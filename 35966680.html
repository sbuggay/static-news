<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1684314057817" as="style"/><link rel="stylesheet" href="styles.css?v=1684314057817"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/robdelacruz/lkwebserver">Show HN: A little web server in C</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>robdelacruz</span> | <span>78 comments</span></div><br/><div><div id="35968598" class="c"><input type="checkbox" id="c-35968598" checked=""/><div class="controls bullet"><span class="by">samtho</span><span>|</span><a href="#35971928">next</a><span>|</span><label class="collapse" for="c-35968598">[-]</label><label class="expand" for="c-35968598">[20 more]</label></div><br/><div class="children"><div class="content">This may sound sort of “old man waves at cloud” of me but one thing I’ve found sad is the gross over-complication of later versions of standards such that the sort of project linked here may not be as practical for something like HTTP&#x2F;3 for example. Similarly, the large, muddled tool chain that is “required” to make modern JavaScript applications makes it hard for newer learners to really understand what is going on because the minimal code version still needs its own transpiler, build system, linter, process managers, etc. Maybe we need all this complexity, but I suspect that some of the overzealous, solve-everything systems design we have come accustomed to is mainly serving to create a larger problem set instead of creating elegant abstractions that are agreed upon.</div><br/><div id="35969212" class="c"><input type="checkbox" id="c-35969212" checked=""/><div class="controls bullet"><span class="by">GuB-42</span><span>|</span><a href="#35968598">parent</a><span>|</span><a href="#35970285">next</a><span>|</span><label class="collapse" for="c-35969212">[-]</label><label class="expand" for="c-35969212">[8 more]</label></div><br/><div class="children"><div class="content">The big thing that makes HTTP&#x2F;2, HTTP&#x2F;3 and even Gemini hard to implement is TLS. I theory, HTTP&#x2F;2 don&#x27;t require it, but in practice, it does.<p>You need to implement a variety of ciphers, manage certificates with expiration dates, etc... And if you wanted to implement all that yourself, people will yell at you for doing your own crypto. So yeah, you need a library. But not just that. You need a way to update your certificates, so you can&#x27;t have a package (or even a single executable) that you can just run and have a server that serves static pages. You could make a self-signed certificate that lasts a thousand years, but good luck getting it accepted.</div><br/><div id="35969785" class="c"><input type="checkbox" id="c-35969785" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#35968598">root</a><span>|</span><a href="#35969212">parent</a><span>|</span><a href="#35971748">next</a><span>|</span><label class="collapse" for="c-35969785">[-]</label><label class="expand" for="c-35969785">[6 more]</label></div><br/><div class="children"><div class="content">Generally speaking, you also need some sort of an operating system to make use of HTTP, and yet that doesn&#x27;t figure into the complexity of HTTP.<p>In classic HTTP TLS was layered beneath it, providing important degrees of freedom, including the freedom to not use TLS, which can be especially important for experimentation and development.<p>Prediction: <i>If</i> HTTP&#x2F;3 manages to substantially replace classic HTTP+TLS, QUIC is destined to become a kernel-provided service like TCP, shunting all that complexity behind an OS abstraction and freeing user space. The fact QUIC uses UDP is an important aspect here because a performant userspace QUIC stack conflicts with classic, high-value abstractions like file descriptors and processes; abstractions which make it viable (i.e. cheap) to have a rich, diverse ecosystem of languages and execution environments in userspace. More importantly, HTTP will have come full circle.</div><br/><div id="35972546" class="c"><input type="checkbox" id="c-35972546" checked=""/><div class="controls bullet"><span class="by">pjc50</span><span>|</span><a href="#35968598">root</a><span>|</span><a href="#35969785">parent</a><span>|</span><a href="#35971369">next</a><span>|</span><label class="collapse" for="c-35972546">[-]</label><label class="expand" for="c-35972546">[1 more]</label></div><br/><div class="children"><div class="content">&gt; QUIC is destined to become a kernel-provided service like TCP<p>I think this might happen in the opposite direction to how you think: the prevalence of containers is likely to thin down the OS layer to just arbitrating the PCIe bus, and you&#x27;ll get monolithic applications that handle all the layers inside themself. So the QUIC layer and the web server and the app-routing and the app itself will all happen inside the same process.</div><br/></div></div><div id="35971369" class="c"><input type="checkbox" id="c-35971369" checked=""/><div class="controls bullet"><span class="by">bongobingo1</span><span>|</span><a href="#35968598">root</a><span>|</span><a href="#35969785">parent</a><span>|</span><a href="#35972546">prev</a><span>|</span><a href="#35971748">next</a><span>|</span><label class="collapse" for="c-35971369">[-]</label><label class="expand" for="c-35971369">[4 more]</label></div><br/><div class="children"><div class="content">&gt; QUIC stack conflicts with classic, high-value abstractions like file descriptors and processes; abstractions which make it viable (i.e. cheap) to have a rich, diverse ecosystem of languages and execution environments in userspace<p>Do you mind expanding on that with a sentence or two?</div><br/><div id="35971635" class="c"><input type="checkbox" id="c-35971635" checked=""/><div class="controls bullet"><span class="by">friendzis</span><span>|</span><a href="#35968598">root</a><span>|</span><a href="#35971369">parent</a><span>|</span><a href="#35971748">next</a><span>|</span><label class="collapse" for="c-35971635">[-]</label><label class="expand" for="c-35971635">[3 more]</label></div><br/><div class="children"><div class="content">UDP is streams in the very classical definition: stream objects (bytes, probably, though a more faithful implementation would contain chunks&#x2F;arrays) go out without predefined start&#x2F;end. In other words, imagine that a single `read()` (or whatever) call returns random chunk from HTML source and it is your job to make sense of where in the space of whole page that chunk comes from. There is even no guarantee that consecutive read will return data &quot;in order&quot;.<p>&quot;File&quot; abstraction layer has predefined start, end, length, order, and so on. You need some buffering magic layer on top of UDP that provides facilities mandated by file abstraction layer.</div><br/><div id="35972474" class="c"><input type="checkbox" id="c-35972474" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#35968598">root</a><span>|</span><a href="#35971635">parent</a><span>|</span><a href="#35971823">next</a><span>|</span><label class="collapse" for="c-35972474">[-]</label><label class="expand" for="c-35972474">[1 more]</label></div><br/><div class="children"><div class="content">&gt; UDP is streams in the very classical definition<p>What do you mean exactly? UDP is not a stream protocol, it is an unreliable datagram one.  A single read will return exactly one UDP datagram.<p>It is TCP where a read will return incremental data which is not necessarily aligned to what the other end wrote.<p>Of course QUIC builds a reliable stream abstraction on top of it, but that&#x27;s not different from TCP.</div><br/></div></div><div id="35971823" class="c"><input type="checkbox" id="c-35971823" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#35968598">root</a><span>|</span><a href="#35971635">parent</a><span>|</span><a href="#35972474">prev</a><span>|</span><a href="#35971748">next</a><span>|</span><label class="collapse" for="c-35971823">[-]</label><label class="expand" for="c-35971823">[1 more]</label></div><br/><div class="children"><div class="content">Worse, a socket read can return a UDP packet from any client as QUIC associates connections using 64-bit identifiers in the UDP payload, not using IP&#x2F;port pairs. Ditto for the fact there can be multiple logical streams per connection. So any user space QUIC stack is responsible for routing packets for any particular connection <i>and</i> logical stream to the correct context using whatever bespoke API the stack provides.<p>IOW, with QUIC a file descriptor no longer represents a particular server&#x2F;client connection, let alone a particular logical stream. From a server perspective, a user space QUIC stack is effectively equivalent to a user space TCP&#x2F;IP stack.
(Relatedly, user space QUIC server stacks are <i>less</i> CPU performant than HTTP stacks using TCP sockets, unless they use something like DPDK to skip the kernel IP stack altogether, avoiding the duplicative processing.)<p>The BSD Sockets API for SCTP (the original, non-UDP encapsulated version) permits 1-to-1 socket descriptors for associations--logical streams within a connection--in addition to an API for 1-to-many--1 socket descriptor representing a connection, over which you can use recvmsg&#x2F;sendmsg to multiplex associations (logical streams). So you have 3 options for using SCTP from user space, from a dead simple, backwards compatible sockets API that matches how TCP&#x2F;IP sockets work, to the low-level QUIC model where user space handles all routing and reassembly. I would expect kernel-based QUIC to work similarly, except combined with kernel-based TLS extensions, which is already a thing for TCP sockets.</div><br/></div></div></div></div></div></div></div></div><div id="35971748" class="c"><input type="checkbox" id="c-35971748" checked=""/><div class="controls bullet"><span class="by">1vuio0pswjnm7</span><span>|</span><a href="#35968598">root</a><span>|</span><a href="#35969212">parent</a><span>|</span><a href="#35969785">prev</a><span>|</span><a href="#35970285">next</a><span>|</span><label class="collapse" for="c-35971748">[-]</label><label class="expand" for="c-35971748">[1 more]</label></div><br/><div class="children"><div class="content">Seems like there are some unspecified assumptions here.  For one, an assumption that TLS is the only game in town.  Another is that &quot;you&quot;, as in &quot;you must do this&quot; or &quot;you must not do that&quot;, applies to every person equally,<p>When one uses TLS today, chances are very good that it&#x27;s using something from djb, someone who &quot;made his own crypto&quot;.  Maybe the assumptions, stated as &quot;rules&quot;, do not apply equally to everyone.  For example,<p>&quot;And if you wanted to implement all that yourself, people will yell at you for doing your own crypto.&quot;<p>In fact, before HTTP&#x2F;2 existed, djb did exactly that, as a demonstration that it could be done.^1  It succeeded IMHO because it worked.  People can &quot;yell&quot; all they want, but as above, these same people if they use TLS are probably using cryptography developed by the person at which they are &quot;yelling&quot;.  Someone who broke the &quot;rules&quot;.  Perhaps there is evidence that HTTP&#x2F;2 would exist even were it not for the prior CurveCP experiment.  But I have yet to find it.<p>The word used in the parent comment was &quot;implement&quot; and the suggestion is that attempts to &quot;implement&quot; would not succeed.  Perhaps the reason they might &quot;fail&quot; is not a technical one.  Perhaps &quot;success&quot; in this instance really refers to acceptance by certain companies that are making &quot;rules&quot; (standards) for the internet to benefit their own commercial interests.  It may be possible to implement a system that works even if these companies do not &quot;accept&quot; it.  If so, then the problem here is the companies, their fanboys&#x2F;fangirls (watch for them in the comment replies), and the undue influence they can exert, not the difficulty of <i>implementing</i> something that works.<p>IMHO, getting something &quot;accepted&quot; by some third party or group of third parties is a different type of &quot;success&quot; that getting something to work (i.e., &quot;implementing&quot;).  It&#x27;s the later I find more interesting.<p>1. <a href="https:&#x2F;&#x2F;curvecp.org" rel="nofollow">https:&#x2F;&#x2F;curvecp.org</a></div><br/></div></div></div></div><div id="35970285" class="c"><input type="checkbox" id="c-35970285" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#35968598">parent</a><span>|</span><a href="#35969212">prev</a><span>|</span><a href="#35972223">next</a><span>|</span><label class="collapse" for="c-35970285">[-]</label><label class="expand" for="c-35970285">[1 more]</label></div><br/><div class="children"><div class="content">i&#x27;m concerned about this too<p>google isn&#x27;t really concerned about creating elegant abstractions so much as they are about improving the performance of their browser talking to their server, though sometimes these do coincide</div><br/></div></div><div id="35972223" class="c"><input type="checkbox" id="c-35972223" checked=""/><div class="controls bullet"><span class="by">treve</span><span>|</span><a href="#35968598">parent</a><span>|</span><a href="#35970285">prev</a><span>|</span><a href="#35972084">next</a><span>|</span><label class="collapse" for="c-35972223">[-]</label><label class="expand" for="c-35972223">[1 more]</label></div><br/><div class="children"><div class="content">I relate to the general concern about complexity creep a lot, but in the HTTP&#x2F;1&#x2F;2&#x2F;3 case I&#x27;m just not terribly worried. So much effort has been put into backwards compatibility. The only potential true new concept that comes to mind is PUSH, which clients can ignore and mostly failed. HTTP&#x2F;2 has been around for almost 10 years and I haven&#x27;t seen a single implementation require it.</div><br/></div></div><div id="35972084" class="c"><input type="checkbox" id="c-35972084" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#35968598">parent</a><span>|</span><a href="#35972223">prev</a><span>|</span><a href="#35969890">next</a><span>|</span><label class="collapse" for="c-35972084">[-]</label><label class="expand" for="c-35972084">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Similarly, the large, muddled tool chain that is “required” to make modern JavaScript applications makes it hard for newer learners to really understand what is going on because the minimal code version still needs its own transpiler, build system, linter, process managers, etc.<p>We built pianojacq.com without all that, just plain vanilla JS and a minimum of dependencies, see: <a href="https:&#x2F;&#x2F;gitlab.com&#x2F;jmattheij&#x2F;pianojacq" rel="nofollow">https:&#x2F;&#x2F;gitlab.com&#x2F;jmattheij&#x2F;pianojacq</a></div><br/></div></div><div id="35969442" class="c"><input type="checkbox" id="c-35969442" checked=""/><div class="controls bullet"><span class="by">sharikone</span><span>|</span><a href="#35968598">parent</a><span>|</span><a href="#35969890">prev</a><span>|</span><a href="#35968652">next</a><span>|</span><label class="collapse" for="c-35969442">[-]</label><label class="expand" for="c-35969442">[1 more]</label></div><br/><div class="children"><div class="content">Some elegant abstractions are created too. JS modules, for example. Or, in another field, the Language Server Protocol.<p>But yes, humans are humans and everything that is &quot;simple&quot; will get built upon and then become the backbone of something complex that will engulf and smother it as it evolves.</div><br/></div></div><div id="35968652" class="c"><input type="checkbox" id="c-35968652" checked=""/><div class="controls bullet"><span class="by">skaushik92</span><span>|</span><a href="#35968598">parent</a><span>|</span><a href="#35969442">prev</a><span>|</span><a href="#35970627">next</a><span>|</span><label class="collapse" for="c-35968652">[-]</label><label class="expand" for="c-35968652">[4 more]</label></div><br/><div class="children"><div class="content">I see what you’re saying and agree that HTTP3 is complicated but I would that since it’s a backwards compatible standard, the added complexities are completely optional. For most use cases the basic protocol is perfectly suitable and only as the scale evolves does it require the additional complexity.</div><br/><div id="35968748" class="c"><input type="checkbox" id="c-35968748" checked=""/><div class="controls bullet"><span class="by">samtho</span><span>|</span><a href="#35968598">root</a><span>|</span><a href="#35968652">parent</a><span>|</span><a href="#35970627">next</a><span>|</span><label class="collapse" for="c-35968748">[-]</label><label class="expand" for="c-35968748">[3 more]</label></div><br/><div class="children"><div class="content">I understand what you’re saying, but if someone decides to post a link to their project that is an HTTP&#x2F;3 server in under X lines of code but only implements HTTP&#x2F;2 features, is it really an HTTP&#x2F;3 web server?</div><br/><div id="35969120" class="c"><input type="checkbox" id="c-35969120" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#35968598">root</a><span>|</span><a href="#35968748">parent</a><span>|</span><a href="#35970627">next</a><span>|</span><label class="collapse" for="c-35969120">[-]</label><label class="expand" for="c-35969120">[2 more]</label></div><br/><div class="children"><div class="content">the HTTP&#x2F;3 standard for servers is not backward compatible with HTTP&#x2F;2 servers, it is backward compatible with HTTP&#x2F;2 <i>clients</i>. And <i>vice versa</i><p>And therefore, an HTTP&#x2F;2 server calling itself compatible with HTTP&#x2F;3 clients is OK</div><br/><div id="35971319" class="c"><input type="checkbox" id="c-35971319" checked=""/><div class="controls bullet"><span class="by">samtho</span><span>|</span><a href="#35968598">root</a><span>|</span><a href="#35969120">parent</a><span>|</span><a href="#35970627">next</a><span>|</span><label class="collapse" for="c-35971319">[-]</label><label class="expand" for="c-35971319">[1 more]</label></div><br/><div class="children"><div class="content">It might be OK on a technical level, but my concern is where someone is showing off a project they used to supposedly learn how to implement HTTP&#x2F;3 but only goes far enough to use an HTTP&#x2F;2 implementation because fully implementing 3 is too complex or not worth it.</div><br/></div></div></div></div></div></div></div></div><div id="35970627" class="c"><input type="checkbox" id="c-35970627" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#35968598">parent</a><span>|</span><a href="#35968652">prev</a><span>|</span><a href="#35971928">next</a><span>|</span><label class="collapse" for="c-35970627">[-]</label><label class="expand" for="c-35970627">[2 more]</label></div><br/><div class="children"><div class="content">It can be simple, or it can be fast.<p>Or it can be neither. But it can&#x27;t be both.<p>If you want fast web at all cost (and you need encryption), you get HTTP3&#x2F;QUIC.</div><br/><div id="35971341" class="c"><input type="checkbox" id="c-35971341" checked=""/><div class="controls bullet"><span class="by">samtho</span><span>|</span><a href="#35968598">root</a><span>|</span><a href="#35970627">parent</a><span>|</span><a href="#35971928">next</a><span>|</span><label class="collapse" for="c-35971341">[-]</label><label class="expand" for="c-35971341">[1 more]</label></div><br/><div class="children"><div class="content">At the end of the day, the question is never one debating simplicity. If you consider the amount of complexity implemented just to even boot into an operating system to run these systems, the lack of simplicity is already a forgone conclusion. The crux of issue is going back to abstractions and my worry is specific to how our abstractions are getting larger and larger and doing more work at even level with very tight coupling rather than creating systems that use more levels as needed.</div><br/></div></div></div></div></div></div><div id="35971928" class="c"><input type="checkbox" id="c-35971928" checked=""/><div class="controls bullet"><span class="by">amadvance</span><span>|</span><a href="#35968598">prev</a><span>|</span><a href="#35968525">next</a><span>|</span><label class="collapse" for="c-35971928">[-]</label><label class="expand" for="c-35971928">[2 more]</label></div><br/><div class="children"><div class="content">Take care that select() is not good for a webserver. From manpage:<p><pre><code>       WARNING: select() can monitor only file descriptors numbers that
       are less than FD_SETSIZE (1024)—an unreasonably low limit for
       many modern applications—and this limitation will not change.
       All modern applications should instead use poll(2) or epoll(7),
       which do not suffer this limitation.</code></pre></div><br/><div id="35972537" class="c"><input type="checkbox" id="c-35972537" checked=""/><div class="controls bullet"><span class="by">pjc50</span><span>|</span><a href="#35971928">parent</a><span>|</span><a href="#35968525">next</a><span>|</span><label class="collapse" for="c-35972537">[-]</label><label class="expand" for="c-35972537">[1 more]</label></div><br/><div class="children"><div class="content">Lol.<p>22 years ago, I worked for Zeus Web Server, which was built entirely around one-process-per-core webserving off select(), and it was so much faster than Apache for serving static content that the developers had built a business out of it. At the time it could saturate a gigabit ethernet link off the largest HP-UX server we could find.<p>Sure, you should use the modern interfaces, but 1024 connections per process can get you surprisingly far.</div><br/></div></div></div></div><div id="35968525" class="c"><input type="checkbox" id="c-35968525" checked=""/><div class="controls bullet"><span class="by">skulk</span><span>|</span><a href="#35971928">prev</a><span>|</span><a href="#35967888">next</a><span>|</span><label class="collapse" for="c-35968525">[-]</label><label class="expand" for="c-35968525">[33 more]</label></div><br/><div class="children"><div class="content">Cool project, but this project demonstrates the reason I&#x27;ve stopped writing things in C. The standard library has garbage string functions and it seems every project has its own version of this file:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;robdelacruz&#x2F;lkwebserver&#x2F;blob&#x2F;main&#x2F;lkstring.c">https:&#x2F;&#x2F;github.com&#x2F;robdelacruz&#x2F;lkwebserver&#x2F;blob&#x2F;main&#x2F;lkstrin...</a><p>It&#x27;s fun to write this (and read others&#x27; versions) the first 3 or 4 times, but it gets old quickly.</div><br/><div id="35969554" class="c"><input type="checkbox" id="c-35969554" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#35968525">parent</a><span>|</span><a href="#35968774">next</a><span>|</span><label class="collapse" for="c-35969554">[-]</label><label class="expand" for="c-35969554">[8 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the &quot;lazy, dumb&quot; way of doing it --- write another string library. A much better way is to design your algorithms so they need a minimum of string manipulation, which is unfortunately on the more difficult side for text-based protocols like HTTP.<p>Personally, I wish HTTP messages were closer to something like ASN.1 DER; there&#x27;s little in the way of string manipulation necessary for those, and all the lengths are prefixes instead of &quot;try to find the terminator&quot; (and don&#x27;t forget to not run past the end of the buffer...)</div><br/><div id="35972555" class="c"><input type="checkbox" id="c-35972555" checked=""/><div class="controls bullet"><span class="by">pjc50</span><span>|</span><a href="#35968525">root</a><span>|</span><a href="#35969554">parent</a><span>|</span><a href="#35969811">next</a><span>|</span><label class="collapse" for="c-35972555">[-]</label><label class="expand" for="c-35972555">[1 more]</label></div><br/><div class="children"><div class="content">&gt; ASN.1 DER<p>This has also had serious security bugs because it&#x27;s so hard to understand.</div><br/></div></div><div id="35969811" class="c"><input type="checkbox" id="c-35969811" checked=""/><div class="controls bullet"><span class="by">jeremyjh</span><span>|</span><a href="#35968525">root</a><span>|</span><a href="#35969554">parent</a><span>|</span><a href="#35972555">prev</a><span>|</span><a href="#35970263">next</a><span>|</span><label class="collapse" for="c-35969811">[-]</label><label class="expand" for="c-35969811">[4 more]</label></div><br/><div class="children"><div class="content">Peak HN right here folks. Pack it in we are done.</div><br/><div id="35970054" class="c"><input type="checkbox" id="c-35970054" checked=""/><div class="controls bullet"><span class="by">favorited</span><span>|</span><a href="#35968525">root</a><span>|</span><a href="#35969811">parent</a><span>|</span><a href="#35970263">next</a><span>|</span><label class="collapse" for="c-35970054">[-]</label><label class="expand" for="c-35970054">[3 more]</label></div><br/><div class="children"><div class="content">Impossible– no part of the thread has involved someone suggesting rewriting it in Rust, which means there&#x27;s no opportunity for someone else to reply &quot;This project seems like a perfect fit for golang, why would you suggest they use Rust instead?&quot;</div><br/><div id="35970840" class="c"><input type="checkbox" id="c-35970840" checked=""/><div class="controls bullet"><span class="by">earthboundkid</span><span>|</span><a href="#35968525">root</a><span>|</span><a href="#35970054">parent</a><span>|</span><a href="#35970263">next</a><span>|</span><label class="collapse" for="c-35970840">[-]</label><label class="expand" for="c-35970840">[2 more]</label></div><br/><div class="children"><div class="content">I could write this thread in an afternoon.</div><br/><div id="35971474" class="c"><input type="checkbox" id="c-35971474" checked=""/><div class="controls bullet"><span class="by">tomcam</span><span>|</span><a href="#35968525">root</a><span>|</span><a href="#35970840">parent</a><span>|</span><a href="#35970263">next</a><span>|</span><label class="collapse" for="c-35971474">[-]</label><label class="expand" for="c-35971474">[1 more]</label></div><br/><div class="children"><div class="content">Deep cut! For newer HN users, that&#x27;s a reference to this comment responding to the original DropBox announcement. <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=17732980" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=17732980</a></div><br/></div></div></div></div></div></div></div></div><div id="35970263" class="c"><input type="checkbox" id="c-35970263" checked=""/><div class="controls bullet"><span class="by">jerrysievert</span><span>|</span><a href="#35968525">root</a><span>|</span><a href="#35969554">parent</a><span>|</span><a href="#35969811">prev</a><span>|</span><a href="#35968774">next</a><span>|</span><label class="collapse" for="c-35970263">[-]</label><label class="expand" for="c-35970263">[2 more]</label></div><br/><div class="children"><div class="content">or just parse in place: <a href="https:&#x2F;&#x2F;github.com&#x2F;celcius-labs&#x2F;tiny-http&#x2F;blob&#x2F;master&#x2F;src&#x2F;http_request.cpp">https:&#x2F;&#x2F;github.com&#x2F;celcius-labs&#x2F;tiny-http&#x2F;blob&#x2F;master&#x2F;src&#x2F;ht...</a></div><br/></div></div></div></div><div id="35968774" class="c"><input type="checkbox" id="c-35968774" checked=""/><div class="controls bullet"><span class="by">xmonkee</span><span>|</span><a href="#35968525">parent</a><span>|</span><a href="#35969554">prev</a><span>|</span><a href="#35968970">next</a><span>|</span><label class="collapse" for="c-35968774">[-]</label><label class="expand" for="c-35968774">[3 more]</label></div><br/><div class="children"><div class="content">I have the same issue, but I blame the absence of good package management. If it had that, one of the thousands of these libraries would have won out and become quasi-standard.</div><br/><div id="35968896" class="c"><input type="checkbox" id="c-35968896" checked=""/><div class="controls bullet"><span class="by">le-mark</span><span>|</span><a href="#35968525">root</a><span>|</span><a href="#35968774">parent</a><span>|</span><a href="#35968970">next</a><span>|</span><label class="collapse" for="c-35968896">[-]</label><label class="expand" for="c-35968896">[2 more]</label></div><br/><div class="children"><div class="content">I always thought the glib part of gtk was really nice for this, but adoption is spotty at best.</div><br/><div id="35969290" class="c"><input type="checkbox" id="c-35969290" checked=""/><div class="controls bullet"><span class="by">ranger_danger</span><span>|</span><a href="#35968525">root</a><span>|</span><a href="#35968896">parent</a><span>|</span><a href="#35968970">next</a><span>|</span><label class="collapse" for="c-35969290">[-]</label><label class="expand" for="c-35969290">[1 more]</label></div><br/><div class="children"><div class="content">glib is a massive dependency just for this, and I think many would argue that gtk in general is not a good idea for painless cross-platform development in 2023.</div><br/></div></div></div></div></div></div><div id="35968970" class="c"><input type="checkbox" id="c-35968970" checked=""/><div class="controls bullet"><span class="by">dajtxx</span><span>|</span><a href="#35968525">parent</a><span>|</span><a href="#35968774">prev</a><span>|</span><a href="#35968944">next</a><span>|</span><label class="collapse" for="c-35968970">[-]</label><label class="expand" for="c-35968970">[3 more]</label></div><br/><div class="children"><div class="content">I know it&#x27;s not your code, but related to this comment, it looks like it missing a check for lks == null?<p><a href="https:&#x2F;&#x2F;github.com&#x2F;robdelacruz&#x2F;lkwebserver&#x2F;blob&#x2F;main&#x2F;lkstring.c#L47">https:&#x2F;&#x2F;github.com&#x2F;robdelacruz&#x2F;lkwebserver&#x2F;blob&#x2F;main&#x2F;lkstrin...</a></div><br/><div id="35969580" class="c"><input type="checkbox" id="c-35969580" checked=""/><div class="controls bullet"><span class="by">denotational</span><span>|</span><a href="#35968525">root</a><span>|</span><a href="#35968970">parent</a><span>|</span><a href="#35968944">next</a><span>|</span><label class="collapse" for="c-35969580">[-]</label><label class="expand" for="c-35969580">[2 more]</label></div><br/><div class="children"><div class="content">That assert is checking a library invariant; it should never fail unless there’s a bug in the string library itself (although I’m not entirely sure this string library would tolerate a malloc failure from a quick glance through).<p>This is distinct from checking the parameters; if lks is null then the user of the API has made an error. Some libraries may sanitise user parameters, others don’t. At any rate, an assert would be the wrong choice to check user parameters since this would result in a (recoverable) user error leading to an abort unless the assert is disabled at compile time (-DNDEBUG), returning an error would be a better choice.</div><br/><div id="35972566" class="c"><input type="checkbox" id="c-35972566" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#35968525">root</a><span>|</span><a href="#35969580">parent</a><span>|</span><a href="#35968944">next</a><span>|</span><label class="collapse" for="c-35972566">[-]</label><label class="expand" for="c-35972566">[1 more]</label></div><br/><div class="children"><div class="content">assert is an acceptable way to deal with precondition failures.</div><br/></div></div></div></div></div></div><div id="35968944" class="c"><input type="checkbox" id="c-35968944" checked=""/><div class="controls bullet"><span class="by">alex_lav</span><span>|</span><a href="#35968525">parent</a><span>|</span><a href="#35968970">prev</a><span>|</span><a href="#35969577">next</a><span>|</span><label class="collapse" for="c-35968944">[-]</label><label class="expand" for="c-35968944">[17 more]</label></div><br/><div class="children"><div class="content">This is how I felt writing Go. Writing the same nongeneric functions with slightly different type signatures and&#x2F;or endless interfaces and&#x2F;or interface{} signatures. It&#x27;s 2023.</div><br/><div id="35970846" class="c"><input type="checkbox" id="c-35970846" checked=""/><div class="controls bullet"><span class="by">earthboundkid</span><span>|</span><a href="#35968525">root</a><span>|</span><a href="#35968944">parent</a><span>|</span><a href="#35969088">next</a><span>|</span><label class="collapse" for="c-35970846">[-]</label><label class="expand" for="c-35970846">[2 more]</label></div><br/><div class="children"><div class="content">You know Go has had generics for the last 15 months, right?</div><br/><div id="35971013" class="c"><input type="checkbox" id="c-35971013" checked=""/><div class="controls bullet"><span class="by">alex_lav</span><span>|</span><a href="#35968525">root</a><span>|</span><a href="#35970846">parent</a><span>|</span><a href="#35969088">next</a><span>|</span><label class="collapse" for="c-35971013">[-]</label><label class="expand" for="c-35971013">[1 more]</label></div><br/><div class="children"><div class="content">Yep! Why?</div><br/></div></div></div></div><div id="35969088" class="c"><input type="checkbox" id="c-35969088" checked=""/><div class="controls bullet"><span class="by">2h</span><span>|</span><a href="#35968525">root</a><span>|</span><a href="#35968944">parent</a><span>|</span><a href="#35970846">prev</a><span>|</span><a href="#35969577">next</a><span>|</span><label class="collapse" for="c-35969088">[-]</label><label class="expand" for="c-35969088">[14 more]</label></div><br/><div class="children"><div class="content">never mind than MANY people dont need generics, and that generics have a significant compilation and runtime cost, in terms of time and memory. who cares right?<p>and never mind that Go has had generics for over a year now right? sometimes having a small, stripped down language is better than having a huge bloated monster. I would point to examples, but you know what they are.</div><br/><div id="35970004" class="c"><input type="checkbox" id="c-35970004" checked=""/><div class="controls bullet"><span class="by">kerkeslager</span><span>|</span><a href="#35968525">root</a><span>|</span><a href="#35969088">parent</a><span>|</span><a href="#35969156">next</a><span>|</span><label class="collapse" for="c-35970004">[-]</label><label class="expand" for="c-35970004">[3 more]</label></div><br/><div class="children"><div class="content">The Gopher narrative timeline as I remember it was:<p>1. Generics are bloated and don&#x27;t allow us to have a single-pass compiler, which we need.<p>2. You don&#x27;t need generics because go generate covers all the cases that generics cover (please ignore that this is a second pass).<p>3. Go has generics!</div><br/><div id="35971949" class="c"><input type="checkbox" id="c-35971949" checked=""/><div class="controls bullet"><span class="by">doctor_eval</span><span>|</span><a href="#35968525">root</a><span>|</span><a href="#35970004">parent</a><span>|</span><a href="#35971139">next</a><span>|</span><label class="collapse" for="c-35971949">[-]</label><label class="expand" for="c-35971949">[1 more]</label></div><br/><div class="children"><div class="content">My recollection of the timeline is a bit different:<p>1. The current proposals for generics are bloated and don&#x27;t fit properly with our vision for Go.<p>2. We will do heaps and heaps of work over many years until we get something we like.<p>3. Go has generics!<p>Also, AFAIK Go is not a single-pass compiler, at least not in the way I learned about compilers.</div><br/></div></div><div id="35971139" class="c"><input type="checkbox" id="c-35971139" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#35968525">root</a><span>|</span><a href="#35970004">parent</a><span>|</span><a href="#35971949">prev</a><span>|</span><a href="#35969156">next</a><span>|</span><label class="collapse" for="c-35971139">[-]</label><label class="expand" for="c-35971139">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, for years C++ said they didn&#x27;t need sealed&#x2F;final classes.  Then they finally added it.  Similar &quot;re-editing&quot; of history was done.<p>When new C++ standard libraries are written, there is now active, public effort to review what exists in other languages.  Finally.</div><br/></div></div></div></div><div id="35969156" class="c"><input type="checkbox" id="c-35969156" checked=""/><div class="controls bullet"><span class="by">vore</span><span>|</span><a href="#35968525">root</a><span>|</span><a href="#35969088">parent</a><span>|</span><a href="#35970004">prev</a><span>|</span><a href="#35969567">next</a><span>|</span><label class="collapse" for="c-35969156">[-]</label><label class="expand" for="c-35969156">[7 more]</label></div><br/><div class="children"><div class="content">Many people don&#x27;t need generics? Significant runtime cost? I would argue that everyone should be using type-safe collections like maps, lists, etc. (I know these are built into the language in Go, but they&#x27;re basically special-cased generics). And, if anything, not having generics has more cost because you end up boxing your values to place into collections rather than letting the compiler monomorphize it. The compilation cost can be more expensive, yes, but it saves a lot of work you would be doing by hand.<p>While Go has had generics for a while now, the vast swath of existing Go code doesn&#x27;t. The situation is definitely improving but there is still a lot of non-generic legacy cruft.</div><br/><div id="35969231" class="c"><input type="checkbox" id="c-35969231" checked=""/><div class="controls bullet"><span class="by">2h</span><span>|</span><a href="#35968525">root</a><span>|</span><a href="#35969156">parent</a><span>|</span><a href="#35969567">next</a><span>|</span><label class="collapse" for="c-35969231">[-]</label><label class="expand" for="c-35969231">[6 more]</label></div><br/><div class="children"><div class="content">&gt; you end up boxing your values to place into collections rather than letting the compiler monomorphize it.<p>you know that Go has interfaces right? and I dont just mean the &quot;any&quot; interface. you can write your own interface similar to io.Reader and others, then add types that implement that interface, then no type matching is needed.<p>&gt; non-generic legacy cruft<p>AKA normal, fine code. generic code is not some magic pixie dust that makes bad code into good code. plenty of awful bloated slow generic code around as well.</div><br/><div id="35969416" class="c"><input type="checkbox" id="c-35969416" checked=""/><div class="controls bullet"><span class="by">vore</span><span>|</span><a href="#35968525">root</a><span>|</span><a href="#35969231">parent</a><span>|</span><a href="#35969348">next</a><span>|</span><label class="collapse" for="c-35969416">[-]</label><label class="expand" for="c-35969416">[4 more]</label></div><br/><div class="children"><div class="content">If you are using interfaces, the value is necessarily boxed as the storage for the value may be heterogeneous. Once a value is typed as e.g. `io.Reader`, dispatching to its methods necessarily requires a vtable lookup (i.e. runtime cost!). Compare this to parametric polymorphism where you can avoid the type erasure and perform static dispatch at compile time. Though, unfortunately, Go&#x27;s implementation of generics (&quot;GC shape with stenciling&quot; instead of full monomorphization) still ends up incurring some runtime cost.<p>With regards to your second point, there are definitely situations where generics are vastly preferred: type-safe collections being a big one. For instance, the standard library containers (<a href="https:&#x2F;&#x2F;pkg.go.dev&#x2F;container" rel="nofollow">https:&#x2F;&#x2F;pkg.go.dev&#x2F;container</a>) are still non-generic with no generic versions in the standard library yet. This is the kind of cruft I mean: generic collections can be turned into concrete collections with type safety, but not the other way around. I make no claims about use of generics making your code being absolutely good or bad, but I do make claims that use of generics can make your code less error-prone and more safe.</div><br/><div id="35969598" class="c"><input type="checkbox" id="c-35969598" checked=""/><div class="controls bullet"><span class="by">svnpenn</span><span>|</span><a href="#35968525">root</a><span>|</span><a href="#35969416">parent</a><span>|</span><a href="#35969348">next</a><span>|</span><label class="collapse" for="c-35969598">[-]</label><label class="expand" for="c-35969598">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I make no claims about use of generics making your code being absolutely good or bad, but I do make claims that use of generics can make your code less error-prone and safe.<p>Right. this is the issue right here. people only see that Go didn&#x27;t have generics, and they never stop for a second to think WHY Go didn&#x27;t have them. Generics have an implementation cost for the Go project, and maintenance cost for the Go project, and end user negative impacts in regards to time and memory. but advocates often dont know or care about these drawback, and only howl that GENERICS ARE MISSING until they are added, consequences be damned.<p>I&#x27;m just saying that while generics are useful in some cases, they are not always the right answer, and it shouldn&#x27;t just be assumed that every language needs them, nor that any non-generic language &quot;sucks&quot;.</div><br/><div id="35970218" class="c"><input type="checkbox" id="c-35970218" checked=""/><div class="controls bullet"><span class="by">brickteacup</span><span>|</span><a href="#35968525">root</a><span>|</span><a href="#35969598">parent</a><span>|</span><a href="#35969665">next</a><span>|</span><label class="collapse" for="c-35970218">[-]</label><label class="expand" for="c-35970218">[1 more]</label></div><br/><div class="children"><div class="content">&gt; stop for a second to think WHY Go didn&#x27;t have them<p>I have thought about this. I concluded that Go doesn&#x27;t have generics because it&#x27;s a poorly designed language whose designers elected to ignore decades of progress in programming language design for... reasons. Hence why you have to do the moral equivalent of passing around void pointers and checking return codes in $current_year</div><br/></div></div><div id="35969665" class="c"><input type="checkbox" id="c-35969665" checked=""/><div class="controls bullet"><span class="by">alex_lav</span><span>|</span><a href="#35968525">root</a><span>|</span><a href="#35969598">parent</a><span>|</span><a href="#35970218">prev</a><span>|</span><a href="#35969348">next</a><span>|</span><label class="collapse" for="c-35969665">[-]</label><label class="expand" for="c-35969665">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m just saying that while generics are useful in some cases, they are not always the right answer, and it shouldn&#x27;t just be assumed that every language needs them, nor that any non-generic language &quot;sucks&quot;.<p>It&#x27;s funny to me, because this comment chain exists because I said I got tired of rewriting the same functions with minute changes, the exact problem generics is intended to solve. I didn&#x27;t say anything sucked, or even that I didn&#x27;t like Go, just that this one aspect got tiring.<p>And yet, this small comment lead into a person feeling their language was being attacked.</div><br/></div></div></div></div></div></div><div id="35969348" class="c"><input type="checkbox" id="c-35969348" checked=""/><div class="controls bullet"><span class="by">emodendroket</span><span>|</span><a href="#35968525">root</a><span>|</span><a href="#35969231">parent</a><span>|</span><a href="#35969416">prev</a><span>|</span><a href="#35969567">next</a><span>|</span><label class="collapse" for="c-35969348">[-]</label><label class="expand" for="c-35969348">[1 more]</label></div><br/><div class="children"><div class="content">What kind of argument is this? Nobody says it’s “magical pixie dust that makes bad code into good code.” It’s a way to avoid writing repetitive code over and over and the runtime cost can be insignificant depending on implementation.</div><br/></div></div></div></div></div></div><div id="35969567" class="c"><input type="checkbox" id="c-35969567" checked=""/><div class="controls bullet"><span class="by">alex_lav</span><span>|</span><a href="#35968525">root</a><span>|</span><a href="#35969088">parent</a><span>|</span><a href="#35969156">prev</a><span>|</span><a href="#35969577">next</a><span>|</span><label class="collapse" for="c-35969567">[-]</label><label class="expand" for="c-35969567">[3 more]</label></div><br/><div class="children"><div class="content">&gt;  never mind than MANY people dont need generics, and that generics have a significant compilation and runtime cost, in terms of time and memory. who cares right?<p>I&#x27;m saying that I wanted them...? I didn&#x27;t say need. I was able to operate without them. I simply _wanted_ them.<p>Also maybe consider the way you&#x27;re communicating? I didn&#x27;t say Go was wrong. I said I didn&#x27;t enjoy it. I&#x27;m allowed to not like things, and I&#x27;m allowed to post about them.<p>_Also_ this concept of &quot;need&quot; is amusing to me. You don&#x27;t _need_ a garbage collector, or a statically linked binary, or static typing, or IDE support, or a debugger, or, or ,or.<p>And yet, people _want_ them.<p>&gt; and never mind that Go has had generics for over a year now right?<p>Their generics implementation is pretty bad IME. Interfaces lacking type parameters seems pretty untenable to me. I&#x27;d rather just not use them.<p>&gt; sometimes having a small, stripped down language<p>Of all the things Go is, I wouldn&#x27;t say its either of these.<p>But also, if you respond, please try to not be so defensive. You can like Go, that is a valid thing to do.</div><br/><div id="35971171" class="c"><input type="checkbox" id="c-35971171" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#35968525">root</a><span>|</span><a href="#35969567">parent</a><span>|</span><a href="#35970110">next</a><span>|</span><label class="collapse" for="c-35971171">[-]</label><label class="expand" for="c-35971171">[1 more]</label></div><br/><div class="children"><div class="content">Very good points about need vs want.  Every time I hear a response to a reasonable software request at work with, &quot;Well, do you really need it?&quot;. I pat my left leg.  It&#x27;s a good leg; I like it; Very helpful, but, sadly not strictly <i>necessary</i>.</div><br/></div></div><div id="35970110" class="c"><input type="checkbox" id="c-35970110" checked=""/><div class="controls bullet"><span class="by">mst</span><span>|</span><a href="#35968525">root</a><span>|</span><a href="#35969567">parent</a><span>|</span><a href="#35971171">prev</a><span>|</span><a href="#35969577">next</a><span>|</span><label class="collapse" for="c-35970110">[-]</label><label class="expand" for="c-35970110">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s still on my &quot;I keep meaning to play with this&quot; list because I keep getting distracted by other shiny things but you might find gomacro interesting.</div><br/></div></div></div></div></div></div></div></div><div id="35969577" class="c"><input type="checkbox" id="c-35969577" checked=""/><div class="controls bullet"><span class="by">krapp</span><span>|</span><a href="#35968525">parent</a><span>|</span><a href="#35968944">prev</a><span>|</span><a href="#35967888">next</a><span>|</span><label class="collapse" for="c-35969577">[-]</label><label class="expand" for="c-35969577">[1 more]</label></div><br/><div class="children"><div class="content">&gt;It&#x27;s fun to write this (and read others&#x27; versions) the first 3 or 4 times, but it gets old quickly.<p>I mean, you can always just use an existing string library or reuse your own. There&#x27;s no reason to rewrite string operations for every project.</div><br/></div></div></div></div><div id="35967888" class="c"><input type="checkbox" id="c-35967888" checked=""/><div class="controls bullet"><span class="by">rahmeero</span><span>|</span><a href="#35968525">prev</a><span>|</span><a href="#35970317">next</a><span>|</span><label class="collapse" for="c-35967888">[-]</label><label class="expand" for="c-35967888">[1 more]</label></div><br/><div class="children"><div class="content">Interesting. Would be good to get more info, beyond having to read the code.<p>Curious to know how it compares to micro_httpd [1] which is about 200 lines of C. Or others like thttpd and tiny_httpd.<p>[1] <a href="https:&#x2F;&#x2F;acme.com&#x2F;software&#x2F;thttpd&#x2F;benchmarks.html" rel="nofollow">https:&#x2F;&#x2F;acme.com&#x2F;software&#x2F;thttpd&#x2F;benchmarks.html</a></div><br/></div></div><div id="35970317" class="c"><input type="checkbox" id="c-35970317" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#35967888">prev</a><span>|</span><a href="#35969523">next</a><span>|</span><label class="collapse" for="c-35970317">[-]</label><label class="expand" for="c-35970317">[2 more]</label></div><br/><div class="children"><div class="content">if you like this, you might like httpdito<p><a href="http:&#x2F;&#x2F;canonical.org&#x2F;~kragen&#x2F;sw&#x2F;dev3&#x2F;httpdito-readme" rel="nofollow">http:&#x2F;&#x2F;canonical.org&#x2F;~kragen&#x2F;sw&#x2F;dev3&#x2F;httpdito-readme</a><p><a href="http:&#x2F;&#x2F;canonical.org&#x2F;~kragen&#x2F;sw&#x2F;dev3&#x2F;server.s" rel="nofollow">http:&#x2F;&#x2F;canonical.org&#x2F;~kragen&#x2F;sw&#x2F;dev3&#x2F;server.s</a><p>it&#x27;s a 2-kilobyte executable written in i386 assembly that can handle 20000 requests per second on my laptop, but only serves up files from the filesystem; no cgi or reverse proxy<p>instead of being single-threaded or preforking it just forks a child per request</div><br/><div id="35971930" class="c"><input type="checkbox" id="c-35971930" checked=""/><div class="controls bullet"><span class="by">jaza</span><span>|</span><a href="#35970317">parent</a><span>|</span><a href="#35969523">next</a><span>|</span><label class="collapse" for="c-35971930">[-]</label><label class="expand" for="c-35971930">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you don’t do that part, it will be over 4kB instead of under 2kB. If you really care about that, you’re probably insane.<p>Love it!</div><br/></div></div></div></div><div id="35969523" class="c"><input type="checkbox" id="c-35969523" checked=""/><div class="controls bullet"><span class="by">davidw</span><span>|</span><a href="#35970317">prev</a><span>|</span><a href="#35968308">next</a><span>|</span><label class="collapse" for="c-35969523">[-]</label><label class="expand" for="c-35969523">[2 more]</label></div><br/><div class="children"><div class="content">For fun, does anyone have something like this in Rust? Curious about that language and this sort of thing would be fun to look at.</div><br/><div id="35970489" class="c"><input type="checkbox" id="c-35970489" checked=""/><div class="controls bullet"><span class="by">imran-iq</span><span>|</span><a href="#35969523">parent</a><span>|</span><a href="#35968308">next</a><span>|</span><label class="collapse" for="c-35970489">[-]</label><label class="expand" for="c-35970489">[1 more]</label></div><br/><div class="children"><div class="content">Isnt it in the book? <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;book&#x2F;ch20-01-single-threaded.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;book&#x2F;ch20-01-single-threade...</a></div><br/></div></div></div></div><div id="35968308" class="c"><input type="checkbox" id="c-35968308" checked=""/><div class="controls bullet"><span class="by">sgloutnikov</span><span>|</span><a href="#35969523">prev</a><span>|</span><a href="#35969911">next</a><span>|</span><label class="collapse" for="c-35968308">[-]</label><label class="expand" for="c-35968308">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s also althttpd [0]. Heard Richard Hipp mention it and fossil in an interview.<p>[0] <a href="https:&#x2F;&#x2F;sqlite.org&#x2F;althttpd&#x2F;doc&#x2F;trunk&#x2F;althttpd.md" rel="nofollow">https:&#x2F;&#x2F;sqlite.org&#x2F;althttpd&#x2F;doc&#x2F;trunk&#x2F;althttpd.md</a></div><br/></div></div><div id="35969911" class="c"><input type="checkbox" id="c-35969911" checked=""/><div class="controls bullet"><span class="by">password4321</span><span>|</span><a href="#35968308">prev</a><span>|</span><a href="#35968493">next</a><span>|</span><label class="collapse" for="c-35969911">[-]</label><label class="expand" for="c-35969911">[1 more]</label></div><br/><div class="children"><div class="content">I use dufs when I need a webserver for minor things, and reverse proxy to it through Caddy if things get serious enough to need an SSL certificate.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;sigoden&#x2F;dufs">https:&#x2F;&#x2F;github.com&#x2F;sigoden&#x2F;dufs</a></div><br/></div></div><div id="35968493" class="c"><input type="checkbox" id="c-35968493" checked=""/><div class="controls bullet"><span class="by">qwertywert_</span><span>|</span><a href="#35969911">prev</a><span>|</span><a href="#35968305">next</a><span>|</span><label class="collapse" for="c-35968493">[-]</label><label class="expand" for="c-35968493">[1 more]</label></div><br/><div class="children"><div class="content">The amount of written functions&#x2F;libs for opening c sockets has to be in the 100,000s at this point. And they are all slightly different.</div><br/></div></div><div id="35968305" class="c"><input type="checkbox" id="c-35968305" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#35968493">prev</a><span>|</span><a href="#35969305">next</a><span>|</span><label class="collapse" for="c-35968305">[-]</label><label class="expand" for="c-35968305">[1 more]</label></div><br/><div class="children"><div class="content">Shameless plug for when I attempted something similar, though multithreaded with pthreads: <a href="https:&#x2F;&#x2F;github.com&#x2F;lionkor&#x2F;http">https:&#x2F;&#x2F;github.com&#x2F;lionkor&#x2F;http</a></div><br/></div></div><div id="35969305" class="c"><input type="checkbox" id="c-35969305" checked=""/><div class="controls bullet"><span class="by">leetrout</span><span>|</span><a href="#35968305">prev</a><span>|</span><a href="#35968249">next</a><span>|</span><label class="collapse" for="c-35969305">[-]</label><label class="expand" for="c-35969305">[1 more]</label></div><br/><div class="children"><div class="content">Reminded me of a small C webserver: G-WAN<p><a href="http:&#x2F;&#x2F;gwan.com&#x2F;" rel="nofollow">http:&#x2F;&#x2F;gwan.com&#x2F;</a></div><br/></div></div><div id="35968249" class="c"><input type="checkbox" id="c-35968249" checked=""/><div class="controls bullet"><span class="by">forgotmypw17</span><span>|</span><a href="#35969305">prev</a><span>|</span><a href="#35969160">next</a><span>|</span><label class="collapse" for="c-35968249">[-]</label><label class="expand" for="c-35968249">[1 more]</label></div><br/><div class="children"><div class="content">Thank you so much for sharing this!<p>This is exactly the type of web server I&#x27;m looking for my project.</div><br/></div></div><div id="35969160" class="c"><input type="checkbox" id="c-35969160" checked=""/><div class="controls bullet"><span class="by">adamrezich</span><span>|</span><a href="#35968249">prev</a><span>|</span><a href="#35968256">next</a><span>|</span><label class="collapse" for="c-35969160">[-]</label><label class="expand" for="c-35969160">[6 more]</label></div><br/><div class="children"><div class="content">this is a great opportunity to ask something I&#x27;ve been wondering about for awhile:<p>what are the best options out there for hosting websites built as HTTP-serving executables (either Windows or Linux)? is it possible to do this relatively cheaply?<p>I ask because I&#x27;ve been working on a framework[0] for building websites in a compiled language recently, and while it&#x27;s been a ton of fun to build and test locally as a hobby project, I have absolutely no idea if it&#x27;s even remotely financially viable to host a (small- to medium-sized) website made this way, compared to all of the managed hosting solutions out there for PHP&#x2F;Node&#x2F;etc.<p>I don&#x27;t want&#x2F;need to pay for a whole dedicated server—I just want to serve HTTP (eventually HTTPS) from a single executable, using one or more SQLite database files. ideally, it would cost as close to your typical shared PHP host as possible.<p>I have almost zero experience with &quot;cloud&quot; hosting—I made a small game with Node on Azure years ago, and accidentally racked up charges just playing around with it in development—so I don&#x27;t know if this, or AWS, or whatever else is a viable solution for this. I&#x27;ve seen that it is indeed possible to host a single executable on Azure, but I haven&#x27;t actually tried it myself, or determined what the pricing for this would end up being.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;rezich&#x2F;Newf">https:&#x2F;&#x2F;github.com&#x2F;rezich&#x2F;Newf</a></div><br/><div id="35972414" class="c"><input type="checkbox" id="c-35972414" checked=""/><div class="controls bullet"><span class="by">robdelacruz</span><span>|</span><a href="#35969160">parent</a><span>|</span><a href="#35971552">next</a><span>|</span><label class="collapse" for="c-35972414">[-]</label><label class="expand" for="c-35972414">[1 more]</label></div><br/><div class="children"><div class="content">This site has a good tutorial for this. It recommends vultr (which is what I use), for $2.50 - $5 a month.<p><a href="https:&#x2F;&#x2F;landchad.net&#x2F;" rel="nofollow">https:&#x2F;&#x2F;landchad.net&#x2F;</a></div><br/></div></div><div id="35971552" class="c"><input type="checkbox" id="c-35971552" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#35969160">parent</a><span>|</span><a href="#35972414">prev</a><span>|</span><a href="#35971584">next</a><span>|</span><label class="collapse" for="c-35971552">[-]</label><label class="expand" for="c-35971552">[1 more]</label></div><br/><div class="children"><div class="content">Maybe look at container hosting with your (statically linked) binary being the only thing in the container?<p>Otherwise, why not just get a cheap VPS and host the binary there? I’ve used Vultr and it’s $3.50&#x2F;month all-in, at the low end. There are even cheaper providers, although I don’t know about their quality. I bet this option would be the cheapest.<p>This is the beauty of a single binary—it’s trivial to deploy!</div><br/></div></div><div id="35971584" class="c"><input type="checkbox" id="c-35971584" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#35969160">parent</a><span>|</span><a href="#35971552">prev</a><span>|</span><a href="#35969366">next</a><span>|</span><label class="collapse" for="c-35971584">[-]</label><label class="expand" for="c-35971584">[1 more]</label></div><br/><div class="children"><div class="content">Cheap VPS. I run multiple things on a single cheap digital ocean droplet.<p>Multiple websites served by golang written server, some static sites, also gitea and Jenkins.</div><br/></div></div><div id="35969366" class="c"><input type="checkbox" id="c-35969366" checked=""/><div class="controls bullet"><span class="by">torstenvl</span><span>|</span><a href="#35969160">parent</a><span>|</span><a href="#35971584">prev</a><span>|</span><a href="#35969545">next</a><span>|</span><label class="collapse" for="c-35969366">[-]</label><label class="expand" for="c-35969366">[1 more]</label></div><br/><div class="children"><div class="content">Not exactly what you&#x27;re looking for, but I&#x27;d use lighttpd and a CGI program.</div><br/></div></div><div id="35969545" class="c"><input type="checkbox" id="c-35969545" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#35969160">parent</a><span>|</span><a href="#35969366">prev</a><span>|</span><a href="#35968256">next</a><span>|</span><label class="collapse" for="c-35969545">[-]</label><label class="expand" for="c-35969545">[1 more]</label></div><br/><div class="children"><div class="content">For AWS simplest thing is to throw it into docker container (`FROM scratch` can work) and run in Fargate (AWS&#x27; container runtime). But its not super-cheap solution; baseline cost is something like $20&#x2F;mo for Fargate and additional $20&#x2F;mo for load-balancer. Lambda can work too, but it is in some ways bit more involved.<p>Cheapest AWS solution would be just EC2 instances (=basic virtual machines). t3a.nano instances cost just $3.5&#x2F;mo and do not require additional load-balancers.<p>The modern cloudy approach would be to look into stuff like CloudFlare Workers, iirc they can run WASM, so if you manage to compile your code to that then it might work.</div><br/></div></div></div></div></div></div></div></div></div></body></html>