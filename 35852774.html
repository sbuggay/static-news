<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1683536457102" as="style"/><link rel="stylesheet" href="styles.css?v=1683536457102"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://wickedengine.net/2023/05/07/vulkan-video-decoding/">Vulkan Video Decoding</a> <span class="domain">(<a href="https://wickedengine.net">wickedengine.net</a>)</span></div><div class="subtext"><span>ibobev</span> | <span>15 comments</span></div><br/><div><div id="35859189" class="c"><input type="checkbox" id="c-35859189" checked=""/><div class="controls bullet"><span class="by">CrampusDestrus</span><span>|</span><a href="#35857364">next</a><span>|</span><label class="collapse" for="c-35859189">[-]</label><label class="expand" for="c-35859189">[3 more]</label></div><br/><div class="children"><div class="content">Correct me if I&#x27;m wrong: when we decode a video we either use software decoding via the cpu or we let a specialized hardware module (usually inside a gpu) handle the decoding in an efficient way. Using Vulkan to decode video basically means writing a decoder in a special way as to accelerate it using the gpu instead of the cpu, which makes it more efficient and faster than cpu decoding and allows older gpus to decode newer formats. Of course it will always be slower and less efficient than the hardware accelerated module but it is more flexible and can actually be updated</div><br/><div id="35859217" class="c"><input type="checkbox" id="c-35859217" checked=""/><div class="controls bullet"><span class="by">TazeTSchnitzel</span><span>|</span><a href="#35859189">parent</a><span>|</span><a href="#35859205">next</a><span>|</span><label class="collapse" for="c-35859217">[-]</label><label class="expand" for="c-35859217">[1 more]</label></div><br/><div class="children"><div class="content">Vulkan is primarily a GPU API, but it relatively recently gained a hardware-accelerated video API called Vulkan Video, which is the topic of this post. That it&#x27;s part of Vulkan is perhaps because video decoders are often bundled with GPUs, though that&#x27;s not always the case and I believe Vulkan Video can be implemented also where it&#x27;s separate from the GPU (common on mobile).</div><br/></div></div><div id="35859205" class="c"><input type="checkbox" id="c-35859205" checked=""/><div class="controls bullet"><span class="by">galad87</span><span>|</span><a href="#35859189">parent</a><span>|</span><a href="#35859217">prev</a><span>|</span><a href="#35857364">next</a><span>|</span><label class="collapse" for="c-35859205">[-]</label><label class="expand" for="c-35859205">[1 more]</label></div><br/><div class="children"><div class="content">No, it&#x27;s only another way to access the same hardware decoder.</div><br/></div></div></div></div><div id="35857364" class="c"><input type="checkbox" id="c-35857364" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#35859189">prev</a><span>|</span><a href="#35857192">next</a><span>|</span><label class="collapse" for="c-35857364">[-]</label><label class="expand" for="c-35857364">[5 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t really done a whole lot with Vulkan yet but this really makes me curious if Vulkan could ever find itself as an alternative to VAAPI on Linux in some cases. Vulkan for compute purposes already seems like a pretty compelling idea, as it is, but in both cases I wonder, but was unable to ascertain an answer with a cursory glance, if it is possible today or maybe will ever be possible, to expose devices to Vulkan that are not GPUs (like compute accelerators.) Perhaps it&#x27;s not even really a good idea :) The case is probably stronger for compute devices a la OpenCL, since at least for video, if you&#x27;re targeting Linux anyways, it seems like you could use dma-bufs to pass buffers between Vulkan and VA-API and other stuff. Still, it does inspire curiosity.<p>A cursory search did seem to suggest encoding was supported as well as decoding in Vulkan, which is very cool.</div><br/><div id="35858601" class="c"><input type="checkbox" id="c-35858601" checked=""/><div class="controls bullet"><span class="by">bubblethink</span><span>|</span><a href="#35857364">parent</a><span>|</span><a href="#35857414">next</a><span>|</span><label class="collapse" for="c-35858601">[-]</label><label class="expand" for="c-35858601">[1 more]</label></div><br/><div class="children"><div class="content">&gt; if Vulkan could ever find itself as an alternative to VAAPI<p>The bar to beat VAAPI is really low. For all practical purposes, VAAPI doesn&#x27;t exist. So any alternate plan, even if it is essentially the same thing underneath, is worth a shot.</div><br/></div></div><div id="35857414" class="c"><input type="checkbox" id="c-35857414" checked=""/><div class="controls bullet"><span class="by">shmerl</span><span>|</span><a href="#35857364">parent</a><span>|</span><a href="#35858601">prev</a><span>|</span><a href="#35857192">next</a><span>|</span><label class="collapse" for="c-35857414">[-]</label><label class="expand" for="c-35857414">[3 more]</label></div><br/><div class="children"><div class="content">Yes, the general idea is for it to replace VAAPI for all relevant use cases.<p>I&#x27;d expect it also to move faster than VAAPI moves now once all things are in place (like adding new hardware and etc.).<p>It might be also possible to implement actual VAAPI over Vulkan video.</div><br/><div id="35857764" class="c"><input type="checkbox" id="c-35857764" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#35857364">root</a><span>|</span><a href="#35857414">parent</a><span>|</span><a href="#35857192">next</a><span>|</span><label class="collapse" for="c-35857764">[-]</label><label class="expand" for="c-35857764">[2 more]</label></div><br/><div class="children"><div class="content">Hmmm, interesting: maybe the last bit is the key to working around the issue that Vulkan drivers can really only exist for GPUs (to my knowledge, anyways). You could still have VA-API drivers for devices other than APIs, alongside a Vulkan implementation.</div><br/><div id="35859349" class="c"><input type="checkbox" id="c-35859349" checked=""/><div class="controls bullet"><span class="by">hrydgard</span><span>|</span><a href="#35857364">root</a><span>|</span><a href="#35857764">parent</a><span>|</span><a href="#35857192">next</a><span>|</span><label class="collapse" for="c-35859349">[-]</label><label class="expand" for="c-35859349">[1 more]</label></div><br/><div class="children"><div class="content">You can have a Vulkan driver that only exposes a video decoder queue and no raster&#x2F;compute&#x2F;copy queues, not a problem.</div><br/></div></div></div></div></div></div></div></div><div id="35857192" class="c"><input type="checkbox" id="c-35857192" checked=""/><div class="controls bullet"><span class="by">dagmx</span><span>|</span><a href="#35857364">prev</a><span>|</span><a href="#35858207">next</a><span>|</span><label class="collapse" for="c-35857192">[-]</label><label class="expand" for="c-35857192">[3 more]</label></div><br/><div class="children"><div class="content">This is great. It brings it in line with DirectX ( <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;medfound&#x2F;direct3d-12-video-overview" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;medfound&#x2F;dir...</a> )<p>It’s quite handy to be able to render a video on to spatial objects</div><br/><div id="35857334" class="c"><input type="checkbox" id="c-35857334" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#35857192">parent</a><span>|</span><a href="#35858712">next</a><span>|</span><label class="collapse" for="c-35857334">[-]</label><label class="expand" for="c-35857334">[1 more]</label></div><br/><div class="children"><div class="content">Yeah. I was trying to do something like render a scene and encode it on-GPU before sending it to disk. Unfortunately, there’s no way to give FFMPEG video textures afaict so even if it uses hw decode, you’re copying the full pixel buffer data twice instead of the drastically smaller encoded frame once (or at least there’s no mechanism exposed that the JS ecosystem can make use of which relies on command-line ffmpeg)</div><br/></div></div><div id="35858712" class="c"><input type="checkbox" id="c-35858712" checked=""/><div class="controls bullet"><span class="by">djmips</span><span>|</span><a href="#35857192">parent</a><span>|</span><a href="#35857334">prev</a><span>|</span><a href="#35858207">next</a><span>|</span><label class="collapse" for="c-35858712">[-]</label><label class="expand" for="c-35858712">[1 more]</label></div><br/><div class="children"><div class="content">I had a professional project I wanted to do in Linux but ended up going with Windows because of the 3D &#x2F; video performance.</div><br/></div></div></div></div><div id="35858207" class="c"><input type="checkbox" id="c-35858207" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#35857192">prev</a><span>|</span><a href="#35857408">next</a><span>|</span><label class="collapse" for="c-35858207">[-]</label><label class="expand" for="c-35858207">[2 more]</label></div><br/><div class="children"><div class="content">I wonder if this will be a path towards crashless video decoding in web browsers*. Probably not though :(<p>* modern web browsers have incredibly complex behavior to try and detect whether your system&#x27;s video codecs have crashed, since they can and will, and then if they crash too many times the system decoder is disabled and either replaced with a software decoder or nothing at all</div><br/><div id="35858479" class="c"><input type="checkbox" id="c-35858479" checked=""/><div class="controls bullet"><span class="by">dagmx</span><span>|</span><a href="#35858207">parent</a><span>|</span><a href="#35857408">next</a><span>|</span><label class="collapse" for="c-35858479">[-]</label><label class="expand" for="c-35858479">[1 more]</label></div><br/><div class="children"><div class="content">Hardware decoders tend to be less resilient than software decoders, since they’re tuned for the most common case but fail at more esoteric scenarios.<p>So I doubt this would change anything to that effect.</div><br/></div></div></div></div><div id="35857408" class="c"><input type="checkbox" id="c-35857408" checked=""/><div class="controls bullet"><span class="by">shmerl</span><span>|</span><a href="#35858207">prev</a><span>|</span><label class="collapse" for="c-35857408">[-]</label><label class="expand" for="c-35857408">[1 more]</label></div><br/><div class="children"><div class="content">Looking forward to it replacing VAAPI, including for AV1.</div><br/></div></div></div></div></div></div></div></body></html>