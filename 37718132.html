<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1696150859561" as="style"/><link rel="stylesheet" href="styles.css?v=1696150859561"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://mitchellh.com/writing/github-changesets">Reorient GitHub pull requests around changesets</a> <span class="domain">(<a href="https://mitchellh.com">mitchellh.com</a>)</span></div><div class="subtext"><span>jamesog</span> | <span>137 comments</span></div><br/><div><div id="37723755" class="c"><input type="checkbox" id="c-37723755" checked=""/><div class="controls bullet"><span class="by">TazeTSchnitzel</span><span>|</span><a href="#37721174">next</a><span>|</span><label class="collapse" for="c-37723755">[-]</label><label class="expand" for="c-37723755">[1 more]</label></div><br/><div class="children"><div class="content">The changeset workflow is what Gerrit uses. Gerrit is great.<p>There&#x27;s a free service (GerritHub) that lets you use Gerrit for your public GitHub project. The learning curve for it is pretty steep if you&#x27;ve never used Gerrit before, though, and it does have some reliability issues.  But for a certain kind of project it can really transform the code review experience.</div><br/></div></div><div id="37721174" class="c"><input type="checkbox" id="c-37721174" checked=""/><div class="controls bullet"><span class="by">noirscape</span><span>|</span><a href="#37723755">prev</a><span>|</span><a href="#37722790">next</a><span>|</span><label class="collapse" for="c-37721174">[-]</label><label class="expand" for="c-37721174">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty sure this approach is somewhat similar to the mailing list git approach, where patches usually get submitted once ready and then changed depending on feedback as a wholly new submitted patch (as part of a broader conversation).<p>It&#x27;d be a useful thing to import without having to bring in the whole charade of using email and mailing lists (which most mail clients tend to be very unfavorable of in general nowadays) - there&#x27;s real advantage to doing this in a web interface instead.<p>UX would probably be more difficult though. The current workflow of &quot;submit branch, make PR, do changes on same branch, merge latest version through web interface&quot; is a big part of the ease of the Github UX. Doing a merge outside of that just by pulling in the right remote branches has always been a crapshoot <i>at best</i> and a pain in the ass at worst. Not helped by the fact that Github&#x27;s documentation on how to do it in git is obscure (intentional I&#x27;m sure; I know it&#x27;s possible but the docs are scattered and all of it recommend just using their gh CLI tool at this point).</div><br/><div id="37722474" class="c"><input type="checkbox" id="c-37722474" checked=""/><div class="controls bullet"><span class="by">__david__</span><span>|</span><a href="#37721174">parent</a><span>|</span><a href="#37723015">next</a><span>|</span><label class="collapse" for="c-37722474">[-]</label><label class="expand" for="c-37722474">[1 more]</label></div><br/><div class="children"><div class="content">&gt; UX would probably be more difficult though. The current workflow of &quot;submit branch, make PR, do changes on same branch, merge latest version through web interface&quot; is a big part of the ease of the Github UX.<p>That was my first thought, too. Though perhaps a simple solution could be having GitHub, on a push, check for a new branch that matches an existing branch from a PR plus “-v2” (or “-v3”, etc.) and automatically consider that a new changeset in the PR.<p>Or perhaps even easier is once you’ve “released” your changeset in the GitHub ui, any pushes to the branch implicitly duplicate it and put it into a new v2 branch instead. That would be a decent ui from the pushers point of view, though there’s an and asymmetry between what you push and what ends up in the repo that I’m not sure I like.</div><br/></div></div><div id="37723015" class="c"><input type="checkbox" id="c-37723015" checked=""/><div class="controls bullet"><span class="by">u801e</span><span>|</span><a href="#37721174">parent</a><span>|</span><a href="#37722474">prev</a><span>|</span><a href="#37722790">next</a><span>|</span><label class="collapse" for="c-37723015">[-]</label><label class="expand" for="c-37723015">[5 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;d be a useful thing to import without having to bring in the whole charade of using email and mailing lists (which most mail clients tend to be very unfavorable of in general nowadays)<p>This is a misconception.  git itself has commands (git-format-patch and git-send-email) that automate the creation of patches and sending changeset email threads to the mailing list.  The only thing one needs to do is set the appropriate configuration settings in their git config (which is a one time operation like setting your name and email address).<p>The actual interaction on the mailing list (responding to those who review patches and changesets can be done in any email client of one&#x27;s choosing (though it&#x27;s helpful to use an email client that supports threading using the Message-Id, In-Reply-To and Reference headers rather than one that only handles conversation view style replies).</div><br/><div id="37723400" class="c"><input type="checkbox" id="c-37723400" checked=""/><div class="controls bullet"><span class="by">da39a3ee</span><span>|</span><a href="#37721174">root</a><span>|</span><a href="#37723015">parent</a><span>|</span><a href="#37722790">next</a><span>|</span><label class="collapse" for="c-37723400">[-]</label><label class="expand" for="c-37723400">[4 more]</label></div><br/><div class="children"><div class="content">No, it is not a misconception. How do I apply a patch from gmail to a specific git repo on my computer? (I would genuinely like to know the answer, but it must not involve mutt, gnus, or dovecot!)</div><br/><div id="37723696" class="c"><input type="checkbox" id="c-37723696" checked=""/><div class="controls bullet"><span class="by">JohnKemeny</span><span>|</span><a href="#37721174">root</a><span>|</span><a href="#37723400">parent</a><span>|</span><a href="#37723898">next</a><span>|</span><label class="collapse" for="c-37723696">[-]</label><label class="expand" for="c-37723696">[1 more]</label></div><br/><div class="children"><div class="content">Copy the content of the email to your clipboard, type `git am` in your terminal, paste and C-d to complete.</div><br/></div></div><div id="37723898" class="c"><input type="checkbox" id="c-37723898" checked=""/><div class="controls bullet"><span class="by">u801e</span><span>|</span><a href="#37721174">root</a><span>|</span><a href="#37723400">parent</a><span>|</span><a href="#37723696">prev</a><span>|</span><a href="#37723717">next</a><span>|</span><label class="collapse" for="c-37723898">[-]</label><label class="expand" for="c-37723898">[1 more]</label></div><br/><div class="children"><div class="content">Save the email to your local machine (in gmail, click the 3 dots and choose download message).  Then run<p><pre><code>    git am &lt; saved_email_file.eml</code></pre></div><br/></div></div><div id="37723717" class="c"><input type="checkbox" id="c-37723717" checked=""/><div class="controls bullet"><span class="by">sammorrowdrums</span><span>|</span><a href="#37721174">root</a><span>|</span><a href="#37723400">parent</a><span>|</span><a href="#37723898">prev</a><span>|</span><a href="#37722790">next</a><span>|</span><label class="collapse" for="c-37723717">[-]</label><label class="expand" for="c-37723717">[1 more]</label></div><br/><div class="children"><div class="content">In the worst case you can copy paste a patch into a new local file in the repo and then apply it with git from there. I’ve had somebody slack me patches before and it is not a big lift.</div><br/></div></div></div></div></div></div></div></div><div id="37722790" class="c"><input type="checkbox" id="c-37722790" checked=""/><div class="controls bullet"><span class="by">Vendan</span><span>|</span><a href="#37721174">prev</a><span>|</span><a href="#37722456">next</a><span>|</span><label class="collapse" for="c-37722790">[-]</label><label class="expand" for="c-37722790">[3 more]</label></div><br/><div class="children"><div class="content">Github had this planned in their old roadmap...  But then they deleted it...<p><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20220831234107&#x2F;https:&#x2F;&#x2F;github.com&#x2F;github&#x2F;roadmap&#x2F;issues&#x2F;211" rel="nofollow noreferrer">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20220831234107&#x2F;https:&#x2F;&#x2F;github.co...</a></div><br/><div id="37723467" class="c"><input type="checkbox" id="c-37723467" checked=""/><div class="controls bullet"><span class="by">mikemcquaid</span><span>|</span><a href="#37722790">parent</a><span>|</span><a href="#37722456">next</a><span>|</span><label class="collapse" for="c-37723467">[-]</label><label class="expand" for="c-37723467">[2 more]</label></div><br/><div class="children"><div class="content">I left GitHub earlier this year after a decade. I’ve seen mockups, hack week projects and proof of concepts of this for the last 5 years (at least). A lot of engineers there knew this is the future that PRs need but GitHub at this point seems organisationally incapable of delivering these sorts of large improvements (Microsoft is perhaps partly but definitely not wholly to blame for this). Instead, they are midway through porting Rails views to use React, keeping most pages looking identical while introducing bugs and regressing previous usability improvements on a weekly basis. A real shame.</div><br/><div id="37723675" class="c"><input type="checkbox" id="c-37723675" checked=""/><div class="controls bullet"><span class="by">als0</span><span>|</span><a href="#37722790">root</a><span>|</span><a href="#37723467">parent</a><span>|</span><a href="#37722456">next</a><span>|</span><label class="collapse" for="c-37723675">[-]</label><label class="expand" for="c-37723675">[1 more]</label></div><br/><div class="children"><div class="content">Wow, why would they spend so much energy rewriting Rails code into React?</div><br/></div></div></div></div></div></div><div id="37722456" class="c"><input type="checkbox" id="c-37722456" checked=""/><div class="controls bullet"><span class="by">parentheses</span><span>|</span><a href="#37722790">prev</a><span>|</span><a href="#37724017">next</a><span>|</span><label class="collapse" for="c-37722456">[-]</label><label class="expand" for="c-37722456">[2 more]</label></div><br/><div class="children"><div class="content">Changesets seem like a UX nightmare. While I understand the motivation, the complexity of version control today is mind boggling.<p>We have a working copy, index, commits, branches, remotes, pull requests - all of these come into play when proposing even the simplest change to an open source repo today. The idea that adding yet another concept to the pile will make things better is something I can&#x27;t agree with.<p>Will it enable more capabilities? Yes. Adding features generally does that.<p>Aside from the &quot;it&#x27;s already complex enough&quot; argument, there&#x27;s also the fact that 90% of changes I&#x27;ve seen in my daily use of git don&#x27;t require this feature. This means the feature will be misunderstood, misused and often not used when actually needed.</div><br/><div id="37723999" class="c"><input type="checkbox" id="c-37723999" checked=""/><div class="controls bullet"><span class="by">bvrmn</span><span>|</span><a href="#37722456">parent</a><span>|</span><a href="#37724017">next</a><span>|</span><label class="collapse" for="c-37723999">[-]</label><label class="expand" for="c-37723999">[1 more]</label></div><br/><div class="children"><div class="content">Changesets in Gerrit are more easier to manage from processes and UX standpoint. There is no branch&#x2F;commit&#x2F;comment&#x2F;rebase&#x2F;commit&#x2F;resolve-staled-comment&#x2F;fight-for-true-pr-merging-strategy dance.<p>I&#x27;m doing a lot of review work and changesets are a killer feature not to lost in comments. Even for small-ish 50 line reviews.<p>Changesets especially powerful with local stack based development tools like stgit which allows to completely remove branch management.</div><br/></div></div></div></div><div id="37724017" class="c"><input type="checkbox" id="c-37724017" checked=""/><div class="controls bullet"><span class="by">mvdtnz</span><span>|</span><a href="#37722456">prev</a><span>|</span><a href="#37720984">next</a><span>|</span><label class="collapse" for="c-37724017">[-]</label><label class="expand" for="c-37724017">[1 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t used GitHub in a while but absolutely all of the author&#x27;s issues are fixed in gitlab and I have a hard time believing GitHub is that far behind.</div><br/></div></div><div id="37720984" class="c"><input type="checkbox" id="c-37720984" checked=""/><div class="controls bullet"><span class="by">lifeisstillgood</span><span>|</span><a href="#37724017">prev</a><span>|</span><a href="#37721691">next</a><span>|</span><label class="collapse" for="c-37720984">[-]</label><label class="expand" for="c-37720984">[6 more]</label></div><br/><div class="children"><div class="content">I am slowly convinced that comments on PRs are like comments on blog posts or youtube videos. Ephemeral, irrelevant and ineffective.  If you really want to &quot;reply&quot;, put up your own blog post or a &quot;reacts&quot; video.  Same for code. unless it&#x27;s simple typo fixes or improvements, deeper fixes come from writing code samples yourself.<p>I recently commented on a juniors code, and put in about four lines of code showing how I would improve the performance- but to do so I of course had to bring up a REPL and put the code in and run it and had more or less done a PR.<p>Make it faster and easier to inject and piece of code into the PR flow (branch <i>pu</i>?), make the whole code base simple to run from any point in memory, fully testrigged, so &quot;just those highlighted lines&quot; can be run and everyone can see.<p>What we are doing with this OP approach is making it easier for a human brain to imagine what the runtime will be like.  That&#x27;s the wrong approach   - make it easier to have the runtime run over the chnaged lines of code and let people step through at PR time, and then make their changes alongside.<p>Or just leave a comment.<p>But we know what the rules are on comments on the internet</div><br/><div id="37722031" class="c"><input type="checkbox" id="c-37722031" checked=""/><div class="controls bullet"><span class="by">zerbinxx</span><span>|</span><a href="#37720984">parent</a><span>|</span><a href="#37723756">next</a><span>|</span><label class="collapse" for="c-37722031">[-]</label><label class="expand" for="c-37722031">[4 more]</label></div><br/><div class="children"><div class="content">One practice I’ve gotten into with juniors is checking out their PR, branching it, PR-ing to their PR, and then having the discussion about what I want them to change there. This is good because it lets us isolate certain issues (and truly resolve them) rather than comments getting pulverized by lots of little commits, only to have someone else come in and say “LGTM!” and merge it with unresolved issues.<p>Another obvious way to fix OP’s issue is to request developers to break their PR’s down into smaller chunks, pair on the parts that need help, and slowly merge things from there. YMMV of course - but any 1000 line PR is going to be a headache regardless of what methodology you’re using to review code.</div><br/><div id="37722242" class="c"><input type="checkbox" id="c-37722242" checked=""/><div class="controls bullet"><span class="by">XorNot</span><span>|</span><a href="#37720984">root</a><span>|</span><a href="#37722031">parent</a><span>|</span><a href="#37723756">next</a><span>|</span><label class="collapse" for="c-37722242">[-]</label><label class="expand" for="c-37722242">[3 more]</label></div><br/><div class="children"><div class="content">I like this approach too, but almost no one understands it (i.e. the idea it&#x27;s possible is foreign) and UI support for it is non-existent in all the major products.<p>It would be wonderful if we could ditch &quot;change these lines&quot; type comments in favour of just letting merge requests with the changes be easily surfaced.</div><br/><div id="37723410" class="c"><input type="checkbox" id="c-37723410" checked=""/><div class="controls bullet"><span class="by">da39a3ee</span><span>|</span><a href="#37720984">root</a><span>|</span><a href="#37722242">parent</a><span>|</span><a href="#37722983">next</a><span>|</span><label class="collapse" for="c-37723410">[-]</label><label class="expand" for="c-37723410">[1 more]</label></div><br/><div class="children"><div class="content">I might be wrong but it sounds like you don&#x27;t know about the GitHub PR feature where you select the lines,  and GitHub allows you to edit them, and posts a diff when you&#x27;re done, and if the author accepts it out becomes a jointly authored commit.</div><br/></div></div><div id="37722983" class="c"><input type="checkbox" id="c-37722983" checked=""/><div class="controls bullet"><span class="by">zerbinxx</span><span>|</span><a href="#37720984">root</a><span>|</span><a href="#37722242">parent</a><span>|</span><a href="#37723410">prev</a><span>|</span><a href="#37723756">next</a><span>|</span><label class="collapse" for="c-37722983">[-]</label><label class="expand" for="c-37722983">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, it really wouldn’t be that hard to implement though. I think I’ll take a stab at something like this using GitHub cli tomorrow or Monday</div><br/></div></div></div></div></div></div><div id="37723756" class="c"><input type="checkbox" id="c-37723756" checked=""/><div class="controls bullet"><span class="by">elAhmo</span><span>|</span><a href="#37720984">parent</a><span>|</span><a href="#37722031">prev</a><span>|</span><a href="#37721691">next</a><span>|</span><label class="collapse" for="c-37723756">[-]</label><label class="expand" for="c-37723756">[1 more]</label></div><br/><div class="children"><div class="content">I frequently use “suggestion” to provide a change I think would be better.<p>‘’’suggestion
&lt;code block&gt;
‘’’</div><br/></div></div></div></div><div id="37721691" class="c"><input type="checkbox" id="c-37721691" checked=""/><div class="controls bullet"><span class="by">jacobegold</span><span>|</span><a href="#37720984">prev</a><span>|</span><a href="#37722263">next</a><span>|</span><label class="collapse" for="c-37721691">[-]</label><label class="expand" for="c-37721691">[6 more]</label></div><br/><div class="children"><div class="content">GitHub actually stores all the data necessary to do this without changing your ref model as the article suggests — even if you force push, it never garbage collects the commits that the branch used to point to.<p>I work on a tool that includes a UI for diffing versions of a GitHub PR, but you can totally get the same thing via messing with GitHub.com URLs.</div><br/><div id="37721745" class="c"><input type="checkbox" id="c-37721745" checked=""/><div class="controls bullet"><span class="by">tomasreimers</span><span>|</span><a href="#37721691">parent</a><span>|</span><a href="#37721712">next</a><span>|</span><label class="collapse" for="c-37721745">[-]</label><label class="expand" for="c-37721745">[1 more]</label></div><br/><div class="children"><div class="content">Hi! I work with the commenter - for those wondering here&#x27;s documentation on that feature (pulled off with pretty much only GH data):<p><a href="https:&#x2F;&#x2F;graphite.dev&#x2F;docs&#x2F;pull-request-versions" rel="nofollow noreferrer">https:&#x2F;&#x2F;graphite.dev&#x2F;docs&#x2F;pull-request-versions</a><p>If people are interested, probably a thing we could do a technical blog post on.</div><br/></div></div><div id="37721712" class="c"><input type="checkbox" id="c-37721712" checked=""/><div class="controls bullet"><span class="by">fahhem</span><span>|</span><a href="#37721691">parent</a><span>|</span><a href="#37721745">prev</a><span>|</span><a href="#37722263">next</a><span>|</span><label class="collapse" for="c-37721712">[-]</label><label class="expand" for="c-37721712">[4 more]</label></div><br/><div class="children"><div class="content">I agree, we work on Reviewable, which uses those same blobs.<p>However, we add tags to commits we&#x27;re referencing, just in case someone at GitHub gets around to implementing garbage collection!</div><br/><div id="37721737" class="c"><input type="checkbox" id="c-37721737" checked=""/><div class="controls bullet"><span class="by">jacobegold</span><span>|</span><a href="#37721691">root</a><span>|</span><a href="#37721712">parent</a><span>|</span><a href="#37722263">next</a><span>|</span><label class="collapse" for="c-37721737">[-]</label><label class="expand" for="c-37721737">[3 more]</label></div><br/><div class="children"><div class="content">They must have refs on the internal git servers -- they need them for the &quot;force pushed from X to Y&quot; timeline events</div><br/><div id="37722187" class="c"><input type="checkbox" id="c-37722187" checked=""/><div class="controls bullet"><span class="by">bongobingo1</span><span>|</span><a href="#37721691">root</a><span>|</span><a href="#37721737">parent</a><span>|</span><a href="#37721748">next</a><span>|</span><label class="collapse" for="c-37722187">[-]</label><label class="expand" for="c-37722187">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve definitely clicked those links through to 404s.</div><br/></div></div><div id="37721748" class="c"><input type="checkbox" id="c-37721748" checked=""/><div class="controls bullet"><span class="by">fahhem</span><span>|</span><a href="#37721691">root</a><span>|</span><a href="#37721737">parent</a><span>|</span><a href="#37722187">prev</a><span>|</span><a href="#37722263">next</a><span>|</span><label class="collapse" for="c-37721748">[-]</label><label class="expand" for="c-37721748">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right, though I think that changed recently? I vaguely remember only the last force push showed up, but now I see more than one so :shrug:</div><br/></div></div></div></div></div></div></div></div><div id="37722263" class="c"><input type="checkbox" id="c-37722263" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#37721691">prev</a><span>|</span><a href="#37721187">next</a><span>|</span><label class="collapse" for="c-37722263">[-]</label><label class="expand" for="c-37722263">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s surprising to me that GitHub currently doesn&#x27;t attach review comments to specific commits, but only to timestamps, and I agree that it would be great to improve that.<p>But I don&#x27;t understand how a contributor can feel pressure to address all of the reviewers&#x27; comments in a single commit: They can commit as many times as they want, and only <i>push</i> when they feel it&#x27;s ready. And in the case where they may want to offer multiple different solutions for a reviewer to choose from, I like a small adaptation of a suggestion I saw by another commenter here, which is to make a PR for each option <i>off their existing PR&#x27;s branch</i>: When one of those option branches is accepted and merged, GitHub will fast-forward the original PR&#x27;s branch to include those commits, which is exactly what you would want and expect.</div><br/><div id="37723034" class="c"><input type="checkbox" id="c-37723034" checked=""/><div class="controls bullet"><span class="by">u801e</span><span>|</span><a href="#37722263">parent</a><span>|</span><a href="#37722380">next</a><span>|</span><label class="collapse" for="c-37723034">[-]</label><label class="expand" for="c-37723034">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s surprising to me that GitHub currently doesn&#x27;t attach review comments to specific commits<p>It is possible to comment on commits in github (you can do it by clicking on the sha1 of the commit and then making a comment on a line in the diff).  But the comment won&#x27;t show up in the main PR diff window.<p>&gt; But I don&#x27;t understand how a contributor can feel pressure to address all of the reviewers&#x27; comments in a single commit: They can commit as many times as they want, and only push when they feel it&#x27;s ready.<p>Unfortunately, this leads to a lot of fixup commits in the branch that muddle up the history.  A changeset consists of one or more commits where each makes one logical change where the what was done and why it was done that way are detailed in the commit message.</div><br/><div id="37723948" class="c"><input type="checkbox" id="c-37723948" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#37722263">root</a><span>|</span><a href="#37723034">parent</a><span>|</span><a href="#37722380">next</a><span>|</span><label class="collapse" for="c-37723948">[-]</label><label class="expand" for="c-37723948">[1 more]</label></div><br/><div class="children"><div class="content">&gt;A changeset consists of one or more commits where each makes one logical change<p>I don&#x27;t yet see how that is different from just... a sequence of commits, which you can do now. (If you want to claim that you could quickly make a bunch of messy local commits and afterwards reorganise them into a more logical group of commits in a changeset -- you can already do that, without any new concept of changesets, by using `git rebase -i`.)</div><br/></div></div></div></div><div id="37722380" class="c"><input type="checkbox" id="c-37722380" checked=""/><div class="controls bullet"><span class="by">ezekg</span><span>|</span><a href="#37722263">parent</a><span>|</span><a href="#37723034">prev</a><span>|</span><a href="#37721187">next</a><span>|</span><label class="collapse" for="c-37722380">[-]</label><label class="expand" for="c-37722380">[1 more]</label></div><br/><div class="children"><div class="content">I think this is what <a href="https:&#x2F;&#x2F;graphite.dev" rel="nofollow noreferrer">https:&#x2F;&#x2F;graphite.dev</a> is trying to do.</div><br/></div></div></div></div><div id="37721187" class="c"><input type="checkbox" id="c-37721187" checked=""/><div class="controls bullet"><span class="by">codazoda</span><span>|</span><a href="#37722263">prev</a><span>|</span><a href="#37723748">next</a><span>|</span><label class="collapse" for="c-37721187">[-]</label><label class="expand" for="c-37721187">[3 more]</label></div><br/><div class="children"><div class="content">I don’t have experience with the outlined workflow, only with GitHub PR’s, but it feels like maybe the PR’s could too big if you have this problem?<p>I’m anticipating some push back on this, because I didn’t notice it mentioned anywhere else, even though there are a fair number of comments. So, I may need take some time to understand these other tools. But, short of that, for me personally, keeping things small and relatively easy to understand is the only way to maintain my sanity.</div><br/><div id="37724047" class="c"><input type="checkbox" id="c-37724047" checked=""/><div class="controls bullet"><span class="by">bvrmn</span><span>|</span><a href="#37721187">parent</a><span>|</span><a href="#37724029">next</a><span>|</span><label class="collapse" for="c-37724047">[-]</label><label class="expand" for="c-37724047">[1 more]</label></div><br/><div class="children"><div class="content">Fracturing a big commit to smaller parts doesn&#x27;t help. Amount of work is the same, number of comments would be higher or same due to bigger context loss. GH PR UI is notoriously confusing while reviewing multi commit PRs.</div><br/></div></div><div id="37724029" class="c"><input type="checkbox" id="c-37724029" checked=""/><div class="controls bullet"><span class="by">mvdtnz</span><span>|</span><a href="#37721187">parent</a><span>|</span><a href="#37724047">prev</a><span>|</span><a href="#37723748">next</a><span>|</span><label class="collapse" for="c-37724029">[-]</label><label class="expand" for="c-37724029">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re absolutely right, the author&#x27;s problem imply massive pull requests that I wouldn&#x27;t accept in my workplace.</div><br/></div></div></div></div><div id="37723748" class="c"><input type="checkbox" id="c-37723748" checked=""/><div class="controls bullet"><span class="by">Lapsa</span><span>|</span><a href="#37721187">prev</a><span>|</span><a href="#37720601">next</a><span>|</span><label class="collapse" for="c-37723748">[-]</label><label class="expand" for="c-37723748">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve noticed listed problems, they surely do exist. but stepping back a little - proposed solution sounds like: &quot;lets make a brand new version control system for already existing version control system&quot;.</div><br/></div></div><div id="37720601" class="c"><input type="checkbox" id="c-37720601" checked=""/><div class="controls bullet"><span class="by">nh2</span><span>|</span><a href="#37723748">prev</a><span>|</span><a href="#37723957">next</a><span>|</span><label class="collapse" for="c-37720601">[-]</label><label class="expand" for="c-37720601">[2 more]</label></div><br/><div class="children"><div class="content">A proper review tool such as reviewable.io (which is on top of Github) addresses all points in his &quot;problems&quot; list.</div><br/><div id="37721994" class="c"><input type="checkbox" id="c-37721994" checked=""/><div class="controls bullet"><span class="by">fahhem</span><span>|</span><a href="#37720601">parent</a><span>|</span><a href="#37723957">next</a><span>|</span><label class="collapse" for="c-37721994">[-]</label><label class="expand" for="c-37721994">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, we heart you too :D</div><br/></div></div></div></div><div id="37723957" class="c"><input type="checkbox" id="c-37723957" checked=""/><div class="controls bullet"><span class="by">intellix</span><span>|</span><a href="#37720601">prev</a><span>|</span><a href="#37720997">next</a><span>|</span><label class="collapse" for="c-37723957">[-]</label><label class="expand" for="c-37723957">[1 more]</label></div><br/><div class="children"><div class="content">isn&#x27;t this what Gitlab have? Instead of v1, 2, 3 you&#x27;re able to see them at the state of each git commit hash</div><br/></div></div><div id="37720997" class="c"><input type="checkbox" id="c-37720997" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#37723957">prev</a><span>|</span><a href="#37721574">next</a><span>|</span><label class="collapse" for="c-37720997">[-]</label><label class="expand" for="c-37720997">[4 more]</label></div><br/><div class="children"><div class="content">Hmm, not saying Github is perfect, but I think there’s value in providing the simplest possible experience as the default.</div><br/><div id="37721754" class="c"><input type="checkbox" id="c-37721754" checked=""/><div class="controls bullet"><span class="by">jacobegold</span><span>|</span><a href="#37720997">parent</a><span>|</span><a href="#37721621">next</a><span>|</span><label class="collapse" for="c-37721754">[-]</label><label class="expand" for="c-37721754">[2 more]</label></div><br/><div class="children"><div class="content">I was lucky enough to work at a company with a great code review tool at one of my first positions -- and I am nowhere near convinced that GH&#x27;s review interface is the simplest possible.<p>Of course, everyone (including myself!) is probably biased to think that whatever they are used to is simplest, tbh.</div><br/><div id="37723361" class="c"><input type="checkbox" id="c-37723361" checked=""/><div class="controls bullet"><span class="by">u801e</span><span>|</span><a href="#37720997">root</a><span>|</span><a href="#37721754">parent</a><span>|</span><a href="#37721621">next</a><span>|</span><label class="collapse" for="c-37723361">[-]</label><label class="expand" for="c-37723361">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I am nowhere near convinced that GH&#x27;s review interface is the simplest possible.<p>It wasn&#x27;t initially designed with code review in mind (unlike systems like phabricator, gerrit, review board, etc).</div><br/></div></div></div></div><div id="37721621" class="c"><input type="checkbox" id="c-37721621" checked=""/><div class="controls bullet"><span class="by">fahhem</span><span>|</span><a href="#37720997">parent</a><span>|</span><a href="#37721754">prev</a><span>|</span><a href="#37721574">next</a><span>|</span><label class="collapse" for="c-37721621">[-]</label><label class="expand" for="c-37721621">[1 more]</label></div><br/><div class="children"><div class="content">I agree, you want a basic tool for most users that just need the ability to review the code. But, once your team is doing something where the code quality is important, you&#x27;ll want to switch to a better tool for the job (like Reviewable!), just like when you switch from a whisk and bowl to a kitchenaid standing mixer when you start baking often</div><br/></div></div></div></div><div id="37721574" class="c"><input type="checkbox" id="c-37721574" checked=""/><div class="controls bullet"><span class="by">neo2006</span><span>|</span><a href="#37720997">prev</a><span>|</span><a href="#37723811">next</a><span>|</span><label class="collapse" for="c-37721574">[-]</label><label class="expand" for="c-37721574">[3 more]</label></div><br/><div class="children"><div class="content">I often stack PRs to emulate the practice described by Mitchell but it&#x27;s not ideal as if you need to change an underlying PR l, you need to rebase all of the dependent PRs.</div><br/><div id="37721607" class="c"><input type="checkbox" id="c-37721607" checked=""/><div class="controls bullet"><span class="by">jacobegold</span><span>|</span><a href="#37721574">parent</a><span>|</span><a href="#37721604">next</a><span>|</span><label class="collapse" for="c-37721607">[-]</label><label class="expand" for="c-37721607">[1 more]</label></div><br/><div class="children"><div class="content">There are tools that solve this problem! I work on one (Graphite), but there&#x27;s also plenty of others like git-branchless and Sapling.  All three of these are inspired by Facebook&#x27;s internal fork of Mercurial (with Phabricator&#x2F;&quot;Diffs&quot; for reviewing) -- Google has a similar model with Piper&#x2F;Critique CLs, with Gerrit as the open source result.</div><br/></div></div><div id="37721604" class="c"><input type="checkbox" id="c-37721604" checked=""/><div class="controls bullet"><span class="by">fahhem</span><span>|</span><a href="#37721574">parent</a><span>|</span><a href="#37721607">prev</a><span>|</span><a href="#37723811">next</a><span>|</span><label class="collapse" for="c-37721604">[-]</label><label class="expand" for="c-37721604">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a ton of cli tools to automate maintaining a stack of PR&#x27;s, with new ones coming out all the time. I&#x27;ve seen &#x27;spr&#x27; for a long time, and recently there&#x27;s graphite&#x27;s and even aviator came out with &#x27;av&#x27;.<p>All supported by Reviewable, of course (sorry for the shameless plug!)</div><br/></div></div></div></div><div id="37723811" class="c"><input type="checkbox" id="c-37723811" checked=""/><div class="controls bullet"><span class="by">danjc</span><span>|</span><a href="#37721574">prev</a><span>|</span><a href="#37720280">next</a><span>|</span><label class="collapse" for="c-37723811">[-]</label><label class="expand" for="c-37723811">[1 more]</label></div><br/><div class="children"><div class="content">It might be less correct from a taxonomy perspective but why not just a different branch for each change?</div><br/></div></div><div id="37720280" class="c"><input type="checkbox" id="c-37720280" checked=""/><div class="controls bullet"><span class="by">oldtownroad</span><span>|</span><a href="#37723811">prev</a><span>|</span><a href="#37719991">next</a><span>|</span><label class="collapse" for="c-37720280">[-]</label><label class="expand" for="c-37720280">[24 more]</label></div><br/><div class="children"><div class="content">I agree. As a way to minimise the pain on GitHub today, we disallow force pushing and enforce squash merging. Force pushing is a nightmarish behaviour, once a Pull Request is opened the branch must be append only.</div><br/><div id="37722188" class="c"><input type="checkbox" id="c-37722188" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#37720280">parent</a><span>|</span><a href="#37720985">next</a><span>|</span><label class="collapse" for="c-37722188">[-]</label><label class="expand" for="c-37722188">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand the appeal of squash commits. AFAICT, the only advantage of squash commits is a nice &quot;linear history&quot;, but you can get that from regular old merge commits just by adding --first-parent to your `git log` command -- and you still have that additional detail available on the second-parent commit chain if you need it.<p>As soon as you start squashing commits, you throw away a very useful guarantee git gives you by default, which is that a given code change A is &quot;in&quot; a given branch B <i>if and only if</i> A is reachable from B. This guarantee is very helpful when debugging differences between versions, e.g., in figuring out which commits I&#x27;ve made locally are actually running in a shared environment like staging&#x2F;UAT.</div><br/></div></div><div id="37721162" class="c"><input type="checkbox" id="c-37721162" checked=""/><div class="controls bullet"><span class="by">stefan_</span><span>|</span><a href="#37720280">parent</a><span>|</span><a href="#37720985">prev</a><span>|</span><a href="#37722203">next</a><span>|</span><label class="collapse" for="c-37721162">[-]</label><label class="expand" for="c-37721162">[7 more]</label></div><br/><div class="children"><div class="content">So you have endless &quot;Fix a&quot; &quot;Typo&quot; &quot;fixup&quot; &quot;revert redo&quot; &quot;add y missed in z&quot; commits and then the squash pushes all that crap into the commit message for whatever the final mess will be?<p>Here is a random series from DRM patchwork: <a href="https:&#x2F;&#x2F;patchwork.kernel.org&#x2F;project&#x2F;dri-devel&#x2F;list&#x2F;?series=788478" rel="nofollow noreferrer">https:&#x2F;&#x2F;patchwork.kernel.org&#x2F;project&#x2F;dri-devel&#x2F;list&#x2F;?series=...</a><p>Would you squash that? Hell no, of course not. You would be mixing atomic changes in different subsystems. It breaks bisect and makes blames a mess.<p>Honestly, squash merges are frequently a sign of people who lack mastery in Git itself or make no effort to produce high-quality independent commits.</div><br/><div id="37721208" class="c"><input type="checkbox" id="c-37721208" checked=""/><div class="controls bullet"><span class="by">avita1</span><span>|</span><a href="#37720280">root</a><span>|</span><a href="#37721162">parent</a><span>|</span><a href="#37721267">next</a><span>|</span><label class="collapse" for="c-37721208">[-]</label><label class="expand" for="c-37721208">[2 more]</label></div><br/><div class="children"><div class="content">&gt; So you have endless &quot;Fix a&quot; &quot;Typo&quot; &quot;fixup&quot; &quot;revert redo&quot; &quot;add y missed in z&quot; commits and then the squash pushes all that crap into the commit message for whatever the final mess will be?<p>In Github at least you can set the behavior to take the PR description by default as the squashed commit message.  In fairness this is not the default. The default behavior for squash merges is to ask for a new commit message right as you hit the merge button, and the default is all of the messages from the commits being squashed together.<p>&gt; make no effort to produce high-quality independent commits<p>I&#x27;m partial to sqaush merges when using github. I don&#x27;t put much effort into the individual commit messages, instead I put lots of effort into the PR description (the thing reviewers will read, and what will eventually become the commit message in revision history). That said, one of my favorite features from gerrit at a past job was that the commit message itself could be reviewed.</div><br/><div id="37721848" class="c"><input type="checkbox" id="c-37721848" checked=""/><div class="controls bullet"><span class="by">piotrkaminski</span><span>|</span><a href="#37720280">root</a><span>|</span><a href="#37721208">parent</a><span>|</span><a href="#37721267">next</a><span>|</span><label class="collapse" for="c-37721848">[-]</label><label class="expand" for="c-37721848">[1 more]</label></div><br/><div class="children"><div class="content">&gt; That said, one of my favorite features from gerrit at a past job was that the commit message itself could be reviewed.<p>Reviewable lets you review your commit messages just like any other file, BTW!  (Disclosure: I&#x27;m the founder.)</div><br/></div></div></div></div><div id="37721267" class="c"><input type="checkbox" id="c-37721267" checked=""/><div class="controls bullet"><span class="by">juped</span><span>|</span><a href="#37720280">root</a><span>|</span><a href="#37721162">parent</a><span>|</span><a href="#37721208">prev</a><span>|</span><a href="#37721216">next</a><span>|</span><label class="collapse" for="c-37721267">[-]</label><label class="expand" for="c-37721267">[1 more]</label></div><br/><div class="children"><div class="content">I see the problem as being that Github&#x27;s bad git tooling blocks people from mastery in Git and actively discourages high-quality commits.</div><br/></div></div><div id="37721216" class="c"><input type="checkbox" id="c-37721216" checked=""/><div class="controls bullet"><span class="by">oldtownroad</span><span>|</span><a href="#37720280">root</a><span>|</span><a href="#37721162">parent</a><span>|</span><a href="#37721267">prev</a><span>|</span><a href="#37721303">next</a><span>|</span><label class="collapse" for="c-37721216">[-]</label><label class="expand" for="c-37721216">[1 more]</label></div><br/><div class="children"><div class="content">A Pull Request should represent one change to the system (whether that’s a new feature or a bug fix). A commit to the Pull Request branch only has value in the context of the Pull Request. If you want a Pull Request to contain multiple atomic changes then sure, you need to do what you’re describing… but that’s entirely optional (and straying even further from the idea of changesets).</div><br/></div></div><div id="37721303" class="c"><input type="checkbox" id="c-37721303" checked=""/><div class="controls bullet"><span class="by">falcojr</span><span>|</span><a href="#37720280">root</a><span>|</span><a href="#37721162">parent</a><span>|</span><a href="#37721216">prev</a><span>|</span><a href="#37723436">next</a><span>|</span><label class="collapse" for="c-37721303">[-]</label><label class="expand" for="c-37721303">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Honestly, squash merges are frequently a sign of people who lack mastery in Git itself or make no effort to produce high-quality independent commits.<p>So literally any open source project that accepts external contributions. For this reason we default to squash merge but will allow for exceptions if people ask for it and know how to structure their commits.</div><br/></div></div><div id="37723436" class="c"><input type="checkbox" id="c-37723436" checked=""/><div class="controls bullet"><span class="by">da39a3ee</span><span>|</span><a href="#37720280">root</a><span>|</span><a href="#37721162">parent</a><span>|</span><a href="#37721303">prev</a><span>|</span><a href="#37722203">next</a><span>|</span><label class="collapse" for="c-37723436">[-]</label><label class="expand" for="c-37723436">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Honestly, squash merges are frequently a sign of people who lack mastery in Git itself or make no effort to produce high-quality independent commits.<p>Otherwise known as &quot;colleagues&quot; :)</div><br/></div></div></div></div><div id="37722203" class="c"><input type="checkbox" id="c-37722203" checked=""/><div class="controls bullet"><span class="by">arwineap</span><span>|</span><a href="#37720280">parent</a><span>|</span><a href="#37721162">prev</a><span>|</span><a href="#37720933">next</a><span>|</span><label class="collapse" for="c-37722203">[-]</label><label class="expand" for="c-37722203">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re going to squash on merge, why would you not allow squashing on the branch?</div><br/></div></div><div id="37720933" class="c"><input type="checkbox" id="c-37720933" checked=""/><div class="controls bullet"><span class="by">huijzer</span><span>|</span><a href="#37720280">parent</a><span>|</span><a href="#37722203">prev</a><span>|</span><a href="#37720972">next</a><span>|</span><label class="collapse" for="c-37720933">[-]</label><label class="expand" for="c-37720933">[1 more]</label></div><br/><div class="children"><div class="content">Oh man yes I dislike non-squash merges very much because they make it so hard to go from the Git blame to the pull request discussion</div><br/></div></div><div id="37720972" class="c"><input type="checkbox" id="c-37720972" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#37720280">parent</a><span>|</span><a href="#37720933">prev</a><span>|</span><a href="#37721640">next</a><span>|</span><label class="collapse" for="c-37720972">[-]</label><label class="expand" for="c-37720972">[9 more]</label></div><br/><div class="children"><div class="content">I really don’t see the difference between force pushing and not when you are going to squash merge anyway.</div><br/><div id="37721188" class="c"><input type="checkbox" id="c-37721188" checked=""/><div class="controls bullet"><span class="by">mbakke</span><span>|</span><a href="#37720280">root</a><span>|</span><a href="#37720972">parent</a><span>|</span><a href="#37721130">next</a><span>|</span><label class="collapse" for="c-37721188">[-]</label><label class="expand" for="c-37721188">[1 more]</label></div><br/><div class="children"><div class="content">Force pushes makes reviews hard to follow, especially if there are multiple rounds. GitLab handles it much better.<p>Relatedly, does GitHub merge understand !squash and !fixup commands? I kind of gave up on those and just accepted a few trailing bugfix commits on PRs to not mess up peoples reviews (some projects also invalidate review on force push).</div><br/></div></div><div id="37721130" class="c"><input type="checkbox" id="c-37721130" checked=""/><div class="controls bullet"><span class="by">eddythompson80</span><span>|</span><a href="#37720280">root</a><span>|</span><a href="#37720972">parent</a><span>|</span><a href="#37721188">prev</a><span>|</span><a href="#37721640">next</a><span>|</span><label class="collapse" for="c-37721130">[-]</label><label class="expand" for="c-37721130">[7 more]</label></div><br/><div class="children"><div class="content">I’m assuming they mean squash merging into main once the PR is accepted. That way you have 1 commit on main that links back to 1 PR with N commits on it. Which is easier to follow on main branch rather than a million commits per PR</div><br/><div id="37721249" class="c"><input type="checkbox" id="c-37721249" checked=""/><div class="controls bullet"><span class="by">mbakke</span><span>|</span><a href="#37720280">root</a><span>|</span><a href="#37721130">parent</a><span>|</span><a href="#37721640">next</a><span>|</span><label class="collapse" for="c-37721249">[-]</label><label class="expand" for="c-37721249">[6 more]</label></div><br/><div class="children"><div class="content">That makes &quot;git bisect&quot; and &quot;git blame&quot; fairly useless. Please don&#x27;t do that. Better to keep &quot;oops&quot; commits than squashing a series of logical changes into one monster commit.</div><br/><div id="37721357" class="c"><input type="checkbox" id="c-37721357" checked=""/><div class="controls bullet"><span class="by">eddythompson80</span><span>|</span><a href="#37720280">root</a><span>|</span><a href="#37721249">parent</a><span>|</span><a href="#37721278">next</a><span>|</span><label class="collapse" for="c-37721357">[-]</label><label class="expand" for="c-37721357">[3 more]</label></div><br/><div class="children"><div class="content">I don’t think there is a one size fits all answer here. “Oops” commits make blame useless too plus they make following any meaningful change very hard.<p>You want small commits in main, so send small PRs. If you have a feature, you can do a feature branch and merge into it the small commits then merge (don’t squash) feature branch into main.</div><br/><div id="37721437" class="c"><input type="checkbox" id="c-37721437" checked=""/><div class="controls bullet"><span class="by">mbakke</span><span>|</span><a href="#37720280">root</a><span>|</span><a href="#37721357">parent</a><span>|</span><a href="#37721278">next</a><span>|</span><label class="collapse" for="c-37721437">[-]</label><label class="expand" for="c-37721437">[2 more]</label></div><br/><div class="children"><div class="content">I see now that the grandparent was <i>enforcing</i> squash commits, did not mean to single out your comment.<p>It just blows my mind as someone with a somewhat perfectionist approach to rebasing (to the extent I sometimes intentionally break up or reorder commits to make the changes more intentional or natural, even when it causes nasty local merge conflicts) :P</div><br/><div id="37721542" class="c"><input type="checkbox" id="c-37721542" checked=""/><div class="controls bullet"><span class="by">eddythompson80</span><span>|</span><a href="#37720280">root</a><span>|</span><a href="#37721437">parent</a><span>|</span><a href="#37721278">next</a><span>|</span><label class="collapse" for="c-37721542">[-]</label><label class="expand" for="c-37721542">[1 more]</label></div><br/><div class="children"><div class="content">Well, I’d appreciate it if I collaborate on a repo with you. I end up giving up commit hygiene due to the absolute lack of interest from folks I work with unfortunately :)</div><br/></div></div></div></div></div></div><div id="37721278" class="c"><input type="checkbox" id="c-37721278" checked=""/><div class="controls bullet"><span class="by">juped</span><span>|</span><a href="#37720280">root</a><span>|</span><a href="#37721249">parent</a><span>|</span><a href="#37721357">prev</a><span>|</span><a href="#37721640">next</a><span>|</span><label class="collapse" for="c-37721278">[-]</label><label class="expand" for="c-37721278">[2 more]</label></div><br/><div class="children"><div class="content">&quot;oops&quot; commits are bad for this too (harder to find the regression when there&#x27;s unrelated broken states), but you&#x27;re right that it&#x27;s less bad.<p>Note that you can bisect --first-parent if you want the &quot;just find the topic branch that introduced this&quot; behavior, without taking away the ability to find the actual commit!</div><br/><div id="37721376" class="c"><input type="checkbox" id="c-37721376" checked=""/><div class="controls bullet"><span class="by">mbakke</span><span>|</span><a href="#37720280">root</a><span>|</span><a href="#37721278">parent</a><span>|</span><a href="#37721640">next</a><span>|</span><label class="collapse" for="c-37721376">[-]</label><label class="expand" for="c-37721376">[1 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t know about --first-parent, thanks! That gives me something to do while narrowing down the exact commit :)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37720577" class="c"><input type="checkbox" id="c-37720577" checked=""/><div class="controls bullet"><span class="by">tmpX7dMeXU</span><span>|</span><a href="#37720280">parent</a><span>|</span><a href="#37721640">prev</a><span>|</span><a href="#37719991">next</a><span>|</span><label class="collapse" for="c-37720577">[-]</label><label class="expand" for="c-37720577">[2 more]</label></div><br/><div class="children"><div class="content">I’ve been contemplating pulling the trigger on this one myself. I’m pretty much sold on it. I’ve been on board with squash merging for years. Best thing I’ve ever done for our project. I eventually came to the realisation that the majority of people who were against it were so because some purist greybeard had beat it into them.</div><br/><div id="37722196" class="c"><input type="checkbox" id="c-37722196" checked=""/><div class="controls bullet"><span class="by">iimblack</span><span>|</span><a href="#37720280">root</a><span>|</span><a href="#37720577">parent</a><span>|</span><a href="#37719991">next</a><span>|</span><label class="collapse" for="c-37722196">[-]</label><label class="expand" for="c-37722196">[1 more]</label></div><br/><div class="children"><div class="content">Majority of people aren’t making atomic commits. In the off chance they are it’s not hard to switch from squash for those one-offs.</div><br/></div></div></div></div></div></div><div id="37719991" class="c"><input type="checkbox" id="c-37719991" checked=""/><div class="controls bullet"><span class="by">m3drano</span><span>|</span><a href="#37720280">prev</a><span>|</span><a href="#37720882">next</a><span>|</span><label class="collapse" for="c-37719991">[-]</label><label class="expand" for="c-37719991">[4 more]</label></div><br/><div class="children"><div class="content">IIUC, he&#x27;s referring to a workflow that Gerrit implements 1-to-1, isn&#x27;t he?</div><br/><div id="37720839" class="c"><input type="checkbox" id="c-37720839" checked=""/><div class="controls bullet"><span class="by">imran-iq</span><span>|</span><a href="#37719991">parent</a><span>|</span><a href="#37720233">next</a><span>|</span><label class="collapse" for="c-37720839">[-]</label><label class="expand" for="c-37720839">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the email flow that&#x27;s existed before gerrit and phabricator. Both of which implemented because it makes sense. Then github came along and here we are.</div><br/><div id="37721768" class="c"><input type="checkbox" id="c-37721768" checked=""/><div class="controls bullet"><span class="by">tomasreimers</span><span>|</span><a href="#37719991">root</a><span>|</span><a href="#37720839">parent</a><span>|</span><a href="#37720233">next</a><span>|</span><label class="collapse" for="c-37721768">[-]</label><label class="expand" for="c-37721768">[1 more]</label></div><br/><div class="children"><div class="content">This. Every time people talk about how pull requests &#x2F;should&#x2F; work, I point to them that&#x27;s largely how they did work...</div><br/></div></div></div></div><div id="37720233" class="c"><input type="checkbox" id="c-37720233" checked=""/><div class="controls bullet"><span class="by">da39a3ee</span><span>|</span><a href="#37719991">parent</a><span>|</span><a href="#37720839">prev</a><span>|</span><a href="#37720882">next</a><span>|</span><label class="collapse" for="c-37720233">[-]</label><label class="expand" for="c-37720233">[1 more]</label></div><br/><div class="children"><div class="content">Yes, he says so two and a half times.</div><br/></div></div></div></div><div id="37720882" class="c"><input type="checkbox" id="c-37720882" checked=""/><div class="controls bullet"><span class="by">cerved</span><span>|</span><a href="#37719991">prev</a><span>|</span><a href="#37723974">next</a><span>|</span><label class="collapse" for="c-37720882">[-]</label><label class="expand" for="c-37720882">[4 more]</label></div><br/><div class="children"><div class="content">More and more I&#x27;m starting to appreciate the email based PR</div><br/><div id="37721594" class="c"><input type="checkbox" id="c-37721594" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#37720882">parent</a><span>|</span><a href="#37721338">next</a><span>|</span><label class="collapse" for="c-37721594">[-]</label><label class="expand" for="c-37721594">[1 more]</label></div><br/><div class="children"><div class="content">Mailing lists are a bit arcane but I agree nonetheless. Learning how to use them is worth it. The changesets proposed by TFA are essentially what the Linux kernel has been doing with email for a long time.</div><br/></div></div><div id="37721338" class="c"><input type="checkbox" id="c-37721338" checked=""/><div class="controls bullet"><span class="by">mbakke</span><span>|</span><a href="#37720882">parent</a><span>|</span><a href="#37721594">prev</a><span>|</span><a href="#37723974">next</a><span>|</span><label class="collapse" for="c-37721338">[-]</label><label class="expand" for="c-37721338">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s simple, scalable, and has none of the mentioned problems.<p>The main drawback is that contributors have to learn a proper mail user agent (Gmail is notoriously bad with patches).</div><br/><div id="37723860" class="c"><input type="checkbox" id="c-37723860" checked=""/><div class="controls bullet"><span class="by">wiktor-k</span><span>|</span><a href="#37720882">root</a><span>|</span><a href="#37721338">parent</a><span>|</span><a href="#37723974">next</a><span>|</span><label class="collapse" for="c-37723860">[-]</label><label class="expand" for="c-37723860">[1 more]</label></div><br/><div class="children"><div class="content">I guess for sending parches using git tooling instead of an email client works best. At least according to <a href="https:&#x2F;&#x2F;git-send-email.io&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;git-send-email.io&#x2F;</a></div><br/></div></div></div></div></div></div><div id="37723974" class="c"><input type="checkbox" id="c-37723974" checked=""/><div class="controls bullet"><span class="by">SergeAx</span><span>|</span><a href="#37720882">prev</a><span>|</span><a href="#37720701">next</a><span>|</span><label class="collapse" for="c-37723974">[-]</label><label class="expand" for="c-37723974">[1 more]</label></div><br/><div class="children"><div class="content">This sounds like what they have in GitLab merge request flow: <a href="https:&#x2F;&#x2F;docs.gitlab.com&#x2F;ee&#x2F;user&#x2F;project&#x2F;merge_requests&#x2F;versions.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.gitlab.com&#x2F;ee&#x2F;user&#x2F;project&#x2F;merge_requests&#x2F;versi...</a></div><br/></div></div><div id="37720701" class="c"><input type="checkbox" id="c-37720701" checked=""/><div class="controls bullet"><span class="by">codeapprove</span><span>|</span><a href="#37723974">prev</a><span>|</span><a href="#37722271">next</a><span>|</span><label class="collapse" for="c-37720701">[-]</label><label class="expand" for="c-37720701">[21 more]</label></div><br/><div class="children"><div class="content">I agree 1000%. I’m the creator of what I believe is a better review interface for GitHub (<a href="https:&#x2F;&#x2F;codeapprove.com" rel="nofollow noreferrer">https:&#x2F;&#x2F;codeapprove.com</a>) but there are also many others:<p><pre><code>  * CodeApprove (codeapprove.com)
  * Graphite (graphite.dev)
  * Reviewable (reviewable.io)
  * Axolo (axolo.co)
  * Viezly (viezly.com)
  * Mergeboard (mergeboard.com)
  * Codestream (codestream.com)
  * Pullpo (pullpo.io)
  * ReviewPad (reviewpad.com)
  * Planar (useplanar.com)
  * Visibly (visibly.dev)
  * Codelantis (codelantis.com)

</code></pre>
I think in the end we should not expect GitHub to provide the best option here. We should expect them to provide a basic option (which they do) and for sophisticated consumers to pay more for a much better option. Everyone should be shopping for code review tools!</div><br/><div id="37721211" class="c"><input type="checkbox" id="c-37721211" checked=""/><div class="controls bullet"><span class="by">noirscape</span><span>|</span><a href="#37720701">parent</a><span>|</span><a href="#37720949">next</a><span>|</span><label class="collapse" for="c-37721211">[-]</label><label class="expand" for="c-37721211">[1 more]</label></div><br/><div class="children"><div class="content">I disagree on this; GitHub should be building the best option here if they have the resources to do so. The fact that the review interface is as basic as it and so prone to accidentally marking the wrong comments as outdated is a major issue (one that other software like Phorge[0] already shows is possible if we&#x27;re sticking to the realm of &quot;non-mailing client reliant git servers&quot;).<p>Having to bolt extra features on top of GitHub to make it work properly is a shortcoming of GitHub, it shouldn&#x27;t be an opportunity to build more tooling the customer has to pay for on top of it. Granted, I can see that conversation would get us nowhere given your income relies on selling people features GitHub is languishing on - you have an obvious interest in keeping that feature shitty.<p>[0]: Phabricator was disabled in 2022, Phorge is the new fork.</div><br/></div></div><div id="37720949" class="c"><input type="checkbox" id="c-37720949" checked=""/><div class="controls bullet"><span class="by">rat9988</span><span>|</span><a href="#37720701">parent</a><span>|</span><a href="#37721211">prev</a><span>|</span><a href="#37721432">next</a><span>|</span><label class="collapse" for="c-37720949">[-]</label><label class="expand" for="c-37720949">[7 more]</label></div><br/><div class="children"><div class="content">&quot;I think in the end we should not expect GitHub to provide the best option here. We should expect them to provide a basic option (which they do) and for sophisticated consumers to pay more for a much better option. Everyone should be shopping for code review tools!
&quot;<p>I understand this linke of thinking might suit you but I fear it is not as convincing as it sounds to you. At least it&#x27;s not to me.</div><br/><div id="37721052" class="c"><input type="checkbox" id="c-37721052" checked=""/><div class="controls bullet"><span class="by">piotrkaminski</span><span>|</span><a href="#37720701">root</a><span>|</span><a href="#37720949">parent</a><span>|</span><a href="#37721432">next</a><span>|</span><label class="collapse" for="c-37721052">[-]</label><label class="expand" for="c-37721052">[6 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s how I like to think about it:  GitHub is a generalist.  They have a big platform with lots of features besides code review, so even though they also have lots of employees they won&#x27;t be able to focus on code review as much as a dedicated company could.  They also have a huge number of users to please so they can&#x27;t afford to rock the boat too much or make the learning curve too steep.<p>I think therefore it&#x27;s pretty much inevitable that if you need a more advanced code review tool you&#x27;ll end up picking a third party one.  Though admittedly, as the founder of Reviewable, that thinking does rather suit me too.  (&quot;It is difficult to get a man to understand something when his salary depends on his not understanding it&quot; and all that.  :D )</div><br/><div id="37721644" class="c"><input type="checkbox" id="c-37721644" checked=""/><div class="controls bullet"><span class="by">0x073</span><span>|</span><a href="#37720701">root</a><span>|</span><a href="#37721052">parent</a><span>|</span><a href="#37721463">next</a><span>|</span><label class="collapse" for="c-37721644">[-]</label><label class="expand" for="c-37721644">[4 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the reason as a company to pick GitHub? Pull request and everything around it are by far the most important part.<p>If i must pay for GitHub and an external tool, isn&#x27;t GitHub just an dumb overpriced git storage.</div><br/><div id="37721729" class="c"><input type="checkbox" id="c-37721729" checked=""/><div class="controls bullet"><span class="by">jacobegold</span><span>|</span><a href="#37720701">root</a><span>|</span><a href="#37721644">parent</a><span>|</span><a href="#37721734">next</a><span>|</span><label class="collapse" for="c-37721729">[-]</label><label class="expand" for="c-37721729">[1 more]</label></div><br/><div class="children"><div class="content">How you do PRs is definitely important, and should be part of a company&#x27;s consideration here, but remember that PRs are already a layer of abstraction over the SCM.  Self-hosting Git is definitely not as easy as setting up a GH account.<p>Not to mention that you get an easy way to spin up your CI&#x2F;CD workflows in GH Actions (which of course definitely has its own problems, which there was another popular HN post about recently). There&#x27;s a reason why it&#x27;s the default for new companies -- if there was something much better, it wouldn&#x27;t have the market share it does I think. Familiarity coming from OSS is also important.</div><br/></div></div><div id="37721734" class="c"><input type="checkbox" id="c-37721734" checked=""/><div class="controls bullet"><span class="by">piotrkaminski</span><span>|</span><a href="#37720701">root</a><span>|</span><a href="#37721644">parent</a><span>|</span><a href="#37721729">prev</a><span>|</span><a href="#37721694">next</a><span>|</span><label class="collapse" for="c-37721734">[-]</label><label class="expand" for="c-37721734">[1 more]</label></div><br/><div class="children"><div class="content">Most frequently, I think it&#x27;s because you want a single platform to store all company code, but not all teams agree on using GitHub PRs vs a more advanced code review tool.  Other potential reasons include having access to the other GitHub features:  issues, actions, security stuff, the merge queue, etc.  You could pull all these together from less-overpriced more-specialized alternatives, of course, but sometimes it&#x27;s nice to have a single integrated platform even if you decide to replace one of its features.</div><br/></div></div><div id="37721694" class="c"><input type="checkbox" id="c-37721694" checked=""/><div class="controls bullet"><span class="by">fahhem</span><span>|</span><a href="#37720701">root</a><span>|</span><a href="#37721644">parent</a><span>|</span><a href="#37721734">prev</a><span>|</span><a href="#37721463">next</a><span>|</span><label class="collapse" for="c-37721694">[-]</label><label class="expand" for="c-37721694">[1 more]</label></div><br/><div class="children"><div class="content">GitHub is a platform with dozens of tools, I think of it as a basic toolbox. It&#x27;s great, but if you&#x27;re hammering nails all day, you should invest in a nailgun. Doesn&#x27;t mean you don&#x27;t use the hammer or the wrench in your toolbox, but when you care about one task a lot, you invest in the tool to do that task better</div><br/></div></div></div></div><div id="37721463" class="c"><input type="checkbox" id="c-37721463" checked=""/><div class="controls bullet"><span class="by">allendoerfer</span><span>|</span><a href="#37720701">root</a><span>|</span><a href="#37721052">parent</a><span>|</span><a href="#37721644">prev</a><span>|</span><a href="#37721432">next</a><span>|</span><label class="collapse" for="c-37721463">[-]</label><label class="expand" for="c-37721463">[1 more]</label></div><br/><div class="children"><div class="content">GitHub is Microsoft, which also does Excel, Azure, Windows, Teams and many other platforms, each bigger than a code review tool.</div><br/></div></div></div></div></div></div><div id="37721432" class="c"><input type="checkbox" id="c-37721432" checked=""/><div class="controls bullet"><span class="by">mhh__</span><span>|</span><a href="#37720701">parent</a><span>|</span><a href="#37720949">prev</a><span>|</span><a href="#37721331">next</a><span>|</span><label class="collapse" for="c-37721432">[-]</label><label class="expand" for="c-37721432">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s like saying it&#x27;s OK to expect (say) Ford to make a car with no steering wheel. GitHub basically define the baseline for the entire industry and have millions upon millions to blow on trying to do better.<p>(OK, Saab did actually do that once but they&#x27;re weird)</div><br/><div id="37721611" class="c"><input type="checkbox" id="c-37721611" checked=""/><div class="controls bullet"><span class="by">ravenstine</span><span>|</span><a href="#37720701">root</a><span>|</span><a href="#37721432">parent</a><span>|</span><a href="#37721331">next</a><span>|</span><label class="collapse" for="c-37721611">[-]</label><label class="expand" for="c-37721611">[1 more]</label></div><br/><div class="children"><div class="content">The two aren&#x27;t even remotely comparable. Whose compny went out of control and crashed because of GitHub missing a feature with their code review?</div><br/></div></div></div></div><div id="37721331" class="c"><input type="checkbox" id="c-37721331" checked=""/><div class="controls bullet"><span class="by">jayroh</span><span>|</span><a href="#37720701">parent</a><span>|</span><a href="#37721432">prev</a><span>|</span><a href="#37721285">next</a><span>|</span><label class="collapse" for="c-37721331">[-]</label><label class="expand" for="c-37721331">[3 more]</label></div><br/><div class="children"><div class="content">Question: does CodeApprove place related files in closer proximity during review? I would _love_ to have a class and its test next to each other instead of sorted alphabetically. I&#x27;m tired of jumping around all over the place, trying to traverse through my review thought process.</div><br/><div id="37721543" class="c"><input type="checkbox" id="c-37721543" checked=""/><div class="controls bullet"><span class="by">fahhem</span><span>|</span><a href="#37720701">root</a><span>|</span><a href="#37721331">parent</a><span>|</span><a href="#37721499">next</a><span>|</span><label class="collapse" for="c-37721543">[-]</label><label class="expand" for="c-37721543">[1 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t speak for CodeApprove, but Reviewable has file grouping capabilities so users can groups files based on anything they want (using a javascript function to do it)</div><br/></div></div></div></div><div id="37721285" class="c"><input type="checkbox" id="c-37721285" checked=""/><div class="controls bullet"><span class="by">dansiemens</span><span>|</span><a href="#37720701">parent</a><span>|</span><a href="#37721331">prev</a><span>|</span><a href="#37721064">next</a><span>|</span><label class="collapse" for="c-37721285">[-]</label><label class="expand" for="c-37721285">[2 more]</label></div><br/><div class="children"><div class="content">&gt; We should expect them to provide a basic option (which they do) and for sophisticated consumers to pay more for a much better option<p>GitHub is fairly feature rich imo, _especially_ when compared to something like CodeCommit on AWS. I’ve been forced to use CodeCommit on client engagements and it’s absolutely horrid. Honestly if your tool supported CodeCommit I’d say the value proposition would skyrocket.</div><br/><div id="37721321" class="c"><input type="checkbox" id="c-37721321" checked=""/><div class="controls bullet"><span class="by">piotrkaminski</span><span>|</span><a href="#37720701">root</a><span>|</span><a href="#37721285">parent</a><span>|</span><a href="#37721064">next</a><span>|</span><label class="collapse" for="c-37721321">[-]</label><label class="expand" for="c-37721321">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious, are you allowed to name any folks using CodeCommit?  I thought it wasn&#x27;t particularly popular.</div><br/></div></div></div></div><div id="37721064" class="c"><input type="checkbox" id="c-37721064" checked=""/><div class="controls bullet"><span class="by">baby</span><span>|</span><a href="#37720701">parent</a><span>|</span><a href="#37721285">prev</a><span>|</span><a href="#37721819">next</a><span>|</span><label class="collapse" for="c-37721064">[-]</label><label class="expand" for="c-37721064">[2 more]</label></div><br/><div class="children"><div class="content">There’s also the new open source git thing from meta right</div><br/><div id="37721148" class="c"><input type="checkbox" id="c-37721148" checked=""/><div class="controls bullet"><span class="by">xixixao</span><span>|</span><a href="#37720701">root</a><span>|</span><a href="#37721064">parent</a><span>|</span><a href="#37721819">next</a><span>|</span><label class="collapse" for="c-37721148">[-]</label><label class="expand" for="c-37721148">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;sapling-scm.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;sapling-scm.com&#x2F;</a></div><br/></div></div></div></div><div id="37721819" class="c"><input type="checkbox" id="c-37721819" checked=""/><div class="controls bullet"><span class="by">jacobegold</span><span>|</span><a href="#37720701">parent</a><span>|</span><a href="#37721064">prev</a><span>|</span><a href="#37721410">next</a><span>|</span><label class="collapse" for="c-37721819">[-]</label><label class="expand" for="c-37721819">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m keeping an eye on Pierre (<a href="https:&#x2F;&#x2F;pierre.co&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;pierre.co&#x2F;</a>) as well — not being subject to the whims of GitHub makes for some interesting ideas!</div><br/></div></div><div id="37721410" class="c"><input type="checkbox" id="c-37721410" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#37720701">parent</a><span>|</span><a href="#37721819">prev</a><span>|</span><a href="#37722271">next</a><span>|</span><label class="collapse" for="c-37721410">[-]</label><label class="expand" for="c-37721410">[2 more]</label></div><br/><div class="children"><div class="content">Average org already pays so many saas and I have to pay one for code reviews too when I&#x27;m already paying GitHub?<p>Also, there isn&#x27;t only paying customers having this issue but large OS too.</div><br/><div id="37721567" class="c"><input type="checkbox" id="c-37721567" checked=""/><div class="controls bullet"><span class="by">jacobegold</span><span>|</span><a href="#37720701">root</a><span>|</span><a href="#37721410">parent</a><span>|</span><a href="#37722271">next</a><span>|</span><label class="collapse" for="c-37721567">[-]</label><label class="expand" for="c-37721567">[1 more]</label></div><br/><div class="children"><div class="content">Large OSS feels like a different use case than the big company one, to be honest -- I think that what maintainers care about is vastly different than what companies do.  GitHub feels optimized for the former (OSS) as it is today.</div><br/></div></div></div></div></div></div><div id="37722271" class="c"><input type="checkbox" id="c-37722271" checked=""/><div class="controls bullet"><span class="by">facorreia</span><span>|</span><a href="#37720701">prev</a><span>|</span><a href="#37723894">next</a><span>|</span><label class="collapse" for="c-37722271">[-]</label><label class="expand" for="c-37722271">[4 more]</label></div><br/><div class="children"><div class="content">It’s very weird that PR approvals remain “approved” after changes to the PR that was approved.</div><br/><div id="37722698" class="c"><input type="checkbox" id="c-37722698" checked=""/><div class="controls bullet"><span class="by">atq2119</span><span>|</span><a href="#37722271">parent</a><span>|</span><a href="#37722723">next</a><span>|</span><label class="collapse" for="c-37722698">[-]</label><label class="expand" for="c-37722698">[1 more]</label></div><br/><div class="children"><div class="content">This can go either way, and it&#x27;s ultimately a social problem, not a technical one.<p>I find that I fairly often notice some minor issues, like a typo in a comment. I do want the submitter to fix those, but making them go through a full review cycles is an unfortunate waste of time as I usually trust them to be adult enough to just make the fix and submit.<p>So I find myself wanting to say &quot;Approve modulo these minor issues&quot;. If a project wants to allow this, it needs to either not require approvals, or allow approvals to remain even after changes to a PR.</div><br/></div></div><div id="37722723" class="c"><input type="checkbox" id="c-37722723" checked=""/><div class="controls bullet"><span class="by">Noumenon72</span><span>|</span><a href="#37722271">parent</a><span>|</span><a href="#37722698">prev</a><span>|</span><a href="#37722345">next</a><span>|</span><label class="collapse" for="c-37722723">[-]</label><label class="expand" for="c-37722723">[1 more]</label></div><br/><div class="children"><div class="content">Typical PR flow on my team for PRs to dev branch is reviewer approves with comments, then submitter addresses comments with new commits and merges (unless they judge the new commits are significant changes). This makes it lighter weight to offer comments since it doesn&#x27;t mean another delay for a rereview. The reviewer gets emailed about any new commits that come in, so all changes do get seen.<p>Github makes it easy to review just the changes since your last approval, a feature which I think obviates the need for changesets as in the OP.</div><br/></div></div><div id="37722345" class="c"><input type="checkbox" id="c-37722345" checked=""/><div class="controls bullet"><span class="by">wcedmisten</span><span>|</span><a href="#37722271">parent</a><span>|</span><a href="#37722723">prev</a><span>|</span><a href="#37723894">next</a><span>|</span><label class="collapse" for="c-37722345">[-]</label><label class="expand" for="c-37722345">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a setting to automatically revoke approvals as &quot;stale&quot; after new changes get pushed</div><br/></div></div></div></div><div id="37723894" class="c"><input type="checkbox" id="c-37723894" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#37722271">prev</a><span>|</span><a href="#37721199">next</a><span>|</span><label class="collapse" for="c-37723894">[-]</label><label class="expand" for="c-37723894">[1 more]</label></div><br/><div class="children"><div class="content">A lot of people mentioning Gerrit, but Gitlab seems to support this too. It also removes approvals for the new changeset in case any were already present (by default, you can now disable this). It seems to have supported changesets forever so I&#x27;m surprised GitHub doesn&#x27;t.<p>I&#x27;ve also considered not allowing contributors to force push. Instead any changes would be pushed (possibly as fixup! or squash! commits) so all history of the merge request is easily accessible. To be rebased&#x2F;squashed later, of course.</div><br/></div></div><div id="37721199" class="c"><input type="checkbox" id="c-37721199" checked=""/><div class="controls bullet"><span class="by">kemayo</span><span>|</span><a href="#37723894">prev</a><span>|</span><a href="#37719979">next</a><span>|</span><label class="collapse" for="c-37721199">[-]</label><label class="expand" for="c-37721199">[3 more]</label></div><br/><div class="children"><div class="content">I work with Gerrit in my job, and find a stack of patches to be a useful way to deal with things... but I&#x27;ve also seen that it <i>definitely</i> has a learning curve for people who&#x27;re not used to it. There&#x27;s something to be said for the GitHub pull-request &quot;just smush together all the commits on this branch&quot; model in terms of ease of understanding.<p>It&#x27;s possible that better tooling would help there, of course.<p>(A surprisingly common pain-point with Gerrit is when you&#x27;ve wound up with a semi-long-lasting stack of patches for some reason, and then you develop a branching tree of sub-patches and need to rebase them all when you make some change higher up. The answer of &quot;don&#x27;t let a stack last long enough that you need to do that&quot; has an appeal, of course.)</div><br/><div id="37721548" class="c"><input type="checkbox" id="c-37721548" checked=""/><div class="controls bullet"><span class="by">jacobegold</span><span>|</span><a href="#37721199">parent</a><span>|</span><a href="#37721722">next</a><span>|</span><label class="collapse" for="c-37721548">[-]</label><label class="expand" for="c-37721548">[1 more]</label></div><br/><div class="children"><div class="content">Better tooling is definitely the answer here -- I used to work at Facebook where rebasing dependent patches in Mercurial when you needed to adjust something felt like a first-classed flow, and I&#x27;m currently working on a tool that does the same thing, but on top of Git and GitHub.</div><br/></div></div><div id="37721722" class="c"><input type="checkbox" id="c-37721722" checked=""/><div class="controls bullet"><span class="by">llimllib</span><span>|</span><a href="#37721199">parent</a><span>|</span><a href="#37721548">prev</a><span>|</span><a href="#37719979">next</a><span>|</span><label class="collapse" for="c-37721722">[-]</label><label class="expand" for="c-37721722">[1 more]</label></div><br/><div class="children"><div class="content">At my previous job the cofounder introduced gerrit; I loved the model but it became immediately apparent that it was too complex for our team and we abandoned it after I spent a ton of time doing tech support for teammates.</div><br/></div></div></div></div><div id="37719979" class="c"><input type="checkbox" id="c-37719979" checked=""/><div class="controls bullet"><span class="by">setheron</span><span>|</span><a href="#37721199">prev</a><span>|</span><a href="#37721295">next</a><span>|</span><label class="collapse" for="c-37719979">[-]</label><label class="expand" for="c-37719979">[5 more]</label></div><br/><div class="children"><div class="content">Surprised he didn&#x27;t refer to stack PR based systems like Gerrit for reference.<p>I have never tried those apps that build a top GitHub. I remember Facebook&#x27;s sapling has a web client as well that does stack reviews.</div><br/><div id="37720004" class="c"><input type="checkbox" id="c-37720004" checked=""/><div class="controls bullet"><span class="by">eyelidlessness</span><span>|</span><a href="#37719979">parent</a><span>|</span><a href="#37720554">next</a><span>|</span><label class="collapse" for="c-37720004">[-]</label><label class="expand" for="c-37720004">[1 more]</label></div><br/><div class="children"><div class="content">There are two mentions of Gerrit in the article. Granted neither goes into detail, but both reference it as prior art on the topic.</div><br/></div></div><div id="37720554" class="c"><input type="checkbox" id="c-37720554" checked=""/><div class="controls bullet"><span class="by">bittermandel</span><span>|</span><a href="#37719979">parent</a><span>|</span><a href="#37720004">prev</a><span>|</span><a href="#37721578">next</a><span>|</span><label class="collapse" for="c-37720554">[-]</label><label class="expand" for="c-37720554">[1 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t he do just that?<p>&gt;  They&#x27;re already a well-explored user experience problem in existing products like Gerrit and Phabricator.</div><br/></div></div><div id="37721578" class="c"><input type="checkbox" id="c-37721578" checked=""/><div class="controls bullet"><span class="by">jacobegold</span><span>|</span><a href="#37719979">parent</a><span>|</span><a href="#37720554">prev</a><span>|</span><a href="#37720154">next</a><span>|</span><label class="collapse" for="c-37721578">[-]</label><label class="expand" for="c-37721578">[1 more]</label></div><br/><div class="children"><div class="content">I used to work at FB, and unfortunately the Sapling review client that shows GH PRs has nothing on the the actual internal code review tooling at Facebook (now called Diffs, formerly Phabricator). I miss that tool so much</div><br/></div></div><div id="37720154" class="c"><input type="checkbox" id="c-37720154" checked=""/><div class="controls bullet"><span class="by">adm_</span><span>|</span><a href="#37719979">parent</a><span>|</span><a href="#37721578">prev</a><span>|</span><a href="#37721295">next</a><span>|</span><label class="collapse" for="c-37720154">[-]</label><label class="expand" for="c-37720154">[1 more]</label></div><br/><div class="children"><div class="content">I believe sapling uses <a href="https:&#x2F;&#x2F;github.com&#x2F;ezyang&#x2F;ghstack">https:&#x2F;&#x2F;github.com&#x2F;ezyang&#x2F;ghstack</a> under the hood for stacked PR.</div><br/></div></div></div></div><div id="37721295" class="c"><input type="checkbox" id="c-37721295" checked=""/><div class="controls bullet"><span class="by">juped</span><span>|</span><a href="#37719979">prev</a><span>|</span><a href="#37721511">next</a><span>|</span><label class="collapse" for="c-37721295">[-]</label><label class="expand" for="c-37721295">[3 more]</label></div><br/><div class="children"><div class="content">I love the amazing, advanced submission and review workflow you can see if you click anything with PATCH in it at <a href="https:&#x2F;&#x2F;public-inbox.org&#x2F;git&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;public-inbox.org&#x2F;git&#x2F;</a>. The best part is that it&#x27;s fully integrated with Git!<p>It&#x27;s distressing to me that Github spends so much money making Git worse. (There&#x27;s some good parts of their whole product lineup, but the Git integration is supposed to be the centerpiece.)</div><br/><div id="37722761" class="c"><input type="checkbox" id="c-37722761" checked=""/><div class="controls bullet"><span class="by">atq2119</span><span>|</span><a href="#37721295">parent</a><span>|</span><a href="#37722758">next</a><span>|</span><label class="collapse" for="c-37722761">[-]</label><label class="expand" for="c-37722761">[1 more]</label></div><br/><div class="children"><div class="content">I agree that this is how development <i>should</i> work. But let&#x27;s be fair: The claim that this &quot;is fully integrated with Git&quot; is at least misleading.<p>Yes, there&#x27;s git format-patch, git send-email, and git am.<p>But what I would really like to see in that link you shared is links that go directly to commit hashes that I can git fetch locally to see a patch or patch set in context; and links between different versions of a patch set; and so on. After all, git am does sometimes fail, e.g. because you have an incompatible base revision. And being able to push with confidence the version that you had in the email is also a plus.</div><br/></div></div><div id="37722758" class="c"><input type="checkbox" id="c-37722758" checked=""/><div class="controls bullet"><span class="by">Noumenon72</span><span>|</span><a href="#37721295">parent</a><span>|</span><a href="#37722761">prev</a><span>|</span><a href="#37721511">next</a><span>|</span><label class="collapse" for="c-37722758">[-]</label><label class="expand" for="c-37722758">[1 more]</label></div><br/><div class="children"><div class="content">All I see is normal code review comments plus diffs, but as an email thread instead of a UI that lets comments be attached to the code they&#x27;re discussing. And it&#x27;s hard to read because no markdown.</div><br/></div></div></div></div><div id="37721511" class="c"><input type="checkbox" id="c-37721511" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#37721295">prev</a><span>|</span><a href="#37720540">next</a><span>|</span><label class="collapse" for="c-37721511">[-]</label><label class="expand" for="c-37721511">[14 more]</label></div><br/><div class="children"><div class="content">Jm2c, but by far the best place I&#x27;ve ever worked (my current client) we don&#x27;t do code reviews at all unless the author wants feedback.<p>PRs are good ways to defend your code base from bad code, and they were born in open source where you literally have no clue who the contributor is, but years of experience left me convinced that I don&#x27;t want such a system where there&#x27;s constant need to overview each other&#x27;s work.<p>I want to work with a team where there is high respect and trust. A team where I know I won&#x27;t like or love all the decisions others make, but I trust their judgement. Maybe they did indeed hack an ugly solution cheating the type system and automated controls. So what? What matters is if they have done so for good reasons (stuff was super urgent, a proper solution was just not worth the effort as the feature&#x2F;fix was really not important for the business).<p>This made development speed skyrocket and I&#x27;m no longer bound to infinite code reviews as if we were sending rockets on Mars.<p>I also want to say, code quality is high, but this stems both from working with great individuals that can be trusted and from much higher interaction speed.</div><br/><div id="37721550" class="c"><input type="checkbox" id="c-37721550" checked=""/><div class="controls bullet"><span class="by">neo2006</span><span>|</span><a href="#37721511">parent</a><span>|</span><a href="#37721666">next</a><span>|</span><label class="collapse" for="c-37721550">[-]</label><label class="expand" for="c-37721550">[5 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see code review as an overwatch but a good communication tool and a way to think about problems collectively. Code review reduce bugs because it permit to have people think about the problem from multiple angles. About decisions, I think important  design decisions need to be taken prior to the code review steps ,and also reviewed.
I&#x27;m not sure what context you worked in that gave you that opinion about code review being a sign of distrust and I think the problem lay within the culture in those places not the code review practice it self.</div><br/><div id="37721602" class="c"><input type="checkbox" id="c-37721602" checked=""/><div class="controls bullet"><span class="by">duncan-donuts</span><span>|</span><a href="#37721511">root</a><span>|</span><a href="#37721550">parent</a><span>|</span><a href="#37721771">next</a><span>|</span><label class="collapse" for="c-37721602">[-]</label><label class="expand" for="c-37721602">[2 more]</label></div><br/><div class="children"><div class="content">I don’t mind code reviews so I’m not really defending who you’re replying to. There is another way to think about this tho and I actually have found this practice to be light years more effective than code reviews. Where I work we have a practice where before you start doing a ton of work on your card&#x2F;ticket you should find someone on your team, explain the problem to them, and show them how you’re going to do the work. This gives your teammates an opportunity to give you feedback before anyone has done anything, and you can both poke holes in design decisions before anyone has done anything they feel strongly about. If you do this process 95% of code reviews are pretty much worthless.</div><br/><div id="37721732" class="c"><input type="checkbox" id="c-37721732" checked=""/><div class="controls bullet"><span class="by">neo2006</span><span>|</span><a href="#37721511">root</a><span>|</span><a href="#37721602">parent</a><span>|</span><a href="#37721771">next</a><span>|</span><label class="collapse" for="c-37721732">[-]</label><label class="expand" for="c-37721732">[1 more]</label></div><br/><div class="children"><div class="content">I fully agree, we also do this and this is the design review I alluded to.
That said, I think both have different purpose. The design review is more about the approach and the high-level implementation. The code review is about the implementation details.
Also, a great aspect often overlooked around code review is that it&#x27;s a great teaching tool if used right. Asking question go a long way and make both the reviewer and the reviewee learn.
Code review is often looked to as a senior watching over what juniors are doing. In my experience it should be done for all levels and even juniors should review seniors PR as they can bring novel perspective and at least learn from the code by reviewing it.</div><br/></div></div></div></div><div id="37721771" class="c"><input type="checkbox" id="c-37721771" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#37721511">root</a><span>|</span><a href="#37721550">parent</a><span>|</span><a href="#37721602">prev</a><span>|</span><a href="#37721666">next</a><span>|</span><label class="collapse" for="c-37721771">[-]</label><label class="expand" for="c-37721771">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m gonna rephrase my previous point. What you say makes sense, but only if you understand that it takes away time, money and energies and after knowing it, and the impact of all this time drag you determine it&#x27;s worth it.<p>Might apply to huge products making millions $ every day. Sure, delivering a bug will be expensive.<p>Might apply when you can&#x27;t trust your colleagues (not skilled, reasonable or experienced enough).<p>Might apply if your code is niche but mission critical (maybe some safety system on a car or a dangerous tool, or surgery equipment).<p>Of course I agree with all you said.<p>But you&#x27;re writing some Java&#x2F;TS web app which isn&#x27;t raking much money, or has still to be launched, or your biggest focus is time to market to beat competitors and you&#x27;re wasting time on code reviews the author  hasn&#x27;t requested?<p>In this scenario (my current client) I want to have a team I can trust and gets stuff done. This does not imply that CRs don&#x27;t happen or design isn&#x27;t discussed, but it happens when it brings value or it is needed. And I like it that way, where we can build stuff, rather discussing how to build it.</div><br/><div id="37722246" class="c"><input type="checkbox" id="c-37722246" checked=""/><div class="controls bullet"><span class="by">neo2006</span><span>|</span><a href="#37721511">root</a><span>|</span><a href="#37721771">parent</a><span>|</span><a href="#37721666">next</a><span>|</span><label class="collapse" for="c-37722246">[-]</label><label class="expand" for="c-37722246">[1 more]</label></div><br/><div class="children"><div class="content">If we want to include the cost of a code review into the equation we should also include the cost of fixing a big that made it to production which is in most of the cases higher then code review. Skill is not a factor here, I work and worked  with some of the best engineers in the world and everyone write buggy code sometimes. Software engineering is a complex practice.
If you are writing some prototyping code or some code that will never make it to production or in a very early stage of a startup, sure I can understand your point.</div><br/></div></div></div></div></div></div><div id="37721666" class="c"><input type="checkbox" id="c-37721666" checked=""/><div class="controls bullet"><span class="by">scubbo</span><span>|</span><a href="#37721511">parent</a><span>|</span><a href="#37721550">prev</a><span>|</span><a href="#37723782">next</a><span>|</span><label class="collapse" for="c-37721666">[-]</label><label class="expand" for="c-37721666">[2 more]</label></div><br/><div class="children"><div class="content">I respect the thoughtfulness with which you made your point, but completely disagree. As another commenter stated - Code Reviews are, for me, primarily a method for communication and knowledge dissemination, secondarily a means to get a second pair of eyes on my work to ensure it&#x27;s legible and that I didn&#x27;t miss anything, and only as a distant third a means to &quot;protect&quot; the codebase.</div><br/><div id="37721699" class="c"><input type="checkbox" id="c-37721699" checked=""/><div class="controls bullet"><span class="by">jacobegold</span><span>|</span><a href="#37721511">root</a><span>|</span><a href="#37721666">parent</a><span>|</span><a href="#37723782">next</a><span>|</span><label class="collapse" for="c-37721699">[-]</label><label class="expand" for="c-37721699">[1 more]</label></div><br/><div class="children"><div class="content">Not to mention the value of a diff&#x2F;pull request&#x2F;changelist&#x2F;patch&#x2F;merge request (so many names...) and its corresponding discussion as a historical artifact for your team to reference later on!</div><br/></div></div></div></div><div id="37721680" class="c"><input type="checkbox" id="c-37721680" checked=""/><div class="controls bullet"><span class="by">RHSeeger</span><span>|</span><a href="#37721511">parent</a><span>|</span><a href="#37723782">prev</a><span>|</span><a href="#37722373">next</a><span>|</span><label class="collapse" for="c-37721680">[-]</label><label class="expand" for="c-37721680">[3 more]</label></div><br/><div class="children"><div class="content">I trust and respect the people I work with. I also prefer to have code reviews, even (especially) of my own code. Code reviews can point out code that<p>- Doesn&#x27;t consider an edge case (NPEs being the most common)<p>- Doesn&#x27;t match up well with the &quot;standard&quot; way we do things (and, all things being equal, using the same approach in every place improves maintainability)<p>- Has a simpler approach<p>- Doesn&#x27;t have a comment where it&#x27;s not clear _why_ the code is doing something (that the author of the code sees as obvious, because they wrote it)<p>- Has misleading method&#x2F;class&#x2F;field names<p>These are all things that I&#x27;ve seen from both myself and others on my team. Having one other team member take a look at my code before it goes to QA can save a lot of time later.</div><br/><div id="37721849" class="c"><input type="checkbox" id="c-37721849" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#37721511">root</a><span>|</span><a href="#37721680">parent</a><span>|</span><a href="#37722373">next</a><span>|</span><label class="collapse" for="c-37721849">[-]</label><label class="expand" for="c-37721849">[2 more]</label></div><br/><div class="children"><div class="content">None of the things you said matters if your issue is time to market or you have little business.<p>Who cares about an edge case no user&#x27;s gonna see?<p>Who cares about an edge case for a non business critical feature?<p>Who cares if there was a better way to implement something if it&#x27;s not a priority?<p>Our work it&#x27;s not meant to give us devs intellectual challenges but solve people&#x27;s problems.<p>All the things you list are reasonable if you&#x27;re making money or they are core to the product or they impact user&#x27;s safety in any way.<p>Otherwise they don&#x27;t matter at all.<p>And half the things you list are solved by having high hiring standards and paying people well.<p>Stuff may not be perfect, maybe there will be better ways, maybe it will be inconsistent at times but it will be more than good enough and move the business forward at much higher speed. Also, just to reiterate I&#x27;ve never stated that we don&#x27;t have standards or make architectural decisions or don&#x27;t give feedback. I merely stated that reviewing PRs for us is an exception, not a rule and that I prefer a system of trust.</div><br/><div id="37722293" class="c"><input type="checkbox" id="c-37722293" checked=""/><div class="controls bullet"><span class="by">RHSeeger</span><span>|</span><a href="#37721511">root</a><span>|</span><a href="#37721849">parent</a><span>|</span><a href="#37722373">next</a><span>|</span><label class="collapse" for="c-37722293">[-]</label><label class="expand" for="c-37722293">[1 more]</label></div><br/><div class="children"><div class="content">My goal is to build things that work, and can continue to be worked on and improved over time; where development doesn&#x27;t grind to a halt in 6 months because nobody cares about quality.<p>Edge cases matter sometimes matter and sometimes do not. They particularly matter in cases where, if the happen, the leave the system in a bad state (corrupt data, etc). Having a second pair of eyes take a look at the code and think &quot;where can this go wrong&quot; doesn&#x27;t cost much, but can save a lot of pain later.<p>Doing things in a simpler way and&#x2F;or a way that matches the way we generally do things makes it easier to maintain. And it&#x27;s fairly common for code maintenance and&#x2F;or further development on the same code, to be more common than writing brand new functionality (code that doesn&#x27;t touch existing code). This is directly related to the &quot;grind to a halt&quot; I mentioned earlier.<p>Literally nothing I mentioned can be solved by hiring standards or pay. Once, because hiring people new to software development is a thing. Two, because everyone... EVERYONE makes mistakes. And EVERYONE can do better with the help of their peers.<p>I prefer that every PR get reviewed by someone, with the (uncommon) exception of those where the developer says it isn&#x27;t worth a review. It generally takes very little time, and it adds to delivered code quality.</div><br/></div></div></div></div></div></div><div id="37722373" class="c"><input type="checkbox" id="c-37722373" checked=""/><div class="controls bullet"><span class="by">quacker</span><span>|</span><a href="#37721511">parent</a><span>|</span><a href="#37721680">prev</a><span>|</span><a href="#37721987">next</a><span>|</span><label class="collapse" for="c-37722373">[-]</label><label class="expand" for="c-37722373">[1 more]</label></div><br/><div class="children"><div class="content">Agree. The better your team members, the less need there is for code review.<p>However, the approach of few&#x2F;no code reviews doesn’t work for large open source projects that accept external contributions (the author of the post is mitchellh who is a founder of HashiCorp, which has&#x2F;had several large open source projects).</div><br/></div></div><div id="37721987" class="c"><input type="checkbox" id="c-37721987" checked=""/><div class="controls bullet"><span class="by">devin-sills</span><span>|</span><a href="#37721511">parent</a><span>|</span><a href="#37722373">prev</a><span>|</span><a href="#37720540">next</a><span>|</span><label class="collapse" for="c-37721987">[-]</label><label class="expand" for="c-37721987">[1 more]</label></div><br/><div class="children"><div class="content">Same experience here. Productivity unlocks like crazy, and amazingly the sky doesn&#x27;t fall. It does require stringent hiring practices though and a flat, open culture. Oftentimes I don&#x27;t need a formal syntactical process like a review but rather just need to bounce ideas off folks to get a good plan for a larger feature.</div><br/></div></div></div></div><div id="37720540" class="c"><input type="checkbox" id="c-37720540" checked=""/><div class="controls bullet"><span class="by">bhouston</span><span>|</span><a href="#37721511">prev</a><span>|</span><a href="#37722952">next</a><span>|</span><label class="collapse" for="c-37720540">[-]</label><label class="expand" for="c-37720540">[3 more]</label></div><br/><div class="children"><div class="content">This is a great suggestion and likely not that hard for GitHub to implement.  I am surprised this isn’t updated more than it is.</div><br/><div id="37720619" class="c"><input type="checkbox" id="c-37720619" checked=""/><div class="controls bullet"><span class="by">ninkendo</span><span>|</span><a href="#37720540">parent</a><span>|</span><a href="#37722952">next</a><span>|</span><label class="collapse" for="c-37720619">[-]</label><label class="expand" for="c-37720619">[2 more]</label></div><br/><div class="children"><div class="content">GitHub seems to have no interest whatsoever in making the process of reviewing code any better or easier. It’s still essentially the same as it was 15 years ago.<p>They introduced batched review comments well over five years ago, and still haven’t fixed the obvious issues with it, like how if you’re the PR author and you’re replying to someone <i>else’s</i> comment, and hit Cmd+Enter, it <i>starts a review of your own PR</i> (requiring you to delete the comment and start over, fun!) rather than just replying. Glaring day-1 oversights of what should have been a simple feature,  never fixed.</div><br/><div id="37720820" class="c"><input type="checkbox" id="c-37720820" checked=""/><div class="controls bullet"><span class="by">Waterluvian</span><span>|</span><a href="#37720540">root</a><span>|</span><a href="#37720619">parent</a><span>|</span><a href="#37722952">next</a><span>|</span><label class="collapse" for="c-37720820">[-]</label><label class="expand" for="c-37720820">[1 more]</label></div><br/><div class="children"><div class="content">I review my own PRs regularly. It’s how I talk through all my changes with meaningful inline comment threads. I prefer the behaviour you’re commenting about because I want to do those things in a “review” rather than pollute inboxes with one-off comments.<p>I think the main issue is that everyone has their happy paths through review, but those aren’t everyone’s happy paths. It’s why I like that having a variety of tools is possible. GitHub likely has to bias towards the beige middle ground that suits everyone well enough.</div><br/></div></div></div></div></div></div><div id="37722952" class="c"><input type="checkbox" id="c-37722952" checked=""/><div class="controls bullet"><span class="by">a-dub</span><span>|</span><a href="#37720540">prev</a><span>|</span><a href="#37721272">next</a><span>|</span><label class="collapse" for="c-37722952">[-]</label><label class="expand" for="c-37722952">[2 more]</label></div><br/><div class="children"><div class="content">it used to be worse. if you pushed changes that removed lines that had review comments on them, the review comments would simply disappear.<p>but yes, i liked perforce too.</div><br/><div id="37723635" class="c"><input type="checkbox" id="c-37723635" checked=""/><div class="controls bullet"><span class="by">SleepyMyroslav</span><span>|</span><a href="#37722952">parent</a><span>|</span><a href="#37721272">next</a><span>|</span><label class="collapse" for="c-37723635">[-]</label><label class="expand" for="c-37723635">[1 more]</label></div><br/><div class="children"><div class="content">Corporate devs are still in perforce paired with some web review tools. It is a big cultural problem for a lots of devs out there that they are not familiar with open source flows and tools.</div><br/></div></div></div></div><div id="37721272" class="c"><input type="checkbox" id="c-37721272" checked=""/><div class="controls bullet"><span class="by">prokopton</span><span>|</span><a href="#37722952">prev</a><span>|</span><a href="#37721595">next</a><span>|</span><label class="collapse" for="c-37721272">[-]</label><label class="expand" for="c-37721272">[1 more]</label></div><br/><div class="children"><div class="content">It’s a slightly different methodology, but Git Patch Stack has worked well for us over the past year. The CLI is a huge help.<p><a href="https:&#x2F;&#x2F;git-ps.sh&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;git-ps.sh&#x2F;</a></div><br/></div></div><div id="37721595" class="c"><input type="checkbox" id="c-37721595" checked=""/><div class="controls bullet"><span class="by">fahhem</span><span>|</span><a href="#37721272">prev</a><span>|</span><label class="collapse" for="c-37721595">[-]</label><label class="expand" for="c-37721595">[1 more]</label></div><br/><div class="children"><div class="content">I truly believe that Reviewable is the best way to review code on GitHub, that&#x27;s why I left a Head of Engineering post to come work here.<p>Reviewable tracks code by revisions (aka changesets), not just the state of the git branch like GitHub, and many more improvements both to the broad strokes and to the small things.<p>Want to immediately see which PR&#x27;s you should review? Want to avoid getting pinged during the day to review PR&#x27;s you could have reviewed on your schedule? Want to see the status of a PR right when you open it? What about keeping your comments on the right line even as new changesets come in so you never have to review the PR from scratch again?<p>All handled by Reviewable to make you a better engineer: fewer interruptions, no repeated work, and generally respond to reviewers faster</div><br/></div></div></div></div></div></div></div></body></html>