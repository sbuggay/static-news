<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1728550878897" as="style"/><link rel="stylesheet" href="styles.css?v=1728550878897"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://number-none.com/blow/blog/programming/2014/09/26/carmack-on-inlined-code.html">John Carmack on inlined code (2014)</a> <span class="domain">(<a href="http://number-none.com">number-none.com</a>)</span></div><div class="subtext"><span>bpierre</span> | <span>329 comments</span></div><br/><div><div id="41785113" class="c"><input type="checkbox" id="c-41785113" checked=""/><div class="controls bullet"><span class="by">mihaic</span><span>|</span><a href="#41787785">next</a><span>|</span><label class="collapse" for="c-41785113">[-]</label><label class="expand" for="c-41785113">[126 more]</label></div><br/><div class="children"><div class="content">When I first heard the maxim that an intelligent person should be able to hold two opposing thoughts at the same time, I was naive to think it meant weighing them for pros and cons. Over time I realized that it means balancing contradictory actions, and the main purpose of experience is knowing when to apply each.<p>Concretely related to the topic, I&#x27;ve often found myself inlining short pieces of one-time code that made functions more explicit, while at other times I&#x27;ll spend days just breaking up thousand line functions into simpler blocks just to be able to follow what&#x27;s going on. In both cases I was creating inconsistencies that younger developers nitpick -- I know I did.<p>My goal in most cases now is to optimize code for the limits of the human mind (my own in low-effort mode) and like to be able to treat rules as guidelines. The trouble is how can you scale this to millions of developers, and what are those limits of the human mind when more and more AI-generated code will be used?</div><br/><div id="41789396" class="c"><input type="checkbox" id="c-41789396" checked=""/><div class="controls bullet"><span class="by">tetha</span><span>|</span><a href="#41785113">parent</a><span>|</span><a href="#41789583">next</a><span>|</span><label class="collapse" for="c-41789396">[-]</label><label class="expand" for="c-41789396">[3 more]</label></div><br/><div class="children"><div class="content">I had exactly this discussion today in an architectural discussion about an infrastructure extension today. As our newest team member noted, we planned to follow the reference architecture of a system in some places, and chose not to follow the reference architecture in other places.<p>And this led to a really good discussion pulling the reference architecture of this system apart and understanding what it optimizes for (resilience and fault tolerance), what it sacrifices (cost, number of systems to maintain) and what we need. And yes, following the reference architecture in one place and breaking it in another place makes sense.<p>And I think that understanding the different options, as well as the optimization goals setting them apart, allows you to make a more informed decision and allows you to make a stronger argument why this is a good decision. In fact, understanding the optimization criteria someone cares about allows you to avoid losing them in topics they neither understand nor care about.<p>For example, our CEO will not understand the technical details why the reference architecture is resilient, or why other choices are less resilient. And he would be annoyed about his time being wasted if you tried. But he is currently very aware of customer impacts due to outages. And like this, we can offer a very good argument to invest money in one place for resilience, and why we can save money in other places without risking a customer impact.<p>We sometimes follow rules, and in other situations, we might not.</div><br/><div id="41789718" class="c"><input type="checkbox" id="c-41789718" checked=""/><div class="controls bullet"><span class="by">mandevil</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41789396">parent</a><span>|</span><a href="#41792038">next</a><span>|</span><label class="collapse" for="c-41789718">[-]</label><label class="expand" for="c-41789718">[1 more]</label></div><br/><div class="children"><div class="content">Yes, and it is the engineering experience&#x2F;skill to know when to follow the &quot;rules&quot; of the reference architecture, and when you&#x27;re better off breaking them, that&#x27;s the entire thing that makes someone a senior engineer&#x2F;manager&#x2F;architect whatever your company calls it.</div><br/></div></div><div id="41792038" class="c"><input type="checkbox" id="c-41792038" checked=""/><div class="controls bullet"><span class="by">jschrf</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41789396">parent</a><span>|</span><a href="#41789718">prev</a><span>|</span><a href="#41789583">next</a><span>|</span><label class="collapse" for="c-41792038">[-]</label><label class="expand" for="c-41792038">[1 more]</label></div><br/><div class="children"><div class="content">Your newest team member sounds like someone worth holding onto.</div><br/></div></div></div></div><div id="41789583" class="c"><input type="checkbox" id="c-41789583" checked=""/><div class="controls bullet"><span class="by">lifeisstillgood</span><span>|</span><a href="#41785113">parent</a><span>|</span><a href="#41789396">prev</a><span>|</span><a href="#41786948">next</a><span>|</span><label class="collapse" for="c-41789583">[-]</label><label class="expand" for="c-41789583">[7 more]</label></div><br/><div class="children"><div class="content">I often Bang on about “software is a new form of literacy”.  And this I feel is a classic example - software is a form of literacy that not only can be executed by a CPU but also at the same time is a way to transmit concepts from one humans head to another (just like writing)<p>And so asking “will AI generated code help” is like asking “will AI generated blog spam help”?<p>No - companies with GitHub copilot are basically asking how do I self-spam my codebase<p>It’s great to get from zero to something in some new JS framework but for your core competancy - it’s like outsourcing your thinking - always comes a cropper<p>(Book still being written)</div><br/><div id="41791195" class="c"><input type="checkbox" id="c-41791195" checked=""/><div class="controls bullet"><span class="by">davidw</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41789583">parent</a><span>|</span><a href="#41789781">next</a><span>|</span><label class="collapse" for="c-41791195">[-]</label><label class="expand" for="c-41791195">[4 more]</label></div><br/><div class="children"><div class="content">&gt; is a way to transmit concepts from one humans head to another (just like writing)<p>That&#x27;s almost its primary purpose in my opinion... the CPU does not care about Ruby vs Python vs Rust, it&#x27;s just executing some binary code instructions. The code is so that other people can change and extend what the system is doing over time and share that with others.</div><br/><div id="41792212" class="c"><input type="checkbox" id="c-41792212" checked=""/><div class="controls bullet"><span class="by">rileymat2</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41791195">parent</a><span>|</span><a href="#41789781">next</a><span>|</span><label class="collapse" for="c-41792212">[-]</label><label class="expand" for="c-41792212">[3 more]</label></div><br/><div class="children"><div class="content">I get your point, but often the binary code instructions between those is vastly different.</div><br/><div id="41793722" class="c"><input type="checkbox" id="c-41793722" checked=""/><div class="controls bullet"><span class="by">davidw</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41792212">parent</a><span>|</span><a href="#41789781">next</a><span>|</span><label class="collapse" for="c-41793722">[-]</label><label class="expand" for="c-41793722">[2 more]</label></div><br/><div class="children"><div class="content">The fact that we work with the high level languages rather than the binary code, despite all their inefficiencies, speaks to the human aspect being pretty important in the equation.</div><br/><div id="41794722" class="c"><input type="checkbox" id="c-41794722" checked=""/><div class="controls bullet"><span class="by">wrsh07</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41793722">parent</a><span>|</span><a href="#41789781">next</a><span>|</span><label class="collapse" for="c-41794722">[-]</label><label class="expand" for="c-41794722">[1 more]</label></div><br/><div class="children"><div class="content">This entire conversation is about tradeoffs, but I would note that some of my favorite engineers that I&#x27;ve had the pleasure of knowing are: 1) very fast and 2) know exactly what the binary code of the thing they are trying to do looks like<p>There&#x27;s a (3) where they&#x27;ll quickly confirm their hypothesis using godbolt (or similar) if in doubt or they want to actually think in binary.<p>Fortunately for the programming community, many of us are able to create useful or interesting things without that kind of depth</div><br/></div></div></div></div></div></div></div></div><div id="41789781" class="c"><input type="checkbox" id="c-41789781" checked=""/><div class="controls bullet"><span class="by">debit-freak</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41789583">parent</a><span>|</span><a href="#41791195">prev</a><span>|</span><a href="#41791719">next</a><span>|</span><label class="collapse" for="c-41789781">[-]</label><label class="expand" for="c-41789781">[1 more]</label></div><br/><div class="children"><div class="content">I think a lot of the traditional teachings of &quot;rhetoric&quot; can apply to coding very naturally—there&#x27;s often practically unlimited ways to communicate the same semantics precisely, but how you lay the code out and frame it can make the human struggle to read it straightforward to overcome (or near-impossible, if you look at obfuscation).</div><br/></div></div><div id="41791719" class="c"><input type="checkbox" id="c-41791719" checked=""/><div class="controls bullet"><span class="by">j7ake</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41789583">parent</a><span>|</span><a href="#41789781">prev</a><span>|</span><a href="#41786948">next</a><span>|</span><label class="collapse" for="c-41791719">[-]</label><label class="expand" for="c-41791719">[1 more]</label></div><br/><div class="children"><div class="content">Computational thinking is more important than software per se.<p>Computational thinking is the mathematical thinking.</div><br/></div></div></div></div><div id="41786948" class="c"><input type="checkbox" id="c-41786948" checked=""/><div class="controls bullet"><span class="by">ragnese</span><span>|</span><a href="#41785113">parent</a><span>|</span><a href="#41789583">prev</a><span>|</span><a href="#41785256">next</a><span>|</span><label class="collapse" for="c-41786948">[-]</label><label class="expand" for="c-41786948">[20 more]</label></div><br/><div class="children"><div class="content">&gt; My goal in most cases now is to optimize code for the limits of the human mind (my own in low-effort mode) and like to be able to treat rules as guidelines. The trouble is how can you scale this to millions of developers, and what are those limits of the human mind when more and more AI-generated code will be used?<p>I think the truth is that we just CAN&#x27;T scale that way with the current programming languages&#x2F;models&#x2F;paradigms. I can&#x27;t PROVE that hypothesis, but it&#x27;s not hard to find examples of big software projects with lots of protocols, conventions, failsafes, QA teams, etc, etc that are either still hugely difficult to contribute to (Linux kernel, web browsers, etc) or still have plenty of bugs (macOS is produced by the richest company on Earth and a few years ago the CALCULATOR app had a bug that made it give the wrong answers...).<p>I feel like our programming tools are pretty good for programming in the small, but I suspect we&#x27;re still waiting for a breakthrough for being able to actually make complex software reliably. (And, no, I don&#x27;t just mean yet another &quot;framework&quot; or another language that&#x27;s just C with a fancier type system or novel memory management)<p>Just my navel gazing for the morning.</div><br/><div id="41787406" class="c"><input type="checkbox" id="c-41787406" checked=""/><div class="controls bullet"><span class="by">twh270</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786948">parent</a><span>|</span><a href="#41787442">next</a><span>|</span><label class="collapse" for="c-41787406">[-]</label><label class="expand" for="c-41787406">[4 more]</label></div><br/><div class="children"><div class="content">I think the only way this gets better is with software development tools that make it impossible to create invalid states.<p>In the physical world, when we build something complex like a car engine, a microprocessor, or bookcase, the laws of physics guide us and help prevent invalid states. Not all of them -- an upside down bookcase still works -- but a lot of them.<p>Of course, part of the problem is that when we build the software equivalent of an upside down bookcase, we &#x27;patch&#x27; it by creating trim and shims to make it look better and more structurally sound instead of tossing it and making another one the right way.<p>But mostly, we write software in a way that allows for a ton of incorrect states. As a trivial example, expressing a person&#x27;s age as an &#x27;int&#x27;, allowing for negative numbers. As a more complicated example, allowing for setting a coupon&#x27;s redemption date when it has not yet been clipped.</div><br/><div id="41789375" class="c"><input type="checkbox" id="c-41789375" checked=""/><div class="controls bullet"><span class="by">bunderbunder</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41787406">parent</a><span>|</span><a href="#41788303">next</a><span>|</span><label class="collapse" for="c-41789375">[-]</label><label class="expand" for="c-41789375">[2 more]</label></div><br/><div class="children"><div class="content">John Backus&#x27;s Turing Award lecture meditated on this idea, and concluded that the best way to do this at scale is to simply minimize the creation of states in the first place, and be careful and thoughtful about <i>where</i> and <i>how</i> we create the states that can&#x27;t be avoided.<p>I would argue that that&#x27;s actually a better guide to how we manage complexity in the physical world. Mechanical engineers generally like to minimize the number of moving parts in a system. When they can&#x27;t avoid moving parts, they tend to fixate on them, and put a lot of effort into creating linkages and failsafes to try to prevent them from interacting in catastrophic ways.<p>The software engineering way would be to create extra moving parts just because complicated things make us feel smart, and deal with potential adverse interactions among them by posting signs that say &quot;Careful, now!&quot; without clearly explaining what the reader is supposed to be careful of. 50 years later, people who try to stick to the (very sound!) principles that Backus proposed are still regularly dismissed as being hipsters and pedants.</div><br/><div id="41793413" class="c"><input type="checkbox" id="c-41793413" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41789375">parent</a><span>|</span><a href="#41788303">next</a><span>|</span><label class="collapse" for="c-41793413">[-]</label><label class="expand" for="c-41793413">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d say that the extra moving parts are there in most cases not because someone wanted to &quot;feel smart&quot; (not that it doesn&#x27;t happen), but to make the pre-existing moving parts do something that they weren&#x27;t originally supposed to do, because nobody understands how those pre-existing parts work well enough to re-engineer them properly on the schedule that they are given. We are an industry that builds bridges out of matchsticks, duck tape, and glue, and many of our processes are basically about how to make the result of that &quot;good enough&quot;.</div><br/></div></div></div></div><div id="41788303" class="c"><input type="checkbox" id="c-41788303" checked=""/><div class="controls bullet"><span class="by">james_marks</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41787406">parent</a><span>|</span><a href="#41789375">prev</a><span>|</span><a href="#41787442">next</a><span>|</span><label class="collapse" for="c-41788303">[-]</label><label class="expand" for="c-41788303">[1 more]</label></div><br/><div class="children"><div class="content">To determine what states should be possible is the act of writing software.</div><br/></div></div></div></div><div id="41787442" class="c"><input type="checkbox" id="c-41787442" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786948">parent</a><span>|</span><a href="#41787406">prev</a><span>|</span><a href="#41787188">next</a><span>|</span><label class="collapse" for="c-41787442">[-]</label><label class="expand" for="c-41787442">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think we will ever get the breakthrough you are looking for.  Things like design patterns and abstractions are our attempt at this.  Eventually you need to trust that however wrote the other code you have to deal with is sane. This assumption is false (and it might be you who is insane thinking they could&#x2F;would make it work they way you think it does).<p>We will never get rid of the need for QA.  Automated tests are great, I believe in them (Note that I didn&#x27;t say unit tests or integration tests). Formal proofs appear great (I have never figured out how to prove my code), but as Knuth said &quot;Beware of bugs in the above code; I have only proved it correct, not tried it&quot;. There are many ways code can be meet the spec and yet wrong because in the real world you rarely understand the problem well enough to write a correct spec in the first place.  QA should understand the problem well enough to say &quot;this isn&#x27;t what I expected to happen.&quot;</div><br/></div></div><div id="41787188" class="c"><input type="checkbox" id="c-41787188" checked=""/><div class="controls bullet"><span class="by">austin-cheney</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786948">parent</a><span>|</span><a href="#41787442">prev</a><span>|</span><a href="#41792274">next</a><span>|</span><label class="collapse" for="c-41787188">[-]</label><label class="expand" for="c-41787188">[1 more]</label></div><br/><div class="children"><div class="content">I suppose that depends on the language and the elegance of your programming paradigm.  This is where primitive simplicity becomes important, because when your foundation is composed of very few things that are not dependent upon each other you can scale almost indefinitely in every direction.<p>Imagine you are limited to only a few ingredients in programming: statements, expressions, functions, objects, arrays, and operators that are not overloaded.  That list does not contain classes, inheritance, declarative helpers, or a bunch of other things.  With a list of ingredients so small no internal structure or paradigm is imposed on you, so you are free to create any design decisions that you want.  Those creative decisions about the organization of things is how you dictate the scale of it all.<p>Most people, though, cannot operate like that.  They claim to want the freedom of infinite scale, but they just need a little help.  With more help supplied by the language, framework, whatever the less freedom you have to make your own decisions.  Eventually there is so much help that all you do as a programmer is contend with that helpful goodness without any chance to scale things in any direction.</div><br/></div></div><div id="41792274" class="c"><input type="checkbox" id="c-41792274" checked=""/><div class="controls bullet"><span class="by">mgsouth</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786948">parent</a><span>|</span><a href="#41787188">prev</a><span>|</span><a href="#41787725">next</a><span>|</span><label class="collapse" for="c-41792274">[-]</label><label class="expand" for="c-41792274">[4 more]</label></div><br/><div class="children"><div class="content">We&#x27;ve been there, done that. CRUD apps on mainframes and minis had incredibly powerful and productive languages and frameworks (Quick, Quiz, QTP: you&#x27;re remembered and missed.) Problem is, they were TUI (terminal UI), isolated, and extremely focused; i.e. limited. They <i>functioned</i>, but would be like straight-jackets to modern users.<p>(Speaking of... has anyone done a 80x24 TUI client for HN? That would be interesting to play with.)</div><br/><div id="41795297" class="c"><input type="checkbox" id="c-41795297" checked=""/><div class="controls bullet"><span class="by">korben5</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41792274">parent</a><span>|</span><a href="#41794804">next</a><span>|</span><label class="collapse" for="c-41795297">[-]</label><label class="expand" for="c-41795297">[2 more]</label></div><br/><div class="children"><div class="content">yes: <a href="https:&#x2F;&#x2F;github.com&#x2F;aome510&#x2F;hackernews-TUI">https:&#x2F;&#x2F;github.com&#x2F;aome510&#x2F;hackernews-TUI</a></div><br/><div id="41795846" class="c"><input type="checkbox" id="c-41795846" checked=""/><div class="controls bullet"><span class="by">mgsouth</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41795297">parent</a><span>|</span><a href="#41794804">next</a><span>|</span><label class="collapse" for="c-41795846">[-]</label><label class="expand" for="c-41795846">[1 more]</label></div><br/><div class="children"><div class="content">Works a treat :)</div><br/></div></div></div></div><div id="41794804" class="c"><input type="checkbox" id="c-41794804" checked=""/><div class="controls bullet"><span class="by">drdec</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41792274">parent</a><span>|</span><a href="#41795297">prev</a><span>|</span><a href="#41787725">next</a><span>|</span><label class="collapse" for="c-41794804">[-]</label><label class="expand" for="c-41794804">[1 more]</label></div><br/><div class="children"><div class="content">&gt; has anyone done a 80x24 TUI client for HN<p>lynx still exists</div><br/></div></div></div></div><div id="41787725" class="c"><input type="checkbox" id="c-41787725" checked=""/><div class="controls bullet"><span class="by">DSMan195276</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786948">parent</a><span>|</span><a href="#41792274">prev</a><span>|</span><a href="#41789330">next</a><span>|</span><label class="collapse" for="c-41787725">[-]</label><label class="expand" for="c-41787725">[5 more]</label></div><br/><div class="children"><div class="content">&gt; protocols, conventions, failsafes, QA teams, etc, etc that are either still hugely difficult to contribute to (Linux kernel, web browsers, etc)<p>To be fair here, I don&#x27;t think it&#x27;s reasonable to expect that once you have &quot;software development skills&quot; it automatically gives you the ability to fix any code out there. The Linux Kernel and web browsers are not hard to contribute to because of conventions, they&#x27;re hard because most of that code requires a lot of outside knowledge of things like hardware or HTML spec, etc.<p>The actual submitting part isn&#x27;t the easiest, but it&#x27;s well documented if you go looking, I&#x27;m pretty sure most people could handle it if they really had a fix they wanted to submit.</div><br/><div id="41788034" class="c"><input type="checkbox" id="c-41788034" checked=""/><div class="controls bullet"><span class="by">ragnese</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41787725">parent</a><span>|</span><a href="#41789330">next</a><span>|</span><label class="collapse" for="c-41788034">[-]</label><label class="expand" for="c-41788034">[4 more]</label></div><br/><div class="children"><div class="content">There are multiple reasons that contributing to various projects may be difficult. But, I was replying to a specific comment about writing code in a way that is easy to understand, and the comment author&#x27;s acknowledgement that this idea&#x2F;practice is hard to scale to a large number of developers (presumably because everyone&#x27;s skills are different and because we each have different ideas about what is &quot;clear&quot;, etc).<p>So, my comment was specifically about code. Yes, developing a kernel driver requires knowledge of the hardware and its quirks. But, if we&#x27;re just talking about the code, why shouldn&#x27;t a competent C developer be able to read the code for an existing hardware driver and come away understanding the hardware?<p>And what about the parts that are NOT related to fiddly hardware? For example, look at all of the recent drama with the Linux filesystem maintainer(s) and interfacing with Rust code. Forget the actual human drama aspect, but just think about the technical code aspect: The Rust devs can&#x27;t even figure out what the C code&#x27;s semantics are, and the lead filesystem guy made some embarrassing outbursts saying that he wasn&#x27;t going to help them by explaining what the actual interface contracts are. It&#x27;s probably because he doesn&#x27;t even know what his own section of the kernel does in the kind of detail that they&#x27;re asking for... That last part is my own speculation, but these Rust guys are <i>also</i> competent at working with C code and they can&#x27;t figure out what assumptions are baked into the C APIs.<p>Web browser code has less to do with nitty gritty hardware. Yet, even a very competent C++ dev is going to have a ton of trouble figuring out the Chromium code base. It&#x27;s just too hard to keep trying to use our current tools for these giant, complex, software projects. No amount of convention or linting or writing your classes and functions to be &quot;easy to understand&quot; is going to <i>really</i> matter in the big picture. Naming variables is hard and important to do well, but at the scale of these projects, individual variable names simply don&#x27;t matter. It&#x27;s hard to even figure out what code is being executed in a given context&#x2F;operation.</div><br/><div id="41790999" class="c"><input type="checkbox" id="c-41790999" checked=""/><div class="controls bullet"><span class="by">tomjakubowski</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41788034">parent</a><span>|</span><a href="#41795000">next</a><span>|</span><label class="collapse" for="c-41790999">[-]</label><label class="expand" for="c-41790999">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Yet, even a very competent C++ dev is going to have a ton of trouble figuring out the Chromium code base.<p>I don&#x27;t think this is true, or at least it wasn&#x27;t circa 2018 when I was writing C++ professionally and semi-competently. I sometimes had to read, understand and change parts of the Chromium code base since I was working on a component which integrated CEF. Over time I began to think of Chromium as a good reference for how to maintain a well-organized C++ code base. It&#x27;s remarkably plain and understandable, greppable even. Eventually I was able to contribute a patch or two back to CEF.<p>The hardest thing by far with respect to making those contributions wasn&#x27;t understanding the C++, it was understanding how to work the build system for development tasks.</div><br/><div id="41792646" class="c"><input type="checkbox" id="c-41792646" checked=""/><div class="controls bullet"><span class="by">TheHegemon</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41790999">parent</a><span>|</span><a href="#41795000">next</a><span>|</span><label class="collapse" for="c-41792646">[-]</label><label class="expand" for="c-41792646">[1 more]</label></div><br/><div class="children"><div class="content">Also agree that the example code base is not the best example to use.<p>The Chromium code base is a joy to read and I would routinely spend hours just reading it to understand deeper topics relating to the JS runtime.<p>Compared to my company&#x27;s much smaller code base that would take hours just to understand the most simplest things because it was written so terribly.</div><br/></div></div></div></div><div id="41795000" class="c"><input type="checkbox" id="c-41795000" checked=""/><div class="controls bullet"><span class="by">DSMan195276</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41788034">parent</a><span>|</span><a href="#41790999">prev</a><span>|</span><a href="#41789330">next</a><span>|</span><label class="collapse" for="c-41795000">[-]</label><label class="expand" for="c-41795000">[1 more]</label></div><br/><div class="children"><div class="content">I guess I just don&#x27;t really get your point then, it&#x27;s not like the Linux Kernel or Chromium or Firefox are giant buggy messes that don&#x27;t work at all. They certainly have bugs but by-and-large they work very well with minimal issues for most people. I also think their codebases are pretty approachable, IMO A competent C or C++ developer can definitely read the code from either one with a little effort - It&#x27;s not the easiest thing but it&#x27;s definitely not impossible, most people just don&#x27;t ever try.<p>My point was that making meaningful contributions such a big fixes requires understanding how the code is _supposed_ to function vs. how it actually functions, that&#x27;s the hard part. In the majority of cases that&#x27;s simply not something the code can tell you, there&#x27;s no replacement for comparing the code to a datasheet or reading the HTML spec to understand how the rendering engine is supposed to work, and those things take time to learn. For the simpler parts people do actively contribute to those without tons of previous experience (or because they already have experience with a library or etc.).</div><br/></div></div></div></div></div></div><div id="41789330" class="c"><input type="checkbox" id="c-41789330" checked=""/><div class="controls bullet"><span class="by">madisp</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786948">parent</a><span>|</span><a href="#41787725">prev</a><span>|</span><a href="#41792951">next</a><span>|</span><label class="collapse" for="c-41789330">[-]</label><label class="expand" for="c-41789330">[1 more]</label></div><br/><div class="children"><div class="content">calculator app on latest macos (sequoia) has a bug today - if you write FF_16 AND FF_16 in the programmer mode and press =, it&#x27;ll display the correct result - FF_16, but the history view displays 0_16 AND FF_16 for some reason.</div><br/></div></div><div id="41792951" class="c"><input type="checkbox" id="c-41792951" checked=""/><div class="controls bullet"><span class="by">JadeNB</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786948">parent</a><span>|</span><a href="#41789330">prev</a><span>|</span><a href="#41788134">next</a><span>|</span><label class="collapse" for="c-41792951">[-]</label><label class="expand" for="c-41792951">[1 more]</label></div><br/><div class="children"><div class="content">&gt; macOS is produced by the richest company on Earth and a few years ago the CALCULATOR app had a bug that made it give the wrong answers...<p>This is stated as if surprising, presumably because we think of a calculator app as a simple thing, but it probably shouldn&#x27;t be that surprising--surely the calculator app isn&#x27;t used that often, and so doesn&#x27;t get much in-the-field testing. Maybe you&#x27;ve occasionally used the calculator in Spotlight, but have you ever opened the app? I don&#x27;t think I have in 20 years.</div><br/></div></div><div id="41788134" class="c"><input type="checkbox" id="c-41788134" checked=""/><div class="controls bullet"><span class="by">knodi</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786948">parent</a><span>|</span><a href="#41792951">prev</a><span>|</span><a href="#41785256">next</a><span>|</span><label class="collapse" for="c-41788134">[-]</label><label class="expand" for="c-41788134">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I feel like our programming tools are pretty good for programming in the small, but I suspect we&#x27;re still waiting for a breakthrough for being able to actually make complex software reliably. (And, no, I don&#x27;t just mean yet another &quot;framework&quot; or another language that&#x27;s just C with a fancier type system or novel memory management)<p>Readability is for human optimization for self or for other people&#x27;s posterity and code comprehension to the readers mind. We need a new way to visualize&#x2F;comprehension code that doesn&#x27;t involve heavy reading and the read&#x27;s personal capabilities of syntax parsing&#x2F;comprehension.<p>This is something we will likely never be able to get right with our current man machine interfaces; keyboard, mouse&#x2F;touch, video and audio.<p>Just a thought. As always I reserve the right to be wrong.</div><br/><div id="41789386" class="c"><input type="checkbox" id="c-41789386" checked=""/><div class="controls bullet"><span class="by">skydhash</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41788134">parent</a><span>|</span><a href="#41785256">next</a><span>|</span><label class="collapse" for="c-41789386">[-]</label><label class="expand" for="c-41789386">[1 more]</label></div><br/><div class="children"><div class="content">Reading is more than enough. What’s often lacking is usually the why? I can understand the code and what it’s doing, but I may not understand the problem (and sub problems) it’s solving . When you can find explanations for that (links to PR discussions, archives of mail threads, and forums post), it’s great. But some don’t bother or it’s somewhere in chat logs.</div><br/></div></div></div></div></div></div><div id="41785256" class="c"><input type="checkbox" id="c-41785256" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#41785113">parent</a><span>|</span><a href="#41786948">prev</a><span>|</span><a href="#41785964">next</a><span>|</span><label class="collapse" for="c-41785256">[-]</label><label class="expand" for="c-41785256">[51 more]</label></div><br/><div class="children"><div class="content">There’s also the effect that a certain code structure that’s clearer for a senior dev might be less clear for a junior dev and vice versa.</div><br/><div id="41785314" class="c"><input type="checkbox" id="c-41785314" checked=""/><div class="controls bullet"><span class="by">rob74</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785256">parent</a><span>|</span><a href="#41785331">next</a><span>|</span><label class="collapse" for="c-41785314">[-]</label><label class="expand" for="c-41785314">[41 more]</label></div><br/><div class="children"><div class="content">Or rather, senior devs have learned to care more for having clear code rather than (over-)applying principles like DRY, separation of concerns etc., while juniors haven&#x27;t (yet)...</div><br/><div id="41785472" class="c"><input type="checkbox" id="c-41785472" checked=""/><div class="controls bullet"><span class="by">JauntyHatAngle</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785314">parent</a><span>|</span><a href="#41785348">next</a><span>|</span><label class="collapse" for="c-41785472">[-]</label><label class="expand" for="c-41785472">[22 more]</label></div><br/><div class="children"><div class="content">I know it&#x27;s overused, but I do find myself saying YAGNI to my junior devs more and more often, as I find they go off on a quest for the perfect abstraction and spend days yak shaving as a result.</div><br/><div id="41785592" class="c"><input type="checkbox" id="c-41785592" checked=""/><div class="controls bullet"><span class="by">silisili</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785472">parent</a><span>|</span><a href="#41788333">next</a><span>|</span><label class="collapse" for="c-41785592">[-]</label><label class="expand" for="c-41785592">[16 more]</label></div><br/><div class="children"><div class="content">Yes!  I work with many folks objectively way younger and smarter than me.  The two bad habits I try to break them of are abstractions and what ifs.<p>They spend so much time chasing perfection that it negatively affects their output.  Multiple times a day I find myself saying &#x27;is that a realistic problem for our use case?&#x27;<p>I don&#x27;t blame them, it&#x27;s admirable.  But I feel like we need to teach YAGNI.  Anymore I feel like a saboteur, polluting our codebase with suboptimal solutions.<p>It&#x27;s weird because my own career was different.  I was a code spammer who learned to wrangle it into something more thoughtful.  But I&#x27;m dealing with overly thoughtful folks I&#x27;m trying to get to spam more code out, so to speak.</div><br/><div id="41785626" class="c"><input type="checkbox" id="c-41785626" checked=""/><div class="controls bullet"><span class="by">reshlo</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785592">parent</a><span>|</span><a href="#41792206">next</a><span>|</span><label class="collapse" for="c-41785626">[-]</label><label class="expand" for="c-41785626">[14 more]</label></div><br/><div class="children"><div class="content">I’ve had the opposite experience before. As a young developer, there were a number of times where I advocated for doing something “the right way” instead of “the good enough way”, was overruled by seniors, and then later I had to fix a bug by doing it “the right way” like I’d wanted to in the first place.<p>Doing it the right way from the start would have saved so much time.</div><br/><div id="41785832" class="c"><input type="checkbox" id="c-41785832" checked=""/><div class="controls bullet"><span class="by">spinningslate</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785626">parent</a><span>|</span><a href="#41786630">next</a><span>|</span><label class="collapse" for="c-41785832">[-]</label><label class="expand" for="c-41785832">[7 more]</label></div><br/><div class="children"><div class="content">This thread is a great illustration of the reality that there are no hard rules, judgement matters, and we don&#x27;t always get things right.<p>I&#x27;m pretty long-in-the-tooth and feel like I&#x27;ve gone through 3 stages in my career:<p>1. Junior dev where everything was new, and did &quot;the simplest thing that could possibly work&quot; because I wasn&#x27;t capable of anything else (I was barely capable of the simple thing).<p>2. Mid-experience, where I&#x27;d learned the basics and thought I knew everything.  This is probably where I wrote my worst code: over-abstracted, using every cool language&#x2F;library feature I knew, justified on the basis of &quot;yeah, but it&#x27;s reusable and will solve lots of stuff in future even though I don&#x27;t know what it is yet&quot;.<p>3. Older and hopefully a bit wiser.  A visceral rejection of speculative reuse as a justification for solving anything beyond the current problem.  Much more focus on really understanding the underlying problem that actually needs solved: less interest in the latest and greatest technology to do that with, and a much larger appreciation of &quot;boring technology&quot; (aka stuff that&#x27;s proven and reliable).<p>The focus on really understanding the problem tends to create more stable abstractions which do get reused.  But that&#x27;s emergent, not speculative ahead-of-time.  There are judgements all the way through that: sometimes deciding to invest in more foundational code, but by default sticking to YAGNI.  Most of all is seeing my value not as weilding techno armageddon, but solving problems for users and customers.<p>I still have a deep fascination with exploring and understanding new tech developments and techniques.  I just have a much higher bar to adopting them for production use.</div><br/><div id="41796554" class="c"><input type="checkbox" id="c-41796554" checked=""/><div class="controls bullet"><span class="by">silisili</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785832">parent</a><span>|</span><a href="#41787088">next</a><span>|</span><label class="collapse" for="c-41796554">[-]</label><label class="expand" for="c-41796554">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The focus on really understanding the problem tends to create more stable abstractions which do get reused. But that&#x27;s emergent, not speculative ahead-of-time.<p>Thank you for putting so eloquently my own fumbling thoughts.  Perfect explanation.</div><br/></div></div><div id="41787088" class="c"><input type="checkbox" id="c-41787088" checked=""/><div class="controls bullet"><span class="by">ryandrake</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785832">parent</a><span>|</span><a href="#41796554">prev</a><span>|</span><a href="#41787927">next</a><span>|</span><label class="collapse" for="c-41787088">[-]</label><label class="expand" for="c-41787088">[3 more]</label></div><br/><div class="children"><div class="content">We all go through that cycle. I think the key is to get yourself through that &quot;complex = good&quot; phase as quickly as possible so you do the least damage and don&#x27;t end up in charge of projects while you&#x27;re in it. Get your &quot;Second System&quot; (as Brooks[1] put it) out of the way as quick as you can, and move on to the more focused, wise phase.<p>Don&#x27;t let yourself fester in phase 2 and become (as Joel put it) an Architecture Astronaut[2].<p>1: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Second-system_effect" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Second-system_effect</a><p>2: <a href="https:&#x2F;&#x2F;www.joelonsoftware.com&#x2F;2001&#x2F;04&#x2F;21&#x2F;dont-let-architecture-astronauts-scare-you&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.joelonsoftware.com&#x2F;2001&#x2F;04&#x2F;21&#x2F;dont-let-architect...</a></div><br/><div id="41792110" class="c"><input type="checkbox" id="c-41792110" checked=""/><div class="controls bullet"><span class="by">lcnPylGDnU4H9OF</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41787088">parent</a><span>|</span><a href="#41787927">next</a><span>|</span><label class="collapse" for="c-41792110">[-]</label><label class="expand" for="c-41792110">[2 more]</label></div><br/><div class="children"><div class="content">Heh, I&#x27;ve read [2] before but another reading just now had this passage stand out:<p>&gt; Another common thing Architecture Astronauts like to do is invent some new architecture and claim it solves something. Java, XML, Soap, XmlRpc, Hailstorm, .NET, Jini, oh lord I can’t keep up. And that’s just in the last 12 months!<p>&gt; I’m not saying there’s anything wrong with these architectures… by no means. They are quite good architectures. What bugs me is the stupendous amount of millennial hype that surrounds them. Remember the Microsoft Dot Net white paper?<p>Nearly word-for-word the same thing could be said about JS frameworks less than 10 years ago.</div><br/><div id="41793310" class="c"><input type="checkbox" id="c-41793310" checked=""/><div class="controls bullet"><span class="by">whstl</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41792110">parent</a><span>|</span><a href="#41787927">next</a><span>|</span><label class="collapse" for="c-41793310">[-]</label><label class="expand" for="c-41793310">[1 more]</label></div><br/><div class="children"><div class="content">Both React and Vue are older than 10 years old at this point. Both are older than jQuery was when they were released, and both have a better backward compatibility story. The only two real competitors not that far behind. It&#x27;s about time for this crappy frontend meme to die.<p>Even SOAP didn&#x27;t really live that long before it started getting abandoned en masse for REST.<p>As someone who was there in the &quot;last 12 months&quot; Joel mentions, what happened in enterprise is like a different planet altogether. Some of this technology had a completely different level of complexity that to this day I am not able to grasp, and the hype was totally unwarranted, unlike actual useful tech like React and Vue (or, out of that list, Java and .NET).</div><br/></div></div></div></div></div></div><div id="41787927" class="c"><input type="checkbox" id="c-41787927" checked=""/><div class="controls bullet"><span class="by">jcgrillo</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785832">parent</a><span>|</span><a href="#41787088">prev</a><span>|</span><a href="#41788410">next</a><span>|</span><label class="collapse" for="c-41787927">[-]</label><label class="expand" for="c-41787927">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The focus on really understanding the problem tends to create more stable abstractions which do get reused. But that&#x27;s emergent, not speculative ahead-of-time.<p>I think this takes a kind of humility you can&#x27;t teach. At least it did for me. To learn this lesson I had to experience in reality what it&#x27;s actually like to work on software where I&#x27;d piled up a bunch of clever ideas and &quot;general solutions&quot;. After doing this enough times I realized that there are very few general solutions to real problems, and likely I&#x27;m not smart enough to game them out ahead of time, so better to focus on things I can actually control.</div><br/></div></div><div id="41788410" class="c"><input type="checkbox" id="c-41788410" checked=""/><div class="controls bullet"><span class="by">james_marks</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785832">parent</a><span>|</span><a href="#41787927">prev</a><span>|</span><a href="#41786630">next</a><span>|</span><label class="collapse" for="c-41788410">[-]</label><label class="expand" for="c-41788410">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Most of all is seeing my value not as wielding techno armageddon, but solving problems for users and customers<p>Also later in my career, I now know: change begets change.<p>That big piece of new code that “fixes everything” will have bugs that will only be discovered by users, and stability is achieved over time through small, targeted fixes.</div><br/></div></div></div></div><div id="41786630" class="c"><input type="checkbox" id="c-41786630" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785626">parent</a><span>|</span><a href="#41785832">prev</a><span>|</span><a href="#41785845">next</a><span>|</span><label class="collapse" for="c-41786630">[-]</label><label class="expand" for="c-41786630">[1 more]</label></div><br/><div class="children"><div class="content">Here is an unwanted senior tip, in many consulting projects without the  “the good enough way” first, there isn&#x27;t anything left for doing “the right way” later on.</div><br/></div></div><div id="41785845" class="c"><input type="checkbox" id="c-41785845" checked=""/><div class="controls bullet"><span class="by">wild_egg</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785626">parent</a><span>|</span><a href="#41786630">prev</a><span>|</span><a href="#41794483">next</a><span>|</span><label class="collapse" for="c-41785845">[-]</label><label class="expand" for="c-41785845">[2 more]</label></div><br/><div class="children"><div class="content">The important bit is figuring out if those times where &quot;the right way&quot; would have helped outweigh the time saved by defaulting to &quot;good enough&quot;.<p>There are always exceptions, but there&#x27;s typically order of magnitude differences between globally doing &quot;the right thing&quot; vs &quot;good enough&quot; and going back to fix the few cases where &quot;good enough&quot; wasn&#x27;t actually good enough.</div><br/><div id="41787535" class="c"><input type="checkbox" id="c-41787535" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785845">parent</a><span>|</span><a href="#41794483">next</a><span>|</span><label class="collapse" for="c-41787535">[-]</label><label class="expand" for="c-41787535">[1 more]</label></div><br/><div class="children"><div class="content">Only long experience can help you figure this out.  All projects should have at least 20% of the developers who have been there for more than 10 years so they have background context to figure out what you will really need.  You then need at least 30% of your developers to be intended to be long term employees but they have less than 10 years.  In turn that means never more than 50% of your project should be short term contractors.  Nothing wrong with short term contractors - they often can write code faster than the long term employees (who end up spending a lot more time in meetings) - but their lack of context means that they can&#x27;t make those decisions correctly and so need to ask (in turn slowing down the long term employees even more)<p>If you are on a true green field project - your organization has never done this before good luck. Do the best you can but beware that you will regret a lot.  Even if you have those long term employees you will do things you regret - just not as much.</div><br/></div></div></div></div><div id="41794483" class="c"><input type="checkbox" id="c-41794483" checked=""/><div class="controls bullet"><span class="by">dahart</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785626">parent</a><span>|</span><a href="#41785845">prev</a><span>|</span><a href="#41785942">next</a><span>|</span><label class="collapse" for="c-41794483">[-]</label><label class="expand" for="c-41794483">[1 more]</label></div><br/><div class="children"><div class="content">Ah, but that’s assuming the ‘right way’ path went perfectly and didn’t over-engineer anything. In reality, the ‘right way’ path being advocated for, statistically will also waste a lot of time, and over-engineering waste can and does grow exponentially, while under-engineering frequently only wastes linear and&#x2F;or small amounts of time, until the problem is better understood.<p>Having witnessed first-hand over-engineering waste millions of dollars and years of time, on more than one occasion, by people advocating for the ‘right way’, I think tallying the time wasted upgrading an under-engineered solution is highly error prone, and that we need to assume that some percentage of time we’ll need to redo things the right way, and that it’s not actually a waste of time, but a cost that needs to be paid in search of whether the “right way” solution is actually called for, since it’s often not. The waste might be the lesser waste compared to something much worse, and it’s not generally possible to do the exact right amount of engineering from the start.<p>Someone here on HN clued me into the counter acronym to DRY, which is WET: write everything twice (or thrice) so the 2nd or 3rd time will be “right”. The first time isn’t waste, it’s necessary learning. This was also famously advocated by Fred Brooks: “Play to Throw One Away” <a href="https:&#x2F;&#x2F;course.ccs.neu.edu&#x2F;cs5500f14&#x2F;Notes&#x2F;Prototyping1&#x2F;planToThrowOneAway.html" rel="nofollow">https:&#x2F;&#x2F;course.ccs.neu.edu&#x2F;cs5500f14&#x2F;Notes&#x2F;Prototyping1&#x2F;plan...</a></div><br/></div></div><div id="41785942" class="c"><input type="checkbox" id="c-41785942" checked=""/><div class="controls bullet"><span class="by">sdeframond</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785626">parent</a><span>|</span><a href="#41794483">prev</a><span>|</span><a href="#41787321">next</a><span>|</span><label class="collapse" for="c-41785942">[-]</label><label class="expand" for="c-41785942">[1 more]</label></div><br/><div class="children"><div class="content">&gt; then later I had to fix a bug<p>How much later? Is it possible that by delivering sooner your team was able to gain insight and&#x2F;or provide value sooner? That matters!</div><br/></div></div><div id="41787321" class="c"><input type="checkbox" id="c-41787321" checked=""/><div class="controls bullet"><span class="by">JasserInicide</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785626">parent</a><span>|</span><a href="#41785942">prev</a><span>|</span><a href="#41792206">next</a><span>|</span><label class="collapse" for="c-41787321">[-]</label><label class="expand" for="c-41787321">[1 more]</label></div><br/><div class="children"><div class="content">Everything in moderation, even moderation.</div><br/></div></div></div></div><div id="41792206" class="c"><input type="checkbox" id="c-41792206" checked=""/><div class="controls bullet"><span class="by">pastaguy1</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785592">parent</a><span>|</span><a href="#41785626">prev</a><span>|</span><a href="#41788333">next</a><span>|</span><label class="collapse" for="c-41792206">[-]</label><label class="expand" for="c-41792206">[1 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t meant to be taken too literally or objectively, but I view YAGNI as almost a meta principle with respect to the other popular ones. It&#x27;s like an admission that you won&#x27;t always get them right, so in the words of Bukowski, &quot;don&#x27;t try&quot;.</div><br/></div></div></div></div><div id="41788333" class="c"><input type="checkbox" id="c-41788333" checked=""/><div class="controls bullet"><span class="by">james_marks</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785472">parent</a><span>|</span><a href="#41785592">prev</a><span>|</span><a href="#41785348">next</a><span>|</span><label class="collapse" for="c-41788333">[-]</label><label class="expand" for="c-41788333">[5 more]</label></div><br/><div class="children"><div class="content">Agreed. I’ve been trying to dial in a rule of thumb:<p>If you aren’t using the abstraction on 3 cases when you build it, it’s too early.<p>Even two turns into a higher bar than I expected.</div><br/><div id="41789216" class="c"><input type="checkbox" id="c-41789216" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41788333">parent</a><span>|</span><a href="#41788653">next</a><span>|</span><label class="collapse" for="c-41789216">[-]</label><label class="expand" for="c-41789216">[1 more]</label></div><br/><div class="children"><div class="content">Your documentation will tell when you need an abstraction. Where there is something relevant to document, there is a relevant abstraction. If its not worth documenting, it is not worth abstracting. Of course, the hard part is determining what is actually relevant to document.<p>The good news is that programmers generally hate writing documentation and will avoid it to the greatest extent possible, so if one is able to overcome that friction to start writing documentation, it is probably worthwhile.<p>Thus we can sum the rule of thumb up to: If you have already started writing documentation for something, you are ready for an abstraction in your code.</div><br/></div></div><div id="41788653" class="c"><input type="checkbox" id="c-41788653" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41788333">parent</a><span>|</span><a href="#41789216">prev</a><span>|</span><a href="#41785348">next</a><span>|</span><label class="collapse" for="c-41788653">[-]</label><label class="expand" for="c-41788653">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s more case by case for me.  A magic number should get a named constant on its first use.  That&#x27;s an abstraction.</div><br/><div id="41792897" class="c"><input type="checkbox" id="c-41792897" checked=""/><div class="controls bullet"><span class="by">spc476</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41788653">parent</a><span>|</span><a href="#41785348">next</a><span>|</span><label class="collapse" for="c-41792897">[-]</label><label class="expand" for="c-41792897">[2 more]</label></div><br/><div class="children"><div class="content">C++ programmers decided against NULL, and for well over a decade, recommended using a plain 0. It was only recently that they came up with a new name:  nullptr.  Sigh.</div><br/><div id="41793542" class="c"><input type="checkbox" id="c-41793542" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41792897">parent</a><span>|</span><a href="#41785348">next</a><span>|</span><label class="collapse" for="c-41793542">[-]</label><label class="expand" for="c-41793542">[1 more]</label></div><br/><div class="children"><div class="content">That had to do with the way NULL was defined, and the implications of that. The implication carried over from C was that NULL would always be null <i>pointer</i> as opposed to 0, but in practice the standard defined it simply as 0 - because C-style (void*)0 wasn&#x27;t compatible with all pointer types anymore - so stuff like:<p><pre><code>   void foo(void*);

   void foo(int); 

   foo(NULL);
</code></pre>
would resolve to foo(int), which is very much contrary to expectations for a null <i>pointer</i>; and worse yet, the wrong call happens silently. With foo(0) that behavior is clearer, so that was the justification to prefer it.<p>On the other hand, if you accept the fact that NULL is really just an alias for 0 and not specifically a null pointer, then it has no semantic meaning as a named constant (you&#x27;re literally just spelling the numeric value with words instead of digits!), and then it&#x27;s about as useful as #define ONE 1<p>And at the same time, that was the only definition of NULL that was backwards compatible with C, so they couldn&#x27;t just redefine it. It had to be a new thing like nullptr.<p>It is very unfortunate that nullptr didn&#x27;t ship in C++98, but then again that was hardly the biggest wart in the language at the time...</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41785348" class="c"><input type="checkbox" id="c-41785348" checked=""/><div class="controls bullet"><span class="by">stahorn</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785314">parent</a><span>|</span><a href="#41785472">prev</a><span>|</span><a href="#41785443">next</a><span>|</span><label class="collapse" for="c-41785348">[-]</label><label class="expand" for="c-41785348">[2 more]</label></div><br/><div class="children"><div class="content">When you thought you made &quot;smart&quot; solutions and many years later you have to go in and fix bugs in it, is usually when you learn this.</div><br/><div id="41786042" class="c"><input type="checkbox" id="c-41786042" checked=""/><div class="controls bullet"><span class="by">newswasboring</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785348">parent</a><span>|</span><a href="#41785443">next</a><span>|</span><label class="collapse" for="c-41786042">[-]</label><label class="expand" for="c-41786042">[1 more]</label></div><br/><div class="children"><div class="content">There is a human side to this which I am going through right now. The first full framework I made is proving to be developer unfriendly in the long run, I put more emphasis on performance than readability (performance was the KPI we were trying to improve at the time). Now I am working with people who are new to the codebase, and I observed they were hesitant to criticize it in front of me. I had to actively start saying &quot;lets remove &lt;frame work name&gt;, its outdated and bad&quot;. Eventually I found it liberating, it also helped me detach my self worth from my work, something I struggle with day to day.</div><br/></div></div></div></div><div id="41785443" class="c"><input type="checkbox" id="c-41785443" checked=""/><div class="controls bullet"><span class="by">orwin</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785314">parent</a><span>|</span><a href="#41785348">prev</a><span>|</span><a href="#41787853">next</a><span>|</span><label class="collapse" for="c-41785443">[-]</label><label class="expand" for="c-41785443">[10 more]</label></div><br/><div class="children"><div class="content">My &#x27;principle&#x27; for DRY is : twice is fine, trice is worth an abstraction (if you think it has a small to moderate chance to happen again). I used to apply it no matter what, soi guess it&#x27;s progress...</div><br/><div id="41785551" class="c"><input type="checkbox" id="c-41785551" checked=""/><div class="controls bullet"><span class="by">whstl</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785443">parent</a><span>|</span><a href="#41787135">next</a><span>|</span><label class="collapse" for="c-41785551">[-]</label><label class="expand" for="c-41785551">[5 more]</label></div><br/><div class="children"><div class="content">I really dislike how this principle ends up being used in practice.<p>A good <i>abstraction</i> that makes actual sense is perfectly good even when it&#x27;s used only once.<p>On the other hand, the idea of deduplicating code by creating an <i>indirection</i> is often not worth it for long-term maintenance, and is precisely the kind of thing that will cause maintenance headaches and anti-patterns.<p>For example: don&#x27;t mix file system or low-level database access with your business code, just create a proper abstraction. But deduplicating very small fragments of same-abstraction-level can have detrimental effects in the long run.</div><br/><div id="41785659" class="c"><input type="checkbox" id="c-41785659" checked=""/><div class="controls bullet"><span class="by">ahoka</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785551">parent</a><span>|</span><a href="#41785669">next</a><span>|</span><label class="collapse" for="c-41785659">[-]</label><label class="expand" for="c-41785659">[1 more]</label></div><br/><div class="children"><div class="content">I think the main problem with these abstractions that they are merely indirections in most cases, limiting the usefulness to several use cases (sometimes to things that never going to be needed).<p>To quote Dijsktra: &quot;The purpose of abstraction is not to be vague, but to create a new semantic level in which one can be absolutely precise.&quot;</div><br/></div></div><div id="41785669" class="c"><input type="checkbox" id="c-41785669" checked=""/><div class="controls bullet"><span class="by">n0w</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785551">parent</a><span>|</span><a href="#41785659">prev</a><span>|</span><a href="#41787651">next</a><span>|</span><label class="collapse" for="c-41785669">[-]</label><label class="expand" for="c-41785669">[2 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t remember where I picked it up from, but nowadays I try to be mindful of when things are &quot;accidentally&quot; repeated and when they are &quot;necessarily&quot; repeated. Abstractions that encapsulate the latter tend to be a good idea regardless of how many times you&#x27;ve repeated a piece of code in practice.</div><br/><div id="41785779" class="c"><input type="checkbox" id="c-41785779" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785669">parent</a><span>|</span><a href="#41787651">next</a><span>|</span><label class="collapse" for="c-41785779">[-]</label><label class="expand" for="c-41785779">[1 more]</label></div><br/><div class="children"><div class="content">Exactly, but distinguishing the two that requires an excellent understanding of the problem space, and can’t at all be figured out in the solution space (i.e., by only looking at the code). But less experienced people only look at the code. In theory, a thousand repetitions would be fine if each one encodes an independent bit of information in the problem space.</div><br/></div></div></div></div><div id="41787651" class="c"><input type="checkbox" id="c-41787651" checked=""/><div class="controls bullet"><span class="by">loup-vaillant</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785551">parent</a><span>|</span><a href="#41785669">prev</a><span>|</span><a href="#41787135">next</a><span>|</span><label class="collapse" for="c-41787651">[-]</label><label class="expand" for="c-41787651">[1 more]</label></div><br/><div class="children"><div class="content">The overarching criterion really is how it affects locality of behaviour: repeating myself and adding an indirection are both bad, the trick is to pick the one that will affect locality of behaviour the least.<p><a href="https:&#x2F;&#x2F;loup-vaillant.fr&#x2F;articles&#x2F;source-of-readability#avoid-repeating-yourself" rel="nofollow">https:&#x2F;&#x2F;loup-vaillant.fr&#x2F;articles&#x2F;source-of-readability#avoi...</a></div><br/></div></div></div></div><div id="41787135" class="c"><input type="checkbox" id="c-41787135" checked=""/><div class="controls bullet"><span class="by">syntaxfree</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785443">parent</a><span>|</span><a href="#41785551">prev</a><span>|</span><a href="#41788104">next</a><span>|</span><label class="collapse" for="c-41787135">[-]</label><label class="expand" for="c-41787135">[1 more]</label></div><br/><div class="children"><div class="content">WET, write everything twice</div><br/></div></div><div id="41788104" class="c"><input type="checkbox" id="c-41788104" checked=""/><div class="controls bullet"><span class="by">aitchnyu</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785443">parent</a><span>|</span><a href="#41787135">prev</a><span>|</span><a href="#41786085">next</a><span>|</span><label class="collapse" for="c-41788104">[-]</label><label class="expand" for="c-41788104">[1 more]</label></div><br/><div class="children"><div class="content">Do you use a copy paste detector to find third copy?</div><br/></div></div><div id="41786085" class="c"><input type="checkbox" id="c-41786085" checked=""/><div class="controls bullet"><span class="by">tomohawk</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785443">parent</a><span>|</span><a href="#41788104">prev</a><span>|</span><a href="#41785639">next</a><span>|</span><label class="collapse" for="c-41786085">[-]</label><label class="expand" for="c-41786085">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Better a little copying than a little dependency&quot; - Russ Cox</div><br/></div></div><div id="41785639" class="c"><input type="checkbox" id="c-41785639" checked=""/><div class="controls bullet"><span class="by">ikari_pl</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785443">parent</a><span>|</span><a href="#41786085">prev</a><span>|</span><a href="#41787853">next</a><span>|</span><label class="collapse" for="c-41785639">[-]</label><label class="expand" for="c-41785639">[1 more]</label></div><br/><div class="children"><div class="content">twice is fine... except some senior devs apply it to the entire file (today I found the second entire file&#x2F;class copied and pasted over to another place... the newer copy is not used either)</div><br/></div></div></div></div><div id="41787853" class="c"><input type="checkbox" id="c-41787853" checked=""/><div class="controls bullet"><span class="by">zeroq</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785314">parent</a><span>|</span><a href="#41785443">prev</a><span>|</span><a href="#41788114">next</a><span>|</span><label class="collapse" for="c-41787853">[-]</label><label class="expand" for="c-41787853">[1 more]</label></div><br/><div class="children"><div class="content">As someone who recently had to go over a large chunk of code written by myself some 10-15 years ago I strongly agree with this sentiment.
Despite being a mature programmer already at that time, I found a lot of magic and gotchas that were supposed to be, and felt at the time, super clever, but now, without a context, or prior version to compare, they are simply overcomplicated.</div><br/></div></div><div id="41788114" class="c"><input type="checkbox" id="c-41788114" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785314">parent</a><span>|</span><a href="#41787853">prev</a><span>|</span><a href="#41786841">next</a><span>|</span><label class="collapse" for="c-41788114">[-]</label><label class="expand" for="c-41788114">[3 more]</label></div><br/><div class="children"><div class="content">I find that it’s typically the other way around as things like DRY, SOLID and most things “clean code” are hopeless anti-patterns peddled by people like Uncle Bob who haven’t actually worked in software development since Fortran was the most popular language. Not that a lot of these things are bad as a principle. They come with a lot of “okish” ideas, but if you follow them religiously you’re going to write really bad code.<p>I think the only principle in programming I think can be followed at all times is YAGNI (you aren’t going to need it). I think every programming course, book, whatever should start by telling you to never, ever, abstract things before you absolutely can’t avoid it. This includes DRY. It’s a billion times better to have similar code in multiple locations that are isolated in their purpose, so that down the line, two-hundred developers later you’re not sitting with code where you’ll need to “go to definition” fifteen times before you get to the code you actually need to find.<p>Of course the flip-side is that, sometimes, it’s ok to abstract or reuse code. But if you don’t have to, you should never ever do either. Which is exactly the opposite of what junior developers do, because juniors are taught all these “hopeless” OOP practices and they are taught to mindlessly follow them by the book. Then 10 years later (or like 50 years in the case of Uncle Bob) they realise that functional programming is just easier to maintain and more fun to work with because everything you need to know is happening right next to each other and not in some obscure service class deep in some ridiculous inheritance tree.</div><br/><div id="41793703" class="c"><input type="checkbox" id="c-41793703" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41788114">parent</a><span>|</span><a href="#41786841">next</a><span>|</span><label class="collapse" for="c-41793703">[-]</label><label class="expand" for="c-41793703">[2 more]</label></div><br/><div class="children"><div class="content">The problem with repeating code in multiple places is that when you find a bug in said code, it won&#x27;t actually be fixed in all the places where it needs to be fixed. For larger projects especially, it is usually a worthwhile tradeoff versus having to peel off some extra abstraction layers when reading the code.<p>The problems usually start when people take this as an opportunity to go nuts on generalizing the abstraction right away - that is, instead of refactoring the common piece of code into a simple function, it becomes a generic class hierarchy to cover all conceivable future cases (but, somehow, rarely the actual future use case, should one arise in practice).<p>Most of this is just cargo cult thinking. OOP is a valid tool on the belt, and it is genuinely good at modelling certain things - but one needs to understand <i>why</i> it is useful there to know when to reach for it and when to leave it alone. That is rarely taught well (if at all), though, and even if it is, it can be hard to grok without hands-on experience.</div><br/><div id="41796445" class="c"><input type="checkbox" id="c-41796445" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41793703">parent</a><span>|</span><a href="#41786841">next</a><span>|</span><label class="collapse" for="c-41796445">[-]</label><label class="expand" for="c-41796445">[1 more]</label></div><br/><div class="children"><div class="content">We agree, but we’ve come to different conclusions. Probably based on our experiences. Which is why I wanted to convey that I think you should do these things in moderation. I almost never do classes, and much rarer inheritance, as an example. That doesn’t mean I wouldn’t make a “base class” containing things like “owned by, updated by, some time stamp” or whatever you would want added to every data object in some traditional system and then inherit that. I would, I might even make multiple “base classes” if it made sense.<p>What I won’t do, however, is abstract code until I have to. More than that as soon as that shared code stops being shared, I’ll stop doing DRY. Not because DRY is necessarily bad, but because of the way people write software which all too often leads to a dog which will tell you dogs can’t fly if you cal fly() on it. Yes, I know that is ridiculous, but I’ve never seen an “clean” system that didn’t eventually end up like that. People like Uncle Bob will tell you that is because people misunderstood the principles, and they’d be correct. Maybe the principles are simply bad if so many people misunderstand them though?</div><br/></div></div></div></div></div></div><div id="41786841" class="c"><input type="checkbox" id="c-41786841" checked=""/><div class="controls bullet"><span class="by">sgu999</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785314">parent</a><span>|</span><a href="#41788114">prev</a><span>|</span><a href="#41785331">next</a><span>|</span><label class="collapse" for="c-41786841">[-]</label><label class="expand" for="c-41786841">[2 more]</label></div><br/><div class="children"><div class="content">good devs*, not all senior devs have learned that, sadly. As a junior dev I&#x27;ve worked under the rule of senior devs who were over-applying arbitrary principles, and that wasn&#x27;t fun. Some absolute nerds have a hard time understanding where their narrow expertise is meant to fit, and they usually don&#x27;t get better with age.</div><br/></div></div></div></div><div id="41785331" class="c"><input type="checkbox" id="c-41785331" checked=""/><div class="controls bullet"><span class="by">kolinko</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785256">parent</a><span>|</span><a href="#41785314">prev</a><span>|</span><a href="#41785964">next</a><span>|</span><label class="collapse" for="c-41785331">[-]</label><label class="expand" for="c-41785331">[9 more]</label></div><br/><div class="children"><div class="content">I bumped into that issue, and it caused a lot of friction between me and 3 young developers I had to manage.<p>Ideas on how to overcome that?</div><br/><div id="41785563" class="c"><input type="checkbox" id="c-41785563" checked=""/><div class="controls bullet"><span class="by">whstl</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785331">parent</a><span>|</span><a href="#41785964">next</a><span>|</span><label class="collapse" for="c-41785563">[-]</label><label class="expand" for="c-41785563">[8 more]</label></div><br/><div class="children"><div class="content">Teaching.<p>I had this problem with an overzealous junior developer and the solution was showing some different perspectives. For example John Ousterhout&#x27;s A Philosophy of Software Design.</div><br/><div id="41786423" class="c"><input type="checkbox" id="c-41786423" checked=""/><div class="controls bullet"><span class="by">thelastparadise</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785563">parent</a><span>|</span><a href="#41785964">next</a><span>|</span><label class="collapse" for="c-41786423">[-]</label><label class="expand" for="c-41786423">[7 more]</label></div><br/><div class="children"><div class="content">I tried this but they just come back with retorts like &quot;OK boomer&quot; which tends to make the situation even worse.<p>How do you respond to that?</div><br/><div id="41786648" class="c"><input type="checkbox" id="c-41786648" checked=""/><div class="controls bullet"><span class="by">garblegarble</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786423">parent</a><span>|</span><a href="#41787158">next</a><span>|</span><label class="collapse" for="c-41786648">[-]</label><label class="expand" for="c-41786648">[1 more]</label></div><br/><div class="children"><div class="content">The sibling comment says &quot;fire them&quot;. That sounds glib, but it&#x27;s the correct solution here.<p>From what you&#x27;ve described, you have a coworker who is not open to learning and considering alternative solutions. They are not able to defend their approach, and are instead dismissive (and using an ageist joke to do it). This is toxic to a collaborative work environment.<p>I give some leeway to assholes who can justify their reasoning. Assholes who just want their way because it&#x27;s their way aren&#x27;t worth it and won&#x27;t make your product better.</div><br/></div></div><div id="41787158" class="c"><input type="checkbox" id="c-41787158" checked=""/><div class="controls bullet"><span class="by">yodsanklai</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786423">parent</a><span>|</span><a href="#41786648">prev</a><span>|</span><a href="#41786535">next</a><span>|</span><label class="collapse" for="c-41787158">[-]</label><label class="expand" for="c-41787158">[1 more]</label></div><br/><div class="children"><div class="content">This is a discriminatory statement and it should be taken seriously.</div><br/></div></div><div id="41786535" class="c"><input type="checkbox" id="c-41786535" checked=""/><div class="controls bullet"><span class="by">cbrozefsky</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786423">parent</a><span>|</span><a href="#41787158">prev</a><span>|</span><a href="#41788330">next</a><span>|</span><label class="collapse" for="c-41786535">[-]</label><label class="expand" for="c-41786535">[1 more]</label></div><br/><div class="children"><div class="content">Fire them.</div><br/></div></div><div id="41788330" class="c"><input type="checkbox" id="c-41788330" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786423">parent</a><span>|</span><a href="#41786535">prev</a><span>|</span><a href="#41787950">next</a><span>|</span><label class="collapse" for="c-41788330">[-]</label><label class="expand" for="c-41788330">[1 more]</label></div><br/><div class="children"><div class="content">Or, perhaps better, just let that hang for a moment - long enough to become uncomfortable - and then say &quot;Try again.&quot;<p>As others have said, if they can&#x27;t or won&#x27;t get that that&#x27;s unacceptable behavior, fire them.  (jerf is more patient than I am...)</div><br/></div></div><div id="41787950" class="c"><input type="checkbox" id="c-41787950" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786423">parent</a><span>|</span><a href="#41788330">prev</a><span>|</span><a href="#41788528">next</a><span>|</span><label class="collapse" for="c-41787950">[-]</label><label class="expand" for="c-41787950">[1 more]</label></div><br/><div class="children"><div class="content">To be honest, at the point where they are being insulting I also agree firing them is a very viable alternative.<p>However, to answer the question more generally, I&#x27;ve had some success first acknowledging that I agree the situation is suboptimal, and giving some of the reasons. These reasons vary; we were strapped for time, we simply didn&#x27;t know better yet, we had this and that specific problem to deal with, sometimes it&#x27;s just straight up &quot;yeah I inherited that code and would never have done that&quot;, honestly.<p>I then indicate my willingness to spend some time fixing the issues, but make it clear that there isn&#x27;t going to be a Big Bang rewriting session, but that we&#x27;re going to do it incrementally, with the system working the whole time, and they need to conceive of it that way. (Unless the situation is in the rare situation where a rewrite is needed.) This tends to limit the blast radius of any specific suggestion.<p>Also, as a senior engineer, I do not 100% prioritize &quot;fixing every single problem in exactly the way I&#x27;d do it&quot;. I will selectively let certain types of bad code through so that the engineer can have experience of it. I may not let true architecture astronautics through, but as long as it is not entirely unreasonable I will let a bit more architecture than perhaps I would have used through. I think it&#x27;s a common fallacy of code review to think that the purpose of code review is to get the code to be <i>exactly</i> as &quot;I&quot; would have written it, but that&#x27;s not really it.<p>Many people, when they see this degree of flexibility, and that you are not riding to the defense of every coding decision made in the past, and are willing to take reasonable risks to upgrade things, will calm down and start working with you. (This is also one of the subtle reasons automated tests are <i>super super important</i>; it is far better for them to start their refactoring and have the automated tests explain the difficulties of the local landscape to them than a developer just blathering.)<p>There will be a set that do not. Ultimately, that&#x27;s a time to admit the hire was a mistake and rectify it appropriately. I don&#x27;t believe in the 10x developer, but not for the usual egalitarian reasons... for me the problem is I firmly, <i>firmly</i> believe in the existence of the net-negative developer, and when you have those the entire 10x question disappears. Net negative is not a permanent stamp, the developer has the opportunity to work their way out of it, and arguably, we <i>all</i> start there both as a new developer and whenever we start a new job&#x2F;position, so let me sooth the egalitarian impulse by saying this is a description of someone at a point in time, not a permanent label to be applied to anyone. Nevertheless, someone who <i>insists</i> on massive changes, who deploys morale-sapping insults to get their way, whose ego is tied up in some specific stack that you&#x27;re not using and basically insists either that we drop everything and rewrite now &quot;or else&quot;, who one way or another refuses to leave &quot;net negative&quot; status... well, it&#x27;s time to take them up on the &quot;or else&quot;. I&#x27;ve exaggerated here to paint the picture clearly in prose, but, then again, of the hundreds of developers I&#x27;ve interacted with to some degree at some point, there&#x27;s a couple that match every phrase I gave, so it&#x27;s not like they don&#x27;t exist at all either.</div><br/></div></div><div id="41788528" class="c"><input type="checkbox" id="c-41788528" checked=""/><div class="controls bullet"><span class="by">ziml77</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786423">parent</a><span>|</span><a href="#41787950">prev</a><span>|</span><a href="#41785964">next</a><span>|</span><label class="collapse" for="c-41788528">[-]</label><label class="expand" for="c-41788528">[1 more]</label></div><br/><div class="children"><div class="content">You mean they literally say &quot;ok boomer&quot;? If so they are not mature enough for the job. That phrase is equivalent to &quot;fuck off&quot; with some ageism slapped on top and is totally unacceptable for a workplace.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41785964" class="c"><input type="checkbox" id="c-41785964" checked=""/><div class="controls bullet"><span class="by">peepee1982</span><span>|</span><a href="#41785113">parent</a><span>|</span><a href="#41785256">prev</a><span>|</span><a href="#41794615">next</a><span>|</span><label class="collapse" for="c-41785964">[-]</label><label class="expand" for="c-41785964">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s exactly what I try to do. I think it&#x27;s an unpopular opinion though, because there are no strict rules that can be applied, unlike with pure ideologies. You have to go by feel and make continuous adjustments, and there&#x27;s no way to know if you did the right thing or not, because not only do different human minds have different limits, but different challenges don&#x27;t tax every human mind to the same proportional extent.<p>I get the impressions that programmers don&#x27;t like ambiguity in general, let alone in things they have to confront in real life.</div><br/><div id="41786110" class="c"><input type="checkbox" id="c-41786110" checked=""/><div class="controls bullet"><span class="by">mr_toad</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785964">parent</a><span>|</span><a href="#41794615">next</a><span>|</span><label class="collapse" for="c-41786110">[-]</label><label class="expand" for="c-41786110">[2 more]</label></div><br/><div class="children"><div class="content">&gt; there are no strict rules that can be applied<p>The rules are there for a reason.  The tricky part is making sure you’re applying them for that reason.</div><br/><div id="41786177" class="c"><input type="checkbox" id="c-41786177" checked=""/><div class="controls bullet"><span class="by">peepee1982</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786110">parent</a><span>|</span><a href="#41794615">next</a><span>|</span><label class="collapse" for="c-41786177">[-]</label><label class="expand" for="c-41786177">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know what your comment has to do with my comment.</div><br/></div></div></div></div></div></div><div id="41794615" class="c"><input type="checkbox" id="c-41794615" checked=""/><div class="controls bullet"><span class="by">JamesBarney</span><span>|</span><a href="#41785113">parent</a><span>|</span><a href="#41785964">prev</a><span>|</span><a href="#41785321">next</a><span>|</span><label class="collapse" for="c-41794615">[-]</label><label class="expand" for="c-41794615">[1 more]</label></div><br/><div class="children"><div class="content">My go to heuristic for how to break up code is white board or draw up in lucidchart your solution to explain it to another dev. If your methods don&#x27;t match the whiteboard refactor.</div><br/></div></div><div id="41785321" class="c"><input type="checkbox" id="c-41785321" checked=""/><div class="controls bullet"><span class="by">skummetmaelk</span><span>|</span><a href="#41785113">parent</a><span>|</span><a href="#41794615">prev</a><span>|</span><a href="#41788923">next</a><span>|</span><label class="collapse" for="c-41785321">[-]</label><label class="expand" for="c-41785321">[2 more]</label></div><br/><div class="children"><div class="content">That doesn&#x27;t seem like holding two opposing thoughts. Why is balancing contradictory actions to optimize an outcome different to weighing pros and cons?</div><br/><div id="41785386" class="c"><input type="checkbox" id="c-41785386" checked=""/><div class="controls bullet"><span class="by">mihaic</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785321">parent</a><span>|</span><a href="#41788923">next</a><span>|</span><label class="collapse" for="c-41785386">[-]</label><label class="expand" for="c-41785386">[1 more]</label></div><br/><div class="children"><div class="content">What I meant to say was that when people encounter contradictory statements like &quot;always inline one-time functions&quot; and &quot;breakdown functions into easy to understand blocks&quot;, they try to only pick one single rule, even if they consider the pros and cons of each rule.<p>After a while they consider both rules as useful, and will move to a more granular case-by-base analysis. Some people get stuck at rule-based thinking though, and they&#x27;ll even accuse you of being inconsistent if you try to do case-by-case analysis.</div><br/></div></div></div></div><div id="41788923" class="c"><input type="checkbox" id="c-41788923" checked=""/><div class="controls bullet"><span class="by">gspencley</span><span>|</span><a href="#41785113">parent</a><span>|</span><a href="#41785321">prev</a><span>|</span><a href="#41790191">next</a><span>|</span><label class="collapse" for="c-41788923">[-]</label><label class="expand" for="c-41788923">[1 more]</label></div><br/><div class="children"><div class="content">My intro to programming was that I wanted to be a game developer in the 90s. Carmack and the others at Id were my literal heroes.<p>Back then, a lot of code optimizations was magic to me. I still just barely understand the famous inverse square root optimization in the Quake III Arena source code. But I wanted to be able to do what those guys were doing. I wanted to learn assembly and to be able to drop down to assembly and to know where and when that would help and why.<p>And I wasn&#x27;t alone. This is because these optimizations are not obvious. There is a &quot;mystique&quot; to them. Which makes it cool. So virtually ALL young, aspiring game programmers wanted to learn how to do this crazy stuff.<p>What did the old timers tell us?<p>Stop. Don&#x27;t. Learn how to write clean, readable, maintainable code FIRST and then learn how to profile your application in order to discover the major bottlenecks and then you can optimize appropriately in order of greatest impact descending.<p>If writing the easiest code to maintain and understand also meant writing the most performant code, then the concept of code optimization wouldn&#x27;t even exist. The two are mutually exclusive, except in specific cases where it&#x27;s not and then it&#x27;s not even worth discussing because there is no conflict.<p>Carmack seems to acknowledge this in his email. He realizes that inlining functions needs to be done with careful judgment, and the rationale is both performance and bug mitigation. But that if inlining were adopted as a matter of course, a policy of &quot;always inline first&quot;, the results would quickly be an unmaintainable, impossible to comprehend mess that would swing so far in the other direction that bugs become more prominent because you can&#x27;t touch anything in isolation.<p>And that&#x27;s the bane of software development: touch one thing and end up breaking a dozen other things that you didn&#x27;t even think about because of interdependence.<p>So we&#x27;ve come up with design patterns and &quot;best practices&quot; that allow us to isolate our moving parts, but that has its own set of trade-offs which is what Carmack is discussing.<p>Being a 26 year veteran in the industry now (not making games btw), I think this is the type of topic that you need to be very experienced to  be able to appreciate, let alone to be able to make the judgment calls to know when inlining is the better option and why.</div><br/></div></div><div id="41790191" class="c"><input type="checkbox" id="c-41790191" checked=""/><div class="controls bullet"><span class="by">hnuser123456</span><span>|</span><a href="#41785113">parent</a><span>|</span><a href="#41788923">prev</a><span>|</span><a href="#41790361">next</a><span>|</span><label class="collapse" for="c-41790191">[-]</label><label class="expand" for="c-41790191">[1 more]</label></div><br/><div class="children"><div class="content">On a positive note, most AI-gen code will follow a style that is very &quot;average&quot; of everything it&#x27;s seen. It will have its own preferred way of laying out the code that happens to look like how most people using that language (and sharing the code online publicly), use it.</div><br/></div></div><div id="41790361" class="c"><input type="checkbox" id="c-41790361" checked=""/><div class="controls bullet"><span class="by">SoftTalker</span><span>|</span><a href="#41785113">parent</a><span>|</span><a href="#41790191">prev</a><span>|</span><a href="#41786061">next</a><span>|</span><label class="collapse" for="c-41790361">[-]</label><label class="expand" for="c-41790361">[1 more]</label></div><br/><div class="children"><div class="content">&gt; other times I&#x27;ll spend days just breaking up thousand line functions into simpler blocks just to be able to follow what&#x27;s going on<p>Absolutely, I&#x27;ll break up a long block of code into several functions, even if there is nowhere else they will be called, just to make things easier to understand (and potentially easier to test). If a function or procedure does not fit on one screen, I will almost always break it up.<p>Obviously &quot;one screen&quot; is an approximation, not all screens&#x2F;windows are the same size, but in practice for me this is about 20-30 lines.</div><br/></div></div><div id="41786061" class="c"><input type="checkbox" id="c-41786061" checked=""/><div class="controls bullet"><span class="by">tomohawk</span><span>|</span><a href="#41785113">parent</a><span>|</span><a href="#41790361">prev</a><span>|</span><a href="#41785620">next</a><span>|</span><label class="collapse" for="c-41786061">[-]</label><label class="expand" for="c-41786061">[1 more]</label></div><br/><div class="children"><div class="content">What makes an apprentice successful is learning the rules of thumb and following them.<p>What makes a journeyman successful is sticking to the rules of thumb, unless directed by a master.<p>What makes a master successful is knowing why the rules of thumb exist, what their limits are, when to not follow them, and being able to make up new rules.</div><br/></div></div><div id="41785620" class="c"><input type="checkbox" id="c-41785620" checked=""/><div class="controls bullet"><span class="by">leoh</span><span>|</span><a href="#41785113">parent</a><span>|</span><a href="#41786061">prev</a><span>|</span><a href="#41790001">next</a><span>|</span><label class="collapse" for="c-41785620">[-]</label><label class="expand" for="c-41785620">[3 more]</label></div><br/><div class="children"><div class="content">You are probably reaching for Hegel’s concept of dialectical reconciliation</div><br/><div id="41785846" class="c"><input type="checkbox" id="c-41785846" checked=""/><div class="controls bullet"><span class="by">mihaic</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785620">parent</a><span>|</span><a href="#41790001">next</a><span>|</span><label class="collapse" for="c-41785846">[-]</label><label class="expand" for="c-41785846">[2 more]</label></div><br/><div class="children"><div class="content">Not sure, didn&#x27;t Hegel say that there should be a synthesis step at some point? My view is that there should never be a synthesis when using these principles as tools, as both conflicting principles need to always maintain opposites.<p>So, more like Heraclitus&#x27;s union of opposites maybe if you really want to label it?</div><br/><div id="41787309" class="c"><input type="checkbox" id="c-41787309" checked=""/><div class="controls bullet"><span class="by">greenie_beans</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785846">parent</a><span>|</span><a href="#41790001">next</a><span>|</span><label class="collapse" for="c-41787309">[-]</label><label class="expand" for="c-41787309">[1 more]</label></div><br/><div class="children"><div class="content">the synthesis would be the outcome maybe? writing code that doesn&#x27;t follow either rule strictly:<p>&gt; Concretely related to the topic, I&#x27;ve often found myself inlining short pieces of one-time code that made functions more explicit, while at other times I&#x27;ll spend days just breaking up thousand line functions into simpler blocks just to be able to follow what&#x27;s going on. In both cases I was creating inconsistencies that younger developers nitpick -- I know I did.</div><br/></div></div></div></div></div></div><div id="41790001" class="c"><input type="checkbox" id="c-41790001" checked=""/><div class="controls bullet"><span class="by">j7ake</span><span>|</span><a href="#41785113">parent</a><span>|</span><a href="#41785620">prev</a><span>|</span><a href="#41786106">next</a><span>|</span><label class="collapse" for="c-41790001">[-]</label><label class="expand" for="c-41790001">[1 more]</label></div><br/><div class="children"><div class="content">To make an advance in a field, you must simultaneously believe in what’s currently known as well as distrust that the paradigm is all true.<p>This gives you the right mindset to focus on advancing the field in a significant way.<p>Believing in the paradigm too much will lead to only incremental results, and not believing enough will not provide enough footholds for you to work on a problem productively.</div><br/></div></div><div id="41786106" class="c"><input type="checkbox" id="c-41786106" checked=""/><div class="controls bullet"><span class="by">moss2</span><span>|</span><a href="#41785113">parent</a><span>|</span><a href="#41790001">prev</a><span>|</span><a href="#41785292">next</a><span>|</span><label class="collapse" for="c-41786106">[-]</label><label class="expand" for="c-41786106">[22 more]</label></div><br/><div class="children"><div class="content">That maxim (&quot;an intelligent person should be able to hold two opposing thoughts at the same time&quot;) is also used by religious groups to indoctrinate people. Be careful!</div><br/><div id="41786232" class="c"><input type="checkbox" id="c-41786232" checked=""/><div class="controls bullet"><span class="by">navane</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786106">parent</a><span>|</span><a href="#41786806">next</a><span>|</span><label class="collapse" for="c-41786232">[-]</label><label class="expand" for="c-41786232">[2 more]</label></div><br/><div class="children"><div class="content">So this maxim can both be used for good and for bad. Extra points for this maxim.</div><br/><div id="41786569" class="c"><input type="checkbox" id="c-41786569" checked=""/><div class="controls bullet"><span class="by">wrasee</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786232">parent</a><span>|</span><a href="#41786806">next</a><span>|</span><label class="collapse" for="c-41786569">[-]</label><label class="expand" for="c-41786569">[1 more]</label></div><br/><div class="children"><div class="content">A metamaxim?</div><br/></div></div></div></div><div id="41786806" class="c"><input type="checkbox" id="c-41786806" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786106">parent</a><span>|</span><a href="#41786232">prev</a><span>|</span><a href="#41786299">next</a><span>|</span><label class="collapse" for="c-41786806">[-]</label><label class="expand" for="c-41786806">[7 more]</label></div><br/><div class="children"><div class="content">Stretch goal: hold three</div><br/><div id="41787149" class="c"><input type="checkbox" id="c-41787149" checked=""/><div class="controls bullet"><span class="by">oofoe</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786806">parent</a><span>|</span><a href="#41787102">next</a><span>|</span><label class="collapse" for="c-41787149">[-]</label><label class="expand" for="c-41787149">[4 more]</label></div><br/><div class="children"><div class="content">Nah. That&#x27;s what the Monk is for.</div><br/><div id="41788250" class="c"><input type="checkbox" id="c-41788250" checked=""/><div class="controls bullet"><span class="by">divs1210</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41787149">parent</a><span>|</span><a href="#41793273">next</a><span>|</span><label class="collapse" for="c-41788250">[-]</label><label class="expand" for="c-41788250">[2 more]</label></div><br/><div class="children"><div class="content">A person of culture, I see.<p>Electric Monks were made for a reason.<p>Surprisingly pertinent to the current discussion.</div><br/><div id="41793279" class="c"><input type="checkbox" id="c-41793279" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41788250">parent</a><span>|</span><a href="#41793273">next</a><span>|</span><label class="collapse" for="c-41793279">[-]</label><label class="expand" for="c-41793279">[1 more]</label></div><br/><div class="children"><div class="content">apposite to the opposite</div><br/></div></div></div></div></div></div><div id="41787102" class="c"><input type="checkbox" id="c-41787102" checked=""/><div class="controls bullet"><span class="by">j_bum</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786806">parent</a><span>|</span><a href="#41787149">prev</a><span>|</span><a href="#41786299">next</a><span>|</span><label class="collapse" for="c-41787102">[-]</label><label class="expand" for="c-41787102">[2 more]</label></div><br/><div class="children"><div class="content">A safe work contribution plan for the year: Hold 1+ (stretch 3) opposing thoughts at a time.</div><br/><div id="41793294" class="c"><input type="checkbox" id="c-41793294" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41787102">parent</a><span>|</span><a href="#41786299">next</a><span>|</span><label class="collapse" for="c-41793294">[-]</label><label class="expand" for="c-41793294">[1 more]</label></div><br/><div class="children"><div class="content">&quot;hold one opposing thought&quot; could be a zen koan</div><br/></div></div></div></div></div></div><div id="41786299" class="c"><input type="checkbox" id="c-41786299" checked=""/><div class="controls bullet"><span class="by">andrewmcwatters</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786106">parent</a><span>|</span><a href="#41786806">prev</a><span>|</span><a href="#41786632">next</a><span>|</span><label class="collapse" for="c-41786299">[-]</label><label class="expand" for="c-41786299">[6 more]</label></div><br/><div class="children"><div class="content">Indoctrination is the exact opposite.</div><br/><div id="41786322" class="c"><input type="checkbox" id="c-41786322" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786299">parent</a><span>|</span><a href="#41787376">next</a><span>|</span><label class="collapse" for="c-41786322">[-]</label><label class="expand" for="c-41786322">[1 more]</label></div><br/><div class="children"><div class="content">Sure, but the maxim can be used to inject this &#x27;exact opposite&#x27;, in perfect accordance with the maxim!</div><br/></div></div><div id="41787376" class="c"><input type="checkbox" id="c-41787376" checked=""/><div class="controls bullet"><span class="by">crabbone</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786299">parent</a><span>|</span><a href="#41786322">prev</a><span>|</span><a href="#41786632">next</a><span>|</span><label class="collapse" for="c-41787376">[-]</label><label class="expand" for="c-41787376">[4 more]</label></div><br/><div class="children"><div class="content">Maybe &quot;indoctrination&quot; was a poor choice of word here.  The problem with this maxim is that it welcomes moral relativism.<p>This can be bad on the assumption that whoever is exposed to the maxim is not a proponent of &quot;virtue ethics&quot; (I use this as a catch-all term for various religious ethics doctrines, the underlying idea is that moral truths are given to people by a divine authority rather than discovered by studying human behavior, needs and happiness).  In this situation, the maxim is an invitation to embrace ideas that aren&#x27;t contradictory to one&#x27;s own, but that live &quot;outside the system&quot;, to put them on equal footing.<p>To make this more concrete, let&#x27;s suppose the subject of child brides.  Some religions have no problem with marrying girls of any age to men of any age.  Now, the maxim suggests that no matter what your moral framework looks like, you should accept that under some circumstances it&#x27;s OK to have child marriages.  But, this isn&#x27;t a contradiction.  There&#x27;s no ethical theory that&#x27;s not based on divine revelation that would accept such a thing.  And that&#x27;s why, by and large, the Western society came to treat child marriages as a crime.<p>Contradictions are only possible when two parties agree on the premises that led to contradicting conclusion, and, in principle, should be possible to be resolved by figuring out which party had a faulty process that derived a contradicting opinion.  Resolving such contradictions is a productive way forward.  But, the kind of &quot;disagreement&quot; between religious ethics and &quot;derived&quot; ethics is where the premises are different.  So, there can be no way forward in an argument between the two, because the only way the two can agree is if one completely abandons their premises.<p>Essentially, you can think about it as if two teams wanted to compete in some sport.  If both are playing soccer, then there&#x27;s a meaning to winning &#x2F; losing, keeping the score, being good or bad at the game.  But, if one team plays soccer while another team is playing chess... it just doesn&#x27;t make sense to pit them against each other.</div><br/><div id="41787791" class="c"><input type="checkbox" id="c-41787791" checked=""/><div class="controls bullet"><span class="by">wavemode</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41787376">parent</a><span>|</span><a href="#41788049">next</a><span>|</span><label class="collapse" for="c-41787791">[-]</label><label class="expand" for="c-41787791">[2 more]</label></div><br/><div class="children"><div class="content">&gt; maxim suggests that no matter what your moral framework looks like, you should accept that under some circumstances it&#x27;s OK to have child marriages<p>You seem to have either misread the maxim, or misunderstood it.<p>The maxim is not that an intelligent person -must- hold two contradictory thoughts in their head at once - rather, that they should be able to. Being &quot;able to&quot; do something, does not mean one does it in all cases.<p>To say that the maxim suggests that someone &quot;should&quot; accept that something that is bad, is sometimes good, is a plain misreading of the text. All it&#x27;s saying is that people -can- do this, if they so choose.</div><br/><div id="41788546" class="c"><input type="checkbox" id="c-41788546" checked=""/><div class="controls bullet"><span class="by">crabbone</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41787791">parent</a><span>|</span><a href="#41788049">next</a><span>|</span><label class="collapse" for="c-41788546">[-]</label><label class="expand" for="c-41788546">[1 more]</label></div><br/><div class="children"><div class="content">In this context, it doesn&#x27;t matter if they &quot;must&quot; or &quot;should be able to&quot;.  No, I didn&#x27;t misunderstand the maxim.  No, I didn&#x27;t mean that it has to happen in all cases.  You are reading something into what I wrote that I didn&#x27;t.<p>The maxim is not used by religious people to its intended effect.  Please read again, if you didn&#x27;t see it the first time.  The maxim is used as a challenge that can be rephrased as:  &quot;if you are as intelligent as you claim, then you should be able to accept both what you believe to be true and whatever nonsense I want you to believe to be true.&quot;</div><br/></div></div></div></div></div></div></div></div><div id="41786632" class="c"><input type="checkbox" id="c-41786632" checked=""/><div class="controls bullet"><span class="by">astrolx</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786106">parent</a><span>|</span><a href="#41786299">prev</a><span>|</span><a href="#41786234">next</a><span>|</span><label class="collapse" for="c-41786632">[-]</label><label class="expand" for="c-41786632">[1 more]</label></div><br/><div class="children"><div class="content">Doublethink!</div><br/></div></div><div id="41786234" class="c"><input type="checkbox" id="c-41786234" checked=""/><div class="controls bullet"><span class="by">echelon</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786106">parent</a><span>|</span><a href="#41786632">prev</a><span>|</span><a href="#41785292">next</a><span>|</span><label class="collapse" for="c-41786234">[-]</label><label class="expand" for="c-41786234">[5 more]</label></div><br/><div class="children"><div class="content">As a tool, it&#x27;s a wedge to break indoctrination and overcome bias. It leads to more pragmatic and less ideological thinking. The subject is compelled to contrast opposing views and consider the merits of each.<p>Any use by ideological groups twists the purpose of the phrase on its head. The quote encourages thinking and consideration. You&#x27;d have to turn off your brain for this to have the opposite effect.</div><br/><div id="41786332" class="c"><input type="checkbox" id="c-41786332" checked=""/><div class="controls bullet"><span class="by">darkwater</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786234">parent</a><span>|</span><a href="#41786393">next</a><span>|</span><label class="collapse" for="c-41786332">[-]</label><label class="expand" for="c-41786332">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Any use by ideological groups twists the purpose of the phrase on its head. The quote encourages thinking and consideration. You&#x27;d have to turn off your brain for this to have the opposite effect.<p>Well, it would not be too surprising that it can be used to, for example, make people think that they can trust science and also believe in some almighty, unexplainable by science divine entity.</div><br/><div id="41786597" class="c"><input type="checkbox" id="c-41786597" checked=""/><div class="controls bullet"><span class="by">asenchi</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786332">parent</a><span>|</span><a href="#41786411">next</a><span>|</span><label class="collapse" for="c-41786597">[-]</label><label class="expand" for="c-41786597">[1 more]</label></div><br/><div class="children"><div class="content">Thoughts like this miss the purpose and significance of the maxim being discussed. Science doesn&#x27;t disprove an &quot;almighty, unexplainable divine entity&quot; any more than an &quot;almighty, unexplainable divine entity&quot; could also provide science as a means to understand the nature of things.<p>Careful you don&#x27;t fall into the trap of indoctrination. :)</div><br/></div></div><div id="41786411" class="c"><input type="checkbox" id="c-41786411" checked=""/><div class="controls bullet"><span class="by">desdenova</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786332">parent</a><span>|</span><a href="#41786597">prev</a><span>|</span><a href="#41786393">next</a><span>|</span><label class="collapse" for="c-41786411">[-]</label><label class="expand" for="c-41786411">[1 more]</label></div><br/><div class="children"><div class="content">You can trust science, but science doesn&#x27;t cover all of reality.<p>My imaginary friend does, buy my magic book.</div><br/></div></div></div></div><div id="41786393" class="c"><input type="checkbox" id="c-41786393" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786234">parent</a><span>|</span><a href="#41786332">prev</a><span>|</span><a href="#41785292">next</a><span>|</span><label class="collapse" for="c-41786393">[-]</label><label class="expand" for="c-41786393">[1 more]</label></div><br/><div class="children"><div class="content">The US has a statutory rapist and someone who believes in active weather manipulation seated in Congress. It&#x27;s easy to get the masses to turn off their brains.</div><br/></div></div></div></div></div></div><div id="41785292" class="c"><input type="checkbox" id="c-41785292" checked=""/><div class="controls bullet"><span class="by">mjburgess</span><span>|</span><a href="#41785113">parent</a><span>|</span><a href="#41786106">prev</a><span>|</span><a href="#41787752">next</a><span>|</span><label class="collapse" for="c-41785292">[-]</label><label class="expand" for="c-41785292">[1 more]</label></div><br/><div class="children"><div class="content">To a certain sort of person, conversation is a game of arriving at these antithesis statements:<p><pre><code>   * Inlining code is the best form of breaking up code. 
   * Love is evil.
   * Rightwing populism is a return to leftwing politics. 
   * etc.

</code></pre>
The purpose is to induce aporia (puzzlement), and hence make it possible to evaluate apparent contradictions. However, a lot of people resent feeling uncertain, and so, people who speak this way are often disliked.</div><br/></div></div><div id="41787752" class="c"><input type="checkbox" id="c-41787752" checked=""/><div class="controls bullet"><span class="by">defaultcompany</span><span>|</span><a href="#41785113">parent</a><span>|</span><a href="#41785292">prev</a><span>|</span><a href="#41791711">next</a><span>|</span><label class="collapse" for="c-41787752">[-]</label><label class="expand" for="c-41787752">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  My goal in most cases now is to optimize code for the limits of the human mind (my own in low-effort mode)<p>I think you would appreciate the philosophy of the Grug Brained Developer: <a href="https:&#x2F;&#x2F;grugbrain.dev" rel="nofollow">https:&#x2F;&#x2F;grugbrain.dev</a></div><br/></div></div><div id="41791711" class="c"><input type="checkbox" id="c-41791711" checked=""/><div class="controls bullet"><span class="by">xnx</span><span>|</span><a href="#41785113">parent</a><span>|</span><a href="#41787752">prev</a><span>|</span><a href="#41791576">next</a><span>|</span><label class="collapse" for="c-41791711">[-]</label><label class="expand" for="c-41791711">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I was creating inconsistencies that younger developers nitpick<p>Obligatory:
“A foolish consistency is the hobgoblin of little minds&quot;<p>Continued because I&#x27;d never read the full passage:
&quot;... adored by little statesmen and philosophers and divines. With consistency a great soul has simply nothing to do. He may as well concern himself with his shadow on the wall. Speak what you think now in hard words, and to-morrow speak what to-morrow thinks in hard words again, though it contradict every thing you said to-day. — &#x27;Ah, so you shall be sure to be misunderstood.&#x27; — Is it so bad, then, to be misunderstood? Pythagoras was misunderstood, and Socrates, and Jesus, and Luther, and Copernicus, and Galileo, and Newton, and every pure and wise spirit that ever took flesh. To be great is to be misunderstood.”
― Ralph Waldo Emerson, Self-Reliance: An Excerpt from Collected Essays, First Series</div><br/></div></div><div id="41791576" class="c"><input type="checkbox" id="c-41791576" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41785113">parent</a><span>|</span><a href="#41791711">prev</a><span>|</span><a href="#41787533">next</a><span>|</span><label class="collapse" for="c-41791576">[-]</label><label class="expand" for="c-41791576">[1 more]</label></div><br/><div class="children"><div class="content">That’s undoubtedly a Zelda Fitzgerald quote (her husband plagiarized her shamelessly).<p>As a consequence of the Rule of Three, you are allowed to have rules that have one exception without having to rethink the law. All X are Y except for Z.<p>I sometimes call this the Rule of Two. Because it deserves more eyeballs than just being a subtext of another rule.</div><br/></div></div><div id="41787533" class="c"><input type="checkbox" id="c-41787533" checked=""/><div class="controls bullet"><span class="by">grbsh</span><span>|</span><a href="#41785113">parent</a><span>|</span><a href="#41791576">prev</a><span>|</span><a href="#41786495">next</a><span>|</span><label class="collapse" for="c-41787533">[-]</label><label class="expand" for="c-41787533">[1 more]</label></div><br/><div class="children"><div class="content">&gt; limits of the human mind when more and more AI-generated code will be used<p>We already have a technology which scales infinitely with the human mind: abstraction and composition of those abstractions into other abstractions.<p>Until now, we’ve focused on getting AI to produce correct code. Now that this is beginning to be successful, I think a necessary next step for it to be useful is to ensure it produces well-abstracted and clean code (such that it scales infinitely)</div><br/></div></div><div id="41786495" class="c"><input type="checkbox" id="c-41786495" checked=""/><div class="controls bullet"><span class="by">hibernator149</span><span>|</span><a href="#41785113">parent</a><span>|</span><a href="#41787533">prev</a><span>|</span><a href="#41787785">next</a><span>|</span><label class="collapse" for="c-41786495">[-]</label><label class="expand" for="c-41786495">[3 more]</label></div><br/><div class="children"><div class="content">Wait, isn&#x27;t that just Doublethink from 1984? Holding two opposing thoughts is a sign that your mental model of the world is wrong and that it needs to be fixed. Where have you heard that maxim?</div><br/><div id="41788796" class="c"><input type="checkbox" id="c-41788796" checked=""/><div class="controls bullet"><span class="by">perrygeo</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786495">parent</a><span>|</span><a href="#41786656">next</a><span>|</span><label class="collapse" for="c-41788796">[-]</label><label class="expand" for="c-41788796">[1 more]</label></div><br/><div class="children"><div class="content">No you&#x27;ve got it completely backwards. Reality has multiple facets (different statements, all of which can be true) and a mental model that insists on a singular judgement is reductionist, missing the forest for the trees. Light is a wave and a particle. People are capable of good and bad. The modern world is both amazing and unsustainable. etc.<p>Holding multiple truths is a sign that you understand the problem. Insisting on a singular judgement is a sign that you&#x27;re just parroting catchy phrases as a short cut to thinking; the real world is rarely so cut and dry.</div><br/></div></div><div id="41786656" class="c"><input type="checkbox" id="c-41786656" checked=""/><div class="controls bullet"><span class="by">HKH2</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41786495">parent</a><span>|</span><a href="#41788796">prev</a><span>|</span><a href="#41787785">next</a><span>|</span><label class="collapse" for="c-41786656">[-]</label><label class="expand" for="c-41786656">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not referring to cognitive dissonance.</div><br/></div></div></div></div></div></div><div id="41787785" class="c"><input type="checkbox" id="c-41787785" checked=""/><div class="controls bullet"><span class="by">VyseofArcadia</span><span>|</span><a href="#41785113">prev</a><span>|</span><a href="#41785518">next</a><span>|</span><label class="collapse" for="c-41787785">[-]</label><label class="expand" for="c-41787785">[24 more]</label></div><br/><div class="children"><div class="content">&gt; That was a cold-sweat moment for me: after all of my harping about latency and responsiveness, I almost shipped a title with a completely unnecessary frame of latency.<p>In this era of 3-5 frame latency being the norm (at least on e.g. the Nintendo Switch), I really appreciate a game developer having anxiety over a single frame.</div><br/><div id="41791709" class="c"><input type="checkbox" id="c-41791709" checked=""/><div class="controls bullet"><span class="by">kllrnohj</span><span>|</span><a href="#41787785">parent</a><span>|</span><a href="#41789402">next</a><span>|</span><label class="collapse" for="c-41791709">[-]</label><label class="expand" for="c-41791709">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re over-crediting Carmack and under-crediting current game devs. 3-5 frames might be current end-to-end latency, but that&#x27;s not what Carmack is talking about. He&#x27;s just talking about the game loop latency. Even at ~4 frames of end-to-end latency, he&#x27;d be talking about an easily avoided 20% regression. That&#x27;s still huge.</div><br/></div></div><div id="41789402" class="c"><input type="checkbox" id="c-41789402" checked=""/><div class="controls bullet"><span class="by">pragma_x</span><span>|</span><a href="#41787785">parent</a><span>|</span><a href="#41791709">prev</a><span>|</span><a href="#41791268">next</a><span>|</span><label class="collapse" for="c-41789402">[-]</label><label class="expand" for="c-41789402">[20 more]</label></div><br/><div class="children"><div class="content">To be fair, back in 2014 that was one frame at 60Hz or slower for some titles.  At 80-120Hz, 3-5 frames is comparatively similar time.</div><br/><div id="41789748" class="c"><input type="checkbox" id="c-41789748" checked=""/><div class="controls bullet"><span class="by">01HNNWZ0MV43FF</span><span>|</span><a href="#41787785">root</a><span>|</span><a href="#41789402">parent</a><span>|</span><a href="#41790417">next</a><span>|</span><label class="collapse" for="c-41789748">[-]</label><label class="expand" for="c-41789748">[5 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think high frame rates are common outside of PC gaming yet.<p>Wikipedia indicates the Switch maxes out at 1080p60, and the newest Zelda only at 900p30 even when docked<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Nintendo_Switch" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Nintendo_Switch</a></div><br/><div id="41789983" class="c"><input type="checkbox" id="c-41789983" checked=""/><div class="controls bullet"><span class="by">VyseofArcadia</span><span>|</span><a href="#41787785">root</a><span>|</span><a href="#41789748">parent</a><span>|</span><a href="#41791265">next</a><span>|</span><label class="collapse" for="c-41789983">[-]</label><label class="expand" for="c-41789983">[3 more]</label></div><br/><div class="children"><div class="content">I believe both the PS5 and whatever nonsense string of Xs, numbers, and descriptors MS named this gen&#x27;s console can do 144Hz output. I don&#x27;t know how many games take advantage of that or whether that refresh rate is common on TVs.</div><br/><div id="41790713" class="c"><input type="checkbox" id="c-41790713" checked=""/><div class="controls bullet"><span class="by">philistine</span><span>|</span><a href="#41787785">root</a><span>|</span><a href="#41789983">parent</a><span>|</span><a href="#41791265">next</a><span>|</span><label class="collapse" for="c-41790713">[-]</label><label class="expand" for="c-41790713">[2 more]</label></div><br/><div class="children"><div class="content">60 FPS isn&#x27;t even promised on PS5 Pro. Most graphically demanding titles still aim for 30 FPS on consoles, with any game able to support 60 FPS consistently worth noting.</div><br/><div id="41793063" class="c"><input type="checkbox" id="c-41793063" checked=""/><div class="controls bullet"><span class="by">Narishma</span><span>|</span><a href="#41787785">root</a><span>|</span><a href="#41790713">parent</a><span>|</span><a href="#41791265">next</a><span>|</span><label class="collapse" for="c-41793063">[-]</label><label class="expand" for="c-41793063">[1 more]</label></div><br/><div class="children"><div class="content">What they said is true. There are some games with 120 FPS modes on PS5 and Series X, maybe even series S. That doesn&#x27;t mean every game (or even most) are like that, just that the hardware supports it. At the end of the day you can&#x27;t stop developers targeting whatever framerate they want.</div><br/></div></div></div></div></div></div><div id="41791265" class="c"><input type="checkbox" id="c-41791265" checked=""/><div class="controls bullet"><span class="by">marxisttemp</span><span>|</span><a href="#41787785">root</a><span>|</span><a href="#41789748">parent</a><span>|</span><a href="#41789983">prev</a><span>|</span><a href="#41790417">next</a><span>|</span><label class="collapse" for="c-41791265">[-]</label><label class="expand" for="c-41791265">[1 more]</label></div><br/><div class="children"><div class="content">I play Fortnite and Call of Duty at 120Hz VRR on Xbox Series X.</div><br/></div></div></div></div><div id="41790417" class="c"><input type="checkbox" id="c-41790417" checked=""/><div class="controls bullet"><span class="by">astrobe_</span><span>|</span><a href="#41787785">root</a><span>|</span><a href="#41789402">parent</a><span>|</span><a href="#41789748">prev</a><span>|</span><a href="#41790542">next</a><span>|</span><label class="collapse" for="c-41790417">[-]</label><label class="expand" for="c-41790417">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve heard that a good reaction time is around 200 ms, some experiments seem to confirm this figure [1]. At 60Hz, a frame is displayed every 17 ms.<p>So it would take a 12 frames animation and a trained gamer for a couple of frames to make a difference (e.g. push the right button before the animation ends and the opponent&#x27;s action takes effect).<p>[1] <a href="https:&#x2F;&#x2F;humanbenchmark.com&#x2F;tests&#x2F;reactiontime&#x2F;statistics" rel="nofollow">https:&#x2F;&#x2F;humanbenchmark.com&#x2F;tests&#x2F;reactiontime&#x2F;statistics</a></div><br/><div id="41790734" class="c"><input type="checkbox" id="c-41790734" checked=""/><div class="controls bullet"><span class="by">sjm</span><span>|</span><a href="#41787785">root</a><span>|</span><a href="#41790417">parent</a><span>|</span><a href="#41791396">next</a><span>|</span><label class="collapse" for="c-41790734">[-]</label><label class="expand" for="c-41790734">[1 more]</label></div><br/><div class="children"><div class="content">Reaction time is completely different to the input latency Carmack is worrying about in his scenario. Imagine if you thought I&#x27;m going to move my arm, and 200ms later your arm actually moved. Apply the same to a first-person shooter --- imagine you nudge your mouse slightly, and 200ms later you get some movement on screen. That is ___hugely___ noticeable.</div><br/></div></div><div id="41791396" class="c"><input type="checkbox" id="c-41791396" checked=""/><div class="controls bullet"><span class="by">harrison_clarke</span><span>|</span><a href="#41787785">root</a><span>|</span><a href="#41790417">parent</a><span>|</span><a href="#41790734">prev</a><span>|</span><a href="#41790495">next</a><span>|</span><label class="collapse" for="c-41791396">[-]</label><label class="expand" for="c-41791396">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.researchgate.net&#x2F;publication&#x2F;266655520_In_the_blink_of_an_eye_Investigating_latency_perception_during_stylus_interaction" rel="nofollow">https:&#x2F;&#x2F;www.researchgate.net&#x2F;publication&#x2F;266655520_In_the_bl...</a><p>this is for a stylus, but people can detect input latency as low as 1ms (possibly lower)<p>with VR, they use the term &quot;motion to photon latency&quot;, and if it&#x27;s over ~20ms, people start getting dizzy. at 200ms, nobody is going to be keeping their lunch down<p>google noticed people making fewer searches if they delayed the result by 100ms<p>edit: if you want an easy demo, open up vim&#x2F;nano over ssh, and type something. then try it locally</div><br/></div></div><div id="41790495" class="c"><input type="checkbox" id="c-41790495" checked=""/><div class="controls bullet"><span class="by">underdeserver</span><span>|</span><a href="#41787785">root</a><span>|</span><a href="#41790417">parent</a><span>|</span><a href="#41791396">prev</a><span>|</span><a href="#41790542">next</a><span>|</span><label class="collapse" for="c-41790495">[-]</label><label class="expand" for="c-41790495">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure this is the right way to look at it. I can&#x27;t find stats right now, but I recall reading top players making frame-perfect moves in games like Smash Bros. Melee and Rocket League.</div><br/><div id="41791062" class="c"><input type="checkbox" id="c-41791062" checked=""/><div class="controls bullet"><span class="by">mywittyname</span><span>|</span><a href="#41787785">root</a><span>|</span><a href="#41790495">parent</a><span>|</span><a href="#41790688">next</a><span>|</span><label class="collapse" for="c-41791062">[-]</label><label class="expand" for="c-41791062">[2 more]</label></div><br/><div class="children"><div class="content">The mistake with focusing on reaction time is that humans can anticipate actions and can perform complex sequences of actions pretty quickly (we have two hands and 10 fingers).  So someone playing one of those &quot;test your reaction time&quot; games might only score like 30ms.  But someone playing a musical instrument can still play a 64th note at 120BPM.<p>Imagine playing a drum that took between 0 and 5 extra frames at 60FPS between striking the head and it producing a sound.  Most people would notice that kind of delay, even if they can&#x27;t &quot;react&quot; that quickly.<p>In games, frame delay translates to having to hold down a key (or wait before pressing the next one) for longer than is strickly necessary in order to produce an effect.  Since fighting games are all about key sequences, the difference between needing to hold key for 0 frames and 5 frames is massive when you consider key combinations might be sequences of up to 5 key presses.  5 frames of delay x five sequential key presses x 8ms a frame = 1600ms vs 1 frame x 5 seq. key presses x 8ms = 40ms.<p>There&#x27;s a massive difference between taking 1.6s to execute a complex move and 0.040s.</div><br/><div id="41791908" class="c"><input type="checkbox" id="c-41791908" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#41787785">root</a><span>|</span><a href="#41791062">parent</a><span>|</span><a href="#41790688">next</a><span>|</span><label class="collapse" for="c-41791908">[-]</label><label class="expand" for="c-41791908">[1 more]</label></div><br/><div class="children"><div class="content">Another example is music (and relatedly, rythm games). With memorized music you have maximal anticipation of actions. The regular rithm only amplifies that anticipation. Musicians can be very consistent at timing (especially rithm section), and very little latency or jitter can throw that off.</div><br/></div></div></div></div><div id="41790688" class="c"><input type="checkbox" id="c-41790688" checked=""/><div class="controls bullet"><span class="by">philistine</span><span>|</span><a href="#41787785">root</a><span>|</span><a href="#41790495">parent</a><span>|</span><a href="#41791062">prev</a><span>|</span><a href="#41790542">next</a><span>|</span><label class="collapse" for="c-41790688">[-]</label><label class="expand" for="c-41790688">[1 more]</label></div><br/><div class="children"><div class="content">Frame perfect moves are exceedingly common in most top fields. Just watch any video about the latest speedruns.<p>The thing with latency is it needs to be consistent. If your latency is between 3 to 5 frames you blew it because you can&#x27;t guarantee the same experience on every button press. If you always have 3 frames of latency, with modern screens, analog controls, and game design aware of those limitations, that&#x27;s much better. Look at modern games like <i>Celeste</i>, who has introduced <i>Coyote Time</i> to account for all the latency of our modern hardware.</div><br/></div></div></div></div></div></div><div id="41790542" class="c"><input type="checkbox" id="c-41790542" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#41787785">root</a><span>|</span><a href="#41789402">parent</a><span>|</span><a href="#41790417">prev</a><span>|</span><a href="#41790731">next</a><span>|</span><label class="collapse" for="c-41790542">[-]</label><label class="expand" for="c-41790542">[6 more]</label></div><br/><div class="children"><div class="content">Why would you even bother running at a game at 120Hz if the user&#x27;s response to what&#x27;s being drawn is effectively 24-30 FPS?</div><br/><div id="41790813" class="c"><input type="checkbox" id="c-41790813" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41787785">root</a><span>|</span><a href="#41790542">parent</a><span>|</span><a href="#41791285">next</a><span>|</span><label class="collapse" for="c-41790813">[-]</label><label class="expand" for="c-41790813">[4 more]</label></div><br/><div class="children"><div class="content">You&#x27;ve seen games running at 120Hz and at 60Hz.  The difference is obvious, isn&#x27;t it?  The difference between 24Hz and 60Hz is certainly obvious: that&#x27;s the visual difference between movies and TV sitcoms.<p>I can type about 90 words per minute on QWERTY, which is about 8 keystrokes per second.  That means that the <i>average</i> interval between keystrokes is about 120 milliseconds, already significantly less than my 200-millisecond reaction time, and many keystrokes are closer together than that—but I rarely make typographical errors.  Fast typists can hit 150 words per minute.  Performing musicians consistently nail note timing to within about 40 milliseconds.  So it turns out that people do routinely time their physical movements a lot more precisely than their reaction time.  Their <i>jitter</i> is much lower than their <i>latency</i>, a phenomenon you are surely familiar with in other contexts, such as netcode for games.<p>If someone&#x27;s latency is 200 milliseconds but its jitter (measured as standard deviation) is 10 milliseconds, then reducing the frame latency from a worst-case 16.7 milliseconds (or 33.3 milliseconds in your 30Hz example) to a worst-case 8.3 milliseconds, and average-case 8.3 milliseconds to average-case 4.2 milliseconds, you&#x27;re knocking off a whole 0.42 standard deviations off their latency.  If they&#x27;re playing against someone else with the same latency, that 0.42<i>σ</i> advantage is very significant!  I think they&#x27;ll win almost 61% of the time, but I&#x27;m not sure of my statistics†.<p>See also <a href="https:&#x2F;&#x2F;danluu.com&#x2F;input-lag&#x2F;#appendix-why-measure-latency" rel="nofollow">https:&#x2F;&#x2F;danluu.com&#x2F;input-lag&#x2F;#appendix-why-measure-latency</a>:<p>&gt; <i>Latency matters! For very simple tasks, people can perceive latencies down to 2 ms or less. Moreover, increasing latency is not only noticeable to users, it causes users to execute simple tasks less accurately. If you want a visual demonstration of what latency looks like and you don’t have a super-fast old computer lying around, check out this MSR demo on touchscreen latency.</i><p>&gt; <i>The most commonly cited document on response time is the nielsen group[sic] article on response times, which claims that latncies[sic] below 100ms feel equivalent and perceived[sic] as instantaneous. One easy way to see that this is false is to go into your terminal and try</i> sleep 0; echo &quot;pong&quot; <i>vs.</i> sleep 0.1; echo &quot;test&quot; <i>(or for that matter, try playing an old game that doesn&#x27;t have latency compensation, like quake 1, with 100 ms ping, or even 30 ms ping, or try typing in a terminal with 30 ms ping). For more info on this and other latency fallacies, see this document on common misconceptions about latency.</i><p>(The original contains several links substantiating those claims.)<p><a href="https:&#x2F;&#x2F;danluu.com&#x2F;keyboard-latency&#x2F;#appendix-counter-arguments-to-common-arguments-that-latency-doesn-t-matter" rel="nofollow">https:&#x2F;&#x2F;danluu.com&#x2F;keyboard-latency&#x2F;#appendix-counter-argume...</a> has a longer explanation.<p>______<p>† First I tried sum(rnorm(100000) &lt; rnorm(100000) + 0.42)&#x2F;1000, which comes to about 61.7 (%).  But it&#x27;s not a consistent 0.42<i>σ</i> of latency being added; it&#x27;s a random latency of up to 0.83<i>σ</i>, so I tried sum(rnorm(100000) &lt; rnorm(100000) + runif(100000, max=0.83))&#x2F;1000, which gave the same result.  But that&#x27;s not taking into account that actually both players have latency, so if we model random latency of up to a frame for the 60Hz player with sum(rnorm(100000) + runif(100000, max=1.67) &gt; rnorm(100000) + runif(100000, max=0.83))&#x2F;1000, we get more like a 60.8% chance that the 120fps player will out-twitch them.  I&#x27;m sure someone who actually knows statistics can tell me the correct way to model this to get the right answer in closed form, but I&#x27;m not sure I could tell the correct closed-form formula from an incorrect one, so I resorted to brute force.</div><br/><div id="41791962" class="c"><input type="checkbox" id="c-41791962" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#41787785">root</a><span>|</span><a href="#41790813">parent</a><span>|</span><a href="#41791285">next</a><span>|</span><label class="collapse" for="c-41791962">[-]</label><label class="expand" for="c-41791962">[3 more]</label></div><br/><div class="children"><div class="content"><i>&gt; You&#x27;ve seen games running at 120Hz and at 60Hz. The difference is obvious, isn&#x27;t it?</i><p>Honestly, I have not. I&#x27;m not much of a gamer, even though I used to be a game developer.<p>Certainly the difference between 30Hz and 60Hz is noticeable.<p>Maybe this is just because I&#x27;m old school but if it were me, I would absolutely prioritize low latency over high frame rate. When you played an early console game, the controls felt like they were concretely wired to the character on screen in a way that most games I play today lack. There&#x27;s a really annoying spongey-ness to how games feel that I attribute largely to latency.<p>I don&#x27;t really give a shit about fancy graphics and animation (I prefer 2D games). But I want the controls to feel solid and snappy.<p>I also make electronic music and it&#x27;s the same thing there. Making music on a computer is wonderful and powerful in many ways, but it doesn&#x27;t have the same immediacy as pushing a button on a hardware synth (well, on most hardware synths).</div><br/><div id="41792130" class="c"><input type="checkbox" id="c-41792130" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41787785">root</a><span>|</span><a href="#41791962">parent</a><span>|</span><a href="#41791285">next</a><span>|</span><label class="collapse" for="c-41792130">[-]</label><label class="expand" for="c-41792130">[2 more]</label></div><br/><div class="children"><div class="content">Oh!  I assumed that because you were a famous game developer you would hang out with gamers who would proudly show off their 120Hz monitor setups.<p>I agree that low latency is more important than high frame rate, and I agree about the snappiness.  But low <i>jitter</i> is even more important for that than low latency, and a sufficiently low frame rate imposes a minimum of jitter.<p>Music is even less tolerant of latency, and PCM measures its jitter tolerance in single-digit microseconds.</div><br/><div id="41794624" class="c"><input type="checkbox" id="c-41794624" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#41787785">root</a><span>|</span><a href="#41792130">parent</a><span>|</span><a href="#41791285">next</a><span>|</span><label class="collapse" for="c-41794624">[-]</label><label class="expand" for="c-41794624">[1 more]</label></div><br/><div class="children"><div class="content">Haha, alas the reality of my celebrity is not as much as you might hope. :)</div><br/></div></div></div></div></div></div></div></div><div id="41791285" class="c"><input type="checkbox" id="c-41791285" checked=""/><div class="controls bullet"><span class="by">marxisttemp</span><span>|</span><a href="#41787785">root</a><span>|</span><a href="#41790542">parent</a><span>|</span><a href="#41790813">prev</a><span>|</span><a href="#41790731">next</a><span>|</span><label class="collapse" for="c-41791285">[-]</label><label class="expand" for="c-41791285">[1 more]</label></div><br/><div class="children"><div class="content">You’re still getting more information, which allows you to be more accurate with your inputs e.g. tracking a moving target.</div><br/></div></div></div></div><div id="41790731" class="c"><input type="checkbox" id="c-41790731" checked=""/><div class="controls bullet"><span class="by">chandler5555</span><span>|</span><a href="#41787785">root</a><span>|</span><a href="#41789402">parent</a><span>|</span><a href="#41790542">prev</a><span>|</span><a href="#41791268">next</a><span>|</span><label class="collapse" for="c-41790731">[-]</label><label class="expand" for="c-41790731">[1 more]</label></div><br/><div class="children"><div class="content">yeah but when people talk about input lag for consoles its generally still in the 60hz sense, rare for games to be 120hz<p>smash brothers ultimate for example runs at 60fps and has 5-6 frames of input lag</div><br/></div></div></div></div><div id="41791268" class="c"><input type="checkbox" id="c-41791268" checked=""/><div class="controls bullet"><span class="by">doctorpangloss</span><span>|</span><a href="#41787785">parent</a><span>|</span><a href="#41789402">prev</a><span>|</span><a href="#41785518">next</a><span>|</span><label class="collapse" for="c-41791268">[-]</label><label class="expand" for="c-41791268">[2 more]</label></div><br/><div class="children"><div class="content">&gt; In this era of 3-5 frame latency being the norm (at least on e.g. the Nintendo Switch)<p>Which titles is this true for? Have you or anyone else measured?</div><br/><div id="41796477" class="c"><input type="checkbox" id="c-41796477" checked=""/><div class="controls bullet"><span class="by">grougnax</span><span>|</span><a href="#41787785">root</a><span>|</span><a href="#41791268">parent</a><span>|</span><a href="#41785518">next</a><span>|</span><label class="collapse" for="c-41796477">[-]</label><label class="expand" for="c-41796477">[1 more]</label></div><br/><div class="children"><div class="content">Almost every title. This is common knowledge.</div><br/></div></div></div></div></div></div><div id="41785518" class="c"><input type="checkbox" id="c-41785518" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41787785">prev</a><span>|</span><a href="#41787870">next</a><span>|</span><label class="collapse" for="c-41785518">[-]</label><label class="expand" for="c-41785518">[32 more]</label></div><br/><div class="children"><div class="content">His overall solution highlighted in the intro is that he&#x27;s moved on from inlining and now does pure functional programming. Inlining is only relevant for him during IO or state changes which he does as minimally as possible and segregates this from his core logic.<p>Pure functional programming is the bigger insight here that most programmers will just never understand why there&#x27;s a benefit there. In fact most programmers don&#x27;t even completely understand what FP is. To most people FP is just a bunch of functional patterns like map, reduce, filter, etc. They never grasp the true nature of &quot;purity&quot; in functional programming.<p>You see this lack of insight in this thread. Most responders literally ignore the fact that Carmack called his email completely outdated and that he mostly does pure FP now.</div><br/><div id="41785930" class="c"><input type="checkbox" id="c-41785930" checked=""/><div class="controls bullet"><span class="by">wmanley</span><span>|</span><a href="#41785518">parent</a><span>|</span><a href="#41789247">next</a><span>|</span><label class="collapse" for="c-41785930">[-]</label><label class="expand" for="c-41785930">[14 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s the link where he discusses functional programming style:<p><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20170116040923&#x2F;http:&#x2F;&#x2F;gamasutra.com&#x2F;view&#x2F;news&#x2F;169296&#x2F;Indepth_Functional_programming_in_C.php" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20170116040923&#x2F;http:&#x2F;&#x2F;gamasutra....</a><p>He does <i>not</i> say that that his email is completely outdated - he just says that calling pure functions is exempt from the inlining rule.<p>He&#x27;s not off writing pure FP now.  His approach is still deeply pragmatic.  In the link above he discusses degrees of function purity.  &quot;Pure FP&quot; has a whole different connotation - where whole programs are written in that constrained style.</div><br/><div id="41790149" class="c"><input type="checkbox" id="c-41790149" checked=""/><div class="controls bullet"><span class="by">pragma_x</span><span>|</span><a href="#41785518">root</a><span>|</span><a href="#41785930">parent</a><span>|</span><a href="#41790080">next</a><span>|</span><label class="collapse" for="c-41790149">[-]</label><label class="expand" for="c-41790149">[8 more]</label></div><br/><div class="children"><div class="content">Thank you for this.  I appreciate that this (classic) article lays bare the essence of FP without the usual pomp and &quot;use Lisp&#x2F;Scheme&#x2F;Haskell already&quot; rhetoric.  My takeaway is that FP is mostly about using functions w&#x2F;o side effects (pure), which can be achieved in any programming language provided you&#x27;re diligent about it.</div><br/><div id="41791428" class="c"><input type="checkbox" id="c-41791428" checked=""/><div class="controls bullet"><span class="by">zelphirkalt</span><span>|</span><a href="#41785518">root</a><span>|</span><a href="#41790149">parent</a><span>|</span><a href="#41791997">next</a><span>|</span><label class="collapse" for="c-41791428">[-]</label><label class="expand" for="c-41791428">[1 more]</label></div><br/><div class="children"><div class="content">This is a bit naive though. It depends on what you want to do and whether the language you are using offers the required primitives and other things like persistent functional data structures. Without those, you will find yourself hard-pressed to make FP happen. It is of course usually possible with most languages (except those where primitives are already mutating and therefore infectiously prevent you from writing pure functions), but it might not be idiomatic at all, or might not be feasible to roll all things your own, to replace any mutating basics. For example imagine having to copy a data structure all over the place again and again, because its methods are mutating its internal state. That would be inefficient, much more inefficient than a well written corresponding functional data structure, and it would be ugly code.<p>Are you going to write that extra data structure, when your task is actually something else? Some management breathing down your neck, asking when something will be done? Or not so well versed coworkers complaining about you adding a lot of code that might need to be maintained by them, while they don&#x27;t understand FP? Do you even have the knowledge to implement that data structure in the first place, or will you need to study a couple of papers and carefully translate their code, if any, i to your language and then verify expected performance in meaningful benchmarks?<p>Lots of problems can arise there in practice.</div><br/></div></div><div id="41791997" class="c"><input type="checkbox" id="c-41791997" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41785518">root</a><span>|</span><a href="#41790149">parent</a><span>|</span><a href="#41791428">prev</a><span>|</span><a href="#41790080">next</a><span>|</span><label class="collapse" for="c-41791997">[-]</label><label class="expand" for="c-41791997">[6 more]</label></div><br/><div class="children"><div class="content">No functional programming is about programming as if your code is a math equation.<p>In math people never use procedures. They write definitions in math in terms of formulas and expressions.<p>If you can get everything to fit on one line in your programming. Then you are doing functional programming.<p>The lack of side effects, lack of mutation and high modularity are the beneficial outcome of fp, it is not the core of what you&#x27;re doing. The core of what you&#x27;re doing is your defining your program as a formula&#x2F;equation&#x2F;expression rather then a list of procedures or steps. Of course, why you would write your program this way is because of the beneficial outcomes.<p>By coincidence if you write your code in a way where you just account for the side effects like deliberately avoiding mutation, IO and side effects... then your program will become isomorphic to a mathematical function. So it goes both ways.<p>Another thing you will note and most people don&#x27;t get this is that for loops don&#x27;t exist in FP. The fundamental unit of &quot;looping&quot; in fp is always done with recursion, just like how they would do it in mathematical expressions.</div><br/><div id="41794763" class="c"><input type="checkbox" id="c-41794763" checked=""/><div class="controls bullet"><span class="by">wrsh07</span><span>|</span><a href="#41785518">root</a><span>|</span><a href="#41791997">parent</a><span>|</span><a href="#41793773">next</a><span>|</span><label class="collapse" for="c-41794763">[-]</label><label class="expand" for="c-41794763">[2 more]</label></div><br/><div class="children"><div class="content">As someone who likes math (math major, applied math grad) and who picked up functional programming relatively early in my career, I don&#x27;t find this model (fp is just math) to improve my understanding or make it easier to understand why I would want to program like this<p>Talking about state and error handling is helpful because it helps explain why to use the tool, not how the tool was forged (or originally conceived)</div><br/><div id="41794944" class="c"><input type="checkbox" id="c-41794944" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41785518">root</a><span>|</span><a href="#41794763">parent</a><span>|</span><a href="#41793773">next</a><span>|</span><label class="collapse" for="c-41794944">[-]</label><label class="expand" for="c-41794944">[1 more]</label></div><br/><div class="children"><div class="content">This doesn’t help you understand why you should do functional programming.<p>It just helps you understand the nature of what functional programming actually is. Too many people think it’s just immutability, anonymous functions, map, reduce and filter.<p>Understanding why you should do functional programming is orthogonal to understanding what it is.<p>Even if I tell you functional programming is more modular and referentially transparent and lacks state. None of these things truly register until you have done both imperative programming and Haskell programming for a non trivial amount of time.<p>Also error handling is orthogonal to functional programming. Yes I know it’s clever how Haskell does it but it’s independent to functional programming… and even so.. explaining maybe monads or any other error monad just makes things less understandable.</div><br/></div></div></div></div><div id="41793773" class="c"><input type="checkbox" id="c-41793773" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41785518">root</a><span>|</span><a href="#41791997">parent</a><span>|</span><a href="#41794763">prev</a><span>|</span><a href="#41790080">next</a><span>|</span><label class="collapse" for="c-41793773">[-]</label><label class="expand" for="c-41793773">[3 more]</label></div><br/><div class="children"><div class="content">For-loops do exist, they just need to not have side effects, which in practice means the likes of map&#x2F;filter&#x2F;reduce (ideally promoted to a first class language feature like sequence comprehensions).<p>You could argue that those are still desugared to recursion, but I think at that point it&#x27;s kinda moot - the construct is still readily recognizable as a loop, and it&#x27;s most likely also implemented under the hood as an imperative loop with encapsulated local state; not that it matters so long as semantics stay the same.<p>In general, so long as mutation can be encapsulated in modules that only expose pure functional interfaces, I think it should still count as FP for practical purposes.</div><br/><div id="41794086" class="c"><input type="checkbox" id="c-41794086" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41785518">root</a><span>|</span><a href="#41793773">parent</a><span>|</span><a href="#41794781">next</a><span>|</span><label class="collapse" for="c-41794086">[-]</label><label class="expand" for="c-41794086">[1 more]</label></div><br/><div class="children"><div class="content">&gt;For-loops do exist, they just need to not have side effects,<p>No they don&#x27;t. For loops and loops in general are procedural actions. You are jumping from directive to directive, command to command. Loops are NOT functional at all. loops are an artifact of the computational machine, jumping to different instructions.<p>Functional programs like functions in mathematics DO not contain for loops.<p>&gt; which in practice means the likes of map&#x2F;filter&#x2F;reduce (ideally promoted to a first class language feature like sequence comprehensions).
&gt;You could argue that those are still desugared to recursion, but I think at that point it&#x27;s kinda moot - the construct is still readily recognizable as a loop,<p>All programs are desugared into assembly instructions. Assembly instructions are procedural by nature... they are not functional so your point is moot as everything is desugared into loop based jumps.<p>map&#x2F;filter&#x2F;reduce Are not loops. They are fundamentally different. It doesn&#x27;t matter if it&#x27;s &quot;recognizeable&quot; as a loop, it is NOT a loop. There is an isomorphism between imperative and functional programming, So the definition of Loop vs. no loops refers to the superficial differences between the two EVEN when the underlying things are the same.<p>&gt;In general, so long as mutation can be encapsulated in modules that only expose pure functional interfaces, I think it should still count as FP for practical purposes.<p>It actually can&#x27;t... for loops rely on mutation to work.<p>a for loop looks like this:<p><pre><code>     &lt;OUTER SCOPE&gt;
     for i in range(10):
          &lt;INNER SCOPE&gt;
</code></pre>
By nature the for loop needs to influence outer scope otherwise your for loop is utterly useless. So how would you influence outer scope from inner scope?<p><pre><code>     &lt;VARIABLE FROM OUTER SCOPE&gt;
     for i in range(10):
          &lt;MUTATE VARIABLE FROM OUTER SCOPE WITHIN INNER SCOPE&gt;
</code></pre>
That&#x27;s the only way man.<p>This is the fundamental nature of for loops. They are imperative constructs. Sure it can look very similar to map or reduce or even filter, but THEY are not the same.</div><br/></div></div><div id="41794781" class="c"><input type="checkbox" id="c-41794781" checked=""/><div class="controls bullet"><span class="by">wrsh07</span><span>|</span><a href="#41785518">root</a><span>|</span><a href="#41793773">parent</a><span>|</span><a href="#41794086">prev</a><span>|</span><a href="#41790080">next</a><span>|</span><label class="collapse" for="c-41794781">[-]</label><label class="expand" for="c-41794781">[1 more]</label></div><br/><div class="children"><div class="content">Largely orthogonal to your comment:<p>One interesting thing I learned&#x2F;realized when reading about the msr dafny project is that for loops mean you need to provide guarantees about invariants.<p>How do I know there&#x27;s no index out of bounds? How do I know how large the resulting array is?<p>When you have to write post conditions for each loop, it makes higher order functions (map, reduce, filter) much more appealing. The proof was already done in the function that will invoke yours!</div><br/></div></div></div></div></div></div></div></div><div id="41790080" class="c"><input type="checkbox" id="c-41790080" checked=""/><div class="controls bullet"><span class="by">solomonb</span><span>|</span><a href="#41785518">root</a><span>|</span><a href="#41785930">parent</a><span>|</span><a href="#41790149">prev</a><span>|</span><a href="#41788878">next</a><span>|</span><label class="collapse" for="c-41790080">[-]</label><label class="expand" for="c-41790080">[1 more]</label></div><br/><div class="children"><div class="content">The original article literally starts with this:<p>&gt; In the years since I wrote this, I have gotten much more bullish about pure functional programming, even in C&#x2F;C++ where reasonable: (link) &gt; &gt;The real enemy addressed by inlining is unexpected dependency and mutation of state, which functional programming solves more directly and completely. However, if you are going to make a lot of state changes, having them all happen inline does have advantages; you should be made constantly aware of the full horror of what you are doing.<p>He explicitly says that functional programming solves the same issue as inlining but more directly and completely.</div><br/></div></div><div id="41788878" class="c"><input type="checkbox" id="c-41788878" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41785518">root</a><span>|</span><a href="#41785930">parent</a><span>|</span><a href="#41790080">prev</a><span>|</span><a href="#41789247">next</a><span>|</span><label class="collapse" for="c-41788878">[-]</label><label class="expand" for="c-41788878">[4 more]</label></div><br/><div class="children"><div class="content">He literally said he’s bullish on pure fp. Which means he is off writing pure fp. His own article about it never explicitly or implicitly implies a “pragmatic approach”.<p>I never said he said his email was completely outdated. He for sure implies it’s outdated and updates us on his views of inlining which I also mentioned.</div><br/><div id="41789635" class="c"><input type="checkbox" id="c-41789635" checked=""/><div class="controls bullet"><span class="by">coob</span><span>|</span><a href="#41785518">root</a><span>|</span><a href="#41788878">parent</a><span>|</span><a href="#41789247">next</a><span>|</span><label class="collapse" for="c-41789635">[-]</label><label class="expand" for="c-41789635">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I never said he said his email was completely outdated.<p>From your prior message:<p>&gt; Carmack called his email completely outdated</div><br/><div id="41789759" class="c"><input type="checkbox" id="c-41789759" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41785518">root</a><span>|</span><a href="#41789635">parent</a><span>|</span><a href="#41789247">next</a><span>|</span><label class="collapse" for="c-41789759">[-]</label><label class="expand" for="c-41789759">[2 more]</label></div><br/><div class="children"><div class="content">Ok my bad but I did mention what he’s doing with inlining. So I contradicted myself in the original message which you didn’t identify.<p>He still does inlining.</div><br/></div></div></div></div></div></div></div></div><div id="41789247" class="c"><input type="checkbox" id="c-41789247" checked=""/><div class="controls bullet"><span class="by">eyelidlessness</span><span>|</span><a href="#41785518">parent</a><span>|</span><a href="#41785930">prev</a><span>|</span><a href="#41786084">next</a><span>|</span><label class="collapse" for="c-41789247">[-]</label><label class="expand" for="c-41789247">[2 more]</label></div><br/><div class="children"><div class="content">I think more people grasp functional programming all the time, or at least the most salient detail: referential transparency. It’s easy to show the benefits in the small, without getting heavy on academics: pure functions are easier to test, understand, and change with confidence. All three of these reinforce each other, but they’re each independently beneficial as well.<p>There are tons of benefits to get from learning this lesson in a more intentional way—I know that I changed my entire outlook on programming after some time working in Clojure!—but I’ve seen other devs take the same lessons in multi-paradigm contexts as well.</div><br/><div id="41789799" class="c"><input type="checkbox" id="c-41789799" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41785518">root</a><span>|</span><a href="#41789247">parent</a><span>|</span><a href="#41786084">next</a><span>|</span><label class="collapse" for="c-41789799">[-]</label><label class="expand" for="c-41789799">[1 more]</label></div><br/><div class="children"><div class="content">Not just this. Modularity is the main insight as well. The reason why oop doesn’t work is because methods can’t be broken down. Your atom is oop is literally a collection of methods tied to mutating state. You cannot break down that collection further.<p>In pure fp. You can break your function down into the smallest computational unit possible. This is what prevents technical debt of the architectural nature as you can rewrite your code as simply recomposing your modular logic.</div><br/></div></div></div></div><div id="41786084" class="c"><input type="checkbox" id="c-41786084" checked=""/><div class="controls bullet"><span class="by">Hendrikto</span><span>|</span><a href="#41785518">parent</a><span>|</span><a href="#41789247">prev</a><span>|</span><a href="#41791336">next</a><span>|</span><label class="collapse" for="c-41786084">[-]</label><label class="expand" for="c-41786084">[6 more]</label></div><br/><div class="children"><div class="content">&gt; he&#x27;s moved on from inlining and now does pure functional programming<p>Neither of those are true. He does more FP ”where reasonable“, and that decreases the need for inlining. He does not do pure FP, and he still inlines.</div><br/><div id="41790103" class="c"><input type="checkbox" id="c-41790103" checked=""/><div class="controls bullet"><span class="by">solomonb</span><span>|</span><a href="#41785518">root</a><span>|</span><a href="#41786084">parent</a><span>|</span><a href="#41788886">next</a><span>|</span><label class="collapse" for="c-41790103">[-]</label><label class="expand" for="c-41790103">[3 more]</label></div><br/><div class="children"><div class="content">&quot;pure FP&quot; does not mean only writing in a functional style. Purity refers to referential transparency, ie., functions do not depend on or modify some global state.</div><br/><div id="41796560" class="c"><input type="checkbox" id="c-41796560" checked=""/><div class="controls bullet"><span class="by">Hendrikto</span><span>|</span><a href="#41785518">root</a><span>|</span><a href="#41790103">parent</a><span>|</span><a href="#41791474">next</a><span>|</span><label class="collapse" for="c-41796560">[-]</label><label class="expand" for="c-41796560">[1 more]</label></div><br/><div class="children"><div class="content">I know what purity is. It is a core principle of functional programing. So ”functional“ already implies purity, and ”pure functional“ implies exclusively functional (e.g. Haskell).</div><br/></div></div><div id="41791474" class="c"><input type="checkbox" id="c-41791474" checked=""/><div class="controls bullet"><span class="by">zelphirkalt</span><span>|</span><a href="#41785518">root</a><span>|</span><a href="#41790103">parent</a><span>|</span><a href="#41796560">prev</a><span>|</span><a href="#41788886">next</a><span>|</span><label class="collapse" for="c-41791474">[-]</label><label class="expand" for="c-41791474">[1 more]</label></div><br/><div class="children"><div class="content">Actually even further: They also don&#x27;t modify&#x2F;mutate any arguments. If they did, then that could raise problems with concurrency.</div><br/></div></div></div></div><div id="41788886" class="c"><input type="checkbox" id="c-41788886" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41785518">root</a><span>|</span><a href="#41786084">parent</a><span>|</span><a href="#41790103">prev</a><span>|</span><a href="#41791336">next</a><span>|</span><label class="collapse" for="c-41788886">[-]</label><label class="expand" for="c-41788886">[2 more]</label></div><br/><div class="children"><div class="content">He literally says he’s more bullish on pure fp. Read it. And I also wrote about where he still inlines.</div><br/><div id="41796569" class="c"><input type="checkbox" id="c-41796569" checked=""/><div class="controls bullet"><span class="by">Hendrikto</span><span>|</span><a href="#41785518">root</a><span>|</span><a href="#41788886">parent</a><span>|</span><a href="#41791336">next</a><span>|</span><label class="collapse" for="c-41796569">[-]</label><label class="expand" for="c-41796569">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. More bullish means he uses and advocates for functional more than before. It by no means implies having ”moved on“ from inlining.</div><br/></div></div></div></div></div></div><div id="41791336" class="c"><input type="checkbox" id="c-41791336" checked=""/><div class="controls bullet"><span class="by">zelphirkalt</span><span>|</span><a href="#41785518">parent</a><span>|</span><a href="#41786084">prev</a><span>|</span><a href="#41785780">next</a><span>|</span><label class="collapse" for="c-41791336">[-]</label><label class="expand" for="c-41791336">[1 more]</label></div><br/><div class="children"><div class="content">That most wont get it is due to the fact that most are kind of &quot;industrial programmers&quot;, who only learn and use mainstream OOP languages amd as such never actually use a mainly FP language a lot. Maybe on HN the ratio is better than on the whole market though.</div><br/></div></div><div id="41785780" class="c"><input type="checkbox" id="c-41785780" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#41785518">parent</a><span>|</span><a href="#41791336">prev</a><span>|</span><a href="#41785858">next</a><span>|</span><label class="collapse" for="c-41785780">[-]</label><label class="expand" for="c-41785780">[2 more]</label></div><br/><div class="children"><div class="content">Some grasp it but see its trade-off contract, which is demanding.</div><br/><div id="41788823" class="c"><input type="checkbox" id="c-41788823" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41785518">root</a><span>|</span><a href="#41785780">parent</a><span>|</span><a href="#41785858">next</a><span>|</span><label class="collapse" for="c-41788823">[-]</label><label class="expand" for="c-41788823">[1 more]</label></div><br/><div class="children"><div class="content">With practice it just becomes another paradigm of programming. The trade off is really a skill issue from this perspective.<p>The larger issue is performance which is a legitimate reason for not using fp in many cases. But additionally in many cases there is no performance trade off.</div><br/></div></div></div></div><div id="41785858" class="c"><input type="checkbox" id="c-41785858" checked=""/><div class="controls bullet"><span class="by">nuancebydefault</span><span>|</span><a href="#41785518">parent</a><span>|</span><a href="#41785780">prev</a><span>|</span><a href="#41785545">next</a><span>|</span><label class="collapse" for="c-41785858">[-]</label><label class="expand" for="c-41785858">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never seen pure FP...</div><br/><div id="41787294" class="c"><input type="checkbox" id="c-41787294" checked=""/><div class="controls bullet"><span class="by">sdeframond</span><span>|</span><a href="#41785518">root</a><span>|</span><a href="#41785858">parent</a><span>|</span><a href="#41789295">next</a><span>|</span><label class="collapse" for="c-41787294">[-]</label><label class="expand" for="c-41787294">[1 more]</label></div><br/><div class="children"><div class="content">I would recommend you take a look at Haskell or Elm.<p>John Karmack did and talked about it <a href="https:&#x2F;&#x2F;m.youtube.com&#x2F;watch?v=1PhArSujR_A" rel="nofollow">https:&#x2F;&#x2F;m.youtube.com&#x2F;watch?v=1PhArSujR_A</a></div><br/></div></div><div id="41789295" class="c"><input type="checkbox" id="c-41789295" checked=""/><div class="controls bullet"><span class="by">eyelidlessness</span><span>|</span><a href="#41785518">root</a><span>|</span><a href="#41785858">parent</a><span>|</span><a href="#41787294">prev</a><span>|</span><a href="#41787273">next</a><span>|</span><label class="collapse" for="c-41789295">[-]</label><label class="expand" for="c-41789295">[1 more]</label></div><br/><div class="children"><div class="content">Surely if you’ve seen any non-trivial amount of code, you have seen pure FP applied piecemeal even if not broadly. A single referentially transparent function <i>is pure FP</i>, even if it’s ultimately called by the most grotesque stateful madness.</div><br/></div></div><div id="41787273" class="c"><input type="checkbox" id="c-41787273" checked=""/><div class="controls bullet"><span class="by">nuancebydefault</span><span>|</span><a href="#41785518">root</a><span>|</span><a href="#41785858">parent</a><span>|</span><a href="#41789295">prev</a><span>|</span><a href="#41793790">next</a><span>|</span><label class="collapse" for="c-41787273">[-]</label><label class="expand" for="c-41787273">[1 more]</label></div><br/><div class="children"><div class="content">I might add Carmack&#x27;s take on functional programming
<a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20120501221535&#x2F;http:&#x2F;&#x2F;gamasutra.com&#x2F;view&#x2F;news&#x2F;169296&#x2F;Indepth_Functional_programming_in_C.php" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20120501221535&#x2F;http:&#x2F;&#x2F;gamasutra....</a></div><br/></div></div><div id="41793790" class="c"><input type="checkbox" id="c-41793790" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41785518">root</a><span>|</span><a href="#41785858">parent</a><span>|</span><a href="#41787273">prev</a><span>|</span><a href="#41785545">next</a><span>|</span><label class="collapse" for="c-41793790">[-]</label><label class="expand" for="c-41793790">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;pandoc.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pandoc.org&#x2F;</a></div><br/></div></div></div></div></div></div><div id="41787870" class="c"><input type="checkbox" id="c-41787870" checked=""/><div class="controls bullet"><span class="by">BenoitEssiambre</span><span>|</span><a href="#41785518">prev</a><span>|</span><a href="#41790728">next</a><span>|</span><label class="collapse" for="c-41787870">[-]</label><label class="expand" for="c-41787870">[12 more]</label></div><br/><div class="children"><div class="content">Here are some information theoretic arguments why inlining code is often beneficial:<p><a href="https:&#x2F;&#x2F;benoitessiambre.com&#x2F;entropy.html" rel="nofollow">https:&#x2F;&#x2F;benoitessiambre.com&#x2F;entropy.html</a><p>In short, it reduces scope of logic.<p>The more logic you have broken out to wider scopes, the more things will try to reuse it before it is designed and hardened for broader use cases. When this logic later needs to be updated or refactored, more things will be tied to it and the effects will be more unpredictable and chaotic.<p>Prematurely breaking out code is not unlike using a lot of global variables instead of variables with tighter scopes. It&#x27;s more difficult to track the effects of change.<p>There&#x27;s more to it. Read the link above for the spicy details.</div><br/><div id="41788847" class="c"><input type="checkbox" id="c-41788847" checked=""/><div class="controls bullet"><span class="by">norir</span><span>|</span><a href="#41787870">parent</a><span>|</span><a href="#41791269">next</a><span>|</span><label class="collapse" for="c-41788847">[-]</label><label class="expand" for="c-41788847">[9 more]</label></div><br/><div class="children"><div class="content">This is why I think it&#x27;s a mistake that many popular languages, including standard c&#x2F;c++, do not support nested function definitions. This for me is the happy medium where code can be broken into clear chunks, but cannot be called outside of the intended scope. A good compiler can also detect if the nested function is only called once and inline it.</div><br/><div id="41789208" class="c"><input type="checkbox" id="c-41789208" checked=""/><div class="controls bullet"><span class="by">badmintonbaseba</span><span>|</span><a href="#41787870">root</a><span>|</span><a href="#41788847">parent</a><span>|</span><a href="#41791438">next</a><span>|</span><label class="collapse" for="c-41789208">[-]</label><label class="expand" for="c-41789208">[6 more]</label></div><br/><div class="children"><div class="content">C++ has lambdas and local classes. Local classes have some annoying arbitrary limitations, but they are otherwise useful.</div><br/><div id="41789519" class="c"><input type="checkbox" id="c-41789519" checked=""/><div class="controls bullet"><span class="by">knodi123</span><span>|</span><a href="#41787870">root</a><span>|</span><a href="#41789208">parent</a><span>|</span><a href="#41791438">next</a><span>|</span><label class="collapse" for="c-41789519">[-]</label><label class="expand" for="c-41789519">[5 more]</label></div><br/><div class="children"><div class="content">After spending a lot of time writing idiomatic React components in es6, I&#x27;ve found my love of locally declared lambdas to really grow.  If I give the lambdas really good names, I find that the main body of my component is very, very readable, even more so than if I&#x27;d used a more traditional style liberally sprinkled with comments.</div><br/><div id="41791704" class="c"><input type="checkbox" id="c-41791704" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#41787870">root</a><span>|</span><a href="#41789519">parent</a><span>|</span><a href="#41791297">next</a><span>|</span><label class="collapse" for="c-41791704">[-]</label><label class="expand" for="c-41791704">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If I give the lambdas really good names<p>That&#x27;s a really funny way to say it.</div><br/></div></div><div id="41791297" class="c"><input type="checkbox" id="c-41791297" checked=""/><div class="controls bullet"><span class="by">zelphirkalt</span><span>|</span><a href="#41787870">root</a><span>|</span><a href="#41789519">parent</a><span>|</span><a href="#41791704">prev</a><span>|</span><a href="#41791438">next</a><span>|</span><label class="collapse" for="c-41791297">[-]</label><label class="expand" for="c-41791297">[3 more]</label></div><br/><div class="children"><div class="content">Giving your lambdas names defeats part of their purpose though.</div><br/><div id="41793824" class="c"><input type="checkbox" id="c-41793824" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41787870">root</a><span>|</span><a href="#41791297">parent</a><span>|</span><a href="#41795579">next</a><span>|</span><label class="collapse" for="c-41793824">[-]</label><label class="expand" for="c-41793824">[1 more]</label></div><br/><div class="children"><div class="content">They have two distinct purposes: anonymous functions, and closures. Those often go together, but there are many scenarios where you only care about the latter, and don&#x27;t actually need the former. Named lambdas (i.e. lambdas assigned to local consts) covers this case if the language doesn&#x27;t have dedicated syntax for it.</div><br/></div></div><div id="41795579" class="c"><input type="checkbox" id="c-41795579" checked=""/><div class="controls bullet"><span class="by">knodi123</span><span>|</span><a href="#41787870">root</a><span>|</span><a href="#41791297">parent</a><span>|</span><a href="#41793824">prev</a><span>|</span><a href="#41791438">next</a><span>|</span><label class="collapse" for="c-41795579">[-]</label><label class="expand" for="c-41795579">[1 more]</label></div><br/><div class="children"><div class="content">maybe one purpose.  but it fulfills another purpose-  self-documenting code, and a really simple non-nested main body to your function.</div><br/></div></div></div></div></div></div></div></div><div id="41791438" class="c"><input type="checkbox" id="c-41791438" checked=""/><div class="controls bullet"><span class="by">humanfromearth9</span><span>|</span><a href="#41787870">root</a><span>|</span><a href="#41788847">parent</a><span>|</span><a href="#41789208">prev</a><span>|</span><a href="#41791766">next</a><span>|</span><label class="collapse" for="c-41791438">[-]</label><label class="expand" for="c-41791438">[1 more]</label></div><br/><div class="children"><div class="content">In Java, a local function reference (defined inside a method and never used outside of this method ) is possible. Notre that this function is not really tied to an object, which is why I don&#x27;t call it a method, and I don&#x27;t use the expression &quot;method reference&quot;, it is just tired to the function that contains it, which may be a method - or not.</div><br/></div></div><div id="41791766" class="c"><input type="checkbox" id="c-41791766" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#41787870">root</a><span>|</span><a href="#41788847">parent</a><span>|</span><a href="#41791438">prev</a><span>|</span><a href="#41791269">next</a><span>|</span><label class="collapse" for="c-41791766">[-]</label><label class="expand" for="c-41791766">[1 more]</label></div><br/><div class="children"><div class="content">Code can always be called outside of that scope just by returning function pointers or closures. The point is not to restrict calling that code, but to restrict the ability to refer to that piece of code by name.<p>As mentioned by others, C++ has lambdas. Even if you don&#x27;t use lambdas, people used to achieve the same effect by using plenty of private functions inside classes, even though the class might have zero variables and simply holds functions. In even older C code, people are used to making one separate .c file for each public function and then define plenty of static functions within each file.</div><br/></div></div></div></div><div id="41791269" class="c"><input type="checkbox" id="c-41791269" checked=""/><div class="controls bullet"><span class="by">zelphirkalt</span><span>|</span><a href="#41787870">parent</a><span>|</span><a href="#41788847">prev</a><span>|</span><a href="#41790728">next</a><span>|</span><label class="collapse" for="c-41791269">[-]</label><label class="expand" for="c-41791269">[2 more]</label></div><br/><div class="children"><div class="content">Of course all this needs to be weighed against maintainability and readability of the code. If the code base is not mainly about something very performance critical and this kind of thing shows to be a bottleneck, then changing things away from more readable towards performance optimized implementation would require a very good justification. I doubt, that this kind of optimization is justified in most cases. For that reason I find the wording &quot;prematurely breaking out code&quot; to be misleading. In most cases one should probably prioritize readability and maintainability and if breaking code out helps those, then it cannot be premature. It could only be premature from a performance limited perspective, which might have not much to do with the use case&#x2F;purpose of the code.<p>It is nice, if a performance optimization manages to keep the same degree of readability and maintainability. Those concerns covered, sure we should go ahead and make the performance optimization.</div><br/><div id="41792333" class="c"><input type="checkbox" id="c-41792333" checked=""/><div class="controls bullet"><span class="by">BenoitEssiambre</span><span>|</span><a href="#41787870">root</a><span>|</span><a href="#41791269">parent</a><span>|</span><a href="#41790728">next</a><span>|</span><label class="collapse" for="c-41792333">[-]</label><label class="expand" for="c-41792333">[1 more]</label></div><br/><div class="children"><div class="content">What I&#x27;m advocating here is only coincidentally a performance optimization. Readability and maintainability (and improved abstraction) are the primary concern and benefit of (sometimes) keeping things inline or more specifically of reducing entropy.</div><br/></div></div></div></div></div></div><div id="41790728" class="c"><input type="checkbox" id="c-41790728" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#41787870">prev</a><span>|</span><a href="#41785121">next</a><span>|</span><label class="collapse" for="c-41790728">[-]</label><label class="expand" for="c-41790728">[4 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>John Carmack on Inlined Code</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39008678">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39008678</a> - Jan 2024 (2 comments)<p><i>John Carmack on Inlined Code (2014)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33679163">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33679163</a> - Nov 2022 (1 comment)<p><i>John Carmack on Inlined Code (2014)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25263488">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25263488</a> - Dec 2020 (169 comments)<p><i>John Carmack on Inlined Code (2014)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=18959636">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=18959636</a> - Jan 2019 (105 comments)<p><i>John Carmack on Inlined Code (2014)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14333115">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14333115</a> - May 2017 (2 comments)<p><i>John Carmack on Inlined Code (2014)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=12120752">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=12120752</a> - July 2016 (199 comments)<p><i>John Carmack on Inlined Code</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8374345">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8374345</a> - Sept 2014 (260 comments)</div><br/><div id="41790772" class="c"><input type="checkbox" id="c-41790772" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41790728">parent</a><span>|</span><a href="#41785121">next</a><span>|</span><label class="collapse" for="c-41790772">[-]</label><label class="expand" for="c-41790772">[3 more]</label></div><br/><div class="children"><div class="content">There is a longer version of this thought-provoking post, also including Carmack&#x27;s thoughts in 02012, at <a href="https:&#x2F;&#x2F;cbarrete.com&#x2F;carmack.html" rel="nofollow">https:&#x2F;&#x2F;cbarrete.com&#x2F;carmack.html</a>.  But maybe that version has not also had threads about it.</div><br/><div id="41791410" class="c"><input type="checkbox" id="c-41791410" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#41790728">root</a><span>|</span><a href="#41790772">parent</a><span>|</span><a href="#41785121">next</a><span>|</span><label class="collapse" for="c-41791410">[-]</label><label class="expand" for="c-41791410">[2 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t seem to have, since <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;from?site=cbarrete.com">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;from?site=cbarrete.com</a> is empty.<p>Should we change the top link to that URL?</div><br/><div id="41791572" class="c"><input type="checkbox" id="c-41791572" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41790728">root</a><span>|</span><a href="#41791410">parent</a><span>|</span><a href="#41785121">next</a><span>|</span><label class="collapse" for="c-41791572">[-]</label><label class="expand" for="c-41791572">[1 more]</label></div><br/><div class="children"><div class="content">I do think it&#x27;s a better page, but I wouldn&#x27;t change the link if I were in charge.  On the other hand, I think everyone is grateful that you&#x27;re in charge of HN and not me.  <i>Especially</i> not me.  So I think you should use your judgment.</div><br/></div></div></div></div></div></div></div></div><div id="41785121" class="c"><input type="checkbox" id="c-41785121" checked=""/><div class="controls bullet"><span class="by">gorgoiler</span><span>|</span><a href="#41790728">prev</a><span>|</span><a href="#41790835">next</a><span>|</span><label class="collapse" for="c-41785121">[-]</label><label class="expand" for="c-41785121">[50 more]</label></div><br/><div class="children"><div class="content">&gt; Inlining functions also has the benefit of not making it possible to call the function from other places.<p>I’ve really gone to town with this in Python.<p><pre><code>  def parse_news_email(…):
    def parse_link(…):
      …

    def parse_subjet(…):
      …

    …
</code></pre>
If you are careful, you can rely on the outer function’s variables being available inside the inner functions as well.  Something like a logger or a db connection can be passed in once and then used without having to pass it as an argument all the time:<p><pre><code>  # sad
  def f1(x, db, logger): …
  def f2(x, db, logger): …
  def f3(x, db, logger): …
  def g(xs, db, logger):
    for x0 in xs:
      x1 = f1(x0, db, logger)
      x2 = f2(x1, db, logger)
      x3 = f3(x2, db, logger)
      yikes x3


  # happy
  def g(xs, db, logger):
    def f1(x): …
    def f2(x): …
    def f3(x): …
    for x in xs:
      yield f3(f2(f1(x)))
</code></pre>
Carmack commented his inline functions as if they were actual functions.  Making actual functions enforces this :)<p>Classes and “constants” can also quite happily live inside a function but those are a bit more jarring to see, and classes usually need to be visible so they can be referred to by the type annotations.</div><br/><div id="41785827" class="c"><input type="checkbox" id="c-41785827" checked=""/><div class="controls bullet"><span class="by">grumbel</span><span>|</span><a href="#41785121">parent</a><span>|</span><a href="#41785423">next</a><span>|</span><label class="collapse" for="c-41785827">[-]</label><label class="expand" for="c-41785827">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not an improvement, as it screws up the code flow. The point of inline blocks is that you can read the code the same way as it is executed. No surprised that code might be called twice or that a function call could be missed or reordered. Adding real functions causes exactly the indirection that one wanted to avoid in the first place. If the block has no name you know that it will only be executed right where it is written.</div><br/><div id="41785872" class="c"><input type="checkbox" id="c-41785872" checked=""/><div class="controls bullet"><span class="by">gorgoiler</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41785827">parent</a><span>|</span><a href="#41785423">next</a><span>|</span><label class="collapse" for="c-41785872">[-]</label><label class="expand" for="c-41785872">[1 more]</label></div><br/><div class="children"><div class="content">Yeah that’s a valid point.  I tend to have in mind that as soon as I pull any of the inner functions out to the publicly visible module level I can say goodbye to ever trying to stop people reusing the code when I don’t really want them to.<p>For example, if your function has an implicit, undocumented contract such as assuming the DB is only a few milliseconds away, but they then reuse the code for logging to DBs over the internet, then they find it’s slow and speed it up with caching.  Now your DB writing code has to suffer their cache logic bugs when it didn’t have to.</div><br/></div></div></div></div><div id="41785423" class="c"><input type="checkbox" id="c-41785423" checked=""/><div class="controls bullet"><span class="by">scbrg</span><span>|</span><a href="#41785121">parent</a><span>|</span><a href="#41785827">prev</a><span>|</span><a href="#41785789">next</a><span>|</span><label class="collapse" for="c-41785423">[-]</label><label class="expand" for="c-41785423">[4 more]</label></div><br/><div class="children"><div class="content">Not sure I believe the benefit of this approach outweighs the added difficulty wrt testing, but I certainly agree that Python needs a <i>yikes</i> keyword :-)</div><br/><div id="41785906" class="c"><input type="checkbox" id="c-41785906" checked=""/><div class="controls bullet"><span class="by">nuancebydefault</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41785423">parent</a><span>|</span><a href="#41785789">next</a><span>|</span><label class="collapse" for="c-41785906">[-]</label><label class="expand" for="c-41785906">[3 more]</label></div><br/><div class="children"><div class="content">What is the benefit of such a yikes? Or do you consider it a yikes language as a whole?<p>Personally I like that functions can be inside functions, as a trade off between inlining and functional seperation in C++.<p>The scope reduction makes it easier to track bugs while it has the benefits of separation of concern.</div><br/><div id="41788064" class="c"><input type="checkbox" id="c-41788064" checked=""/><div class="controls bullet"><span class="by">scbrg</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41785906">parent</a><span>|</span><a href="#41785789">next</a><span>|</span><label class="collapse" for="c-41788064">[-]</label><label class="expand" for="c-41788064">[2 more]</label></div><br/><div class="children"><div class="content">&gt; What is the benefit of such a yikes? Or do you consider it a yikes language as a whole?<p>None, it was just a simple joke based on the typo in the post I replied to. I like Python, and have in fact been happily using it as my main language for over 20 years.</div><br/><div id="41791238" class="c"><input type="checkbox" id="c-41791238" checked=""/><div class="controls bullet"><span class="by">gorgoiler</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41788064">parent</a><span>|</span><a href="#41785789">next</a><span>|</span><label class="collapse" for="c-41791238">[-]</label><label class="expand" for="c-41791238">[1 more]</label></div><br/><div class="children"><div class="content">Ahhh, now I (top level author) get it :)</div><br/></div></div></div></div></div></div></div></div><div id="41785789" class="c"><input type="checkbox" id="c-41785789" checked=""/><div class="controls bullet"><span class="by">wraptile</span><span>|</span><a href="#41785121">parent</a><span>|</span><a href="#41785423">prev</a><span>|</span><a href="#41785355">next</a><span>|</span><label class="collapse" for="c-41785789">[-]</label><label class="expand" for="c-41785789">[1 more]</label></div><br/><div class="children"><div class="content">The latter pattern is very popular in Python web scraping and data parsing niches as the code is quite verbose and specific and I&#x27;m very happy with this approach. Easy to read and debug and the maintenance is naturally organized.</div><br/></div></div><div id="41785355" class="c"><input type="checkbox" id="c-41785355" checked=""/><div class="controls bullet"><span class="by">toenail</span><span>|</span><a href="#41785121">parent</a><span>|</span><a href="#41785789">prev</a><span>|</span><a href="#41785185">next</a><span>|</span><label class="collapse" for="c-41785355">[-]</label><label class="expand" for="c-41785355">[27 more]</label></div><br/><div class="children"><div class="content">&gt; Inlining functions also has the benefit of not making it possible to call the function from other places.<p>Congrats, you&#x27;ve got an untestable unit.</div><br/><div id="41785678" class="c"><input type="checkbox" id="c-41785678" checked=""/><div class="controls bullet"><span class="by">ahoka</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41785355">parent</a><span>|</span><a href="#41785514">next</a><span>|</span><label class="collapse" for="c-41785678">[-]</label><label class="expand" for="c-41785678">[1 more]</label></div><br/><div class="children"><div class="content">Congratulations, you are writing test for things that would not need test if weren&#x27;t put behind a under-defined interface. Meanwhile sprint goals are not met and overall product quality is embarrassing, but you have 100% MC&#x2F;DC coverage of your addNumbersOrThrowIfAbove(a, b, c).</div><br/></div></div><div id="41785514" class="c"><input type="checkbox" id="c-41785514" checked=""/><div class="controls bullet"><span class="by">jeltz</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41785355">parent</a><span>|</span><a href="#41785678">prev</a><span>|</span><a href="#41789587">next</a><span>|</span><label class="collapse" for="c-41785514">[-]</label><label class="expand" for="c-41785514">[12 more]</label></div><br/><div class="children"><div class="content">Which is usually a positive. Testing tiny subunits usually just makes refactoring and adding new features hard while not improving test quality.</div><br/><div id="41786907" class="c"><input type="checkbox" id="c-41786907" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41785514">parent</a><span>|</span><a href="#41785590">next</a><span>|</span><label class="collapse" for="c-41786907">[-]</label><label class="expand" for="c-41786907">[2 more]</label></div><br/><div class="children"><div class="content">Testing is a tool that sometimes makes your life easier. IME, many (not all) tiny subunits do actually have better tests when examined at that level. You just want to avoid tests which will need to be updated for unrelated changes, and try to avoid writing code which propagates that sort of minutia throughout the codebase:<p>&gt; while not improving test quality<p>The big wins from fine-grained testing are<p>1. Knowing _where_ your program is broken<p>2. Testing &quot;rare&quot; edge cases<p>Elaborating on (2), your code probably works well enough on some sort of input or you wouldn&#x27;t ship it. Tests allow you to cheaply test all four Turkish &quot;i&quot;s and some unicode combining marks, test empty inputs, test what happens when a clock runs backward ever or forward too slowly&#x2F;quickly, .... You&#x27;ll hit some of those cases eventually in prod, where pressures are high and debugging&#x2F;triaging is slow, and integration tests won&#x27;t usually save you. I&#x27;m also a huge fan of testing timing-based logic with pure functions operating on the state being passed in (so it&#x27;s tested, better than an integration test would accomplish, and you never have to wait for anything godawful like an actual futex or sleep or whatever).<p>&gt; makes refactoring and adding new features hard<p>What you&#x27;re describing is a world where accomplishing a single task (refactoring, adding a new feature) has ripple effects through the rest of the system, or else the tests are examining proxy metrics rather than invariants the tiny subunits should actually adhere to. Testing being hard is a symptom of that design, and squashing the symptom (avoiding tests on tiny subunits) won&#x27;t fix any of the other problems it causes.<p>If you&#x27;re stuck in some codebase with that property and without the ability to change it, by all means, don&#x27;t test every little setup_redis_for_db_payment_handling_special_case_hulu method. Do, however, test things with sensible, time-invariant names -- data structures, algorithms, anything that if you squint a bit looks kind of like parsing or serialization, .... If you have a finicky loop with a bunch of backoff-related state, pull the backoff into its own code unit and test how it behaves with clocks that run backward or other edge cases. The loop itself (or any other confluence of many disparate coding concepts) probably doesn&#x27;t need to be unit tested for the reasons you mention, but you usually can and should pull out some of the components into testable units.</div><br/><div id="41787700" class="c"><input type="checkbox" id="c-41787700" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41786907">parent</a><span>|</span><a href="#41785590">next</a><span>|</span><label class="collapse" for="c-41787700">[-]</label><label class="expand" for="c-41787700">[1 more]</label></div><br/><div class="children"><div class="content">The problem is there is rarely a clear interface for your subunit.  As such you will want to refactor that interface in ways that break tests in the future.  If you are writing another string you can probably come up with a good interface and then write good tests that won&#x27;t make refactoring hard - but string should be a solved problem for most of us (unless you are writing a new programming language) and instead we are working on problems that are not as clear and only our competitors work on so we can&#x27;t even learn from others.</div><br/></div></div></div></div><div id="41785590" class="c"><input type="checkbox" id="c-41785590" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41785514">parent</a><span>|</span><a href="#41786907">prev</a><span>|</span><a href="#41785649">next</a><span>|</span><label class="collapse" for="c-41785590">[-]</label><label class="expand" for="c-41785590">[8 more]</label></div><br/><div class="children"><div class="content">Not according to jon carmack. He stated he switched to pure functional programming in the intro which is basically stating all his logic is in the form of unit testable pure functions.</div><br/><div id="41787252" class="c"><input type="checkbox" id="c-41787252" checked=""/><div class="controls bullet"><span class="by">nuancebydefault</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41785590">parent</a><span>|</span><a href="#41786049">next</a><span>|</span><label class="collapse" for="c-41787252">[-]</label><label class="expand" for="c-41787252">[2 more]</label></div><br/><div class="children"><div class="content">I found this [] article of Carmack. While reading, I understood there is a  large set of gray shades to pureness of &quot;pure functional&quot; code. He calls being functional a useful abstraction, a function() is never purely functional.<p>[] <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20120501221535&#x2F;http:&#x2F;&#x2F;gamasutra.com&#x2F;view&#x2F;news&#x2F;169296&#x2F;Indepth_Functional_programming_in_C.php" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20120501221535&#x2F;http:&#x2F;&#x2F;gamasutra....</a></div><br/><div id="41788727" class="c"><input type="checkbox" id="c-41788727" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41787252">parent</a><span>|</span><a href="#41786049">next</a><span>|</span><label class="collapse" for="c-41788727">[-]</label><label class="expand" for="c-41788727">[1 more]</label></div><br/><div class="children"><div class="content">When people say pure functional programming they never mean the entire program is like this.<p>Because if it were your program would have no changing state and no output.<p>What they mean is that your code is purely functional as much as possible. And there is high segregation between functional code and non functional code in the sense that state and IO is segregated as much as possible away into very small very general functionality.</div><br/></div></div></div></div><div id="41786049" class="c"><input type="checkbox" id="c-41786049" checked=""/><div class="controls bullet"><span class="by">foldr</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41785590">parent</a><span>|</span><a href="#41787252">prev</a><span>|</span><a href="#41787862">next</a><span>|</span><label class="collapse" for="c-41786049">[-]</label><label class="expand" for="c-41786049">[4 more]</label></div><br/><div class="children"><div class="content">Nothing about pure functional programming requires unit testing all of your functions. You can decide to unit test larger or smaller units of code, just as you can in any other paradigm.</div><br/><div id="41788760" class="c"><input type="checkbox" id="c-41788760" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41786049">parent</a><span>|</span><a href="#41787862">next</a><span>|</span><label class="collapse" for="c-41788760">[-]</label><label class="expand" for="c-41788760">[3 more]</label></div><br/><div class="children"><div class="content">In pure functional programming a pure function is unit testable by definition of what a pure function is. I never said it requires functions to be tested. Just that it requires functions to be testable.<p>In other paradigms do not do this. As soon as a module touches IO or state it becomes entangled with that and NOT unit testable.<p>Is it still testable? Possibly. But not as a unit.</div><br/><div id="41793838" class="c"><input type="checkbox" id="c-41793838" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41788760">parent</a><span>|</span><a href="#41787862">next</a><span>|</span><label class="collapse" for="c-41793838">[-]</label><label class="expand" for="c-41793838">[2 more]</label></div><br/><div class="children"><div class="content">How do you unit test a local function that is a closure in pure functional code?</div><br/><div id="41793930" class="c"><input type="checkbox" id="c-41793930" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41793838">parent</a><span>|</span><a href="#41787862">next</a><span>|</span><label class="collapse" for="c-41793930">[-]</label><label class="expand" for="c-41793930">[1 more]</label></div><br/><div class="children"><div class="content">Of course you can&#x27;t unit test things with restricted scope.<p>f(x) = x + 2 + 4<p>How do you unit test x + 2 or (+ 4) even if the operation is pure? You can&#x27;t. Because it&#x27;s not callable. It&#x27;s the same thing with the closure.<p>The only things that are testable are things on unrestricted scope. AKA global scope. Think about what happens if you have a &quot;closure&quot; on global scope.<p>If you really want to test it then your &quot;unit tests&quot; which typically live on global scope, need to be moved to local scope. That&#x27;s just the rules of scope.<p>There is one special case here. If the parent function returns the local function as a value. But even in this case the parent and local function have to be treated as a unit. The unit test will involve first calling the parent, then calling the local. The parent and child function form a &quot;unit&quot; thanks to shared state and the parent is essentially &quot;moving&quot; the local function into global scope.<p>Generally best practice is to use combinators if you want to maximize the granularity in which you can modularize your logic. I would even argue that closures stradle the line between pure and impure, so I actually avoid closures whenever possible.</div><br/></div></div></div></div></div></div></div></div><div id="41787862" class="c"><input type="checkbox" id="c-41787862" checked=""/><div class="controls bullet"><span class="by">tightbookkeeper</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41785590">parent</a><span>|</span><a href="#41786049">prev</a><span>|</span><a href="#41785649">next</a><span>|</span><label class="collapse" for="c-41787862">[-]</label><label class="expand" for="c-41787862">[1 more]</label></div><br/><div class="children"><div class="content">&gt; pure fp<p>No he didn’t.</div><br/></div></div></div></div><div id="41785649" class="c"><input type="checkbox" id="c-41785649" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41785514">parent</a><span>|</span><a href="#41785590">prev</a><span>|</span><a href="#41789587">next</a><span>|</span><label class="collapse" for="c-41785649">[-]</label><label class="expand" for="c-41785649">[1 more]</label></div><br/><div class="children"><div class="content">Like most things being talked about here, so much depends on the specifics.<p>I think developers should generally try and aim for, at every scale, the outputs of a system to be pure functions of the inputs (whether by reducing the scope of the system or expanding the set of things considered inputs). Beyond that there are so many decisions at the margin that are going to be based on personal inclination.</div><br/></div></div></div></div><div id="41789587" class="c"><input type="checkbox" id="c-41789587" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41785355">parent</a><span>|</span><a href="#41785514">prev</a><span>|</span><a href="#41785463">next</a><span>|</span><label class="collapse" for="c-41789587">[-]</label><label class="expand" for="c-41789587">[1 more]</label></div><br/><div class="children"><div class="content">Ideally, you&#x27;ve just moved the unit boundary to where it logically should be instead of many small implementation details that should not be exposed.</div><br/></div></div><div id="41785463" class="c"><input type="checkbox" id="c-41785463" checked=""/><div class="controls bullet"><span class="by">xboxnolifes</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41785355">parent</a><span>|</span><a href="#41789587">prev</a><span>|</span><a href="#41785584">next</a><span>|</span><label class="collapse" for="c-41785463">[-]</label><label class="expand" for="c-41785463">[10 more]</label></div><br/><div class="children"><div class="content">The unit here is the email, not the email&#x27;s link or subjects. Those are implementation details.</div><br/><div id="41785923" class="c"><input type="checkbox" id="c-41785923" checked=""/><div class="controls bullet"><span class="by">mgsouth</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41785463">parent</a><span>|</span><a href="#41785584">next</a><span>|</span><label class="collapse" for="c-41785923">[-]</label><label class="expand" for="c-41785923">[9 more]</label></div><br/><div class="children"><div class="content">What do you use unit tests for, other than verifying implementation details?<p>Perhaps we have a difference in definition. To me, a unit test for a function such as &quot;parse_news_email&quot; would explore variations in parameters and states. Because of combinatorial explosion, that often means at least some white-box testing. I&#x27;m not going to generate random subjects and senders, and received-froms, I&#x27;m going to target based on internal details. Are we doing smart things with the message ID hostname? Then what happens if two messages come in with the same message ID but from different relays? The objective is that the unit test wrings out the implementation details, and the <i>caller&#x27;s</i> unit test doesn&#x27;t need to exhaustively test them.<p>This white-box texting may require directly poking at or mocking internal functions or at least abusing how they&#x27;re called. For example, parsing the news item might entail pulling up <i>and modifying</i> conversation thread cache entries or state. For some of the tests you may need hand-crafted cache state, it&#x27;s not feasible to create unique states for each parameter combination you&#x27;re testing, and testing a combination will pollute the state for the following combinations. Or maybe the function depends upon an external resource you can&#x27;t beat to death with a million identical requests. So the least-bad, simplest solution may be to freeze or back out part of the normal state update in the unit test. Which would usually involve directly invoking the internal routines.<p>Can this lead to fragile, false-positve to the point of useless tests? You betcha. That&#x27;s where entertaining two contrary viewpoints is needed :) Use experience and good judgement about pros and cons in the particular situation.</div><br/><div id="41789481" class="c"><input type="checkbox" id="c-41789481" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41785923">parent</a><span>|</span><a href="#41794079">next</a><span>|</span><label class="collapse" for="c-41789481">[-]</label><label class="expand" for="c-41789481">[4 more]</label></div><br/><div class="children"><div class="content">Unit tests are for documenting the API contract for the user. You are going to target based on what you are willing to forevermore commit to for those who will use what you have created. Indeed, what happens when two messages come in with the same message ID is something the user needs to be aware of and how it functions needs to remain stable no matter what you do behind the scenes in the future, so you would absolutely want to document that behaviour. <i>How</i> it is implemented is irrelevant, though. The only thing that matters is that, from the public API perspective, it is handled appropriately.<p>There is a time and place for other types of tests, of course. You are right that unit tests are not the be all and end all. A good testing framework will allow you to mark for future developers which tests are &quot;set in stone&quot; and which are deemed throwaway.</div><br/><div id="41792016" class="c"><input type="checkbox" id="c-41792016" checked=""/><div class="controls bullet"><span class="by">mgsouth</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41789481">parent</a><span>|</span><a href="#41794079">next</a><span>|</span><label class="collapse" for="c-41792016">[-]</label><label class="expand" for="c-41792016">[3 more]</label></div><br/><div class="children"><div class="content">We&#x27;re in general agreement about the purpose of unit tests. I disagree on a couple of points.<p>Tests do <i>not</i> document the API. No test is complete, and for that reason alone can&#x27;t completely document anything. For example, a good API might specify that &quot;the <i>sender</i> must be non-null, and must be valid per RFC blah.&quot; There&#x27;s no way to test that inclusively, to check all possible inputs. You can&#x27;t use the test cases to deduce &quot;we must meet RFC blah.&quot; You might <i>suspect</i> it, but you&#x27;d be risking undefined behavior it you stray from input that doesn&#x27;t exactly match the test cases. And before anyone objects &quot;the API docs can be incomplete too,&quot; well, that true. But the point is that a written API has vastly more descriptive power than a set of test cases. (The same applies to &quot;self-documenting code&quot;. Bah humbug.) There&#x27;s also the objection &quot;but you can&#x27;t guarentee cases you don&#x27;t test!&quot; Also true. That&#x27;s reality. _You can never test all your intended behavior._ You pick your test cases to do the best you can, and change your cases as problems pop up.<p>The other thing I would shy away from is including throwaway tests in the framework. Throwaways are a thing, developers use them all the time, but don&#x27;t make them unwanted stepchildren--poorly (incompletely?) designed, slapped together, limited scope, confusing for another developer (including time-traveling self) to wade through and decide whether this is a real failure or just bogus test. They&#x27;re tech debt. <i>Less frequently used</i> tests are another matter. For example, release-engineering tests that only get run against release candidates. But these should be just as much real, set in stone, as any other deliverable.<p>Which I guess is a third viewpoint nuance difference. I treat tests as being part of the package just as much as any other deliverable. They morph and shift as APIs change, or dependencies mutate, or bugs are found. They aren&#x27;t something that can be put to the side and left to vegetate.</div><br/><div id="41792198" class="c"><input type="checkbox" id="c-41792198" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41792016">parent</a><span>|</span><a href="#41794079">next</a><span>|</span><label class="collapse" for="c-41792198">[-]</label><label class="expand" for="c-41792198">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; There&#x27;s no way to test that inclusively, to check all possible inputs.</i><p>Which means the RFC claim is false and should not be asserted in the first place. The API may incidentally accept valid RFC input, but there is no way to know that it does for sure for all inputs. You might <i>suspect</i> it conforms to the RFC, but to claim that it does with certainty is incorrect. Only what is documented in the tests is known to be true.<p>Everything else is undefined behaviour. Even if you do happen to conform to an RFC in one version, without testing to verify that continues to hold true, it probably won’t.<p>This is exactly why unit tests are the expected documentation by users. It prevents you, the author, from make spurious claims. If you try, the computer will catch you in your lies.<p><i>&gt; The other thing I would shy away from is including throwaway tests in the framework.</i><p>What does that mean? I suspect you are thinking of something completely different as this doesn&#x27;t quite make sense with respect to what I said. It probably makes sense in another context, and if I have inferred that context correctly, I&#x27;d agree... But, again, untreated to our discussion.</div><br/><div id="41793124" class="c"><input type="checkbox" id="c-41793124" checked=""/><div class="controls bullet"><span class="by">mgsouth</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41792198">parent</a><span>|</span><a href="#41794079">next</a><span>|</span><label class="collapse" for="c-41793124">[-]</label><label class="expand" for="c-41793124">[1 more]</label></div><br/><div class="children"><div class="content">OK, one more round. An API spec is a <i>contract</i>, not a <i>guarentee of correctness.</i> You, as the client, are free to pass me any data that fits the spec. If my parsing library does the wrong thing, then I&#x27;ve got a bug and need to fix it. My tests are also defective and need to be adjusted.<p>If you passed 3.974737373 to cos(x), and got back 200.0, would you be mollified if the developers told you &quot;that value clearly isn&#x27;t in the unit test cases, so you&#x27;re in undefined behavior&quot;? Of course not. The <i>spec</i> might be &quot;x is a single-float by value, 0.0 &lt;= x &lt; 2.0 * PI, result is the cosine of X as a single-float.&quot; That&#x27;s a contract, an intent--an API.<p>The same for a mail parser. If my library croaks with a valid (per RFC) address then I&#x27;ve got a problem. If I try to provide some long, custom, set of cases I will or won&#x27;t support, then my customer developers are going to be rightfully annoyed. What are <i>they</i> supposed to do when they get a valid but unsupported address? Note we&#x27;re not talking about carving out broad exceptions reasonable in context (&quot;RFC 5322 except we don&#x27;t support raw IP addresses foo@[1.2.3.4]&quot;, &quot;we treat all usernames as case-insensitive&quot;). And we&#x27;re not talking about &quot;Our spec (intent) is foo, but we&#x27;ve only tested blah blah blah.&quot;<p>Early in my career I would get pretty frustrated by users who were not concerned with arranging their data and procedures the right way, clueless about what they <i>really</i> were doing. OK, so I still get frustrated by stupid :) But it&#x27;s gradually seeped into my head that what matters is the user&#x27;s intentions. Specs are an imperfect simplificaton of those very complex things, APIs are imperfect simplifcations of the specs, and our beautiful code and distributed clusters and redundant networks are extremely limited and imperfect implementations of the APIs. Some especially harmful potential flaws get extra attention during arch, implementation, and testing. When things get too far out we fix them.</div><br/></div></div></div></div></div></div></div></div><div id="41794079" class="c"><input type="checkbox" id="c-41794079" checked=""/><div class="controls bullet"><span class="by">xboxnolifes</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41785923">parent</a><span>|</span><a href="#41789481">prev</a><span>|</span><a href="#41790241">next</a><span>|</span><label class="collapse" for="c-41794079">[-]</label><label class="expand" for="c-41794079">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What do you use unit tests for, other than verifying implementation details?<p>You don&#x27;t need to verify the return of `parse_subject()` directly, since it will be part of the return of `parse_email()`. Verify it there.</div><br/></div></div><div id="41790241" class="c"><input type="checkbox" id="c-41790241" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41785923">parent</a><span>|</span><a href="#41794079">prev</a><span>|</span><a href="#41785584">next</a><span>|</span><label class="collapse" for="c-41790241">[-]</label><label class="expand" for="c-41790241">[3 more]</label></div><br/><div class="children"><div class="content">&gt; What do you use unit tests for, other than verifying implementation details?<p>1. Determining when the observable behavior of the program changes.<p>2. Codifying <i>only</i> the specific behaviors that are known to be relied on by callers.<p>3. Preventing regressions after bugs are fixed.<p>Failing tests are alarm bells, when do you want them to grab your attention?</div><br/><div id="41791723" class="c"><input type="checkbox" id="c-41791723" checked=""/><div class="controls bullet"><span class="by">mgsouth</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41790241">parent</a><span>|</span><a href="#41785584">next</a><span>|</span><label class="collapse" for="c-41791723">[-]</label><label class="expand" for="c-41791723">[2 more]</label></div><br/><div class="children"><div class="content">Excellent points, violently agree, my question was poorly worded. The <i>purpose</i> of units tests is to verify the contracted API is actually being provided <i>by the implementation details</i>. A clearer question might have been &quot;what are unit tests for if not to exercise the implementation details, verifying they adhere to the API?&quot; Unit tests validate implementation details, integration tests validate APIs.<p>To me, a good unit test beats the stuffing out of the unit. It&#x27;s as much a part of the unit as the public functions, so should take full advantage of internal details (keeping test fragility in mind); of course that implies the unit test needs ongoing maintenance just as much as the public functions. If you&#x27;re passing a small set of inputs and checking the outputs, well that&#x27;s a smoke test, not a unit test.<p>To answer your last question, I want the alarm bells to ring whenever the implementation details don&#x27;t hold up. That&#x27;s whether the function code changed, a code or state dependency changed, or the testing process itself changed. If at all feasible all the unit tests run every time the the complete suite is run, in full meat-grinder mode. &quot;Complete suite&quot; is hand-wavy; e.g. it might be the suite for a major library, but not the end-to-end application.</div><br/><div id="41793853" class="c"><input type="checkbox" id="c-41793853" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41791723">parent</a><span>|</span><a href="#41785584">next</a><span>|</span><label class="collapse" for="c-41793853">[-]</label><label class="expand" for="c-41793853">[1 more]</label></div><br/><div class="children"><div class="content">All that doesn&#x27;t mean that you have to consider artificial boundaries that you yourself have introduced <i>for convenience</i> when deciding on the proper boundaries for what constitutes a &quot;unit&quot;. Not every instance of code reuse makes for a good unit to test.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41785584" class="c"><input type="checkbox" id="c-41785584" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41785355">parent</a><span>|</span><a href="#41785463">prev</a><span>|</span><a href="#41785851">next</a><span>|</span><label class="collapse" for="c-41785584">[-]</label><label class="expand" for="c-41785584">[1 more]</label></div><br/><div class="children"><div class="content">This is a major insight. Defining a local function isn&#x27;t a big deal you can always just copy and pasta it out to global scope.<p>Any time you merge state with function you can no longer move the function. This is the same problem as OOP. Closures can&#x27;t be modular the same way methods in objects can&#x27;t be modular.<p>The smallest unit of testable module is the combinator. John Carmack literally mentioned he does pure functional programming now which basically everyone in this entire thread is completely ignoring.</div><br/></div></div><div id="41785851" class="c"><input type="checkbox" id="c-41785851" checked=""/><div class="controls bullet"><span class="by">gorgoiler</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41785355">parent</a><span>|</span><a href="#41785584">prev</a><span>|</span><a href="#41785185">next</a><span>|</span><label class="collapse" for="c-41785851">[-]</label><label class="expand" for="c-41785851">[1 more]</label></div><br/><div class="children"><div class="content">Yup, and I should have called this out as a downside.   Thank you for raising it.<p>On visibility, one of the patterns I’ve always liked in Java is using package level visibility to limit functions to that code’s package <i>and</i> that packages tests, where they are in the same package (but possibly defined elsewhere.)<p>(This doesn’t help though with the reduction in argument verbosity, of course.)</div><br/></div></div></div></div><div id="41785185" class="c"><input type="checkbox" id="c-41785185" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41785121">parent</a><span>|</span><a href="#41785355">prev</a><span>|</span><a href="#41786471">next</a><span>|</span><label class="collapse" for="c-41785185">[-]</label><label class="expand" for="c-41785185">[1 more]</label></div><br/><div class="children"><div class="content">Funny enough, the equivalent of your Python example is how Haskell &#x27;fakes&#x27; all functions with more than one argument (at least by default).<p>Imperative blocks of code in Haskell (do-notation) also work like this.</div><br/></div></div><div id="41786471" class="c"><input type="checkbox" id="c-41786471" checked=""/><div class="controls bullet"><span class="by">zelphirkalt</span><span>|</span><a href="#41785121">parent</a><span>|</span><a href="#41785185">prev</a><span>|</span><a href="#41786380">next</a><span>|</span><label class="collapse" for="c-41786471">[-]</label><label class="expand" for="c-41786471">[2 more]</label></div><br/><div class="children"><div class="content">Where is the part, where this is &quot;careful&quot;? This is just how scopes work. I don&#x27;t see what is special about the inner functions using things in the scope of the outer functions.</div><br/><div id="41793878" class="c"><input type="checkbox" id="c-41793878" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41786471">parent</a><span>|</span><a href="#41786380">next</a><span>|</span><label class="collapse" for="c-41793878">[-]</label><label class="expand" for="c-41793878">[1 more]</label></div><br/><div class="children"><div class="content">Excessive use of external bindings in a closure can make it hard to reason about lifetimes in cases where that matters (e.g. when you find out that a huge object graph is alive solely because some callback somewhere is a lambda that closed over one of the objects in said graph).</div><br/></div></div></div></div><div id="41786380" class="c"><input type="checkbox" id="c-41786380" checked=""/><div class="controls bullet"><span class="by">orf</span><span>|</span><a href="#41785121">parent</a><span>|</span><a href="#41786471">prev</a><span>|</span><a href="#41785311">next</a><span>|</span><label class="collapse" for="c-41786380">[-]</label><label class="expand" for="c-41786380">[2 more]</label></div><br/><div class="children"><div class="content">That’s gonna be quite expensive, don’t do this in hot loops. You’re re-defining and re-creating the function object each time the outer function is called.</div><br/><div id="41791464" class="c"><input type="checkbox" id="c-41791464" checked=""/><div class="controls bullet"><span class="by">gorgoiler</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41786380">parent</a><span>|</span><a href="#41785311">next</a><span>|</span><label class="collapse" for="c-41791464">[-]</label><label class="expand" for="c-41791464">[1 more]</label></div><br/><div class="children"><div class="content">Good point.  I measured it for 10^6 loops:<p>(1) 40ms for inline code;<p>(2) 150ms for an inner function with one expression;<p>(3) 200ms for a slightly more complex inner function; and<p>(4) 4000ms+ for an inner function and an inner class.<p><pre><code>  def f1(n: int) -&gt; int:
      return n * 2

  def f2(n: int) -&gt; int:
      def g():
          return n * 2
  
      return g()
  
  def f3(n: int) -&gt; int:
      def g():
          for _ in range(0):
              try:
                  pass
              except Exception as exc:
                  if isinstance(exc, 1):
                      pass
                  else:
                      while True:
                          pass
                  raise Exception()
          return n * 2
  
      return g()
  
  def f4(n: int) -&gt; int:
      class X:
          def __init__(self, a, b, c):
              pass
  
          def _(self) -&gt; float:
              return 1.23
  
      def g():
          for _ in range(0):
              try:
                  pass
              except Exception as exc:
                  if isinstance(exc, 1):
                      pass
                  else:
                      while True:
                          pass
                  raise Exception()
          return n * 2
  
      return g()</code></pre></div><br/></div></div></div></div><div id="41785311" class="c"><input type="checkbox" id="c-41785311" checked=""/><div class="controls bullet"><span class="by">InDubioProRubio</span><span>|</span><a href="#41785121">parent</a><span>|</span><a href="#41786380">prev</a><span>|</span><a href="#41785330">next</a><span>|</span><label class="collapse" for="c-41785311">[-]</label><label class="expand" for="c-41785311">[1 more]</label></div><br/><div class="children"><div class="content">So inlining is the private of functions without a object. Pop it all to stack, add arguments, set functionpointer to instructionstart of inline code, challenge accepted, lets go to..</div><br/></div></div><div id="41785330" class="c"><input type="checkbox" id="c-41785330" checked=""/><div class="controls bullet"><span class="by">raverbashing</span><span>|</span><a href="#41785121">parent</a><span>|</span><a href="#41785311">prev</a><span>|</span><a href="#41786010">next</a><span>|</span><label class="collapse" for="c-41785330">[-]</label><label class="expand" for="c-41785330">[1 more]</label></div><br/><div class="children"><div class="content">It might be a benefit in some cases, but I do feel that f1&#x2F;f2&#x2F;f3 are the prime candidates for actual unit testing</div><br/></div></div><div id="41786010" class="c"><input type="checkbox" id="c-41786010" checked=""/><div class="controls bullet"><span class="by">a_t48</span><span>|</span><a href="#41785121">parent</a><span>|</span><a href="#41785330">prev</a><span>|</span><a href="#41785325">next</a><span>|</span><label class="collapse" for="c-41786010">[-]</label><label class="expand" for="c-41786010">[4 more]</label></div><br/><div class="children"><div class="content">You can do this in C++, too, but the syntax is a little uglier.</div><br/><div id="41791753" class="c"><input type="checkbox" id="c-41791753" checked=""/><div class="controls bullet"><span class="by">kllrnohj</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41786010">parent</a><span>|</span><a href="#41785325">next</a><span>|</span><label class="collapse" for="c-41791753">[-]</label><label class="expand" for="c-41791753">[3 more]</label></div><br/><div class="children"><div class="content">Not that bad?<p><pre><code>    int main() {
        int a = -1;
        [&amp;] {
            a = 42;
            printf(&quot;I&#x27;m an uncallable inline block&quot;);
        }();

        printf(&quot; &quot;);

        [&amp;] {
            printf(&quot;of code\n&quot;);
        }();

        [&amp;] {
            printf(&quot;Passing state: %d\n&quot;, a);
        }();

        return 0;
    }</code></pre></div><br/><div id="41793887" class="c"><input type="checkbox" id="c-41793887" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41791753">parent</a><span>|</span><a href="#41791824">next</a><span>|</span><label class="collapse" for="c-41793887">[-]</label><label class="expand" for="c-41793887">[1 more]</label></div><br/><div class="children"><div class="content">At this point, why wouldn&#x27;t you just use a nested block?</div><br/></div></div><div id="41791824" class="c"><input type="checkbox" id="c-41791824" checked=""/><div class="controls bullet"><span class="by">a_t48</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41791753">parent</a><span>|</span><a href="#41793887">prev</a><span>|</span><a href="#41785325">next</a><span>|</span><label class="collapse" for="c-41791824">[-]</label><label class="expand" for="c-41791824">[1 more]</label></div><br/><div class="children"><div class="content">It’s not horrible, a little bit verbose though.</div><br/></div></div></div></div></div></div><div id="41785325" class="c"><input type="checkbox" id="c-41785325" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#41785121">parent</a><span>|</span><a href="#41786010">prev</a><span>|</span><a href="#41786298">next</a><span>|</span><label class="collapse" for="c-41785325">[-]</label><label class="expand" for="c-41785325">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s possible to nest subprograms within subprograms in Ada. I take advantage of this ability to break a large operation into one or more smaller simpler &quot;core&quot; operations, and then in the main body of the procedure write some setup code followed by calls to the core operation(s).</div><br/></div></div><div id="41786298" class="c"><input type="checkbox" id="c-41786298" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#41785121">parent</a><span>|</span><a href="#41785325">prev</a><span>|</span><a href="#41790835">next</a><span>|</span><label class="collapse" for="c-41786298">[-]</label><label class="expand" for="c-41786298">[3 more]</label></div><br/><div class="children"><div class="content">Remember to `nonlocal xs, db, logger` inside those inner functions. I&#x27;m not sure if this is needed for variables that are only read, but I wouldn&#x27;t ever leave it out.</div><br/><div id="41787933" class="c"><input type="checkbox" id="c-41787933" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41786298">parent</a><span>|</span><a href="#41790835">next</a><span>|</span><label class="collapse" for="c-41787933">[-]</label><label class="expand" for="c-41787933">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>I&#x27;m not sure if this is needed for variables that are only read</i><p>It’s not needed. In fact, you <i>should</i> leave it out for read-only variables. That’s standard practice - if you use `nonlocal` people reading the code will expect to see writes to the variables.</div><br/><div id="41794968" class="c"><input type="checkbox" id="c-41794968" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41787933">parent</a><span>|</span><a href="#41790835">next</a><span>|</span><label class="collapse" for="c-41794968">[-]</label><label class="expand" for="c-41794968">[1 more]</label></div><br/><div class="children"><div class="content">&gt; That’s standard practice - if you use `nonlocal` people reading the code will expect to see writes to the variables.<p>Since when? I was under the impression Python virtually doesn&#x27;t have lexical scoping at all and that&#x27;s why `nonlocal` exists. I mean hell, in CPython you can literally access and modify the local variables of your caller (and everything else up the call stack too). I never associated `nonlocal` at all with specifically writes. Just access in general.</div><br/></div></div></div></div></div></div></div></div><div id="41790835" class="c"><input type="checkbox" id="c-41790835" checked=""/><div class="controls bullet"><span class="by">low_tech_love</span><span>|</span><a href="#41785121">prev</a><span>|</span><a href="#41785389">next</a><span>|</span><label class="collapse" for="c-41790835">[-]</label><label class="expand" for="c-41790835">[2 more]</label></div><br/><div class="children"><div class="content">Interesting: this is a 2014 post from Jonathan Blow reproducing a 2014 comment by John Carmack reproducing a 2007 e-mail by the same Carmack reproducing a 2006 conversation (I assume also via e-mail) he had with a Henry Spencer reproducing something else the same Spencer read a while ago and was trying to remember (possibly inaccurately?).<p>I wonder what is the actual original source (from Saab, maybe?), and if this indeed holds true?</div><br/><div id="41792323" class="c"><input type="checkbox" id="c-41792323" checked=""/><div class="controls bullet"><span class="by">EGreg</span><span>|</span><a href="#41790835">parent</a><span>|</span><a href="#41785389">next</a><span>|</span><label class="collapse" for="c-41792323">[-]</label><label class="expand" for="c-41792323">[1 more]</label></div><br/><div class="children"><div class="content">Is this kind of like 300 was a movie about a Frank Miller novel about a Greek legend about the actual Battle of Thermopylae?</div><br/></div></div></div></div><div id="41785389" class="c"><input type="checkbox" id="c-41785389" checked=""/><div class="controls bullet"><span class="by">dehrmann</span><span>|</span><a href="#41790835">prev</a><span>|</span><a href="#41787915">next</a><span>|</span><label class="collapse" for="c-41785389">[-]</label><label class="expand" for="c-41785389">[12 more]</label></div><br/><div class="children"><div class="content">Always read older stuff from Carmack remembering the context. He made a name for himself getting 3D games to run on slow hardware. The standard advice of write for clarity first, make sure algorithms have reasonable runtimes, and look at profiler data if it&#x27;s slow is all you need 99% of the time.</div><br/><div id="41786778" class="c"><input type="checkbox" id="c-41786778" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#41785389">parent</a><span>|</span><a href="#41785455">next</a><span>|</span><label class="collapse" for="c-41786778">[-]</label><label class="expand" for="c-41786778">[3 more]</label></div><br/><div class="children"><div class="content">I find the inlined style can actually improve clarity.<p>A lot of code written toward the &quot;uncle bob&quot; style where you maximize the number of functions has fantastic local clarity, you can see exactly what the code you are looking at is doing; but atrocious global clarity, where it&#x27;s nearly impossible to figure out what the system does on a larger scale.<p>Inlining can help with that, local clarity deteriorates a bit, but global clarity typically improves by reducing the number of indirections.  The code does indeed also tend to get faster, as it&#x27;s much easier to identify and remove redundant code when you have it all in front of you. ... but this also improves the clarity of the code!<p>You can of course go too far, in either direction, but my sense is that we&#x27;re often leaning much too far toward short isolated functions now than is optimal.</div><br/><div id="41793984" class="c"><input type="checkbox" id="c-41793984" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41785389">root</a><span>|</span><a href="#41786778">parent</a><span>|</span><a href="#41790160">next</a><span>|</span><label class="collapse" for="c-41793984">[-]</label><label class="expand" for="c-41793984">[1 more]</label></div><br/><div class="children"><div class="content">One thing that&#x27;s nice about functions is that they force the associated block of code to be named, and for state that is specific to the function to be clearly separate from external state (closures aside). It would be good to be able to retain those advantages even in linear code that nevertheless has clear boundaries between different parts of it that would be nice to enforce or at least highlight, but without losing the readability of sequential execution.<p>To some extent you can have that in languages that let you create a named lambda with explicit captures and immediately invoke it, e.g. in C++:<p><pre><code>   int g;

   void doThisAndThat(int a, int b, int c) {

      doThis: auto x = [&amp;a, &amp;b] {
        ...
      }();

      doThat: [&amp;g, &amp;c, &amp;x] {
        ...
      }();
   }
</code></pre>
The syntax makes it kind of an eyesore though. Would be nice to have something specifically designed for this purpose.</div><br/></div></div><div id="41790160" class="c"><input type="checkbox" id="c-41790160" checked=""/><div class="controls bullet"><span class="by">silvestrov</span><span>|</span><a href="#41785389">root</a><span>|</span><a href="#41786778">parent</a><span>|</span><a href="#41793984">prev</a><span>|</span><a href="#41785455">next</a><span>|</span><label class="collapse" for="c-41790160">[-]</label><label class="expand" for="c-41790160">[1 more]</label></div><br/><div class="children"><div class="content">&gt; atrocious global clarity<p>much like microservices.</div><br/></div></div></div></div><div id="41785455" class="c"><input type="checkbox" id="c-41785455" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#41785389">parent</a><span>|</span><a href="#41786778">prev</a><span>|</span><a href="#41785433">next</a><span>|</span><label class="collapse" for="c-41785455">[-]</label><label class="expand" for="c-41785455">[6 more]</label></div><br/><div class="children"><div class="content">And before that, 2D games (side-scrolling platformers were not a thing on PC hardware until Carmack did it, iirc). I think his main thing is balancing clarity - what happens when and in what order - with maintainability.<p>Compare this with enterprise software, which is orders of magnitude more complex than video games in terms of business logic (the complexity in video games is in performance optimization), but whose developers tend to add many layers of abstraction and indirection, so the core business process is obfuscated, or there&#x27;s a billion non-functional side activities also being applied (logging, analytics, etc), again obfuscating the core functionality.<p>It&#x27;s fun to go back to more elementary programming things, in e.g. Advent of Code challenges or indeed, game development.</div><br/><div id="41785573" class="c"><input type="checkbox" id="c-41785573" checked=""/><div class="controls bullet"><span class="by">nadam</span><span>|</span><a href="#41785389">root</a><span>|</span><a href="#41785455">parent</a><span>|</span><a href="#41785665">next</a><span>|</span><label class="collapse" for="c-41785573">[-]</label><label class="expand" for="c-41785573">[2 more]</label></div><br/><div class="children"><div class="content">&quot;compare this with enterprise software, which is orders of magnitude more complex than video games in terms of business logic&quot;
Maybe this was true 20 years ago, but I do not think this is true today. Game code of some games is almost as complex as enterprise software or even more complex in some cases (think of grand strategy games like Civilization or Paradox games). The difference is that it still needs to be performant, so the evolutionary force just kills programmers and companies creating unperformant abstractions. In my opinion game programming is just harder than enterprise programming if we speak about complex games. (I have done both). The only thing which is easier in game programming is that it is a bit easier to 
 see clearly in terms of &#x27;business requirements&#x27;, and also it is more meritocratic (you can start a game company anywhere on the globe, no need to be at business centers.) And of course game programming is more fun, so programmers do the harder job even for less money.<p>For people who think game programming is less complex than enterprise software, I suggest the CharacterMovementComponent class in unreal engine which is the logic of movement of characters (people) in a networked game environment... With multiple thousand lines of code in just the header is not uncommon in unreal. And this is not complex because of optimization mostly. This is very complex and messy logic. Of course we can argue that networking and physics could be done in a simple naive way, which would be unacceptable in terms of latency and throughput, so all in all complexity is because of optimization after all. But it is not the &#x27;fun&#x27; elegant kind of optimization, it is close to messy enterprise software in some sense in my opinion.</div><br/><div id="41786371" class="c"><input type="checkbox" id="c-41786371" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#41785389">root</a><span>|</span><a href="#41785573">parent</a><span>|</span><a href="#41785665">next</a><span>|</span><label class="collapse" for="c-41786371">[-]</label><label class="expand" for="c-41786371">[1 more]</label></div><br/><div class="children"><div class="content">I have heard modern game development compared to OS development in terms of complexity and I think that comparison is quite apt; especially when the game involves intricate graphics and complicated networking involving multiple time scales as you say.</div><br/></div></div></div></div><div id="41785665" class="c"><input type="checkbox" id="c-41785665" checked=""/><div class="controls bullet"><span class="by">high_na_euv</span><span>|</span><a href="#41785389">root</a><span>|</span><a href="#41785455">parent</a><span>|</span><a href="#41785573">prev</a><span>|</span><a href="#41793589">next</a><span>|</span><label class="collapse" for="c-41785665">[-]</label><label class="expand" for="c-41785665">[2 more]</label></div><br/><div class="children"><div class="content">&gt;Compare this with enterprise software, which is orders of magnitude more complex than video games in terms of business logic<p>I dont buy it in games like gta, cyberpunk or witcher 3</div><br/><div id="41786054" class="c"><input type="checkbox" id="c-41786054" checked=""/><div class="controls bullet"><span class="by">a_t48</span><span>|</span><a href="#41785389">root</a><span>|</span><a href="#41785665">parent</a><span>|</span><a href="#41793589">next</a><span>|</span><label class="collapse" for="c-41786054">[-]</label><label class="expand" for="c-41786054">[1 more]</label></div><br/><div class="children"><div class="content">In both design space and programming complexity, you&#x27;re right.</div><br/></div></div></div></div><div id="41793589" class="c"><input type="checkbox" id="c-41793589" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#41785389">root</a><span>|</span><a href="#41785455">parent</a><span>|</span><a href="#41785665">prev</a><span>|</span><a href="#41785433">next</a><span>|</span><label class="collapse" for="c-41793589">[-]</label><label class="expand" for="c-41793589">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And before that, 2D games (side-scrolling platformers were not a thing on PC hardware until Carmack did it, iirc). I think his main thing is balancing clarity - what happens when and in what order - with maintainability.<p>Smooth side-scrollers did exist on the PC before Keen (An early one would be the PC port of Defender).  <i>Moon Patrol</i> even had jumping in the early &#x27;80s.<p>Furthermore other contemporaries of Carmack were making full-fledged side-scrolling platformers in ways different from how Keen did it (there were many platformers released in 1990).  They all involved various limitations on level design (as did what Keen used), but I don&#x27;t believe any of them allowed both X and Y scrolling like the Keen games did.</div><br/></div></div></div></div><div id="41785433" class="c"><input type="checkbox" id="c-41785433" checked=""/><div class="controls bullet"><span class="by">physicles</span><span>|</span><a href="#41785389">parent</a><span>|</span><a href="#41785455">prev</a><span>|</span><a href="#41787915">next</a><span>|</span><label class="collapse" for="c-41785433">[-]</label><label class="expand" for="c-41785433">[2 more]</label></div><br/><div class="children"><div class="content">I agree with this in general, but his essay on functional programming in C++ (linked at the top of the page) is phenomenal and is fantastic general advice when working in any non-functional language.</div><br/><div id="41785522" class="c"><input type="checkbox" id="c-41785522" checked=""/><div class="controls bullet"><span class="by">nicolaslegland</span><span>|</span><a href="#41785389">root</a><span>|</span><a href="#41785433">parent</a><span>|</span><a href="#41787915">next</a><span>|</span><label class="collapse" for="c-41785522">[-]</label><label class="expand" for="c-41785522">[1 more]</label></div><br/><div class="children"><div class="content"><i>Link at the top of the page</i> broken, found an archived version at <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20120501221535&#x2F;http:&#x2F;&#x2F;gamasutra.com&#x2F;view&#x2F;news&#x2F;169296&#x2F;Indepth_Functional_programming_in_C.php" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20120501221535&#x2F;http:&#x2F;&#x2F;gamasutra....</a></div><br/></div></div></div></div></div></div><div id="41787915" class="c"><input type="checkbox" id="c-41787915" checked=""/><div class="controls bullet"><span class="by">donatj</span><span>|</span><a href="#41785389">prev</a><span>|</span><a href="#41795964">next</a><span>|</span><label class="collapse" for="c-41787915">[-]</label><label class="expand" for="c-41787915">[5 more]</label></div><br/><div class="children"><div class="content">I have a coworker that LOVES to make these one or two line single use functions that absolutely drives me nuts.<p>Just from a sheer readability perspective being able to read a routine from top to bottom and understand what everything is doing is invaluable.<p>I have thought about it many times, I wish there was an IDE where you could expand function calls inline.</div><br/><div id="41788172" class="c"><input type="checkbox" id="c-41788172" checked=""/><div class="controls bullet"><span class="by">wodenokoto</span><span>|</span><a href="#41787915">parent</a><span>|</span><a href="#41791712">next</a><span>|</span><label class="collapse" for="c-41788172">[-]</label><label class="expand" for="c-41788172">[2 more]</label></div><br/><div class="children"><div class="content">It’s called “self documenting code” and the way you self document code it is by taking all your comments and make them into functions, named after your would-be comment.<p>I’m not a fan either.</div><br/><div id="41788747" class="c"><input type="checkbox" id="c-41788747" checked=""/><div class="controls bullet"><span class="by">MetaWhirledPeas</span><span>|</span><a href="#41787915">root</a><span>|</span><a href="#41788172">parent</a><span>|</span><a href="#41791712">next</a><span>|</span><label class="collapse" for="c-41788747">[-]</label><label class="expand" for="c-41788747">[1 more]</label></div><br/><div class="children"><div class="content">Everything must be done to taste. I think code can be made &quot;self-documenting&quot; without going overboard and doing silly things.</div><br/></div></div></div></div><div id="41791712" class="c"><input type="checkbox" id="c-41791712" checked=""/><div class="controls bullet"><span class="by">zelphirkalt</span><span>|</span><a href="#41787915">parent</a><span>|</span><a href="#41788172">prev</a><span>|</span><a href="#41789131">next</a><span>|</span><label class="collapse" for="c-41791712">[-]</label><label class="expand" for="c-41791712">[1 more]</label></div><br/><div class="children"><div class="content">This can be done in a good way and in bad ways. With most code you will be calling builtin procedures&#x2F;functions. You also don&#x27;t look under the hood for those usually. But for the code of your coworker it seems to irritate you. This could mean many things. Just to name a few: (1) The names are not giving a good idea what those functions do. (2) The level of abstraction is not the same inside the calling function, so that you feel the need to check the implementation detail of those small functions. (3) You don&#x27;t trust the implementation of those smaller functions. (4) The separated out functions could be not worth separating out and being given names, because what the code in them does is clear enough without them being separated out. (n) or some other reason.<p>The issue does not have to be that those things are split out into separate small functions. The issue might be something else.</div><br/></div></div><div id="41789131" class="c"><input type="checkbox" id="c-41789131" checked=""/><div class="controls bullet"><span class="by">Tyr42</span><span>|</span><a href="#41787915">parent</a><span>|</span><a href="#41791712">prev</a><span>|</span><a href="#41795964">next</a><span>|</span><label class="collapse" for="c-41789131">[-]</label><label class="expand" for="c-41789131">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes it&#x27;s easier to define some vocabulary and then use it.  Like defining push and pop on a stack vs stack[++ix] = blah and blah = stack[ix--].<p>And avoids needing to think about it being prefix or postfix after you don&#x27;t that one time.<p>But at other times it&#x27;s insufferable, when the abstraction is leaky and unintuitive.</div><br/></div></div></div></div><div id="41795964" class="c"><input type="checkbox" id="c-41795964" checked=""/><div class="controls bullet"><span class="by">torginus</span><span>|</span><a href="#41787915">prev</a><span>|</span><a href="#41785428">next</a><span>|</span><label class="collapse" for="c-41795964">[-]</label><label class="expand" for="c-41795964">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Typically I am there to rail against the people that talk about using threads and an RTOS for such things, when a simple polled loop that looks like a primitive video game is much more clear and effective. &quot;<p>Yess, I finally feel vindicated. I&#x27;ve been having this argument with embedded people since forever. I was of the opinion that if million line big boy PC apps can make do with just one thread, having fifteen threads and synchronizing between them using mutexes and condition variables on a microcontroller with 64kb RAM is just  bonkers.<p>For some reason, the statement that a while(true) loop + ISRs + DMA can do everything an RTOS like FreeRTOS can do, can rile up embedded folks to no end.</div><br/></div></div><div id="41785428" class="c"><input type="checkbox" id="c-41785428" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#41795964">prev</a><span>|</span><a href="#41785588">next</a><span>|</span><label class="collapse" for="c-41785428">[-]</label><label class="expand" for="c-41785428">[2 more]</label></div><br/><div class="children"><div class="content">I feel like this style is also encouraged in Go and &#x2F; or the clean&#x2F;onion architecture &#x2F; DDD, to a point, where the core business logic can and should be a string of &quot;do this, then do that, then do that&quot; code. In my own experience I&#x27;ve only had a few opportunities to do so (most of my work is front-end which is a different thing entirely), the one was application initialisation (Create the logger, then connect to the database, then if needed initialize &#x2F; migrate it, then if needed load test data. Then create the core domain services that uses the database connection. Then create the HTTP handlers that interface with the domain services. Then start the HTTP server. Then listen for an end process command and shut down gracefully), the other was pure business logic (read the database, transform, write to file, but &quot;database&quot; and &quot;file&quot; were abstract concepts that could be swapped out easily). You don&#x27;t really get that in front-end programming though, it&#x27;s all event driven etc.</div><br/><div id="41785565" class="c"><input type="checkbox" id="c-41785565" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#41785428">parent</a><span>|</span><a href="#41785588">next</a><span>|</span><label class="collapse" for="c-41785565">[-]</label><label class="expand" for="c-41785565">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the one was application initialisation<p>...and then you want to parallelize as much as possible to allow for fast boot times which helps the development process immensely.<p>One of the things I&#x27;ve learned is that optimizing for developer quality of life is one of the best approaches when it comes to correctness and performance. Then, the developers would be able to run multiple iterations of the real thing.</div><br/></div></div></div></div><div id="41785588" class="c"><input type="checkbox" id="c-41785588" checked=""/><div class="controls bullet"><span class="by">otikik</span><span>|</span><a href="#41785428">prev</a><span>|</span><a href="#41794424">next</a><span>|</span><label class="collapse" for="c-41785588">[-]</label><label class="expand" for="c-41785588">[3 more]</label></div><br/><div class="children"><div class="content">&gt;  I have gotten much more bullish about pure functional programming, even in C&#x2F;C++ where reasonable: (link)<p>The link is no longer valid, I believe this is the article in question:<p><a href="https:&#x2F;&#x2F;www.gamedeveloper.com&#x2F;programming&#x2F;in-depth-functional-programming-in-c-" rel="nofollow">https:&#x2F;&#x2F;www.gamedeveloper.com&#x2F;programming&#x2F;in-depth-functiona...</a></div><br/><div id="41785617" class="c"><input type="checkbox" id="c-41785617" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41785588">parent</a><span>|</span><a href="#41794424">next</a><span>|</span><label class="collapse" for="c-41785617">[-]</label><label class="expand" for="c-41785617">[2 more]</label></div><br/><div class="children"><div class="content">Probably the more important link. He&#x27;s basically saying his old email is outdated and he does pure FP now.</div><br/><div id="41785825" class="c"><input type="checkbox" id="c-41785825" checked=""/><div class="controls bullet"><span class="by">meheleventyone</span><span>|</span><a href="#41785588">root</a><span>|</span><a href="#41785617">parent</a><span>|</span><a href="#41794424">next</a><span>|</span><label class="collapse" for="c-41785825">[-]</label><label class="expand" for="c-41785825">[1 more]</label></div><br/><div class="children"><div class="content">This is over a decade old at this stage, it would be interesting to know how his thoughts have evolved since.</div><br/></div></div></div></div></div></div><div id="41794424" class="c"><input type="checkbox" id="c-41794424" checked=""/><div class="controls bullet"><span class="by">rcv</span><span>|</span><a href="#41785588">prev</a><span>|</span><a href="#41785875">next</a><span>|</span><label class="collapse" for="c-41794424">[-]</label><label class="expand" for="c-41794424">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The fly-by-wire flight software for the Saab Gripen (a lightweight fighter) went a step further...<p>I would love to hear some war stories about the development of flight software.  A lot of it is surely classified, but I&#x27;m fascinated by how those systems are put together.</div><br/></div></div><div id="41785875" class="c"><input type="checkbox" id="c-41785875" checked=""/><div class="controls bullet"><span class="by">physicsguy</span><span>|</span><a href="#41794424">prev</a><span>|</span><a href="#41785763">next</a><span>|</span><label class="collapse" for="c-41785875">[-]</label><label class="expand" for="c-41785875">[1 more]</label></div><br/><div class="children"><div class="content">I think when developing something from scratch, it&#x27;s actually not a terrible strategy to do this and pick out boundaries when they become clearer. Creating interfaces that make sense is an art, not a science.</div><br/></div></div><div id="41785763" class="c"><input type="checkbox" id="c-41785763" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#41785875">prev</a><span>|</span><a href="#41785847">next</a><span>|</span><label class="collapse" for="c-41785763">[-]</label><label class="expand" for="c-41785763">[11 more]</label></div><br/><div class="children"><div class="content">I wish languages had the following:<p><pre><code>  let x = block {
     …
     return 5
  } &#x2F;&#x2F; x == 5
</code></pre>
And the way to mark copypaste, e.g.<p><pre><code>  common foo {
    asdf(qwerty(i+j));
    printf(“%p”, write));
    bar();
  }
  …(repeats verbatim 20 times)…
  …
  common foo {
    asdf(qwerty(i+k));
    printf(“%d”, (int)write); &#x2F;&#x2F; cast to int
    bar();
  }
  …
</code></pre>
And then you could `mycc diff-common foo` and see:<p><pre><code>  &lt;file&gt;:&lt;line&gt;: common
  &lt;file&gt;:&lt;line&gt;: common
  …
  &lt;file&gt;:&lt;line&gt;:
    @@…@@
    -asdf(qwerty(i+j));
    +asdf(qwerty(i+k));
    @@…@@
    -printf(“%p”, write));
    +printf(“%d”, (int)write); &#x2F;&#x2F; cast to int
</code></pre>
With this you can track named common blocks (allows using surrounding context like i,j,k). Without them being functions and subject for functional entanglement $subj discusses. Most common code gets found out and divergences get bold. IDE support for immediate highlighting, snippeting and auto-common-ing similar code would be very nice.<p>Multi-patching common parts with easily reviewing the results would also be great. Because the bugs from calling a common function arise from the fact that you modify it and it suddenly works differently for some context. Well, you can comment a common block as fragile and then ignore it while patching:<p><pre><code>  common foo {
    &#x2F;&#x2F; @const: modified and fragile!
    …
  }
</code></pre>
You still see differences but it doesn’t add in a multi-patch dialog.<p>Not expecting it to appear anywhere though, features like that are never considered. Maybe someone interested can feature it in circles? (without my name associated)</div><br/><div id="41785849" class="c"><input type="checkbox" id="c-41785849" checked=""/><div class="controls bullet"><span class="by">badmintonbaseba</span><span>|</span><a href="#41785763">parent</a><span>|</span><a href="#41792772">next</a><span>|</span><label class="collapse" for="c-41785849">[-]</label><label class="expand" for="c-41785849">[6 more]</label></div><br/><div class="children"><div class="content">In C++ it&#x27;s an idiom to use immediately invoked lambdas:<p><pre><code>  auto x = []{
    &#x2F;*...*&#x2F;
    return 5;
  }();
</code></pre>
There is&#x2F;was an attempt to introduce a more of a first-class language construct for such immediate &quot;block expressions&quot;:<p><a href="https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2023&#x2F;p2806r2.html" rel="nofollow">https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2023&#x2F;p28...</a><p>I&#x27;m not convinced that automatic checking of copy-paste errors of such blocks make much sense though. At least I think the false positive rate would be way too high.</div><br/><div id="41786301" class="c"><input type="checkbox" id="c-41786301" checked=""/><div class="controls bullet"><span class="by">sltkr</span><span>|</span><a href="#41785763">root</a><span>|</span><a href="#41785849">parent</a><span>|</span><a href="#41785895">next</a><span>|</span><label class="collapse" for="c-41786301">[-]</label><label class="expand" for="c-41786301">[1 more]</label></div><br/><div class="children"><div class="content">GCC has supported statement expressions for ages: <a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Statement-Exprs.html" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Statement-Exprs.html</a><p>They&#x27;re also used extensively in the Linux kernel, mostly to implement macros: <a href="https:&#x2F;&#x2F;github.com&#x2F;search?q=repo%3Atorvalds%2Flinux%20%22(%7B%22&amp;type=code">https:&#x2F;&#x2F;github.com&#x2F;search?q=repo%3Atorvalds%2Flinux%20%22(%7...</a></div><br/></div></div><div id="41785895" class="c"><input type="checkbox" id="c-41785895" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#41785763">root</a><span>|</span><a href="#41785849">parent</a><span>|</span><a href="#41786301">prev</a><span>|</span><a href="#41786566">next</a><span>|</span><label class="collapse" for="c-41785895">[-]</label><label class="expand" for="c-41785895">[1 more]</label></div><br/><div class="children"><div class="content">IIFE exist, but are cumbersome to type&#x2F;read in most languages. C++ is probably the winner by syntax and semantics here.<p><i>false positive rate would be way too high</i><p>The key idea is not to have identical blocks, but to have a way to overview changes in similar code, similar by origin and design. It’s a snippet diff tool, not a typo autocorrector. There’s no false positives cause if “common foo” has zero diff in all cases, it probably <i>should</i> be “foo(…)”.</div><br/></div></div><div id="41786566" class="c"><input type="checkbox" id="c-41786566" checked=""/><div class="controls bullet"><span class="by">mkoubaa</span><span>|</span><a href="#41785763">root</a><span>|</span><a href="#41785849">parent</a><span>|</span><a href="#41785895">prev</a><span>|</span><a href="#41792772">next</a><span>|</span><label class="collapse" for="c-41786566">[-]</label><label class="expand" for="c-41786566">[3 more]</label></div><br/><div class="children"><div class="content">Now if only c++ could guarantee copy elision from lambda returns...</div><br/><div id="41786674" class="c"><input type="checkbox" id="c-41786674" checked=""/><div class="controls bullet"><span class="by">badmintonbaseba</span><span>|</span><a href="#41785763">root</a><span>|</span><a href="#41786566">parent</a><span>|</span><a href="#41786705">next</a><span>|</span><label class="collapse" for="c-41786674">[-]</label><label class="expand" for="c-41786674">[1 more]</label></div><br/><div class="children"><div class="content">There is a lot of guaranteed copy elision since C++17, what exactly do you mean?</div><br/></div></div><div id="41786705" class="c"><input type="checkbox" id="c-41786705" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41785763">root</a><span>|</span><a href="#41786566">parent</a><span>|</span><a href="#41786674">prev</a><span>|</span><a href="#41792772">next</a><span>|</span><label class="collapse" for="c-41786705">[-]</label><label class="expand" for="c-41786705">[1 more]</label></div><br/><div class="children"><div class="content">It depends if using C++17 and later versions.</div><br/></div></div></div></div></div></div><div id="41792772" class="c"><input type="checkbox" id="c-41792772" checked=""/><div class="controls bullet"><span class="by">atq2119</span><span>|</span><a href="#41785763">parent</a><span>|</span><a href="#41785849">prev</a><span>|</span><a href="#41785870">next</a><span>|</span><label class="collapse" for="c-41792772">[-]</label><label class="expand" for="c-41792772">[1 more]</label></div><br/><div class="children"><div class="content">Regarding compound statements returning values: There are a number of languages which have that, including Rust. Ironically, it made me wish for a reversed form of the construct, i.e. something like<p><pre><code>    { ...; expr } --&gt; x;
    &#x2F;&#x2F; x is a new variable initialized to expr
</code></pre>
I feel like this would help readability when the compound statement is very large.</div><br/></div></div><div id="41785870" class="c"><input type="checkbox" id="c-41785870" checked=""/><div class="controls bullet"><span class="by">lexicality</span><span>|</span><a href="#41785763">parent</a><span>|</span><a href="#41792772">prev</a><span>|</span><a href="#41785847">next</a><span>|</span><label class="collapse" for="c-41785870">[-]</label><label class="expand" for="c-41785870">[3 more]</label></div><br/><div class="children"><div class="content">Can you help me understand why this would be beneficial, other than avoiding using the word &quot;function&quot;?</div><br/><div id="41785929" class="c"><input type="checkbox" id="c-41785929" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#41785763">root</a><span>|</span><a href="#41785870">parent</a><span>|</span><a href="#41785847">next</a><span>|</span><label class="collapse" for="c-41785929">[-]</label><label class="expand" for="c-41785929">[2 more]</label></div><br/><div class="children"><div class="content">I guess you’re asking about the block part — it’s a minor syntactic convenience and not the main point of the comment. It avoids the word function&#x2F;lambda or def-block and related syntactic inconvenience like parentheses around and at the end and interference with ASI (when applicable).</div><br/><div id="41789287" class="c"><input type="checkbox" id="c-41789287" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#41785763">root</a><span>|</span><a href="#41785929">parent</a><span>|</span><a href="#41785847">next</a><span>|</span><label class="collapse" for="c-41789287">[-]</label><label class="expand" for="c-41789287">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re looking for blocks-as-expressions, e.g. the following is valid Rust:<p><pre><code>    let x = {
        whatever;
        5
    }; &#x2F;&#x2F; assigns 5 to x</code></pre></div><br/></div></div></div></div></div></div></div></div><div id="41785847" class="c"><input type="checkbox" id="c-41785847" checked=""/><div class="controls bullet"><span class="by">nuancebydefault</span><span>|</span><a href="#41785763">prev</a><span>|</span><a href="#41792965">next</a><span>|</span><label class="collapse" for="c-41785847">[-]</label><label class="expand" for="c-41785847">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The function that is least likely to cause a problem is one that doesn’t exist, which is the benefit of inlining it.<p>I think that summarizes the case pro inlining.</div><br/></div></div><div id="41792965" class="c"><input type="checkbox" id="c-41792965" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#41785847">prev</a><span>|</span><a href="#41791775">next</a><span>|</span><label class="collapse" for="c-41792965">[-]</label><label class="expand" for="c-41792965">[1 more]</label></div><br/><div class="children"><div class="content">In my opinion, there is value in functions that have only one caller: it&#x27;s called functional decomposition. The right granularity of functional decomposition can make the logic easier to understand.<p>To prevent unintended uses of a helper function in C, you can make it static. Then at least nothing from outside of that translation unit can call it.</div><br/></div></div><div id="41791775" class="c"><input type="checkbox" id="c-41791775" checked=""/><div class="controls bullet"><span class="by">lencastre</span><span>|</span><a href="#41792965">prev</a><span>|</span><a href="#41789414">next</a><span>|</span><label class="collapse" for="c-41791775">[-]</label><label class="expand" for="c-41791775">[3 more]</label></div><br/><div class="children"><div class="content">I’m not even pretending I understood Carmack’s email&#x2F;mailing list post but if more intelligent&#x2F;experienced programmers than me care to help me out, what exactly is meant by this he wrote in 2007:<p>_If a function is called from multiple places, see if it is possible to arrange for the work to be done in a single place, perhaps with flags, and inline that._<p>Thanks,</div><br/><div id="41791866" class="c"><input type="checkbox" id="c-41791866" checked=""/><div class="controls bullet"><span class="by">tcoville</span><span>|</span><a href="#41791775">parent</a><span>|</span><a href="#41789414">next</a><span>|</span><label class="collapse" for="c-41791866">[-]</label><label class="expand" for="c-41791866">[2 more]</label></div><br/><div class="children"><div class="content">This is a heavily simplified version of what I&#x27;m suspecting he&#x27;s trying to portray, key this wouldn&#x27;t be useful for utility functions like string manipulation but more business logic being used across similar functions:<p><pre><code>  def processOrder():
      # Some common processing logic
      print(&quot;Processing the order...&quot;)
  
  def placeOnlineOrder():
      processOrder()
      print(&quot;Sending confirmation email...&quot;)
  
  def placeInStoreOrder():
      processOrder()
      print(&quot;Printing receipt...&quot;)
  
  # Calls from different locations
  placeOnlineOrder()
  placeInStoreOrder()
</code></pre>
Could become:<p><pre><code>  def processOrder(order_type):
      # Common processing logic
      print(&quot;Processing the order...&quot;)
  
      if order_type == &quot;online&quot;:
          print(&quot;Sending confirmation email...&quot;)
      elif order_type == &quot;in_store&quot;:
          print(&quot;Printing receipt...&quot;)
  
  # Unified calls with different flags
  processOrder(&quot;online&quot;)
  processOrder(&quot;in_store&quot;)</code></pre></div><br/><div id="41792332" class="c"><input type="checkbox" id="c-41792332" checked=""/><div class="controls bullet"><span class="by">fluoridation</span><span>|</span><a href="#41791775">root</a><span>|</span><a href="#41791866">parent</a><span>|</span><a href="#41789414">next</a><span>|</span><label class="collapse" for="c-41792332">[-]</label><label class="expand" for="c-41792332">[1 more]</label></div><br/><div class="children"><div class="content">That... looks decidedly worse. Now you have fewer functions that need to be concerned with multiple unrelated things for no reason.</div><br/></div></div></div></div></div></div><div id="41789414" class="c"><input type="checkbox" id="c-41789414" checked=""/><div class="controls bullet"><span class="by">endlessmike89</span><span>|</span><a href="#41791775">prev</a><span>|</span><a href="#41789864">next</a><span>|</span><label class="collapse" for="c-41789414">[-]</label><label class="expand" for="c-41789414">[1 more]</label></div><br/><div class="children"><div class="content">Link to the Wayback Machine cache&#x2F;mirror, in case you&#x27;re also experiencing a &quot;Bad Gateway&#x2F;Connection refused&quot; error<p><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20241009062005&#x2F;http:&#x2F;&#x2F;number-none.com&#x2F;blow&#x2F;blog&#x2F;programming&#x2F;2014&#x2F;09&#x2F;26&#x2F;carmack-on-inlined-code.html" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20241009062005&#x2F;http:&#x2F;&#x2F;number-non...</a></div><br/></div></div><div id="41789864" class="c"><input type="checkbox" id="c-41789864" checked=""/><div class="controls bullet"><span class="by">easeout</span><span>|</span><a href="#41789414">prev</a><span>|</span><a href="#41794081">next</a><span>|</span><label class="collapse" for="c-41789864">[-]</label><label class="expand" for="c-41789864">[1 more]</label></div><br/><div class="children"><div class="content">Come to think of it, execute-and-inhibit style as described here is exactly what&#x27;s going on when in continuous deployment you run your same pipeline many times a day with small changes, and gate new development behind feature flags. We&#x27;re familiar with the confidence derived from frequently repeating the whole job.</div><br/></div></div><div id="41794081" class="c"><input type="checkbox" id="c-41794081" checked=""/><div class="controls bullet"><span class="by">ydnaclementine</span><span>|</span><a href="#41789864">prev</a><span>|</span><a href="#41790756">next</a><span>|</span><label class="collapse" for="c-41794081">[-]</label><label class="expand" for="c-41794081">[1 more]</label></div><br/><div class="children"><div class="content">&gt; do always, then inhibit or ignore strategy<p>can anyone expound on this? I&#x27;m not sure what he&#x27;s exactly referring to here</div><br/></div></div><div id="41790738" class="c"><input type="checkbox" id="c-41790738" checked=""/><div class="controls bullet"><span class="by">fabiensanglard</span><span>|</span><a href="#41790756">prev</a><span>|</span><a href="#41785153">next</a><span>|</span><label class="collapse" for="c-41790738">[-]</label><label class="expand" for="c-41790738">[4 more]</label></div><br/><div class="children"><div class="content">How does a program work when its disallow &quot;backward branches&quot;. Same thing with &quot;subroutine calls&quot; how do you structure a program without them?</div><br/><div id="41791157" class="c"><input type="checkbox" id="c-41791157" checked=""/><div class="controls bullet"><span class="by">bdowling</span><span>|</span><a href="#41790738">parent</a><span>|</span><a href="#41790842">next</a><span>|</span><label class="collapse" for="c-41791157">[-]</label><label class="expand" for="c-41791157">[1 more]</label></div><br/><div class="children"><div class="content">You can do a lot with a program that looks like:<p><pre><code>  while(1) {
    if (condition1)
      ...
    if (condition2)
      ...
    &#x2F;&#x2F; etc
  }
</code></pre>
Subroutine calls can be eliminated by inlining everything, using macros to make the code more manageable. Loops can be simulated using macros that expand to multiple copies of the code, one for each step.<p>One advantage is that the program will never get into an unbounded loop because the program counter will always advance towards the end of the main loop.</div><br/></div></div><div id="41790842" class="c"><input type="checkbox" id="c-41790842" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41790738">parent</a><span>|</span><a href="#41791157">prev</a><span>|</span><a href="#41793324">next</a><span>|</span><label class="collapse" for="c-41790842">[-]</label><label class="expand" for="c-41790842">[1 more]</label></div><br/><div class="children"><div class="content">Well, you have one backward branch at the end of the program, and you inline your subroutines.  I&#x27;m pretty sure you&#x27;ve written shaders for ancient GPUs that had similar limitations?  And anything you can do in hardware you can do without subroutine calls, and in hardware the loop starts again on every clock cycle.</div><br/></div></div><div id="41793324" class="c"><input type="checkbox" id="c-41793324" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#41790738">parent</a><span>|</span><a href="#41790842">prev</a><span>|</span><a href="#41785153">next</a><span>|</span><label class="collapse" for="c-41793324">[-]</label><label class="expand" for="c-41793324">[1 more]</label></div><br/><div class="children"><div class="content">It allows one backward branch. Think of it like hand-rolling your OS scheduler for processes&#x2F;threads. You also have to track your &quot;program counter&quot; yourself. As a silly example:<p><pre><code>  typedef enum state {EVEN, ODD} state_t;
  state_t task1 = EVEN;
  state_t task2 = EVEN;
  while (1) {
    switch(task1) {
    case EVEN:
        &#x2F;&#x2F; do even things
        task1 = ODD;
        break;
    case ODD:
        &#x2F;&#x2F; do odd things
        task1 = EVEN;
        break;
    default:
        fprintf(stderr, &quot;WTF?\n&quot;);
        exit(1);
    }
    switch(task2) {
    case EVEN:
        &#x2F;&#x2F; do even things
        task2 = ODD;
        break;
    case ODD:
        &#x2F;&#x2F; do odd things
        task2 = EVEN;
        break;
    default:
        fprintf(stderr, &quot;WTF?\n&quot;);
        exit(1);
    }
  }
</code></pre>
For every &quot;process&quot; you&#x27;ve unrolled like this, you have to place it into its own switch&#x2F;case or call out to a function which has similar logic (when subroutines aren&#x27;t disallowed). If the process is short enough you let it execute all the way through, bigger processes would need to be broken apart like above to avoid consuming an entire cycle&#x27;s time (especially important in real-time systems).</div><br/></div></div></div></div><div id="41785153" class="c"><input type="checkbox" id="c-41785153" checked=""/><div class="controls bullet"><span class="by">rossant</span><span>|</span><a href="#41790738">prev</a><span>|</span><a href="#41787782">next</a><span>|</span><label class="collapse" for="c-41785153">[-]</label><label class="expand" for="c-41785153">[4 more]</label></div><br/><div class="children"><div class="content">(2014)</div><br/><div id="41785215" class="c"><input type="checkbox" id="c-41785215" checked=""/><div class="controls bullet"><span class="by">mindsuck</span><span>|</span><a href="#41785153">parent</a><span>|</span><a href="#41785291">next</a><span>|</span><label class="collapse" for="c-41785215">[-]</label><label class="expand" for="c-41785215">[2 more]</label></div><br/><div class="children"><div class="content">First discussed here back then: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8374345">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8374345</a></div><br/><div id="41790719" class="c"><input type="checkbox" id="c-41790719" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#41785153">root</a><span>|</span><a href="#41785215">parent</a><span>|</span><a href="#41785291">next</a><span>|</span><label class="collapse" for="c-41790719">[-]</label><label class="expand" for="c-41790719">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! Macroexpanded:<p><i>John Carmack on Inlined Code</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39008678">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39008678</a> - Jan 2024 (2 comments)<p><i>John Carmack on Inlined Code (2014)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33679163">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33679163</a> - Nov 2022 (1 comment)<p><i>John Carmack on Inlined Code (2014)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25263488">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25263488</a> - Dec 2020 (169 comments)<p><i>John Carmack on Inlined Code (2014)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=18959636">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=18959636</a> - Jan 2019 (105 comments)<p><i>John Carmack on Inlined Code (2014)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14333115">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14333115</a> - May 2017 (2 comments)<p><i>John Carmack on Inlined Code (2014)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=12120752">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=12120752</a> - July 2016 (199 comments)<p><i>John Carmack on Inlined Code</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8374345">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8374345</a> - Sept 2014 (260 comments)</div><br/></div></div></div></div><div id="41785291" class="c"><input type="checkbox" id="c-41785291" checked=""/><div class="controls bullet"><span class="by">mcosta</span><span>|</span><a href="#41785153">parent</a><span>|</span><a href="#41785215">prev</a><span>|</span><a href="#41787782">next</a><span>|</span><label class="collapse" for="c-41785291">[-]</label><label class="expand" for="c-41785291">[1 more]</label></div><br/><div class="children"><div class="content">2007</div><br/></div></div></div></div><div id="41785550" class="c"><input type="checkbox" id="c-41785550" checked=""/><div class="controls bullet"><span class="by">randomtoast</span><span>|</span><a href="#41787782">prev</a><span>|</span><a href="#41789909">next</a><span>|</span><label class="collapse" for="c-41785550">[-]</label><label class="expand" for="c-41785550">[1 more]</label></div><br/><div class="children"><div class="content">My browser says &quot;The connection to number-none.com is not secure&quot;. Guess it is only a matter of time until HTTPS becomes mandatory.</div><br/></div></div><div id="41789909" class="c"><input type="checkbox" id="c-41789909" checked=""/><div class="controls bullet"><span class="by">adamrezich</span><span>|</span><a href="#41785550">prev</a><span>|</span><a href="#41786514">next</a><span>|</span><label class="collapse" for="c-41789909">[-]</label><label class="expand" for="c-41789909">[1 more]</label></div><br/><div class="children"><div class="content">I find that when initially exploring a problem space, it&#x27;s useful to consider functions as “verbs” to help me think through the solution, and that feels useful in helping me figure out a solution to my problem—I&#x27;ve isolated some_operation() into its own function, and it&#x27;s easy to see at a glance whether or not some_operation() does the specific thing its name claims to do (and if so, how well).<p>But then after things have solidified somewhat, it&#x27;s good practice to go back through your code and determine whether those “verbs” ended up being used more than once. Quite often, something that I thought would be repeated enough to justify being its own function, is actually only invoked in one specific place—so I go back and inline these functions as needed.<p>The less my code looks like a byzantine tangle of function invocations, and the more my code reads like a straightforward list of statements to execute in order, the better it makes me feel, because I know that I&#x27;m not unnecessarily hiding complexity, and I can get a better, more concrete feel for what my program&#x27;s execution looks like.</div><br/></div></div><div id="41785810" class="c"><input type="checkbox" id="c-41785810" checked=""/><div class="controls bullet"><span class="by">Ono-Sendai</span><span>|</span><a href="#41786514">prev</a><span>|</span><a href="#41785173">next</a><span>|</span><label class="collapse" for="c-41785810">[-]</label><label class="expand" for="c-41785810">[12 more]</label></div><br/><div class="children"><div class="content">There is actually a major problem with long functions - they take a long time to compile, due to superlinear complexity in computation time as a function of function length.  In other words breaking up a large function into smaller function can greatly reduce compile times.</div><br/><div id="41785819" class="c"><input type="checkbox" id="c-41785819" checked=""/><div class="controls bullet"><span class="by">badmintonbaseba</span><span>|</span><a href="#41785810">parent</a><span>|</span><a href="#41786680">next</a><span>|</span><label class="collapse" for="c-41785819">[-]</label><label class="expand" for="c-41785819">[8 more]</label></div><br/><div class="children"><div class="content">That honestly feels like a minor problem, and not something to optimize for. Also an aggressively inlining compiler will experience exactly the same problem. AFAIK at least clang always inlines a static (as in internal linkage) function if it&#x27;s used only once in the translation unit, no matter how large it is.</div><br/><div id="41786071" class="c"><input type="checkbox" id="c-41786071" checked=""/><div class="controls bullet"><span class="by">Ono-Sendai</span><span>|</span><a href="#41785810">root</a><span>|</span><a href="#41785819">parent</a><span>|</span><a href="#41786680">next</a><span>|</span><label class="collapse" for="c-41786071">[-]</label><label class="expand" for="c-41786071">[7 more]</label></div><br/><div class="children"><div class="content">Visual studio doesn&#x27;t do that inlining.  And it is a significant problem, I have had to refactor my code into multiple functions because of it.</div><br/><div id="41786687" class="c"><input type="checkbox" id="c-41786687" checked=""/><div class="controls bullet"><span class="by">badmintonbaseba</span><span>|</span><a href="#41785810">root</a><span>|</span><a href="#41786071">parent</a><span>|</span><a href="#41786680">next</a><span>|</span><label class="collapse" for="c-41786687">[-]</label><label class="expand" for="c-41786687">[6 more]</label></div><br/><div class="children"><div class="content">It might be a significant problem, but not in the code, but the compiler. Fair enough, you are working around a compiler issue.</div><br/><div id="41788680" class="c"><input type="checkbox" id="c-41788680" checked=""/><div class="controls bullet"><span class="by">Ono-Sendai</span><span>|</span><a href="#41785810">root</a><span>|</span><a href="#41786687">parent</a><span>|</span><a href="#41786680">next</a><span>|</span><label class="collapse" for="c-41788680">[-]</label><label class="expand" for="c-41788680">[5 more]</label></div><br/><div class="children"><div class="content">If you consider any superlinear complexity a &#x27;compiler issue&#x27; I guess.</div><br/><div id="41789041" class="c"><input type="checkbox" id="c-41789041" checked=""/><div class="controls bullet"><span class="by">badmintonbaseba</span><span>|</span><a href="#41785810">root</a><span>|</span><a href="#41788680">parent</a><span>|</span><a href="#41786680">next</a><span>|</span><label class="collapse" for="c-41789041">[-]</label><label class="expand" for="c-41789041">[4 more]</label></div><br/><div class="children"><div class="content">It absolutely is, if it makes compile times unreasonable for reasonable code. Compilers have to make trade-offs like this all the time, they can&#x27;t use overly excessive optimizations.</div><br/><div id="41789138" class="c"><input type="checkbox" id="c-41789138" checked=""/><div class="controls bullet"><span class="by">Ono-Sendai</span><span>|</span><a href="#41785810">root</a><span>|</span><a href="#41789041">parent</a><span>|</span><a href="#41786680">next</a><span>|</span><label class="collapse" for="c-41789138">[-]</label><label class="expand" for="c-41789138">[3 more]</label></div><br/><div class="children"><div class="content">I dunno.  O(n^2) is for sure a bug.  But O(nlogn) I think is reasonable.</div><br/><div id="41789496" class="c"><input type="checkbox" id="c-41789496" checked=""/><div class="controls bullet"><span class="by">badmintonbaseba</span><span>|</span><a href="#41785810">root</a><span>|</span><a href="#41789138">parent</a><span>|</span><a href="#41786680">next</a><span>|</span><label class="collapse" for="c-41789496">[-]</label><label class="expand" for="c-41789496">[2 more]</label></div><br/><div class="children"><div class="content">O(nlogn) is probably reasonable. Why break up a long function then if you are experiencing O(nlogn) scaling of compile time on function size?</div><br/><div id="41789577" class="c"><input type="checkbox" id="c-41789577" checked=""/><div class="controls bullet"><span class="by">Ono-Sendai</span><span>|</span><a href="#41785810">root</a><span>|</span><a href="#41789496">parent</a><span>|</span><a href="#41786680">next</a><span>|</span><label class="collapse" for="c-41789577">[-]</label><label class="expand" for="c-41789577">[1 more]</label></div><br/><div class="children"><div class="content">Because it can still result in compile times I find excessive.
For example breaking up a function that takes 5 seconds to compile into a bunch of functions that take 1 to 2 seconds in total.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41786680" class="c"><input type="checkbox" id="c-41786680" checked=""/><div class="controls bullet"><span class="by">tightbookkeeper</span><span>|</span><a href="#41785810">parent</a><span>|</span><a href="#41785819">prev</a><span>|</span><a href="#41785173">next</a><span>|</span><label class="collapse" for="c-41786680">[-]</label><label class="expand" for="c-41786680">[3 more]</label></div><br/><div class="children"><div class="content">If you are willing to make code worse to micro optimize compile times (not even sure this is true) then you should not use any modern language with complex type checking (rust, swift, C#, etc).</div><br/><div id="41788689" class="c"><input type="checkbox" id="c-41788689" checked=""/><div class="controls bullet"><span class="by">Ono-Sendai</span><span>|</span><a href="#41785810">root</a><span>|</span><a href="#41786680">parent</a><span>|</span><a href="#41785173">next</a><span>|</span><label class="collapse" for="c-41788689">[-]</label><label class="expand" for="c-41788689">[2 more]</label></div><br/><div class="children"><div class="content">Writing a medium to large program in C++, you really need to fight long compile times or they can get out of hand.  That affects the way you write code quite a lot, or it should at least.   I&#x27;ve heard Rust and Swift also suffer from long compile times.</div><br/><div id="41790463" class="c"><input type="checkbox" id="c-41790463" checked=""/><div class="controls bullet"><span class="by">tightbookkeeper</span><span>|</span><a href="#41785810">root</a><span>|</span><a href="#41788689">parent</a><span>|</span><a href="#41785173">next</a><span>|</span><label class="collapse" for="c-41790463">[-]</label><label class="expand" for="c-41790463">[1 more]</label></div><br/><div class="children"><div class="content">Agreed.<p>But For C++ template combinatorics are going to dominate any slow down due to function length.</div><br/></div></div></div></div></div></div></div></div><div id="41785173" class="c"><input type="checkbox" id="c-41785173" checked=""/><div class="controls bullet"><span class="by">gdiamos</span><span>|</span><a href="#41785810">prev</a><span>|</span><label class="collapse" for="c-41785173">[-]</label><label class="expand" for="c-41785173">[9 more]</label></div><br/><div class="children"><div class="content">How much of this is specific to control loops that execute at 60hz?</div><br/><div id="41785253" class="c"><input type="checkbox" id="c-41785253" checked=""/><div class="controls bullet"><span class="by">lloeki</span><span>|</span><a href="#41785173">parent</a><span>|</span><a href="#41785316">next</a><span>|</span><label class="collapse" for="c-41785253">[-]</label><label class="expand" for="c-41785253">[5 more]</label></div><br/><div class="children"><div class="content">None.<p>&gt; The real enemy addressed by inlining is unexpected dependency and mutation of state, which functional programming solves more directly and completely. However, if you are going to make a lot of state changes, having them all happen inline does have advantages; you should be made constantly aware of the full horror of what you are doing. When it gets to be too much to take, figure out how to factor blocks out into pure functions (and don.t let them slide back into impurity!).<p>Some years ago at job foo I wrote a Ruby library that was doing some stuff. Time was of the essence, I was a one-man team, and the trickiness of it required a clear understanding of the details, so I wrote a single ~1000 LOC file comprising of the entirety of the namespace module of that library, with but a couple or three functions.<p>Then a new hire joined my one-man team. I said: apologies for this unholy mess, it&#x27;s overdue for a refactoring, with a bunch of proper classes with small methods and split in a few files accordingly. They said: not at all, the code was exceptionally clear; I could sit and understand every bit of it down to the grittier critical details in under an hour, and having seen it written this way it is obvious to me that these details of interactions would not have been abstracted away, but obscured away.</div><br/><div id="41785986" class="c"><input type="checkbox" id="c-41785986" checked=""/><div class="controls bullet"><span class="by">otikik</span><span>|</span><a href="#41785173">root</a><span>|</span><a href="#41785253">parent</a><span>|</span><a href="#41785539">next</a><span>|</span><label class="collapse" for="c-41785986">[-]</label><label class="expand" for="c-41785986">[2 more]</label></div><br/><div class="children"><div class="content">I have worked with many developers and I have seen them follow two distinct paths when encountering complex code.<p>There&#x27;s one camp that wants to use abstractions and names, and there&#x27;s another (in my experience, smaller) camp which prefers to have as few abstractions as possible, and &quot;every gritty detail visible&quot;.<p>I think both strategies have advantages and disadvantages. The group that likes abstractions can &quot;ignore parts of the code&quot; quickly, which potentially makes them &quot;search&quot; faster. If there&#x27;s a bug that needs fixing, or a new feature that needs to be added, they will reach the part of the code that will need modifications faster.<p>The detail-oriented people can take a bit longer to identify the code that needs modification, but they also tend to be able to make those modifications faster.  They also tend to be be great &quot;spelunkers&quot;. They seem to have a &quot;bigger cache&quot;, so to speak. But it is not infinite. They will eventually not be able to hold all the complexity in their heads, just like the first group. It will just take a bit longer.<p>I am firmly on the first group and that is how I write my code. I have been fortunate enough to encounter enough people from the other group to know not to diss their code immediately, and to appreciate it for its merits. When working in a team with both kinds of personalities one has to make compromises (&quot;please remove all of these 1-line functions, Jonathan will hate them&quot;, and &quot;could you split this 3k lines function into 2 or 3 smaller ones, for easier review?&quot;).</div><br/><div id="41793423" class="c"><input type="checkbox" id="c-41793423" checked=""/><div class="controls bullet"><span class="by">whstl</span><span>|</span><a href="#41785173">root</a><span>|</span><a href="#41785986">parent</a><span>|</span><a href="#41785539">next</a><span>|</span><label class="collapse" for="c-41793423">[-]</label><label class="expand" for="c-41793423">[1 more]</label></div><br/><div class="children"><div class="content">Some might consider me part of the &quot;second group&quot;, but I&#x27;m perfectly fine with abstractions and I create them all the time.<p>I do however have a problem with indirections that don&#x27;t really abstract anything and only exist for aesthetical reasons.<p>Not every function&#x2F;method is an &quot;abstraction&quot;. Having too many one-line methods is as bad as pretending that functions with 2k&#x2F;3k lines are appropriate in all cases.</div><br/></div></div></div></div><div id="41785539" class="c"><input type="checkbox" id="c-41785539" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#41785173">root</a><span>|</span><a href="#41785253">parent</a><span>|</span><a href="#41785986">prev</a><span>|</span><a href="#41785346">next</a><span>|</span><label class="collapse" for="c-41785539">[-]</label><label class="expand" for="c-41785539">[1 more]</label></div><br/><div class="children"><div class="content">Thing is, a lot of developers see long code and think &quot;this is a Bad Thing&quot; because of dogma, but in practice, a lot of developers never actually wrote anything nontrivial like that.</div><br/></div></div><div id="41785346" class="c"><input type="checkbox" id="c-41785346" checked=""/><div class="controls bullet"><span class="by">yoz</span><span>|</span><a href="#41785173">root</a><span>|</span><a href="#41785253">parent</a><span>|</span><a href="#41785539">prev</a><span>|</span><a href="#41785316">next</a><span>|</span><label class="collapse" for="c-41785346">[-]</label><label class="expand" for="c-41785346">[1 more]</label></div><br/><div class="children"><div class="content">Your final ten words of the comment are a perfectly concise explanation of the problem; thank you! And it drives home something I often forget about <i>why</i> code units should do Only One Thing.</div><br/></div></div></div></div><div id="41785316" class="c"><input type="checkbox" id="c-41785316" checked=""/><div class="controls bullet"><span class="by">cryptonym</span><span>|</span><a href="#41785173">parent</a><span>|</span><a href="#41785253">prev</a><span>|</span><a href="#41785397">next</a><span>|</span><label class="collapse" for="c-41785316">[-]</label><label class="expand" for="c-41785316">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Minimize control flow complexity and “area under ifs”, favoring consistent execution paths and times over “optimally” avoiding unnecessary work.<p>If your control loop must always run under 16ms, you better make sure the worst case is 16ms rather than trying to optimise best or mid case. Avoid ifs that skips processing, that&#x27;s good for demo but doesn&#x27;t help reaching prod quality goals. Sometimes it doesn&#x27;t bring the benefits you think, sometimes it hides poorly optimised paths, sometimes it creates subtle bugs. Of course always use your own discernment...<p>That would be very different in a typical cloud app where the goal is to keep CPU, memory and network usage as low as possible, not much caring about having a constant response time on each REST endpoint.</div><br/></div></div><div id="41785397" class="c"><input type="checkbox" id="c-41785397" checked=""/><div class="controls bullet"><span class="by">Netch</span><span>|</span><a href="#41785173">parent</a><span>|</span><a href="#41785316">prev</a><span>|</span><a href="#41786091">next</a><span>|</span><label class="collapse" for="c-41785397">[-]</label><label class="expand" for="c-41785397">[1 more]</label></div><br/><div class="children"><div class="content">All the code which is not in hot path may conform to any rules, and typically is designed according to something like SOLID, to make understanding and maintenance as simple as possible (and suitable to any average coder).<p>All the code which performance, memory cost, etc. is critical, should be adjusted to fit into required confine even if it will violate all other tenets. This often results in combination of opposite approaches - anything that does well.<p>Finally, one just profiles the code and fixes all most spending paths. This is what now any average programmer can do. What it canʼt do - and what Carmack has been doing for decades - is to predict such places and fixes them proactively at architectural level; and to find tricky solutions that average joe-the-programmer hasnʼt heard ever.</div><br/></div></div><div id="41786091" class="c"><input type="checkbox" id="c-41786091" checked=""/><div class="controls bullet"><span class="by">cjfd</span><span>|</span><a href="#41785173">parent</a><span>|</span><a href="#41785397">prev</a><span>|</span><label class="collapse" for="c-41786091">[-]</label><label class="expand" for="c-41786091">[1 more]</label></div><br/><div class="children"><div class="content">Mostly, all of it. People who are not writing that kind of loop probably should not do any of this. Optimize for code clarity, which may involve either inlining or extracting depending on the situation.</div><br/></div></div></div></div></div></div></div></div></div></body></html>