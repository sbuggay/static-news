<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1728464455038" as="style"/><link rel="stylesheet" href="styles.css?v=1728464455038"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://number-none.com/blow/blog/programming/2014/09/26/carmack-on-inlined-code.html">John Carmack on Inlined Code</a> <span class="domain">(<a href="http://number-none.com">number-none.com</a>)</span></div><div class="subtext"><span>bpierre</span> | <span>68 comments</span></div><br/><div><div id="41785113" class="c"><input type="checkbox" id="c-41785113" checked=""/><div class="controls bullet"><span class="by">mihaic</span><span>|</span><a href="#41785518">next</a><span>|</span><label class="collapse" for="c-41785113">[-]</label><label class="expand" for="c-41785113">[22 more]</label></div><br/><div class="children"><div class="content">When I first heard the maxim that an intelligent person should be able to hold two opposing thoughts at the same time, I was naive to think it meant weighing them for pros and cons. Over time I realized that it means balancing contradictory actions, and the main purpose of experience is knowing when to apply each.<p>Concretely related to the topic, I&#x27;ve often found myself inlining short pieces of one-time code that made functions more explicit, while at other times I&#x27;ll spend days just breaking up thousand line functions into simpler blocks just to be able to follow what&#x27;s going on. In both cases I was creating inconsistencies that younger developers nitpick -- I know I did.<p>My goal in most cases now is to optimize code for the limits of the human mind (my own in low-effort mode) and like to be able to treat rules as guidelines. The trouble is how can you scale this to millions of developers, and what are those limits of the human mind when more and more AI-generated code will be used?</div><br/><div id="41785256" class="c"><input type="checkbox" id="c-41785256" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#41785113">parent</a><span>|</span><a href="#41785321">next</a><span>|</span><label class="collapse" for="c-41785256">[-]</label><label class="expand" for="c-41785256">[16 more]</label></div><br/><div class="children"><div class="content">There’s also the effect that a certain code structure that’s clearer for a senior dev might be less clear for a junior dev and vice versa.</div><br/><div id="41785314" class="c"><input type="checkbox" id="c-41785314" checked=""/><div class="controls bullet"><span class="by">rob74</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785256">parent</a><span>|</span><a href="#41785331">next</a><span>|</span><label class="collapse" for="c-41785314">[-]</label><label class="expand" for="c-41785314">[13 more]</label></div><br/><div class="children"><div class="content">Or rather, senior devs have learned to care more for having clear code rather than (over-)applying principles like DRY, separation of concerns etc., while juniors haven&#x27;t (yet)...</div><br/><div id="41785472" class="c"><input type="checkbox" id="c-41785472" checked=""/><div class="controls bullet"><span class="by">JauntyHatAngle</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785314">parent</a><span>|</span><a href="#41785348">next</a><span>|</span><label class="collapse" for="c-41785472">[-]</label><label class="expand" for="c-41785472">[5 more]</label></div><br/><div class="children"><div class="content">I know it&#x27;s overused, but I do find myself saying YAGNI to my junior devs more and more often, as I find they go off on a quest for the perfect abstraction and spend days yak shaving as a result.</div><br/><div id="41785592" class="c"><input type="checkbox" id="c-41785592" checked=""/><div class="controls bullet"><span class="by">silisili</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785472">parent</a><span>|</span><a href="#41785348">next</a><span>|</span><label class="collapse" for="c-41785592">[-]</label><label class="expand" for="c-41785592">[4 more]</label></div><br/><div class="children"><div class="content">Yes!  I work with many folks objectively way younger and smarter than me.  The two bad habits I try to break them of are abstractions and what ifs.<p>They spend so much time chasing perfection that it negatively affects their output.  Multiple times a day I find myself saying &#x27;is that a realistic problem for our use case?&#x27;<p>I don&#x27;t blame them, it&#x27;s admirable.  But I feel like we need to teach YAGNI.  Anymore I feel like a saboteur, polluting our codebase with suboptimal solutions.<p>It&#x27;s weird because my own career was different.  I was a code spammer who learned to wrangle it into something more thoughtful.  But I&#x27;m dealing with overly thoughtful folks I&#x27;m trying to get to spam more code out, so to speak.</div><br/><div id="41785626" class="c"><input type="checkbox" id="c-41785626" checked=""/><div class="controls bullet"><span class="by">reshlo</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785592">parent</a><span>|</span><a href="#41785348">next</a><span>|</span><label class="collapse" for="c-41785626">[-]</label><label class="expand" for="c-41785626">[3 more]</label></div><br/><div class="children"><div class="content">I’ve had the opposite experience before. As a young developer, there were a number of times where I advocated for doing something “the right way” instead of “the good enough way”, was overruled by seniors, and then later I had to fix a bug by doing it “the right way” like I’d wanted to in the first place.<p>Doing it the right way from the start would have saved so much time.</div><br/><div id="41785845" class="c"><input type="checkbox" id="c-41785845" checked=""/><div class="controls bullet"><span class="by">wild_egg</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785626">parent</a><span>|</span><a href="#41785832">next</a><span>|</span><label class="collapse" for="c-41785845">[-]</label><label class="expand" for="c-41785845">[1 more]</label></div><br/><div class="children"><div class="content">The important bit is figuring out if those times where &quot;the right way&quot; would have helped outweigh the time saved by defaulting to &quot;good enough&quot;.<p>There are always exceptions, but there&#x27;s typically order of magnitude differences between globally doing &quot;the right thing&quot; vs &quot;good enough&quot; and going back to fix the few cases where &quot;good enough&quot; wasn&#x27;t actually good enough.</div><br/></div></div><div id="41785832" class="c"><input type="checkbox" id="c-41785832" checked=""/><div class="controls bullet"><span class="by">spinningslate</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785626">parent</a><span>|</span><a href="#41785845">prev</a><span>|</span><a href="#41785348">next</a><span>|</span><label class="collapse" for="c-41785832">[-]</label><label class="expand" for="c-41785832">[1 more]</label></div><br/><div class="children"><div class="content">This thread is a great illustration of the reality that there are no hard rules, judgement matters, and we don&#x27;t always get things right.<p>I&#x27;m pretty long-in-the-tooth and feel like I&#x27;ve gone through 3 stages in my career:<p>1. Junior dev where everything was new, and did &quot;the simplest thing that could possibly work&quot; because I wasn&#x27;t capable of anything else (I was barely capable of the simple thing).<p>2. Mid-experience, where I&#x27;d learned the basics and thought I knew everything.  This is probably where I wrote my worst code: over-abstracted, using every cool language&#x2F;library feature I knew, justified on the basis of &quot;yeah, but it&#x27;s reusable and will solve lots of stuff in future even though I don&#x27;t know what it is yet&quot;.<p>3. Older and hopefully a bit wiser.  A visceral rejection of speculative reuse as a justification for solving anything beyond the current problem.  Much more focus on really understanding the underlying problem that actually needs solved: less interest in the latest and greatest technology to do that with, and a much larger appreciation of &quot;boring technology&quot; (aka stuff that&#x27;s proven and reliable).<p>The focus on really understanding the problem tends to create more stable abstractions which do get reused.  But that&#x27;s emergent, not speculative ahead-of-time.  There are judgements all the way through that: sometimes deciding to invest in more foundational code, but by default sticking to YAGNI.  Most of all is seeing my value not as weilding techno armageddon, but solving problems for users and customers.<p>I still have a deep fascination with exploring and understanding new tech developments and techniques.  I just have a much higher bar to adopting them for production use.</div><br/></div></div></div></div></div></div></div></div><div id="41785348" class="c"><input type="checkbox" id="c-41785348" checked=""/><div class="controls bullet"><span class="by">stahorn</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785314">parent</a><span>|</span><a href="#41785472">prev</a><span>|</span><a href="#41785443">next</a><span>|</span><label class="collapse" for="c-41785348">[-]</label><label class="expand" for="c-41785348">[1 more]</label></div><br/><div class="children"><div class="content">When you thought you made &quot;smart&quot; solutions and many years later you have to go in and fix bugs in it, is usually when you learn this.</div><br/></div></div><div id="41785443" class="c"><input type="checkbox" id="c-41785443" checked=""/><div class="controls bullet"><span class="by">orwin</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785314">parent</a><span>|</span><a href="#41785348">prev</a><span>|</span><a href="#41785331">next</a><span>|</span><label class="collapse" for="c-41785443">[-]</label><label class="expand" for="c-41785443">[6 more]</label></div><br/><div class="children"><div class="content">My &#x27;principle&#x27; for DRY is : twice is fine, trice is worth an abstraction (if you think it has a small to moderate chance to happen again). I used to apply it no matter what, soi guess it&#x27;s progress...</div><br/><div id="41785551" class="c"><input type="checkbox" id="c-41785551" checked=""/><div class="controls bullet"><span class="by">whstl</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785443">parent</a><span>|</span><a href="#41785639">next</a><span>|</span><label class="collapse" for="c-41785551">[-]</label><label class="expand" for="c-41785551">[4 more]</label></div><br/><div class="children"><div class="content">I really dislike how this principle ends up being used in practice.<p>A good <i>abstraction</i> that makes actual sense is perfectly good even when it&#x27;s used only once.<p>On the other hand, the idea of deduplicating code by creating an <i>indirection</i> is often not worth it for long-term maintenance, and is precisely the kind of thing that will cause maintenance headaches and anti-patterns.<p>For example: don&#x27;t mix file system or low-level database access with your business code, just create a proper abstraction. But deduplicating very small fragments of same-abstraction-level can have detrimental effects in the long run.</div><br/><div id="41785659" class="c"><input type="checkbox" id="c-41785659" checked=""/><div class="controls bullet"><span class="by">ahoka</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785551">parent</a><span>|</span><a href="#41785669">next</a><span>|</span><label class="collapse" for="c-41785659">[-]</label><label class="expand" for="c-41785659">[1 more]</label></div><br/><div class="children"><div class="content">I think the main problem with these abstractions that they are merely indirections in most cases, limiting the usefulness to several use cases (sometimes to things that never going to be needed).<p>To quote Dijsktra: &quot;The purpose of abstraction is not to be vague, but to create a new semantic level in which one can be absolutely precise.&quot;</div><br/></div></div><div id="41785669" class="c"><input type="checkbox" id="c-41785669" checked=""/><div class="controls bullet"><span class="by">n0w</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785551">parent</a><span>|</span><a href="#41785659">prev</a><span>|</span><a href="#41785639">next</a><span>|</span><label class="collapse" for="c-41785669">[-]</label><label class="expand" for="c-41785669">[2 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t remember where I picked it up from, but nowadays I try to be mindful of when things are &quot;accidentally&quot; repeated and when they are &quot;necessarily&quot; repeated. Abstractions that encapsulate the latter tend to be a good idea regardless of how many times you&#x27;ve repeated a piece of code in practice.</div><br/><div id="41785779" class="c"><input type="checkbox" id="c-41785779" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785669">parent</a><span>|</span><a href="#41785639">next</a><span>|</span><label class="collapse" for="c-41785779">[-]</label><label class="expand" for="c-41785779">[1 more]</label></div><br/><div class="children"><div class="content">Exactly, but distinguishing the two that requires an excellent understanding of the problem space, and can’t at all be figured out in the solution space (i.e., by only looking at the code). But less experienced people only look at the code. In theory, a thousand repetitions would be fine if each one encodes an independent bit of information in the problem space.</div><br/></div></div></div></div></div></div><div id="41785639" class="c"><input type="checkbox" id="c-41785639" checked=""/><div class="controls bullet"><span class="by">ikari_pl</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785443">parent</a><span>|</span><a href="#41785551">prev</a><span>|</span><a href="#41785331">next</a><span>|</span><label class="collapse" for="c-41785639">[-]</label><label class="expand" for="c-41785639">[1 more]</label></div><br/><div class="children"><div class="content">twice is fine... except some senior devs apply it to the entire file (today I found the second entire file&#x2F;class copied and pasted over to another place... the newer copy is not used either)</div><br/></div></div></div></div></div></div><div id="41785331" class="c"><input type="checkbox" id="c-41785331" checked=""/><div class="controls bullet"><span class="by">kolinko</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785256">parent</a><span>|</span><a href="#41785314">prev</a><span>|</span><a href="#41785321">next</a><span>|</span><label class="collapse" for="c-41785331">[-]</label><label class="expand" for="c-41785331">[2 more]</label></div><br/><div class="children"><div class="content">I bumped into that issue, and it caused a lot of friction between me and 3 young developers I had to manage.<p>Ideas on how to overcome that?</div><br/><div id="41785563" class="c"><input type="checkbox" id="c-41785563" checked=""/><div class="controls bullet"><span class="by">whstl</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785331">parent</a><span>|</span><a href="#41785321">next</a><span>|</span><label class="collapse" for="c-41785563">[-]</label><label class="expand" for="c-41785563">[1 more]</label></div><br/><div class="children"><div class="content">Teaching.<p>I had this problem with an overzealous junior developer and the solution was showing some different perspectives. For example John Ousterhout&#x27;s A Philosophy of Software Design.</div><br/></div></div></div></div></div></div><div id="41785321" class="c"><input type="checkbox" id="c-41785321" checked=""/><div class="controls bullet"><span class="by">skummetmaelk</span><span>|</span><a href="#41785113">parent</a><span>|</span><a href="#41785256">prev</a><span>|</span><a href="#41785620">next</a><span>|</span><label class="collapse" for="c-41785321">[-]</label><label class="expand" for="c-41785321">[2 more]</label></div><br/><div class="children"><div class="content">That doesn&#x27;t seem like holding two opposing thoughts. Why is balancing contradictory actions to optimize an outcome different to weighing pros and cons?</div><br/><div id="41785386" class="c"><input type="checkbox" id="c-41785386" checked=""/><div class="controls bullet"><span class="by">mihaic</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785321">parent</a><span>|</span><a href="#41785620">next</a><span>|</span><label class="collapse" for="c-41785386">[-]</label><label class="expand" for="c-41785386">[1 more]</label></div><br/><div class="children"><div class="content">What I meant to say was that when people encounter contradictory statements like &quot;always inline one-time functions&quot; and &quot;breakdown functions into easy to understand blocks&quot;, they try to only pick one single rule, even if they consider the pros and cons of each rule.<p>After a while they consider both rules as useful, and will move to a more granular case-by-base analysis. Some people get stuck at rule-based thinking though, and they&#x27;ll even accuse you of being inconsistent if you try to do case-by-case analysis.</div><br/></div></div></div></div><div id="41785620" class="c"><input type="checkbox" id="c-41785620" checked=""/><div class="controls bullet"><span class="by">leoh</span><span>|</span><a href="#41785113">parent</a><span>|</span><a href="#41785321">prev</a><span>|</span><a href="#41785292">next</a><span>|</span><label class="collapse" for="c-41785620">[-]</label><label class="expand" for="c-41785620">[2 more]</label></div><br/><div class="children"><div class="content">You are probably reaching for Hegel’s concept of dialectical reconciliation</div><br/><div id="41785846" class="c"><input type="checkbox" id="c-41785846" checked=""/><div class="controls bullet"><span class="by">mihaic</span><span>|</span><a href="#41785113">root</a><span>|</span><a href="#41785620">parent</a><span>|</span><a href="#41785292">next</a><span>|</span><label class="collapse" for="c-41785846">[-]</label><label class="expand" for="c-41785846">[1 more]</label></div><br/><div class="children"><div class="content">Not sure, didn&#x27;t Hegel say that there should be a synthesis step at some point? My view is that there should never be a synthesis when using these principles as tools, as both conflicting principles need to always maintain opposites.<p>So, more like Heraclitus&#x27;s union of opposites maybe if you really want to label it?</div><br/></div></div></div></div><div id="41785292" class="c"><input type="checkbox" id="c-41785292" checked=""/><div class="controls bullet"><span class="by">mjburgess</span><span>|</span><a href="#41785113">parent</a><span>|</span><a href="#41785620">prev</a><span>|</span><a href="#41785518">next</a><span>|</span><label class="collapse" for="c-41785292">[-]</label><label class="expand" for="c-41785292">[1 more]</label></div><br/><div class="children"><div class="content">To a certain sort of person, conversation is a game of arriving at these antithesis statements:<p><pre><code>   * Inlining code is the best form of breaking up code. 
   * Love is evil.
   * Rightwing populism is a return to leftwing politics. 
   * etc.

</code></pre>
The purpose is to induce aporia (puzzlement), and hence make it possible to evaluate apparent contradictions. However, a lot of people resent feeling uncertain, and so, people who speak this way are often disliked.</div><br/></div></div></div></div><div id="41785518" class="c"><input type="checkbox" id="c-41785518" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41785113">prev</a><span>|</span><a href="#41785847">next</a><span>|</span><label class="collapse" for="c-41785518">[-]</label><label class="expand" for="c-41785518">[3 more]</label></div><br/><div class="children"><div class="content">His overall solution highlighted in the intro is that he&#x27;s moved on from inlining and now does pure functional programming. Inlining is only relevant for him during IO or state changes which he does as minimally as possible and segregates this from his core logic.<p>Pure functional programming is the bigger insight here that most programmers will just never understand why there&#x27;s a benefit there. In fact most programmers don&#x27;t even completely understand what FP is. To most people FP is just a bunch of functional patterns like map, reduce, filter, etc. They never grasp the true nature of &quot;purity&quot; in functional programming.<p>You see this lack of insight in this thread. Most responders literally ignore the fact that Carmack called his email completely outdated and that he mostly does pure FP now.</div><br/><div id="41785780" class="c"><input type="checkbox" id="c-41785780" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#41785518">parent</a><span>|</span><a href="#41785545">next</a><span>|</span><label class="collapse" for="c-41785780">[-]</label><label class="expand" for="c-41785780">[1 more]</label></div><br/><div class="children"><div class="content">Some grasp it but see its trade-off contract, which is demanding.</div><br/></div></div></div></div><div id="41785847" class="c"><input type="checkbox" id="c-41785847" checked=""/><div class="controls bullet"><span class="by">nuancebydefault</span><span>|</span><a href="#41785518">prev</a><span>|</span><a href="#41785121">next</a><span>|</span><label class="collapse" for="c-41785847">[-]</label><label class="expand" for="c-41785847">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The function that is least likely to cause a problem is one that doesn’t exist, which is the benefit of inlining it.<p>I think that summarizes the case pro inlining.</div><br/></div></div><div id="41785121" class="c"><input type="checkbox" id="c-41785121" checked=""/><div class="controls bullet"><span class="by">gorgoiler</span><span>|</span><a href="#41785847">prev</a><span>|</span><a href="#41785763">next</a><span>|</span><label class="collapse" for="c-41785121">[-]</label><label class="expand" for="c-41785121">[16 more]</label></div><br/><div class="children"><div class="content">&gt; Inlining functions also has the benefit of not making it possible to call the function from other places.<p>I’ve really gone to town with this in Python.<p><pre><code>  def parse_news_email(…):
    def parse_link(…):
      …

    def parse_subjet(…):
      …

    …
</code></pre>
If you are careful, you can rely on the outer function’s variables being available inside the inner functions as well.  Something like a logger or a db connection can be passed in once and then used without having to pass it as an argument all the time:<p><pre><code>  # sad
  def f1(x, db, logger): …
  def f2(x, db, logger): …
  def f3(x, db, logger): …
  def g(xs, db, logger):
    for x0 in xs:
      x1 = f1(x0, db, logger)
      x2 = f2(x1, db, logger)
      x3 = f3(x2, db, logger)
      yikes x3


  # happy
  def g(xs, db, logger):
    def f1(x): …
    def f2(x): …
    def f3(x): …
    for x in xs:
      yield f3(f2(f1(x)))
</code></pre>
Carmack commented his inline functions as if they were actual functions.  Making actual functions enforces this :)<p>Classes and “constants” can also quite happily live inside a function but those are a bit more jarring to see, and classes usually need to be visible so they can be referred to by the type annotations.</div><br/><div id="41785827" class="c"><input type="checkbox" id="c-41785827" checked=""/><div class="controls bullet"><span class="by">grumbel</span><span>|</span><a href="#41785121">parent</a><span>|</span><a href="#41785789">next</a><span>|</span><label class="collapse" for="c-41785827">[-]</label><label class="expand" for="c-41785827">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not an improvement, as it screws up the code flow. The point of inline blocks is that you can read the code the same way as it is executed. No surprised that code might be called twice or that a function call could be missed. Adding real functions causes exactly the indirection that one wanted to avoid in the first place. If the block has no name you know that it will only be executed right where it is written.</div><br/></div></div><div id="41785789" class="c"><input type="checkbox" id="c-41785789" checked=""/><div class="controls bullet"><span class="by">wraptile</span><span>|</span><a href="#41785121">parent</a><span>|</span><a href="#41785827">prev</a><span>|</span><a href="#41785185">next</a><span>|</span><label class="collapse" for="c-41785789">[-]</label><label class="expand" for="c-41785789">[1 more]</label></div><br/><div class="children"><div class="content">The latter pattern is very popular in Python web scraping and data parsing niches as the code is quite verbose and specific and I&#x27;m very happy with this approach. Easy to read and debug and the maintenance is naturally organized.</div><br/></div></div><div id="41785185" class="c"><input type="checkbox" id="c-41785185" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41785121">parent</a><span>|</span><a href="#41785789">prev</a><span>|</span><a href="#41785311">next</a><span>|</span><label class="collapse" for="c-41785185">[-]</label><label class="expand" for="c-41785185">[1 more]</label></div><br/><div class="children"><div class="content">Funny enough, the equivalent of your Python example is how Haskell &#x27;fakes&#x27; all functions with more than one argument (at least by default).<p>Imperative blocks of code in Haskell (do-notation) also work like this.</div><br/></div></div><div id="41785311" class="c"><input type="checkbox" id="c-41785311" checked=""/><div class="controls bullet"><span class="by">InDubioProRubio</span><span>|</span><a href="#41785121">parent</a><span>|</span><a href="#41785185">prev</a><span>|</span><a href="#41785355">next</a><span>|</span><label class="collapse" for="c-41785311">[-]</label><label class="expand" for="c-41785311">[1 more]</label></div><br/><div class="children"><div class="content">So inlining is the private of functions without a object. Pop it all to stack, add arguments, set functionpointer to instructionstart of inline code, challenge accepted, lets go to..</div><br/></div></div><div id="41785355" class="c"><input type="checkbox" id="c-41785355" checked=""/><div class="controls bullet"><span class="by">toenail</span><span>|</span><a href="#41785121">parent</a><span>|</span><a href="#41785311">prev</a><span>|</span><a href="#41785423">next</a><span>|</span><label class="collapse" for="c-41785355">[-]</label><label class="expand" for="c-41785355">[8 more]</label></div><br/><div class="children"><div class="content">&gt; Inlining functions also has the benefit of not making it possible to call the function from other places.<p>Congrats, you&#x27;ve got an untestable unit.</div><br/><div id="41785851" class="c"><input type="checkbox" id="c-41785851" checked=""/><div class="controls bullet"><span class="by">gorgoiler</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41785355">parent</a><span>|</span><a href="#41785678">next</a><span>|</span><label class="collapse" for="c-41785851">[-]</label><label class="expand" for="c-41785851">[1 more]</label></div><br/><div class="children"><div class="content">[delayed]</div><br/></div></div><div id="41785678" class="c"><input type="checkbox" id="c-41785678" checked=""/><div class="controls bullet"><span class="by">ahoka</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41785355">parent</a><span>|</span><a href="#41785851">prev</a><span>|</span><a href="#41785514">next</a><span>|</span><label class="collapse" for="c-41785678">[-]</label><label class="expand" for="c-41785678">[1 more]</label></div><br/><div class="children"><div class="content">Congratulations, you are writing test for things that would not need test if weren&#x27;t put behind a under-defined interface. Meanwhile sprint goals are not met and overall product quality is embarrassing, but you have 100% MC&#x2F;DC coverage of your addNumbersOrThrowIfAbove(a, b, c).</div><br/></div></div><div id="41785514" class="c"><input type="checkbox" id="c-41785514" checked=""/><div class="controls bullet"><span class="by">jeltz</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41785355">parent</a><span>|</span><a href="#41785678">prev</a><span>|</span><a href="#41785584">next</a><span>|</span><label class="collapse" for="c-41785514">[-]</label><label class="expand" for="c-41785514">[3 more]</label></div><br/><div class="children"><div class="content">Which is usually a positive. Testing tiny subunits usually just makes refactoring and adding new features hard while not improving test quality.</div><br/><div id="41785649" class="c"><input type="checkbox" id="c-41785649" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41785514">parent</a><span>|</span><a href="#41785590">next</a><span>|</span><label class="collapse" for="c-41785649">[-]</label><label class="expand" for="c-41785649">[1 more]</label></div><br/><div class="children"><div class="content">Like most things being talked about here, so much depends on the specifics.<p>I think developers should generally try and aim for, at every scale, the outputs of a system to be pure functions of the inputs (whether by reducing the scope of the system or expanding the set of things considered inputs). Beyond that there are so many decisions at the margin that are going to be based on personal inclination.</div><br/></div></div><div id="41785590" class="c"><input type="checkbox" id="c-41785590" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41785514">parent</a><span>|</span><a href="#41785649">prev</a><span>|</span><a href="#41785584">next</a><span>|</span><label class="collapse" for="c-41785590">[-]</label><label class="expand" for="c-41785590">[1 more]</label></div><br/><div class="children"><div class="content">Not according to jon carmack. He stated he switched to pure functional programming in the intro which is basically stating all his logic is in the form of unit testable pure functions.</div><br/></div></div></div></div><div id="41785584" class="c"><input type="checkbox" id="c-41785584" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41785355">parent</a><span>|</span><a href="#41785514">prev</a><span>|</span><a href="#41785463">next</a><span>|</span><label class="collapse" for="c-41785584">[-]</label><label class="expand" for="c-41785584">[1 more]</label></div><br/><div class="children"><div class="content">This is a major insight. Defining a local function isn&#x27;t a big deal you can always just copy and pasta it out to global scope.<p>Any time you merge state with function you can no longer move the function. This is the same problem as OOP. Closures can&#x27;t be modular the same way methods in objects can&#x27;t be modular.<p>The smallest unit of testable module is the combinator. John Carmack literally mentioned he does pure functional programming now which basically everyone in this entire thread is completely ignoring.</div><br/></div></div><div id="41785463" class="c"><input type="checkbox" id="c-41785463" checked=""/><div class="controls bullet"><span class="by">xboxnolifes</span><span>|</span><a href="#41785121">root</a><span>|</span><a href="#41785355">parent</a><span>|</span><a href="#41785584">prev</a><span>|</span><a href="#41785423">next</a><span>|</span><label class="collapse" for="c-41785463">[-]</label><label class="expand" for="c-41785463">[1 more]</label></div><br/><div class="children"><div class="content">The unit here is the email, not the email&#x27;s link or subjects. Those are implementation details.</div><br/></div></div></div></div><div id="41785423" class="c"><input type="checkbox" id="c-41785423" checked=""/><div class="controls bullet"><span class="by">scbrg</span><span>|</span><a href="#41785121">parent</a><span>|</span><a href="#41785355">prev</a><span>|</span><a href="#41785330">next</a><span>|</span><label class="collapse" for="c-41785423">[-]</label><label class="expand" for="c-41785423">[1 more]</label></div><br/><div class="children"><div class="content">Not sure I believe the benefit of this approach outweighs the added difficulty wrt testing, but I certainly agree that Python needs a <i>yikes</i> keyword :-)</div><br/></div></div><div id="41785330" class="c"><input type="checkbox" id="c-41785330" checked=""/><div class="controls bullet"><span class="by">raverbashing</span><span>|</span><a href="#41785121">parent</a><span>|</span><a href="#41785423">prev</a><span>|</span><a href="#41785325">next</a><span>|</span><label class="collapse" for="c-41785330">[-]</label><label class="expand" for="c-41785330">[1 more]</label></div><br/><div class="children"><div class="content">It might be a benefit in some cases, but I do feel that f1&#x2F;f2&#x2F;f3 are the prime candidates for actual unit testing</div><br/></div></div><div id="41785325" class="c"><input type="checkbox" id="c-41785325" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#41785121">parent</a><span>|</span><a href="#41785330">prev</a><span>|</span><a href="#41785763">next</a><span>|</span><label class="collapse" for="c-41785325">[-]</label><label class="expand" for="c-41785325">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s possible to nest subprograms within subprograms in Ada. I take advantage of this ability to break a large operation into one or more smaller simpler &quot;core&quot; operations, and then in the main body of the procedure write some setup code followed by calls to the core operation(s).</div><br/></div></div></div></div><div id="41785763" class="c"><input type="checkbox" id="c-41785763" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#41785121">prev</a><span>|</span><a href="#41785810">next</a><span>|</span><label class="collapse" for="c-41785763">[-]</label><label class="expand" for="c-41785763">[2 more]</label></div><br/><div class="children"><div class="content">I wish languages had the following:<p><pre><code>  let x = block {
     …
     return 5
  } &#x2F;&#x2F; x == 5
</code></pre>
And the way to mark copypaste, e.g.<p><pre><code>  common foo {
    asdf(qwerty(i+j));
    printf(“%p”, write));
    bar();
  }
  …(repeats verbatim 20 times)…
  …
  common foo {
    asdf(qwerty(i+k));
    printf(“%d”, (int)write); &#x2F;&#x2F; cast to int
    bar();
  }
  …
</code></pre>
And then you could `mycc diff-common foo` and see:<p><pre><code>  &lt;file&gt;:&lt;line&gt;: common
  &lt;file&gt;:&lt;line&gt;: common
  …
  &lt;file&gt;:&lt;line&gt;:
    @@…@@
    -asdf(qwerty(i+j));
    +asdf(qwerty(i+k));
    @@…@@
    -printf(“%p”, write));
    +printf(“%d”, (int)write); &#x2F;&#x2F; cast to int
</code></pre>
With this you can track named common blocks (allows using surrounding context like i,j,k). Without them being functions and subject for functional entanglement $subj discusses. Most common code gets found out and divergences get bold. IDE support for immediate highlighting, snippeting and auto-common-ing similar code would be very nice.<p>Multi-patching common parts with easily reviewing the results would also be great. Because the bugs from calling a common function arise from the fact that you modify it and it suddenly works differently for some context. Well, you can comment a common block as fragile and then ignore it while patching:<p><pre><code>  common foo {
    &#x2F;&#x2F; @const: modified and fragile!
    …
  }
</code></pre>
You still see differences but it doesn’t add in a multi-patch dialog.<p>Not expecting it to appear anywhere though, features like that are never considered. Maybe someone interested can feature it in circles? (without my name associated)</div><br/><div id="41785849" class="c"><input type="checkbox" id="c-41785849" checked=""/><div class="controls bullet"><span class="by">badmintonbaseba</span><span>|</span><a href="#41785763">parent</a><span>|</span><a href="#41785810">next</a><span>|</span><label class="collapse" for="c-41785849">[-]</label><label class="expand" for="c-41785849">[1 more]</label></div><br/><div class="children"><div class="content">In C++ it&#x27;s an idiom to use immediately invoked lambdas:<p><pre><code>  auto x = []{
    &#x2F;*...*&#x2F;
    return 5;
  }();
</code></pre>
There is&#x2F;was an attempt to introduce a more of a first-class language construct for such immediate &quot;block expressions&quot;:<p><a href="https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2023&#x2F;p2806r2.html" rel="nofollow">https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2023&#x2F;p28...</a><p>I&#x27;m not convinced that automatic checking of copy-paste errors of such blocks make much sense though. At least I think the false positive rate would be way too high.</div><br/></div></div></div></div><div id="41785810" class="c"><input type="checkbox" id="c-41785810" checked=""/><div class="controls bullet"><span class="by">Ono-Sendai</span><span>|</span><a href="#41785763">prev</a><span>|</span><a href="#41785428">next</a><span>|</span><label class="collapse" for="c-41785810">[-]</label><label class="expand" for="c-41785810">[2 more]</label></div><br/><div class="children"><div class="content">There is actually a major problem with long functions - they take a long time to compile, due to superlinear complexity in computation time as a function of function length.  In other words breaking up a large function into smaller function can greatly reduce compile times.</div><br/><div id="41785819" class="c"><input type="checkbox" id="c-41785819" checked=""/><div class="controls bullet"><span class="by">badmintonbaseba</span><span>|</span><a href="#41785810">parent</a><span>|</span><a href="#41785428">next</a><span>|</span><label class="collapse" for="c-41785819">[-]</label><label class="expand" for="c-41785819">[1 more]</label></div><br/><div class="children"><div class="content">That honestly feels like a minor problem, and not something to optimize for. Also an aggressively inlining compiler will experience exactly the same problem. AFAIK at least clang always inlines a static (as in internal linkage) function if it&#x27;s used only once in the translation unit, no matter how large it is.</div><br/></div></div></div></div><div id="41785428" class="c"><input type="checkbox" id="c-41785428" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#41785810">prev</a><span>|</span><a href="#41785389">next</a><span>|</span><label class="collapse" for="c-41785428">[-]</label><label class="expand" for="c-41785428">[2 more]</label></div><br/><div class="children"><div class="content">I feel like this style is also encouraged in Go and &#x2F; or the clean&#x2F;onion architecture &#x2F; DDD, to a point, where the core business logic can and should be a string of &quot;do this, then do that, then do that&quot; code. In my own experience I&#x27;ve only had a few opportunities to do so (most of my work is front-end which is a different thing entirely), the one was application initialisation (Create the logger, then connect to the database, then if needed initialize &#x2F; migrate it, then if needed load test data. Then create the core domain services that uses the database connection. Then create the HTTP handlers that interface with the domain services. Then start the HTTP server. Then listen for an end process command and shut down gracefully), the other was pure business logic (read the database, transform, write to file, but &quot;database&quot; and &quot;file&quot; were abstract concepts that could be swapped out easily). You don&#x27;t really get that in front-end programming though, it&#x27;s all event driven etc.</div><br/><div id="41785565" class="c"><input type="checkbox" id="c-41785565" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#41785428">parent</a><span>|</span><a href="#41785389">next</a><span>|</span><label class="collapse" for="c-41785565">[-]</label><label class="expand" for="c-41785565">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the one was application initialisation<p>...and then you want to parallelize as much as possible to allow for fast boot times which helps the development process immensely.<p>One of the things I&#x27;ve learned is that optimizing for developer quality of life is one of the best approaches when it comes to correctness and performance. Then, the developers would be able to run multiple iterations of the real thing.</div><br/></div></div></div></div><div id="41785389" class="c"><input type="checkbox" id="c-41785389" checked=""/><div class="controls bullet"><span class="by">dehrmann</span><span>|</span><a href="#41785428">prev</a><span>|</span><a href="#41785588">next</a><span>|</span><label class="collapse" for="c-41785389">[-]</label><label class="expand" for="c-41785389">[6 more]</label></div><br/><div class="children"><div class="content">Always read older stuff from Carmack remembering the context. He made a name for himself getting 3D games to run on slow hardware. The standard advice of write for clarity first, make sure algorithms have reasonable runtimes, and look at profiler data if it&#x27;s slow is all you need 99% of the time.</div><br/><div id="41785455" class="c"><input type="checkbox" id="c-41785455" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#41785389">parent</a><span>|</span><a href="#41785433">next</a><span>|</span><label class="collapse" for="c-41785455">[-]</label><label class="expand" for="c-41785455">[3 more]</label></div><br/><div class="children"><div class="content">And before that, 2D games (side-scrolling platformers were not a thing on PC hardware until Carmack did it, iirc). I think his main thing is balancing clarity - what happens when and in what order - with maintainability.<p>Compare this with enterprise software, which is orders of magnitude more complex than video games in terms of business logic (the complexity in video games is in performance optimization), but whose developers tend to add many layers of abstraction and indirection, so the core business process is obfuscated, or there&#x27;s a billion non-functional side activities also being applied (logging, analytics, etc), again obfuscating the core functionality.<p>It&#x27;s fun to go back to more elementary programming things, in e.g. Advent of Code challenges or indeed, game development.</div><br/><div id="41785573" class="c"><input type="checkbox" id="c-41785573" checked=""/><div class="controls bullet"><span class="by">nadam</span><span>|</span><a href="#41785389">root</a><span>|</span><a href="#41785455">parent</a><span>|</span><a href="#41785665">next</a><span>|</span><label class="collapse" for="c-41785573">[-]</label><label class="expand" for="c-41785573">[1 more]</label></div><br/><div class="children"><div class="content">&quot;compare this with enterprise software, which is orders of magnitude more complex than video games in terms of business logic&quot;
Maybe this was true 20 years ago, but I do not think this is true today. Game code of some games is almost as complex as enterprise software or even more complex in some cases (think of grand strategy games like Civilization or Paradox games). The difference is that it still needs to be performant, so the evolutionary force just kills programmers and companies creating unperformant abstractions. In my opinion game programming is just harder than enterprise programming if we speak about complex games. (I have done both). The only thing which is easier in game programming is that it is a bit easier to 
 see clearly in terms of &#x27;business requirements&#x27;, and also it is more meritocratic (you can start a game company anywhere on the globe, no need to be at business centers.) And of course game programming is more fun, so programmers do the harder job even for less money.<p>For people who think game programming is less complex than enterprise software, I suggest the CharacterMovementComponent class in unreal engine which is the logic of movement of characters (people) in a networked game environment... With multiple thousand lines of code in just the header is not uncommon in unreal. And this is not complex because of optimization mostly. This is very complex and messy logic. Of course we can argue that networking and physics could be done in a simple naive way, which would be unacceptable in terms of latency and throughput, so all in all complexity is because of optimization after all. But it is not the &#x27;fun&#x27; elegant kind of optimization, it is close to messy enterprise software in some sense in my opinion.</div><br/></div></div><div id="41785665" class="c"><input type="checkbox" id="c-41785665" checked=""/><div class="controls bullet"><span class="by">high_na_euv</span><span>|</span><a href="#41785389">root</a><span>|</span><a href="#41785455">parent</a><span>|</span><a href="#41785573">prev</a><span>|</span><a href="#41785433">next</a><span>|</span><label class="collapse" for="c-41785665">[-]</label><label class="expand" for="c-41785665">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Compare this with enterprise software, which is orders of magnitude more complex than video games in terms of business logic<p>I dont buy it in games like gta, cyberpunk or witcher 3</div><br/></div></div></div></div><div id="41785433" class="c"><input type="checkbox" id="c-41785433" checked=""/><div class="controls bullet"><span class="by">physicles</span><span>|</span><a href="#41785389">parent</a><span>|</span><a href="#41785455">prev</a><span>|</span><a href="#41785588">next</a><span>|</span><label class="collapse" for="c-41785433">[-]</label><label class="expand" for="c-41785433">[2 more]</label></div><br/><div class="children"><div class="content">I agree with this in general, but his essay on functional programming in C++ (linked at the top of the page) is phenomenal and is fantastic general advice when working in any non-functional language.</div><br/><div id="41785522" class="c"><input type="checkbox" id="c-41785522" checked=""/><div class="controls bullet"><span class="by">nicolaslegland</span><span>|</span><a href="#41785389">root</a><span>|</span><a href="#41785433">parent</a><span>|</span><a href="#41785588">next</a><span>|</span><label class="collapse" for="c-41785522">[-]</label><label class="expand" for="c-41785522">[1 more]</label></div><br/><div class="children"><div class="content"><i>Link at the top of the page</i> broken, found an archived version at <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20120501221535&#x2F;http:&#x2F;&#x2F;gamasutra.com&#x2F;view&#x2F;news&#x2F;169296&#x2F;Indepth_Functional_programming_in_C.php" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20120501221535&#x2F;http:&#x2F;&#x2F;gamasutra....</a></div><br/></div></div></div></div></div></div><div id="41785588" class="c"><input type="checkbox" id="c-41785588" checked=""/><div class="controls bullet"><span class="by">otikik</span><span>|</span><a href="#41785389">prev</a><span>|</span><a href="#41785550">next</a><span>|</span><label class="collapse" for="c-41785588">[-]</label><label class="expand" for="c-41785588">[3 more]</label></div><br/><div class="children"><div class="content">&gt;  I have gotten much more bullish about pure functional programming, even in C&#x2F;C++ where reasonable: (link)<p>The link is no longer valid, I believe this is the article in question:<p><a href="https:&#x2F;&#x2F;www.gamedeveloper.com&#x2F;programming&#x2F;in-depth-functional-programming-in-c-" rel="nofollow">https:&#x2F;&#x2F;www.gamedeveloper.com&#x2F;programming&#x2F;in-depth-functiona...</a></div><br/><div id="41785617" class="c"><input type="checkbox" id="c-41785617" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41785588">parent</a><span>|</span><a href="#41785550">next</a><span>|</span><label class="collapse" for="c-41785617">[-]</label><label class="expand" for="c-41785617">[2 more]</label></div><br/><div class="children"><div class="content">Probably the more important link. He&#x27;s basically saying his old email is outdated and he does pure FP now.</div><br/><div id="41785825" class="c"><input type="checkbox" id="c-41785825" checked=""/><div class="controls bullet"><span class="by">meheleventyone</span><span>|</span><a href="#41785588">root</a><span>|</span><a href="#41785617">parent</a><span>|</span><a href="#41785550">next</a><span>|</span><label class="collapse" for="c-41785825">[-]</label><label class="expand" for="c-41785825">[1 more]</label></div><br/><div class="children"><div class="content">This is over a decade old at this stage, it would be interesting to know how his thoughts have evolved since.</div><br/></div></div></div></div></div></div><div id="41785550" class="c"><input type="checkbox" id="c-41785550" checked=""/><div class="controls bullet"><span class="by">randomtoast</span><span>|</span><a href="#41785588">prev</a><span>|</span><a href="#41785153">next</a><span>|</span><label class="collapse" for="c-41785550">[-]</label><label class="expand" for="c-41785550">[1 more]</label></div><br/><div class="children"><div class="content">My browser says &quot;The connection to number-none.com is not secure&quot;. Guess it is only a matter of time until HTTPS becomes mandatory.</div><br/></div></div><div id="41785153" class="c"><input type="checkbox" id="c-41785153" checked=""/><div class="controls bullet"><span class="by">rossant</span><span>|</span><a href="#41785550">prev</a><span>|</span><a href="#41785173">next</a><span>|</span><label class="collapse" for="c-41785153">[-]</label><label class="expand" for="c-41785153">[3 more]</label></div><br/><div class="children"><div class="content">(2014)</div><br/><div id="41785215" class="c"><input type="checkbox" id="c-41785215" checked=""/><div class="controls bullet"><span class="by">mindsuck</span><span>|</span><a href="#41785153">parent</a><span>|</span><a href="#41785291">next</a><span>|</span><label class="collapse" for="c-41785215">[-]</label><label class="expand" for="c-41785215">[1 more]</label></div><br/><div class="children"><div class="content">First discussed here back then: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8374345">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8374345</a></div><br/></div></div><div id="41785291" class="c"><input type="checkbox" id="c-41785291" checked=""/><div class="controls bullet"><span class="by">mcosta</span><span>|</span><a href="#41785153">parent</a><span>|</span><a href="#41785215">prev</a><span>|</span><a href="#41785173">next</a><span>|</span><label class="collapse" for="c-41785291">[-]</label><label class="expand" for="c-41785291">[1 more]</label></div><br/><div class="children"><div class="content">2007</div><br/></div></div></div></div><div id="41785173" class="c"><input type="checkbox" id="c-41785173" checked=""/><div class="controls bullet"><span class="by">gdiamos</span><span>|</span><a href="#41785153">prev</a><span>|</span><label class="collapse" for="c-41785173">[-]</label><label class="expand" for="c-41785173">[6 more]</label></div><br/><div class="children"><div class="content">How much of this is specific to control loops that execute at 60hz?</div><br/><div id="41785253" class="c"><input type="checkbox" id="c-41785253" checked=""/><div class="controls bullet"><span class="by">lloeki</span><span>|</span><a href="#41785173">parent</a><span>|</span><a href="#41785397">next</a><span>|</span><label class="collapse" for="c-41785253">[-]</label><label class="expand" for="c-41785253">[3 more]</label></div><br/><div class="children"><div class="content">None.<p>&gt; The real enemy addressed by inlining is unexpected dependency and mutation of state, which functional programming solves more directly and completely. However, if you are going to make a lot of state changes, having them all happen inline does have advantages; you should be made constantly aware of the full horror of what you are doing. When it gets to be too much to take, figure out how to factor blocks out into pure functions (and don.t let them slide back into impurity!).<p>Some years ago at job foo I wrote a Ruby library that was doing some stuff. Time was of the essence, I was a one-man team, and the trickiness of it required a clear understanding of the details, so I wrote a single ~1000 LOC file comprising of the entirety of the namespace module of that library, with but a couple or three functions.<p>Then a new hire joined my one-man team. I said: apologies for this unholy mess, it&#x27;s overdue for a refactoring, with a bunch of proper classes with small methods and split in a few files accordingly. They said: not at all, the code was exceptionally clear; I could sit and understand every bit of it down to the grittier critical details in under an hour, and having seen it written this way it is obvious to me that these details of interactions would not have been abstracted away, but obscured away.</div><br/><div id="41785539" class="c"><input type="checkbox" id="c-41785539" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#41785173">root</a><span>|</span><a href="#41785253">parent</a><span>|</span><a href="#41785346">next</a><span>|</span><label class="collapse" for="c-41785539">[-]</label><label class="expand" for="c-41785539">[1 more]</label></div><br/><div class="children"><div class="content">Thing is, a lot of developers see long code and think &quot;this is a Bad Thing&quot; because of dogma, but in practice, a lot of developers never actually wrote anything nontrivial like that.</div><br/></div></div><div id="41785346" class="c"><input type="checkbox" id="c-41785346" checked=""/><div class="controls bullet"><span class="by">yoz</span><span>|</span><a href="#41785173">root</a><span>|</span><a href="#41785253">parent</a><span>|</span><a href="#41785539">prev</a><span>|</span><a href="#41785397">next</a><span>|</span><label class="collapse" for="c-41785346">[-]</label><label class="expand" for="c-41785346">[1 more]</label></div><br/><div class="children"><div class="content">Your final ten words of the comment are a perfectly concise explanation of the problem; thank you! And it drives home something I often forget about <i>why</i> code units should do Only One Thing.</div><br/></div></div></div></div><div id="41785397" class="c"><input type="checkbox" id="c-41785397" checked=""/><div class="controls bullet"><span class="by">Netch</span><span>|</span><a href="#41785173">parent</a><span>|</span><a href="#41785253">prev</a><span>|</span><a href="#41785316">next</a><span>|</span><label class="collapse" for="c-41785397">[-]</label><label class="expand" for="c-41785397">[1 more]</label></div><br/><div class="children"><div class="content">All the code which is not in hot path may conform to any rules, and typically is designed according to something like SOLID, to make understanding and maintenance as simple as possible (and suitable to any average coder).<p>All the code which performance, memory cost, etc. is critical, should be adjusted to fit into required confine even if it will violate all other tenets. This often results in combination of opposite approaches - anything that does well.<p>Finally, one just profiles the code and fixes all most spending paths. This is what now any average programmer can do. What it canʼt do - and what Carmack has been doing for decades - is to predict such places and fixes them proactively at architectural level; and to find tricky solutions that average joe-the-programmer hasnʼt heard ever.</div><br/></div></div><div id="41785316" class="c"><input type="checkbox" id="c-41785316" checked=""/><div class="controls bullet"><span class="by">cryptonym</span><span>|</span><a href="#41785173">parent</a><span>|</span><a href="#41785397">prev</a><span>|</span><label class="collapse" for="c-41785316">[-]</label><label class="expand" for="c-41785316">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Minimize control flow complexity and “area under ifs”, favoring consistent execution paths and times over “optimally” avoiding unnecessary work.<p>If your control loop must always run under 16ms, you better make sure the worst case is 16ms rather than trying to optimise best or mid case. Avoid ifs that skips processing, that&#x27;s good for demo but doesn&#x27;t help reaching prod quality goals. Sometimes it doesn&#x27;t bring the benefits you think, sometimes it hides poorly optimised paths, sometimes it creates subtle bugs. Of course always use your own discernment...<p>That would be very different in a typical cloud app where the goal is to keep CPU, memory and network usage as low as possible, not much caring about having a constant response time on each REST endpoint.</div><br/></div></div></div></div></div></div></div></div></div></body></html>