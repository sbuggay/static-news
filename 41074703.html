<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1722330064774" as="style"/><link rel="stylesheet" href="styles.css?v=1722330064774"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://dhashe.com/how-to-build-highly-debuggable-c-binaries.html">How to build highly-debuggable C++ binaries</a> <span class="domain">(<a href="https://dhashe.com">dhashe.com</a>)</span></div><div class="subtext"><span>synergy20</span> | <span>71 comments</span></div><br/><div><div id="41104749" class="c"><input type="checkbox" id="c-41104749" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#41107033">next</a><span>|</span><label class="collapse" for="c-41104749">[-]</label><label class="expand" for="c-41104749">[7 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    if (breakpoint_1 &amp;&amp; (x_id == 153827)) {
        __asm(&quot;int $3&quot;);
    }
</code></pre>
No, don’t do it quite like that. Do:<p><pre><code>    __asm(“int3\n\tnop”);
</code></pre>
int3 is a “trap”, so gdb sees IP set to the instruction after int3: it’s literally the correct address plus one.  gdb’s core architecture code is, to be polite, not very enlightened, and gdb does not understand that int3 works this way. So gdb may generate an incorrect backtrace, and I’ve even caught gdb completely failing to generate a trace at all in some cases. By adding the nop, IP + 1 is still inside the inline asm statement, which is definitely in the same basic block and even on the same line, and gdb is much happier.</div><br/><div id="41106646" class="c"><input type="checkbox" id="c-41106646" checked=""/><div class="controls bullet"><span class="by">cordenr</span><span>|</span><a href="#41104749">parent</a><span>|</span><a href="#41105614">next</a><span>|</span><label class="collapse" for="c-41106646">[-]</label><label class="expand" for="c-41106646">[5 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t gdb allow breakpoints to be made to be  conditional?<p>Add a breakpoint somewhere in the code, say added as breakpoint #2.   Then;<p><pre><code>    condition 2 (x_id == 153827)
</code></pre>
Or is there some other reason to not do this?</div><br/><div id="41107231" class="c"><input type="checkbox" id="c-41107231" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#41104749">root</a><span>|</span><a href="#41106646">parent</a><span>|</span><a href="#41106917">next</a><span>|</span><label class="collapse" for="c-41107231">[-]</label><label class="expand" for="c-41107231">[1 more]</label></div><br/><div class="children"><div class="content">The rationale is explained in the article; it&#x27;s for speed.</div><br/></div></div><div id="41106917" class="c"><input type="checkbox" id="c-41106917" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41104749">root</a><span>|</span><a href="#41106646">parent</a><span>|</span><a href="#41107231">prev</a><span>|</span><a href="#41106673">next</a><span>|</span><label class="collapse" for="c-41106917">[-]</label><label class="expand" for="c-41106917">[1 more]</label></div><br/><div class="children"><div class="content">The only reason is that many still don&#x27;t learn how to use debuggers, people write blog posts about language featuritis, rewrite X in Y, and then keep using debuggers as if stuck in the 1960&#x27;s.</div><br/></div></div><div id="41106673" class="c"><input type="checkbox" id="c-41106673" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#41104749">root</a><span>|</span><a href="#41106646">parent</a><span>|</span><a href="#41106917">prev</a><span>|</span><a href="#41105614">next</a><span>|</span><label class="collapse" for="c-41106673">[-]</label><label class="expand" for="c-41106673">[2 more]</label></div><br/><div class="children"><div class="content">Only reason I can think of is that conditional breakpoints in the debugger can be <i>much</i> slower than compiling that same condition right into the debuggee.</div><br/><div id="41106918" class="c"><input type="checkbox" id="c-41106918" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41104749">root</a><span>|</span><a href="#41106673">parent</a><span>|</span><a href="#41105614">next</a><span>|</span><label class="collapse" for="c-41106918">[-]</label><label class="expand" for="c-41106918">[1 more]</label></div><br/><div class="children"><div class="content">If the CPU doesn&#x27;t support conditional hardware breakpoints, some do.</div><br/></div></div></div></div></div></div></div></div><div id="41107033" class="c"><input type="checkbox" id="c-41107033" checked=""/><div class="controls bullet"><span class="by">teleforce</span><span>|</span><a href="#41104749">prev</a><span>|</span><a href="#41101564">next</a><span>|</span><label class="collapse" for="c-41107033">[-]</label><label class="expand" for="c-41107033">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Enable frame-pointers for all functions<p>&gt;Compile with frame-pointers.<p>It&#x27;s good to see that enabling frame pointers are included in the recommendations for debugging purposes.<p>The discussions on the relevance and the usefulness of frame pointers earlier this year on HN [1]:<p>[1] The return of the frame pointers:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39731824">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39731824</a></div><br/></div></div><div id="41101564" class="c"><input type="checkbox" id="c-41101564" checked=""/><div class="controls bullet"><span class="by">mark_undoio</span><span>|</span><a href="#41107033">prev</a><span>|</span><a href="#41103632">next</a><span>|</span><label class="collapse" for="c-41101564">[-]</label><label class="expand" for="c-41101564">[16 more]</label></div><br/><div class="children"><div class="content">Good to see this discussed - debuggability is not talked about enough but, done right, it could be a superpower.<p>Setting the build for an old x64 machine (<a href="https:&#x2F;&#x2F;dhashe.com&#x2F;how-to-build-highly-debuggable-c-binaries.html#set-the-build-architecture-to-base-x86_64" rel="nofollow">https:&#x2F;&#x2F;dhashe.com&#x2F;how-to-build-highly-debuggable-c-binaries...</a>) for reversible &#x2F; time travel debuggers seems unnecessarily restrictive to me.  I&#x27;d expect a modern time travel debug tool (e.g. either rr or Undo - disclaimer, which I work on) to cope fine with most modern instructions (I believe GDB&#x27;s built-in record &#x2F; replay debugging tends to be further behind the curve on new CPU instructions - but if you&#x27;re doing anything at scale it&#x27;s not the right choice anyhow).<p>Regarding compilation (<a href="https:&#x2F;&#x2F;dhashe.com&#x2F;how-to-build-highly-debuggable-c-binaries.html#partition-your-tus-into-debuggable-and-fast" rel="nofollow">https:&#x2F;&#x2F;dhashe.com&#x2F;how-to-build-highly-debuggable-c-binaries...</a>) - we generally advise customers to use -Og rather than -O0.  As the article states, this will still optimise out some code but should be a good trade-off without being too slow.  (NB. last I checked, clang currently uses -Og as an alias for -O1, so it may behave less satisfactorily than under GCC).<p>It&#x27;s also not said enough but: you don&#x27;t need a special debug build to be able to debug.  It&#x27;s less user-friendly to debug a fully-optimised release build but it&#x27;s totally possible.  You just need to retain the DWARF debug info (instead of throwing it away).  This is really important to know if you&#x27;re debugging on a customer system or analysing a bug that&#x27;s only in release builds.</div><br/><div id="41101747" class="c"><input type="checkbox" id="c-41101747" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41101564">parent</a><span>|</span><a href="#41101890">next</a><span>|</span><label class="collapse" for="c-41101747">[-]</label><label class="expand" for="c-41101747">[10 more]</label></div><br/><div class="children"><div class="content">Having debugged a lot of optimized code I would strongly recommend against it unless you are in a context where performance of your build is paramount (games?) or you cannot reproduce the bug when compiled without optimizations. Compilers really do a terrible job at preserving useful debug info when you turn them on. It’s a massive pain to have everything be marked as “optimized out” and reassemble the things you want from other variables or by using a disassembler to manually track which register the value is hiding in.</div><br/><div id="41101942" class="c"><input type="checkbox" id="c-41101942" checked=""/><div class="controls bullet"><span class="by">SleepyMyroslav</span><span>|</span><a href="#41101564">root</a><span>|</span><a href="#41101747">parent</a><span>|</span><a href="#41102005">next</a><span>|</span><label class="collapse" for="c-41101942">[-]</label><label class="expand" for="c-41101942">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not only games. Anything sizeable that needs to run to repro will crumble under 20-100x times slowdown. Multithreaded behaviors will be just different. All those wonderful templated abstractions do not come for free in -O0. Ranges are especially egregious example. Debug build is truly dead outside of unit testing (imho).<p>Realistic scenario that gamedev uses: deoptimize translation units you are interested in finding or reproducing bugs.</div><br/><div id="41106717" class="c"><input type="checkbox" id="c-41106717" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#41101564">root</a><span>|</span><a href="#41101942">parent</a><span>|</span><a href="#41102040">next</a><span>|</span><label class="collapse" for="c-41106717">[-]</label><label class="expand" for="c-41106717">[2 more]</label></div><br/><div class="children"><div class="content">&gt; 20-100x<p>This would be really unusual though right? For reference, in plain C code I see a 2x slowdown, in Zig a 4x slowdown (which I still need to investigate why exactly that&#x27;s the case), and in C++ (even with heavy stdlib usage and on MSVC) at most 10x - which is the absolute worst case I&#x27;ve seen yet. My C++ info is a bit outdated though, have things gotten much worse in &quot;modern&quot; C++?<p>Or in other words: if you see a slowdown of 100x in debug mode, I would be really concerned about why the performance is so heavily dependent on the optimizer doing it&#x27;s thing and would start investigating what&#x27;s the reason for such a massive slowdown.</div><br/><div id="41107211" class="c"><input type="checkbox" id="c-41107211" checked=""/><div class="controls bullet"><span class="by">Cu3PO42</span><span>|</span><a href="#41101564">root</a><span>|</span><a href="#41106717">parent</a><span>|</span><a href="#41102040">next</a><span>|</span><label class="collapse" for="c-41107211">[-]</label><label class="expand" for="c-41107211">[1 more]</label></div><br/><div class="children"><div class="content">At work, I have a large C++ codebase in which I can observe slowdowns of one order of magnitude or more with -O0 compared to -O3. And for many bugs it still takes 10 minutes of runtime to hit them, so not using optimizations just isn&#x27;t tenable.<p>As far as I can tell, this is worse than for the average C++ codebase. I have some ideas for why the optimizer is able to achieve such large improvements with this particular code and some of that could surely be done with better source, but it&#x27;s a huge code base and a refactoring on that scale just isn&#x27;t going to happen.</div><br/></div></div></div></div><div id="41102040" class="c"><input type="checkbox" id="c-41102040" checked=""/><div class="controls bullet"><span class="by">senkora</span><span>|</span><a href="#41101564">root</a><span>|</span><a href="#41101942">parent</a><span>|</span><a href="#41106717">prev</a><span>|</span><a href="#41102005">next</a><span>|</span><label class="collapse" for="c-41102040">[-]</label><label class="expand" for="c-41102040">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Realistic scenario that gamedev uses: deoptimize translation units you are interested in finding or reproducing bugs.<p>Yep, looks like that’s this bullet point:<p><a href="https:&#x2F;&#x2F;dhashe.com&#x2F;category&#x2F;blog.html#partition-your-tus-into-debuggable-and-fast" rel="nofollow">https:&#x2F;&#x2F;dhashe.com&#x2F;category&#x2F;blog.html#partition-your-tus-int...</a></div><br/></div></div></div></div><div id="41102005" class="c"><input type="checkbox" id="c-41102005" checked=""/><div class="controls bullet"><span class="by">mark_undoio</span><span>|</span><a href="#41101564">root</a><span>|</span><a href="#41101747">parent</a><span>|</span><a href="#41101942">prev</a><span>|</span><a href="#41103682">next</a><span>|</span><label class="collapse" for="c-41102005">[-]</label><label class="expand" for="c-41102005">[3 more]</label></div><br/><div class="children"><div class="content">&gt; It’s a massive pain to have everything be marked as “optimized out” and reassemble the things you want from other variables or by using a disassembler to manually track which register the value is hiding in.<p>If you&#x27;ve got a time traveling &#x2F; reversible debugger than you can (sometimes) go back to a point where the value was being written &#x2F; used, at which point it&#x27;ll often reappear in scope and be accessible.<p>I believe DWARF&#x27;s built-in virtual machine should be able to recompute missing values in many cases but I don&#x27;t think compilers are great at putting the relevant info in, even where it should be possible to compute the right value fairly easily.</div><br/><div id="41102016" class="c"><input type="checkbox" id="c-41102016" checked=""/><div class="controls bullet"><span class="by">mark_undoio</span><span>|</span><a href="#41101564">root</a><span>|</span><a href="#41102005">parent</a><span>|</span><a href="#41103682">next</a><span>|</span><label class="collapse" for="c-41102016">[-]</label><label class="expand" for="c-41102016">[2 more]</label></div><br/><div class="children"><div class="content">The other trick I&#x27;ve found really helpful for &quot;optimized out&quot; values is to find places where they cross boundaries that block optimizations (e.g. procedure calls to another translation unit, so long as you&#x27;re not doing some kind of link-time optimisation).<p>e.g. if the value you&#x27;re interested in is being passed to &#x2F; returned from a function then inspecting it around the call &#x2F; return site should have the value available.</div><br/><div id="41102228" class="c"><input type="checkbox" id="c-41102228" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41101564">root</a><span>|</span><a href="#41102016">parent</a><span>|</span><a href="#41103682">next</a><span>|</span><label class="collapse" for="c-41102228">[-]</label><label class="expand" for="c-41102228">[1 more]</label></div><br/><div class="children"><div class="content">Two particular notes around this (exact commands assuming gdb, but other debuggers should have equivalents):<p>Pass various arguments to `backtrace` rather than just relying the default. Chances are it will have <i>some</i> non-optimized-out variables, which you can use to figure out what&#x27;s going on.<p>Use `info registers` and see what looks like a pointer, then cast it to a type you suspect it is. Note that this can be done for <i>any</i> stack frame.</div><br/></div></div></div></div></div></div><div id="41103682" class="c"><input type="checkbox" id="c-41103682" checked=""/><div class="controls bullet"><span class="by">DyslexicAtheist</span><span>|</span><a href="#41101564">root</a><span>|</span><a href="#41101747">parent</a><span>|</span><a href="#41102005">prev</a><span>|</span><a href="#41101890">next</a><span>|</span><label class="collapse" for="c-41103682">[-]</label><label class="expand" for="c-41103682">[2 more]</label></div><br/><div class="children"><div class="content">feels strange still to see complaints about debugging in production being inconvenient when we should have caught these issues in test&#x2F;staging. secondly I think not having debug tools and debug data in production is a security feature.</div><br/><div id="41105673" class="c"><input type="checkbox" id="c-41105673" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41101564">root</a><span>|</span><a href="#41103682">parent</a><span>|</span><a href="#41101890">next</a><span>|</span><label class="collapse" for="c-41105673">[-]</label><label class="expand" for="c-41105673">[1 more]</label></div><br/><div class="children"><div class="content">You’re trolling, right?</div><br/></div></div></div></div></div></div><div id="41101890" class="c"><input type="checkbox" id="c-41101890" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41101564">parent</a><span>|</span><a href="#41101747">prev</a><span>|</span><a href="#41103632">next</a><span>|</span><label class="collapse" for="c-41101890">[-]</label><label class="expand" for="c-41101890">[5 more]</label></div><br/><div class="children"><div class="content">&gt; you don&#x27;t need a special debug build to be able to debug<p>Note that this is <i>highly</i> dependent on choice of compiler. Clang is utter crap for debugging even at -O1, but I&#x27;ve encountered basically no trouble ever using GCC at -O2 (you do have to learn a little about how the binary changes but that&#x27;s easy enough to pick up). I really would not recommend -O3; historically it introduced bugs and regardless it makes the build process <i>much</i> slower, and the performance gain is fairly negligible (I can&#x27;t say how much it destroys debuggability due to lack of experience). I can&#x27;t speak for MSVC personally but it&#x27;s a bad sign that its culture strongly promotes separate debug builds.<p>That said, sanitizers are a place where a special debug build does help. Valgrind can do many of the things that sanitizers can but is around 10× slower which is a real pain if you can&#x27;t isolate what you&#x27;re targeting, so recompiling for sanitizers is a good idea.<p>(Other brief notes)<p>I have never actually encountered a case where the lack of frame pointers actually caused problems. As far as I&#x27;m concerned, any tool that breaks without them is a broken tool. (Theoretically they can speed up large traceback contexts if you&#x27;re doing extensive profiling; good API design probably helps for the sanitizers case here)<p>Rather than assembly int3, Unix-portable `SIGTRAP` is very useful for breakpoints; debuggers handle it specially. You can ignore it for non-debugged runs but get breakpoints when you are debugging without changing the binary or options! Alternatively you could leave it unignored if you have tooling that dumps core or something nicely for you.</div><br/><div id="41107248" class="c"><input type="checkbox" id="c-41107248" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#41101564">root</a><span>|</span><a href="#41101890">parent</a><span>|</span><a href="#41106134">next</a><span>|</span><label class="collapse" for="c-41107248">[-]</label><label class="expand" for="c-41107248">[1 more]</label></div><br/><div class="children"><div class="content">-O3 only breaks your code if it is invalid to begin with.</div><br/></div></div><div id="41106134" class="c"><input type="checkbox" id="c-41106134" checked=""/><div class="controls bullet"><span class="by">rerdavies</span><span>|</span><a href="#41101564">root</a><span>|</span><a href="#41101890">parent</a><span>|</span><a href="#41107248">prev</a><span>|</span><a href="#41102801">next</a><span>|</span><label class="collapse" for="c-41106134">[-]</label><label class="expand" for="c-41106134">[1 more]</label></div><br/><div class="children"><div class="content">Unpleasantly, GCC is utter crap for debugging even at -O0 on ARM64 platforms. I&#x27;ve tried both -O0 and -Og. :-( Highly unpredictable step-over behaviour, and many genuine lines of code that won&#x27;t take breakpoints.... MSVC has always been immaculately good at debugging, so this is an unpleasant surprise that&#x27;s seriously cutting into my productivity.<p>I&#x27;ve always felt that the debug code performance penalty was a good proxy for simulating what what users experience on machines that aren&#x27;t god-level development machines. If it doesn&#x27;t perform nicely on my machine with -O0, it&#x27;s not likely to perform well on machines owned by mere mortals. And there&#x27;s the extra lovely reward of being pleasantly surprised the snappy lively responsiveness of code that&#x27;s compiled with -O3. (Optimizing actually-performance-critical code is of course, a separate kettle of fish).</div><br/></div></div><div id="41102801" class="c"><input type="checkbox" id="c-41102801" checked=""/><div class="controls bullet"><span class="by">omoikane</span><span>|</span><a href="#41101564">root</a><span>|</span><a href="#41101890">parent</a><span>|</span><a href="#41106134">prev</a><span>|</span><a href="#41103632">next</a><span>|</span><label class="collapse" for="c-41102801">[-]</label><label class="expand" for="c-41102801">[2 more]</label></div><br/><div class="children"><div class="content">Debugging experience aside, I found that &quot;-O3&quot; is generally worth it if you also set &quot;-march=native&quot;.  For example, here are some run times for computing SHA256, you can see that there is slightly more to be gained going from -O2 to -O3 with -march=native:<p><pre><code>   -O2: 10.22
   -O3: 9.82

   -O2 -march=native: 9.86
   -O3 -march=native: 9.43
</code></pre>
This is basically SHA256 over ~8GB of data, averaged over 5 runs.  The numbers are rather crude here since I measured them just now, but I remember it was more significant when I first did it last month for <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40687942">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40687942</a></div><br/><div id="41103217" class="c"><input type="checkbox" id="c-41103217" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#41101564">root</a><span>|</span><a href="#41102801">parent</a><span>|</span><a href="#41103632">next</a><span>|</span><label class="collapse" for="c-41103217">[-]</label><label class="expand" for="c-41103217">[1 more]</label></div><br/><div class="children"><div class="content">Yeah -march=native is amazing. I use it when compiling &amp; benchmarking rust code.<p>But - to anyone reading this later - please don’t do this blindly. You probably never want to distribute binaries with this flag set. It enables all the features available on the host CPU. So your build will change depending on the physical cpu you have installed. If you have a modern amd cpu, it may enable avx512 extensions and make your binary unusable on many Intel CPUs.</div><br/></div></div></div></div></div></div></div></div><div id="41103632" class="c"><input type="checkbox" id="c-41103632" checked=""/><div class="controls bullet"><span class="by">renox</span><span>|</span><a href="#41101564">prev</a><span>|</span><a href="#41101667">next</a><span>|</span><label class="collapse" for="c-41103632">[-]</label><label class="expand" for="c-41103632">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Avoid stepping into irrelevant code<p>Thanks a lot!! I don&#x27;t know how many times I&#x27;ve stepped into the C++ standard library and it gets really annoying..</div><br/></div></div><div id="41101667" class="c"><input type="checkbox" id="c-41101667" checked=""/><div class="controls bullet"><span class="by">ggambetta</span><span>|</span><a href="#41103632">prev</a><span>|</span><a href="#41102864">next</a><span>|</span><label class="collapse" for="c-41101667">[-]</label><label class="expand" for="c-41101667">[8 more]</label></div><br/><div class="children"><div class="content">About a million years ago (OK, more like 20) I was making casual videogames in C++ and I wanted a cross-platform (Linux, Mac, Windows) way to get a stack trace whenever a game crashed. What I ended up doing was adding a macro to the first line of every function, let&#x27;s call it STACKTRACE, which was something like<p><pre><code>  #define STACKTRACE GLOBAL_STACK_FILE[GLOBAL_STACK_IDX] = __FILE__; GLOBAL_STACK_LINE[GLOBAL_STACK_IDX++] = __LINE__; StackTraceCleaner stc;
</code></pre>
StackTraceCleaner was a class that didn&#x27;t do anything but execute GLOBAL_STACK_IDX-- in its destructor.<p>So at any point in time I could inspect GLOBAL_STACK_FILE and GLOBAL_STACK_LINE and have a complete stack trace of the game.<p>Obviously this only worked because these games weren&#x27;t performance-critical and because they were essentially single-threaded, but it did the job at the time. We&#x27;re talking about a time when Visual Studio 6&#x27;s support for templates was half-broken, and the STL wasn&#x27;t exactly S, to the point that I had to roll out my own string, smart pointers, containers, etc -- made twice as hard because of the aforementioned broken template support in VS6 :(<p>I do miss these simpler, more innocent times, though.</div><br/><div id="41107206" class="c"><input type="checkbox" id="c-41107206" checked=""/><div class="controls bullet"><span class="by">pjc50</span><span>|</span><a href="#41101667">parent</a><span>|</span><a href="#41102481">next</a><span>|</span><label class="collapse" for="c-41107206">[-]</label><label class="expand" for="c-41107206">[1 more]</label></div><br/><div class="children"><div class="content">I had to do that when dealing with a device that was only debuggable over USB. When it crashed, that also took out the uplink and the debugger. So I had to record the stack trace in an area of memory specified as uninitialized, then dump it out as one of the first things to happen after a reboot.</div><br/></div></div><div id="41102481" class="c"><input type="checkbox" id="c-41102481" checked=""/><div class="controls bullet"><span class="by">VikingCoder</span><span>|</span><a href="#41101667">parent</a><span>|</span><a href="#41107206">prev</a><span>|</span><a href="#41103419">next</a><span>|</span><label class="collapse" for="c-41102481">[-]</label><label class="expand" for="c-41102481">[1 more]</label></div><br/><div class="children"><div class="content">Back in VS6 days, I did a similar thing, but I generated a GUID for the first line of every function.<p>STACKTRACE(&quot;e0957136-fed3-414d-80b9-8bbf84f3fa03&quot;);<p>With the GUID, I could see where functions moved as they were refactored.<p>I would write out the GUID to a thread-local file handle, along with a time-stamp, and an &quot;enter&quot; or &quot;exit&quot; when an RAII object left the stack.<p>Then I could retrospectively debug after running my program.  I could see the callstack, and step through in time.  I would walk my source and record GUID-to-filename&#x2F;linenumber in a map.  Then I could dump out a Visual Studio output that had the file name and line number, and execution time...  allowing me to step forward and back through the execution.<p>Stone knives and bearskins.</div><br/></div></div><div id="41103419" class="c"><input type="checkbox" id="c-41103419" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41101667">parent</a><span>|</span><a href="#41102481">prev</a><span>|</span><a href="#41102585">next</a><span>|</span><label class="collapse" for="c-41103419">[-]</label><label class="expand" for="c-41103419">[1 more]</label></div><br/><div class="children"><div class="content">We used a similar technique on a CRM server, UNIX based, back in 1999 - 2001.<p>Another techique is that all key allocations were handled based, so we could also easily dump what the whole process map was about.</div><br/></div></div><div id="41102585" class="c"><input type="checkbox" id="c-41102585" checked=""/><div class="controls bullet"><span class="by">arjvik</span><span>|</span><a href="#41101667">parent</a><span>|</span><a href="#41103419">prev</a><span>|</span><a href="#41103210">next</a><span>|</span><label class="collapse" for="c-41102585">[-]</label><label class="expand" for="c-41102585">[2 more]</label></div><br/><div class="children"><div class="content">My C++ is quite rusty, but why not have StackTraceCleaner&#x27;s constructor take __FILE__ and __LINE__ as arguments and update the file and line arrays there?</div><br/><div id="41103902" class="c"><input type="checkbox" id="c-41103902" checked=""/><div class="controls bullet"><span class="by">ggambetta</span><span>|</span><a href="#41101667">root</a><span>|</span><a href="#41102585">parent</a><span>|</span><a href="#41103210">next</a><span>|</span><label class="collapse" for="c-41103902">[-]</label><label class="expand" for="c-41103902">[1 more]</label></div><br/><div class="children"><div class="content">Could have been that, honestly I&#x27;m not sure. 20-ish years :)</div><br/></div></div></div></div><div id="41103210" class="c"><input type="checkbox" id="c-41103210" checked=""/><div class="controls bullet"><span class="by">FooBarWidget</span><span>|</span><a href="#41101667">parent</a><span>|</span><a href="#41102585">prev</a><span>|</span><a href="#41103627">next</a><span>|</span><label class="collapse" for="c-41103210">[-]</label><label class="expand" for="c-41103210">[1 more]</label></div><br/><div class="children"><div class="content">This is the same strategy I used in the Passenger application server.</div><br/></div></div></div></div><div id="41102864" class="c"><input type="checkbox" id="c-41102864" checked=""/><div class="controls bullet"><span class="by">binary132</span><span>|</span><a href="#41101667">prev</a><span>|</span><a href="#41101754">next</a><span>|</span><label class="collapse" for="c-41102864">[-]</label><label class="expand" for="c-41102864">[1 more]</label></div><br/><div class="children"><div class="content">I particularly liked the point that not every TU needs to be compiled in debug mode.  I am working on a build system and now I’m thinking of setting aside some time to make sure debug and optimization is an object level option.  In general, I think the usefulness of a well specified ABI over object code is vastly underappreciated!</div><br/></div></div><div id="41101754" class="c"><input type="checkbox" id="c-41101754" checked=""/><div class="controls bullet"><span class="by">Galanwe</span><span>|</span><a href="#41102864">prev</a><span>|</span><a href="#41105349">next</a><span>|</span><label class="collapse" for="c-41101754">[-]</label><label class="expand" for="c-41101754">[4 more]</label></div><br/><div class="children"><div class="content">What irks me the most is that in 2024, I still can&#x27;t reliably embed source code in dwarf5 to get meaningful source-contextualized stacktraces and have to ship source code separately and override the source mapping.</div><br/><div id="41101877" class="c"><input type="checkbox" id="c-41101877" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#41101754">parent</a><span>|</span><a href="#41105349">next</a><span>|</span><label class="collapse" for="c-41101877">[-]</label><label class="expand" for="c-41101877">[3 more]</label></div><br/><div class="children"><div class="content">Strong agree.<p>At least on Windows you can setup Symbol Server + Source Indexing to achieve the same result.<p>Once upon a time I wrote a small tool that can embed full source code into PDBs. I doubt anyone has ever used it though. For proprietary software it&#x27;s not uncommon to leak PDBs on accident at some point. It could be disastrous to also leak full source code!<p><a href="https:&#x2F;&#x2F;www.forrestthewoods.com&#x2F;blog&#x2F;embedding-source-code-in-pdbs-with-rust&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.forrestthewoods.com&#x2F;blog&#x2F;embedding-source-code-i...</a><p>It&#x27;s relatively easy to add source indexing to PDBs. I&#x27;ve successfully done that for a non-standard Monorepo. Works great.</div><br/><div id="41102027" class="c"><input type="checkbox" id="c-41102027" checked=""/><div class="controls bullet"><span class="by">mark_undoio</span><span>|</span><a href="#41101754">root</a><span>|</span><a href="#41101877">parent</a><span>|</span><a href="#41103695">next</a><span>|</span><label class="collapse" for="c-41102027">[-]</label><label class="expand" for="c-41102027">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s `debuginfod` on Linux: <a href="https:&#x2F;&#x2F;developers.redhat.com&#x2F;blog&#x2F;2019&#x2F;10&#x2F;14&#x2F;introducing-debuginfod-the-elfutils-debuginfo-server" rel="nofollow">https:&#x2F;&#x2F;developers.redhat.com&#x2F;blog&#x2F;2019&#x2F;10&#x2F;14&#x2F;introducing-de...</a><p>It builds a lot on quite a simple conceptual base, benefiting from native support in gcc &#x2F; clang (for embedding unique build IDs) and in GDB (for contacting the server).  It can serve up both source and symbol information.<p>I would like to see this adopted more - e.g. build infrastructure automatically populating a debuginfod server so debugging is seamless.</div><br/></div></div><div id="41103695" class="c"><input type="checkbox" id="c-41103695" checked=""/><div class="controls bullet"><span class="by">becurious</span><span>|</span><a href="#41101754">root</a><span>|</span><a href="#41101877">parent</a><span>|</span><a href="#41102027">prev</a><span>|</span><a href="#41105349">next</a><span>|</span><label class="collapse" for="c-41103695">[-]</label><label class="expand" for="c-41103695">[1 more]</label></div><br/><div class="children"><div class="content">There is SourceLink where you can get the mapping into the pdb files:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;sourcelink">https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;sourcelink</a></div><br/></div></div></div></div></div></div><div id="41105349" class="c"><input type="checkbox" id="c-41105349" checked=""/><div class="controls bullet"><span class="by">breatheoften</span><span>|</span><a href="#41101754">prev</a><span>|</span><a href="#41102156">next</a><span>|</span><label class="collapse" for="c-41105349">[-]</label><label class="expand" for="c-41105349">[3 more]</label></div><br/><div class="children"><div class="content">I recently added some pretty printers for a type we have a lot of in our codebase (the c++ Eigen library).<p>Unlike the article we are using lldb rather than gdb ... and while I appreciate thats its possible _at all_ to script the debugger to do some pretty printing -- I found it quite a bit more frought to implement than initially expected ...<p>To take the Eigen example ...  Eigen is a &#x27;header only&#x27; library and offers  Templated vector and matrix types.  The types are template over (optionally), data type, number of rows, number of columns, and matrix row order (row major or column major).  All that information is not actually even available at runtime -- just the type name (with the instantiated values for template arguments) ...<p>I ended up having to super hackily parse information out of the template type name in order to be able to pretty print the matrix appropriately in lldb ...<p>Problems of this nature abound when debugging c++ ...  Very often with a header only library, there isn&#x27;t even a symbol for methods you might want to call -- so you want to eg, call the size() method on some object within the debugger to see how big it is, you&#x27;ll often be out of look due to an undefined symbol reference since the 0-overahead compilation models ensures the symbol doesn&#x27;t even have to be created in the binary ...<p>Would be nice if there was some kind of way around that -- I guess I need to try the workaround mentioned in the article of explicitly instantiating template classes for common classes in &#x27;debug&#x27; mode ... My fuzzy mental model derived from previous experience somehow doesn&#x27;t think that will actually help the issue tho -- but I&#x27;d be happy to be wrong!</div><br/><div id="41106970" class="c"><input type="checkbox" id="c-41106970" checked=""/><div class="controls bullet"><span class="by">Const-me</span><span>|</span><a href="#41105349">parent</a><span>|</span><a href="#41107039">next</a><span>|</span><label class="collapse" for="c-41106970">[-]</label><label class="expand" for="c-41106970">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Would be nice if there was some kind of way around that<p>I’m using Windows and compile with Visual Studio. That debugger visualization file  <a href="https:&#x2F;&#x2F;github.com&#x2F;cdcseacave&#x2F;Visual-Studio-Visualizers&#x2F;blob&#x2F;master&#x2F;Eigen.natvis">https:&#x2F;&#x2F;github.com&#x2F;cdcseacave&#x2F;Visual-Studio-Visualizers&#x2F;blob...</a> makes Eigen vectors and matrices show up nicely in debugger.</div><br/></div></div><div id="41107039" class="c"><input type="checkbox" id="c-41107039" checked=""/><div class="controls bullet"><span class="by">vintagedave</span><span>|</span><a href="#41105349">parent</a><span>|</span><a href="#41106970">prev</a><span>|</span><a href="#41102156">next</a><span>|</span><label class="collapse" for="c-41107039">[-]</label><label class="expand" for="c-41107039">[1 more]</label></div><br/><div class="children"><div class="content">A colleague was doing this for std::map&lt;&gt; for libc++ in LLDB recently, and he found the same thing: he had to hackily parse the template name for the types. He told me that usually for formatters, PDB has a type ID you can use to look up the type, but templates don&#x27;t.</div><br/></div></div></div></div><div id="41102156" class="c"><input type="checkbox" id="c-41102156" checked=""/><div class="controls bullet"><span class="by">Const-me</span><span>|</span><a href="#41105349">prev</a><span>|</span><a href="#41101650">next</a><span>|</span><label class="collapse" for="c-41102156">[-]</label><label class="expand" for="c-41102156">[1 more]</label></div><br/><div class="children"><div class="content">Tangentially related, a few tips about offline debugging on Windows: <a href="http:&#x2F;&#x2F;const.me&#x2F;articles&#x2F;windbg&#x2F;windbg-intro.pdf" rel="nofollow">http:&#x2F;&#x2F;const.me&#x2F;articles&#x2F;windbg&#x2F;windbg-intro.pdf</a><p>Not a silver bullet but still, being able to collect and analyze user-mode crash dumps is sometimes the best way to investigate and fix bugs.</div><br/></div></div><div id="41101650" class="c"><input type="checkbox" id="c-41101650" checked=""/><div class="controls bullet"><span class="by">hurpdurpdurp</span><span>|</span><a href="#41102156">prev</a><span>|</span><a href="#41102459">next</a><span>|</span><label class="collapse" for="c-41101650">[-]</label><label class="expand" for="c-41101650">[5 more]</label></div><br/><div class="children"><div class="content">Great article with lots of good advice, but it makes me wonder what the consensus is on using ASAN in production.<p>Once upon a time it was widely said that ASAN should not be used for production code. The authors advocated against it and from a general-purpose security perspective it gives attackers a very large writable memory region at a fixed offset to play with. But over time I see more and more ASAN code in production on the theory that ASAN <i>may</i> make a system easier to exploit, but a memory corruption <i>will</i> make it easier to exploit. And so it&#x27;s better to have knowledge of the issue.<p>Also, I&#x27;ve personally found the glibc malloc tunables very useful for debugging.</div><br/><div id="41102221" class="c"><input type="checkbox" id="c-41102221" checked=""/><div class="controls bullet"><span class="by">ryandrake</span><span>|</span><a href="#41101650">parent</a><span>|</span><a href="#41106754">next</a><span>|</span><label class="collapse" for="c-41102221">[-]</label><label class="expand" for="c-41102221">[3 more]</label></div><br/><div class="children"><div class="content">To me, leaving a debug tool on in production because it happens to mask a bug is like the old (mal)practice of turning off optimizations in Release builds because of hard-to-debug crashes. Better to just fix the crashes.</div><br/><div id="41106853" class="c"><input type="checkbox" id="c-41106853" checked=""/><div class="controls bullet"><span class="by">debatem1</span><span>|</span><a href="#41101650">root</a><span>|</span><a href="#41102221">parent</a><span>|</span><a href="#41106127">next</a><span>|</span><label class="collapse" for="c-41106853">[-]</label><label class="expand" for="c-41106853">[1 more]</label></div><br/><div class="children"><div class="content">ASAN doesn&#x27;t mask bugs-- quite the opposite, it turns silent memory corruptions into crashes.</div><br/></div></div><div id="41106127" class="c"><input type="checkbox" id="c-41106127" checked=""/><div class="controls bullet"><span class="by">zbentley</span><span>|</span><a href="#41101650">root</a><span>|</span><a href="#41102221">parent</a><span>|</span><a href="#41106853">prev</a><span>|</span><a href="#41106754">next</a><span>|</span><label class="collapse" for="c-41106127">[-]</label><label class="expand" for="c-41106127">[1 more]</label></div><br/><div class="children"><div class="content">I only have a problem with one word in that statement:<p>&quot;just&quot;.</div><br/></div></div></div></div><div id="41106754" class="c"><input type="checkbox" id="c-41106754" checked=""/><div class="controls bullet"><span class="by">self_awareness</span><span>|</span><a href="#41101650">parent</a><span>|</span><a href="#41102221">prev</a><span>|</span><a href="#41102459">next</a><span>|</span><label class="collapse" for="c-41106754">[-]</label><label class="expand" for="c-41106754">[1 more]</label></div><br/><div class="children"><div class="content">I think that using ASAN in production is a terrible idea, from the
reasons you&#x27;ve provided. Also a memory corruption <i>might not be there</i>,
but ASAN <i>is always there</i>, so we&#x27;re switching a potential open attack
vector for an guaranteed open attack vector.<p>But generally, using ASAN in production is not what ASAN is for. If
someone needs &quot;memory safety&quot; that ASAN provides, and doesn&#x27;t care about
slower runtime, then why did they use C++ in the first place? Just use
Java. I understand this is not an option for old codebases though.<p>Also, using ASAN in production is like using a library for which the
author states it&#x27;s only meant for debugging and they doesn&#x27;t really care
about introducing any attack vectors in future versions. Even if it&#x27;s
not &quot;exploitable&quot; now, it might be in the future. Why would anyone want
to use such library and take the responsibility that nothing bad will
happen on the customer machine?</div><br/></div></div></div></div><div id="41102459" class="c"><input type="checkbox" id="c-41102459" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#41101650">prev</a><span>|</span><a href="#41105618">next</a><span>|</span><label class="collapse" for="c-41102459">[-]</label><label class="expand" for="c-41102459">[3 more]</label></div><br/><div class="children"><div class="content">Good points, but for me number one would be to avoid runtime polymorphism like the plague.<p>If your call graph has more roots than your neighbors garden and the whole thing is a forest and not a tree you will have a hard time understanding, analyzing and ultimately debugging.</div><br/><div id="41107212" class="c"><input type="checkbox" id="c-41107212" checked=""/><div class="controls bullet"><span class="by">pjc50</span><span>|</span><a href="#41102459">parent</a><span>|</span><a href="#41106139">next</a><span>|</span><label class="collapse" for="c-41107212">[-]</label><label class="expand" for="c-41107212">[1 more]</label></div><br/><div class="children"><div class="content">People respond to the awful complexity of C++ in many ways, each trying to cut out huge sections of the language, but I think this is the first time I&#x27;ve seen someone argue against using virtual dispatch. Somewhere out there a Smalltalk programmer is laughing.</div><br/></div></div><div id="41106139" class="c"><input type="checkbox" id="c-41106139" checked=""/><div class="controls bullet"><span class="by">zbentley</span><span>|</span><a href="#41102459">parent</a><span>|</span><a href="#41107212">prev</a><span>|</span><a href="#41105618">next</a><span>|</span><label class="collapse" for="c-41106139">[-]</label><label class="expand" for="c-41106139">[1 more]</label></div><br/><div class="children"><div class="content">What do you mean by &quot;runtime polymorphism&quot; here? Vtable dispatches? Something else?<p>I guess I&#x27;m confused by the mention of call graph roots; in my mind those are just ... entry points. Edges in the call graph might be a PITA to follow in a debugger because of indirections like vtables&#x2F;optimizer inlining&#x2F;etc., but isn&#x27;t that separate? Or is my terminology model wrong?</div><br/></div></div></div></div><div id="41105618" class="c"><input type="checkbox" id="c-41105618" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#41102459">prev</a><span>|</span><a href="#41103969">next</a><span>|</span><label class="collapse" for="c-41105618">[-]</label><label class="expand" for="c-41105618">[1 more]</label></div><br/><div class="children"><div class="content">In case the author is here: I see --gdb3 in a lot of places on the post where I think they meant --ggdb3.</div><br/></div></div><div id="41101725" class="c"><input type="checkbox" id="c-41101725" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#41103969">prev</a><span>|</span><a href="#41101686">next</a><span>|</span><label class="collapse" for="c-41101725">[-]</label><label class="expand" for="c-41101725">[6 more]</label></div><br/><div class="children"><div class="content">Great post. I’m surprised it requires so much effort. On Windows you pretty just need to make a debug build and… that’s it!<p>A nice trick with MSVC is you can turn off optimizations for TU or any block of code with:<p><pre><code>    #pragma optimize( &quot;&quot;, off )
</code></pre>
Leaps and bounds easier than hacking the build the system.</div><br/><div id="41102646" class="c"><input type="checkbox" id="c-41102646" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41101725">parent</a><span>|</span><a href="#41106848">next</a><span>|</span><label class="collapse" for="c-41102646">[-]</label><label class="expand" for="c-41102646">[2 more]</label></div><br/><div class="children"><div class="content">Assuming spatulas are absent, I&#x27;ve never had a problem with the build system on Linux. Nonetheless, for GCC the equivalent is:<p><pre><code>  #pragma GCC optimize (&quot;O0&quot;)
</code></pre>
(see also target, push_options, and pop_options)<p>This is also available as a per-function attribute, using both gnu and standard syntaxes:<p><pre><code>  __attribute__((optimize(&quot;O0&quot;)))
  [[gnu::optimize(&quot;O0&quot;)]]</code></pre></div><br/><div id="41103729" class="c"><input type="checkbox" id="c-41103729" checked=""/><div class="controls bullet"><span class="by">bialpio</span><span>|</span><a href="#41101725">root</a><span>|</span><a href="#41102646">parent</a><span>|</span><a href="#41106848">next</a><span>|</span><label class="collapse" for="c-41103729">[-]</label><label class="expand" for="c-41103729">[1 more]</label></div><br/><div class="children"><div class="content">For completeness, in Clang `[[clang::optnone]]` as a per-function attribute also works fine. I&#x27;m using it for debugging quite frequently lately.</div><br/></div></div></div></div><div id="41106848" class="c"><input type="checkbox" id="c-41106848" checked=""/><div class="controls bullet"><span class="by">self_awareness</span><span>|</span><a href="#41101725">parent</a><span>|</span><a href="#41102646">prev</a><span>|</span><a href="#41102511">next</a><span>|</span><label class="collapse" for="c-41106848">[-]</label><label class="expand" for="c-41106848">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I’m surprised it requires so much effort. On Windows you pretty just need to make a debug build and... that’s it!<p>Well, except the Debug build in MSVC doesn&#x27;t do half of the things from
this list. Also, the list tells you how to use the compilation driver
directly, so when comparing stuff, you would need to use the &quot;cl.exe&quot;
compiler. For a &quot;default&quot; debugging experience it&#x27;s enough to use
CMake&#x27;s Debug build type. It even has a built-in &quot;release with debug
info&quot; build type.</div><br/></div></div><div id="41102511" class="c"><input type="checkbox" id="c-41102511" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#41101725">parent</a><span>|</span><a href="#41106848">prev</a><span>|</span><a href="#41101795">next</a><span>|</span><label class="collapse" for="c-41102511">[-]</label><label class="expand" for="c-41102511">[1 more]</label></div><br/><div class="children"><div class="content">I mean, to be fair, if you&#x27;re fiddling with&#x2F;invoking cl.exe manually then you&#x27;d need to know a lot of the general equivalents and nits listed here. MSVC&#x27;s debug build will do a lot for you out of the box though which is great. That said you often have to support&#x2F;know 400 random build tools when using C++ to enable things like this, so it&#x27;s often useful knowledge anyway.</div><br/></div></div><div id="41101795" class="c"><input type="checkbox" id="c-41101795" checked=""/><div class="controls bullet"><span class="by">FpUser</span><span>|</span><a href="#41101725">parent</a><span>|</span><a href="#41102511">prev</a><span>|</span><a href="#41101686">next</a><span>|</span><label class="collapse" for="c-41101795">[-]</label><label class="expand" for="c-41101795">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&quot;On Windows you pretty just need to make a debug build and… that’s it!&quot;<p>I got pretty much the same on Linux when using CLion IDE from JetBrains.</div><br/></div></div></div></div><div id="41101686" class="c"><input type="checkbox" id="c-41101686" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#41101725">prev</a><span>|</span><label class="collapse" for="c-41101686">[-]</label><label class="expand" for="c-41101686">[12 more]</label></div><br/><div class="children"><div class="content">Anyone have tips on getting good stack traces in opt builds? I am really struggling with it at the moment. LLVM sanitizers all generate brilliant stack traces by forking llvm-symbolizer and feeding it the goods. But during runtime crashes on optimized binaries I don&#x27;t seem to get good stack traces. One of the problems is that some library backtrace functions do not print the base address of the DSO mapping, which means they are printing a meaningless PC that can&#x27;t be used to find file and line later.</div><br/><div id="41107277" class="c"><input type="checkbox" id="c-41107277" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#41101686">parent</a><span>|</span><a href="#41102946">next</a><span>|</span><label class="collapse" for="c-41107277">[-]</label><label class="expand" for="c-41107277">[1 more]</label></div><br/><div class="children"><div class="content">libbacktrace does it all, and there is also that feature in the C++ standard library now.</div><br/></div></div><div id="41102946" class="c"><input type="checkbox" id="c-41102946" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#41101686">parent</a><span>|</span><a href="#41107277">prev</a><span>|</span><a href="#41101921">next</a><span>|</span><label class="collapse" for="c-41102946">[-]</label><label class="expand" for="c-41102946">[1 more]</label></div><br/><div class="children"><div class="content">Mozilla has a tool to fix up the bad dladdr-based printing methods in log files here: <a href="https:&#x2F;&#x2F;github.com&#x2F;mozilla&#x2F;fix-stacks&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;mozilla&#x2F;fix-stacks&#x2F;</a>. Note that it relies on doing a little bit of post-processing on dladdr to get the base of the DSO it is in: <a href="https:&#x2F;&#x2F;searchfox.org&#x2F;mozilla-central&#x2F;source&#x2F;mozglue&#x2F;misc&#x2F;StackWalk.cpp#856-870" rel="nofollow">https:&#x2F;&#x2F;searchfox.org&#x2F;mozilla-central&#x2F;source&#x2F;mozglue&#x2F;misc&#x2F;St...</a><p>As for whether or not you can use this in a signal handler... well, I hate reading the POSIX standard with regard to signal safety because it&#x27;s just not well-written, but as far as I can tell, a non-async-signal-safe function can be safely called from a signal handler for a synchronous signal (which most of the interesting signals for dumping stack traces are--it&#x27;s only something like dump-stack-trace-on-SIGUSR1 that&#x27;s actually going to be an asynchronous signal), so long as it is not interrupting a non-async-signal-safe function. So as long as you&#x27;re not crashing in libc, it should be kosher.</div><br/></div></div><div id="41101921" class="c"><input type="checkbox" id="c-41101921" checked=""/><div class="controls bullet"><span class="by">bogwog</span><span>|</span><a href="#41101686">parent</a><span>|</span><a href="#41102946">prev</a><span>|</span><a href="#41102048">next</a><span>|</span><label class="collapse" for="c-41101921">[-]</label><label class="expand" for="c-41101921">[1 more]</label></div><br/><div class="children"><div class="content">Have you looked into using a library like Breakpad (<a href="https:&#x2F;&#x2F;chromium.googlesource.com&#x2F;breakpad&#x2F;breakpad&#x2F;" rel="nofollow">https:&#x2F;&#x2F;chromium.googlesource.com&#x2F;breakpad&#x2F;breakpad&#x2F;</a>)? It&#x27;s probably too much work to integrate for local debugging only though.</div><br/></div></div><div id="41102048" class="c"><input type="checkbox" id="c-41102048" checked=""/><div class="controls bullet"><span class="by">mark_undoio</span><span>|</span><a href="#41101686">parent</a><span>|</span><a href="#41101921">prev</a><span>|</span><a href="#41102850">next</a><span>|</span><label class="collapse" for="c-41102048">[-]</label><label class="expand" for="c-41102048">[3 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re on *NIX have you tried just invoking gstack or similar as an external process?  <a href="https:&#x2F;&#x2F;linux.die.net&#x2F;man&#x2F;1&#x2F;gstack" rel="nofollow">https:&#x2F;&#x2F;linux.die.net&#x2F;man&#x2F;1&#x2F;gstack</a><p>Or, indeed, getting a core dump and applying GDB to it.  GDB seems generally pretty good at reconstructing stacks at arbitrary points in application runtime.<p>We&#x27;ve also used a combination of libunwind and <a href="https:&#x2F;&#x2F;linux.die.net&#x2F;man&#x2F;1&#x2F;addr2line" rel="nofollow">https:&#x2F;&#x2F;linux.die.net&#x2F;man&#x2F;1&#x2F;addr2line</a> to produce good crash dumps when GDB is not necessarily available.</div><br/><div id="41102075" class="c"><input type="checkbox" id="c-41102075" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#41101686">root</a><span>|</span><a href="#41102048">parent</a><span>|</span><a href="#41102850">next</a><span>|</span><label class="collapse" for="c-41102075">[-]</label><label class="expand" for="c-41102075">[2 more]</label></div><br/><div class="children"><div class="content">To which of the projects that are all named &quot;libunwind&quot; do you refer?</div><br/><div id="41102167" class="c"><input type="checkbox" id="c-41102167" checked=""/><div class="controls bullet"><span class="by">mark_undoio</span><span>|</span><a href="#41101686">root</a><span>|</span><a href="#41102075">parent</a><span>|</span><a href="#41102850">next</a><span>|</span><label class="collapse" for="c-41102167">[-]</label><label class="expand" for="c-41102167">[1 more]</label></div><br/><div class="children"><div class="content">This one, I believe: <a href="https:&#x2F;&#x2F;github.com&#x2F;libunwind&#x2F;libunwind">https:&#x2F;&#x2F;github.com&#x2F;libunwind&#x2F;libunwind</a><p>ETA: Thinking about it, I&#x27;m not really sure what it&#x27;d do for C++ - I guess you&#x27;d end up with mangled names, so if you want sensible names you might need to demangle (either as a post-processing step or within the dumper) too.<p>I don&#x27;t think you&#x27;ll get any decoded argument values out of it either, so I guess it depends what backtrace info is needed.</div><br/></div></div></div></div></div></div><div id="41102850" class="c"><input type="checkbox" id="c-41102850" checked=""/><div class="controls bullet"><span class="by">dllu</span><span>|</span><a href="#41101686">parent</a><span>|</span><a href="#41102048">prev</a><span>|</span><a href="#41102254">next</a><span>|</span><label class="collapse" for="c-41102850">[-]</label><label class="expand" for="c-41102850">[2 more]</label></div><br/><div class="children"><div class="content">I enjoy using backward: <a href="https:&#x2F;&#x2F;github.com&#x2F;bombela&#x2F;backward-cpp">https:&#x2F;&#x2F;github.com&#x2F;bombela&#x2F;backward-cpp</a></div><br/><div id="41102879" class="c"><input type="checkbox" id="c-41102879" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#41101686">root</a><span>|</span><a href="#41102850">parent</a><span>|</span><a href="#41102254">next</a><span>|</span><label class="collapse" for="c-41102879">[-]</label><label class="expand" for="c-41102879">[1 more]</label></div><br/><div class="children"><div class="content">Looks worth investigating. Also making me wonder how many different backtrace implementations are out there on GitHub with Google copyrights!</div><br/></div></div></div></div><div id="41102254" class="c"><input type="checkbox" id="c-41102254" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41101686">parent</a><span>|</span><a href="#41102850">prev</a><span>|</span><a href="#41101718">next</a><span>|</span><label class="collapse" for="c-41102254">[-]</label><label class="expand" for="c-41102254">[1 more]</label></div><br/><div class="children"><div class="content">Rule number one: never use Clang; its optimizers destroy too much information unlike GCC.<p>You can use `dl_iterate_phdr` at startup if you need DSO info?</div><br/></div></div><div id="41101718" class="c"><input type="checkbox" id="c-41101718" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41101686">parent</a><span>|</span><a href="#41102254">prev</a><span>|</span><label class="collapse" for="c-41101718">[-]</label><label class="expand" for="c-41101718">[2 more]</label></div><br/><div class="children"><div class="content">Is calling dladdr on the addresses not enough for you?</div><br/><div id="41101769" class="c"><input type="checkbox" id="c-41101769" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#41101686">root</a><span>|</span><a href="#41101718">parent</a><span>|</span><label class="collapse" for="c-41101769">[-]</label><label class="expand" for="c-41101769">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not async signal safe, so I did not even try that.<p>I think there&#x27;s a huge amount of complexity both inherent to the problem and caused by fifty years of accumulated bad habits, which is indicated by the thousands of lines of code in compiler-rt dedicated to handling this issue. I&#x27;d like to call their library functions but they are all in private-looking namespaces. I also tried to use the Abseil failure signal handler but it often fails to unwind and even when it does unwind has a habit of just printing unknown for the symbol name or file, and never prints the DSO base addresses.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>