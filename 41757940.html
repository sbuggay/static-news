<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1728378068696" as="style"/><link rel="stylesheet" href="styles.css?v=1728378068696"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://r.ena.to/blog/optimizing-postgres-table-layout-for-maximum-efficiency/">Optimizing Postgres table layout for maximum efficiency</a> <span class="domain">(<a href="https://r.ena.to">r.ena.to</a>)</span></div><div class="subtext"><span>napsterbr</span> | <span>52 comments</span></div><br/><div><div id="41770089" class="c"><input type="checkbox" id="c-41770089" checked=""/><div class="controls bullet"><span class="by">johnthuss</span><span>|</span><a href="#41774123">next</a><span>|</span><label class="collapse" for="c-41770089">[-]</label><label class="expand" for="c-41770089">[10 more]</label></div><br/><div class="children"><div class="content">This is a super useful thing to know and I&#x27;m thankful for this article highlighting this aspect of Postgres.<p>But I would disagree with the takeaway to focus on optimizing your indexes and not your tables. The reason is that the order of columns in a multi-column index is highly meaningful and intentional in order to support match on a range of values for the last column in the index. The way databases work you can only utilize a multi-column index on (customer_id int4, date timestamp) if have an equality match on customer_id, like &quot;WHERE customer_id = 1 AND BETWEEN &#x27;2024-01-01&#x27; and &#x27;2025-01-01&#x27;&quot;. If you reorder these columns in the index to put the larger date column first, then, sure, you save space in the index, but you also make it worthless – it will never be used by the query above. As such, optimizing a multi-column index is only useful when all the columns are queried for equality rather than a range.<p>In contrast, when you are creating a NEW table you might not think hard about the order of the columns in the table, and especially not about the data-sizes of each column and their alignment. But doing so at the time you create the table can be tremendously beneficial if it is going to be very large. It is important to note that you not only save space on-disk, but in precious RAM when the tuples are loaded.</div><br/><div id="41773526" class="c"><input type="checkbox" id="c-41773526" checked=""/><div class="controls bullet"><span class="by">rand_r</span><span>|</span><a href="#41770089">parent</a><span>|</span><a href="#41770482">next</a><span>|</span><label class="collapse" for="c-41773526">[-]</label><label class="expand" for="c-41773526">[4 more]</label></div><br/><div class="children"><div class="content">This is sort of an aside, but a very interesting thing about Postgres is that it can efficiently combine independent column indexes together, so there is much less of a need, compared to older databases, to even create multi-column indexes. It&#x27;s a feature from 8.1 called &quot;Bitmap Scan&quot;. Basically, if you create an index on column X and an index on column Y, it can use them  to do queries involving either or both columns pretty efficiently (for any number of columns).<p>It&#x27;s not as fast as a multi-column index, but the savings of not having to worry about all the combinations of columns that can be queried together could well be worth it.<p>- <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;release&#x2F;8.1.0&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;release&#x2F;8.1.0&#x2F;</a><p>- <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;indexes-bitmap-scans.html" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;indexes-bitmap-scans...</a></div><br/><div id="41774461" class="c"><input type="checkbox" id="c-41774461" checked=""/><div class="controls bullet"><span class="by">williamdclt</span><span>|</span><a href="#41770089">root</a><span>|</span><a href="#41773526">parent</a><span>|</span><a href="#41774352">next</a><span>|</span><label class="collapse" for="c-41774461">[-]</label><label class="expand" for="c-41774461">[2 more]</label></div><br/><div class="children"><div class="content">It’s very cool, but at high throughput you really see the difference. This bitmap scan can take huge amounts of cpu, reduced to nothing (and much faster) when setting up a proper multi column index.<p>On small&#x2F;medium tables and lowish throughout though, yeah it’s often good enough and avoids having many indexes for specific use cases (which is a cost in itself, in memory&#x2F;cpu&#x2F;storage)</div><br/><div id="41774765" class="c"><input type="checkbox" id="c-41774765" checked=""/><div class="controls bullet"><span class="by">jamespo</span><span>|</span><a href="#41770089">root</a><span>|</span><a href="#41774461">parent</a><span>|</span><a href="#41774352">next</a><span>|</span><label class="collapse" for="c-41774765">[-]</label><label class="expand" for="c-41774765">[1 more]</label></div><br/><div class="children"><div class="content">Do you have any benchmarks? Be interesting to compare.</div><br/></div></div></div></div><div id="41774352" class="c"><input type="checkbox" id="c-41774352" checked=""/><div class="controls bullet"><span class="by">Pamar</span><span>|</span><a href="#41770089">root</a><span>|</span><a href="#41773526">parent</a><span>|</span><a href="#41774461">prev</a><span>|</span><a href="#41770482">next</a><span>|</span><label class="collapse" for="c-41774352">[-]</label><label class="expand" for="c-41774352">[1 more]</label></div><br/><div class="children"><div class="content">Bitmap Scan sounds a lot like Rushmore technology in Foxpro[1]. Are they the same?<p>1) <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;FoxPro" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;FoxPro</a><p>It is difficult to find a complete explanation for Rushmore nowadays, from what I remember, it would create a bitmap where each bit represented the nth record of the table you wanted to search, then with a single, fast sequential scan it would set the nth bit to 1 if the record satisfied all clauses of your search, 0 otherwise.<p>Try to see if this makes any sense to you: <a href="http:&#x2F;&#x2F;www.foxpert.com&#x2F;docs&#x2F;howfoxproworks.en.htm" rel="nofollow">http:&#x2F;&#x2F;www.foxpert.com&#x2F;docs&#x2F;howfoxproworks.en.htm</a></div><br/></div></div></div></div><div id="41770482" class="c"><input type="checkbox" id="c-41770482" checked=""/><div class="controls bullet"><span class="by">jeltz</span><span>|</span><a href="#41770089">parent</a><span>|</span><a href="#41773526">prev</a><span>|</span><a href="#41770450">next</a><span>|</span><label class="collapse" for="c-41770482">[-]</label><label class="expand" for="c-41770482">[2 more]</label></div><br/><div class="children"><div class="content">This is a limitation which is currently being worked on. The order will still matter of course but it will allow PostgreSQL to make some use of indexes even when the order of coulums does not match.<p><a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;message-id&#x2F;CAH2-Wzmn1YsLzOGgjAQZdn1STSG_y8qP__vggTaPAYXJP%2BG4bw%40mail.gmail.com" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;message-id&#x2F;CAH2-Wzmn1YsLzOGgjAQZd...</a></div><br/><div id="41771197" class="c"><input type="checkbox" id="c-41771197" checked=""/><div class="controls bullet"><span class="by">johnthuss</span><span>|</span><a href="#41770089">root</a><span>|</span><a href="#41770482">parent</a><span>|</span><a href="#41770450">next</a><span>|</span><label class="collapse" for="c-41771197">[-]</label><label class="expand" for="c-41771197">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt;&gt; This is
feasible in cases where the total number of distinct values in the
column &#x27;a&#x27; is reasonably small (think tens or hundreds, perhaps even
thousands for very large composite indexes).<p>It&#x27;s great this is improving, but this is a fairly narrow improvement. Personally, the multi-column indexes I use would not be improved by this change since column &#x27;a&#x27; does not store a &quot;reasonably small&quot; distribution of values.</div><br/></div></div></div></div><div id="41770450" class="c"><input type="checkbox" id="c-41770450" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#41770089">parent</a><span>|</span><a href="#41770482">prev</a><span>|</span><a href="#41774123">next</a><span>|</span><label class="collapse" for="c-41770450">[-]</label><label class="expand" for="c-41770450">[3 more]</label></div><br/><div class="children"><div class="content">This (index ordering resulting in useless indices) is not true, at least not in newer versions of Postgres (I just tried with 15).<p>While the query will take much longer (for me, it was about 47 msec vs 0.6 msec for 2,000,000 rows), it still uses the index.<p>Similarly, while normally you wouldn’t expect a query using predicate Y to use an index defined on columns (X, Y, Z) if predicate X is also not referenced, Postgres may choose to do so, depending on table stats, and the relative difference between random_page_cost and seq_page_cost. I’ve seen it happen before.</div><br/><div id="41771899" class="c"><input type="checkbox" id="c-41771899" checked=""/><div class="controls bullet"><span class="by">ghusbands</span><span>|</span><a href="#41770089">root</a><span>|</span><a href="#41770450">parent</a><span>|</span><a href="#41774123">next</a><span>|</span><label class="collapse" for="c-41771899">[-]</label><label class="expand" for="c-41771899">[2 more]</label></div><br/><div class="children"><div class="content">&gt; This (index ordering resulting in useless indices) is not true, at least not in newer versions of Postgres (I just tried with 15).<p>&gt; While the query will take much longer (for me, it was about 47 msec vs 0.6 msec for 2,000,000 rows), it still uses the index.<p>I&#x27;d argue that something being 78x slower can make it pretty useless, but it is indeed at least used, in some cases.</div><br/><div id="41772066" class="c"><input type="checkbox" id="c-41772066" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#41770089">root</a><span>|</span><a href="#41771899">parent</a><span>|</span><a href="#41774123">next</a><span>|</span><label class="collapse" for="c-41772066">[-]</label><label class="expand" for="c-41772066">[1 more]</label></div><br/><div class="children"><div class="content">Certainly I wouldn’t encourage this, no, but it <i>is</i> possible, and is still usually faster than a sequential scan.</div><br/></div></div></div></div></div></div></div></div><div id="41774123" class="c"><input type="checkbox" id="c-41774123" checked=""/><div class="controls bullet"><span class="by">branko_d</span><span>|</span><a href="#41770089">prev</a><span>|</span><a href="#41771274">next</a><span>|</span><label class="collapse" for="c-41774123">[-]</label><label class="expand" for="c-41774123">[3 more]</label></div><br/><div class="children"><div class="content">From the article:<p><pre><code>  Having the data aligned ensures faster access time when retrieving pages from disk.
</code></pre>
Byte-level alignment cannot possibly have anything to do with retrieving pages from disk, simply because the unit of retrieval is the whole page. From the hardware&#x2F;OS perspective, a page is just an opaque blob of bytes (comprised from one or more blocks on the physical drive).<p>Only after these bytes have reached RAM does the byte-level alignment play a role, because CPU works slower on misaligned data.<p>The article itself then goes on to illustrates the above (and seemingly contradict itself):<p><pre><code>  SQLite does not pad or align columns within a row. Everything is tightly packed together using minimal space. Two consequences of this design:

  SQLite has to work harder (use more CPU cycles) to access data within a row once it has that row in memory.
  SQLite uses fewer bytes on disk, less memory, and spends less time moving content around because there are fewer bytes to move.</code></pre></div><br/><div id="41774212" class="c"><input type="checkbox" id="c-41774212" checked=""/><div class="controls bullet"><span class="by">winternewt</span><span>|</span><a href="#41774123">parent</a><span>|</span><a href="#41771274">next</a><span>|</span><label class="collapse" for="c-41774212">[-]</label><label class="expand" for="c-41774212">[2 more]</label></div><br/><div class="children"><div class="content">I think the idea is that padding results in lower storage efficiency, which means fewer rows per page and hence lower I&#x2F;O throughput. By changing the column order you can reduce the amount of padding required.</div><br/><div id="41774371" class="c"><input type="checkbox" id="c-41774371" checked=""/><div class="controls bullet"><span class="by">branko_d</span><span>|</span><a href="#41774123">root</a><span>|</span><a href="#41774212">parent</a><span>|</span><a href="#41771274">next</a><span>|</span><label class="collapse" for="c-41774371">[-]</label><label class="expand" for="c-41774371">[1 more]</label></div><br/><div class="children"><div class="content">Sure, having less padding increases I&#x2F;O efficiency. I was just commenting on the author&#x27;s apparent confusion as to why the padding is there in the first place.<p>Here is the full(er) quote:<p><pre><code>  Postgres will happily add padding to the underlying data in order to make sure it is properly aligned at the physical layer. Having the data aligned ensures faster access time when retrieving pages from disk.
</code></pre>
This might be misunderstood as &quot;Postgres adds padding to speed-up disk I&#x2F;O&quot;, which is the opposite of what actually happens. Padding slows-down I&#x2F;O but speeds-up the CPU processing afterwards.<p>SQLite made the opposite tradeoff.</div><br/></div></div></div></div></div></div><div id="41771274" class="c"><input type="checkbox" id="c-41771274" checked=""/><div class="controls bullet"><span class="by">gnfargbl</span><span>|</span><a href="#41774123">prev</a><span>|</span><a href="#41769965">next</a><span>|</span><label class="collapse" for="c-41771274">[-]</label><label class="expand" for="c-41771274">[2 more]</label></div><br/><div class="children"><div class="content">The ever-useful postgres_dba tool (<a href="https:&#x2F;&#x2F;github.com&#x2F;NikolayS&#x2F;postgres_dba">https:&#x2F;&#x2F;github.com&#x2F;NikolayS&#x2F;postgres_dba</a>) can help with this. Install it, start psql, run :dba and choose option p1 to see how much table space you would save by reordering your columns.</div><br/><div id="41772369" class="c"><input type="checkbox" id="c-41772369" checked=""/><div class="controls bullet"><span class="by">samokhvalov</span><span>|</span><a href="#41771274">parent</a><span>|</span><a href="#41769965">next</a><span>|</span><label class="collapse" for="c-41772369">[-]</label><label class="expand" for="c-41772369">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for mentioning!</div><br/></div></div></div></div><div id="41769965" class="c"><input type="checkbox" id="c-41769965" checked=""/><div class="controls bullet"><span class="by">wccrawford</span><span>|</span><a href="#41771274">prev</a><span>|</span><a href="#41770328">next</a><span>|</span><label class="collapse" for="c-41769965">[-]</label><label class="expand" for="c-41769965">[3 more]</label></div><br/><div class="children"><div class="content">Interesting.  But if this is important, why doesn&#x27;t Postgres do it invisibly, automatically?  Surely there&#x27;s a most-correct sequence, with the longest values first, and the shortest values last, and then (probably) the variable-length values?<p>It could then happily report back the data in the order that the DB Admin&#x2F;developer expects.</div><br/><div id="41770566" class="c"><input type="checkbox" id="c-41770566" checked=""/><div class="controls bullet"><span class="by">jeltz</span><span>|</span><a href="#41769965">parent</a><span>|</span><a href="#41770049">next</a><span>|</span><label class="collapse" for="c-41770566">[-]</label><label class="expand" for="c-41770566">[1 more]</label></div><br/><div class="children"><div class="content">Because nobody has implemented it yet. A patch would be very welcome by many but nobody has written one.</div><br/></div></div><div id="41770049" class="c"><input type="checkbox" id="c-41770049" checked=""/><div class="controls bullet"><span class="by">j45</span><span>|</span><a href="#41769965">parent</a><span>|</span><a href="#41770566">prev</a><span>|</span><a href="#41770328">next</a><span>|</span><label class="collapse" for="c-41770049">[-]</label><label class="expand" for="c-41770049">[1 more]</label></div><br/><div class="children"><div class="content">Updating column rows in MySQL is pretty trivial, and I&#x27;ve wondered why it&#x27;s not the same in Postgres, even at the GUI level.<p>Ordering columns for performance might be a different order of reccomendation.</div><br/></div></div></div></div><div id="41770328" class="c"><input type="checkbox" id="c-41770328" checked=""/><div class="controls bullet"><span class="by">rtuin</span><span>|</span><a href="#41769965">prev</a><span>|</span><a href="#41771082">next</a><span>|</span><label class="collapse" for="c-41770328">[-]</label><label class="expand" for="c-41770328">[17 more]</label></div><br/><div class="children"><div class="content">It’s really something you don’t know how this applies to your Postgres DB, until you run into a situation where you do.<p>The author explains this very well, it’s a good read! I’ve learned about this padding little over a year ago, while I was designing a data intensive application with a colleague. I was skeptical about the advantage at first, but for our specific design, where we have 100 to 480+ columns in one table it makes a huge difference on table store size. Not so much on the indexes, though.</div><br/><div id="41770548" class="c"><input type="checkbox" id="c-41770548" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#41770328">parent</a><span>|</span><a href="#41771082">next</a><span>|</span><label class="collapse" for="c-41770548">[-]</label><label class="expand" for="c-41770548">[16 more]</label></div><br/><div class="children"><div class="content">&gt; where we have 100 to 480+ columns in one table<p>I’m sorry, what? Why?</div><br/><div id="41774058" class="c"><input type="checkbox" id="c-41774058" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#41770328">root</a><span>|</span><a href="#41770548">parent</a><span>|</span><a href="#41770815">next</a><span>|</span><label class="collapse" for="c-41774058">[-]</label><label class="expand" for="c-41774058">[3 more]</label></div><br/><div class="children"><div class="content">Not OP but in similar situation. Main reason is that the primary tables represent various official declarations, and they have a <i>lot</i> of fields. In addition, our customers are required by law to keep the data readily available for 5-10 years. Also the law states our customers are responsible for the data they send through our systems, so they want to see what they&#x27;re sending.<p>So just to give an example of how field count &quot;blows up&quot;, there can be up to 8 different parties related to a single declaration, and for each we want to have for display&#x2F;print purposes our internal id, id in customers system, organization number, name, address, postal code, location, country code, contact person, contact person phone and email.<p>So we&#x27;re talking about almost 100 fields just to store parties.<p>We want to store all that separate from say our &quot;companies&quot; table as a company might change name, location etc, and we&#x27;re required to show&#x2F;print the details from today 5+ years down the line.<p>We could put that in a separate table, but that means 8 joins to fetch data for a single record just there. And that&#x27;s just one piece of the declarations, and at least 3-4 of these parties our customers want to see in overview grids and be able to filter on there.<p>Now tack on 20+ years of doing this, with various official systems coming and going with different technical requirements, and it adds up.</div><br/><div id="41774586" class="c"><input type="checkbox" id="c-41774586" checked=""/><div class="controls bullet"><span class="by">mkesper</span><span>|</span><a href="#41770328">root</a><span>|</span><a href="#41774058">parent</a><span>|</span><a href="#41770815">next</a><span>|</span><label class="collapse" for="c-41774586">[-]</label><label class="expand" for="c-41774586">[2 more]</label></div><br/><div class="children"><div class="content">Sounds like it&#x27;s rife to convert to JSON fields maybe?</div><br/><div id="41774660" class="c"><input type="checkbox" id="c-41774660" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#41770328">root</a><span>|</span><a href="#41774586">parent</a><span>|</span><a href="#41770815">next</a><span>|</span><label class="collapse" for="c-41774660">[-]</label><label class="expand" for="c-41774660">[1 more]</label></div><br/><div class="children"><div class="content">If we could limit us to only PostgreSQL we could perhaps do that for new modules. Sadly we have some customers which want to use their own MSSQL database.<p>Though we&#x27;ll see what the future holds. PostgreSQL is interesting due to cost and features, and many of the large customers are shifting their POV on how they want to run things, almost doing 180&#x27;s in some cases.</div><br/></div></div></div></div></div></div><div id="41770815" class="c"><input type="checkbox" id="c-41770815" checked=""/><div class="controls bullet"><span class="by">rtuin</span><span>|</span><a href="#41770328">root</a><span>|</span><a href="#41770548">parent</a><span>|</span><a href="#41774058">prev</a><span>|</span><a href="#41772190">next</a><span>|</span><label class="collapse" for="c-41770815">[-]</label><label class="expand" for="c-41770815">[10 more]</label></div><br/><div class="children"><div class="content">Glad you asked!<p>This system contains measurements and state of physical devices (time series). It’s designed for both heavy write and read, with slight emphasis on write.
Each table is one type of device and contains 1 to 5 different measurements&#x2F;states. But here’s the trick: because data is queried with minimum bucket size of 15minutes I figured we could just create a  column for each measurement + quarter of the day (i.e. measure0000, measure0015), so that’s 100 columns for each measurement (96 quarter + 4 for DST), include the date in the key, et voila: excellent write performance (because it’s mainly UPDATE queries) and good read performance.<p>Okay, the queries to make sense of the data aren’t pretty, but can be generated.<p>I find it really cool how effective this is for time-series data without Postgres extensions (we’re on RDS).</div><br/><div id="41773115" class="c"><input type="checkbox" id="c-41773115" checked=""/><div class="controls bullet"><span class="by">sevensor</span><span>|</span><a href="#41770328">root</a><span>|</span><a href="#41770815">parent</a><span>|</span><a href="#41771322">next</a><span>|</span><label class="collapse" for="c-41773115">[-]</label><label class="expand" for="c-41773115">[2 more]</label></div><br/><div class="children"><div class="content">Fascinating. How reliable is the measurement apparatus? Or to put it another way, how tolerant of missed measurements is this scheme? I’ve been in a similar situation in a past life and we took a different approach.  I was never satisfied with how we ended up doing it though.</div><br/><div id="41774470" class="c"><input type="checkbox" id="c-41774470" checked=""/><div class="controls bullet"><span class="by">rtuin</span><span>|</span><a href="#41770328">root</a><span>|</span><a href="#41773115">parent</a><span>|</span><a href="#41771322">next</a><span>|</span><label class="collapse" for="c-41774470">[-]</label><label class="expand" for="c-41774470">[1 more]</label></div><br/><div class="children"><div class="content">I see your point. Some of our measurements are counters and interpolate missing data via certain rules. We store these interpolations in a separate table with exactly the same format and join the two tables directly when querying the data. Since the real value always takes precedence over the interpolated value this is just a COALESCE(realmeasure0000, interpolation0000) statement.<p>This is super fast when taking advantage of postgres&#x27; partition-wise joins.</div><br/></div></div></div></div><div id="41771322" class="c"><input type="checkbox" id="c-41771322" checked=""/><div class="controls bullet"><span class="by">aidos</span><span>|</span><a href="#41770328">root</a><span>|</span><a href="#41770815">parent</a><span>|</span><a href="#41773115">prev</a><span>|</span><a href="#41772233">next</a><span>|</span><label class="collapse" for="c-41771322">[-]</label><label class="expand" for="c-41771322">[3 more]</label></div><br/><div class="children"><div class="content">The updates wouldn’t be in place anyway because of the Postgres mvcc approach, right?<p>I can see the advantage in terms of just needing a single tuple for a reads. So a timestamp + value model would likely take twice as much heap space than your approach?<p>Given that you’re probably always just inserting new data you could use a brin index to get fast reads on the date ranges. Would be interesting to see it in action and play around to see the tradeoffs. The model you’ve settled on sounds like it would be a pain to query.</div><br/><div id="41774394" class="c"><input type="checkbox" id="c-41774394" checked=""/><div class="controls bullet"><span class="by">rtuin</span><span>|</span><a href="#41770328">root</a><span>|</span><a href="#41771322">parent</a><span>|</span><a href="#41772102">next</a><span>|</span><label class="collapse" for="c-41774394">[-]</label><label class="expand" for="c-41774394">[1 more]</label></div><br/><div class="children"><div class="content">Good observation. The updates are as much HOT-updates as possible. I wasn&#x27;t familiar with BRIN-indexes before, so I have to look into that.<p>At first glance our solution follows a similar approach, let me elaborate:<p>- no index columns are updated ever, only inserted<p>- all tables are partitioned based on date (partition range is 1 month)<p>- for some tables there is another layer of partitioning (3 sub-partitions, based on one specific column)<p>- finding an appropriate fillfactor is important to improve the speed of UPDATE statements (HOT-updates)<p>- standard vacuum &#x2F; auto vacuum settings work great for us so far.<p>- to improve ANALYZE performance, set column statistics of value-only columns to 0.</div><br/></div></div><div id="41772102" class="c"><input type="checkbox" id="c-41772102" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#41770328">root</a><span>|</span><a href="#41771322">parent</a><span>|</span><a href="#41774394">prev</a><span>|</span><a href="#41772233">next</a><span>|</span><label class="collapse" for="c-41772102">[-]</label><label class="expand" for="c-41772102">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The updates wouldn’t be in place anyway because of the Postgres mvcc approach, right?<p>They might be if the columns being updated weren’t indexed [0], but since it sounds like at least one is, no, not in-place.<p>Though interestingly, your comment on BRIN indexes is quite relevant, as that’s the one type of index that HOT can still work with.<p>[0]: <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;storage-hot.html" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;storage-hot.html</a></div><br/></div></div></div></div><div id="41772233" class="c"><input type="checkbox" id="c-41772233" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#41770328">root</a><span>|</span><a href="#41770815">parent</a><span>|</span><a href="#41771322">prev</a><span>|</span><a href="#41770939">next</a><span>|</span><label class="collapse" for="c-41772233">[-]</label><label class="expand" for="c-41772233">[2 more]</label></div><br/><div class="children"><div class="content">I assume you looked at the various Postgres functions, like width_bucket()?<p>I’ve never ran a PG-based TSDB so I’m reluctant to pass judgment one way or the other, but as I hope you can understand, “we have hundreds of columns in a table” is alarming at first glance.</div><br/><div id="41774436" class="c"><input type="checkbox" id="c-41774436" checked=""/><div class="controls bullet"><span class="by">rtuin</span><span>|</span><a href="#41770328">root</a><span>|</span><a href="#41772233">parent</a><span>|</span><a href="#41770939">next</a><span>|</span><label class="collapse" for="c-41774436">[-]</label><label class="expand" for="c-41774436">[1 more]</label></div><br/><div class="children"><div class="content">The schema is organized by how we need to query it which is mostly by fetching all measurements for an entire day or month. Querying statistics on those metrics is not often needed, maybe a few times per week or day, so we do that in Snowflake if necessary. Or create a specialized streaming data flow when it the stats are queried more often.</div><br/></div></div></div></div><div id="41770939" class="c"><input type="checkbox" id="c-41770939" checked=""/><div class="controls bullet"><span class="by">napsterbr</span><span>|</span><a href="#41770328">root</a><span>|</span><a href="#41770815">parent</a><span>|</span><a href="#41772233">prev</a><span>|</span><a href="#41772190">next</a><span>|</span><label class="collapse" for="c-41770939">[-]</label><label class="expand" for="c-41770939">[2 more]</label></div><br/><div class="children"><div class="content">One interesting thing your team may want to look into (if you haven&#x27;t already) is compression.<p>Of course there are a multitude of variables we don&#x27;t have access from the outside, but Postgres only compresses data that is TOASTed, and based on your description of the table, the data is not being TOASTed (and therefore not being compressed).<p>Instead, if you could somehow pack your timeseries entries into an array, you would get the benefits of compression automatically.<p>Given your write performance requirements, using an array may be out-of-question (and you may get too much overhead from dead tuples) -- but who knows? Always a good idea to benchmark.<p>I actually considered mentioning this at the post but figured it was too long already and could be the material for a future one :)</div><br/><div id="41774507" class="c"><input type="checkbox" id="c-41774507" checked=""/><div class="controls bullet"><span class="by">rtuin</span><span>|</span><a href="#41770328">root</a><span>|</span><a href="#41770939">parent</a><span>|</span><a href="#41772190">next</a><span>|</span><label class="collapse" for="c-41774507">[-]</label><label class="expand" for="c-41774507">[1 more]</label></div><br/><div class="children"><div class="content">This is interesting! Turning the values into arrays is not suitable for our base-tables, but might be for the several materialization tables we run.</div><br/></div></div></div></div></div></div><div id="41772190" class="c"><input type="checkbox" id="c-41772190" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#41770328">root</a><span>|</span><a href="#41770548">parent</a><span>|</span><a href="#41770815">prev</a><span>|</span><a href="#41771082">next</a><span>|</span><label class="collapse" for="c-41772190">[-]</label><label class="expand" for="c-41772190">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know what they&#x27;re doing, but highly-denormalized tables are very common, and sometimes even the norm, depending on how things are set up, especially in OLAP contexts.</div><br/><div id="41772248" class="c"><input type="checkbox" id="c-41772248" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#41770328">root</a><span>|</span><a href="#41772190">parent</a><span>|</span><a href="#41771082">next</a><span>|</span><label class="collapse" for="c-41772248">[-]</label><label class="expand" for="c-41772248">[1 more]</label></div><br/><div class="children"><div class="content">Highly denormalized tables are often the norm simply because the tables weren’t properly normalized to begin with, and the data model wasn’t properly done, such that reasonable joins are overly difficult.<p>OLAP is of course its own problem, and most of the best practices for OLTP do not apply.</div><br/></div></div></div></div></div></div></div></div><div id="41771082" class="c"><input type="checkbox" id="c-41771082" checked=""/><div class="controls bullet"><span class="by">didgetmaster</span><span>|</span><a href="#41770328">prev</a><span>|</span><a href="#41769755">next</a><span>|</span><label class="collapse" for="c-41771082">[-]</label><label class="expand" for="c-41771082">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s been awhile since I dug into the bowels of PG; but the overall row size with respect to page size used to be important. If you had a table where every row took up 4097 bytes and the page size was 8K; the your disk footprint for that table was double. Only one row fit in a page and the other (nearly) half of each page was wasted.<p>If that is still true, then alignment issues could push you over the edge if you are close to it.</div><br/></div></div><div id="41769755" class="c"><input type="checkbox" id="c-41769755" checked=""/><div class="controls bullet"><span class="by">remus</span><span>|</span><a href="#41771082">prev</a><span>|</span><a href="#41770750">next</a><span>|</span><label class="collapse" for="c-41769755">[-]</label><label class="expand" for="c-41769755">[6 more]</label></div><br/><div class="children"><div class="content">Very interesting, but I think the author overstates the importance of alignment a little. Unless your data&#x2F;indexes are already of a challenging size (or you expect them to be imminently) for your hardware then fiddling with byte alignment details feels like a fairly premature optimisation.<p>Disk is cheap, memory is plentiful, your time is expensive etc.</div><br/><div id="41770032" class="c"><input type="checkbox" id="c-41770032" checked=""/><div class="controls bullet"><span class="by">egnehots</span><span>|</span><a href="#41769755">parent</a><span>|</span><a href="#41770615">next</a><span>|</span><label class="collapse" for="c-41770032">[-]</label><label class="expand" for="c-41770032">[2 more]</label></div><br/><div class="children"><div class="content">As mentioned in the article, it&#x27;s a good idea to consider this when creating a new table, since it&#x27;s essentially a free optimization. However, it&#x27;s probably not worth the hassle of reordering a production table for that.<p>&gt; Disk is cheap, memory is plentiful, but your time is expensive, etc.<p>One thing to keep in mind, though, is that while you often have plenty of disk space, RAM is still relatively expensive. It&#x27;s also divided into many smaller buffers, such as working memory and shared buffers, which are not that large. These optimizations help to fit more data into cache.<p>However, what the article said about alignment being important for indexes is somewhat misleading. Reordering an index field is not the same as reordering columns in a table. Beside having to rewrite queries, it also changes the access pattern and the time required to access the data, which is often much more significant than the space saved. Indexes are, by nature, a tradeoff where you give up space to gain time, so this mindset doesn&#x27;t really apply there.</div><br/><div id="41770129" class="c"><input type="checkbox" id="c-41770129" checked=""/><div class="controls bullet"><span class="by">napsterbr</span><span>|</span><a href="#41769755">root</a><span>|</span><a href="#41770032">parent</a><span>|</span><a href="#41770615">next</a><span>|</span><label class="collapse" for="c-41770129">[-]</label><label class="expand" for="c-41770129">[1 more]</label></div><br/><div class="children"><div class="content">Hey, author here.<p>&gt; Indexes are, by nature, a tradeoff where you give up space to gain time, so this mindset doesn&#x27;t really apply there.<p>I agree that (re)aligning indexes are a different beast entirely, but (as mentioned in my recommendation) ideally the developer should keep this in mind when creating the index initially.<p>Factors like cardinality and even readability should take precedence over perfect alignment, but all else being equal, aligning your indexes from the very moment they are introduced in the codebase is the ideal scenario IMO.</div><br/></div></div></div></div><div id="41770615" class="c"><input type="checkbox" id="c-41770615" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#41769755">parent</a><span>|</span><a href="#41770032">prev</a><span>|</span><a href="#41769807">next</a><span>|</span><label class="collapse" for="c-41770615">[-]</label><label class="expand" for="c-41770615">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Disk is cheap, memory is plentiful, your time is expensive etc.<p>Spend 30 minutes one day playing around with Postgres, trying different column combinations out. Boom, you now know how best to order columns. This doesn’t seem like a big ask.<p>The flip side is that changing data at scale is HARD, so if you put things like this off, when you do finally need to squeeze bytes, it’s painful.<p>Also, memory is absolutely not plentiful. That’s generally the biggest bottleneck (or rather, the lack of it then makes IO the bottleneck) for an RDBMS, assuming you have connection pooling and aren’t saturating the CPU with overhead.</div><br/></div></div><div id="41769807" class="c"><input type="checkbox" id="c-41769807" checked=""/><div class="controls bullet"><span class="by">koolba</span><span>|</span><a href="#41769755">parent</a><span>|</span><a href="#41770615">prev</a><span>|</span><a href="#41772221">next</a><span>|</span><label class="collapse" for="c-41769807">[-]</label><label class="expand" for="c-41769807">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Disk is cheap, memory is plentiful, your time is expensive etc.<p>Taking the time to know the in memory sizing for your data types is well worth it. Taking the time to think about the types to use and sorting them by size is also minimal and well worth it.<p>It may make sense for the system to do it automatically for newly created tables. But maybe not as it’s possible you’d want the data layout to match some existing structure.</div><br/></div></div><div id="41772221" class="c"><input type="checkbox" id="c-41772221" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#41769755">parent</a><span>|</span><a href="#41769807">prev</a><span>|</span><a href="#41770750">next</a><span>|</span><label class="collapse" for="c-41772221">[-]</label><label class="expand" for="c-41772221">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Disk is cheap, memory is plentiful, your time is expensive etc.<p>Index size is not solely a storage concern. I also don&#x27;t really care about how much disk space I pay for, but sometimes I care a lot about how long it takes to vacuum a table.</div><br/></div></div></div></div><div id="41770750" class="c"><input type="checkbox" id="c-41770750" checked=""/><div class="controls bullet"><span class="by">SoftTalker</span><span>|</span><a href="#41769755">prev</a><span>|</span><a href="#41770346">next</a><span>|</span><label class="collapse" for="c-41770750">[-]</label><label class="expand" for="c-41770750">[2 more]</label></div><br/><div class="children"><div class="content">This is the sort of thing that good DBAs used to know about and manage, but nowadays that isn&#x27;t a fashionable job.</div><br/><div id="41772155" class="c"><input type="checkbox" id="c-41772155" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#41770750">parent</a><span>|</span><a href="#41770346">next</a><span>|</span><label class="collapse" for="c-41772155">[-]</label><label class="expand" for="c-41772155">[1 more]</label></div><br/><div class="children"><div class="content">It’s coming back in the form of DBRE (hi, it’s me), but unfortunately actual core RDBMS knowledge is often lacking. RDBMS administration is legitimately difficult, as they have a million knobs to turn, and a million gotchas that can tank performance if you aren’t careful. I should mention here that this difficulty really only occurs at scale. If your DB has a few million rows, as long as your queries are indexed it’s unlikely that you’ll experience problems. You probably won’t have optimal performance, but it’s likely to be good enough.<p>Personally, I love it, but also find it frustrating. The amount of times I’ve presented “here’s your problem, here’s how to fix it, sorry it’s gonna suck” only to be told “nah, we’ll just upsize the instance” is far too many.</div><br/></div></div></div></div><div id="41770346" class="c"><input type="checkbox" id="c-41770346" checked=""/><div class="controls bullet"><span class="by">OliverJones</span><span>|</span><a href="#41770750">prev</a><span>|</span><a href="#41772000">next</a><span>|</span><label class="collapse" for="c-41770346">[-]</label><label class="expand" for="c-41770346">[1 more]</label></div><br/><div class="children"><div class="content">Good material!<p>It has to be said, the order of columns in correctly designed multicolumn BTREE indexes is governed by the shape of the queries the indexes support.<p>So don&#x27;t arbitarily reorder columns in your indexes to handle alignment.</div><br/></div></div><div id="41772000" class="c"><input type="checkbox" id="c-41772000" checked=""/><div class="controls bullet"><span class="by">tiffanyh</span><span>|</span><a href="#41770346">prev</a><span>|</span><a href="#41770503">next</a><span>|</span><label class="collapse" for="c-41772000">[-]</label><label class="expand" for="c-41772000">[1 more]</label></div><br/><div class="children"><div class="content">How much of this article is rooted in hard drives with physically mechanical spinning disk latency assumptions, vs ssd&#x2F;nvme?</div><br/></div></div><div id="41770503" class="c"><input type="checkbox" id="c-41770503" checked=""/><div class="controls bullet"><span class="by">delduca</span><span>|</span><a href="#41772000">prev</a><span>|</span><a href="#41769782">next</a><span>|</span><label class="collapse" for="c-41770503">[-]</label><label class="expand" for="c-41770503">[3 more]</label></div><br/><div class="children"><div class="content">Could the Django ORM deal with this?</div><br/><div id="41770578" class="c"><input type="checkbox" id="c-41770578" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#41770503">parent</a><span>|</span><a href="#41770740">next</a><span>|</span><label class="collapse" for="c-41770578">[-]</label><label class="expand" for="c-41770578">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but it doesn’t that I’m aware of. Certainly able to override the classes yourself, though. Make a lookup table of column type &#x2F; length and then reorder based on that.</div><br/></div></div><div id="41770740" class="c"><input type="checkbox" id="c-41770740" checked=""/><div class="controls bullet"><span class="by">jbkkd</span><span>|</span><a href="#41770503">parent</a><span>|</span><a href="#41770578">prev</a><span>|</span><a href="#41769782">next</a><span>|</span><label class="collapse" for="c-41770740">[-]</label><label class="expand" for="c-41770740">[1 more]</label></div><br/><div class="children"><div class="content">It can&#x27;t right now, but this is a doable extension</div><br/></div></div></div></div><div id="41769782" class="c"><input type="checkbox" id="c-41769782" checked=""/><div class="controls bullet"><span class="by">koolba</span><span>|</span><a href="#41770503">prev</a><span>|</span><label class="collapse" for="c-41769782">[-]</label><label class="expand" for="c-41769782">[2 more]</label></div><br/><div class="children"><div class="content">The content itself is fine but the unnecessary image above the label “ <i>You have the right to remain aligned</i>” with the usual AI-generated garbage text cheapens the entire article.</div><br/><div id="41769841" class="c"><input type="checkbox" id="c-41769841" checked=""/><div class="controls bullet"><span class="by">loloquwowndueo</span><span>|</span><a href="#41769782">parent</a><span>|</span><label class="collapse" for="c-41769841">[-]</label><label class="expand" for="c-41769841">[1 more]</label></div><br/><div class="children"><div class="content">Are you kidding, that image is hilarious.<p>(Articles that intersperse annoying memes every 3 paragraphs with obnoxious gif animations are much much worse).</div><br/></div></div></div></div></div></div></div></div></div></body></html>