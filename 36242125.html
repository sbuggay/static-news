<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1686301251749" as="style"/><link rel="stylesheet" href="styles.css?v=1686301251749"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a>Launch HN: Infield (YC W20) – Safer, faster dependency upgrades</a> </div><div class="subtext"><span>stevepike</span> | <span>30 comments</span></div><br/><div><div id="36243832" class="c"><input type="checkbox" id="c-36243832" checked=""/><div class="controls bullet"><span class="by">ZeroCool2u</span><span>|</span><a href="#36244125">next</a><span>|</span><label class="collapse" for="c-36243832">[-]</label><label class="expand" for="c-36243832">[7 more]</label></div><br/><div class="children"><div class="content">Ruby is nice, but if you were to actually solve this problem for Python you&#x27;d print money. The deluge of knowledge required to actually navigate Python dependency management across all major OS&#x27;s for the most complex use cases (typically ML stuff with deep compiler&#x2F;tool chain deps) is nothing short of a nightmare. Especially on Windows, the rage I feel towards MSVC knows no bounds. venv, pip, (mini)conda, mamba, poetry, apt, yum... Obviously the last two are good to know anyways, but ugh the hours I&#x27;ve lost and will never get back to the rest.<p>Anyways, god speed my dudes.</div><br/><div id="36244030" class="c"><input type="checkbox" id="c-36244030" checked=""/><div class="controls bullet"><span class="by">stevepike</span><span>|</span><a href="#36243832">parent</a><span>|</span><a href="#36244109">next</a><span>|</span><label class="collapse" for="c-36244030">[-]</label><label class="expand" for="c-36244030">[3 more]</label></div><br/><div class="children"><div class="content">(founder here). The interaction between high level language package managers and system binaries or compiled extensions is definitely on our roadmap. For example the ruby net-ssh gem relies on specific versions of openssl being compiled on the machine. Do you think this is particularly difficult in ML?<p>Is your frustration mostly from needing compile all this non-python stuff across environments?</div><br/><div id="36254600" class="c"><input type="checkbox" id="c-36254600" checked=""/><div class="controls bullet"><span class="by">pabs3</span><span>|</span><a href="#36243832">root</a><span>|</span><a href="#36244030">parent</a><span>|</span><a href="#36244307">next</a><span>|</span><label class="collapse" for="c-36254600">[-]</label><label class="expand" for="c-36254600">[1 more]</label></div><br/><div class="children"><div class="content">Hmm, the Debian package of ruby-net-ssh doesn&#x27;t even depend on OpenSSL at all.</div><br/></div></div><div id="36244307" class="c"><input type="checkbox" id="c-36244307" checked=""/><div class="controls bullet"><span class="by">ZeroCool2u</span><span>|</span><a href="#36243832">root</a><span>|</span><a href="#36244030">parent</a><span>|</span><a href="#36254600">prev</a><span>|</span><a href="#36244109">next</a><span>|</span><label class="collapse" for="c-36244307">[-]</label><label class="expand" for="c-36244307">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, you&#x27;re right on the money. This is basically insane in ML, but _especially_ in corporate environments, think F500, where sudo is disabled in containers and experimentation (in terms of trying different package versions) is quite challenging due to security restrictions.<p>Frankly, it&#x27;s one of the reasons that we&#x27;re seeing a lot of excitement around stuff written in Rust, but with Python bindings[1][2]. Cargo makes it so easy to build across various platforms and then just produce statically compiled platform specific python wheels. If PyTorch and TF had been written using Rust, any other other ultra high perf language with a tool-chain as reliable as cargo, a lot of folks lives would be easier.<p>[1]: <a href="https:&#x2F;&#x2F;www.getdaft.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.getdaft.io&#x2F;</a><p>[2]: <a href="https:&#x2F;&#x2F;www.pola.rs&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.pola.rs&#x2F;</a></div><br/></div></div></div></div><div id="36244109" class="c"><input type="checkbox" id="c-36244109" checked=""/><div class="controls bullet"><span class="by">jchonphoenix</span><span>|</span><a href="#36243832">parent</a><span>|</span><a href="#36244030">prev</a><span>|</span><a href="#36246345">next</a><span>|</span><label class="collapse" for="c-36244109">[-]</label><label class="expand" for="c-36244109">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think you&#x27;d print money just by telling people if a dependency is hard or easy to install though. You&#x27;d need to actually solve the problem of getting the dependency installed or suggesting some alternative solution that gets the code written.<p>E.g. if I&#x27;m banging my head against a wall trying to upgrade to the newest version of PyTorch for some graph embeddings feature and everything breaks, knowing it&#x27;s high risk doesn&#x27;t help me. I still need to get the thing installed so I can use the feature.</div><br/><div id="36244179" class="c"><input type="checkbox" id="c-36244179" checked=""/><div class="controls bullet"><span class="by">ZeroCool2u</span><span>|</span><a href="#36243832">root</a><span>|</span><a href="#36244109">parent</a><span>|</span><a href="#36246345">next</a><span>|</span><label class="collapse" for="c-36244179">[-]</label><label class="expand" for="c-36244179">[1 more]</label></div><br/><div class="children"><div class="content">Okay yeah, totally agree. I already know it&#x27;s hard to install. If they gave me a path they were confident would work in terms of deps&#x2F;versions to upgrade to, that I would pay for if it worked well.</div><br/></div></div></div></div><div id="36246345" class="c"><input type="checkbox" id="c-36246345" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#36243832">parent</a><span>|</span><a href="#36244109">prev</a><span>|</span><a href="#36244125">next</a><span>|</span><label class="collapse" for="c-36246345">[-]</label><label class="expand" for="c-36246345">[1 more]</label></div><br/><div class="children"><div class="content">Do you work at a company forcing you to develop on Windows? You couldn&#x27;t pay to do to that.</div><br/></div></div></div></div><div id="36244125" class="c"><input type="checkbox" id="c-36244125" checked=""/><div class="controls bullet"><span class="by">SkyPuncher</span><span>|</span><a href="#36243832">prev</a><span>|</span><a href="#36251265">next</a><span>|</span><label class="collapse" for="c-36244125">[-]</label><label class="expand" for="c-36244125">[2 more]</label></div><br/><div class="children"><div class="content">I clicked into this because I was excited, but everything feels like it&#x27;s missing the mark for me. And, that pricing. Woof. That&#x27;s steep for being a fancy changelog interpreter.<p>----<p>My biggest pain isn&#x27;t with the plan. It&#x27;s with the actual upgrade process. Things _always_ break. Every single time we do a major upgrade, there&#x27;s this long tail of things we need to fix. Even worse is the undocumented changes that break. This gives me nightmares.<p>The problem with your product is four parts:<p>* It needs to solve much more of the problem. It&#x27;s not really valuable to know that I need to change stuff. I can figure that out by running my package managers update tool and seeing what breaks.<p>* When things break, it&#x27;s unbelievably time consuming to fix them. Even worse is the person tasked with doing the upgrade is likely not the subject matter expert on broken code.<p>* I need to know what&#x27;s broken that wasn&#x27;t documented. This is by far the hardest part of our upgrade cycles. It keeps me up at night knowing a major upgrade could break things that aren&#x27;t covered by unit tests.<p>* Because dependency upgrades are so hard, we tend to do them in large swoops. We set aside a week or two of pain and power through them. Given you&#x27;re charging $60&#x2F;m, this suggests:<p><pre><code>  * Your model is more aligned with small, continuous upgrades. Once you&#x27;re &quot;close&quot; to the most recent version, it tends to be easier to upgrade.

  * Your model needs a better way to &quot;gain pace&quot; with the latest releases. If I can incrementally upgrade one package on every PR until I&#x27;m up to date, that&#x27;d be amazing.
</code></pre>
-----<p>I think this tool would be extremely value to me (likely $60&#x2F;m&#x2F;repo) if it:<p>* It ran the repo&#x27;s test suite against progressively newer versions of dependencies. Showing when and where unit tests fail.<p>* Provide some means of &quot;intelligent E2E&quot; testing. Fire up our API&#x2F;application. Tell us what changes when dependencies are upgraded.<p>* Fan out broken code to the subject matter expert. If an upgrade from X to Y is broken, look at the `git blame` to figure out who knows how to fix the code. Ping them asking them for help.</div><br/><div id="36244792" class="c"><input type="checkbox" id="c-36244792" checked=""/><div class="controls bullet"><span class="by">stevepike</span><span>|</span><a href="#36244125">parent</a><span>|</span><a href="#36251265">next</a><span>|</span><label class="collapse" for="c-36244792">[-]</label><label class="expand" for="c-36244792">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the feedback. We know we&#x27;re tackling a big problem here. Our ultimate goal is that if you use Infield we keep you on the latest version of every dependency, automatically. The road to get there can go a number of ways.<p>&gt; My biggest pain isn&#x27;t with the plan. It&#x27;s with the actual upgrade process. Things _always_ break. Every single time we do a major upgrade, there&#x27;s this long tail of things we need to fix. Even worse is the undocumented changes that break. This gives me nightmares.<p>Planning is one way to make those major upgrades go wrong less often. Our idea is that we can break large upgrades down into incremental changes that are individually safe and mixed in to your regular dev cycles, so that when you go to do the large upgrade you&#x27;re not making such a big change all at once. This means things like fixing every deprecation ahead of time and making sure all the other dependencies you use are compatible with the version you&#x27;re upgrading to.<p>We&#x27;re calling this &quot;upgrade paths&quot; in our tool. Something like a major rails version upgrade is terrifying because of all the moving parts. Often you may have a dozen other gems that need to be upgraded in order to upgrade Rails. You said &quot;If I can incrementally upgrade one package on every PR until I&#x27;m up to date, that&#x27;d be amazing.&quot;. We want to make that the flow for major framework upgrades, so you&#x27;re merging in incremental improvements in the blocking dependencies ahead of time.<p>Undocumented breakages are for sure on our roadmap. We have two types in mind today:
  - Changes that are missing from the changelog
  - Incompatibilities across gems (for instance there was a time recently where if you had both datadog and newrelic installed and used elsaticsearch upgrading the newrelic gem would break prod)<p>We have some ideas on how to figure this out automatically (like reading code diffs with GPT rather than just changelogs), but the best way is to see upgrades out in the wild. As we see more and more upgrade experiences from our customers we&#x27;ll be able to catch these issues and build this dataset.<p>I&#x27;d love to hear other ideas for making major framework upgrades safer.<p>&gt; * It ran the repo&#x27;s test suite against progressively newer versions of dependencies. Showing when and where unit tests fail.<p>Would this be something like `git bisect` for upgrades? We run your CI to figure out where you can upgrade to without something breaking? We&#x27;re trying to figure this out statically by reading changelogs and building up a database of breaking changes. Our roadmap is to make this database better over time by pulling in more and more undocumented changes (by seeing customer upgrade experiences and by sourcing information from places like github issues). In my experience it&#x27;s more common (and much more dangerous) that things break when your dependency changes in a way that wouldn&#x27;t be caught by CI.</div><br/></div></div></div></div><div id="36251265" class="c"><input type="checkbox" id="c-36251265" checked=""/><div class="controls bullet"><span class="by">morgante</span><span>|</span><a href="#36244125">prev</a><span>|</span><a href="#36245422">next</a><span>|</span><label class="collapse" for="c-36251265">[-]</label><label class="expand" for="c-36251265">[2 more]</label></div><br/><div class="children"><div class="content">Congrats on the launch!<p>The dashboard looks really well done, especially the path identification.<p>I&#x27;m curious why you decided to start with Ruby. Anecdotally, it doesn&#x27;t seem as big of a problem as other languages with either (a) more upgrades or (b) worse package managers.<p>Disclosure: I&#x27;m the cofounder of <a href="https:&#x2F;&#x2F;grit.io" rel="nofollow">https:&#x2F;&#x2F;grit.io</a> which also does some dependency management, but focused on automating the actual code changes.</div><br/><div id="36251729" class="c"><input type="checkbox" id="c-36251729" checked=""/><div class="controls bullet"><span class="by">stevepike</span><span>|</span><a href="#36251265">parent</a><span>|</span><a href="#36245422">next</a><span>|</span><label class="collapse" for="c-36251729">[-]</label><label class="expand" for="c-36251729">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! We wanted to start with a language that&#x27;s relatively consolidated around a framework before expanding to more balkanized ones like JS.</div><br/></div></div></div></div><div id="36245422" class="c"><input type="checkbox" id="c-36245422" checked=""/><div class="controls bullet"><span class="by">ilikebits</span><span>|</span><a href="#36251265">prev</a><span>|</span><a href="#36245851">next</a><span>|</span><label class="collapse" for="c-36245422">[-]</label><label class="expand" for="c-36245422">[2 more]</label></div><br/><div class="children"><div class="content">How are you computing upgrade paths? This seems impossible to do accurately, especially for Ruby, since you can&#x27;t simulate the user&#x27;s build&#x27;s dependency resolution given that Gemfiles are dynamic.</div><br/><div id="36246160" class="c"><input type="checkbox" id="c-36246160" checked=""/><div class="controls bullet"><span class="by">stevepike</span><span>|</span><a href="#36245422">parent</a><span>|</span><a href="#36245851">next</a><span>|</span><label class="collapse" for="c-36246160">[-]</label><label class="expand" for="c-36246160">[1 more]</label></div><br/><div class="children"><div class="content">Can you expand a little? Here&#x27;s some technical background on what we&#x27;re doing:<p>We have our own database of every version of every rubygems package alongside its runtime dependencies (like you see at <a href="https:&#x2F;&#x2F;rubygems.org&#x2F;gems&#x2F;pundit" rel="nofollow">https:&#x2F;&#x2F;rubygems.org&#x2F;gems&#x2F;pundit</a>).<p>Then we parse your Gemfile and Gemfile.lock. We use the Gemfile to figure out gem group and pinned requirements (we run turn your Gemfile into a ruby AST since Gemfiles can be arbitrary ruby code; we use bundler&#x27;s APIs to parse your Gemfile.lock). This gives us all of the dependencies your rely on.<p>Then we let you choose one or more package that you want to upgrade and the version you want to target (let&#x27;s say Rails 7.0.4.3).<p>Now we have [your dependencies and their current versions], [target rails version], [all of the runtime dependency constraints of these gems]. We run this through a dependency resolution algorithm (pubgrub). If it resolves then you&#x27;re good to upgrade to that version of Rails without changing anything.<p>If this fails to resolve, it&#x27;s because one or more of your current dependencies has a runtime restriction on rails (or another indirect gem being pulled in by the new rails version). This is where the optimization part comes in. The problem becomes &quot;what is the optimal set of versions of all your dependencies that would resolve with the next version of Rails&quot;. Currently we solve for this set trying to optimize for the fewest upgrades. As our dataset of breaking changes gets better we&#x27;ll change that to optimizing for the &quot;lowest effort&quot;.<p>Happy to elaborate.</div><br/></div></div></div></div><div id="36245851" class="c"><input type="checkbox" id="c-36245851" checked=""/><div class="controls bullet"><span class="by">aorth</span><span>|</span><a href="#36245422">prev</a><span>|</span><a href="#36244080">next</a><span>|</span><label class="collapse" for="c-36245851">[-]</label><label class="expand" for="c-36245851">[2 more]</label></div><br/><div class="children"><div class="content">Sounds a bit like the Renovate bot <a href="https:&#x2F;&#x2F;docs.renovatebot.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.renovatebot.com&#x2F;</a>, but with LLM changelog parsing.<p>I started using Renovate on a few project recently and I am impressed. Not quite yet to the point of letting it merge dependency updates for me, but for unearthing them and creating a pull request (after which my tests run automatically) is already a big help.</div><br/><div id="36246174" class="c"><input type="checkbox" id="c-36246174" checked=""/><div class="controls bullet"><span class="by">ADLenehan</span><span>|</span><a href="#36245851">parent</a><span>|</span><a href="#36244080">next</a><span>|</span><label class="collapse" for="c-36246174">[-]</label><label class="expand" for="c-36246174">[1 more]</label></div><br/><div class="children"><div class="content">Andy here (Product at Infield). I&#x27;ve also been impressed with what I&#x27;ve seen from Renovate - particularly on the configuration side. How has it worked for you on major &#x2F; breaking upgrades?</div><br/></div></div></div></div><div id="36244080" class="c"><input type="checkbox" id="c-36244080" checked=""/><div class="controls bullet"><span class="by">setgree</span><span>|</span><a href="#36245851">prev</a><span>|</span><a href="#36244604">next</a><span>|</span><label class="collapse" for="c-36244080">[-]</label><label class="expand" for="c-36244080">[3 more]</label></div><br/><div class="children"><div class="content">Very cool! Is the LLM-on-the-backend a recent addition or have y&#x27;all been thinking about that potential since 2020? Would be curious to hear a bit more about your journey to market</div><br/><div id="36244680" class="c"><input type="checkbox" id="c-36244680" checked=""/><div class="controls bullet"><span class="by">stevepike</span><span>|</span><a href="#36244080">parent</a><span>|</span><a href="#36244604">next</a><span>|</span><label class="collapse" for="c-36244680">[-]</label><label class="expand" for="c-36244680">[2 more]</label></div><br/><div class="children"><div class="content">Thanks! We actually pivoted to working on this problem at the beginning of last year. We were previously called Syndetic and were building software for data providers. As we considered pivoting I spent some time thinking about the biggest problems I&#x27;ve faced maintaining software and started doing personal consulting. I upgraded a bunch of Rails and React apps for various companies over the course of 2022.<p>Toward the middle of last year I re-connected with Andy (our third cofounder) who I went to school with and have wanted to work on a company with for a long time. We did a bunch of customer discovery &#x2F; product work to figure out how to take what I learned doing this by hand and turn it into a software product. That was exciting enough that we decided to bring Andy on as a third co-founder and pivot our YC company.<p>Allison and my background is in building data businesses. Before Infield and Syndetic we worked at a startup in the beverage industry where we standardized inventory data for every alcohol product sold in the US. As we got into building Infield we didn&#x27;t expect to use LLMs at all. We imagined a similar human-in-the-loop expert system to what we&#x27;ve built before.<p>I&#x27;ve been extremely impressed with recent language model&#x27;s ability to handle unstructured changelog text. For example, consider the following snippet of a changelog:<p><pre><code>  Security:
  - Address an issue with password validation

  Breaking change:
  - The `foo?` method now returns a boolean instead of int
</code></pre>
Language models can carry the context through, so we are able to not just parse this apart into discrete changes (which I could figure out how to do with a regex) but also bring in context and categorize them. It can do this generically and really feels like something new.</div><br/><div id="36246261" class="c"><input type="checkbox" id="c-36246261" checked=""/><div class="controls bullet"><span class="by">setgree</span><span>|</span><a href="#36244080">root</a><span>|</span><a href="#36244680">parent</a><span>|</span><a href="#36244604">next</a><span>|</span><label class="collapse" for="c-36246261">[-]</label><label class="expand" for="c-36246261">[1 more]</label></div><br/><div class="children"><div class="content">Very cool, I love hearing founder journeys. Best of luck to you all.</div><br/></div></div></div></div></div></div><div id="36244604" class="c"><input type="checkbox" id="c-36244604" checked=""/><div class="controls bullet"><span class="by">wodow</span><span>|</span><a href="#36244080">prev</a><span>|</span><a href="#36244087">next</a><span>|</span><label class="collapse" for="c-36244604">[-]</label><label class="expand" for="c-36244604">[2 more]</label></div><br/><div class="children"><div class="content">What I would love to be standard in all product launches like this would be to have a mailing list per integration or, as with this, programming language.<p>I want to be able to drop my email address and only hear back when support for $MY_FAVE_LANG is available.</div><br/><div id="36244701" class="c"><input type="checkbox" id="c-36244701" checked=""/><div class="controls bullet"><span class="by">stevepike</span><span>|</span><a href="#36244604">parent</a><span>|</span><a href="#36244087">next</a><span>|</span><label class="collapse" for="c-36244701">[-]</label><label class="expand" for="c-36244701">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a bit buried, but if you go to <a href="https:&#x2F;&#x2F;app.infield.ai&#x2F;hn">https:&#x2F;&#x2F;app.infield.ai&#x2F;hn</a> and click &quot;I don&#x27;t use Ruby&quot; we&#x27;ll ask for your email&#x2F;language and put you on our list.</div><br/></div></div></div></div><div id="36244087" class="c"><input type="checkbox" id="c-36244087" checked=""/><div class="controls bullet"><span class="by">xwowsersx</span><span>|</span><a href="#36244604">prev</a><span>|</span><a href="#36243919">next</a><span>|</span><label class="collapse" for="c-36244087">[-]</label><label class="expand" for="c-36244087">[3 more]</label></div><br/><div class="children"><div class="content">Maybe it&#x27;s just me but this wording seems weird to me, not sure why exactly:<p>&gt; World-class Engineering teams use Infield to make dependency maintenance time twice as productive.<p>Specifically, &quot;to make dependency maintenance time twice as productive.&quot; Feel like it ought to say &quot;to cut the time they spend maintaining dependencies in half&quot;. I know that&#x27;s wordier and maybe that&#x27;s not quite it, but the wording as is feels a bit tortured to me.</div><br/><div id="36245131" class="c"><input type="checkbox" id="c-36245131" checked=""/><div class="controls bullet"><span class="by">ADLenehan</span><span>|</span><a href="#36244087">parent</a><span>|</span><a href="#36243919">next</a><span>|</span><label class="collapse" for="c-36245131">[-]</label><label class="expand" for="c-36245131">[2 more]</label></div><br/><div class="children"><div class="content">Andy (Infield co-founder) here - agreed that wording was a bit clunky. Changed now. Appreciate the feedback!</div><br/><div id="36252918" class="c"><input type="checkbox" id="c-36252918" checked=""/><div class="controls bullet"><span class="by">xwowsersx</span><span>|</span><a href="#36244087">root</a><span>|</span><a href="#36245131">parent</a><span>|</span><a href="#36243919">next</a><span>|</span><label class="collapse" for="c-36252918">[-]</label><label class="expand" for="c-36252918">[1 more]</label></div><br/><div class="children"><div class="content">No problem. Congrats on the launch!</div><br/></div></div></div></div></div></div><div id="36243919" class="c"><input type="checkbox" id="c-36243919" checked=""/><div class="controls bullet"><span class="by">funerr</span><span>|</span><a href="#36244087">prev</a><span>|</span><a href="#36243918">next</a><span>|</span><label class="collapse" for="c-36243919">[-]</label><label class="expand" for="c-36243919">[2 more]</label></div><br/><div class="children"><div class="content">Cool idea! I thought about it too a few years ago while doing some upgrades. Do you support more languages? And do you have it in CLI form?</div><br/><div id="36245118" class="c"><input type="checkbox" id="c-36245118" checked=""/><div class="controls bullet"><span class="by">stevepike</span><span>|</span><a href="#36243919">parent</a><span>|</span><a href="#36243918">next</a><span>|</span><label class="collapse" for="c-36245118">[-]</label><label class="expand" for="c-36245118">[1 more]</label></div><br/><div class="children"><div class="content">Only Ruby right now. We want to make it work really well for one language before expanding. Which language would you want it in?<p>We have a command line tool you can use to send your lockfile to our server so we can process it, but you have to use our web app to view the results.</div><br/></div></div></div></div><div id="36243918" class="c"><input type="checkbox" id="c-36243918" checked=""/><div class="controls bullet"><span class="by">Alifatisk</span><span>|</span><a href="#36243919">prev</a><span>|</span><a href="#36251649">next</a><span>|</span><label class="collapse" for="c-36243918">[-]</label><label class="expand" for="c-36243918">[2 more]</label></div><br/><div class="children"><div class="content">Interesting, might try it out!</div><br/></div></div><div id="36251649" class="c"><input type="checkbox" id="c-36251649" checked=""/><div class="controls bullet"><span class="by">mrwnmonm</span><span>|</span><a href="#36243918">prev</a><span>|</span><label class="collapse" for="c-36251649">[-]</label><label class="expand" for="c-36251649">[2 more]</label></div><br/><div class="children"><div class="content">Adding Go later?</div><br/><div id="36251751" class="c"><input type="checkbox" id="c-36251751" checked=""/><div class="controls bullet"><span class="by">stevepike</span><span>|</span><a href="#36251649">parent</a><span>|</span><label class="collapse" for="c-36251751">[-]</label><label class="expand" for="c-36251751">[1 more]</label></div><br/><div class="children"><div class="content">Definitely. I&#x27;m very interested in govulncheck and building tooling into the ecosystem to make dependency use safer.</div><br/></div></div></div></div></div></div></div></div></div></body></html>