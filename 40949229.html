<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1720861252406" as="style"/><link rel="stylesheet" href="styles.css?v=1720861252406"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.jvt.me/posts/2024/07/12/things-know-commits/">Things I know about Git commits</a> <span class="domain">(<a href="https://www.jvt.me">www.jvt.me</a>)</span></div><div class="subtext"><span>sea-gold</span> | <span>49 comments</span></div><br/><div><div id="40951517" class="c"><input type="checkbox" id="c-40951517" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#40951899">next</a><span>|</span><label class="collapse" for="c-40951517">[-]</label><label class="expand" for="c-40951517">[5 more]</label></div><br/><div class="children"><div class="content">`git reflog`, which the article prominently mentions, really should be the VERY FIRST thing to teach everyone who is learning git.<p>If you don&#x27;t know about it, it is well worth checking it out now.<p>It is your one ticket to getting to whatever previous, good (or bad!) state you were at any point before[1]. The only thing it cannot help you recover is locally made changes that you never committed to anything at any point, and have since locally deleted. This is surprisingly rare, at least for me, as I just tend to `git stash` stuff I don&#x27;t want anymore.<p>With `git reflog` in your backpocket, you can rebase, merge, branch, delete branches, cherry-pick, rewrite history, whatever, all to your heart&#x27;s content. `git reflog` keeps a journal of every single action, and tells you the HEAD before and after each action, which you can then simply checkout or `reset --hard` your branch to.<p>I never even use any arguments with it, I literally just `git reflog`.<p>[1] Unless garbage collection has deleted the commit you were pointing to, I guess, but I&#x27;ve never had to use `git reflog` <i>that</i> far in the future.</div><br/><div id="40952732" class="c"><input type="checkbox" id="c-40952732" checked=""/><div class="controls bullet"><span class="by">ezst</span><span>|</span><a href="#40951517">parent</a><span>|</span><a href="#40952599">next</a><span>|</span><label class="collapse" for="c-40952732">[-]</label><label class="expand" for="c-40952732">[1 more]</label></div><br/><div class="children"><div class="content">&gt; `git reflog`, which the article prominently mentions, really should be the VERY FIRST thing to teach everyone who is learning git.<p>Top that up with `log` showing all branches at all times (except if you ask otherwise) and you end up pretty much where mercurial is. Detached heads is such nonsense. Git missing phases and obsolescence (to denote if and how history eventually got rewritten) is another.</div><br/></div></div><div id="40952599" class="c"><input type="checkbox" id="c-40952599" checked=""/><div class="controls bullet"><span class="by">idoubtit</span><span>|</span><a href="#40951517">parent</a><span>|</span><a href="#40952732">prev</a><span>|</span><a href="#40951917">next</a><span>|</span><label class="collapse" for="c-40952599">[-]</label><label class="expand" for="c-40952599">[1 more]</label></div><br/><div class="children"><div class="content">Over the last decade, I think I&#x27;ve only used `reflog` twice. The only case I remember clearly was to help a co-worker that had created a local mess, starting with a `git pull` (meaning a merge) on the wrong branch then piling onto that.<p>If you use Git in a terminal, a much simpler alternative to the reflog is having the commit hash in the prompt. Then comparing&#x2F;reverting to a previous state just requires scrolling the terminal to find the commit id. It&#x27;s much easier to read than the reflog. With the help of the shell prompt, the terminal can help with the questions &quot;what did I do to get there and how to get out?&quot;.<p>I also think that Git has become much more error-proof. It&#x27;s been a long time since I&#x27;ve seen anyone lost in their own repository like I&#x27;d seen years ago. There are better GUIs. In the command line, modern Git often displays hints, has warnings for some dangerous commands, and sometimes explains how to rollback.</div><br/></div></div><div id="40951917" class="c"><input type="checkbox" id="c-40951917" checked=""/><div class="controls bullet"><span class="by">compressedgas</span><span>|</span><a href="#40951517">parent</a><span>|</span><a href="#40952599">prev</a><span>|</span><a href="#40951769">next</a><span>|</span><label class="collapse" for="c-40951917">[-]</label><label class="expand" for="c-40951917">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d also recommend turning off reflog expiration with:<p><pre><code>  gc.reflogexpire=never
  gc.reflogexpireunreachable=never</code></pre></div><br/></div></div></div></div><div id="40951899" class="c"><input type="checkbox" id="c-40951899" checked=""/><div class="controls bullet"><span class="by">donatj</span><span>|</span><a href="#40951517">prev</a><span>|</span><a href="#40951270">next</a><span>|</span><label class="collapse" for="c-40951899">[-]</label><label class="expand" for="c-40951899">[9 more]</label></div><br/><div class="children"><div class="content">&gt; People who say &quot;just delete the repo&quot; when things go wrong really frustrate me<p>YES. Go be a baker or something! If you&#x27;re going to be a developer you should generally speaking be willing to figure out what&#x27;s wrong and how to fix it.<p>Know how your tools work. Bad carpenter what have you...<p>Also speaking of `git reflog` and such - I still stand by this article I wrote a few years back - <a href="https:&#x2F;&#x2F;donatstudios.com&#x2F;yagni-git-gc" rel="nofollow">https:&#x2F;&#x2F;donatstudios.com&#x2F;yagni-git-gc</a><p>99% of people should just turn automatic `git gc` off. You don&#x27;t need it. Turn it off and you never have to worry about losing work. It&#x27;s there, you just have to find it.</div><br/><div id="40952626" class="c"><input type="checkbox" id="c-40952626" checked=""/><div class="controls bullet"><span class="by">zvrba</span><span>|</span><a href="#40951899">parent</a><span>|</span><a href="#40952690">next</a><span>|</span><label class="collapse" for="c-40952626">[-]</label><label class="expand" for="c-40952626">[1 more]</label></div><br/><div class="children"><div class="content">Git is an abysmal tool for many (most?) uses of it, but that unfortunately has become &quot;standard&quot;. The sheer awfulness of git is witnessed by the amount of posts about it and little consensus on &quot;best practices&quot; (e.g., rebase vs merge).<p>So, I don&#x27;t judge, but sympathize with people who just &quot;delete the repo and start from scratch&quot;. Unintuitive, user-hostile tools call for heavy-handed solutions.<p>IME, most people are willing to learn something when they&#x27;re shown the value for invested effort. That &quot;delete the repo&quot; is standard answer for fixing f*up, tells more about the tool than the people using it. (I.e. it requires disproportionately big investment of time for little value.)</div><br/></div></div><div id="40952690" class="c"><input type="checkbox" id="c-40952690" checked=""/><div class="controls bullet"><span class="by">cedws</span><span>|</span><a href="#40951899">parent</a><span>|</span><a href="#40952626">prev</a><span>|</span><a href="#40951933">next</a><span>|</span><label class="collapse" for="c-40952690">[-]</label><label class="expand" for="c-40952690">[1 more]</label></div><br/><div class="children"><div class="content">I haven’t done that since my junior days. Do people really do this? I know Git’s UX is bad but wow.</div><br/></div></div><div id="40951933" class="c"><input type="checkbox" id="c-40951933" checked=""/><div class="controls bullet"><span class="by">compressedgas</span><span>|</span><a href="#40951899">parent</a><span>|</span><a href="#40952690">prev</a><span>|</span><a href="#40951905">next</a><span>|</span><label class="collapse" for="c-40951933">[-]</label><label class="expand" for="c-40951933">[1 more]</label></div><br/><div class="children"><div class="content">Instead of turning off the automatic git gc, turn off the reflog expiration with:<p><pre><code>  gc.reflogexpire=never
  gc.reflogexpireunreachable=never</code></pre></div><br/></div></div><div id="40951905" class="c"><input type="checkbox" id="c-40951905" checked=""/><div class="controls bullet"><span class="by">jimmaswell</span><span>|</span><a href="#40951899">parent</a><span>|</span><a href="#40951933">prev</a><span>|</span><a href="#40951270">next</a><span>|</span><label class="collapse" for="c-40951905">[-]</label><label class="expand" for="c-40951905">[5 more]</label></div><br/><div class="children"><div class="content">I could spend hours of my workday on some uninteresting, irrelevant bullshit because the local repo is fucked, or just delete it and move on to solving actual problems and producing value. The choice is clear.</div><br/><div id="40951925" class="c"><input type="checkbox" id="c-40951925" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#40951899">root</a><span>|</span><a href="#40951905">parent</a><span>|</span><a href="#40952222">next</a><span>|</span><label class="collapse" for="c-40951925">[-]</label><label class="expand" for="c-40951925">[3 more]</label></div><br/><div class="children"><div class="content">Or you could spend an hour or so learning to use git (or a git compatible vcs like Jujutsu) and then you never bork your repos, and instead spend your time solving actual problems and producing value.<p>What kind of pastries do you like?</div><br/><div id="40952054" class="c"><input type="checkbox" id="c-40952054" checked=""/><div class="controls bullet"><span class="by">jimmaswell</span><span>|</span><a href="#40951899">root</a><span>|</span><a href="#40951925">parent</a><span>|</span><a href="#40952222">next</a><span>|</span><label class="collapse" for="c-40952054">[-]</label><label class="expand" for="c-40952054">[2 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t remember the last time I had to delete a repo, at most I do a hard reset to the head of the main branch. Still don&#x27;t care and I&#x27;m doing well enough getting consistent maximum performance ratings at my job and building things in my own time. Sometimes a problem is not worth addressing, and part of being an effective software engineer on the whole is recognizing those times.</div><br/><div id="40952168" class="c"><input type="checkbox" id="c-40952168" checked=""/><div class="controls bullet"><span class="by">jenadine</span><span>|</span><a href="#40951899">root</a><span>|</span><a href="#40952054">parent</a><span>|</span><a href="#40952222">next</a><span>|</span><label class="collapse" for="c-40952168">[-]</label><label class="expand" for="c-40952168">[1 more]</label></div><br/><div class="children"><div class="content">Both points are valid.<p>But it shouldn&#x27;t take hours to &quot;fix&quot; a repo in most cases. As you said: git reset.<p>Anyway, I&#x27;ve been putting some of my repo in very bad states by doing git operation from different unix user that lacked the right permission to do all the writes leaving some corrupted objects and stuff which needs a bit more than just a reset to recover. Then it takes some time to recover, but that&#x27;s because I also don&#x27;t want to loose some hours of un-pushed work.<p>Doing a delete of my repo could have been faster but I&#x27;d have lost some temporary branches and squashes and stuff that would also represent some work.<p>But I think the original point is for people who are not even able to do a git reset.</div><br/></div></div></div></div></div></div><div id="40952222" class="c"><input type="checkbox" id="c-40952222" checked=""/><div class="controls bullet"><span class="by">usr1106</span><span>|</span><a href="#40951899">root</a><span>|</span><a href="#40951905">parent</a><span>|</span><a href="#40951925">prev</a><span>|</span><a href="#40951270">next</a><span>|</span><label class="collapse" for="c-40952222">[-]</label><label class="expand" for="c-40952222">[1 more]</label></div><br/><div class="children"><div class="content">I have never deleted a repo because it&#x27;s messed up. In the early days understanding what was wrong was sometimes challenging. But once I learned it it&#x27;s just routine to clean it up. I do occasionally search stuff from my reflog or trial branches from years ago, no way I want to lose that opportunity.<p>One needs to learn full branch names and how the abbreviations used in daily life really work. A local branch called origin&#x2F;foo can be confusing, especially after being pushed. And of course one needs to understanding the concept of remote branches in the first place, they are not really remote, typical poor git terminology.<p>For mass mess-ups in the work tree git status -s | grep ... oneliners are your friend.</div><br/></div></div></div></div></div></div><div id="40951270" class="c"><input type="checkbox" id="c-40951270" checked=""/><div class="controls bullet"><span class="by">alganet</span><span>|</span><a href="#40951899">prev</a><span>|</span><a href="#40952371">next</a><span>|</span><label class="collapse" for="c-40951270">[-]</label><label class="expand" for="c-40951270">[5 more]</label></div><br/><div class="children"><div class="content">To me, commit messages really shine on file histories and `git blame`.<p>Opening an unknown file and having the option to see all it went through is powerful. The commit messages and history will tell you which files are related, which files change together, why they do, etc.<p>It&#x27;s a superpower that a team can cultivate.</div><br/><div id="40951336" class="c"><input type="checkbox" id="c-40951336" checked=""/><div class="controls bullet"><span class="by">lucasoshiro</span><span>|</span><a href="#40951270">parent</a><span>|</span><a href="#40952371">next</a><span>|</span><label class="collapse" for="c-40951336">[-]</label><label class="expand" for="c-40951336">[4 more]</label></div><br/><div class="children"><div class="content">I strongly agree.<p>Git isn&#x27;t only code sharing that you commit and forget. It is a database of code that tracks what changed, why changed, who changed and when changed.<p>Want to know why a piece of code exists? Find the commit that introduced it, read the message. If it&#x27;s not enough, you can search the commit and find the discussion on GitHub&#x2F;GitLab&#x2F;etc.<p>A new bug suddenly appeared? Use git bisect to find what was the commit that introduced it.<p>Some months ago I posted some tips about using Git as a debugging tool, if you want to read more about it: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39877637">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39877637</a></div><br/><div id="40952074" class="c"><input type="checkbox" id="c-40952074" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#40951270">root</a><span>|</span><a href="#40951336">parent</a><span>|</span><a href="#40952371">next</a><span>|</span><label class="collapse" for="c-40952074">[-]</label><label class="expand" for="c-40952074">[3 more]</label></div><br/><div class="children"><div class="content">See also:<p><pre><code>    git log -L:funcname:file
</code></pre>
funcname will be matched after wrapping it in a &quot;function declaration identifying&quot; regexp.<p>Get the entire history of a given function (as long as it was in &lt;file&gt;). Not a daily driver, but sometimes unimaginably valuable.</div><br/><div id="40952090" class="c"><input type="checkbox" id="c-40952090" checked=""/><div class="controls bullet"><span class="by">ufo</span><span>|</span><a href="#40951270">root</a><span>|</span><a href="#40952074">parent</a><span>|</span><a href="#40952371">next</a><span>|</span><label class="collapse" for="c-40952090">[-]</label><label class="expand" for="c-40952090">[2 more]</label></div><br/><div class="children"><div class="content">Could you please give a concrete example of how to use funcname? I tried looking in the man page and didn&#x27;t get it.</div><br/></div></div></div></div></div></div></div></div><div id="40952371" class="c"><input type="checkbox" id="c-40952371" checked=""/><div class="controls bullet"><span class="by">jraph</span><span>|</span><a href="#40951270">prev</a><span>|</span><a href="#40951338">next</a><span>|</span><label class="collapse" for="c-40952371">[-]</label><label class="expand" for="c-40952371">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Make sure you review your own code changes<p>The author says he reviews himself on a GitLab MR &#x2F; GitHub PL, I rely on two things for this:<p>- git add -p, which also helps me split stuff in several commits if needed. It bothers me that it doesn&#x27;t work for new files.<p>- git difftool dir-diff for changes with several commits<p>I like that it would work on any git hosting, and that it works locally. And that I can just amend my commits if I see something.</div><br/><div id="40952482" class="c"><input type="checkbox" id="c-40952482" checked=""/><div class="controls bullet"><span class="by">JNRowe</span><span>|</span><a href="#40952371">parent</a><span>|</span><a href="#40952519">next</a><span>|</span><label class="collapse" for="c-40952482">[-]</label><label class="expand" for="c-40952482">[1 more]</label></div><br/><div class="children"><div class="content">`git add -p` can also work for new files, it just requires you to call `git add --intent-to-add` first.  After using -N&#x2F;--intent-to-add you&#x27;ll see that the file is registered in the status output, and -p will work exactly how like you expect.<p>I often find myself spiking things then breaking them back down with -N and repeated `git commit -p` to form a reasonable history.  The workflow seems to really suit my mind.  However, it does require some testing vigilance if you&#x27;re manually editing the hunks for clarity on top of simply splitting them up.</div><br/></div></div><div id="40952519" class="c"><input type="checkbox" id="c-40952519" checked=""/><div class="controls bullet"><span class="by">arcanemachiner</span><span>|</span><a href="#40952371">parent</a><span>|</span><a href="#40952482">prev</a><span>|</span><a href="#40952578">next</a><span>|</span><label class="collapse" for="c-40952519">[-]</label><label class="expand" for="c-40952519">[1 more]</label></div><br/><div class="children"><div class="content">&gt; - git add -p, which also helps me split stuff in several commits if needed. It bothers me that it doesn&#x27;t work for new files.<p>Lazygit is an amazing tool that can definitely do this (and many other useful things).</div><br/></div></div></div></div><div id="40951338" class="c"><input type="checkbox" id="c-40951338" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#40952371">prev</a><span>|</span><a href="#40951227">next</a><span>|</span><label class="collapse" for="c-40951338">[-]</label><label class="expand" for="c-40951338">[4 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Do the work up front to make your history atomic</i><p>Is this saying 1 feature &#x2F; main &quot;idea&quot; per commit?<p>Overall this post is gold, but also probably preaching to the choir.  IME it&#x27;s challenging to convert non-believers to the faction of Orthodox Git.<p>For me, learning the ins and outs of Git felt like uncovering a part of myself which has always been there.  Nothing new was created, only revealed.</div><br/><div id="40951410" class="c"><input type="checkbox" id="c-40951410" checked=""/><div class="controls bullet"><span class="by">jcoder</span><span>|</span><a href="#40951338">parent</a><span>|</span><a href="#40951227">next</a><span>|</span><label class="collapse" for="c-40951410">[-]</label><label class="expand" for="c-40951410">[3 more]</label></div><br/><div class="children"><div class="content">Not the author, but when I use the phrase I mean each commit accomplishes a single important thing, but also that each commit is complete: it includes necessary tests for example. IMO every commit that lands on `main` must pass the test suite (this means intermediate commits should be squashed into that atomic commit).</div><br/><div id="40951540" class="c"><input type="checkbox" id="c-40951540" checked=""/><div class="controls bullet"><span class="by">epage</span><span>|</span><a href="#40951338">root</a><span>|</span><a href="#40951410">parent</a><span>|</span><a href="#40951227">next</a><span>|</span><label class="collapse" for="c-40951540">[-]</label><label class="expand" for="c-40951540">[2 more]</label></div><br/><div class="children"><div class="content">The more I&#x27;ve been doing open source maintenance and contributions where there isn&#x27;t as much context between the code author and reviewer, the more I&#x27;ve been pushing for a little more than this.<p>- Add tests in a commit *before* the fix.  They should pass, showing the behavior before your change.  Then, the commit with your change will update the tests.  The diff between these commits represents the change in behavior.  This helps the author test their tests (I&#x27;ve written tests thinking they covered the relevant case but didn&#x27;t), the reviewer to more precisely see the change in behavior and comment on it, and the wider community to understand what the PR description is about.<p>- Where reasonable, find ways to split code changes out of feature &#x2F; fix commits into refactor commits.  Reading a diff top-down doesn&#x27;t tell you anything; you need to jump around a lot to see how the parts interact.  By splitting it up, you can more quickly understand each piece and the series of commits tells a story of how the feature of fix came to be.<p>- Commits are atomic while PRs tell a story, as long as it doesn&#x27;t get too big.  Refactor are usually leading towards a goal and having them tied together with that goal helps to provide the context to understand it all.  However, this has to be balanced with the fact that larger reviews mean more things are missed on each pass and its different things on each pass, causing a lot of &quot;20 rounds of feedback in and I just noticed this major problem&quot;.<p>As an example of these is a recent PR of mine against Cargo: <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;cargo&#x2F;pull&#x2F;14239">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;cargo&#x2F;pull&#x2F;14239</a><p>In particular, the refactors leading up to the final change made it so the actual fix was a one line change.  It also linked out to the prior refactors that I split out into separate PRs to keep this one smaller.</div><br/><div id="40952013" class="c"><input type="checkbox" id="c-40952013" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#40951338">root</a><span>|</span><a href="#40951540">parent</a><span>|</span><a href="#40951227">next</a><span>|</span><label class="collapse" for="c-40952013">[-]</label><label class="expand" for="c-40952013">[1 more]</label></div><br/><div class="children"><div class="content">I absolutely love that testing suggestion - I&#x27;d never considered shipping a whole separate commit adding the OLD test first, but having a second commit that then updates that test to illustrate the change in behavior is such an obviously good idea.</div><br/></div></div></div></div></div></div></div></div><div id="40951227" class="c"><input type="checkbox" id="c-40951227" checked=""/><div class="controls bullet"><span class="by">lucasoshiro</span><span>|</span><a href="#40951338">prev</a><span>|</span><a href="#40952278">next</a><span>|</span><label class="collapse" for="c-40951227">[-]</label><label class="expand" for="c-40951227">[1 more]</label></div><br/><div class="children"><div class="content">If you want more controversial things about squash, here are two that I posted here last week:<p>1. &quot;How squash merge can break Git repos with submodules&quot;, about a situation where squash merges silently broke a repository: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40846596">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40846596</a><p>2. &quot;Git: please stop squash merging!&quot; giving some technical explanation about what squash merges actually are under the hood and how the misconceptions about Git leads to invalid &quot;pros&quot; about squash merging: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40840572">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40840572</a></div><br/></div></div><div id="40952278" class="c"><input type="checkbox" id="c-40952278" checked=""/><div class="controls bullet"><span class="by">usr1106</span><span>|</span><a href="#40951227">prev</a><span>|</span><a href="#40952199">next</a><span>|</span><label class="collapse" for="c-40952278">[-]</label><label class="expand" for="c-40952278">[1 more]</label></div><br/><div class="children"><div class="content">I agree with most of the items on the list. But some are too short to understand what they mean or they are really &quot;It depends&quot;.<p>The most important point for me is that the same tool is used for 2 purposes: Keeping track of quick trial and error experiments so that you can return to the best one once you have made up your mind. And producing a readable story of self-contained atomic commits telling a story to the reviewer and yourself weeks or years later.<p>I hate myself every time when I don&#x27;t get the context switch right between those 2 modes of operation. Or just don&#x27;t do the second phase because I first need fo fix a bug and will continue with the current branch later.</div><br/></div></div><div id="40952199" class="c"><input type="checkbox" id="c-40952199" checked=""/><div class="controls bullet"><span class="by">jenadine</span><span>|</span><a href="#40952278">prev</a><span>|</span><a href="#40951484">next</a><span>|</span><label class="collapse" for="c-40952199">[-]</label><label class="expand" for="c-40952199">[3 more]</label></div><br/><div class="children"><div class="content">It frighten me how some contributor to my open source repo just don&#x27;t care about their git history. They do 100 of &quot;crap&quot; commits (author&#x27;s wording) and merge commits. Sometimes I&#x27;d write a comment like: &quot;can you please rebase your branch&quot; and even very senior software engineer are clueless and can&#x27;t do it even if I give the exact git command i&#x27;d use. In the end it&#x27;s simpler for me to do it myself.<p>Some developers don&#x27;t even use git and just use some UI on top.<p>I wish GitHub would have an interface to do interactive rebase and edit commit messages.</div><br/><div id="40952504" class="c"><input type="checkbox" id="c-40952504" checked=""/><div class="controls bullet"><span class="by">jonathanlydall</span><span>|</span><a href="#40952199">parent</a><span>|</span><a href="#40951484">next</a><span>|</span><label class="collapse" for="c-40952504">[-]</label><label class="expand" for="c-40952504">[2 more]</label></div><br/><div class="children"><div class="content">I consider myself very knowledgeable on using Git even though I almost exclusively use it through GUI tools, however my particular GUI wrapper of choice, TortoiseGit on Windows is incredibly powerful. I very regularly do rebasing, squashing, use worktrees extensively, etc.<p>When I occasionally have to work on Linux or macOS for our Electron based cross platform product, I haven’t yet found a GUI tool I feel comes remotely close to TortoiseGit in terms of advanced features. So much so that if I need to do things like rebasing or dealing with slightly complicated merges, I push first to a branch and then do the Git work on my Windows machine.<p>I could work out all the Git command line arguments for these advanced use cases, but for something like rebasing with some squashing or skipping, I can’t see how anything except a well designed GUI could be anything except a seriously clunky and much slower experience.<p>My feeling is that (good) GUIs in general make a lot more sense for Git, instead of having to read the entire manual upfront to know the available tools, the GUI can show relevant options based on context and you don’t get bogged down having to type out&#x2F;paste commit references and other things into your terminal.<p>I occasionally use the built in Git tools on VS Code and Visual Studio 2022 (the latter of which only in the last couple of years didn’t completely suck), but generally only for simple pulls, commits and pushes, which is generally more convenient in the IDE than having to switch to TortoiseGit.<p>Of course a tool is just a tool, if you don’t “get” how Git works, no tool will save you, but I do think TortoiseGit’s rebase UI helped me get to the point where Git “clicked” for me sooner.</div><br/><div id="40952666" class="c"><input type="checkbox" id="c-40952666" checked=""/><div class="controls bullet"><span class="by">philwelch</span><span>|</span><a href="#40952199">root</a><span>|</span><a href="#40952504">parent</a><span>|</span><a href="#40951484">next</a><span>|</span><label class="collapse" for="c-40952666">[-]</label><label class="expand" for="c-40952666">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I could work out all the Git command line arguments for these advanced use cases, but for something like rebasing with some squashing or skipping, I can’t see how anything except a well designed GUI could be anything except a seriously clunky and much slower experience.<p>That’s just an interactive rebase; on the command line it opens a text editor. It’s pretty easy.</div><br/></div></div></div></div></div></div><div id="40951484" class="c"><input type="checkbox" id="c-40951484" checked=""/><div class="controls bullet"><span class="by">yerdoingitwrong</span><span>|</span><a href="#40952199">prev</a><span>|</span><a href="#40951904">next</a><span>|</span><label class="collapse" for="c-40951484">[-]</label><label class="expand" for="c-40951484">[6 more]</label></div><br/><div class="children"><div class="content">The most USELESS commit messages are &quot;Fixes #12345 (#23456)&quot;.
It tells the git log reviewer NOTHING.
You shouldn&#x27;t have to rely on github to understand your project.
State the intent of the bug fix in the commit message.</div><br/><div id="40952655" class="c"><input type="checkbox" id="c-40952655" checked=""/><div class="controls bullet"><span class="by">karmarepellent</span><span>|</span><a href="#40951484">parent</a><span>|</span><a href="#40952269">next</a><span>|</span><label class="collapse" for="c-40952655">[-]</label><label class="expand" for="c-40952655">[1 more]</label></div><br/><div class="children"><div class="content">Well written GitHub issues and PRs that you can reference in your git commit also don&#x27;t save you from commenting code. I mean please do not reference an issue in a code comments, but describing to other people what a function in general does goes a long way to build understanding.<p>For new contributors it&#x27;s probably also more useful to see the latest snapshot of the code base and code comments than having to check a git log in order to find out why a function would be written in the way it is.</div><br/></div></div><div id="40952269" class="c"><input type="checkbox" id="c-40952269" checked=""/><div class="controls bullet"><span class="by">turboponyy</span><span>|</span><a href="#40951484">parent</a><span>|</span><a href="#40952655">prev</a><span>|</span><a href="#40952176">next</a><span>|</span><label class="collapse" for="c-40952269">[-]</label><label class="expand" for="c-40952269">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. For PR commits, appending the PR number (e.g. `#8`) to the short message is fine, but the short message should still contain a summary of changes. For issues, having something like &quot;Fixed #8&quot; in the commit message body is picked up by forges like GitHub.</div><br/></div></div><div id="40952176" class="c"><input type="checkbox" id="c-40952176" checked=""/><div class="controls bullet"><span class="by">dakiol</span><span>|</span><a href="#40951484">parent</a><span>|</span><a href="#40952269">prev</a><span>|</span><a href="#40951904">next</a><span>|</span><label class="collapse" for="c-40952176">[-]</label><label class="expand" for="c-40952176">[3 more]</label></div><br/><div class="children"><div class="content">Depends. If the number points to a very well written ticket, that’s fine.
We work with Jira and Github and all the bugs&#x2F;features are explained in Jira tickets. I’m not staying long enough in this company to see them changing from Jira to something else, so I don’t care about the Jira dependence to understand commits.</div><br/><div id="40952287" class="c"><input type="checkbox" id="c-40952287" checked=""/><div class="controls bullet"><span class="by">jraph</span><span>|</span><a href="#40951484">root</a><span>|</span><a href="#40952176">parent</a><span>|</span><a href="#40951904">next</a><span>|</span><label class="collapse" for="c-40952287">[-]</label><label class="expand" for="c-40952287">[2 more]</label></div><br/><div class="children"><div class="content">The git log should still stand on its own. The ticketing platform could get migrated in a way ticket numbers are not kept or old tickets are a bit less convenient to find, or just temporarily down.<p>When working on the code, it&#x27;s also very useful to access the history without having to open each ticket. Being able to hover a line, having the message of the commit which last changed it, and be able to say &quot;ah ok, it was for this&quot; is quite useful.<p>&gt; I’m not staying long enough in this company to see them changing from Jira to something else, so I don’t care about the Jira dependence to understand commits<p>Isn&#x27;t this a terrible argument in favor of &quot;Fixes NNN&quot; commits? Someone who care about the longevity of a versioned thing should care. If you don&#x27;t care anyway, nothing matters much.</div><br/><div id="40952639" class="c"><input type="checkbox" id="c-40952639" checked=""/><div class="controls bullet"><span class="by">karmarepellent</span><span>|</span><a href="#40951484">root</a><span>|</span><a href="#40952287">parent</a><span>|</span><a href="#40951904">next</a><span>|</span><label class="collapse" for="c-40952639">[-]</label><label class="expand" for="c-40952639">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know about the &quot;git log should stand on its own&quot;. Chances are that when you finally migrate to another ticketing system and the ticket numbers in your commits &quot;break&quot; or become meaningless, you do not care much about that old history anyway.<p>And even if someone is interested in an old commit that contains a ticket number for a ticketing system that does not exist anymore, the commit itself (the code changes, not the message) tell the story as well, just not in prose.</div><br/></div></div></div></div></div></div></div></div><div id="40951904" class="c"><input type="checkbox" id="c-40951904" checked=""/><div class="controls bullet"><span class="by">osigurdson</span><span>|</span><a href="#40951484">prev</a><span>|</span><a href="#40952324">next</a><span>|</span><label class="collapse" for="c-40951904">[-]</label><label class="expand" for="c-40951904">[3 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; Squashing is better than 100 crap commits<p>Unless your work is trivial, you will have crap commits. Have discipline but don&#x27;t insist on working on trivial things just so your commits appear logical without rework.</div><br/><div id="40952196" class="c"><input type="checkbox" id="c-40952196" checked=""/><div class="controls bullet"><span class="by">dougthesnails</span><span>|</span><a href="#40951904">parent</a><span>|</span><a href="#40952255">next</a><span>|</span><label class="collapse" for="c-40952196">[-]</label><label class="expand" for="c-40952196">[1 more]</label></div><br/><div class="children"><div class="content">Or learn to rebase those crap commits into coherent ones.</div><br/></div></div><div id="40952255" class="c"><input type="checkbox" id="c-40952255" checked=""/><div class="controls bullet"><span class="by">turboponyy</span><span>|</span><a href="#40951904">parent</a><span>|</span><a href="#40952196">prev</a><span>|</span><a href="#40952324">next</a><span>|</span><label class="collapse" for="c-40952255">[-]</label><label class="expand" for="c-40952255">[1 more]</label></div><br/><div class="children"><div class="content">You realize that commits can be changed, right?</div><br/></div></div></div></div><div id="40952324" class="c"><input type="checkbox" id="c-40952324" checked=""/><div class="controls bullet"><span class="by">at_a_remove</span><span>|</span><a href="#40951904">prev</a><span>|</span><a href="#40951585">next</a><span>|</span><label class="collapse" for="c-40952324">[-]</label><label class="expand" for="c-40952324">[1 more]</label></div><br/><div class="children"><div class="content">Ah, the endless mysteries of git.  People say, &quot;It&#x27;s so simple once you understand the base model.&quot;  And yet there are these inevitable <i>buts</i>.  And somehow, people keep arguing over how to use it, what is the Correct Way.  If it were that simple, the One True methodology would be obvious, yet the disagreements continue.  Then I ask dumb questions about merging and have yet to hear how the magic happens, just very circular &quot;merging ... merges&quot; answers.<p>One day I hope to have a positive and comprehensible experience involving git and perhaps even git and another programmer, but that might be too much to ask.</div><br/></div></div><div id="40951585" class="c"><input type="checkbox" id="c-40951585" checked=""/><div class="controls bullet"><span class="by">r-s</span><span>|</span><a href="#40952324">prev</a><span>|</span><a href="#40952545">next</a><span>|</span><label class="collapse" for="c-40951585">[-]</label><label class="expand" for="c-40951585">[1 more]</label></div><br/><div class="children"><div class="content">&gt; 58. Trying to police commit history is going to be painful<p>This has been my experience. Very painful</div><br/></div></div><div id="40952545" class="c"><input type="checkbox" id="c-40952545" checked=""/><div class="controls bullet"><span class="by">g-b-r</span><span>|</span><a href="#40951585">prev</a><span>|</span><a href="#40952189">next</a><span>|</span><label class="collapse" for="c-40952545">[-]</label><label class="expand" for="c-40952545">[2 more]</label></div><br/><div class="children"><div class="content">PLEASE, recognize that &quot;atomic&quot; commits as the author defines them (basically whole features), will actually jumble up a large part of the diff, however much advanced your diff program is, making verifying the changes a lot harder..!<p>If you like to see chains of commits each with a complete feature, just remember that merge commits are commits as well!<p>Sure, rebase a feature branch before merging it, but then merge it with a <i>merge commit</i> ! (merge --no-ff)<p>That way you&#x27;ll have both your &quot;atomic commits&quot;, and <i>actually atomic</i> commits, that is commits with changes that any diff program will be able to highlight correctly.  
Verification will be extremely easier, but you&#x27;ll retain the ability to browse the history at a higher abstraction level (either use any decent graphical git browser, or simply --first-parent).</div><br/><div id="40952720" class="c"><input type="checkbox" id="c-40952720" checked=""/><div class="controls bullet"><span class="by">philwelch</span><span>|</span><a href="#40952545">parent</a><span>|</span><a href="#40952189">next</a><span>|</span><label class="collapse" for="c-40952720">[-]</label><label class="expand" for="c-40952720">[1 more]</label></div><br/><div class="children"><div class="content">I prefer the exact opposite approach personally: no merge commits, only rebases and fast-forward merges to master. Of course I never merge more than a handful of commits to master at a time—almost always just one—and if it’s more than one, it’s specifically because the diff is more understandable broken apart that way.<p>Though to be honest I am not sure what you mean by “jumbled” diffs. If you’re pushing a bunch of intermediary commits that don’t make sense on their own, don’t; that’s what interactive rebase is for. If you’re seeing jumbled diffs it might be specifically because you’re relying on merge commits instead of rebasing and fast-forwarding; if you consistently and diligently rebase that isn’t a problem.</div><br/></div></div></div></div><div id="40952189" class="c"><input type="checkbox" id="c-40952189" checked=""/><div class="controls bullet"><span class="by">dougthesnails</span><span>|</span><a href="#40952545">prev</a><span>|</span><a href="#40952190">next</a><span>|</span><label class="collapse" for="c-40952189">[-]</label><label class="expand" for="c-40952189">[1 more]</label></div><br/><div class="children"><div class="content">Be still my heart.</div><br/></div></div><div id="40951756" class="c"><input type="checkbox" id="c-40951756" checked=""/><div class="controls bullet"><span class="by">khana</span><span>|</span><a href="#40952190">prev</a><span>|</span><label class="collapse" for="c-40951756">[-]</label><label class="expand" for="c-40951756">[1 more]</label></div><br/><div class="children"><div class="content">and the winner:
Do the work up front to make your history atomic</div><br/></div></div></div></div></div></div></div></body></html>