<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1697965257734" as="style"/><link rel="stylesheet" href="styles.css?v=1697965257734"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.benburwell.com/posts/transactions-are-not-locks/">Transactions Are Not Locks (2022)</a> <span class="domain">(<a href="https://www.benburwell.com">www.benburwell.com</a>)</span></div><div class="subtext"><span>Paul-Craft</span> | <span>47 comments</span></div><br/><div><div id="37973813" class="c"><input type="checkbox" id="c-37973813" checked=""/><div class="controls bullet"><span class="by">grahamlee</span><span>|</span><a href="#37971505">next</a><span>|</span><label class="collapse" for="c-37973813">[-]</label><label class="expand" for="c-37973813">[1 more]</label></div><br/><div class="children"><div class="content">Lamport’s time&#x2F;clocks paper solves this exact problem, using this exact example, without locks.</div><br/></div></div><div id="37971505" class="c"><input type="checkbox" id="c-37971505" checked=""/><div class="controls bullet"><span class="by">aeonik</span><span>|</span><a href="#37973813">prev</a><span>|</span><a href="#37973012">next</a><span>|</span><label class="collapse" for="c-37971505">[-]</label><label class="expand" for="c-37971505">[14 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t store the state like this.<p>Just append an update to an immutable data store, and program the logic to unfold from the latest records.<p>See Diatomic: <a href="https:&#x2F;&#x2F;docs.datomic.com&#x2F;pro&#x2F;getting-started&#x2F;brief-overview.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.datomic.com&#x2F;pro&#x2F;getting-started&#x2F;brief-overview....</a></div><br/><div id="37972051" class="c"><input type="checkbox" id="c-37972051" checked=""/><div class="controls bullet"><span class="by">Spiwux</span><span>|</span><a href="#37971505">parent</a><span>|</span><a href="#37971629">next</a><span>|</span><label class="collapse" for="c-37972051">[-]</label><label class="expand" for="c-37972051">[6 more]</label></div><br/><div class="children"><div class="content">Are you suggesting everybody should use event sourcing instead of using transactions? Because the general consensus on event sourcing is &quot;don&#x27;t use it unless you absolutely have to.&quot;</div><br/><div id="37972605" class="c"><input type="checkbox" id="c-37972605" checked=""/><div class="controls bullet"><span class="by">kmeisthax</span><span>|</span><a href="#37971505">root</a><span>|</span><a href="#37972051">parent</a><span>|</span><a href="#37972507">next</a><span>|</span><label class="collapse" for="c-37972605">[-]</label><label class="expand" for="c-37972605">[2 more]</label></div><br/><div class="children"><div class="content">If you maintained financial records the way that database example code says you should, you&#x27;d be a terrible accountant.<p>Standard practice for accountancy is to record each transaction <i>twice</i>: once for the debited account and again for the credited account. You even create accounts for expenses and income; which are explicitly allowed to go negative (otherwise you couldn&#x27;t record income). This is known as double-entry accounting, and it&#x27;s equivalent to what you deride as &quot;event sourcing&quot;.<p>To put it back into the language of databases, double-entry accounting is the third normal form of accounting. You wouldn&#x27;t store a &quot;sum total of blog posts on a website&quot; row in your database schema now would you? Why would you have a &quot;sum total of transactions&quot; or single entries for your transactions that only show that money came in but not where it went?</div><br/><div id="37973657" class="c"><input type="checkbox" id="c-37973657" checked=""/><div class="controls bullet"><span class="by">crdrost</span><span>|</span><a href="#37971505">root</a><span>|</span><a href="#37972605">parent</a><span>|</span><a href="#37972507">next</a><span>|</span><label class="collapse" for="c-37973657">[-]</label><label class="expand" for="c-37973657">[1 more]</label></div><br/><div class="children"><div class="content">I think you are objecting to a poorly chosen example and that is okay. It _is_ a poorly chosen example.<p>The exact pedantry that you are making is kind of poorly chosen, in double-entry bookkeeping you would say that you record the transaction <i>proper</i> either once or <i>n</i> + 1 times, depending on how pedantic you are being. (Double-entry bookkeeping discovered the feature that in  filesystems is called “journaling,” you always write first to the transaction log, which is the “1” if you answer 1, then you update the <i>n</i> account ledger pages involved in the transaction with their individual deltas plus the transaction log ID.) A real bank also allows accounts to go negative all the time, which is another criticism.<p>The “event sourcing” is actually just the transaction log, which is not double entry, which is why I say that the pedantry is poorly chosen. The ledger, in combination with “closing the books for the year,” actually instantiates a generic construction for persisting data structures, see lectures at [1], where you take periodic snapshots of a value to limit your worst-case reconstruction time while storing a tractable buffer of deltas. The point of the ledger thus is to denormalize the data to make it efficient to answer the question, “how did this client&#x27;s balance change over time?” without seeking over the whole transaction log.<p>[1] <a href="https:&#x2F;&#x2F;courses.csail.mit.edu&#x2F;6.851&#x2F;spring21&#x2F;lectures&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;courses.csail.mit.edu&#x2F;6.851&#x2F;spring21&#x2F;lectures&#x2F;</a></div><br/></div></div></div></div><div id="37972507" class="c"><input type="checkbox" id="c-37972507" checked=""/><div class="controls bullet"><span class="by">strken</span><span>|</span><a href="#37971505">root</a><span>|</span><a href="#37972051">parent</a><span>|</span><a href="#37972605">prev</a><span>|</span><a href="#37973631">next</a><span>|</span><label class="collapse" for="c-37972507">[-]</label><label class="expand" for="c-37972507">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately financial systems are the one example everyone uses for transactions, and also the most obvious place where event sourcing is close to mandatory.</div><br/></div></div><div id="37973631" class="c"><input type="checkbox" id="c-37973631" checked=""/><div class="controls bullet"><span class="by">galkk</span><span>|</span><a href="#37971505">root</a><span>|</span><a href="#37972051">parent</a><span>|</span><a href="#37972507">prev</a><span>|</span><a href="#37973753">next</a><span>|</span><label class="collapse" for="c-37973631">[-]</label><label class="expand" for="c-37973631">[1 more]</label></div><br/><div class="children"><div class="content">I suspect that parent suggested to use something like lsm trees as storage layer. They are append only. Event sourcing usually operates on much higher abstaction levels<p>(P.s. personally I don’t believe in event sourcing at all. This is a great idea that just doesn’t seem to work in practice).</div><br/></div></div><div id="37973753" class="c"><input type="checkbox" id="c-37973753" checked=""/><div class="controls bullet"><span class="by">civilitty</span><span>|</span><a href="#37971505">root</a><span>|</span><a href="#37972051">parent</a><span>|</span><a href="#37973631">prev</a><span>|</span><a href="#37971629">next</a><span>|</span><label class="collapse" for="c-37973753">[-]</label><label class="expand" for="c-37973753">[1 more]</label></div><br/><div class="children"><div class="content">Event sourcing as a system wide architecture is very difficult to pull off well but it works perfectly fine when applied to a narrow use case.<p>It can be as simple as a Postgres append only table keyed by an (id, version) tuple with a JSON column for the change event. You don’t need to pull in the whole enterprise pattern with aggregates, projections, etc to get the essence of event sourcing.</div><br/></div></div></div></div><div id="37971629" class="c"><input type="checkbox" id="c-37971629" checked=""/><div class="controls bullet"><span class="by">jimbob45</span><span>|</span><a href="#37971505">parent</a><span>|</span><a href="#37972051">prev</a><span>|</span><a href="#37971546">next</a><span>|</span><label class="collapse" for="c-37971629">[-]</label><label class="expand" for="c-37971629">[1 more]</label></div><br/><div class="children"><div class="content">That sounds like you’re suggesting Event Sourcing?</div><br/></div></div><div id="37971546" class="c"><input type="checkbox" id="c-37971546" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#37971505">parent</a><span>|</span><a href="#37971629">prev</a><span>|</span><a href="#37973011">next</a><span>|</span><label class="collapse" for="c-37971546">[-]</label><label class="expand" for="c-37971546">[4 more]</label></div><br/><div class="children"><div class="content">i like this model, but i think the goal was to enforce a constraint (non-negative balance) and fail the operation, reporting that result to the requester. how do you do that in the monotonic style?</div><br/><div id="37971835" class="c"><input type="checkbox" id="c-37971835" checked=""/><div class="controls bullet"><span class="by">btown</span><span>|</span><a href="#37971505">root</a><span>|</span><a href="#37971546">parent</a><span>|</span><a href="#37971676">next</a><span>|</span><label class="collapse" for="c-37971835">[-]</label><label class="expand" for="c-37971835">[2 more]</label></div><br/><div class="children"><div class="content">In theory, in event sourcing, a reader would enumerate every proposed transaction, in order, and skip any invalid ones (or ones invalidated by a separate invalidation stream). This is expensive, so a materialized Balances table might be created and maintained - not by the database per se, but by a dedicated stream ingesting process. The user might also asynchronously see a set of failed operations - synchronous is harder, but doable if you block on polling for the stream processing result, or have an “await key” primitive. Or just wait a second or two to refresh the page.<p>There’s a lot of machinery involved, and a subtle logic change or error could invalidate balances for your entire client base. The transactional approach, with event sourcing used as an audit utility used by humans to verify correctness, is often a better path.</div><br/><div id="37972504" class="c"><input type="checkbox" id="c-37972504" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#37971505">root</a><span>|</span><a href="#37971835">parent</a><span>|</span><a href="#37971676">next</a><span>|</span><label class="collapse" for="c-37972504">[-]</label><label class="expand" for="c-37972504">[1 more]</label></div><br/><div class="children"><div class="content">This episode of Signals &amp; Threads discusses a system (an exchange for OTC securities) which is both event sourced and which has constraints. It works in the same way you&#x27;ve described modulo some implementation details. <a href="https:&#x2F;&#x2F;signalsandthreads.com&#x2F;state-machine-replication-and-why-you-should-care&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;signalsandthreads.com&#x2F;state-machine-replication-and-...</a><p>Most of us are never going to work with a system with the scale and SLA to necessitate this approach, but it&#x27;s an enjoyable interview nonetheless.</div><br/></div></div></div></div><div id="37971676" class="c"><input type="checkbox" id="c-37971676" checked=""/><div class="controls bullet"><span class="by">pico303</span><span>|</span><a href="#37971505">root</a><span>|</span><a href="#37971546">parent</a><span>|</span><a href="#37971835">prev</a><span>|</span><a href="#37973011">next</a><span>|</span><label class="collapse" for="c-37971676">[-]</label><label class="expand" for="c-37971676">[1 more]</label></div><br/><div class="children"><div class="content">You don’t. The original suggestion isn’t a good one for a constrained system like bank balances.</div><br/></div></div></div></div><div id="37973011" class="c"><input type="checkbox" id="c-37973011" checked=""/><div class="controls bullet"><span class="by">yowlingcat</span><span>|</span><a href="#37971505">parent</a><span>|</span><a href="#37971546">prev</a><span>|</span><a href="#37973012">next</a><span>|</span><label class="collapse" for="c-37973011">[-]</label><label class="expand" for="c-37973011">[2 more]</label></div><br/><div class="children"><div class="content">This is not just an ignorant idea but a stupid idea. Just because you can&#x27;t figure out the right way to do it in vanilla SQL doesn&#x27;t mean it can&#x27;t be done [1]. This strawman is just a different form of the NoSQL strawman [2].<p>Edit: Ah, looks like I&#x27;ve struck a nerve with the event sourcing Datomic fanboys. Enjoy using your golden hammer and turning every problem into a nail!<p>By the way, if you ever make my way into my organization and waste my time with this nonsense, I WILL fire you. Nobody should tolerate your desire to solve already-solved problems with poorer quality solutions you have selected for their novelty. At that point, I&#x27;ll kindly ask you to please explain to me what a write ahead log is and what it does, because if you don&#x27;t, I&#x27;ll happily explain it for you.<p>[1] <a href="https:&#x2F;&#x2F;brandur.org&#x2F;idempotency-keys" rel="nofollow noreferrer">https:&#x2F;&#x2F;brandur.org&#x2F;idempotency-keys</a><p>[2] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=b2F-DItXtZs">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=b2F-DItXtZs</a></div><br/><div id="37973847" class="c"><input type="checkbox" id="c-37973847" checked=""/><div class="controls bullet"><span class="by">paranoidrobot</span><span>|</span><a href="#37971505">root</a><span>|</span><a href="#37973011">parent</a><span>|</span><a href="#37973012">next</a><span>|</span><label class="collapse" for="c-37973847">[-]</label><label class="expand" for="c-37973847">[1 more]</label></div><br/><div class="children"><div class="content">Re your edit: I suspect that down voter&#x27;s issue with your post is the aggressive nature of it.</div><br/></div></div></div></div></div></div><div id="37973012" class="c"><input type="checkbox" id="c-37973012" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#37971505">prev</a><span>|</span><a href="#37971824">next</a><span>|</span><label class="collapse" for="c-37973012">[-]</label><label class="expand" for="c-37973012">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t look before you jump, instead look after you jump, because then you can rollback and undo the hurt :)<p>You can do this with deferred triggers, for example.  Here&#x27;s where a COMMIT trigger would be handy -- something that runs when the client&#x27;s COMMIT begins executing (though other triggers could still run in the COMMIT trigger were to execute any DMLs).</div><br/></div></div><div id="37971824" class="c"><input type="checkbox" id="c-37971824" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#37973012">prev</a><span>|</span><a href="#37972166">next</a><span>|</span><label class="collapse" for="c-37971824">[-]</label><label class="expand" for="c-37971824">[6 more]</label></div><br/><div class="children"><div class="content">If you have external side-effects, and your transaction fails, undo whatever you did in the external system. Don&#x27;t just roll-back your database, but forget to &quot;request your money back&quot; from that system.<p>And remember, don&#x27;t use transactions when you cannot compensate the failure. For example, if you were to transfer money to an external bank, you probably can&#x27;t just &quot;undo&quot; the sending of money. Your bank is on the hook for that money, so if, for example, the account you withdrew money from would now be negative ... you probably want it to still be negative if a failure happens ... instead of staying zero after rolling back the transaction. Otherwise, that other bank is going to come asking for that money you said you sent them.</div><br/><div id="37972320" class="c"><input type="checkbox" id="c-37972320" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#37971824">parent</a><span>|</span><a href="#37972311">next</a><span>|</span><label class="collapse" for="c-37972320">[-]</label><label class="expand" for="c-37972320">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d caution against holding a transaction for the duration of an API call to a foreign system. API calls can take a very long time, especially if you are retrying on timeouts. Long lived transactions are dangerous, because it prevents you from releasing locks, which interferes with concurrent transactions and with vacuuming. I&#x27;ve seen it bring down production before.<p>Consider for example the following scenario; you are experiencing higher than normal load, leading you to send a lot of requests to this other system. Their scaling is flawed, and your traffic actually brings them down. This leads to timeouts and long transaction times. Now you are holding lots of locks for a very long time, and you database is under a heavy load - you&#x27;re now in danger of overloading your database and going down.<p>I&#x27;d suggest commiting a record representing your intention to integrate with this other system, executing your API call, and <i>then</i> updating your state (assuming the call is successful). (For the example above, circuit breakers would also be an important mitigation.)</div><br/></div></div><div id="37972311" class="c"><input type="checkbox" id="c-37972311" checked=""/><div class="controls bullet"><span class="by">JoshGlazebrook</span><span>|</span><a href="#37971824">parent</a><span>|</span><a href="#37972320">prev</a><span>|</span><a href="#37972166">next</a><span>|</span><label class="collapse" for="c-37972311">[-]</label><label class="expand" for="c-37972311">[4 more]</label></div><br/><div class="children"><div class="content">This is a major pain point with dealing with Stripe. If you want to write a record in your local db (to record a cancellation), then call the stripe api to say cancel a subscription, if the api call fails, you can rollback your db changes by failing the transaction.<p>If the api call succeeds, but your transaction fails to write to the db and rollsback, then what?<p>You then have to rely on the Stripe webhooks to &quot;sync&quot; your local db state with what stripe has, oh but don&#x27;t forget stripe webhooks don&#x27;t have any guaranteed order in which they are delivered, so just ignore all of the event data, you have to fetch the current state of the stripe object your event is associated with and make sure the handling of these events are idempotent.<p>It&#x27;s not wise to rely solely on Stripe being the source of truth, but there is no way to really implement 2 phase commit with external services like this. Maybe you fire off an event into a pubsub or queue to handle the actual writing to your db, but what if the webhook gets to your service first?<p>Shit is hard.</div><br/><div id="37973861" class="c"><input type="checkbox" id="c-37973861" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#37971824">root</a><span>|</span><a href="#37972311">parent</a><span>|</span><a href="#37972545">next</a><span>|</span><label class="collapse" for="c-37973861">[-]</label><label class="expand" for="c-37973861">[1 more]</label></div><br/><div class="children"><div class="content">Any sync needs two phases:<p>- active state transitions (webhooks)<p>- reconciliation (api)<p>You can do reconciliation without active state transitions, but it usually takes awhile (slow and scheduled). However, it’s a requirement with webhooks because you don’t know if they are in-order or delayed or just broken. Thus, you need to reconcile your state every so often.</div><br/></div></div><div id="37972545" class="c"><input type="checkbox" id="c-37972545" checked=""/><div class="controls bullet"><span class="by">yencabulator</span><span>|</span><a href="#37971824">root</a><span>|</span><a href="#37972311">parent</a><span>|</span><a href="#37973861">prev</a><span>|</span><a href="#37972438">next</a><span>|</span><label class="collapse" for="c-37972545">[-]</label><label class="expand" for="c-37972545">[1 more]</label></div><br/><div class="children"><div class="content">You record a want-to-cancel state, and then only after Stripe acknowledges the cancellation you transition from want-to-cancel to cancelled. State machines.</div><br/></div></div><div id="37972438" class="c"><input type="checkbox" id="c-37972438" checked=""/><div class="controls bullet"><span class="by">tynorf</span><span>|</span><a href="#37971824">root</a><span>|</span><a href="#37972311">parent</a><span>|</span><a href="#37972545">prev</a><span>|</span><a href="#37972166">next</a><span>|</span><label class="collapse" for="c-37972438">[-]</label><label class="expand" for="c-37972438">[1 more]</label></div><br/><div class="children"><div class="content">You might be interested in this: <a href="https:&#x2F;&#x2F;brandur.org&#x2F;idempotency-keys" rel="nofollow noreferrer">https:&#x2F;&#x2F;brandur.org&#x2F;idempotency-keys</a></div><br/></div></div></div></div></div></div><div id="37972166" class="c"><input type="checkbox" id="c-37972166" checked=""/><div class="controls bullet"><span class="by">karmakaze</span><span>|</span><a href="#37971824">prev</a><span>|</span><a href="#37972701">next</a><span>|</span><label class="collapse" for="c-37972166">[-]</label><label class="expand" for="c-37972166">[6 more]</label></div><br/><div class="children"><div class="content">For complete&#x2F;correctness:<p><pre><code>  select balance from accounts where name = &#x27;A&#x27; for update;
</code></pre>
&gt; Now, other transactions won’t be able to read this row until our transaction is committed or rolled back (for update can only be used inside a transaction).<p>This is true for SERIALIZABLE isolation. Depending on the configured isolation level (e.g. READ COMMITTED aka snapshot) other concurrent transactions can read (but not update) the locked row, which can lead to write skew.</div><br/><div id="37972620" class="c"><input type="checkbox" id="c-37972620" checked=""/><div class="controls bullet"><span class="by">Alpi</span><span>|</span><a href="#37972166">parent</a><span>|</span><a href="#37972262">next</a><span>|</span><label class="collapse" for="c-37972620">[-]</label><label class="expand" for="c-37972620">[1 more]</label></div><br/><div class="children"><div class="content">FOR UPDATE locks the row for other blocking transactions (including another select for update)
The weaker form that only locks updates and deletes is called FOR SHARE.
Transaction isolation levels do not make a difference here.<p><a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;explicit-locking.html#LOCKING-ROWS" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;explicit-locking.htm...</a><p>So the article is correct that SELECT FOR UPDATE will ensure that another concurrent SELECT FOR UPDATE transaction never acquire the same row (it will block), though nothing prevents other non-blocking selects to query this row concurrently.<p>You can think of it as usual locks - only the threads that explicitly use the same lock have the mutual exclusion guarantees. If there’s another thread that does not acquire the lock and tries to access the critical section - it will be able to do so.</div><br/></div></div><div id="37972262" class="c"><input type="checkbox" id="c-37972262" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#37972166">parent</a><span>|</span><a href="#37972620">prev</a><span>|</span><a href="#37972701">next</a><span>|</span><label class="collapse" for="c-37972262">[-]</label><label class="expand" for="c-37972262">[4 more]</label></div><br/><div class="children"><div class="content">ETA: I misread, I thought you were referring to the table lock section, but you were referring to the row lock section. You&#x27;re correct, FOR UPDATE locks do not prevent concurrent reads, which could cause a concurrency problem if you&#x27;re not very careful (and Murphy&#x27;s law applies).<p>---<p>The article is correct. That section contains this snippet:<p><pre><code>    lock table accounts;
</code></pre>
The default lock mode for LOCK is ACCESS EXCLUSIVE, which will prevent concurrent reads.<p><pre><code>    ACCESS EXCLUSIVE (AccessExclusiveLock)

    Conflicts with locks of all modes [...]. This mode guarantees that the holder is the only transaction accessing the table in any way.
</code></pre>
<a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;explicit-locking.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;explicit-locking.htm...</a></div><br/><div id="37972526" class="c"><input type="checkbox" id="c-37972526" checked=""/><div class="controls bullet"><span class="by">yencabulator</span><span>|</span><a href="#37972166">root</a><span>|</span><a href="#37972262">parent</a><span>|</span><a href="#37972668">next</a><span>|</span><label class="collapse" for="c-37972526">[-]</label><label class="expand" for="c-37972526">[2 more]</label></div><br/><div class="children"><div class="content">The part that has &quot;for update&quot; doesn&#x27;t have &quot;lock table&quot;.</div><br/><div id="37972561" class="c"><input type="checkbox" id="c-37972561" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#37972166">root</a><span>|</span><a href="#37972526">parent</a><span>|</span><a href="#37972668">next</a><span>|</span><label class="collapse" for="c-37972561">[-]</label><label class="expand" for="c-37972561">[1 more]</label></div><br/><div class="children"><div class="content">My bad, thanks.</div><br/></div></div></div></div><div id="37972668" class="c"><input type="checkbox" id="c-37972668" checked=""/><div class="controls bullet"><span class="by">Alpi</span><span>|</span><a href="#37972166">root</a><span>|</span><a href="#37972262">parent</a><span>|</span><a href="#37972526">prev</a><span>|</span><a href="#37972701">next</a><span>|</span><label class="collapse" for="c-37972668">[-]</label><label class="expand" for="c-37972668">[1 more]</label></div><br/><div class="children"><div class="content">For update actually does block concurrent SELECT FOR UPDATES, so the article is correct</div><br/></div></div></div></div></div></div><div id="37972701" class="c"><input type="checkbox" id="c-37972701" checked=""/><div class="controls bullet"><span class="by">comvidyarthi</span><span>|</span><a href="#37972166">prev</a><span>|</span><a href="#37971540">next</a><span>|</span><label class="collapse" for="c-37972701">[-]</label><label class="expand" for="c-37972701">[1 more]</label></div><br/><div class="children"><div class="content">I don’t understand the title of the article. The article essentially talks about what RepeatableRead isolation levels of Postgresql cannot do and how to remedy that by Serialize Isolation. But both need lock at some level, and tradeoff performance guarantees for 
weaker&#x2F;stronger consistency guarantees.</div><br/></div></div><div id="37971540" class="c"><input type="checkbox" id="c-37971540" checked=""/><div class="controls bullet"><span class="by">CaliforniaKarl</span><span>|</span><a href="#37972701">prev</a><span>|</span><a href="#37971758">next</a><span>|</span><label class="collapse" for="c-37971540">[-]</label><label class="expand" for="c-37971540">[5 more]</label></div><br/><div class="children"><div class="content">For the row-locking example, wouldn’t it be better to include both A and B in the SELECT, so that the FOR UPDATE can lock both records?  Even if using strict serialization, I wonder if FOR UPDATE-ing both rows would help stop (or delay) other conflicting transactions.</div><br/><div id="37971662" class="c"><input type="checkbox" id="c-37971662" checked=""/><div class="controls bullet"><span class="by">CraigJPerry</span><span>|</span><a href="#37971540">parent</a><span>|</span><a href="#37971758">next</a><span>|</span><label class="collapse" for="c-37971662">[-]</label><label class="expand" for="c-37971662">[4 more]</label></div><br/><div class="children"><div class="content">Yeah without including A and B there’s a risk of deadlock</div><br/><div id="37971928" class="c"><input type="checkbox" id="c-37971928" checked=""/><div class="controls bullet"><span class="by">rowls66</span><span>|</span><a href="#37971540">root</a><span>|</span><a href="#37971662">parent</a><span>|</span><a href="#37971758">next</a><span>|</span><label class="collapse" for="c-37971928">[-]</label><label class="expand" for="c-37971928">[3 more]</label></div><br/><div class="children"><div class="content">To avoid deadlock, you need to ensure that locking happens in the same order in all concurrent transactions. So account A must be locked before account B and never in the opposite order. So if account B is the account being debited and therefore the account that needs to have a sufficient balance, then account A must be locked first. If account A is the account to be debited, then explicitly locking account B is not necessary. It will be locked when its updated.</div><br/><div id="37972154" class="c"><input type="checkbox" id="c-37972154" checked=""/><div class="controls bullet"><span class="by">karmakaze</span><span>|</span><a href="#37971540">root</a><span>|</span><a href="#37971928">parent</a><span>|</span><a href="#37971758">next</a><span>|</span><label class="collapse" for="c-37972154">[-]</label><label class="expand" for="c-37972154">[2 more]</label></div><br/><div class="children"><div class="content">I think I agree but was hard to parse the message. My summary would be to always lock A and B in the same order <i>(e.g. smallest account number first)</i> regardless of which is being reduced or increased. In addition, an UPDATE statement counts as lock so doesn&#x27;t need a SELECT ... FOR UPDATE if it&#x27;s the 2nd one that you want to do.</div><br/><div id="37973400" class="c"><input type="checkbox" id="c-37973400" checked=""/><div class="controls bullet"><span class="by">CraigJPerry</span><span>|</span><a href="#37971540">root</a><span>|</span><a href="#37972154">parent</a><span>|</span><a href="#37971758">next</a><span>|</span><label class="collapse" for="c-37973400">[-]</label><label class="expand" for="c-37973400">[1 more]</label></div><br/><div class="children"><div class="content">If transaction 1 and 2 are running the example and the ordering is something like:<p><pre><code>    txn1 = db.begin()

    # implicit exclusive row lock established here on A row, exclusive rather than shared read because we say for update
    currBalance1 = txn1.query(&#x27;select balance from accounts where name = A for update’)

    … &lt;snipped some of the example code&gt; …

    txn1.execute(&#x27;update accounts set balance = balance - $amount where name = A&#x27;)

    # Concurrently tx2 begins, tx1 has locked row A so far
    txn2 = db.begin()

    # we’re exclusively locking row B in txn2
    currBalance2 = txn2.query(&#x27;select balance from accounts where name = B for update’)

    # This is the first point in transaction 1 where we take an exclusive lock on B, however we are deadlocked now
    txn1.execute(&#x27;update accounts set balance = balance + $amount where name = B&#x27;)
</code></pre>
The solution is what the parent suggested, take the exclusive locks on rows A&amp;B at the same time because if transaction 2 is locking B&amp;C you can’t afford to do 2 separate for update calls because b might get locked as you’ve just locked A and were about to lock B<p><pre><code>    select balance from accounts where name = &#x27;A&#x27; or name = ‘B’ for update</code></pre></div><br/></div></div></div></div></div></div></div></div></div></div><div id="37971758" class="c"><input type="checkbox" id="c-37971758" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#37971540">prev</a><span>|</span><a href="#37972176">next</a><span>|</span><label class="collapse" for="c-37971758">[-]</label><label class="expand" for="c-37971758">[6 more]</label></div><br/><div class="children"><div class="content">Bank accounts... It&#x27;s always bank accounts</div><br/><div id="37972347" class="c"><input type="checkbox" id="c-37972347" checked=""/><div class="controls bullet"><span class="by">bastawhiz</span><span>|</span><a href="#37971758">parent</a><span>|</span><a href="#37972176">next</a><span>|</span><label class="collapse" for="c-37972347">[-]</label><label class="expand" for="c-37972347">[5 more]</label></div><br/><div class="children"><div class="content">In fairness, it&#x27;s a great example. Moving money between accounts requires updating the state of at least two records. Moreover, nearly everyone working with databases has one or at least understands how a bank account should work. And as far as relevant examples go, I can&#x27;t think of anything else where the correctness of the operation is quite as critical.</div><br/><div id="37972766" class="c"><input type="checkbox" id="c-37972766" checked=""/><div class="controls bullet"><span class="by">ludston</span><span>|</span><a href="#37971758">root</a><span>|</span><a href="#37972347">parent</a><span>|</span><a href="#37972552">next</a><span>|</span><label class="collapse" for="c-37972766">[-]</label><label class="expand" for="c-37972766">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a deceptive example because banks are distributed systems (in that they interoperate with other banks&#x2F;financial systems, and often have distributed internal database systems across multiple products too). Regular db transactions are insufficient for ensuring consistency across a distributed system, primarily because one of the systems may fail to commit their transaction after the other has succeeded. Even if there is only a single database, protecting data against concurrency issues is still non-trivial even with transactions.</div><br/></div></div><div id="37972552" class="c"><input type="checkbox" id="c-37972552" checked=""/><div class="controls bullet"><span class="by">yencabulator</span><span>|</span><a href="#37971758">root</a><span>|</span><a href="#37972347">parent</a><span>|</span><a href="#37972766">prev</a><span>|</span><a href="#37972613">next</a><span>|</span><label class="collapse" for="c-37972552">[-]</label><label class="expand" for="c-37972552">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a bad example because bank accounts <i>don&#x27;t</i> work like this. Accounting etc use an append-only ledger.</div><br/><div id="37972928" class="c"><input type="checkbox" id="c-37972928" checked=""/><div class="controls bullet"><span class="by">throwawaybkkg</span><span>|</span><a href="#37971758">root</a><span>|</span><a href="#37972552">parent</a><span>|</span><a href="#37972613">next</a><span>|</span><label class="collapse" for="c-37972928">[-]</label><label class="expand" for="c-37972928">[1 more]</label></div><br/><div class="children"><div class="content">There is no one true way that bank accounts work. I work for a big bank and I&#x27;ve come to accept that there are valid cases for UPDATING and even DELETING transactions in your Core Banking system. It is true that your general ledger is append-only, but that doesn&#x27;t apply to what happens before you close your books.</div><br/></div></div></div></div><div id="37972613" class="c"><input type="checkbox" id="c-37972613" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#37971758">root</a><span>|</span><a href="#37972347">parent</a><span>|</span><a href="#37972552">prev</a><span>|</span><a href="#37972176">next</a><span>|</span><label class="collapse" for="c-37972613">[-]</label><label class="expand" for="c-37972613">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, there&#x27;s a reason and that&#x27;s the reason.<p>I just wish it were applicable to something else.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>