<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1710838876782" as="style"/><link rel="stylesheet" href="styles.css?v=1710838876782"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://vanhunteradams.com/Pico/Bootloader/Boot_sequence.html">RP2040 Boot Sequence</a>Â <span class="domain">(<a href="https://vanhunteradams.com">vanhunteradams.com</a>)</span></div><div class="subtext"><span>vmoore</span> | <span>47 comments</span></div><br/><div><div id="39748008" class="c"><input type="checkbox" id="c-39748008" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#39748743">next</a><span>|</span><label class="collapse" for="c-39748008">[-]</label><label class="expand" for="c-39748008">[7 more]</label></div><br/><div class="children"><div class="content">For those wondering about why there&#x27;s both a boot ROM and the boot2 in flash:<p>The flash chips used support both a basic SPI mode, and an advanced QSPI mode. There is a well-defined standard protocol for basic SPI mode, so virtually all chips will respond to the same read command for simple slow byte-by-byte reading. The only thing left to try is the four SPI modes (Does clock idle high or low? Do we transfer on the full pulse, or on the half pulse?) - hardware often even supports two of them, and there&#x27;s only one set which actually makes sense.<p>QSPI, on the other hand, is more of a wild-west. You need to run a bunch of chip-specific commands to enter QSPI mode, and there are quite a few possible variations for QSPI read commands, not to mention a lot of different timing requirements. Trying out all of them isn&#x27;t really possible, hence the chip-specific boot2 segment.<p>Staying in SPI mode isn&#x27;t really viable either because the application code is stored in the flash chip. To give an example, jumping to a random instruction would incur a 1280 ns read with a W25Q80BW flash chip operating in SPI mode (realistically x10 due to a lower safe clock frequency), whereas QSPI mode can reliably do that in as little as 125 ns. With the RP2040 running at 133MHz a 16-cycle delay for a random jump or a read from a data block is not too bad, but a 170 or even 1700-cycle delay is just way too much.</div><br/><div id="39752499" class="c"><input type="checkbox" id="c-39752499" checked=""/><div class="controls bullet"><span class="by">mips_r4300i</span><span>|</span><a href="#39748008">parent</a><span>|</span><a href="#39748289">next</a><span>|</span><label class="collapse" for="c-39752499">[-]</label><label class="expand" for="c-39752499">[2 more]</label></div><br/><div class="children"><div class="content">Great info, and now some chips are supporting Octo-SPI which is even more vendor dependent. At some point we&#x27;re basically back to parallel flash...</div><br/><div id="39752929" class="c"><input type="checkbox" id="c-39752929" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#39748008">root</a><span>|</span><a href="#39752499">parent</a><span>|</span><a href="#39748289">next</a><span>|</span><label class="collapse" for="c-39752929">[-]</label><label class="expand" for="c-39752929">[1 more]</label></div><br/><div class="children"><div class="content">TBH, a lot of the details are fairly standardized across vendors, and&#x2F;or are discoverable through SFDP. Parsing the SFDP tables would take a nontrivial amount of program memory, though; I don&#x27;t know as I&#x27;d want to embed that logic in ROM.</div><br/></div></div></div></div><div id="39748289" class="c"><input type="checkbox" id="c-39748289" checked=""/><div class="controls bullet"><span class="by">stevefolta</span><span>|</span><a href="#39748008">parent</a><span>|</span><a href="#39752499">prev</a><span>|</span><a href="#39748743">next</a><span>|</span><label class="collapse" for="c-39748289">[-]</label><label class="expand" for="c-39748289">[4 more]</label></div><br/><div class="children"><div class="content">And where the document talks about SSI, it essentially means SPI (just with differential signalling etc.)?  In other words, is it this SSI?: &lt;<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Synchronous_Serial_Interface" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Synchronous_Serial_Interface</a>&gt;</div><br/><div id="39748611" class="c"><input type="checkbox" id="c-39748611" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#39748008">root</a><span>|</span><a href="#39748289">parent</a><span>|</span><a href="#39748743">next</a><span>|</span><label class="collapse" for="c-39748611">[-]</label><label class="expand" for="c-39748611">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a &quot;synchronous serial interface&quot; similar to SPI, but that isn&#x27;t what the Wikipedia article you&#x27;re linking to is about.<p>It&#x27;s the DW_apb_ssi peripheral from Synopsys (<a href="https:&#x2F;&#x2F;www.synopsys.com&#x2F;dw&#x2F;ipdir.php?c=DW_apb_ssi" rel="nofollow">https:&#x2F;&#x2F;www.synopsys.com&#x2F;dw&#x2F;ipdir.php?c=DW_apb_ssi</a>).</div><br/><div id="39749680" class="c"><input type="checkbox" id="c-39749680" checked=""/><div class="controls bullet"><span class="by">tonyarkles</span><span>|</span><a href="#39748008">root</a><span>|</span><a href="#39748611">parent</a><span>|</span><a href="#39748743">next</a><span>|</span><label class="collapse" for="c-39749680">[-]</label><label class="expand" for="c-39749680">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s always a bit funny to me how much of the Synopsis IP ends up in different chips. As an example a decade+ ago I implemented a from-scratch USB Peripheral stack on an STM32 microcontroller, basically because the vendor SDK wasn&#x27;t capable of doing what I needed or being readily modified to do what I needed. A couple of years ago I was debugging some firmware for a chip from a completely different vendor and noticed that the USB registers looked... familiar. Looked back at the original project and was somewhat surprised to discover that it was exactly the same registers in the same order just mapped to a different spot in memory.</div><br/><div id="39753876" class="c"><input type="checkbox" id="c-39753876" checked=""/><div class="controls bullet"><span class="by">dezgeg</span><span>|</span><a href="#39748008">root</a><span>|</span><a href="#39749680">parent</a><span>|</span><a href="#39748743">next</a><span>|</span><label class="collapse" for="c-39753876">[-]</label><label class="expand" for="c-39753876">[1 more]</label></div><br/><div class="children"><div class="content">The same thing has happened in the Linux kernel - there are multiple semi-duplicate SoC USB drivers for the Synopsys core.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39748743" class="c"><input type="checkbox" id="c-39748743" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#39748008">prev</a><span>|</span><a href="#39747443">next</a><span>|</span><label class="collapse" for="c-39748743">[-]</label><label class="expand" for="c-39748743">[26 more]</label></div><br/><div class="children"><div class="content">This complexity forced me to abandon it for learning and switch to STM32. I was able to write blinky with few dozens of assembly instructions for STM32. I spent like month reading about SPI, QSPI, flash chips and still was not able to understand how to proceed with RP2040 other than copy&amp;paste their &quot;bootloader&quot; as an opaque blob.<p>May be I&#x27;m weird, but for me RP2040 was terrible chip for learning ARM. STM32 on the other hand just worked and I gradually learned to blink the chip, to write linker script, to write UART, to use C, to use CMSIS and so on. In the end I was able to write a commercial firmware with it.<p>I understand that if I would just use their SDK with cmake, that wouldn&#x27;t be a problem, but I&#x27;m not going to use their SDK. I hate cmake and I need to understand everything from the ground up.<p>I think that at this moment I can grok this bootloader and write my own version of it, because I know much more about it, but it wouldn&#x27;t serve its purpose as a chip for learning.<p>IMO that&#x27;s a flawed approach: to throw infinitely complex tools onto a beginner. It&#x27;s much easier to start simple, with just an assembler and may be linker. And a chip for beginners must not require those complex initialization procedures.<p>This chip is also incredibly complex with its two cores and PIO cores. It&#x27;s absolutely cool thing, but it&#x27;s absolutely not for beginners, it&#x27;s for experienced engineers. I&#x27;d prefer something simple, like STM32, with built-in flash, but with proper documentation and without any compromises. Like flexible voltage source, on-board programmer, plenty of hardware blocks, not cheap price (because who cares if chip cost is $1 or $10 for hobby).<p>RP2040 documentation is superb, I must admit. That&#x27;s what they did perfectly.</div><br/><div id="39750402" class="c"><input type="checkbox" id="c-39750402" checked=""/><div class="controls bullet"><span class="by">freedom-fries</span><span>|</span><a href="#39748743">parent</a><span>|</span><a href="#39749282">next</a><span>|</span><label class="collapse" for="c-39750402">[-]</label><label class="expand" for="c-39750402">[9 more]</label></div><br/><div class="children"><div class="content">&gt; May be I&#x27;m weird, but for me RP2040 was terrible chip for learning ARM. STM32 on the other hand just worked<p>My experience was opposite of yours. I found RP2040 refreshing compared to the complexity of dealing with proprietary toolchains that other devices required for me to start working with their chips. Nearly every part of RP2040 was documented in great detail and usable exclusively with the tools I could find in Arch Linux repo (when using Linux) and Homebrew (when using Mac). I could drop down to assembly or move up to C++, or even Rust or Python depending on whether I wanted to tool around or just get things done.<p>Even more impressive was that I was able to use debugger with another RP2040 Pico acting as SWD debug probe (Google Picoprobe) which again worked the same across Mac and Linux with the software I already had (gdb) and saved me from buying yet another piece of JTAG hardware with questionable software support.<p>Oh, and <i>every</i> single software with RP2040, including UF2 boot-rom, second stage bootloader and examples are on Github, which allowed me to go as deep as I wanted and more importantly, just get on with what I needed to do when I wanted things to just work.<p>I&#x27;ve worked with uC on and off, but never I have worked with a uC that just worked with just worked with tools I already had. I now work exclusively with RP2040, even when I find other chips much more capable (ESP32 in this case). RP2040 allows me to futz around as long as I want, as deep or shallow as I have time on hand, plus when I stop futzing around, it allows me to just flash new ROM over USB and get on do what I &#x2F;need&#x2F; to do.<p>Oh.. and I just <i>love</i> the USB mass-storage mode â no more custom flasher tools, just `cp blah.uf2 &#x2F;mnt&#x2F;RP2040&#x2F;` and off I go. I can smoke it, but I can&#x27;t brick it! Plus, when I need quick iteration I can just use PicoProbe and do `code - flash - debug - code` almost as fast as I can hit keyboard buttons.<p>RP2040 is a game changer for me!</div><br/><div id="39751624" class="c"><input type="checkbox" id="c-39751624" checked=""/><div class="controls bullet"><span class="by">mardifoufs</span><span>|</span><a href="#39748743">root</a><span>|</span><a href="#39750402">parent</a><span>|</span><a href="#39751075">next</a><span>|</span><label class="collapse" for="c-39751624">[-]</label><label class="expand" for="c-39751624">[5 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t the toolchain for the esp almost fully open source (ESP-IDF)? The only part that aren&#x27;t super open on the esp32 are the radio related firmware and blobs, but those are just not even there in the rp2040 anyways and not related to the toolchain itself.</div><br/><div id="39753041" class="c"><input type="checkbox" id="c-39753041" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#39748743">root</a><span>|</span><a href="#39751624">parent</a><span>|</span><a href="#39751075">next</a><span>|</span><label class="collapse" for="c-39753041">[-]</label><label class="expand" for="c-39753041">[4 more]</label></div><br/><div class="children"><div class="content">If I recall correctly, a not-insignificant issue is (was?) that the ESP is based on the relatively obscure Xtensa microarchitecture - which is poorly supported (if at all) by the regular open-source toolchain. This means you have to use forks provided by Espressif, rather than just using the standard ones provided by your OS.<p>It&#x27;s still open-source so a lot better than having to use a proprietary compiler or IDE, but it&#x27;s a lot more involved than just your regular bundle of C libraries you can use with your normal tooling.</div><br/><div id="39753171" class="c"><input type="checkbox" id="c-39753171" checked=""/><div class="controls bullet"><span class="by">sam_bristow</span><span>|</span><a href="#39748743">root</a><span>|</span><a href="#39753041">parent</a><span>|</span><a href="#39751075">next</a><span>|</span><label class="collapse" for="c-39753171">[-]</label><label class="expand" for="c-39753171">[3 more]</label></div><br/><div class="children"><div class="content">I believe newer ESP32 chips are based on the Risc-V microarchitecture.</div><br/><div id="39753270" class="c"><input type="checkbox" id="c-39753270" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#39748743">root</a><span>|</span><a href="#39753171">parent</a><span>|</span><a href="#39751075">next</a><span>|</span><label class="collapse" for="c-39753270">[-]</label><label class="expand" for="c-39753270">[2 more]</label></div><br/><div class="children"><div class="content">Yup. The original ES32, ESP32-S2, and ESP32-S3 use Xtensa, but the ESP32-C2, -C3, -C6, and -H2 use RISC-V.<p>Unfortunately they don&#x27;t all have the same feature set, so you&#x27;ll often still see the Xtensa variants in the wild as they are are simply a better product overall.</div><br/><div id="39753858" class="c"><input type="checkbox" id="c-39753858" checked=""/><div class="controls bullet"><span class="by">MrBuddyCasino</span><span>|</span><a href="#39748743">root</a><span>|</span><a href="#39753270">parent</a><span>|</span><a href="#39751075">next</a><span>|</span><label class="collapse" for="c-39753858">[-]</label><label class="expand" for="c-39753858">[1 more]</label></div><br/><div class="children"><div class="content">The C6 is pretty much a superset of the features of the old Xtensa based models.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39751075" class="c"><input type="checkbox" id="c-39751075" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#39748743">root</a><span>|</span><a href="#39750402">parent</a><span>|</span><a href="#39751624">prev</a><span>|</span><a href="#39749282">next</a><span>|</span><label class="collapse" for="c-39751075">[-]</label><label class="expand" for="c-39751075">[3 more]</label></div><br/><div class="children"><div class="content">Personally, I want a processor agnostic platform.<p>I don&#x27;t want to invest in one processor only to find out later that I needed USB2.0 instead of USB1.1, and then needing to read 500 pages of datasheets to move to a different platform.<p>Reading datasheets was nice at one point, but now it feels more like filling out tax forms.</div><br/><div id="39752241" class="c"><input type="checkbox" id="c-39752241" checked=""/><div class="controls bullet"><span class="by">ndiddy</span><span>|</span><a href="#39748743">root</a><span>|</span><a href="#39751075">parent</a><span>|</span><a href="#39753056">next</a><span>|</span><label class="collapse" for="c-39752241">[-]</label><label class="expand" for="c-39752241">[1 more]</label></div><br/><div class="children"><div class="content">It depends on what you&#x27;re looking for. If you&#x27;re doing hobbyist stuff, using Arduino libraries (or even Linux single-board computers) will get you a processor agnostic solution. However, if you&#x27;re dealing with production in volume, using 95% of the capabilities of a 45 cent chip is much better than using 50% of the capabilities of a 2 dollar chip, and there&#x27;s nothing that&#x27;ll get you there besides dealing with hardware specific features (and therefore datasheets).</div><br/></div></div><div id="39753056" class="c"><input type="checkbox" id="c-39753056" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#39748743">root</a><span>|</span><a href="#39751075">parent</a><span>|</span><a href="#39752241">prev</a><span>|</span><a href="#39749282">next</a><span>|</span><label class="collapse" for="c-39753056">[-]</label><label class="expand" for="c-39753056">[1 more]</label></div><br/><div class="children"><div class="content">The problem is that processor agnostic platforms have to follow the lowest common denominator. An agnostic USB library which works on both USB2.0 and USB1.1 microcontrollers is going to be limited to USB1.1 features.</div><br/></div></div></div></div></div></div><div id="39749282" class="c"><input type="checkbox" id="c-39749282" checked=""/><div class="controls bullet"><span class="by">jcalvinowens</span><span>|</span><a href="#39748743">parent</a><span>|</span><a href="#39750402">prev</a><span>|</span><a href="#39753013">next</a><span>|</span><label class="collapse" for="c-39749282">[-]</label><label class="expand" for="c-39749282">[3 more]</label></div><br/><div class="children"><div class="content">I think it depends on what you want.<p>Having worked quite a bit with  both, I think the average beginner would find the rp2040&#x27;s cmake based SDK more accessible than stm32cube, which I dislike immensely. The CircuitPython support is also really interesting for somebody who isn&#x27;t a programmer but wants to experiment.<p>But if you&#x27;re already an experienced programmer and want to roll your own stuff, I absolutely agree stm32 is a better way to go. This is a little example: <a href="https:&#x2F;&#x2F;github.com&#x2F;jcalvinowens&#x2F;ledboard">https:&#x2F;&#x2F;github.com&#x2F;jcalvinowens&#x2F;ledboard</a><p>I will say, I think the generalized PIO engine the rp2040 has is incredible. I hope everybody starts doing that.</div><br/><div id="39751087" class="c"><input type="checkbox" id="c-39751087" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#39748743">root</a><span>|</span><a href="#39749282">parent</a><span>|</span><a href="#39753013">next</a><span>|</span><label class="collapse" for="c-39751087">[-]</label><label class="expand" for="c-39751087">[2 more]</label></div><br/><div class="children"><div class="content">Iâm a programmer but appreciate CircuitPython. I used the KB2040 to build two bespoke mini keyboards. It took just a few dozen lines of Python. Couldnât be happier with it.</div><br/><div id="39751784" class="c"><input type="checkbox" id="c-39751784" checked=""/><div class="controls bullet"><span class="by">nimish</span><span>|</span><a href="#39748743">root</a><span>|</span><a href="#39751087">parent</a><span>|</span><a href="#39753013">next</a><span>|</span><label class="collapse" for="c-39751784">[-]</label><label class="expand" for="c-39751784">[1 more]</label></div><br/><div class="children"><div class="content">CircuitPython rules. Much easier to prototype algorithms and libraries than C.</div><br/></div></div></div></div></div></div><div id="39753013" class="c"><input type="checkbox" id="c-39753013" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#39748743">parent</a><span>|</span><a href="#39749282">prev</a><span>|</span><a href="#39749179">next</a><span>|</span><label class="collapse" for="c-39753013">[-]</label><label class="expand" for="c-39753013">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re a beginner who wants to learn how chips work, something like the ATmega328 or the ATmega32u4 would by far be the best choice. It&#x27;s pretty much a textbook chip, with enough peripherals to be useful yet not so many it gets confusing, and a datasheet which is quite readable.<p>Once you get into ARM territory it inherently gets very complex very quickly. They are massive chips made of multiple IP blocks from different vendors which have been glued together. Full documentation easily gets into the thousands of pages. The RP2040 has <i>excellent</i> documentation, and even that is <i>barely</i> enough to be usable.<p>With the exception of a very small group of people at the design company, essentially nobody is hand-writing assembly. There&#x27;s just no point: it&#x27;s incredibly complicated, and it takes orders of magnitude longer than just using the provided SDK. This makes hand-writing it only an option for hobbyists: nobody wants to pay for their engineer to spend a lot of time doing it in a worse way. Turns out &quot;I hate cmake&quot; isn&#x27;t a very good reason to waste tens of thousand of dollars in engineer-hours.<p>But even for the hobbyist the SDK is probably the better choice. The one provided for the RP2040 is quite well-made, and even if you hate cmake just copy&#x2F;pasting its C code into your own cmake-less toy SDK probably makes more sense than reinventing the wheel yourself.</div><br/></div></div><div id="39749179" class="c"><input type="checkbox" id="c-39749179" checked=""/><div class="controls bullet"><span class="by">joezydeco</span><span>|</span><a href="#39748743">parent</a><span>|</span><a href="#39753013">prev</a><span>|</span><a href="#39750928">next</a><span>|</span><label class="collapse" for="c-39749179">[-]</label><label class="expand" for="c-39749179">[7 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t totally agree with this perspective. Adafruit ships these in dev boards with a CircuitPython layer ready to go - you can have it up and doing something in 90 seconds if you&#x27;re the Arduino type of hobbyist. You don&#x27;t need to know a thing about the bootloader at all except maybe to hold down the bootstrap line with a pushbutton to reflash the system if it&#x27;s bricked. The USB loader is incredibly slick and modern.<p>All this bootstrap sequencing is pretty typical for an ARM Cortex unit, and it&#x27;s not as overburdened with options like, say, a TI Sitara. They&#x27;re still unbricking with TFTP.<p>For $0.70 in onesies this is a pretty nice piece of silicon.</div><br/><div id="39749227" class="c"><input type="checkbox" id="c-39749227" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#39748743">root</a><span>|</span><a href="#39749179">parent</a><span>|</span><a href="#39749264">next</a><span>|</span><label class="collapse" for="c-39749227">[-]</label><label class="expand" for="c-39749227">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think the person you&#x27;re responding to is &quot;the Arduino type of hobbyist&quot;, though.<p>I feel the same, I didn&#x27;t like Arduino&#x27;s abstractions and how they hid what was actually going on. It has its appeals for people who don&#x27;t care about the inner workings and just want to use a microcontroller to &quot;quickly do something for which a microcontroller would be handy right now&quot;, but it won&#x27;t get you much further than that, in my opinion.</div><br/></div></div><div id="39749444" class="c"><input type="checkbox" id="c-39749444" checked=""/><div class="controls bullet"><span class="by">parl_match</span><span>|</span><a href="#39748743">root</a><span>|</span><a href="#39749179">parent</a><span>|</span><a href="#39749264">prev</a><span>|</span><a href="#39750928">next</a><span>|</span><label class="collapse" for="c-39749444">[-]</label><label class="expand" for="c-39749444">[4 more]</label></div><br/><div class="children"><div class="content">Missing the point. There&#x27;s a huge amount of us who are between &quot;complete and bare metal understanding of the soc&quot; and &quot;using python&quot;.  STM32 nailed it, RP2040 is gaining a reputation for complexity.</div><br/><div id="39749736" class="c"><input type="checkbox" id="c-39749736" checked=""/><div class="controls bullet"><span class="by">joezydeco</span><span>|</span><a href="#39748743">root</a><span>|</span><a href="#39749444">parent</a><span>|</span><a href="#39750928">next</a><span>|</span><label class="collapse" for="c-39749736">[-]</label><label class="expand" for="c-39749736">[3 more]</label></div><br/><div class="children"><div class="content">I get the perspective. And I agree that RP2040 needs the equivalent of STMCube or even CubeMX. But they&#x27;re not there yet. Are they banking on the community to provide that with the same amount of love that RPi got? I don&#x27;t see that happening for multiple reasons.</div><br/><div id="39750472" class="c"><input type="checkbox" id="c-39750472" checked=""/><div class="controls bullet"><span class="by">parl_match</span><span>|</span><a href="#39748743">root</a><span>|</span><a href="#39749736">parent</a><span>|</span><a href="#39750928">next</a><span>|</span><label class="collapse" for="c-39750472">[-]</label><label class="expand" for="c-39750472">[2 more]</label></div><br/><div class="children"><div class="content">I think their aggressive price point is at odds with their mission.<p>The mission used to be &quot;unit of computing for education and makers at a super low pricepoint&quot;. This feels more like &quot;create the lowest pricepoint possible&quot;.</div><br/><div id="39751887" class="c"><input type="checkbox" id="c-39751887" checked=""/><div class="controls bullet"><span class="by">joezydeco</span><span>|</span><a href="#39748743">root</a><span>|</span><a href="#39750472">parent</a><span>|</span><a href="#39750928">next</a><span>|</span><label class="collapse" for="c-39751887">[-]</label><label class="expand" for="c-39751887">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s peculiar. I think the &#x27;educational&#x27; mission of RPi flew the coop a long time ago when they found they were selling piles of Linux SBCs at or below a cost that was realistic. Now they&#x27;re a COTS part used in industry. (Ever buy a $25,000 heat staking machine to discover that they used an Raspberry Pi as the primary control unit? I have.)<p>Arduino is now going through the same experience, they have a &quot;pro&quot; line where they&#x27;re trying to compete with existing Linux SBCs in the industrial space like Phytec, Variscite, or Kontron. But they can&#x27;t match on cost yet.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39750928" class="c"><input type="checkbox" id="c-39750928" checked=""/><div class="controls bullet"><span class="by">RicoElectrico</span><span>|</span><a href="#39748743">parent</a><span>|</span><a href="#39749179">prev</a><span>|</span><a href="#39749218">next</a><span>|</span><label class="collapse" for="c-39750928">[-]</label><label class="expand" for="c-39750928">[3 more]</label></div><br/><div class="children"><div class="content">What really sets apart RP2040 is the amount of SRAM you get for the price. Other &quot;outsiders&quot; like Espressif are also generous.<p>Mainstream MCU manufacturers really skimp on it, even if you don&#x27;t need Cortex-M4&#x2F;7 to run a simple GUI you <i>have</i> to buy a whiz-bang part with huge pinout, very rich peripherals you won&#x27;t need and a matching price tag for those.</div><br/><div id="39753081" class="c"><input type="checkbox" id="c-39753081" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#39748743">root</a><span>|</span><a href="#39750928">parent</a><span>|</span><a href="#39749218">next</a><span>|</span><label class="collapse" for="c-39753081">[-]</label><label class="expand" for="c-39753081">[2 more]</label></div><br/><div class="children"><div class="content">I believe a big reason for this is that the RP2040 is manufactured on a relatively modern process node. Mainstream MCU manufacturers use <i>ancient</i> nodes, which means using the same amount of SRAM is a lot more expensive area-wise.<p>It probably also helps that the RP2040 (and most Espressif chips too!) don&#x27;t include any onboard flash. Adding a nontrivial amount of on-chip flash is quite expensive, so they just used that area budget for extra SRAM instead. If you want more than a few hundred K of flash you need to use an external chip anyways, so why bother with on-chip flash at all?</div><br/><div id="39753565" class="c"><input type="checkbox" id="c-39753565" checked=""/><div class="controls bullet"><span class="by">RicoElectrico</span><span>|</span><a href="#39748743">root</a><span>|</span><a href="#39753081">parent</a><span>|</span><a href="#39749218">next</a><span>|</span><label class="collapse" for="c-39753565">[-]</label><label class="expand" for="c-39753565">[1 more]</label></div><br/><div class="children"><div class="content">AFAIK Espressif parts that do include flash just co-package it ;) From what I know, ESP8266 is TSMC 40 nm and TSMC offers embedded flash down to 28 nm (their website must be outdated).</div><br/></div></div></div></div></div></div><div id="39750303" class="c"><input type="checkbox" id="c-39750303" checked=""/><div class="controls bullet"><span class="by">daghamm</span><span>|</span><a href="#39748743">parent</a><span>|</span><a href="#39749218">prev</a><span>|</span><a href="#39747443">next</a><span>|</span><label class="collapse" for="c-39750303">[-]</label><label class="expand" for="c-39750303">[1 more]</label></div><br/><div class="children"><div class="content">This is still a huge step up compared to the broadcom chips in raspberry 1-4.<p>On the big brothers, you have this odd CPU + GPU mish-mash and everything (including interrupt and mem layout) can look different depending on which one is currently running the show.</div><br/></div></div></div></div><div id="39747443" class="c"><input type="checkbox" id="c-39747443" checked=""/><div class="controls bullet"><span class="by">blueflow</span><span>|</span><a href="#39748743">prev</a><span>|</span><a href="#39749146">next</a><span>|</span><label class="collapse" for="c-39747443">[-]</label><label class="expand" for="c-39747443">[1 more]</label></div><br/><div class="children"><div class="content">Official documentation: <a href="https:&#x2F;&#x2F;datasheets.raspberrypi.com&#x2F;rp2040&#x2F;rp2040-datasheet.pdf" rel="nofollow">https:&#x2F;&#x2F;datasheets.raspberrypi.com&#x2F;rp2040&#x2F;rp2040-datasheet.p...</a>, Booting is page 130 ff</div><br/></div></div><div id="39749146" class="c"><input type="checkbox" id="c-39749146" checked=""/><div class="controls bullet"><span class="by">vha3</span><span>|</span><a href="#39747443">prev</a><span>|</span><a href="#39748547">next</a><span>|</span><label class="collapse" for="c-39749146">[-]</label><label class="expand" for="c-39749146">[2 more]</label></div><br/><div class="children"><div class="content">Some fun easter eggs in the bootrom. It seems like kilograham is a Doors fan: <a href="https:&#x2F;&#x2F;github.com&#x2F;raspberrypi&#x2F;pico-bootrom&#x2F;blob&#x2F;ef22cd8ede5bc007f81d7f2416b48db90f313434&#x2F;bootrom&#x2F;bootrom.ld#L14">https:&#x2F;&#x2F;github.com&#x2F;raspberrypi&#x2F;pico-bootrom&#x2F;blob&#x2F;ef22cd8ede5...</a></div><br/><div id="39750631" class="c"><input type="checkbox" id="c-39750631" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#39749146">parent</a><span>|</span><a href="#39748547">next</a><span>|</span><label class="collapse" for="c-39750631">[-]</label><label class="expand" for="c-39750631">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s another really subtle easter egg hidden in bootrom_rt0.S:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;raspberrypi&#x2F;pico-bootrom&#x2F;blob&#x2F;ef22cd8ede5bc007f81d7f2416b48db90f313434&#x2F;bootrom&#x2F;bootrom_rt0.S#L442-L444">https:&#x2F;&#x2F;github.com&#x2F;raspberrypi&#x2F;pico-bootrom&#x2F;blob&#x2F;ef22cd8ede5...</a><p>And the explanation:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30970274">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30970274</a></div><br/></div></div></div></div><div id="39748547" class="c"><input type="checkbox" id="c-39748547" checked=""/><div class="controls bullet"><span class="by">MenhirMike</span><span>|</span><a href="#39749146">prev</a><span>|</span><a href="#39747848">next</a><span>|</span><label class="collapse" for="c-39748547">[-]</label><label class="expand" for="c-39748547">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Power is applied to the chip, and the RUN pin is high. The chip will be held in reset for as long as RUN is not high.<p>Is that a typo, or do I not understand this? Should it be &quot;as long as RUN is high&quot;? Because I assume that the RUN pin is active low, so as long as it is high, the chip will be held in reset?</div><br/><div id="39748572" class="c"><input type="checkbox" id="c-39748572" checked=""/><div class="controls bullet"><span class="by">colejohnson66</span><span>|</span><a href="#39748547">parent</a><span>|</span><a href="#39751284">next</a><span>|</span><label class="collapse" for="c-39748572">[-]</label><label class="expand" for="c-39748572">[1 more]</label></div><br/><div class="children"><div class="content">Nope. RUN is active-high:[0;pg12]<p>&gt; Global asynchronous reset pin. Reset when driven low, run when driven high. If no external reset is required, this pin can be tied directly to IOVDD.<p>RST pins tend to be active-low, which is the same thing. Perhaps Raspberry Pi decided to call it the &quot;run&quot; pin instead of the &quot;reset&quot; one to avoid possibly confusing hobbyists?<p>[0]: <a href="https:&#x2F;&#x2F;datasheets.raspberrypi.com&#x2F;rp2040&#x2F;rp2040-datasheet.pdf" rel="nofollow">https:&#x2F;&#x2F;datasheets.raspberrypi.com&#x2F;rp2040&#x2F;rp2040-datasheet.p...</a></div><br/></div></div><div id="39751284" class="c"><input type="checkbox" id="c-39751284" checked=""/><div class="controls bullet"><span class="by">NotYourLawyer</span><span>|</span><a href="#39748547">parent</a><span>|</span><a href="#39748572">prev</a><span>|</span><a href="#39747848">next</a><span>|</span><label class="collapse" for="c-39751284">[-]</label><label class="expand" for="c-39751284">[1 more]</label></div><br/><div class="children"><div class="content">I think the second sentence should be in parentheses.</div><br/></div></div></div></div><div id="39747848" class="c"><input type="checkbox" id="c-39747848" checked=""/><div class="controls bullet"><span class="by">dmitrygr</span><span>|</span><a href="#39748547">prev</a><span>|</span><a href="#39748694">next</a><span>|</span><label class="collapse" for="c-39747848">[-]</label><label class="expand" for="c-39747848">[1 more]</label></div><br/><div class="children"><div class="content">This is a rehash of official docs, which are both clearer and more detailed. Suggest reading official docs. See âbootâ section in rp2040 TRM</div><br/></div></div><div id="39748694" class="c"><input type="checkbox" id="c-39748694" checked=""/><div class="controls bullet"><span class="by">crmd</span><span>|</span><a href="#39747848">prev</a><span>|</span><label class="collapse" for="c-39748694">[-]</label><label class="expand" for="c-39748694">[6 more]</label></div><br/><div class="children"><div class="content">It&#x27;s kind of annoying that the author made me search for what an RP2040 was, rather than including it in the first paragraph.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;RP2040" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;RP2040</a></div><br/><div id="39749023" class="c"><input type="checkbox" id="c-39749023" checked=""/><div class="controls bullet"><span class="by">Goz3rr</span><span>|</span><a href="#39748694">parent</a><span>|</span><a href="#39749296">next</a><span>|</span><label class="collapse" for="c-39749023">[-]</label><label class="expand" for="c-39749023">[4 more]</label></div><br/><div class="children"><div class="content">That doesn&#x27;t seem unusual to me, given that to get to this page you either have to be searching for the specific terms already (and know what they are) or come from the homepage -&gt; RP2040 (Raspberry Pi Pico) projects -&gt; Custom serial bootloader for the RP2040 -&gt; Preliminary reading RP2040 boot sequence</div><br/><div id="39749607" class="c"><input type="checkbox" id="c-39749607" checked=""/><div class="controls bullet"><span class="by">crmd</span><span>|</span><a href="#39748694">root</a><span>|</span><a href="#39749023">parent</a><span>|</span><a href="#39749296">next</a><span>|</span><label class="collapse" for="c-39749607">[-]</label><label class="expand" for="c-39749607">[3 more]</label></div><br/><div class="children"><div class="content">I came to that page directly from the front page of HN. I think it&#x27;s reasonable to assume a significant portion of their traffic today directly to this page didn&#x27;t already know what RP2040 is. Missed opportunity to educate readers.</div><br/><div id="39750316" class="c"><input type="checkbox" id="c-39750316" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#39748694">root</a><span>|</span><a href="#39749607">parent</a><span>|</span><a href="#39752494">next</a><span>|</span><label class="collapse" for="c-39750316">[-]</label><label class="expand" for="c-39750316">[1 more]</label></div><br/><div class="children"><div class="content">It might be nice, but most web pages aren&#x27;t written with Hacker News in mind. We share them anyway.<p>You should expect to sometimes encounter documents where you aren&#x27;t the target audience and you have to look up terms.</div><br/></div></div><div id="39752494" class="c"><input type="checkbox" id="c-39752494" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#39748694">root</a><span>|</span><a href="#39749607">parent</a><span>|</span><a href="#39750316">prev</a><span>|</span><a href="#39749296">next</a><span>|</span><label class="collapse" for="c-39752494">[-]</label><label class="expand" for="c-39752494">[1 more]</label></div><br/><div class="children"><div class="content">Do you want every single subpage in the world to reexplain its context again?<p>Do you expect every SF Chronicle article to explain to you what SF is?</div><br/></div></div></div></div></div></div><div id="39749296" class="c"><input type="checkbox" id="c-39749296" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#39748694">parent</a><span>|</span><a href="#39749023">prev</a><span>|</span><label class="collapse" for="c-39749296">[-]</label><label class="expand" for="c-39749296">[1 more]</label></div><br/><div class="children"><div class="content">I mean, in as much as it is annoying when an article about, say, NTFS internals does not explain what NTFS stands for, or what a filesystem is. If you&#x27;re the target audience, you&#x27;ll know already.</div><br/></div></div></div></div></div></div></div></div></div></body></html>