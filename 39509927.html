<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1709024454020" as="style"/><link rel="stylesheet" href="styles.css?v=1709024454020"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://wingolog.org/archives/2024/02/26/on-the-impossibility-of-composing-finalizers-and-ffi">On the impossibility of composing finalizers and FFI</a> <span class="domain">(<a href="https://wingolog.org">wingolog.org</a>)</span></div><div class="subtext"><span>ingve</span> | <span>25 comments</span></div><br/><div><div id="39520569" class="c"><input type="checkbox" id="c-39520569" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#39520660">next</a><span>|</span><label class="collapse" for="c-39520569">[-]</label><label class="expand" for="c-39520569">[3 more]</label></div><br/><div class="children"><div class="content">Managing FFI will always require cooperation with the GC if there is one. If the GC doesn&#x27;t expose adequate APIs for doing that cooperation, that feels like more of a design problem with that GC than a fact of nature. You shouldn&#x27;t be trying to &quot;trick&quot; the compiler&#x2F;runtime to keep your thing live until you&#x27;ve finished using it: you should tell it when you need to keep it live until, and it should listen to you.</div><br/><div id="39520993" class="c"><input type="checkbox" id="c-39520993" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#39520569">parent</a><span>|</span><a href="#39520660">next</a><span>|</span><label class="collapse" for="c-39520993">[-]</label><label class="expand" for="c-39520993">[2 more]</label></div><br/><div class="children"><div class="content">In other words, managing FFI resources will remain &quot;manual&quot; or otherwise deterministic. The mechanism will cooperate with GC by releasing an object to be collected once its interaction with FFI is done.<p>In absence of finalizers, I suspect, FFI resources could also be garbage-collected.<p>If looks like traditional GC-based languages (like Java or Lisp) are hurt by absence of static data flow analysis, which would guarantee that a finalizer cannot revive the object being collected (e.g. by creating a new live reference to it elsewhere). Finalizers can likely be made safe enough if their code is more restricted; that would still allow many reasonable finalizers that calmly release external resources.</div><br/><div id="39521638" class="c"><input type="checkbox" id="c-39521638" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#39520569">root</a><span>|</span><a href="#39520993">parent</a><span>|</span><a href="#39520660">next</a><span>|</span><label class="collapse" for="c-39521638">[-]</label><label class="expand" for="c-39521638">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Finalizers can likely be made safe enough if their code is more restricted; that would still allow many reasonable finalizers that calmly release external resources.<p>If a finalizer calls external code to release external resources (a not uncommon use case), there’s no way static data flow analysis can determine that external code doesn’t make a call back into the VM that revives objects, is there?</div><br/></div></div></div></div></div></div><div id="39520660" class="c"><input type="checkbox" id="c-39520660" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#39520569">prev</a><span>|</span><a href="#39520560">next</a><span>|</span><label class="collapse" for="c-39520660">[-]</label><label class="expand" for="c-39520660">[4 more]</label></div><br/><div class="children"><div class="content">The LuaJIT example isn&#x27;t correct though, the lifetime of garbage collected objects is clearly documented: <a href="https:&#x2F;&#x2F;luajit.org&#x2F;ext_ffi_semantics.html#gc" rel="nofollow">https:&#x2F;&#x2F;luajit.org&#x2F;ext_ffi_semantics.html#gc</a>
In the example function `blob` will not be collected because it <i>is</i> <i>reachable</i> from the `blob` argument local variable (IOW it is on the Lua stack). `ffi.string`() copies the string data into a new Lua string, and the lifetime of blob is guaranteed until the return of the function. So not sure what the issue is.<p><pre><code>  function blob_contents(blob) -- &lt;- this ensures liveness until past return 
     local len_out = ffi.new(&#x27;unsigned int&#x27;)
     local contents = hb.hb_blob_get_data(blob, len_out)
     local len = len_out[0];
     return ffi.string(contents, len)
  end</code></pre></div><br/><div id="39520720" class="c"><input type="checkbox" id="c-39520720" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#39520660">parent</a><span>|</span><a href="#39520560">next</a><span>|</span><label class="collapse" for="c-39520720">[-]</label><label class="expand" for="c-39520720">[3 more]</label></div><br/><div class="children"><div class="content">The argument is that the JIT might realise that blob is never used beyond that line, and collect it early. In general that would be a desirable feature.</div><br/><div id="39520735" class="c"><input type="checkbox" id="c-39520735" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#39520660">root</a><span>|</span><a href="#39520720">parent</a><span>|</span><a href="#39520560">next</a><span>|</span><label class="collapse" for="c-39520735">[-]</label><label class="expand" for="c-39520735">[2 more]</label></div><br/><div class="children"><div class="content">I know it says this: &quot;The semantics of LuaJIT do not prescribe when GC can happen and what values will be live, so the GC and the compiler are not constrained to extend the liveness of blob to, say, the entirety of its lexical scope. &quot;<p>But it is flat wrong. From the LuaJIT documentation:
&quot;All explicitly (ffi.new(), ffi.cast() etc.) or implicitly (accessors) created cdata objects are garbage collected. You need to ensure to retain valid references to cdata objects somewhere on a <i>Lua stack</i>, an upvalue or in a Lua table while they are still in use. Once the last reference to a cdata object is gone, the garbage collector will automatically free the memory used by it (at the end of the next GC cycle).&quot;<p>The Lua stack in this case includes all the local variables in that function scope.
It&#x27;s a non-issue&#x2F;straw man and is common sense.
If LuaJIT FFI worked the way the author supposed, it would  be near  impossible to use practically.<p>“It is perfectly valid to collect blob after its last use”<p>This is a useless statement. It’s perfectly “valid” for LuaJIT to not even read your source code and exit immediately, but that isn’t what it does because it would be useless. What counts as a reference is both PUC Lua and LuaJIT is defined.<p>As far as the desirability of finer grained liveness, Lua has block scope (do end), but in practice LuaJIT does well inlining so functions ought to be short anyway.</div><br/><div id="39521709" class="c"><input type="checkbox" id="c-39521709" checked=""/><div class="controls bullet"><span class="by">reichstein</span><span>|</span><a href="#39520660">root</a><span>|</span><a href="#39520735">parent</a><span>|</span><a href="#39520560">next</a><span>|</span><label class="collapse" for="c-39521709">[-]</label><label class="expand" for="c-39521709">[1 more]</label></div><br/><div class="children"><div class="content">GC is usually not specified to happen at particular times, or saying which values are definitely going to be GCed.
Instead it relies on the language semantics, so that any value which is used later in the program, is not going to be GCed. How and when the runtime system determines that a value is not going to be used again is an optimization problem, not a correctness problem.<p>So everything you quote Lua a saying here is consistent. 
The thing is that it only considers &quot;used later&quot; as &quot;used later by the Lua program&quot;.
Or rather, it only considers Lua values as &quot;values&quot;. A value stored in non-managed memory is not a value. It&#x27;s not GCed. The `ffi.new`-created Lua value is, and it&#x27;s finalizer happens to free the native memory that the pointer refers to.<p>So non -Lua &quot;values&quot; are not GCed, they are freed as side effects of Lua values being GCed.</div><br/></div></div></div></div></div></div></div></div><div id="39520560" class="c"><input type="checkbox" id="c-39520560" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#39520660">prev</a><span>|</span><a href="#39520766">next</a><span>|</span><label class="collapse" for="c-39520560">[-]</label><label class="expand" for="c-39520560">[2 more]</label></div><br/><div class="children"><div class="content">This is the essence of Rusts lifetime analysis; a pointer to an object can&#x27;t be live for longer than the object itself is.<p>In this particular example, you&#x27;d make an object with a finalizer and hide the raw pointer inside of it. Then you can only touch that pointer by going through a Rust object which participates in lifetime analysis, and it&#x27;ll clean it up when it&#x27;s done. Any more attempts to touch that object&#x2F;pointer will fail to compile.<p>Expressed that way it makes sense that some people call it &quot;GC at compile time&quot;.</div><br/><div id="39521062" class="c"><input type="checkbox" id="c-39521062" checked=""/><div class="controls bullet"><span class="by">arcticbull</span><span>|</span><a href="#39520560">parent</a><span>|</span><a href="#39520766">next</a><span>|</span><label class="collapse" for="c-39521062">[-]</label><label class="expand" for="c-39521062">[1 more]</label></div><br/><div class="children"><div class="content">I like using this neat newtype for wrapping FFI objects.<p><pre><code>  pub struct OwnedForeignInstance(NonNull&lt;std::ffi::c_void&gt;);
</code></pre>
You can then, as you say, implement Drop to give up the foreign object when it&#x27;s no longer needed.<p><pre><code>  impl Drop for OwnedForeignInstance {
      fn drop(&amp;mut self) {
          unsafe { &#x2F;* Destroy self.0.as_ptr() *&#x2F; }
      }
  }
</code></pre>
You can define an un-owned reference to the owned foreign instance using a newtype like this.<p><pre><code>  pub struct UnownedReference(PhantomData&lt;UnsafeCell&lt;*mut ()&gt;&gt;);
</code></pre>
Then, you can hand out zero-cost lifetime-checked references to the owned foreign instance like this.<p><pre><code>  impl Deref for OwnedForeignInstance {
      type Target = UnownedReference;
      fn deref(&amp;self) -&gt; &amp;Self::Target {
          unsafe { &amp;*(self.0.as_ptr() as *mut _) }
      }
  }

  impl DerefMut for OwnedForeignInstance {
      fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
          unsafe { &amp;mut *(self.0.as_ptr() as *mut _) }
      }
  }
</code></pre>
Once you&#x27;ve done that, you expose your FFI functionality on UnownedReference, relying on auto-deref. Unless it consumes the receiver, in which case you put it on the OwnedForeignInstance. This way you can&#x27;t destroy the object while references to it continue to exist.<p>It&#x27;s not perfect, but it&#x27;s the best way I&#x27;ve found so far for making FFI wrapper objects that look and feel like Rust objects while respecting the FFI contract.</div><br/></div></div></div></div><div id="39520766" class="c"><input type="checkbox" id="c-39520766" checked=""/><div class="controls bullet"><span class="by">01HNNWZ0MV43FF</span><span>|</span><a href="#39520560">prev</a><span>|</span><a href="#39520505">next</a><span>|</span><label class="collapse" for="c-39520766">[-]</label><label class="expand" for="c-39520766">[1 more]</label></div><br/><div class="children"><div class="content">When I see all the trouble that async Rust and normal C# have had with finalizers, I must wonder if anything composes with anything else, or it&#x27;s all just banging rocks and praying</div><br/></div></div><div id="39520505" class="c"><input type="checkbox" id="c-39520505" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39520766">prev</a><span>|</span><a href="#39513853">next</a><span>|</span><label class="collapse" for="c-39520505">[-]</label><label class="expand" for="c-39520505">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>want to copy out its contents as a byte string.</i><p>That object should take care of it. Even if the parent object is reclaimed, the byte string should independently persist for as long as is necessary. Since byte strings don&#x27;t contain pointers to anything, reference counting could be used.<p>The refcount could be in the parent blob, such that when its nonzero, the blob is pinned against reclamation.<p>Of course you can&#x27;t just share out the internals of an object, such that GC doesn&#x27;t know about them. It doesn&#x27;t matter if it&#x27;s a foreign object set up with FFI or something built into the run time.</div><br/></div></div><div id="39513853" class="c"><input type="checkbox" id="c-39513853" checked=""/><div class="controls bullet"><span class="by">celeritascelery</span><span>|</span><a href="#39520505">prev</a><span>|</span><a href="#39521035">next</a><span>|</span><label class="collapse" for="c-39513853">[-]</label><label class="expand" for="c-39513853">[1 more]</label></div><br/><div class="children"><div class="content">Given how much research there is into this topic, I am sure that I just don&#x27;t understand the complexity of it. But to me it seems like you could have a function that associates one value with another in the GC. Something like `gc_borrows_from`. You would than write the problematic code like this:<p><pre><code>    function blob_contents(blob)
       local len_out = ffi.new(&#x27;unsigned int&#x27;)
       local contents = gc_borrows_from(blob, hb.hb_blob_get_data(blob, len_out))
       local len = len_out[0];
       return ffi.string(contents, len)
    end
</code></pre>
This would tell the GC that the data returned by `hb_blob_get_data` is borrowed from blob, and it can&#x27;t collect `blob` until `contents` is also unreachable. How to implement that would be up to the runtime, but it seems reasonable to have a wrapper type that holds a traceable reference back to blob.</div><br/></div></div><div id="39521035" class="c"><input type="checkbox" id="c-39521035" checked=""/><div class="controls bullet"><span class="by">LispSporks22</span><span>|</span><a href="#39513853">prev</a><span>|</span><a href="#39520238">next</a><span>|</span><label class="collapse" for="c-39521035">[-]</label><label class="expand" for="c-39521035">[2 more]</label></div><br/><div class="children"><div class="content">I think the SDL2 bindings for Common Lisp went through a similar realization and any kind of finalization was removed.</div><br/><div id="39521463" class="c"><input type="checkbox" id="c-39521463" checked=""/><div class="controls bullet"><span class="by">phoe-krk</span><span>|</span><a href="#39521035">parent</a><span>|</span><a href="#39520238">next</a><span>|</span><label class="collapse" for="c-39521463">[-]</label><label class="expand" for="c-39521463">[1 more]</label></div><br/><div class="children"><div class="content">Yes. Yet another problem with finalizers is the question of &quot;which thread does actually run the finalizers&quot;? In case of some C libraries, objects must be released exactly by the thread in which they were allocated; this means that e.g. in Steel Bank Common Lisp it is impossible to use finalizers in these cases.</div><br/></div></div></div></div><div id="39520238" class="c"><input type="checkbox" id="c-39520238" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#39521035">prev</a><span>|</span><a href="#39520559">next</a><span>|</span><label class="collapse" for="c-39520238">[-]</label><label class="expand" for="c-39520238">[8 more]</label></div><br/><div class="children"><div class="content">Anything that stops languages from just exposing some functions that solve this exact problem?<p><pre><code>  function blob_contents(blob)
    ffi.pin(blob)
    -- ...
    ffi.unpin(blob)
  end
</code></pre>
Where pin disables garbage collection of the given object while pin re-enables it, forming the exact region where its lifetime is guaranteed which is apparently what the author needs.<p>It&#x27;s manual memory management and the code will have to be written carefully if the language has exceptions or other forms of unwinding. It should work though.<p>Moving garbage collectors also have a concept of pinning objects since code can save pointers to them. Seems like the same problem to me.</div><br/><div id="39521435" class="c"><input type="checkbox" id="c-39521435" checked=""/><div class="controls bullet"><span class="by">sparkie</span><span>|</span><a href="#39520238">parent</a><span>|</span><a href="#39520695">next</a><span>|</span><label class="collapse" for="c-39521435">[-]</label><label class="expand" for="c-39521435">[1 more]</label></div><br/><div class="children"><div class="content">Scheme has Guardians for this. They&#x27;re available in Guile[1], and have recently been submitted as an SRFI[2] for standardization. Original proposal is from Kent Dybvig et al in 1993[3]<p>[1]:<a href="https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;guile&#x2F;&#x2F;manual&#x2F;html_node&#x2F;Guardians.html" rel="nofollow">https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;guile&#x2F;&#x2F;manual&#x2F;html_node&#x2F;Guardia...</a><p>[2]:<a href="https:&#x2F;&#x2F;srfi.schemers.org&#x2F;srfi-246&#x2F;" rel="nofollow">https:&#x2F;&#x2F;srfi.schemers.org&#x2F;srfi-246&#x2F;</a><p>[3]:<a href="https:&#x2F;&#x2F;www.cs.tufts.edu&#x2F;comp&#x2F;250RTS&#x2F;archive&#x2F;kent-dybvig&#x2F;guardians.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cs.tufts.edu&#x2F;comp&#x2F;250RTS&#x2F;archive&#x2F;kent-dybvig&#x2F;gua...</a></div><br/></div></div><div id="39520695" class="c"><input type="checkbox" id="c-39520695" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#39520238">parent</a><span>|</span><a href="#39521435">prev</a><span>|</span><a href="#39520711">next</a><span>|</span><label class="collapse" for="c-39520695">[-]</label><label class="expand" for="c-39520695">[1 more]</label></div><br/><div class="children"><div class="content">This is unnecessary. The blob argument binding itself is making the object reachable throughout the function.
You can easily test it with collectgarbage(&#x27;collect&#x27;)
The author&#x27;s example is simply mistaken about the relatively straightforward semantics of LuaJIT.</div><br/></div></div><div id="39520711" class="c"><input type="checkbox" id="c-39520711" checked=""/><div class="controls bullet"><span class="by">fweimer</span><span>|</span><a href="#39520238">parent</a><span>|</span><a href="#39520695">prev</a><span>|</span><a href="#39520469">next</a><span>|</span><label class="collapse" for="c-39520711">[-]</label><label class="expand" for="c-39520711">[1 more]</label></div><br/><div class="children"><div class="content">In many cases, you do not need to pin the object, only keep it alive. Current Java has a reachability fence for this: <a href="https:&#x2F;&#x2F;docs.oracle.com&#x2F;en&#x2F;java&#x2F;javase&#x2F;17&#x2F;docs&#x2F;api&#x2F;java.base&#x2F;java&#x2F;lang&#x2F;ref&#x2F;Reference.html#reachabilityFence(java.lang.Object)" rel="nofollow">https:&#x2F;&#x2F;docs.oracle.com&#x2F;en&#x2F;java&#x2F;javase&#x2F;17&#x2F;docs&#x2F;api&#x2F;java.base...</a><p>I think I saw this first in MLton, which has a touch function for this purpose: <a href="http:&#x2F;&#x2F;mlton.org&#x2F;MLtonFinalizable" rel="nofollow">http:&#x2F;&#x2F;mlton.org&#x2F;MLtonFinalizable</a><p>I&#x27;m not convince this is particularly hard to use functionality, all things considered. Supporting explicit deallocation in a safe way is much harder, especially if FFI callbacks are involved.</div><br/></div></div><div id="39520469" class="c"><input type="checkbox" id="c-39520469" checked=""/><div class="controls bullet"><span class="by">cmrx64</span><span>|</span><a href="#39520238">parent</a><span>|</span><a href="#39520711">prev</a><span>|</span><a href="#39520559">next</a><span>|</span><label class="collapse" for="c-39520469">[-]</label><label class="expand" for="c-39520469">[4 more]</label></div><br/><div class="children"><div class="content">This is often what happens, and this is often what’s fragile. In the blog these are referred to as “lifetime extension”. The code is written as carefully as it ever is and I can confirm the observation that it’s just begging for a segfault or a leak :) Note that finalizers are asynchronous, and there’s an inversion of control&#x2F;scoping issue with the way you’ve described it.</div><br/><div id="39521186" class="c"><input type="checkbox" id="c-39521186" checked=""/><div class="controls bullet"><span class="by">nh2</span><span>|</span><a href="#39520238">root</a><span>|</span><a href="#39520469">parent</a><span>|</span><a href="#39520516">next</a><span>|</span><label class="collapse" for="c-39521186">[-]</label><label class="expand" for="c-39521186">[1 more]</label></div><br/><div class="children"><div class="content">Haskell&#x27;s FFI has `withForeignPtr :: ForeignPtr a -&gt; (Ptr a -&gt; IO b) -&gt; IO b` [1].<p>A ForeignPtr is a GC-managed pointer with an associated finalizer.
The finalizer runs when the ForeignPtr gets GC&#x27;d.<p>`withForeignPtr` creates a scope (accepting a lambda) in which you can inspect the pointer `(Ptr a -&gt; IO b)`.<p>This works well in practice, so I do not really understand why &quot;among GC implementors, it is a truth universally acknowledged that a program containing finalizers must be in want of a segfault&quot;.<p>[1]: <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;base-4.19.1.0&#x2F;docs&#x2F;Foreign-ForeignPtr.html#v:withForeignPtr" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;base-4.19.1.0&#x2F;docs&#x2F;Forei...</a></div><br/></div></div><div id="39520516" class="c"><input type="checkbox" id="c-39520516" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39520238">root</a><span>|</span><a href="#39520469">parent</a><span>|</span><a href="#39521186">prev</a><span>|</span><a href="#39520559">next</a><span>|</span><label class="collapse" for="c-39520516">[-]</label><label class="expand" for="c-39520516">[2 more]</label></div><br/><div class="children"><div class="content">The pin and unpin could be tied to a reference count in the byte string object that was extracted. When blob&#x27;s get_data is called to get the byte string, its pin count is bumped up. When the byte string is reclaimed by GC, it bumps down the blob&#x27;s pin count.</div><br/><div id="39520808" class="c"><input type="checkbox" id="c-39520808" checked=""/><div class="controls bullet"><span class="by">cmrx64</span><span>|</span><a href="#39520238">root</a><span>|</span><a href="#39520516">parent</a><span>|</span><a href="#39520559">next</a><span>|</span><label class="collapse" for="c-39520808">[-]</label><label class="expand" for="c-39520808">[1 more]</label></div><br/><div class="children"><div class="content">I don’t dispute the possibility of using pinning correctly, in practice it’s a source of bugs. Fuzzy and loose ownership regimes just don’t compose well, people are bad at running region checkers in their head and anything beyond the absolute simplest smallest scoped is prone to eventual error.</div><br/></div></div></div></div></div></div></div></div><div id="39520559" class="c"><input type="checkbox" id="c-39520559" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#39520238">prev</a><span>|</span><label class="collapse" for="c-39520559">[-]</label><label class="expand" for="c-39520559">[2 more]</label></div><br/><div class="children"><div class="content">Julia solves this pretty well by having a gc_preserve macro that tells the compiler that an object has hidden references within the scope.</div><br/><div id="39520703" class="c"><input type="checkbox" id="c-39520703" checked=""/><div class="controls bullet"><span class="by">ng55QPSK</span><span>|</span><a href="#39520559">parent</a><span>|</span><label class="collapse" for="c-39520703">[-]</label><label class="expand" for="c-39520703">[1 more]</label></div><br/><div class="children"><div class="content">which means: you tell the compiler</div><br/></div></div></div></div></div></div></div></div></div></body></html>