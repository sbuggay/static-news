<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1705050055346" as="style"/><link rel="stylesheet" href="styles.css?v=1705050055346"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://linuxtldr.com/file-descriptors-linux/">What Are File Descriptors in Linux</a>Â <span class="domain">(<a href="https://linuxtldr.com">linuxtldr.com</a>)</span></div><div class="subtext"><span>marcodiego</span> | <span>29 comments</span></div><br/><div><div id="38964700" class="c"><input type="checkbox" id="c-38964700" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#38964193">next</a><span>|</span><label class="collapse" for="c-38964700">[-]</label><label class="expand" for="c-38964700">[13 more]</label></div><br/><div class="children"><div class="content">Hopefully this isn&#x27;t too hard of a rant, but file descriptors are... neither files nor descriptors. They literally don&#x27;t &quot;describe&quot; anything about anything, and whatever they refer to doesn&#x27;t need to be a file either. They&#x27;re literally the exact opposite - 100% opaque integers, as opaque as anything in a program could possibly be, that could refer to pretty much any kernel object.<p>Why they were ever called file <i>descriptors</i> in the first place (esp. given the one thing they lack is any description), and why they couldn&#x27;t just start being called &quot;handles&quot; (like on Windows) or &quot;object IDs&quot; or something else that at least makes some modicum of sense, is beyond me.</div><br/><div id="38965017" class="c"><input type="checkbox" id="c-38965017" checked=""/><div class="controls bullet"><span class="by">nineteen999</span><span>|</span><a href="#38964700">parent</a><span>|</span><a href="#38965004">next</a><span>|</span><label class="collapse" for="c-38965017">[-]</label><label class="expand" for="c-38965017">[1 more]</label></div><br/><div class="children"><div class="content">&gt; file descriptors are... neither files nor descriptors<p>This is a pretty modern and userspace-centric view of file descriptors IMHO. The &quot;description&quot; part is in the file description table on the kernel side of the userspace&#x2F;kernel boundary (see struct file[1]) for what are extremely obvious reasons.<p>Up to V7 UNIX (1973-1979[2,3]), the file description table could literally only reference a file on disk, UNIX domain&#x2F;TCP&#x2F;UDP sockets weren&#x27;t introduced until 4.2BSD.<p>Your gentle rant makes sense from a modern point of view of course, but we need to keep in mind that the UNIX design is over 50 years old now. You could argue that the 4.2BSD people should have used different tables&#x2F;names rather than overload the file description table but that ship has sailed and here we are.<p>[1]<a href="https:&#x2F;&#x2F;chenshuo.com&#x2F;notes&#x2F;kernel&#x2F;file-descriptor-table&#x2F;" rel="nofollow">https:&#x2F;&#x2F;chenshuo.com&#x2F;notes&#x2F;kernel&#x2F;file-descriptor-table&#x2F;</a><p>[2]<a href="https:&#x2F;&#x2F;www.tuhs.org&#x2F;cgi-bin&#x2F;utree.pl?file=V4&#x2F;nsys&#x2F;file.h" rel="nofollow">https:&#x2F;&#x2F;www.tuhs.org&#x2F;cgi-bin&#x2F;utree.pl?file=V4&#x2F;nsys&#x2F;file.h</a><p>[3]<a href="https:&#x2F;&#x2F;www.tuhs.org&#x2F;cgi-bin&#x2F;utree.pl?file=V7&#x2F;usr&#x2F;include&#x2F;sys&#x2F;file.h" rel="nofollow">https:&#x2F;&#x2F;www.tuhs.org&#x2F;cgi-bin&#x2F;utree.pl?file=V7&#x2F;usr&#x2F;include&#x2F;sy...</a></div><br/></div></div><div id="38965004" class="c"><input type="checkbox" id="c-38965004" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38964700">parent</a><span>|</span><a href="#38965017">prev</a><span>|</span><a href="#38964941">next</a><span>|</span><label class="collapse" for="c-38965004">[-]</label><label class="expand" for="c-38965004">[3 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Why they were ever called file descriptors in the first place</i><p>Human laziness, no doubt. What you refer to as &quot;file descriptor&quot; is really a <i>pointer</i> to a file descriptor. It is likely that over time &quot;file descriptor pointer&quot; or &quot;file descriptor handle&quot; was shortened, and then ultimately accepted into the lexicon.</div><br/><div id="38965025" class="c"><input type="checkbox" id="c-38965025" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#38964700">root</a><span>|</span><a href="#38965004">parent</a><span>|</span><a href="#38964941">next</a><span>|</span><label class="collapse" for="c-38965025">[-]</label><label class="expand" for="c-38965025">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Everything they can refer to is a file.<p>In what sense is (say) a signalfd a &quot;file&quot;? How about a pidfd?</div><br/><div id="38965097" class="c"><input type="checkbox" id="c-38965097" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38964700">root</a><span>|</span><a href="#38965025">parent</a><span>|</span><a href="#38964941">next</a><span>|</span><label class="collapse" for="c-38965097">[-]</label><label class="expand" for="c-38965097">[1 more]</label></div><br/><div class="children"><div class="content">Originally, a file in computing referred to a group of punch cards stored in a box. If this is the definition you hold on to, then signalfd and pidfd do not represent a file. In fact, by that definition nothing in modern computing is a file.<p>However, as the technology evolved and punch cards went out of style, everyone (except maybe you) accepted &quot;file&quot; as an abstract representation of said box. signalfd and pidfd fit within that abstraction.<p>Should I preemptively start into your next question of why Linux has tty when there is no teletype to be found?</div><br/></div></div></div></div></div></div><div id="38964941" class="c"><input type="checkbox" id="c-38964941" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#38964700">parent</a><span>|</span><a href="#38965004">prev</a><span>|</span><a href="#38964193">next</a><span>|</span><label class="collapse" for="c-38964941">[-]</label><label class="expand" for="c-38964941">[8 more]</label></div><br/><div class="children"><div class="content">They describe the state of a stream.  Which are flags and a current offset at a minimum.  On linux you can examine &#x2F;proc&#x2F;&lt;pid&gt;&#x2F;fdinfo&#x2F;&lt;fd&gt; to see what it &#x27;describes&#x27; precisely.</div><br/><div id="38964953" class="c"><input type="checkbox" id="c-38964953" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#38964700">root</a><span>|</span><a href="#38964941">parent</a><span>|</span><a href="#38964193">next</a><span>|</span><label class="collapse" for="c-38964953">[-]</label><label class="expand" for="c-38964953">[7 more]</label></div><br/><div class="children"><div class="content">The file descriptor doesn&#x27;t describe anything. It&#x27;s like your social security number, it&#x27;s merely a unique identifier for something else. Does your SSN describe you as a human? What do I know about you as a human after I hear your SSN? Absolutely nothing.</div><br/><div id="38965093" class="c"><input type="checkbox" id="c-38965093" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#38964700">root</a><span>|</span><a href="#38964953">parent</a><span>|</span><a href="#38965118">next</a><span>|</span><label class="collapse" for="c-38965093">[-]</label><label class="expand" for="c-38965093">[5 more]</label></div><br/><div class="children"><div class="content">&gt; What do I know about you as a human after I hear your SSN<p>You know what part of the country I was born in,  and using that,  you can guess my age range.  The interface is an opaque number,  the implementation describes state,  some of which is guaranteed to be present,  one of which you can access using lseek(),  which is a system call.  In this case the state is even completely deterministic.</div><br/><div id="38965228" class="c"><input type="checkbox" id="c-38965228" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#38964700">root</a><span>|</span><a href="#38965093">parent</a><span>|</span><a href="#38965118">next</a><span>|</span><label class="collapse" for="c-38965228">[-]</label><label class="expand" for="c-38965228">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The interface is an opaque number<p>While opaque for a subset of the API, it&#x27;s not fully opaque since certain assumptions are made by the client based on their value: they are guaranteed to be reused and minimal.<p>What this means is I can do close(0); open(...) to redirect stdin.<p>&gt; the implementation describes state, some of which is guaranteed to be present, one of which you can access using lseek()<p>&gt;&gt; Which are flags and a current offset at a minimum.<p>Uhh... no. Try that with pipes, sockets, FIFOs or any of the myriad other file types, eventfds, signalfds, kqueue, etc there are. Most open fds on a data center server likely don&#x27;t meet your criteria.<p>Even POSIX disagrees for the concept you are trying to convey cf &quot;file description&quot;.
<a href="https:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;9699919799&#x2F;basedefs&#x2F;V1_chap03.html" rel="nofollow">https:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;9699919799&#x2F;basedefs&#x2F;V1...</a></div><br/><div id="38965249" class="c"><input type="checkbox" id="c-38965249" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#38964700">root</a><span>|</span><a href="#38965228">parent</a><span>|</span><a href="#38965118">next</a><span>|</span><label class="collapse" for="c-38965249">[-]</label><label class="expand" for="c-38965249">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Even POSIX disagrees for the concept you are trying to convey cf &quot;file description&quot;<p>You should have kept reading:<p>3.258 Open File Description
A record of how a process or group of processes is accessing a file. Each file descriptor refers to exactly one open file description, but an open file description can be referred to by more than one file descriptor. The file offset, file status, and file access modes are attributes of an open file description.</div><br/><div id="38965299" class="c"><input type="checkbox" id="c-38965299" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#38964700">root</a><span>|</span><a href="#38965249">parent</a><span>|</span><a href="#38965118">next</a><span>|</span><label class="collapse" for="c-38965299">[-]</label><label class="expand" for="c-38965299">[2 more]</label></div><br/><div class="children"><div class="content">&quot;The file offset, file status, and file access modes are attributes of an open file description&quot;<p>That says file <i>description</i> there buddy, not descriptor. The two are defined separately, that is all.<p>The single integer does not describe state in the way those terms are typically used; we have clearer vocabulary: refers, points to, etc that&#x27;s fine. But it is a distinction with a difference. (They&#x27;re not even unique).<p>Edit: yeah, it says refers, not describes.</div><br/><div id="38965365" class="c"><input type="checkbox" id="c-38965365" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#38964700">root</a><span>|</span><a href="#38965299">parent</a><span>|</span><a href="#38965118">next</a><span>|</span><label class="collapse" for="c-38965365">[-]</label><label class="expand" for="c-38965365">[1 more]</label></div><br/><div class="children"><div class="content">And,  read more carefully,  emphasis added:<p>&quot;Each file descriptor refers to exactly one open file description&quot;<p>Different integers are always unique.  It&#x27;s the file description that isn&#x27;t:<p>&quot;but an open file description can be referred to by more than one file descriptor.&quot;<p>You&#x27;re attempting to make a huge distinction between interface and implementation.  I can&#x27;t rightly determine why.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38965118" class="c"><input type="checkbox" id="c-38965118" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#38964700">root</a><span>|</span><a href="#38964953">parent</a><span>|</span><a href="#38965093">prev</a><span>|</span><a href="#38964193">next</a><span>|</span><label class="collapse" for="c-38965118">[-]</label><label class="expand" for="c-38965118">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not even unique (outside of a process) nor exclusive.</div><br/></div></div></div></div></div></div></div></div><div id="38964193" class="c"><input type="checkbox" id="c-38964193" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#38964700">prev</a><span>|</span><a href="#38964664">next</a><span>|</span><label class="collapse" for="c-38964193">[-]</label><label class="expand" for="c-38964193">[1 more]</label></div><br/><div class="children"><div class="content">The subtler issues:<p>* All of the following exist and are distinct:<p><pre><code>  * File descriptor (for as long as it&#x27;s open)
  * File descriptor number (can be replaced by close+open or dup\*; there are also special values like `AT_FDCWD`, `OPENMAX` (not necessarily equal to `FD_SETSIZE` or what `ulimit` limits you to)
  * Open file description (unchanged across dup and fork ...)
  * Files (e.g. separate open() calls that happen to refer to the same file, whether by the same name or not)
  * File names
</code></pre>
* file descriptors to special files, to things that are not files, to files outside of the current chroot, to files from a directory that has been mounted over, to files that have been moved or deleted<p>* what exactly does mmap hold on to?<p>* recvmsg cmsg can make file descriptors appear. Fortunately this is the most common use of cmsg, but remember you can get more than you request (but IIRC there&#x27;s no clean way to get the number given, the API is underspecified)<p>* There&#x27;s really nothing special about file descriptors 0, 1, and 2; they&#x27;re just a strong convention that processes tend to have open at fork time. In practice, you can live without stdin and stdout, but stderr can be written to by all sorts of library functions.<p>* seriously, use `O_CLOEXEC` by default people!<p>* representing FD ownership can be tricky</div><br/></div></div><div id="38964664" class="c"><input type="checkbox" id="c-38964664" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38964193">prev</a><span>|</span><a href="#38964471">next</a><span>|</span><label class="collapse" for="c-38964664">[-]</label><label class="expand" for="c-38964664">[1 more]</label></div><br/><div class="children"><div class="content">&gt; For example, if you open a âexample_file1.txtâ file (which is nothing but a process)<p>Iâm very confused by this use of âprocessâ. This isnât one? Thereâs a note further down talking about how closing it will make it available to other processes that doesnât make sense either.</div><br/></div></div><div id="38964471" class="c"><input type="checkbox" id="c-38964471" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#38964664">prev</a><span>|</span><a href="#38963853">next</a><span>|</span><label class="collapse" for="c-38964471">[-]</label><label class="expand" for="c-38964471">[1 more]</label></div><br/><div class="children"><div class="content">I think of file descriptors as a void* across address spaces<p>In C you often use void* for opaque handles.<p>But you can&#x27;t have a user space pointer into the kernel, since it&#x27;s in a different address space.  So you instead have an integer that&#x27;s unique within a particular process, and then a per-process table in the kernel that points to the real data structures.</div><br/></div></div><div id="38963853" class="c"><input type="checkbox" id="c-38963853" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#38964471">prev</a><span>|</span><a href="#38964737">next</a><span>|</span><label class="collapse" for="c-38963853">[-]</label><label class="expand" for="c-38963853">[3 more]</label></div><br/><div class="children"><div class="content">DOS and Windows calls them file handles, but they serve the same function. DOS even has the same 0, 1, 2 for in, out, err. Of course they all inherited this design from Unix.</div><br/><div id="38964549" class="c"><input type="checkbox" id="c-38964549" checked=""/><div class="controls bullet"><span class="by">simonblack</span><span>|</span><a href="#38963853">parent</a><span>|</span><a href="#38964737">next</a><span>|</span><label class="collapse" for="c-38964549">[-]</label><label class="expand" for="c-38964549">[2 more]</label></div><br/><div class="children"><div class="content"><i>Of course they all inherited this design from Unix.</i><p>As far as Microsoft is concerned, Windows and MSDOS inherited this design from XENIX, which was Microsoft&#x27;s clone of V7 UNIX. That XENIX was later sold to the Santa Cruz Operation, then later again SCO XENIX was renamed to SCO UNIX.<p>It&#x27;s fascinating to wonder how different the computing world would be today if Microsoft had used their XENIX as the underlying base for Windows, instead of the  way they did do it.<p>Linux would probably have never got off the ground, and remained a curiosity like the MINIX it was based upon initially. And Microsoft would completely own the UNIX world. Thank God they didn&#x27;t.</div><br/><div id="38964647" class="c"><input type="checkbox" id="c-38964647" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#38963853">root</a><span>|</span><a href="#38964549">parent</a><span>|</span><a href="#38964737">next</a><span>|</span><label class="collapse" for="c-38964647">[-]</label><label class="expand" for="c-38964647">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>XENIX, which was Microsoft&#x27;s clone of V7 UNIX</i><p>no, not a clone, xenix was licensed unix v7, licensed from AT&amp;T. They did not have a license to use the trademark unix, so they called their version xenix.<p>unix was already widely available when Linus started tinkering, he wanted to play with source, and BSD&#x27;s were still tangled up in copyright. Had closed source Windows been based on unix, linux&#x27;s open source hegemony would have toppled Windows too</div><br/></div></div></div></div></div></div><div id="38964737" class="c"><input type="checkbox" id="c-38964737" checked=""/><div class="controls bullet"><span class="by">yonatan8070</span><span>|</span><a href="#38963853">prev</a><span>|</span><a href="#38964795">next</a><span>|</span><label class="collapse" for="c-38964737">[-]</label><label class="expand" for="c-38964737">[2 more]</label></div><br/><div class="children"><div class="content">What uses are there for limiting system level FDs? To me it sounds like it can only cause problems</div><br/><div id="38964800" class="c"><input type="checkbox" id="c-38964800" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#38964737">parent</a><span>|</span><a href="#38964795">next</a><span>|</span><label class="collapse" for="c-38964800">[-]</label><label class="expand" for="c-38964800">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m guessing here based on how they&#x27;re implemented on Windows, and someone should correct me if I&#x27;m wrong, but I would <i>think</i> it&#x27;s meant to guard against consuming (comparatively expensive) kernel-mode memory. Expensive because they can&#x27;t be paged to disk [1], and thus actually consume RAM, thus allowing even lowly-privileged applications to completely exhaust physical RAM and thus make the system unusable.<p>FWIW, I don&#x27;t think Windows has such a limit, so this makes me wonder if this is really the concern. I&#x27;m not aware of a better reason.<p>[1] AFAIK, on Windows, kernel <i>objects</i> (which the kernel cares about) use the non-paged pool, but <i>handles</i> to them (which user-mode cares about) use the paged pool. So you don&#x27;t technically need to limit the number of handles per se, but it seems like a convenient proxy.</div><br/></div></div></div></div><div id="38964795" class="c"><input type="checkbox" id="c-38964795" checked=""/><div class="controls bullet"><span class="by">shmerl</span><span>|</span><a href="#38964737">prev</a><span>|</span><a href="#38964710">next</a><span>|</span><label class="collapse" for="c-38964795">[-]</label><label class="expand" for="c-38964795">[3 more]</label></div><br/><div class="children"><div class="content"><i>&gt; The lsof command is used to list the information about running processes in the system and can also be used to list the file descriptor under a specific PID.</i><p><i>&gt; For that, use the â-dâ flag to specify a range of file descriptors, with the â-pâ option specifying the PID. To combine this selection, use the â-aâ flag.</i><p><i>&gt; $ lsof -a -d 0-2147483647 -p 11472</i><p>That works. A nicer way to do it:<p>htop &gt; F3 (search by name to find the process) &gt; Enter (to select) &gt; L (open the list of file descriptors) &gt; F4 (filter by resource name)<p>It lists all open files and other resources of the process.</div><br/><div id="38965296" class="c"><input type="checkbox" id="c-38965296" checked=""/><div class="controls bullet"><span class="by">kristjansson</span><span>|</span><a href="#38964795">parent</a><span>|</span><a href="#38964710">next</a><span>|</span><label class="collapse" for="c-38965296">[-]</label><label class="expand" for="c-38965296">[2 more]</label></div><br/><div class="children"><div class="content">I use htop at least once a day and had no idea it could do that.  Thanks!</div><br/><div id="38965372" class="c"><input type="checkbox" id="c-38965372" checked=""/><div class="controls bullet"><span class="by">shmerl</span><span>|</span><a href="#38964795">root</a><span>|</span><a href="#38965296">parent</a><span>|</span><a href="#38964710">next</a><span>|</span><label class="collapse" for="c-38965372">[-]</label><label class="expand" for="c-38965372">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re welcome! I found that after KDE replaced ksysguard with system monitor. The former could list all open files of the proecss, but the latter can&#x27;t. So I was digging for some good tool and found this obscure htop feature :)<p>It&#x27;s documented in man htop btw.</div><br/></div></div></div></div></div></div><div id="38964710" class="c"><input type="checkbox" id="c-38964710" checked=""/><div class="controls bullet"><span class="by">pm2222</span><span>|</span><a href="#38964795">prev</a><span>|</span><a href="#38963561">next</a><span>|</span><label class="collapse" for="c-38964710">[-]</label><label class="expand" for="c-38964710">[1 more]</label></div><br/><div class="children"><div class="content">Coat checks are similar.</div><br/></div></div></div></div></div></div></div></body></html>