<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1706086859910" as="style"/><link rel="stylesheet" href="styles.css?v=1706086859910"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/ashvardanian/SimSIMD">SimSIMD: Hardware-accelerated similarity metrics and distance functions</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>sroussey</span> | <span>25 comments</span></div><br/><div><div id="39115185" class="c"><input type="checkbox" id="c-39115185" checked=""/><div class="controls bullet"><span class="by">egorfine</span><span>|</span><a href="#39112754">next</a><span>|</span><label class="collapse" for="c-39115185">[-]</label><label class="expand" for="c-39115185">[1 more]</label></div><br/><div class="children"><div class="content">I wonder how it compares to faiss in terms of performance on Intel CPUs</div><br/></div></div><div id="39112754" class="c"><input type="checkbox" id="c-39112754" checked=""/><div class="controls bullet"><span class="by">ttul</span><span>|</span><a href="#39115185">prev</a><span>|</span><a href="#39113671">next</a><span>|</span><label class="collapse" for="c-39112754">[-]</label><label class="expand" for="c-39112754">[1 more]</label></div><br/><div class="children"><div class="content">This is the kind of basement sorcery that makes the world go round. Nicely done.</div><br/></div></div><div id="39113671" class="c"><input type="checkbox" id="c-39113671" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#39112754">prev</a><span>|</span><a href="#39113087">next</a><span>|</span><label class="collapse" for="c-39113671">[-]</label><label class="expand" for="c-39113671">[8 more]</label></div><br/><div class="children"><div class="content">Tangential: How do you guys decide which similarity metric to use? Euclidean seems the most intuitive but I&#x27;m sure others also have use cases. This situation is similar to the similarity metrics used to compare two distributions (KL for insurance, tho technically it&#x27;s not a metric). Is there some art to it or is there really a systematic way to choose metrics for different tasks?</div><br/><div id="39114254" class="c"><input type="checkbox" id="c-39114254" checked=""/><div class="controls bullet"><span class="by">godelski</span><span>|</span><a href="#39113671">parent</a><span>|</span><a href="#39113743">next</a><span>|</span><label class="collapse" for="c-39114254">[-]</label><label class="expand" for="c-39114254">[3 more]</label></div><br/><div class="children"><div class="content">This is actually a really underappreciated question! (and also really interesting!) There&#x27;s a lot of nuance to this because the truth is that distance becomes less meaningful as you increase dimensions. You can find some papers comparing Lp distances with different p values (p=2 == Euclidean == L2). But as dimension increases, the distance to the furthest points decreases (making it harder to differentiate near points from far points). Cosine similarity is a commonly used one, but as dimensions increase the likelihood that any two tensors are orthogonal rapidly increases. This might seem counterintuitive because the probability is really low in 2 or 3 dims as you only have 2 or a plane in R3.<p>So really the answer honestly tends to be ad hoc: &quot;whatever works best&quot;. It&#x27;s good to keep in mind that any intuition you have about geometry goes out the window as dimensions increase. It&#x27;s always important to remember assumptions made, especially when focusing on empiricism. There are definitely some nuances that can point you in better directions (pun intended :) than random guessing, especially if you know a lot about your geometry, but it is messy and nuances can make big differences.<p>I wish I had a better answer but I hope this is informative. Maybe some mathematician will show up and add more. I&#x27;m sure there&#x27;s someone on HN that loves to talk about higher dimensional geometry and I&#x27;d love to hear those &quot;rants.&quot;</div><br/><div id="39114780" class="c"><input type="checkbox" id="c-39114780" checked=""/><div class="controls bullet"><span class="by">Loic</span><span>|</span><a href="#39113671">root</a><span>|</span><a href="#39114254">parent</a><span>|</span><a href="#39114379">next</a><span>|</span><label class="collapse" for="c-39114780">[-]</label><label class="expand" for="c-39114780">[1 more]</label></div><br/><div class="children"><div class="content">&quot;whatever works best&quot; because it also totally depends on your field of application. Here[0] is for example a similarity search using the Tanimoto[1] index.<p>The &quot;works best&quot; is also, in many cases, subjective. This is also not easy to assess, you may need several people looking at the results, here molecules, to say if yes they are similar or not. A chemist will think differently than a biologist in this regard.<p>[0]: <a href="https:&#x2F;&#x2F;www.chemeo.com&#x2F;similar?smiles=Cc1c%28%5bN%2b%5d%28%3dO%29%5bO-%5d%29cc%28%5bN%2b%5d%28%3dO%29%5bO-%5d%29cc1%5bN%2b%5d%28%3dO%29%5bO-%5d" rel="nofollow">https:&#x2F;&#x2F;www.chemeo.com&#x2F;similar?smiles=Cc1c%28%5bN%2b%5d%28%3...</a><p>[1]: <a href="https:&#x2F;&#x2F;jcheminf.biomedcentral.com&#x2F;articles&#x2F;10.1186&#x2F;s13321-015-0069-3" rel="nofollow">https:&#x2F;&#x2F;jcheminf.biomedcentral.com&#x2F;articles&#x2F;10.1186&#x2F;s13321-0...</a></div><br/></div></div><div id="39114379" class="c"><input type="checkbox" id="c-39114379" checked=""/><div class="controls bullet"><span class="by">sroussey</span><span>|</span><a href="#39113671">root</a><span>|</span><a href="#39114254">parent</a><span>|</span><a href="#39114780">prev</a><span>|</span><a href="#39113743">next</a><span>|</span><label class="collapse" for="c-39114379">[-]</label><label class="expand" for="c-39114379">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I’m working on a test framework to try the various permutations to see what works.<p>And for me to get a feel for it.</div><br/></div></div></div></div><div id="39113743" class="c"><input type="checkbox" id="c-39113743" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#39113671">parent</a><span>|</span><a href="#39114254">prev</a><span>|</span><a href="#39113087">next</a><span>|</span><label class="collapse" for="c-39113743">[-]</label><label class="expand" for="c-39113743">[4 more]</label></div><br/><div class="children"><div class="content">My intuition:<p>L2 in low dims, Cosine in high dims. Hamming on similar size sets, Jaccard on others. Jensen-Shannon (symmetric KL) when dealing with histograms and probability distribution.</div><br/><div id="39113985" class="c"><input type="checkbox" id="c-39113985" checked=""/><div class="controls bullet"><span class="by">SubiculumCode</span><span>|</span><a href="#39113671">root</a><span>|</span><a href="#39113743">parent</a><span>|</span><a href="#39113087">next</a><span>|</span><label class="collapse" for="c-39113985">[-]</label><label class="expand" for="c-39113985">[3 more]</label></div><br/><div class="children"><div class="content">Manhattan is better than L2 at high dimensions..but why cos?</div><br/><div id="39114035" class="c"><input type="checkbox" id="c-39114035" checked=""/><div class="controls bullet"><span class="by">SubiculumCode</span><span>|</span><a href="#39113671">root</a><span>|</span><a href="#39113985">parent</a><span>|</span><a href="#39113087">next</a><span>|</span><label class="collapse" for="c-39114035">[-]</label><label class="expand" for="c-39114035">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;stats.stackexchange.com&#x2F;questions&#x2F;341535&#x2F;curse-of-dimensionality-does-cosine-similarity-work-better-and-if-so-why" rel="nofollow">https:&#x2F;&#x2F;stats.stackexchange.com&#x2F;questions&#x2F;341535&#x2F;curse-of-di...</a></div><br/><div id="39114215" class="c"><input type="checkbox" id="c-39114215" checked=""/><div class="controls bullet"><span class="by">godelski</span><span>|</span><a href="#39113671">root</a><span>|</span><a href="#39114035">parent</a><span>|</span><a href="#39113087">next</a><span>|</span><label class="collapse" for="c-39114215">[-]</label><label class="expand" for="c-39114215">[1 more]</label></div><br/><div class="children"><div class="content">Cosine similarity is certainly not immune to the curse of dimensionality. In fact, it is explicitly prone to it. As dimensions increase, the likelihood that any two tensors are orthogonal rapidly increases. This is easy to reason out if you start from 2 dimensions, count the number of orthogonal vectors, and then move to 3D, and so on.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39113087" class="c"><input type="checkbox" id="c-39113087" checked=""/><div class="controls bullet"><span class="by">chaps</span><span>|</span><a href="#39113671">prev</a><span>|</span><a href="#39112844">next</a><span>|</span><label class="collapse" for="c-39113087">[-]</label><label class="expand" for="c-39113087">[5 more]</label></div><br/><div class="children"><div class="content">Nice! Similarity searching is the bane of my existence, but also gives life to so many of the things I work on. 200x sounds wonderfully fast.<p>Does this do levenshtein distance? Didn&#x27;t see it in the main document.<p>Edit: also, THANK YOU for adding a parameter to specify # of threads. Wish this was a wider standard practice.</div><br/><div id="39113106" class="c"><input type="checkbox" id="c-39113106" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39113087">parent</a><span>|</span><a href="#39113618">next</a><span>|</span><label class="collapse" for="c-39113106">[-]</label><label class="expand" for="c-39113106">[1 more]</label></div><br/><div class="children"><div class="content">The author is also responsible for the StringZilla library that includes levenstein distance: <a href="https:&#x2F;&#x2F;github.com&#x2F;ashvardanian&#x2F;StringZilla">https:&#x2F;&#x2F;github.com&#x2F;ashvardanian&#x2F;StringZilla</a></div><br/></div></div><div id="39113618" class="c"><input type="checkbox" id="c-39113618" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#39113087">parent</a><span>|</span><a href="#39113106">prev</a><span>|</span><a href="#39113186">next</a><span>|</span><label class="collapse" for="c-39113618">[-]</label><label class="expand" for="c-39113618">[1 more]</label></div><br/><div class="children"><div class="content">He-hey! For Levenshtein distance check out the development branch of StringZilla. Hopefully will release this week :)<p>Oh, and for multithreading, USearch might be more practical.</div><br/></div></div><div id="39113186" class="c"><input type="checkbox" id="c-39113186" checked=""/><div class="controls bullet"><span class="by">brrrrrm</span><span>|</span><a href="#39113087">parent</a><span>|</span><a href="#39113618">prev</a><span>|</span><a href="#39112844">next</a><span>|</span><label class="collapse" for="c-39113186">[-]</label><label class="expand" for="c-39113186">[2 more]</label></div><br/><div class="children"><div class="content">OMP_NUM_THREADS=n is pretty standard in HPC workloads</div><br/><div id="39113261" class="c"><input type="checkbox" id="c-39113261" checked=""/><div class="controls bullet"><span class="by">chaps</span><span>|</span><a href="#39113087">root</a><span>|</span><a href="#39113186">parent</a><span>|</span><a href="#39112844">next</a><span>|</span><label class="collapse" for="c-39113261">[-]</label><label class="expand" for="c-39113261">[1 more]</label></div><br/><div class="children"><div class="content">Huh, thanks. I&#x27;ll check it out and see if I can drop that in.</div><br/></div></div></div></div></div></div><div id="39112844" class="c"><input type="checkbox" id="c-39112844" checked=""/><div class="controls bullet"><span class="by">turnsout</span><span>|</span><a href="#39113087">prev</a><span>|</span><a href="#39112947">next</a><span>|</span><label class="collapse" for="c-39112844">[-]</label><label class="expand" for="c-39112844">[8 more]</label></div><br/><div class="children"><div class="content">Are vector databases like Chroma already doing some of this? If not, it could be a huge win for RAG workflows!</div><br/><div id="39112880" class="c"><input type="checkbox" id="c-39112880" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#39112844">parent</a><span>|</span><a href="#39112987">next</a><span>|</span><label class="collapse" for="c-39112880">[-]</label><label class="expand" for="c-39112880">[2 more]</label></div><br/><div class="children"><div class="content">SimSIMD is already used in USearch, ClickHouse, and Lantern. In other solutions SIMD is generally limited to pre-2015 Assembly instructions. So yes, there a lot of RAG workflows to accelerate :)</div><br/><div id="39113653" class="c"><input type="checkbox" id="c-39113653" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#39112844">root</a><span>|</span><a href="#39112880">parent</a><span>|</span><a href="#39112987">next</a><span>|</span><label class="collapse" for="c-39113653">[-]</label><label class="expand" for="c-39113653">[1 more]</label></div><br/><div class="children"><div class="content">the sad part is that they are the ones ripping the benefits of this tech by capturing that sweet VC money</div><br/></div></div></div></div><div id="39112987" class="c"><input type="checkbox" id="c-39112987" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#39112844">parent</a><span>|</span><a href="#39112880">prev</a><span>|</span><a href="#39112947">next</a><span>|</span><label class="collapse" for="c-39112987">[-]</label><label class="expand" for="c-39112987">[5 more]</label></div><br/><div class="children"><div class="content">I’m curious if pgvector is using it. It’s actually pretty fast for us without even indexing.</div><br/><div id="39113312" class="c"><input type="checkbox" id="c-39113312" checked=""/><div class="controls bullet"><span class="by">sakras</span><span>|</span><a href="#39112844">root</a><span>|</span><a href="#39112987">parent</a><span>|</span><a href="#39112947">next</a><span>|</span><label class="collapse" for="c-39113312">[-]</label><label class="expand" for="c-39113312">[4 more]</label></div><br/><div class="children"><div class="content">As far as I&#x27;m aware pg_vector just uses the compiler&#x27;s autovectorization on float32. I think specifically for Euclidean distance you won&#x27;t really beat GCC (the README even admits it: &quot;GCC handles single-precision float but might not be the best choice for int8 and _Float16 arrays, which has been part of the C language since 2011.&quot;)</div><br/><div id="39113650" class="c"><input type="checkbox" id="c-39113650" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#39112844">root</a><span>|</span><a href="#39113312">parent</a><span>|</span><a href="#39114177">next</a><span>|</span><label class="collapse" for="c-39113650">[-]</label><label class="expand" for="c-39113650">[2 more]</label></div><br/><div class="children"><div class="content">Yes, the improvements for float32 aren&#x27;t very dramatic, but it can be 3x NumPy&#x2F;SciPy: <a href="https:&#x2F;&#x2F;ashvardanian.com&#x2F;posts&#x2F;simsimd-faster-scipy&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ashvardanian.com&#x2F;posts&#x2F;simsimd-faster-scipy&#x2F;</a><p>C11 is also a bit tricky, as its support is optional, as far as I remember.</div><br/><div id="39113795" class="c"><input type="checkbox" id="c-39113795" checked=""/><div class="controls bullet"><span class="by">sakras</span><span>|</span><a href="#39112844">root</a><span>|</span><a href="#39113650">parent</a><span>|</span><a href="#39114177">next</a><span>|</span><label class="collapse" for="c-39113795">[-]</label><label class="expand" for="c-39113795">[1 more]</label></div><br/><div class="children"><div class="content">I also notice you use FMA in your AVX2 L2 distance calculation. I don&#x27;t think pg_vector enables that, so SimSIMD might be slightly faster.<p>Also interesting that it beats NumPy&#x2F;SciPy by so much! I wonder what they&#x27;re doing..</div><br/></div></div></div></div><div id="39114177" class="c"><input type="checkbox" id="c-39114177" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#39112844">root</a><span>|</span><a href="#39113312">parent</a><span>|</span><a href="#39113650">prev</a><span>|</span><a href="#39112947">next</a><span>|</span><label class="collapse" for="c-39114177">[-]</label><label class="expand" for="c-39114177">[1 more]</label></div><br/><div class="children"><div class="content">It doesn’t support f16 or i8 at all yet (at least not in the released version).</div><br/></div></div></div></div></div></div></div></div><div id="39112947" class="c"><input type="checkbox" id="c-39112947" checked=""/><div class="controls bullet"><span class="by">sroussey</span><span>|</span><a href="#39112844">prev</a><span>|</span><label class="collapse" for="c-39112947">[-]</label><label class="expand" for="c-39112947">[1 more]</label></div><br/><div class="children"><div class="content">I’m using this and became a contributor this year (prebuilt binaries for nodejs and bun, as well as some ts&#x2F;js mangling). :)</div><br/></div></div></div></div></div></div></div></body></html>