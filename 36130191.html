<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1685523667010" as="style"/><link rel="stylesheet" href="styles.css?v=1685523667010"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/ossrs/ffmpeg-webrtc/pull/1">WebRTC support being added to FFmpeg</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>Sean-Der</span> | <span>21 comments</span></div><br/><div><div id="36132957" class="c"><input type="checkbox" id="c-36132957" checked=""/><div class="controls bullet"><span class="by">Sean-Der</span><span>|</span><a href="#36132819">next</a><span>|</span><label class="collapse" for="c-36132957">[-]</label><label class="expand" for="c-36132957">[4 more]</label></div><br/><div class="children"><div class="content">I am really excited for this PR to land. Being able to use WebRTC for Broadcast and Playback is going to be huge.<p>Instead of doing fixed interval keyframe we can use receiver feedback (Massive reduction in bandwidth)<p>Instead of server side generated transcodes we can use Simulcast. Will be better quality AND massively reduced server load.<p>If anyone wants to use with Pion check out <a href="https:&#x2F;&#x2F;github.com&#x2F;Glimesh&#x2F;broadcast-box">https:&#x2F;&#x2F;github.com&#x2F;Glimesh&#x2F;broadcast-box</a><p>Then run `ffmpeg -re -f lavfi -i testsrc=s=1280x720:r=30 -f lavfi -i sine=f=440:b=4 -vcodec libx264 -pix_fmt yuv420p -profile:v baseline -r 25 -g 50 -acodec libopus -ar 48000 -ac 2   -f rtc -authorization &quot;STREAM_NAME&quot; &quot;<a href="http:&#x2F;&#x2F;localhost:8080&#x2F;whip" rel="nofollow">http:&#x2F;&#x2F;localhost:8080&#x2F;whip</a>&quot;</div><br/><div id="36135573" class="c"><input type="checkbox" id="c-36135573" checked=""/><div class="controls bullet"><span class="by">millon</span><span>|</span><a href="#36132957">parent</a><span>|</span><a href="#36133239">next</a><span>|</span><label class="collapse" for="c-36135573">[-]</label><label class="expand" for="c-36135573">[2 more]</label></div><br/><div class="children"><div class="content">What is receiver feedback?</div><br/><div id="36135874" class="c"><input type="checkbox" id="c-36135874" checked=""/><div class="controls bullet"><span class="by">kabes</span><span>|</span><a href="#36132957">root</a><span>|</span><a href="#36135573">parent</a><span>|</span><a href="#36133239">next</a><span>|</span><label class="collapse" for="c-36135874">[-]</label><label class="expand" for="c-36135874">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an umbrella term for a bunch of mechanisms where the receiver can tell the sender about things like dropped packets, congestion etc. So the sender can adjust the stream accordingly.</div><br/></div></div></div></div><div id="36133239" class="c"><input type="checkbox" id="c-36133239" checked=""/><div class="controls bullet"><span class="by">nerdbaggy</span><span>|</span><a href="#36132957">parent</a><span>|</span><a href="#36135573">prev</a><span>|</span><a href="#36132819">next</a><span>|</span><label class="collapse" for="c-36133239">[-]</label><label class="expand" for="c-36133239">[1 more]</label></div><br/><div class="children"><div class="content">I wish there was a better way to scale receiver feedback. It is very hard&#x2F;impossible to scale without the server saving every frame and being able to come up with the frames as needed.</div><br/></div></div></div></div><div id="36132819" class="c"><input type="checkbox" id="c-36132819" checked=""/><div class="controls bullet"><span class="by">stevemk14ebr</span><span>|</span><a href="#36132957">prev</a><span>|</span><a href="#36134681">next</a><span>|</span><label class="collapse" for="c-36132819">[-]</label><label class="expand" for="c-36132819">[4 more]</label></div><br/><div class="children"><div class="content">&quot;Unfortunately, most WHIP implementations are highly complex and require modern C++11 or C++14, or RUST...To meet FFmpeg&#x27;s requirements, this PR contains just C code. And we have rewritten the WHIP and WebRTC protocol stack using only around 2k lines of C code.&quot;<p>Where is the section on the security audit? For a protocol accepting remote streams especially this seems like a vector for exploitable bugs to be introduced unintentionally.</div><br/><div id="36132850" class="c"><input type="checkbox" id="c-36132850" checked=""/><div class="controls bullet"><span class="by">MuffinFlavored</span><span>|</span><a href="#36132819">parent</a><span>|</span><a href="#36134681">next</a><span>|</span><label class="collapse" for="c-36132850">[-]</label><label class="expand" for="c-36132850">[3 more]</label></div><br/><div class="children"><div class="content">why couldn&#x27;t they just compile with Rust to a .dll&#x2F;.dylib&#x2F;.so and then do some dlopen &#x2F; dlsym FFI? :P</div><br/><div id="36133180" class="c"><input type="checkbox" id="c-36133180" checked=""/><div class="controls bullet"><span class="by">Sean-Der</span><span>|</span><a href="#36132819">root</a><span>|</span><a href="#36132850">parent</a><span>|</span><a href="#36133105">next</a><span>|</span><label class="collapse" for="c-36133180">[-]</label><label class="expand" for="c-36133180">[1 more]</label></div><br/><div class="children"><div class="content">I tried to do this with OBS. The code worked really well. It was so stable and performant. Life is significantly better not debugging SEGV. However it puts too much burden on the maintainers.<p>So much work goes into packaging etc… I don’t have much hope for the ‘Rust as a submodule in a C&#x2F;C++ project’ story :(</div><br/></div></div><div id="36133105" class="c"><input type="checkbox" id="c-36133105" checked=""/><div class="controls bullet"><span class="by">rcme</span><span>|</span><a href="#36132819">root</a><span>|</span><a href="#36132850">parent</a><span>|</span><a href="#36133180">prev</a><span>|</span><a href="#36134681">next</a><span>|</span><label class="collapse" for="c-36133105">[-]</label><label class="expand" for="c-36133105">[1 more]</label></div><br/><div class="children"><div class="content">It’s too hard to support every possible target that way.</div><br/></div></div></div></div></div></div><div id="36134681" class="c"><input type="checkbox" id="c-36134681" checked=""/><div class="controls bullet"><span class="by">pavlov</span><span>|</span><a href="#36132819">prev</a><span>|</span><a href="#36135223">next</a><span>|</span><label class="collapse" for="c-36134681">[-]</label><label class="expand" for="c-36134681">[1 more]</label></div><br/><div class="children"><div class="content">More specifically it’s WHIP publishing support, not full WebRTC.<p>WHIP stands for WebRTC-HTTP Ingestion Protocol. It’s “a simple HTTP-based protocol that will allow WebRTC-based ingestion of content into streaming services and&#x2F;or CDNs.”</div><br/></div></div><div id="36132907" class="c"><input type="checkbox" id="c-36132907" checked=""/><div class="controls bullet"><span class="by">Game_Ender</span><span>|</span><a href="#36135223">prev</a><span>|</span><a href="#36134213">next</a><span>|</span><label class="collapse" for="c-36132907">[-]</label><label class="expand" for="c-36132907">[4 more]</label></div><br/><div class="children"><div class="content">It will be great to have an alternative to using a big chunk of a Chrome [0] just to be able stream video to a client.<p>0 - <a href="https:&#x2F;&#x2F;chromium.googlesource.com&#x2F;external&#x2F;webrtc&#x2F;" rel="nofollow">https:&#x2F;&#x2F;chromium.googlesource.com&#x2F;external&#x2F;webrtc&#x2F;</a></div><br/><div id="36133004" class="c"><input type="checkbox" id="c-36133004" checked=""/><div class="controls bullet"><span class="by">Sean-Der</span><span>|</span><a href="#36132907">parent</a><span>|</span><a href="#36134213">next</a><span>|</span><label class="collapse" for="c-36133004">[-]</label><label class="expand" for="c-36133004">[3 more]</label></div><br/><div class="children"><div class="content">Lots of other WebRTC implementation exist (in many languages). Happy to help if you have any questions<p>* <a href="https:&#x2F;&#x2F;github.com&#x2F;aiortc&#x2F;aiortc">https:&#x2F;&#x2F;github.com&#x2F;aiortc&#x2F;aiortc</a> (Python)<p>* GStreamer’s webrtcbin (C)<p>* <a href="https:&#x2F;&#x2F;github.com&#x2F;shinyoshiaki&#x2F;werift-webrtc">https:&#x2F;&#x2F;github.com&#x2F;shinyoshiaki&#x2F;werift-webrtc</a> (Typescript)<p>* <a href="https:&#x2F;&#x2F;github.com&#x2F;pion&#x2F;webrtc">https:&#x2F;&#x2F;github.com&#x2F;pion&#x2F;webrtc</a> (Golang)<p>* <a href="https:&#x2F;&#x2F;github.com&#x2F;webrtc-rs&#x2F;webrtc">https:&#x2F;&#x2F;github.com&#x2F;webrtc-rs&#x2F;webrtc</a> (Rust)<p>* <a href="https:&#x2F;&#x2F;github.com&#x2F;awslabs&#x2F;amazon-kinesis-video-streams-webrtc-sdk-c">https:&#x2F;&#x2F;github.com&#x2F;awslabs&#x2F;amazon-kinesis-video-streams-webr...</a> (C&#x2F;Embedded)<p>* <a href="https:&#x2F;&#x2F;webrtc.googlesource.com&#x2F;src&#x2F;" rel="nofollow">https:&#x2F;&#x2F;webrtc.googlesource.com&#x2F;src&#x2F;</a> (C++)<p>* <a href="https:&#x2F;&#x2F;github.com&#x2F;rawrtc&#x2F;rawrtc">https:&#x2F;&#x2F;github.com&#x2F;rawrtc&#x2F;rawrtc</a> (C++)
* <a href="https:&#x2F;&#x2F;github.com&#x2F;sipsorcery-org&#x2F;sipsorcery">https:&#x2F;&#x2F;github.com&#x2F;sipsorcery-org&#x2F;sipsorcery</a> (C#)<p>* <a href="https:&#x2F;&#x2F;github.com&#x2F;paullouisageneau&#x2F;libdatachannel">https:&#x2F;&#x2F;github.com&#x2F;paullouisageneau&#x2F;libdatachannel</a> (C++)<p>See <a href="https:&#x2F;&#x2F;github.com&#x2F;sipsorcery&#x2F;webrtc-echoes">https:&#x2F;&#x2F;github.com&#x2F;sipsorcery&#x2F;webrtc-echoes</a> for examples of all of them running against each other.</div><br/><div id="36133259" class="c"><input type="checkbox" id="c-36133259" checked=""/><div class="controls bullet"><span class="by">Game_Ender</span><span>|</span><a href="#36132907">root</a><span>|</span><a href="#36133004">parent</a><span>|</span><a href="#36134213">next</a><span>|</span><label class="collapse" for="c-36133259">[-]</label><label class="expand" for="c-36133259">[2 more]</label></div><br/><div class="children"><div class="content">Thanks, I was look for well supported and actively maintained C++ library and libdatachannel looks like it!<p>Btw you need to check the links the AWS one is broken, and rawrtc has had only a few commits over the last few years.  Also neither of those is compared in the webrtc-echoes.</div><br/><div id="36133299" class="c"><input type="checkbox" id="c-36133299" checked=""/><div class="controls bullet"><span class="by">Sean-Der</span><span>|</span><a href="#36132907">root</a><span>|</span><a href="#36133259">parent</a><span>|</span><a href="#36134213">next</a><span>|</span><label class="collapse" for="c-36133299">[-]</label><label class="expand" for="c-36133299">[1 more]</label></div><br/><div class="children"><div class="content">Sorry about that! Fixed the AWS link, got truncated on phone.</div><br/></div></div></div></div></div></div></div></div><div id="36134213" class="c"><input type="checkbox" id="c-36134213" checked=""/><div class="controls bullet"><span class="by">EGreg</span><span>|</span><a href="#36132907">prev</a><span>|</span><a href="#36134073">next</a><span>|</span><label class="collapse" for="c-36134213">[-]</label><label class="expand" for="c-36134213">[2 more]</label></div><br/><div class="children"><div class="content">Just FYI, what we do at <a href="https:&#x2F;&#x2F;qbix.com&#x2F;platform" rel="nofollow">https:&#x2F;&#x2F;qbix.com&#x2F;platform</a> is we send WebRTC via MediaRecorder to a Node.js server via a socket. We then call ffmpeg from there, to record the video. In addition we can send RMTP to YouTube Telegram or Facebook for a livestream.<p>Actually we are big fans of trying to eliminate ALL dependence on Big Tech platforms so if you want to run your broadcast in a peer-to-peer way, you can:<p><a href="https:&#x2F;&#x2F;community.qbix.com&#x2F;t&#x2F;teleconferencing-and-live-broadcasts&#x2F;181" rel="nofollow">https:&#x2F;&#x2F;community.qbix.com&#x2F;t&#x2F;teleconferencing-and-live-broad...</a><p>Yes we built a self-rebalancing peer to peer broadcast tree based on WebRTC, that can be used to “livestream” to unlimited numbers of people even without needing some Big Tech server farms.</div><br/><div id="36135740" class="c"><input type="checkbox" id="c-36135740" checked=""/><div class="controls bullet"><span class="by">pavlov</span><span>|</span><a href="#36134213">parent</a><span>|</span><a href="#36134073">next</a><span>|</span><label class="collapse" for="c-36135740">[-]</label><label class="expand" for="c-36135740">[1 more]</label></div><br/><div class="children"><div class="content">Since we&#x27;re doing the self-promotion thing...<p>If you want to record WebRTC (or stream it to a service like YouTube&#x2F;Twitch&#x2F;Facebook), there are many different implementation strategies. The choices and trade-offs can be pretty confusing.<p>I wrote a long article about this topic:<p><a href="https:&#x2F;&#x2F;www.daily.co&#x2F;blog&#x2F;why-recording-webrtc-is-so-hard-2&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.daily.co&#x2F;blog&#x2F;why-recording-webrtc-is-so-hard-2&#x2F;</a><p>I work at Daily.co where we provide a WebRTC platform which makes cloud-based recording&#x2F;streaming not just possible but also visually rich and easy to use. The article is from a neutral viewpoint though, the options discussed could be used by any WebRTC app and are not specific to Daily.</div><br/></div></div></div></div><div id="36134073" class="c"><input type="checkbox" id="c-36134073" checked=""/><div class="controls bullet"><span class="by">jbritton</span><span>|</span><a href="#36134213">prev</a><span>|</span><a href="#36133070">next</a><span>|</span><label class="collapse" for="c-36134073">[-]</label><label class="expand" for="c-36134073">[2 more]</label></div><br/><div class="children"><div class="content">Will this allow a client to receive an rtsp stream and display it (with video tag or on canvas)?</div><br/><div id="36134091" class="c"><input type="checkbox" id="c-36134091" checked=""/><div class="controls bullet"><span class="by">Sean-Der</span><span>|</span><a href="#36134073">parent</a><span>|</span><a href="#36133070">next</a><span>|</span><label class="collapse" for="c-36134091">[-]</label><label class="expand" for="c-36134091">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think that will ever be possible unfortunately. WebRTC requires DTLS+SRTP for the mandatory security, don&#x27;t ever see that being made optional.<p>For RTSP&#x2F;WebRTC bridging I have used <a href="https:&#x2F;&#x2F;github.com&#x2F;AlexxIT&#x2F;go2rtc">https:&#x2F;&#x2F;github.com&#x2F;AlexxIT&#x2F;go2rtc</a> and really enjoy it.</div><br/></div></div></div></div><div id="36133070" class="c"><input type="checkbox" id="c-36133070" checked=""/><div class="controls bullet"><span class="by">pyrolistical</span><span>|</span><a href="#36134073">prev</a><span>|</span><label class="collapse" for="c-36133070">[-]</label><label class="expand" for="c-36133070">[2 more]</label></div><br/><div class="children"><div class="content">Seems like an opportunity for Zig to flex its C compatibility</div><br/><div id="36135589" class="c"><input type="checkbox" id="c-36135589" checked=""/><div class="controls bullet"><span class="by">joren-</span><span>|</span><a href="#36133070">parent</a><span>|</span><label class="collapse" for="c-36135589">[-]</label><label class="expand" for="c-36135589">[1 more]</label></div><br/><div class="children"><div class="content">I am not entirely sure with were you are going with this comment but FYI here is an ffmpeg fork with the build system replaced with a &quot;build.zig&quot; file and the Zig build environment: <a href="https:&#x2F;&#x2F;github.com&#x2F;andrewrk&#x2F;ffmpeg">https:&#x2F;&#x2F;github.com&#x2F;andrewrk&#x2F;ffmpeg</a>
I would assume that a C implementation of WebRTC would not differ much from other libraries and should be compatible.</div><br/></div></div></div></div></div></div></div></div></div></body></html>