<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1718010073828" as="style"/><link rel="stylesheet" href="styles.css?v=1718010073828"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://codeopinion.com/beware-anti-patterns-in-event-driven-architecture/">Anti-patterns in event-driven architecture</a> <span class="domain">(<a href="https://codeopinion.com">codeopinion.com</a>)</span></div><div class="subtext"><span>indentit</span> | <span>121 comments</span></div><br/><div><div id="40631553" class="c"><input type="checkbox" id="c-40631553" checked=""/><div class="controls bullet"><span class="by">onetimeuse92304</span><span>|</span><a href="#40620095">next</a><span>|</span><label class="collapse" for="c-40631553">[-]</label><label class="expand" for="c-40631553">[1 more]</label></div><br/><div class="children"><div class="content">Not specifically about event-driven, but the most damaging anti-pattern I would say is microservices.<p>In pretty much all projects I worked with, people chop up the functionality into small separate services and have the events be serialised, sent over the network and deserialised on the other side.<p>This typically causes enormous waste of efficiency and consequently causes applications to be much more complex than they need to be.<p>I have many times worked with apps which occupied huge server farms when in reality the business logic would be fine to run on a single node if just structured correctly.</div><br/></div></div><div id="40620095" class="c"><input type="checkbox" id="c-40620095" checked=""/><div class="controls bullet"><span class="by">arwhatever</span><span>|</span><a href="#40631553">prev</a><span>|</span><a href="#40620351">next</a><span>|</span><label class="collapse" for="c-40620095">[-]</label><label class="expand" for="c-40620095">[33 more]</label></div><br/><div class="children"><div class="content">I often hear the argument in favor of event-driven architecture that you can work on one part of a system in isolation without having to consider the other parts, and then I get assigned some task which requires me to consider the entire system operation, now with events that are harder to trace than function calls would have been.<p>Now when people argue “because decoupling,” I hear, “You don’t get as much notification that you just broke a downstream system.”</div><br/><div id="40623081" class="c"><input type="checkbox" id="c-40623081" checked=""/><div class="controls bullet"><span class="by">junto</span><span>|</span><a href="#40620095">parent</a><span>|</span><a href="#40630830">next</a><span>|</span><label class="collapse" for="c-40623081">[-]</label><label class="expand" for="c-40623081">[9 more]</label></div><br/><div class="children"><div class="content">You need to improve your telemetry to feel the benefits. I can trace all the way through multiple services easily on a simple detailed flame graph in our systems.<p><a href="https:&#x2F;&#x2F;www.datadoghq.com&#x2F;knowledge-center&#x2F;distributed-tracing&#x2F;flame-graph&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.datadoghq.com&#x2F;knowledge-center&#x2F;distributed-traci...</a><p>Unless you have a single monolith, you’re going to face issues with versioning whether it’s event based or API based. In each case you can usually add new properties to a message, but you can’t remove properties or change their types. If you need that, create a new version.<p>The author does a lot of videos on the event sourcing topic. Event driven I get. It works well in several applications I’ve helped to build over the last 15 years. But event sourcing? I truly don’t get it. Yeah I get it’s nice in terms of auditing to see every change to an entity and who made it, or replay up to to change x on y date, but that really is a niche requirement.</div><br/><div id="40628764" class="c"><input type="checkbox" id="c-40628764" checked=""/><div class="controls bullet"><span class="by">YZF</span><span>|</span><a href="#40620095">root</a><span>|</span><a href="#40623081">parent</a><span>|</span><a href="#40623223">next</a><span>|</span><label class="collapse" for="c-40628764">[-]</label><label class="expand" for="c-40628764">[3 more]</label></div><br/><div class="children"><div class="content">There are many examples of event sourcing but perhaps the most classical one is the bank account.<p>It&#x27;s not just about auditing, it&#x27;s also about transactionality and atomicity.<p>If you want to withdraw $5 from your account, the traditional approach of locking, updating everything, unlocking (or in other words wrapping everything in a transaction) doesn&#x27;t scale as well as the notion that you just record the transaction (event). Implementation-wise this withdrawal can involve, updating two accounts and updating the audit&#x2F;account transaction logs. We also want this to scale since our bank has millions of customers all operating more or less concurrently. A distributed log (like Kafka) is easy to scale and easy to reason about. You just insert the transaction record and you have a distributed system that will scale and is easy to reason about.<p>Another driver&#x2F;flavour for something like event sourcing is what some might call state-based or state-oriented programming. That is instead of modifying state directly you are synchronizing state via events. This lets you e.g. code state machines around those that can lead, again, to easier to reason about (and test) code.</div><br/><div id="40630737" class="c"><input type="checkbox" id="c-40630737" checked=""/><div class="controls bullet"><span class="by">davedx</span><span>|</span><a href="#40620095">root</a><span>|</span><a href="#40628764">parent</a><span>|</span><a href="#40623223">next</a><span>|</span><label class="collapse" for="c-40630737">[-]</label><label class="expand" for="c-40630737">[2 more]</label></div><br/><div class="children"><div class="content">Do you know for a fact that banks use event sourcing for transactions? I thought they were extremely eventually consistent</div><br/><div id="40630780" class="c"><input type="checkbox" id="c-40630780" checked=""/><div class="controls bullet"><span class="by">YZF</span><span>|</span><a href="#40620095">root</a><span>|</span><a href="#40630737">parent</a><span>|</span><a href="#40623223">next</a><span>|</span><label class="collapse" for="c-40630780">[-]</label><label class="expand" for="c-40630780">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty sure different banks use vastly different architectures. Some run nightly batch jobs on mainframes that are written in COBOL. But alas, I&#x27;ve not worked for any bank, this is just a commonly used example. I am willing to bet the transaction log, or ledger, is indeed a very common approach since that&#x27;s also common in accounting.<p>EDIT: Also event sourcing would typically be eventually consistent. I imagine for some banking applications a stronger consistency guarantee might be required, e.g. to prevent you from withdrawing the $100 in your account multiple times.</div><br/></div></div></div></div></div></div><div id="40623223" class="c"><input type="checkbox" id="c-40623223" checked=""/><div class="controls bullet"><span class="by">scubbo</span><span>|</span><a href="#40620095">root</a><span>|</span><a href="#40623081">parent</a><span>|</span><a href="#40628764">prev</a><span>|</span><a href="#40630819">next</a><span>|</span><label class="collapse" for="c-40623223">[-]</label><label class="expand" for="c-40623223">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I can trace all the way through multiple services easily on a simple detailed flame graph in our systems<p>I&#x27;m not sure what point is being made here. It&#x27;s good that you can do that - but are you implying that that&#x27;s not possible in an API-driven system?</div><br/></div></div><div id="40630819" class="c"><input type="checkbox" id="c-40630819" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#40620095">root</a><span>|</span><a href="#40623081">parent</a><span>|</span><a href="#40623223">prev</a><span>|</span><a href="#40623767">next</a><span>|</span><label class="collapse" for="c-40630819">[-]</label><label class="expand" for="c-40630819">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I can trace all the way through multiple services easily on a simple detailed flame graph in our systems.<p>That&#x27;s not exactly an obscure feature exclusive to datadog. From the top of my head, both AWS and Azure support distributed tracing with dedicated support for visualization in their x-ray and application insights services.</div><br/><div id="40630848" class="c"><input type="checkbox" id="c-40630848" checked=""/><div class="controls bullet"><span class="by">Jenk</span><span>|</span><a href="#40620095">root</a><span>|</span><a href="#40630819">parent</a><span>|</span><a href="#40623767">next</a><span>|</span><label class="collapse" for="c-40630848">[-]</label><label class="expand" for="c-40630848">[1 more]</label></div><br/><div class="children"><div class="content">I doubt GP was suggesting it is unique to DD.</div><br/></div></div></div></div><div id="40623767" class="c"><input type="checkbox" id="c-40623767" checked=""/><div class="controls bullet"><span class="by">okr</span><span>|</span><a href="#40620095">root</a><span>|</span><a href="#40623081">parent</a><span>|</span><a href="#40630819">prev</a><span>|</span><a href="#40628775">next</a><span>|</span><label class="collapse" for="c-40623767">[-]</label><label class="expand" for="c-40623767">[1 more]</label></div><br/><div class="children"><div class="content">A niche requirement? There are big accounting firms who organize payrolls, where the changes that you mentioned are an important part of their business.<p>There are also other companies, which do the typical snapshot and roll up to the current time, when they start the services, that need the data without having access to the database.</div><br/></div></div><div id="40628775" class="c"><input type="checkbox" id="c-40628775" checked=""/><div class="controls bullet"><span class="by">NomDePlum</span><span>|</span><a href="#40620095">root</a><span>|</span><a href="#40623081">parent</a><span>|</span><a href="#40623767">prev</a><span>|</span><a href="#40630830">next</a><span>|</span><label class="collapse" for="c-40628775">[-]</label><label class="expand" for="c-40628775">[1 more]</label></div><br/><div class="children"><div class="content">Depends what domain you work in. Auditability is a key&#x2F;mandatory requirement in a lot of regulated industries.<p>There are of course other ways to do auditability.<p>Event Sourcing + Projections provide a nice way to build multiple models&#x2F;views from the same dataset. This can provide a lot of simplification for client code.</div><br/></div></div></div></div><div id="40630830" class="c"><input type="checkbox" id="c-40630830" checked=""/><div class="controls bullet"><span class="by">pyrale</span><span>|</span><a href="#40620095">parent</a><span>|</span><a href="#40623081">prev</a><span>|</span><a href="#40621112">next</a><span>|</span><label class="collapse" for="c-40630830">[-]</label><label class="expand" for="c-40630830">[1 more]</label></div><br/><div class="children"><div class="content">&gt; now with events that are harder to trace than function calls<p>Same issue as microservices: there are people who want to use the paradigm but not do the investment in monitoring&#x2F;tooling.</div><br/></div></div><div id="40621112" class="c"><input type="checkbox" id="c-40621112" checked=""/><div class="controls bullet"><span class="by">trevor-e</span><span>|</span><a href="#40620095">parent</a><span>|</span><a href="#40630830">prev</a><span>|</span><a href="#40624214">next</a><span>|</span><label class="collapse" for="c-40621112">[-]</label><label class="expand" for="c-40621112">[6 more]</label></div><br/><div class="children"><div class="content">Like anything it can be abused and sometimes folks go overboard with turning everything into an event. However, when done right, it is really amazing to work with.<p>As an event producer as long as you follow reasonable backwards-compatibility best practices then you should be pretty safe from breaking things downstream. As a consumer, follow defensive programming and allow for idempotency in case you need to reprocess an event. Pretty straightforward once you get the hang of things.</div><br/><div id="40630356" class="c"><input type="checkbox" id="c-40630356" checked=""/><div class="controls bullet"><span class="by">majormajor</span><span>|</span><a href="#40620095">root</a><span>|</span><a href="#40621112">parent</a><span>|</span><a href="#40622529">next</a><span>|</span><label class="collapse" for="c-40630356">[-]</label><label class="expand" for="c-40630356">[3 more]</label></div><br/><div class="children"><div class="content">&gt; As an event producer as long as you follow reasonable backwards-compatibility best practices then you should be pretty safe from breaking things downstream.<p>That can protect you from &quot;downstream can&#x27;t even read the message anymore&quot; but it <i>doesn&#x27;t</i> help you with the much more common &quot;downstream isn&#x27;t doing the right thing with the message anymore&quot; problem. Schema evolution is kinda like schema&#x27;d RPC calls vs plain JSON: it will protect you from &quot;oops, we sent eventId instead of event_id&quot; type of errors, but won&#x27;t prevent you from making logical errors. In a larger org, this can turn into delayed-discovery nightmares.<p>A synchronous API call could give you back an error response and alert your immediately to something being wrong. The system notifies you directly.<p>A downstream event consumer may fail in ways entirely off of your team&#x27;s radar. The downstream team starts getting alerts. Whether or not those alerts make it immediately obvious to them that it&#x27;s your fault... that depends on a bunch of factors.</div><br/><div id="40630934" class="c"><input type="checkbox" id="c-40630934" checked=""/><div class="controls bullet"><span class="by">pyrale</span><span>|</span><a href="#40620095">root</a><span>|</span><a href="#40630356">parent</a><span>|</span><a href="#40622529">next</a><span>|</span><label class="collapse" for="c-40630934">[-]</label><label class="expand" for="c-40630934">[2 more]</label></div><br/><div class="children"><div class="content">Data consumers in unknown teams is a nightmare regardless of the architecture.<p>Events sent for readership you can’t control are ideally of the type «x changed», and the consumer must then fetch data on the relevant endpoint.<p>That or the company must have serious versioning policies.</div><br/><div id="40631402" class="c"><input type="checkbox" id="c-40631402" checked=""/><div class="controls bullet"><span class="by">mattacular</span><span>|</span><a href="#40620095">root</a><span>|</span><a href="#40630934">parent</a><span>|</span><a href="#40622529">next</a><span>|</span><label class="collapse" for="c-40631402">[-]</label><label class="expand" for="c-40631402">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the benefit of using an asynchronous event driven system if you can&#x27;t process any of those events without performing a synchronous query back on the same provider for all of the necessary data?</div><br/></div></div></div></div></div></div><div id="40622529" class="c"><input type="checkbox" id="c-40622529" checked=""/><div class="controls bullet"><span class="by">gnat</span><span>|</span><a href="#40620095">root</a><span>|</span><a href="#40621112">parent</a><span>|</span><a href="#40630356">prev</a><span>|</span><a href="#40624214">next</a><span>|</span><label class="collapse" for="c-40622529">[-]</label><label class="expand" for="c-40622529">[2 more]</label></div><br/><div class="children"><div class="content">Do you have pointers to such best practices? Gratefully received etc.</div><br/><div id="40622630" class="c"><input type="checkbox" id="c-40622630" checked=""/><div class="controls bullet"><span class="by">mvc</span><span>|</span><a href="#40620095">root</a><span>|</span><a href="#40622529">parent</a><span>|</span><a href="#40624214">next</a><span>|</span><label class="collapse" for="c-40622630">[-]</label><label class="expand" for="c-40622630">[1 more]</label></div><br/><div class="children"><div class="content">Rich Hickey&#x27;s talk about &quot;growth&quot; (as opposed to change) of software systems is a good one for this.<p>Tldr: ok to add things. Not ok to remove things or change things</div><br/></div></div></div></div></div></div><div id="40624214" class="c"><input type="checkbox" id="c-40624214" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40620095">parent</a><span>|</span><a href="#40621112">prev</a><span>|</span><a href="#40621825">next</a><span>|</span><label class="collapse" for="c-40624214">[-]</label><label class="expand" for="c-40624214">[7 more]</label></div><br/><div class="children"><div class="content">&gt; now with events that are harder to trace than function calls would have been<p>I don&#x27;t know how this could be true.  Events are <i>things</i> - nouns which can be backed-up, replicated, stored, queried, rendered, indexed and searched over.</div><br/><div id="40628590" class="c"><input type="checkbox" id="c-40628590" checked=""/><div class="controls bullet"><span class="by">sattoshi</span><span>|</span><a href="#40620095">root</a><span>|</span><a href="#40624214">parent</a><span>|</span><a href="#40629138">next</a><span>|</span><label class="collapse" for="c-40628590">[-]</label><label class="expand" for="c-40628590">[1 more]</label></div><br/><div class="children"><div class="content">How is it not true? Instead of tracking data and function calls over a unified stacktrace, you track Things and Messages over databases, queues, and logs —- none of which you can trivially attach a debugger to.<p>I generally like event-driven architecture, but I need to admit that debuggability is sacrificed where it matters most.</div><br/></div></div><div id="40629138" class="c"><input type="checkbox" id="c-40629138" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#40620095">root</a><span>|</span><a href="#40624214">parent</a><span>|</span><a href="#40628590">prev</a><span>|</span><a href="#40621825">next</a><span>|</span><label class="collapse" for="c-40629138">[-]</label><label class="expand" for="c-40629138">[5 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no &quot;find usages&quot; for events, and it becomes harder to find out why something <i>didn&#x27;t</i> happen. A function call can&#x27;t simply &quot;not return&quot; - in the worst case you get an exception, or a stuck thread in the caller that will show up in a stack dump. But downstream event processing can very easily just not happen, for one of many different reasons, and out-of-the-box it&#x27;s often difficult to investigate.</div><br/><div id="40631057" class="c"><input type="checkbox" id="c-40631057" checked=""/><div class="controls bullet"><span class="by">friendzis</span><span>|</span><a href="#40620095">root</a><span>|</span><a href="#40629138">parent</a><span>|</span><a href="#40629220">next</a><span>|</span><label class="collapse" for="c-40631057">[-]</label><label class="expand" for="c-40631057">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A function call can&#x27;t simply &quot;not return&quot;<p>Remember &quot;callback hell&quot;? Assumption that a function call returns after running to completion requires rather specific synchronous cascading architecture, which WILL break in multithreaded code. Most of the multithreaded function calls will set a flag in shared memory and return early, expecting caller to poll.<p>If your API is based on single entry-point `invokeMethod(callee, method)` it is equally untraceable to event entry point `fireEvent(producer, event)`.</div><br/></div></div><div id="40629220" class="c"><input type="checkbox" id="c-40629220" checked=""/><div class="controls bullet"><span class="by">soulofmischief</span><span>|</span><a href="#40620095">root</a><span>|</span><a href="#40629138">parent</a><span>|</span><a href="#40631057">prev</a><span>|</span><a href="#40621825">next</a><span>|</span><label class="collapse" for="c-40629220">[-]</label><label class="expand" for="c-40629220">[3 more]</label></div><br/><div class="children"><div class="content">In JavaScript,<p><pre><code>  const
    myEvent = &#x27;myEvent&#x27;, 
    target = new EventTarget()

  target.on( myEvent, () =&gt; {
    console.log( &quot;It&#x27;s easy to introspect well-organized code.&quot; )
  })

  target.dispatchEvent( new Event( myEvent ))</code></pre></div><br/><div id="40629298" class="c"><input type="checkbox" id="c-40629298" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#40620095">root</a><span>|</span><a href="#40629220">parent</a><span>|</span><a href="#40621825">next</a><span>|</span><label class="collapse" for="c-40629298">[-]</label><label class="expand" for="c-40629298">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, good luck remembering to do that up-front for every event handler. You missed one? Whoops, enjoy the information you wanted silently not being there when you need it.</div><br/><div id="40630506" class="c"><input type="checkbox" id="c-40630506" checked=""/><div class="controls bullet"><span class="by">soulofmischief</span><span>|</span><a href="#40620095">root</a><span>|</span><a href="#40629298">parent</a><span>|</span><a href="#40621825">next</a><span>|</span><label class="collapse" for="c-40630506">[-]</label><label class="expand" for="c-40630506">[1 more]</label></div><br/><div class="children"><div class="content">Remembering to do what? Properly maintain a list of constants and enums to use throughout my application?<p>That&#x27;s not something I have to remember or forget, it&#x27;s a simple habit that is as natural as importing and referencing a function.<p>As a general rule, numbers and string literals should never be hardcoded. Internalizing this should be a base expectation of any high-performing team member.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40621825" class="c"><input type="checkbox" id="c-40621825" checked=""/><div class="controls bullet"><span class="by">Osiris</span><span>|</span><a href="#40620095">parent</a><span>|</span><a href="#40624214">prev</a><span>|</span><a href="#40620302">next</a><span>|</span><label class="collapse" for="c-40621825">[-]</label><label class="expand" for="c-40621825">[3 more]</label></div><br/><div class="children"><div class="content">What I like about event driven is that you don&#x27;t even need to know if anyone is listening to or cares about your event.<p>And as a consumer, many independent tasks can be triggered by the same event.<p>I&#x27;m working on a system right now and because of events, it&#x27;s very easy for me to write a handler for when a certain type of record is created in the database. My feature depends on knowing that new record was made so we can send some emails and do other things.<p>The people that wrote the code that creates the record, didn&#x27;t have to do anything to support the feature.<p>But I agree that it&#x27;s not the right solution for every problem. But there are certain problems it solves really well.</div><br/><div id="40628496" class="c"><input type="checkbox" id="c-40628496" checked=""/><div class="controls bullet"><span class="by">zdragnar</span><span>|</span><a href="#40620095">root</a><span>|</span><a href="#40621825">parent</a><span>|</span><a href="#40620302">next</a><span>|</span><label class="collapse" for="c-40628496">[-]</label><label class="expand" for="c-40628496">[2 more]</label></div><br/><div class="children"><div class="content">&gt; you don&#x27;t even need to know if anyone is listening to or cares about your event.<p>Right up until you need to change something about the event because the business logic it represents has changed. Then you suddenly need to track down all the systems that have been relying on it, including that one that nobody knows anything about and always forgets exists because some guy decided to implement the service in erlang and nobody who ever touched it even works at the company anymore.</div><br/><div id="40631154" class="c"><input type="checkbox" id="c-40631154" checked=""/><div class="controls bullet"><span class="by">friendzis</span><span>|</span><a href="#40620095">root</a><span>|</span><a href="#40628496">parent</a><span>|</span><a href="#40620302">next</a><span>|</span><label class="collapse" for="c-40631154">[-]</label><label class="expand" for="c-40631154">[1 more]</label></div><br/><div class="children"><div class="content">I really dislike this argument, because it puts the duty of managing dependencies and requirements directly on code. This is organizational issue!<p>First, if your event (or whatever) changes enough that there are inter-component breakages it means engineering requirements must have changed and tracing dependencies of requirements is organizational thing.<p>Second, you either do trunk based development and constantly break downstream or do leaf based development and have constantly out of date core dependencies. In any case, that&#x27;s release version management, which is again organizational thing.</div><br/></div></div></div></div></div></div><div id="40620302" class="c"><input type="checkbox" id="c-40620302" checked=""/><div class="controls bullet"><span class="by">hobs</span><span>|</span><a href="#40620095">parent</a><span>|</span><a href="#40621825">prev</a><span>|</span><a href="#40620662">next</a><span>|</span><label class="collapse" for="c-40620302">[-]</label><label class="expand" for="c-40620302">[2 more]</label></div><br/><div class="children"><div class="content">I think generally a lot of these types of problems were actually had by folks who grew out of single node systems and had a lot of interesting ideas to solve problems that were new in those domains, GIVEN they&#x27;ve already solved the stateful domain problems as well.<p>When you&#x27;ve never grown out of a single node domain but you do event driven &quot;because scaling&quot; or whatever, you&#x27;ve shot yourself in the foot amazingly hard.</div><br/><div id="40622821" class="c"><input type="checkbox" id="c-40622821" checked=""/><div class="controls bullet"><span class="by">The_Colonel</span><span>|</span><a href="#40620095">root</a><span>|</span><a href="#40620302">parent</a><span>|</span><a href="#40620662">next</a><span>|</span><label class="collapse" for="c-40622821">[-]</label><label class="expand" for="c-40622821">[1 more]</label></div><br/><div class="children"><div class="content">Yes, events, async, eventual consistency, decoupling represent a difficult&#x2F;complex solution for some hard problems encountered when scaling high.<p>But people often forget there are trade-offs to everything and if you don&#x27;t have these hard problems, you&#x27;re giving yourself only headaches.<p>My pet-peeve is &quot;decoupling&quot; - it&#x27;s treated as holy with only benefits and no downsides. But it&#x27;s actually again a level of complexity - unless you need it, tightly coupled code will be easier to write, read, debug etc.</div><br/></div></div></div></div><div id="40620662" class="c"><input type="checkbox" id="c-40620662" checked=""/><div class="controls bullet"><span class="by">scubbo</span><span>|</span><a href="#40620095">parent</a><span>|</span><a href="#40620302">prev</a><span>|</span><a href="#40621293">next</a><span>|</span><label class="collapse" for="c-40620662">[-]</label><label class="expand" for="c-40620662">[1 more]</label></div><br/><div class="children"><div class="content">Amen. Event-driven architecture makes it easier to bury your head in the sand, and harder to implement an actually-working feature.</div><br/></div></div><div id="40621293" class="c"><input type="checkbox" id="c-40621293" checked=""/><div class="controls bullet"><span class="by">NicoJuicy</span><span>|</span><a href="#40620095">parent</a><span>|</span><a href="#40620662">prev</a><span>|</span><a href="#40620577">next</a><span>|</span><label class="collapse" for="c-40621293">[-]</label><label class="expand" for="c-40621293">[1 more]</label></div><br/><div class="children"><div class="content">And that&#x27;s why a SAGA describes that flow.<p>Don&#x27;t take it into consideration and you&#x27;re fucked.<p>Source: previous &quot;seniors&quot; didn&#x27;t take it into consideration, they left</div><br/></div></div><div id="40620577" class="c"><input type="checkbox" id="c-40620577" checked=""/><div class="controls bullet"><span class="by">moandcompany</span><span>|</span><a href="#40620095">parent</a><span>|</span><a href="#40621293">prev</a><span>|</span><a href="#40620351">next</a><span>|</span><label class="collapse" for="c-40620577">[-]</label><label class="expand" for="c-40620577">[2 more]</label></div><br/><div class="children"><div class="content">Integration tests?</div><br/><div id="40621017" class="c"><input type="checkbox" id="c-40621017" checked=""/><div class="controls bullet"><span class="by">worik</span><span>|</span><a href="#40620095">root</a><span>|</span><a href="#40620577">parent</a><span>|</span><a href="#40620351">next</a><span>|</span><label class="collapse" for="c-40621017">[-]</label><label class="expand" for="c-40621017">[1 more]</label></div><br/><div class="children"><div class="content">...happen too late</div><br/></div></div></div></div></div></div><div id="40620351" class="c"><input type="checkbox" id="c-40620351" checked=""/><div class="controls bullet"><span class="by">pudwallabee</span><span>|</span><a href="#40620095">prev</a><span>|</span><a href="#40619970">next</a><span>|</span><label class="collapse" for="c-40620351">[-]</label><label class="expand" for="c-40620351">[9 more]</label></div><br/><div class="children"><div class="content">I have seen Kafka pulled out by its hairs and replaced with request based architecture.<p>Event driven architecture, to me is itself an antipattern.<p>It seems like a replacement for batch processing.  Replayable messages are AWESOME.  Until you encounter the complexity for a system to actually replay them consistently.<p>As far as the authors video, while there was some truth in there, it was a little thin, compared to the complexity of these architectures.  I believe that even though Kafka acts the part of &quot;dumb pipe&quot;, it doesnt stay dumb for long, and the n distributions of Kafka logs in your organization could be 1000x more expensive than a monolithic DB and a monolithic API to maintain.<p>Yes it appears auditable but is it?  The big argument for replayability is that unlike an API that falls over theres no data loss.  If you work with Kafka long enough you’ll realize that data loss will become a problem you didnt think you had.  You’ll have to hire people to “look into” data loss problems constantly with Kafka.  Its just too much infrastructure to even care about.<p>Theres also, something ergonomically wrong with event drive architecture.  People dont like it.  And it also turns people into robots who are “not responsible” for their product. Theres so much infrastructure to maintain that people just punt everything back to the “enterprise kafka team”.<p>The whole point of microservices was to enable flexibility, smart services and dumb pipes, and effective CI&#x2F;CD and devops.<p>We are nearing the end of microservices adoption whether it be event or request driven.  In mature organizations it seems to me that request driven is winning by a large margin over event driven.<p>It may be counterintuitive, but the time to market of request driven architecture and cost to maintain is way way lower.</div><br/><div id="40631124" class="c"><input type="checkbox" id="c-40631124" checked=""/><div class="controls bullet"><span class="by">buster</span><span>|</span><a href="#40620351">parent</a><span>|</span><a href="#40630401">next</a><span>|</span><label class="collapse" for="c-40631124">[-]</label><label class="expand" for="c-40631124">[1 more]</label></div><br/><div class="children"><div class="content">I think the problem here is Kafka and not event driven architecture.
I am a strong proponent of not using Kafka for events. It&#x27;s wrong 90% of the time and for the other 10% you can find better solutions.<p>Also, people need to understand that &quot;event driven&quot; has <i>nothing</i> to do with &quot;event sourcing&quot;. Just don&#x27;t keep all the events until eternity, because you can (and because some people think you should because &quot;kafka&quot;).</div><br/></div></div><div id="40630401" class="c"><input type="checkbox" id="c-40630401" checked=""/><div class="controls bullet"><span class="by">majormajor</span><span>|</span><a href="#40620351">parent</a><span>|</span><a href="#40631124">prev</a><span>|</span><a href="#40629229">next</a><span>|</span><label class="collapse" for="c-40630401">[-]</label><label class="expand" for="c-40630401">[2 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t run into weird Kafka data loss issues like you describe - although, I will note, a lot of applications <i>don&#x27;t actually have much testing to notice something like 1 in 10k messages being dropped</i> if it was happening.[0]<p>But when I&#x27;ve done that testing, Kafka hasn&#x27;t been the problem.<p>The problem I&#x27;ve run into most is that ordering is a giant fucking pain in the ass if you actually want consistent replayability and don&#x27;t have trivial partitioning needs. Some consumers want things in order by customer ID, other consumers want things in order by sold product ID, others by invoice ID? Uh oh. If you&#x27;re thinking you could easily replay to debug, the size and scope of the data you have to process for some of those cases just exploded. Or you wrote N times, once for each of those, and then hopefully your multi-write transaction implementation was perfect!<p>[0] in fairness, a lot of applications also don&#x27;t guarantee that they never drop requests at all, obviously. 500 and retry and hope that you don&#x27;t run out of retries very often; if you do, it&#x27;s just dropped on the ground and it&#x27;s considered acceptable loss to have some of that for most companies&#x2F;applications.</div><br/></div></div><div id="40629229" class="c"><input type="checkbox" id="c-40629229" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#40620351">parent</a><span>|</span><a href="#40630401">prev</a><span>|</span><a href="#40621690">next</a><span>|</span><label class="collapse" for="c-40629229">[-]</label><label class="expand" for="c-40629229">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I believe that even though Kafka acts the part of &quot;dumb pipe&quot;, it doesnt stay dumb for long<p>In my experience programmers are very happy to do everything in the application (something database people often complain about). What kind of problems do you see?<p>&gt; If you work with Kafka long enough you’ll realize that data loss will become a problem you didnt think you had. You’ll have to hire people to “look into” data loss problems constantly with Kafka.<p>Not my experience at all, and I&#x27;ve used Kafka at a wide range of companies, from household-name scale to startups. Kafka is the boring just-works technology that everyone claims they&#x27;re looking for.<p>I&#x27;m no fan of microservices, but Kafka is absolutely the right datastore most of the time.</div><br/></div></div><div id="40621690" class="c"><input type="checkbox" id="c-40621690" checked=""/><div class="controls bullet"><span class="by">smrtinsert</span><span>|</span><a href="#40620351">parent</a><span>|</span><a href="#40629229">prev</a><span>|</span><a href="#40627286">next</a><span>|</span><label class="collapse" for="c-40621690">[-]</label><label class="expand" for="c-40621690">[2 more]</label></div><br/><div class="children"><div class="content">&gt; and the n distributions of Kafka logs in your organization could be 1000x more expensive than a monolithic DB and a monolithic API to maintain<p>Not to mention certain observability vendors bleeding you for all those logs you now need to keep an eye on it.<p>Absolutely agreed on every point</div><br/><div id="40630221" class="c"><input type="checkbox" id="c-40630221" checked=""/><div class="controls bullet"><span class="by">RHSman2</span><span>|</span><a href="#40620351">root</a><span>|</span><a href="#40621690">parent</a><span>|</span><a href="#40627286">next</a><span>|</span><label class="collapse" for="c-40630221">[-]</label><label class="expand" for="c-40630221">[1 more]</label></div><br/><div class="children"><div class="content">The unseen critical part of the equation</div><br/></div></div></div></div><div id="40627286" class="c"><input type="checkbox" id="c-40627286" checked=""/><div class="controls bullet"><span class="by">therealdrag0</span><span>|</span><a href="#40620351">parent</a><span>|</span><a href="#40621690">prev</a><span>|</span><a href="#40619970">next</a><span>|</span><label class="collapse" for="c-40627286">[-]</label><label class="expand" for="c-40627286">[2 more]</label></div><br/><div class="children"><div class="content">What are the causes of data loss?</div><br/><div id="40627513" class="c"><input type="checkbox" id="c-40627513" checked=""/><div class="controls bullet"><span class="by">pudwallabee</span><span>|</span><a href="#40620351">root</a><span>|</span><a href="#40627286">parent</a><span>|</span><a href="#40619970">next</a><span>|</span><label class="collapse" for="c-40627513">[-]</label><label class="expand" for="c-40627513">[1 more]</label></div><br/><div class="children"><div class="content">I dunno ask the “enterprise kafka team”.</div><br/></div></div></div></div></div></div><div id="40619970" class="c"><input type="checkbox" id="c-40619970" checked=""/><div class="controls bullet"><span class="by">candiddevmike</span><span>|</span><a href="#40620351">prev</a><span>|</span><a href="#40631234">next</a><span>|</span><label class="collapse" for="c-40619970">[-]</label><label class="expand" for="c-40619970">[53 more]</label></div><br/><div class="children"><div class="content">Can someone share some long term event driven success stories?  Almost everything you see online is written by consultants or brand new, greenfield implementations, curious how long these systems last.</div><br/><div id="40620580" class="c"><input type="checkbox" id="c-40620580" checked=""/><div class="controls bullet"><span class="by">ninkendo</span><span>|</span><a href="#40619970">parent</a><span>|</span><a href="#40620332">next</a><span>|</span><label class="collapse" for="c-40620580">[-]</label><label class="expand" for="c-40620580">[4 more]</label></div><br/><div class="children"><div class="content">Chiming in with another “no” here. We adopted a message bus&#x2F;event-driven architecture when moving a very popular piece of software from the cloud, to directly on the user’s device… it was a disaster IMO.<p>The core orchestration of the system was done via events on the bus, and nobody had any idea what was happening when a bug occurred. People would pass bugs around, “my code did the right thing given the event it got”, “well, my code did the right thing too”, and nobody understood the full picture because everyone was stuck in their own silo. Event driven architectures encourage this: events decouple systems such that you don’t know or care what happens when you emit a message, until one day it’s emitted with slightly different timing or ordering or different semantics, and things are broken and nobody knows why.<p>The worst part is that software is basically “take user input, do process A on it, then do process B on that, then do process C on that.” It could have <i>so easily</i> been a simple imperative function that called C(B(A(input))), but instead we made events for “inputWasEmitted”, “Aoutput”, “Boutput”, etc.<p>What happens when system C needs one more piece of metadata about the user input? 3 PR’s into 3 repos to plumb the information around. Coordinating the release of 3 libraries. All around just awful to work with.<p>Oh and this is a <i>very high profile</i> piece of software with a user base in the 9 figure range.<p>(Wild tangent: holy <i>shit</i> is hard to get iOS to accept “do process” in a sentence. I edited that paragraph at least 30 times, no joke, trying every trick I could to stop it correcting it to “due process”. I almost gave up. I used to defend autocorrect but holy shit that was a nightmare.)</div><br/><div id="40620841" class="c"><input type="checkbox" id="c-40620841" checked=""/><div class="controls bullet"><span class="by">tadfisher</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40620580">parent</a><span>|</span><a href="#40631028">next</a><span>|</span><label class="collapse" for="c-40620841">[-]</label><label class="expand" for="c-40620841">[2 more]</label></div><br/><div class="children"><div class="content">I think the true term for this phenomenon is &quot;decoherence&quot; rather than &quot;decoupling&quot;. Your components are still as coupled as they ever were, but the coupling has moved from compile-time (e.g. function calls) to runtime. The component that &quot;handles events&quot; decoheres the entire system because it&#x27;s now responsible for the entire messaging layer between components, rather than the individual components being responsible for their slice of the system.</div><br/><div id="40630020" class="c"><input type="checkbox" id="c-40630020" checked=""/><div class="controls bullet"><span class="by">jesse__</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40620841">parent</a><span>|</span><a href="#40631028">next</a><span>|</span><label class="collapse" for="c-40630020">[-]</label><label class="expand" for="c-40630020">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a great name for that property.  I&#x27;ve always cringed when people say &#x27;something something decoupling&#x27; because most of the time the end result is actually just as coupled, but ends up indirected or something.  Now I have a more specific word for it, thanks!!</div><br/></div></div></div></div><div id="40631028" class="c"><input type="checkbox" id="c-40631028" checked=""/><div class="controls bullet"><span class="by">setr</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40620580">parent</a><span>|</span><a href="#40620841">prev</a><span>|</span><a href="#40620332">next</a><span>|</span><label class="collapse" for="c-40631028">[-]</label><label class="expand" for="c-40631028">[1 more]</label></div><br/><div class="children"><div class="content">&gt; (Wild tangent: holy shit is hard to get iOS to accept “do process” in a sentence. I edited that paragraph at least 30 times, no joke, trying every trick I could to stop it correcting it to “due process”. I almost gave up. I used to defend autocorrect but holy shit that was a nightmare.)<p>can you not just pick the original spelling in the autocomplete menu above the keyboard?</div><br/></div></div></div></div><div id="40620332" class="c"><input type="checkbox" id="c-40620332" checked=""/><div class="controls bullet"><span class="by">Salgat</span><span>|</span><a href="#40619970">parent</a><span>|</span><a href="#40620580">prev</a><span>|</span><a href="#40630924">next</a><span>|</span><label class="collapse" for="c-40620332">[-]</label><label class="expand" for="c-40620332">[9 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.eventstore.com&#x2F;case-studies&#x2F;insureon" rel="nofollow">https:&#x2F;&#x2F;www.eventstore.com&#x2F;case-studies&#x2F;insureon</a><p>I can attest to this case study being 100% true. Our platform has been using EventStore as our primary database for 9 years going strong, and I&#x27;m still very happy with it. The key thing is that it needs to be done right from the very beginning; you can&#x27;t do major architecture reworks later on and you need an architect who really knows what they&#x27;re doing. Also, you can&#x27;t half-ass it; event sourcing, CQRS, etc all had to embraced the entire time, no shortcuts.<p>I will say though, the biggest downside is that scaling is difficult since you can&#x27;t always rely on snapshots of data, sometimes you need to event source the entire model and that can get data heavy. If you&#x27;re standing up a new projector, you could be going through tens of millions of events before it is caught up which requires planning. It is incredible though being able to have every single state change ever made on the platform available, the data guys love it and it makes troubleshooting way easier since there&#x27;s no secrets on what happened. The biggest con is that most people don&#x27;t really understand it intuitively, since it&#x27;s a very different way of doing things, which is why so many companies end up fucking it up.</div><br/><div id="40626697" class="c"><input type="checkbox" id="c-40626697" checked=""/><div class="controls bullet"><span class="by">therealdrag0</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40620332">parent</a><span>|</span><a href="#40620514">next</a><span>|</span><label class="collapse" for="c-40626697">[-]</label><label class="expand" for="c-40626697">[3 more]</label></div><br/><div class="children"><div class="content">Note that event sourced data and event based architecture are different things. You can have one without the other.</div><br/><div id="40627024" class="c"><input type="checkbox" id="c-40627024" checked=""/><div class="controls bullet"><span class="by">Salgat</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40626697">parent</a><span>|</span><a href="#40620514">next</a><span>|</span><label class="collapse" for="c-40627024">[-]</label><label class="expand" for="c-40627024">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a type of event driven architecture, since events generated both hydrate models and trigger event listeners&#x2F;subscribers. For example, a command to update a customer&#x27;s address might also have a process manager listening for that event that kicks off a process to send an email notification. That same event is still used to event source the customer model which includes an address.<p>I suppose you could have event sourcing in a purely isolated manner where the events aren&#x27;t used for anything else, but you&#x27;d be severely limiting the advantages that come free with that.</div><br/><div id="40627461" class="c"><input type="checkbox" id="c-40627461" checked=""/><div class="controls bullet"><span class="by">therealdrag0</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40627024">parent</a><span>|</span><a href="#40620514">next</a><span>|</span><label class="collapse" for="c-40627461">[-]</label><label class="expand" for="c-40627461">[1 more]</label></div><br/><div class="children"><div class="content">That’s what I mean. I worked on services that have event sourced db model but synchronous REST API. And I’ve worked on services that communicate with events for IPC but use relational sql for data store.<p>Your example uses the same events for both so sure that can be done but doesn’t have to. I haven’t worked on a system like that personally so maybe it can fine.<p>But honestly I’m a bit skeptical since that removes services’ data sovereignty. Sounds like the recipe for “distributed monolith” architecture. And actually I just remembered another team at my company is ripping out their use of kafka as their data source on a green field project cuz it was a disaster, so skepticism emphasized.</div><br/></div></div></div></div></div></div><div id="40620514" class="c"><input type="checkbox" id="c-40620514" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40620332">parent</a><span>|</span><a href="#40626697">prev</a><span>|</span><a href="#40630924">next</a><span>|</span><label class="collapse" for="c-40620514">[-]</label><label class="expand" for="c-40620514">[5 more]</label></div><br/><div class="children"><div class="content">Am I dumb or is this basically the binlog of your database but without the tooling to let you do efficient querying?<p>Like I get the &quot;message bus&quot; architecture when you have a bunch of services emitting events and consumers for differing purposes but I don&#x27;t think I would feel comfortable using it for state tracking. Especially when it seems really hard to enforce a schema &#x2F; do migrations. CQRS also makes sense for this but only when it functions as a WAL and isn&#x27;t meant to be stored forever but persisted by everyone who&#x27;s interested in it and then eventually discarded.</div><br/><div id="40629276" class="c"><input type="checkbox" id="c-40629276" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40620514">parent</a><span>|</span><a href="#40620677">next</a><span>|</span><label class="collapse" for="c-40629276">[-]</label><label class="expand" for="c-40629276">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Am I dumb or is this basically the binlog of your database but without the tooling to let you do efficient querying?<p>Yes, and I honestly think a traditional database that exposed this stuff would be a winner (but I guess it&#x27;s too hard, and meanwhile event-sourcing frameworks are building better alternatives). Separating the low-level part from the high-level part that does things like indexing and querying has a lot of advantages: you decouple data storage from validation so you can have validated data without having to drop invalid data on the floor, you decouple index updates from data writes so your scaling problems get way simpler, you can get sensible happens-before semantics without needing transactions that can deadlock and all the crazy stuff that traditional databases do (secret MVCC implementations while the database goes out of its way to present an illusion of a single &quot;current&quot; version of the data, snapshotting that you can&#x27;t access directly, ...).</div><br/></div></div><div id="40620677" class="c"><input type="checkbox" id="c-40620677" checked=""/><div class="controls bullet"><span class="by">ffsm8</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40620514">parent</a><span>|</span><a href="#40629276">prev</a><span>|</span><a href="#40620850">next</a><span>|</span><label class="collapse" for="c-40620677">[-]</label><label class="expand" for="c-40620677">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Especially when it seems really hard to enforce a schema &#x2F; do migrations</i><p>Enforcing the schema isn&#x27;t too hard ime. But every migration needs to be bi-directionally compatible. That&#x27;s likely what they meant with &quot;you need an architect and can&#x27;t make major changes later on&quot;<p>It&#x27;s the same issue you&#x27;ve had with nosql, even though you technically do have a schema</div><br/></div></div><div id="40620850" class="c"><input type="checkbox" id="c-40620850" checked=""/><div class="controls bullet"><span class="by">_3u10</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40620514">parent</a><span>|</span><a href="#40620677">prev</a><span>|</span><a href="#40630924">next</a><span>|</span><label class="collapse" for="c-40620850">[-]</label><label class="expand" for="c-40620850">[2 more]</label></div><br/><div class="children"><div class="content">Pretty much. Also all your projectors need to be deterministic.<p>eg. Your commands have to ALWAYS do the same thing else replaying the event log does not produce the same output and then you’re back to square one.<p>It’s usually easier &#x2F; more useful to just use an audit table.</div><br/><div id="40623277" class="c"><input type="checkbox" id="c-40623277" checked=""/><div class="controls bullet"><span class="by">blowski</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40620850">parent</a><span>|</span><a href="#40630924">next</a><span>|</span><label class="collapse" for="c-40623277">[-]</label><label class="expand" for="c-40623277">[1 more]</label></div><br/><div class="children"><div class="content">Yes, if version 1.3 of Command handler X was the active version when an event happened, then it needs to be replayed with that version, even if you’re now on v4.5.</div><br/></div></div></div></div></div></div></div></div><div id="40630924" class="c"><input type="checkbox" id="c-40630924" checked=""/><div class="controls bullet"><span class="by">lz400</span><span>|</span><a href="#40619970">parent</a><span>|</span><a href="#40620332">prev</a><span>|</span><a href="#40631306">next</a><span>|</span><label class="collapse" for="c-40630924">[-]</label><label class="expand" for="c-40630924">[1 more]</label></div><br/><div class="children"><div class="content">AFAIK almost every stock market order processing system is event driven, and they are all usually very old systems that have been successfully running for years. I&#x27;ve seen some implementation in investment banks, what you&#x27;re usually told is that most exchanges and banks run similar architectures. The reason for this is partially that FIX, the protocol for electronic orders in markets is event based.</div><br/></div></div><div id="40631306" class="c"><input type="checkbox" id="c-40631306" checked=""/><div class="controls bullet"><span class="by">liampulles</span><span>|</span><a href="#40619970">parent</a><span>|</span><a href="#40630924">prev</a><span>|</span><a href="#40620042">next</a><span>|</span><label class="collapse" for="c-40631306">[-]</label><label class="expand" for="c-40631306">[1 more]</label></div><br/><div class="children"><div class="content">Our system is command driven, and works well, but it is because we explicitly have less rigorous demands on the messages and the messages don&#x27;t cross team boundaries. My past experience also makes me wary of event driven systems.</div><br/></div></div><div id="40620042" class="c"><input type="checkbox" id="c-40620042" checked=""/><div class="controls bullet"><span class="by">blowski</span><span>|</span><a href="#40619970">parent</a><span>|</span><a href="#40631306">prev</a><span>|</span><a href="#40622705">next</a><span>|</span><label class="collapse" for="c-40620042">[-]</label><label class="expand" for="c-40620042">[3 more]</label></div><br/><div class="children"><div class="content">I was the lead developer on one for an insurance company a few years back, and it’s still in active use. Insurance is a heavily regulated domain, where an audit trail is more important than performance. There was a natural pattern for it to follow, as we were mapping a stable industry standard.<p>I also tried doing it in a property setting, where profit margins were tight. The effort needed wasn’t worth the cost, and clients didn’t really care about the value proposition anyway. We pretty much replaced the whole layer with a more traditional crud system.</div><br/><div id="40630372" class="c"><input type="checkbox" id="c-40630372" checked=""/><div class="controls bullet"><span class="by">chenster</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40620042">parent</a><span>|</span><a href="#40622705">next</a><span>|</span><label class="collapse" for="c-40630372">[-]</label><label class="expand" for="c-40630372">[2 more]</label></div><br/><div class="children"><div class="content">What did you mean traditional crud as oppose to event-driven arch? How is it relevant to the subject in dicussion?</div><br/><div id="40631498" class="c"><input type="checkbox" id="c-40631498" checked=""/><div class="controls bullet"><span class="by">blowski</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40630372">parent</a><span>|</span><a href="#40622705">next</a><span>|</span><label class="collapse" for="c-40631498">[-]</label><label class="expand" for="c-40631498">[1 more]</label></div><br/><div class="children"><div class="content">Event-driven: At runtime, the client tells the system what has happened, the system stores the event and is configured in advance for how to react to it.<p>CRUD: Imperative. Client tells us to create&#x2F;update a specific entity with some data.</div><br/></div></div></div></div></div></div><div id="40622705" class="c"><input type="checkbox" id="c-40622705" checked=""/><div class="controls bullet"><span class="by">rswail</span><span>|</span><a href="#40619970">parent</a><span>|</span><a href="#40620042">prev</a><span>|</span><a href="#40620186">next</a><span>|</span><label class="collapse" for="c-40622705">[-]</label><label class="expand" for="c-40622705">[3 more]</label></div><br/><div class="children"><div class="content">Wrote a public transport ticketing system that processes 100-200K+ trips&#x2F;day with sub-second push of notification to mobiles of trip&#x2F;payments.<p>Event driven and CQRS &quot;entities&quot; made logic and processing much easier to create&#x2F;test&#x2F;debug.<p>Primary issues:
1. Making sure you focus on the &quot;Nouns&quot; (entities) not the &quot;Verbs&quot;.
2. Kafka requiring polling for consumers sucks if you want to &quot;scale to zero&quot;.
3. Sharding of event consumers can be complicated.
4. People have trouble understanding the concepts and keep wanting to write &quot;ProcessX&quot; type functions instead of state machines and event handlers.
5. Retry&#x2F;replay is complicated, better to reverse&#x2F;replay. Dealing with side effects in replay is also complicated (does a replay generate the output events which trigger state changes in other entities?)<p>Been running now for 6 years, minimal downtime except for maintenance&#x2F;upgrades.<p>In the process of introducing major new entity and associated changes, most of the system unaffected due to the decoupling.</div><br/><div id="40630385" class="c"><input type="checkbox" id="c-40630385" checked=""/><div class="controls bullet"><span class="by">chenster</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40622705">parent</a><span>|</span><a href="#40620186">next</a><span>|</span><label class="collapse" for="c-40630385">[-]</label><label class="expand" for="c-40630385">[2 more]</label></div><br/><div class="children"><div class="content">Can you elaborate #1 Nouns over Vers?</div><br/><div id="40630712" class="c"><input type="checkbox" id="c-40630712" checked=""/><div class="controls bullet"><span class="by">rswail</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40630385">parent</a><span>|</span><a href="#40620186">next</a><span>|</span><label class="collapse" for="c-40630712">[-]</label><label class="expand" for="c-40630712">[1 more]</label></div><br/><div class="children"><div class="content">A lot of people focus on the process instead of the participating entities.<p>The focus when designing the system should be on the entities (Customer, Payment, Bill, Order, Inventory) instead of the processes (ordering, billing, fulfillment). I summarize that by saying &quot;Nouns over Verbs&quot;.<p>The state of each of the entities is affected by the processes, but the effect happens from changes in other entities, Customers place an Order. Customers get a Bill for the Order, Customers make a Payment, etc.<p>The states of each of these entities is independent of the others and reacts&#x2F;changes <i>only</i> as a result of two things, either an external &quot;Command&quot;, or an &quot;Event&quot;.<p>Commands are events that occur outside of the system boundary, usually visible as part of an API (if RESTful) that uses POST&#x2F;PUT&#x2F;DELETE or they are imperatives from one entity to another.<p>Commands are imperatives, Place Order, Pay Bill, Fulfill Order, etc.<p>Events are records of occurrences in the system, expressed in the past tense and are immutable. Order Placed, Bill Paid, Order Fulfilled.<p>Customers place an Order by POSTing to &#x2F;orders (or potentially &#x2F;customers&#x2F;uuid&#x2F;orders).<p>Events are generated from entities inside the system. (Order being placed generates an order_placed event).<p>The difference is that by focussing on the entities, and their state, independent of other entities, the entities can be created, tested, installed, evolved independently of other entities in the system.<p>The thinking about them is simplified and focussed, they are naturally decoupled because they can only find out about other entities by inquiring or affect other entities by generating a Command or an Event.<p>Any events they generate are processed asynchronously and can have multiple consumers.</div><br/></div></div></div></div></div></div><div id="40620186" class="c"><input type="checkbox" id="c-40620186" checked=""/><div class="controls bullet"><span class="by">devdude1337</span><span>|</span><a href="#40619970">parent</a><span>|</span><a href="#40622705">prev</a><span>|</span><a href="#40620702">next</a><span>|</span><label class="collapse" for="c-40620186">[-]</label><label class="expand" for="c-40620186">[1 more]</label></div><br/><div class="children"><div class="content">When I did game dev I often went for an even driven approach or messaging based systems combined with oop and state machines to prevent eventual consistency locally.
It works great in that domain, albeit not being the most performant solution.<p>In web or business systems it works well for some(!) parts. You just shouldn’t do everything that way - but often people get too exited about a solution and then they tend to overdo it and apply it everywhere, even when not appropriate.<p>Always chose the golden middle path and apply patterns where they fit well.</div><br/></div></div><div id="40620702" class="c"><input type="checkbox" id="c-40620702" checked=""/><div class="controls bullet"><span class="by">cweld510</span><span>|</span><a href="#40619970">parent</a><span>|</span><a href="#40620186">prev</a><span>|</span><a href="#40620012">next</a><span>|</span><label class="collapse" for="c-40620702">[-]</label><label class="expand" for="c-40620702">[1 more]</label></div><br/><div class="children"><div class="content">I work on an event-based architecture that I think is successful, but that’s because our core primitives are event-based, so there is no impedance mismatch in the way that there can be if you migrate from a request-response architecture to an evented one. Specifically, we aren’t trying to deal with databases and HTTP (both of which are largely synchronous primitives). Instead, I work on a platform for somewhat arbitrary code execution; and the code we are executing depends on our code rather than vice versa. In general, the code we execute on the platform can run for an indeterminate amount of time, and it generally has control and calls back into our code rather than our code calling into it. So our control flow is naturally callback-based rather than request&#x2F;response; as a result, our system is fundamentally event-based.</div><br/></div></div><div id="40620012" class="c"><input type="checkbox" id="c-40620012" checked=""/><div class="controls bullet"><span class="by">cjk2</span><span>|</span><a href="#40619970">parent</a><span>|</span><a href="#40620702">prev</a><span>|</span><a href="#40620347">next</a><span>|</span><label class="collapse" for="c-40620012">[-]</label><label class="expand" for="c-40620012">[8 more]</label></div><br/><div class="children"><div class="content">No. We have a complete fucking disaster on our hands.</div><br/><div id="40620019" class="c"><input type="checkbox" id="c-40620019" checked=""/><div class="controls bullet"><span class="by">macintux</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40620012">parent</a><span>|</span><a href="#40620347">next</a><span>|</span><label class="collapse" for="c-40620019">[-]</label><label class="expand" for="c-40620019">[7 more]</label></div><br/><div class="children"><div class="content">How old of a system? Do you feel it’s the implementation, the design, or the concept itself that went wrong? Is your system a good fit?<p>(No stake in this one way or another, just curious.)</div><br/><div id="40620027" class="c"><input type="checkbox" id="c-40620027" checked=""/><div class="controls bullet"><span class="by">cjk2</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40620019">parent</a><span>|</span><a href="#40620347">next</a><span>|</span><label class="collapse" for="c-40620027">[-]</label><label class="expand" for="c-40620027">[6 more]</label></div><br/><div class="children"><div class="content">Less than 5 years. Vanity project. Built and maintained by astronaut architects. Entirely unnecessary. Poorly implemented down to the level of wire contracts being inconsistent. Overheads are insane both from engineering and operational POV.</div><br/><div id="40620143" class="c"><input type="checkbox" id="c-40620143" checked=""/><div class="controls bullet"><span class="by">moandcompany</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40620027">parent</a><span>|</span><a href="#40620347">next</a><span>|</span><label class="collapse" for="c-40620143">[-]</label><label class="expand" for="c-40620143">[5 more]</label></div><br/><div class="children"><div class="content">Resume driven development never goes out of style</div><br/><div id="40620473" class="c"><input type="checkbox" id="c-40620473" checked=""/><div class="controls bullet"><span class="by">cjk2</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40620143">parent</a><span>|</span><a href="#40620176">next</a><span>|</span><label class="collapse" for="c-40620473">[-]</label><label class="expand" for="c-40620473">[3 more]</label></div><br/><div class="children"><div class="content">I call this one FDD: Fuckwit Driven Development. Because if it was resume-driven I&#x27;d expect it to be something that they would want to put on their resume. But this is unmentionable.</div><br/><div id="40620569" class="c"><input type="checkbox" id="c-40620569" checked=""/><div class="controls bullet"><span class="by">moandcompany</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40620473">parent</a><span>|</span><a href="#40620176">next</a><span>|</span><label class="collapse" for="c-40620569">[-]</label><label class="expand" for="c-40620569">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s sayings along the lines of &quot;Victory&#x2F;success has a thousand fathers, but defeat&#x2F;failure is an orphan.&quot;<p>Chances are that system, and its outcomes are described very differently on a resume</div><br/><div id="40630159" class="c"><input type="checkbox" id="c-40630159" checked=""/><div class="controls bullet"><span class="by">OccamsMirror</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40620569">parent</a><span>|</span><a href="#40620176">next</a><span>|</span><label class="collapse" for="c-40630159">[-]</label><label class="expand" for="c-40630159">[1 more]</label></div><br/><div class="children"><div class="content">As long as the list of technologies used is impressive sounding you&#x27;re on to a winner.</div><br/></div></div></div></div></div></div><div id="40620176" class="c"><input type="checkbox" id="c-40620176" checked=""/><div class="controls bullet"><span class="by">analognoise</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40620143">parent</a><span>|</span><a href="#40620473">prev</a><span>|</span><a href="#40620347">next</a><span>|</span><label class="collapse" for="c-40620176">[-]</label><label class="expand" for="c-40620176">[1 more]</label></div><br/><div class="children"><div class="content">Hail, RDD, my favorite development style.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40620347" class="c"><input type="checkbox" id="c-40620347" checked=""/><div class="controls bullet"><span class="by">vmaurin</span><span>|</span><a href="#40619970">parent</a><span>|</span><a href="#40620012">prev</a><span>|</span><a href="#40620350">next</a><span>|</span><label class="collapse" for="c-40620347">[-]</label><label class="expand" for="c-40620347">[1 more]</label></div><br/><div class="children"><div class="content">I have been doing this kind of stuff both in ad tech and trust &amp; safety industry, mainly to handle scalability. Something that looks like &quot;Event-carried state transfer&quot; here <a href="https:&#x2F;&#x2F;martinfowler.com&#x2F;articles&#x2F;201701-event-driven.html" rel="nofollow">https:&#x2F;&#x2F;martinfowler.com&#x2F;articles&#x2F;201701-event-driven.html</a><p>These system are working fine, but maybe a common ground :
* very few services
* the main throughput is &quot;fact&quot; events (so something that did happen)
* what you get as &quot;Event carried state transfer&quot; is basically the configuration. One service own it, with a classical DB and a UI, but then expose configuration to all the system with this kind of event (and all the consumers consume these read only)
* usually you have to deal with eventual consistency a lot in this kind of setup (so it scales well, but there is a tradeoff)</div><br/></div></div><div id="40620350" class="c"><input type="checkbox" id="c-40620350" checked=""/><div class="controls bullet"><span class="by">jgraettinger1</span><span>|</span><a href="#40619970">parent</a><span>|</span><a href="#40620347">prev</a><span>|</span><a href="#40620612">next</a><span>|</span><label class="collapse" for="c-40620350">[-]</label><label class="expand" for="c-40620350">[5 more]</label></div><br/><div class="children"><div class="content">PostgreSQL.<p>The WAL is an event log, and when you squint at its internal architecture, you’ll see plenty of overlap with distributed event sourcing.</div><br/><div id="40620597" class="c"><input type="checkbox" id="c-40620597" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40620350">parent</a><span>|</span><a href="#40621131">next</a><span>|</span><label class="collapse" for="c-40620597">[-]</label><label class="expand" for="c-40620597">[1 more]</label></div><br/><div class="children"><div class="content">Likewise with git.  There&#x27;s the &quot;top-level events&quot; that you see (commits).  But even when you&#x27;re doing &#x27;unsafe&#x27; operations, you&#x27;re working with the lower-level reflog events.</div><br/></div></div><div id="40621131" class="c"><input type="checkbox" id="c-40621131" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40620350">parent</a><span>|</span><a href="#40620597">prev</a><span>|</span><a href="#40629286">next</a><span>|</span><label class="collapse" for="c-40621131">[-]</label><label class="expand" for="c-40621131">[2 more]</label></div><br/><div class="children"><div class="content">Almost every modern software system. Anything running over the Web is event driven.</div><br/><div id="40628721" class="c"><input type="checkbox" id="c-40628721" checked=""/><div class="controls bullet"><span class="by">lolive</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40621131">parent</a><span>|</span><a href="#40629286">next</a><span>|</span><label class="collapse" for="c-40628721">[-]</label><label class="expand" for="c-40628721">[1 more]</label></div><br/><div class="children"><div class="content">99.99% of the data we consume on the Web comes out of databases [call it Transactional-SQL-xxx or ColumnBased-yyy or Elastic-SaaS-zzz].</div><br/></div></div></div></div><div id="40629286" class="c"><input type="checkbox" id="c-40629286" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40620350">parent</a><span>|</span><a href="#40621131">prev</a><span>|</span><a href="#40620612">next</a><span>|</span><label class="collapse" for="c-40629286">[-]</label><label class="expand" for="c-40629286">[1 more]</label></div><br/><div class="children"><div class="content">Right. The hard part is already done. Which makes it infuriating that it&#x27;s all &quot;internal&quot;. Every serious RDBMS already contains an implementation of an event-sourcing system, but you&#x27;re not allowed to actually use it.</div><br/></div></div></div></div><div id="40620612" class="c"><input type="checkbox" id="c-40620612" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40619970">parent</a><span>|</span><a href="#40620350">prev</a><span>|</span><a href="#40621254">next</a><span>|</span><label class="collapse" for="c-40620612">[-]</label><label class="expand" for="c-40620612">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;ve had mistakes that we&#x27;ve been able to course-correct from.<p>Our users are small-businesses with organisation numbers, and we mostly think of them as unique.  But they strictly aren&#x27;t, so we &#x27;overwrote&#x27; some companies with other companies.<p>Once we detected and fixed the bug, we just replayed the events with the fixed code, and we hadn&#x27;t lost any data.</div><br/></div></div><div id="40621254" class="c"><input type="checkbox" id="c-40621254" checked=""/><div class="controls bullet"><span class="by">lanstin</span><span>|</span><a href="#40619970">parent</a><span>|</span><a href="#40620612">prev</a><span>|</span><a href="#40621301">next</a><span>|</span><label class="collapse" for="c-40621254">[-]</label><label class="expand" for="c-40621254">[1 more]</label></div><br/><div class="children"><div class="content">It is a very convenient way to move higher latency operations from the realtime path to a near real time path. E.g. you want to send an email when a payment is authorized, you don’t want to wait for the whole SMTP transaction so you just post an even and reply back to the user. Also settlements of captured autos, 5st sort of thing. Even saving some user pref, start the task, reply back to user. and if it fails async send a failure msg.</div><br/></div></div><div id="40621301" class="c"><input type="checkbox" id="c-40621301" checked=""/><div class="controls bullet"><span class="by">nitwit005</span><span>|</span><a href="#40619970">parent</a><span>|</span><a href="#40621254">prev</a><span>|</span><a href="#40620676">next</a><span>|</span><label class="collapse" for="c-40621301">[-]</label><label class="expand" for="c-40621301">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen successful, but flawed usage.<p>Every use I&#x27;ve seen sent events after database transactions, with the event not part of the transaction. This means you can get both dropped events, and out of order events.<p>My current company has analytics driven by a system like that. I&#x27;m sure there&#x27;s some corrupted data as a result.<p>The main issue being people just don&#x27;t know how to build and test distributed systems.</div><br/><div id="40624260" class="c"><input type="checkbox" id="c-40624260" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40621301">parent</a><span>|</span><a href="#40620676">next</a><span>|</span><label class="collapse" for="c-40624260">[-]</label><label class="expand" for="c-40624260">[4 more]</label></div><br/><div class="children"><div class="content">I had an interview where I was asked how I would guarantee that an event happened in addition to a database update (transactionally).<p>It sounded kind of impossible, I said as much, and then proposed a different approach.  The interviewer persisted and claimed that it could be done with &#x27;the outbox pattern&#x27;.<p>I disagreed and ended the interview there.  Later when I was chatting about it with a former colleague, he said &quot;Oh, they solved the two generals problem?&quot;<p>&gt; Every use I&#x27;ve seen sent events after database transactions, with the event not part of the transaction.<p>Maybe this is what they were doing.</div><br/><div id="40626003" class="c"><input type="checkbox" id="c-40626003" checked=""/><div class="controls bullet"><span class="by">lastofus</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40624260">parent</a><span>|</span><a href="#40629455">next</a><span>|</span><label class="collapse" for="c-40626003">[-]</label><label class="expand" for="c-40626003">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t quite see what the outbox pattern has to do with the two generals problem.<p>The point of the outbox pattern is that a durable record of the need to send an event is stored in the DB as part of the DB txn, taking advantage of ACID guarantees.<p>Once you have that durable record in your DB, you can essentially treat your DB as a queue (there&#x27;s lot of great articles on how to do this with Postgres for instance) for some worker processes to later process the queue records, and send the events.<p>The worker processes in turn can decide if they want to attempt at least once, or at most once delivery of the message. Of course if you choose the later, then maybe your event is never sent, and perhaps that was the point you were trying to make to the interviewer.<p>They key takeaway though is that you are no longer reliant on the original process that stores the DB txn to also send the event, which can fail for any number of reasons, and may have no path to recovery. In other words, at least once delivery is now an option on the table.</div><br/></div></div><div id="40629455" class="c"><input type="checkbox" id="c-40629455" checked=""/><div class="controls bullet"><span class="by">nick__m</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40624260">parent</a><span>|</span><a href="#40626003">prev</a><span>|</span><a href="#40628617">next</a><span>|</span><label class="collapse" for="c-40629455">[-]</label><label class="expand" for="c-40629455">[1 more]</label></div><br/><div class="children"><div class="content">You could two phase commit with XA compliant broker and database.</div><br/></div></div><div id="40628617" class="c"><input type="checkbox" id="c-40628617" checked=""/><div class="controls bullet"><span class="by">ramchip</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40624260">parent</a><span>|</span><a href="#40629455">prev</a><span>|</span><a href="#40620676">next</a><span>|</span><label class="collapse" for="c-40628617">[-]</label><label class="expand" for="c-40628617">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a bit confused by the story. Why did you disagree?</div><br/></div></div></div></div></div></div><div id="40620676" class="c"><input type="checkbox" id="c-40620676" checked=""/><div class="controls bullet"><span class="by">simonbw</span><span>|</span><a href="#40619970">parent</a><span>|</span><a href="#40621301">prev</a><span>|</span><a href="#40629112">next</a><span>|</span><label class="collapse" for="c-40620676">[-]</label><label class="expand" for="c-40620676">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s been an incredibly useful pattern for me in game development. I have a hard time imagining making a game with any level of complexity without it. You can definitely go overboard with it, but I have a hard time even imagining how some systems like collision detection&#x2F;a physics engine could even work without it.</div><br/><div id="40622151" class="c"><input type="checkbox" id="c-40622151" checked=""/><div class="controls bullet"><span class="by">ClimaxGravely</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40620676">parent</a><span>|</span><a href="#40629112">next</a><span>|</span><label class="collapse" for="c-40622151">[-]</label><label class="expand" for="c-40622151">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s generally been my experience as well.<p>However I&#x27;ve seen some frameworks where you can do collision imperatively. For example<p>if (sprite.collide(tilemap)) {do something}<p>These are generally on smaller less taxing frameworks (in this case I&#x27;m referring to haxeflixel) but they do exist!</div><br/></div></div></div></div><div id="40629112" class="c"><input type="checkbox" id="c-40629112" checked=""/><div class="controls bullet"><span class="by">thr0w</span><span>|</span><a href="#40619970">parent</a><span>|</span><a href="#40620676">prev</a><span>|</span><a href="#40621832">next</a><span>|</span><label class="collapse" for="c-40629112">[-]</label><label class="expand" for="c-40629112">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Can someone share some long term event driven success stories?<p>JavaScript</div><br/><div id="40630043" class="c"><input type="checkbox" id="c-40630043" checked=""/><div class="controls bullet"><span class="by">jesse__</span><span>|</span><a href="#40619970">root</a><span>|</span><a href="#40629112">parent</a><span>|</span><a href="#40621832">next</a><span>|</span><label class="collapse" for="c-40630043">[-]</label><label class="expand" for="c-40630043">[1 more]</label></div><br/><div class="children"><div class="content">I think we have very different definitions of success</div><br/></div></div></div></div><div id="40621832" class="c"><input type="checkbox" id="c-40621832" checked=""/><div class="controls bullet"><span class="by">Osiris</span><span>|</span><a href="#40619970">parent</a><span>|</span><a href="#40629112">prev</a><span>|</span><a href="#40620772">next</a><span>|</span><label class="collapse" for="c-40621832">[-]</label><label class="expand" for="c-40621832">[1 more]</label></div><br/><div class="children"><div class="content">The project I&#x27;m working on is about 13 years old (ruby on rails) with over 260 engineers and the product has a very robust event driven system that is at the core of a lot of important features.</div><br/></div></div><div id="40620772" class="c"><input type="checkbox" id="c-40620772" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#40619970">parent</a><span>|</span><a href="#40621832">prev</a><span>|</span><a href="#40620932">next</a><span>|</span><label class="collapse" for="c-40620772">[-]</label><label class="expand" for="c-40620772">[1 more]</label></div><br/><div class="children"><div class="content">I saw it done well in manufacturing.<p>I think it works well when it&#x27;s the <i>only</i> thing that can work.</div><br/></div></div><div id="40620932" class="c"><input type="checkbox" id="c-40620932" checked=""/><div class="controls bullet"><span class="by">tlarkworthy</span><span>|</span><a href="#40619970">parent</a><span>|</span><a href="#40620772">prev</a><span>|</span><a href="#40620039">next</a><span>|</span><label class="collapse" for="c-40620932">[-]</label><label class="expand" for="c-40620932">[1 more]</label></div><br/><div class="children"><div class="content">Webhooks? Slack automation? GitHub actions?</div><br/></div></div><div id="40620039" class="c"><input type="checkbox" id="c-40620039" checked=""/><div class="controls bullet"><span class="by">turkey99</span><span>|</span><a href="#40619970">parent</a><span>|</span><a href="#40620932">prev</a><span>|</span><a href="#40631234">next</a><span>|</span><label class="collapse" for="c-40620039">[-]</label><label class="expand" for="c-40620039">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it’s a great tool for integration. We have a product suite and it’s our chosen way to connect products.</div><br/></div></div></div></div><div id="40631297" class="c"><input type="checkbox" id="c-40631297" checked=""/><div class="controls bullet"><span class="by">liampulles</span><span>|</span><a href="#40631234">prev</a><span>|</span><a href="#40628698">next</a><span>|</span><label class="collapse" for="c-40631297">[-]</label><label class="expand" for="c-40631297">[1 more]</label></div><br/><div class="children"><div class="content">Our system at work is a command driven system. We don&#x27;t use messages as a source of state, but really just as Async instructions. And we store them which can be useful for retrying, data fixes, and stats.<p>I feel like a lot of teams out there can probably benefit from this simpler approach - it&#x27;s probably what a lot of people are doing unwittingly.</div><br/></div></div><div id="40628698" class="c"><input type="checkbox" id="c-40628698" checked=""/><div class="controls bullet"><span class="by">YZF</span><span>|</span><a href="#40631297">prev</a><span>|</span><a href="#40630881">next</a><span>|</span><label class="collapse" for="c-40628698">[-]</label><label class="expand" for="c-40628698">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve worked in a large company where some variation of event driven architecture was used everywhere and treated as the word of G-d. Fairly successfully. Mostly in applications that ran on a single machine.<p>I&#x27;ve ended up in a lot of arguments about this while we were building larger distributed systems because I&#x27;ve come from a more request&#x2F;response oriented message passing architectures. I.e. more synchronous. What I&#x27;ve found is that the event driven architecture did tend to lead to less abstractions and more leaked internal details. This isn&#x27;t fundamental (you can treat events like an API) but was related to some details in our implementation (something along the line of CDC).<p>Another problem with distributed systems with persistent queues passing events is that if the consumer falls behind you start developing a lag. Yet another considerations is that the infrastructure to support this tends to have some performance penalties (e.g. going through Kafka with an event ends up being a lot more expensive than an RPC call). Overall it IMO makes for a lot of additional complexity which you may need in some cases, but if you don&#x27;t then you shouldn&#x27;t pay the cost.<p>What I&#x27;ve come to realize is that in many ways those systems are equivalent. You can simulate one over the other. If you have an event based system you can send requests as events and then wait for the response event. If you have a request&#x2F;response system you can simulate events over that.<p>If we look at things like consensus protocols or distributed&#x2F;persistent queues then obviously we would need some underlying resources (e.g. you might need a database behind your request&#x2F;response model). So... Semantics. Don&#x27;t know if others have a similar experience but when one system is mandated people will invent workarounds that end up looking like the other paradigm, which makes things worse.<p>There are things that conceptually fit well with an event driven architecture and then there are things that fit well with a request&#x2F;response model. I&#x27;m guessing most large scale complex distributed apps would be best supporting both models.</div><br/><div id="40631552" class="c"><input type="checkbox" id="c-40631552" checked=""/><div class="controls bullet"><span class="by">bux93</span><span>|</span><a href="#40628698">parent</a><span>|</span><a href="#40629205">next</a><span>|</span><label class="collapse" for="c-40631552">[-]</label><label class="expand" for="c-40631552">[1 more]</label></div><br/><div class="children"><div class="content">Every synchronous call is, in fact, asynchronous. We just hide it on the stack, in the return address, in the TCP connection etc. No call is really blocking anymore, the OS or the CPU will run some other thread. People who insist that things are simpler in a synchronous model are just ignoring the actual mechanics. Which is fine, that&#x27;s just abstraction.</div><br/></div></div><div id="40629205" class="c"><input type="checkbox" id="c-40629205" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#40628698">parent</a><span>|</span><a href="#40631552">prev</a><span>|</span><a href="#40630881">next</a><span>|</span><label class="collapse" for="c-40629205">[-]</label><label class="expand" for="c-40629205">[4 more]</label></div><br/><div class="children"><div class="content">&gt; What I&#x27;ve found is that the event driven architecture did tend to lead to less abstractions and more leaked internal details. This isn&#x27;t fundamental (you can treat events like an API)<p>I&#x27;d put it the other way: event driven architecture makes it safer to expose more internal details for longer, and lets you push back the point where you really need to fully decouple your API. I see that as an advantage; an abstract API is a means not an end.<p>&gt; Another problem with distributed systems with persistent queues passing events is that if the consumer falls behind you start developing a lag.<p>Isn&#x27;t that what you want? Whatever your architecture, fundamentally when you can&#x27;t keep up either you queue or you start dropping some inputs.<p>&gt; If you have a request&#x2F;response system you can simulate events over that.<p>How? I mean you can implement your own eventing layer on top of a request&#x2F;response system, but that&#x27;s going to give you all the problems of both.<p>&gt; If we look at things like consensus protocols or distributed&#x2F;persistent queues then obviously we would need some underlying resources (e.g. you might need a database behind your request&#x2F;response model).<p>Huh?<p>&gt; Don&#x27;t know if others have a similar experience but when one system is mandated people will invent workarounds that end up looking like the other paradigm, which makes things worse.<p>I agree that building a request&#x2F;response system on top of an event sourcing system gives you something worse than using a native request&#x2F;response system. But that&#x27;s not a good reason to abandon the mandate, because building a true event-sourcing system has real advantages, and most of those advantages disappear once you start mixing the two. What you do need is full buyin and support at every level rather than a mandate imposed on people who don&#x27;t want to follow it, but that&#x27;s true for every development choice.</div><br/><div id="40629614" class="c"><input type="checkbox" id="c-40629614" checked=""/><div class="controls bullet"><span class="by">YZF</span><span>|</span><a href="#40628698">root</a><span>|</span><a href="#40629205">parent</a><span>|</span><a href="#40630881">next</a><span>|</span><label class="collapse" for="c-40629614">[-]</label><label class="expand" for="c-40629614">[3 more]</label></div><br/><div class="children"><div class="content">Everything is a means and not an end but decoupling via an explicit API makes change easier. Spreading state across your system via events (specifically synchronizing data across systems via events relating to how that data changes) creates coupling.<p>re: Huh. Sorry I was not clear there. What I meant is you can not create persistent queue semantics out of a request&#x2F;response model without being able to make certain kinds of requests that access resources. Maybe that&#x27;s an obvious statement.<p>re: mandate. I think I&#x27;m saying these sort of mandates inevitable result in poor design. even the purest of purest event sourcing systems actually use requests&#x2F;response simply because that is the fundamental building block of systems. E.g. Kafka uses gRPCs from the client and waits for a response in order to inject something into a queue. The communication between Kafka nodes is based on messages. The basic building block of any distributed computer system is a packet (request) being sent from one machine to another, and a response being sent back (e.g. TCP control messages). A mandate that says though shall build everything on top of event sourcing is sort of silly in this context since it should be obvious the building blocks of event sourced systems use requests&#x2F;response. Even without this nit-picking restricting application developers to only build on top of this abstraction inevitably leads to ugliness. IMO anyways and having seen this mandate at work in a large organizations. Use the right tool for your job is more or less what I&#x27;m saying or the other famous way of stating this is when all you have is a hammer everything looks like a nail.<p>re: isn&#x27;t that what you want. well, if it is what you want then it is what you want, but many systems are ok with things just getting lost and not persisted. e.g. an HTTP GET request from a browser, in the absence of a network connection, is just lost, it&#x27;s not persisted to be played later, and so there is no way to build a lagging queue with HTTP GET requests that are yet to be processed. Again, maybe an obvious statement.</div><br/><div id="40629896" class="c"><input type="checkbox" id="c-40629896" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#40628698">root</a><span>|</span><a href="#40629614">parent</a><span>|</span><a href="#40630881">next</a><span>|</span><label class="collapse" for="c-40629896">[-]</label><label class="expand" for="c-40629896">[2 more]</label></div><br/><div class="children"><div class="content">&gt; decoupling via an explicit API makes change easier. Spreading state across your system via events (specifically synchronizing data across systems via events relating to how that data changes) creates coupling.<p>An explicit API comes at a cost; the way I&#x27;d put it is that the inherently lower coupling of events (because e.g. you can publish the same events in multiple formats, whereas a request-response API generally needs to have a single response format) means that you have more slack to defer that cost for longer (i.e. it takes you longer to reach the point where the overall system coupling is too bad and you need to introduce those API layers).<p>I&#x27;m not sure I follow what you&#x27;re saying about sharing events relating to how data changes. IMO if you need a shared view of &quot;the current version of the data&quot;, the right solution is to publish that as events too.<p>&gt; E.g. Kafka uses gRPCs from the client and waits for a response in order to inject something into a queue. The communication between Kafka nodes is based on messages. The basic building block of any distributed computer system is a packet (request) being sent from one machine to another, and a response being sent back (e.g. TCP control messages).<p>I don&#x27;t know the details of kafka&#x27;s low-level protocols, but it&#x27;s certainly possible to build these systems based on one-way messaging all the way down; gRPC has one-way messages, plenty of protocols are built on one-way UDP rather than TCP...<p>&gt; e.g. an HTTP GET request from a browser, in the absence of a network connection, is just lost, it&#x27;s not persisted to be played later, and so there is no way to build a lagging queue with HTTP GET requests that are yet to be processed.<p>Right, <i>because</i> HTTP is a request-response protocol. Whereas Kafka does buffer messages and send them later if you lose your network connection for a short time (of course there is a point at which it will give up and call your error handler).<p>I don&#x27;t think the fact that HTTP works that way means it&#x27;s <i>desirable</i> to just abandon those requests - e.g. in fact these days if you navigate to a page with Chrome when you have no network connection it will make the request when you&#x27;re back online and send you a notification that it&#x27;s loaded the page that it couldn&#x27;t load earlier.</div><br/><div id="40630042" class="c"><input type="checkbox" id="c-40630042" checked=""/><div class="controls bullet"><span class="by">YZF</span><span>|</span><a href="#40628698">root</a><span>|</span><a href="#40629896">parent</a><span>|</span><a href="#40630881">next</a><span>|</span><label class="collapse" for="c-40630042">[-]</label><label class="expand" for="c-40630042">[1 more]</label></div><br/><div class="children"><div class="content">Usually when you&#x27;re ingesting something into Kafka it&#x27;s important to know whether that was successful or not, hence the more or less inherent request&#x2F;response that&#x27;s part of that. That said it&#x27;s an interesting thought experiment to see how far you can go without that.<p>When I think of large scale success stories around the request&#x2F;response model I think AWS (where famously Bezos mandated APIs first) and Google. Both now have services that look more event oriented (e.g. SQS or Firebase). And ofcourse the modern web (though the ugly hacks needed to make something look like event driven was certainly not fun).<p>Events related to data changes are about keeping data structures in sync via events. Also known as state-based architecture. Something I worked on in the early 2000&#x27;s kept a remote client&#x2F;UI in sync with the server and a database using events like that and was a pretty lean&#x2F;neat implementation.<p>Good one on the Chrome re-making requests when you&#x27;re online for an active tab. That&#x27;s certainly an interesting use case.<p>My intuition is that some things are very naturally events. Let&#x27;s say a packet arriving into your computer. A mouse click. And some things are naturally a request-response. Let&#x27;s say calculating the Cosine of an angle. You can replace x = sin(y) with an event, and an event that comes back, but that feels awkward as a human. Maybe not the best example...<p>It&#x27;s another variation on the sync vs. async debates I guess. Coroutines or callbacks...</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40630881" class="c"><input type="checkbox" id="c-40630881" checked=""/><div class="controls bullet"><span class="by">DotaFan</span><span>|</span><a href="#40628698">prev</a><span>|</span><a href="#40619959">next</a><span>|</span><label class="collapse" for="c-40630881">[-]</label><label class="expand" for="c-40630881">[1 more]</label></div><br/><div class="children"><div class="content">Event-driven architecture should be implemented across complete system (client-be) or be used in a single feature, i.e. it needs to be all or bare minimum, else it&#x27;s just an absolute mess.</div><br/></div></div><div id="40619959" class="c"><input type="checkbox" id="c-40619959" checked=""/><div class="controls bullet"><span class="by">gnat</span><span>|</span><a href="#40630881">prev</a><span>|</span><a href="#40620900">next</a><span>|</span><label class="collapse" for="c-40619959">[-]</label><label class="expand" for="c-40619959">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20240608190815&#x2F;https:&#x2F;&#x2F;codeopinion.com&#x2F;beware-anti-patterns-in-event-driven-architecture&#x2F;" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20240608190815&#x2F;https:&#x2F;&#x2F;codeopini...</a></div><br/></div></div><div id="40620900" class="c"><input type="checkbox" id="c-40620900" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#40619959">prev</a><span>|</span><a href="#40620836">next</a><span>|</span><label class="collapse" for="c-40620900">[-]</label><label class="expand" for="c-40620900">[1 more]</label></div><br/><div class="children"><div class="content">I’m starting to get a sad about event driven stuff.<p>I’ve used it with a good degree of success in some data pipeline and spark stuff to have stuff automatically kick off, without heinous conditional orchestration logic. I also use evented stuff over channels in a lot of my rust code with great success.<p>However, echoing the sentiments of some other comments: most articles about event driven stuff seem to be either marketing blogspam or “we tried it and it was awful”. To be honest I look at a lot of those blog posts and about half the time my thoughts are “no wonder that didn’t work out, that’s an insane design” but is that just “you’re-doing-it-wrong-cope”?<p>Are there success stories out there that just aren’t being written? Is there just no success stories? Is the architecture less forgiving of poor design and this “higher bar of entry” torpedoes a number of projects? Is it more susceptible to “architecture astronauts” which dooms it? Is it actually decent, but requires a somewhat larger mindset-change than most people take to it, leading to half-baked implementations?<p>I can’t help but feel the underlying design has some kernels of some really good ideas, but the volume of available evidence sort of suggests otherwise.</div><br/></div></div><div id="40620836" class="c"><input type="checkbox" id="c-40620836" checked=""/><div class="controls bullet"><span class="by">aejm</span><span>|</span><a href="#40620900">prev</a><span>|</span><a href="#40621220">next</a><span>|</span><label class="collapse" for="c-40620836">[-]</label><label class="expand" for="c-40620836">[1 more]</label></div><br/><div class="children"><div class="content">What are people’s thoughts on using event driven architecture in games? Specifically multiplayer games, and massively multiplayer games (MMOrpgs).
Another comment mentions it was helpful, how specifically, were there any tradeoffs, do certain types of games work better?</div><br/></div></div><div id="40621220" class="c"><input type="checkbox" id="c-40621220" checked=""/><div class="controls bullet"><span class="by">chermi</span><span>|</span><a href="#40620836">prev</a><span>|</span><a href="#40620956">next</a><span>|</span><label class="collapse" for="c-40621220">[-]</label><label class="expand" for="c-40621220">[1 more]</label></div><br/><div class="children"><div class="content">I always thought it would be an interesting exercise to build an event-based controls system. There&#x27;s a lot triggering action X based on event A. And actions based on composite events. I never found anyone who had done it.<p>Edit- I should say I never saw one in the wild, quick search found some academic projects <a href="https:&#x2F;&#x2F;scholar.google.com&#x2F;scholar?q=event-driven+control+system&amp;hl=en&amp;as_sdt=0&amp;as_vis=1&amp;oi=scholart#d=gs_qabs&amp;t=1717895148440&amp;u=%23p%3D2KAKAhWCSPkJ" rel="nofollow">https:&#x2F;&#x2F;scholar.google.com&#x2F;scholar?q=event-driven+control+sy...</a></div><br/></div></div><div id="40620956" class="c"><input type="checkbox" id="c-40620956" checked=""/><div class="controls bullet"><span class="by">rammy1234</span><span>|</span><a href="#40621220">prev</a><span>|</span><a href="#40621012">next</a><span>|</span><label class="collapse" for="c-40620956">[-]</label><label class="expand" for="c-40620956">[2 more]</label></div><br/><div class="children"><div class="content">My 2 cents - There is no anti-pattern specific to event driven. It is essentially asynchronous nature. It means you start with understanding the business needs and SLA. Question often comes in my experience is &quot;can they wait?&quot; and what&#x27;s the risk of dirty data or data fetched with delay ( worst case ). event driven is always about worst case scenario and will it work then.</div><br/><div id="40627298" class="c"><input type="checkbox" id="c-40627298" checked=""/><div class="controls bullet"><span class="by">therealdrag0</span><span>|</span><a href="#40620956">parent</a><span>|</span><a href="#40621012">next</a><span>|</span><label class="collapse" for="c-40627298">[-]</label><label class="expand" for="c-40627298">[1 more]</label></div><br/><div class="children"><div class="content">The main anti pattern is making the wrong choice; using async when sync fits better.</div><br/></div></div></div></div><div id="40621012" class="c"><input type="checkbox" id="c-40621012" checked=""/><div class="controls bullet"><span class="by">worik</span><span>|</span><a href="#40620956">prev</a><span>|</span><a href="#40619977">next</a><span>|</span><label class="collapse" for="c-40621012">[-]</label><label class="expand" for="c-40621012">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Event driven architecture &quot;. Mēh!<p>There is no avoiding it when dealing with, erm, events.<p>Events are things that happen that you cannot predict exactly when, where, and what.<p>The user clicked the mouse<p>The wind changed direction<p>Using Events to signal state change from one part of a system to another is a bad idea. Use a function call.<p>A rule of thumb is if the producer and the consu,er are in the same system then &quot;Event Driven Architecture &quot; is the anti pattern</div><br/><div id="40621032" class="c"><input type="checkbox" id="c-40621032" checked=""/><div class="controls bullet"><span class="by">gardenhedge</span><span>|</span><a href="#40621012">parent</a><span>|</span><a href="#40619977">next</a><span>|</span><label class="collapse" for="c-40621032">[-]</label><label class="expand" for="c-40621032">[1 more]</label></div><br/><div class="children"><div class="content">What if one event should trigger many actions?</div><br/></div></div></div></div><div id="40621211" class="c"><input type="checkbox" id="c-40621211" checked=""/><div class="controls bullet"><span class="by">oddevan</span><span>|</span><a href="#40619977">prev</a><span>|</span><a href="#40620507">next</a><span>|</span><label class="collapse" for="c-40621211">[-]</label><label class="expand" for="c-40621211">[1 more]</label></div><br/><div class="children"><div class="content">Went in thinking I would find out a few pitfalls for the event-driven app I&#x27;m writing...<p>&gt; Commands only have a single consumer. There must be a single consumer. That’s it. They do not use the publish-subscribe pattern.<p>...oops.<p>Now the question is how much (more) time I want to spend on a(nother) rewrite.</div><br/></div></div></div></div></div></div></div></body></html>