<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1722762051907" as="style"/><link rel="stylesheet" href="styles.css?v=1722762051907"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://arxiv.org/abs/2205.12626">Non-computability of solutions of certain equations on digital computers (2022)</a>Â <span class="domain">(<a href="https://arxiv.org">arxiv.org</a>)</span></div><div class="subtext"><span>lisper</span> | <span>74 comments</span></div><br/><div><div id="41150122" class="c"><input type="checkbox" id="c-41150122" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#41150814">next</a><span>|</span><label class="collapse" for="c-41150122">[-]</label><label class="expand" for="c-41150122">[16 more]</label></div><br/><div class="children"><div class="content">Happy to see this made it to the front page.  I submitted it because I&#x27;m hoping someone here will be able to understand it well enough to explain its significance.  Is this Big News or a parlor trick?  If it really is an example of an uncomputable physical process, that would seem to me to be earth-shattering, and yet this result does not appear to have made a splash.  It is based on a construction of J. Myhill of a continuous recursive (and hence computable) function whose derivative is not computable.  The proof is non-constructive, and it assumes the existence of a partially decidable set called A which somehow (this is the part I don&#x27;t quite understand) results in a computable function despite the fact that its derivative can&#x27;t be computable because that would imply A is decidable.  Any clues would be much appreciated.<p>[UPDATE] Let me put this more succinctly: how is it possible that there can be a continuous computable function whose derivative is uncomputable?  What exactly is it about this function that makes numerical differentiation fail?<p>[UPDATE2] Here is a link to the Myhill paper for easy reference.<p><a href="https:&#x2F;&#x2F;projecteuclid.org&#x2F;download&#x2F;pdf_1&#x2F;euclid.mmj&#x2F;1029000631" rel="nofollow">https:&#x2F;&#x2F;projecteuclid.org&#x2F;download&#x2F;pdf_1&#x2F;euclid.mmj&#x2F;10290006...</a><p>It&#x27;s remarkably short, only two pages.</div><br/><div id="41150342" class="c"><input type="checkbox" id="c-41150342" checked=""/><div class="controls bullet"><span class="by">solveit</span><span>|</span><a href="#41150122">parent</a><span>|</span><a href="#41150420">next</a><span>|</span><label class="collapse" for="c-41150342">[-]</label><label class="expand" for="c-41150342">[2 more]</label></div><br/><div class="children"><div class="content">&gt; how is it possible that there can be a continuous computable function whose derivative is uncomputable?<p>For others: The original paper is short and very readable - <a href="https:&#x2F;&#x2F;projecteuclid.org&#x2F;journalArticle&#x2F;Download?urlId=10.1307%2Fmmj%2F1029000631" rel="nofollow">https:&#x2F;&#x2F;projecteuclid.org&#x2F;journalArticle&#x2F;Download?urlId=10.1...</a><p>The intuition seems to be that computability of a function is actually approximability, and derivatives can be large even when the function is very small, by having the large slope confined to a very small area. So by constructing a function f that contains an uncomputable (but recursively enumerable!) set encoded in the derivative by strategically placing little bumps, but having the bumps grow exponentially smaller, Myhill was able to construct a function that was easily approximable but whose derivative wasn&#x27;t.<p>The key detail here is that the bumps grow exponentially smaller in the order the  uncomputable set appears in its enumeration. This allows Myhill to construct a sequence of computable functions that (uniformly) approximate f to within 2^(-n). If the bumps weren&#x27;t ordered in this way, we wouldn&#x27;t know how far down the sequence to go to approximate f to within 2^(-n). The ordering lets us just look at the first n elements of the uncomputable set.<p>Why doesn&#x27;t this allow us to approximate the derivative? Because at any x, we don&#x27;t know how well we have to approximate f in order to approximate f&#x27;(x), so we need knowledge of the entire uncomputable set, which we cannot have.</div><br/><div id="41151155" class="c"><input type="checkbox" id="c-41151155" checked=""/><div class="controls bullet"><span class="by">a1369209993</span><span>|</span><a href="#41150122">root</a><span>|</span><a href="#41150342">parent</a><span>|</span><a href="#41150420">next</a><span>|</span><label class="collapse" for="c-41151155">[-]</label><label class="expand" for="c-41151155">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The key detail here is that the bumps grow exponentially smaller<p>Pedantically, it&#x27;s that the bumps grow exponentially <i>narrower</i>.<p>IIUC, a simpler (but more nitpickable) version would be f&#x27;(n+1&#x2F;y) = [the fraction of n-state Turing machines that halt within y steps] (for positive integers n, and 0 elsewhere); then f is the integral of f&#x27;. The value of f(x) can be approximated arbitrarily well by running every floor(x)-state Turing machine for a large finite number of steps[2], but f&#x27;(x) is equal to Chaitin&#x27;s constant[0] for n-state Turing machines over a strictly-positive-length[1] subinterval of [n,n+1).<p>A <i>much</i> simpler version is f&#x27;(x) = {-1 if x&lt;0; +1 if x&gt;0; Chaitin&#x27;s constant if x=0}. f(x) = abs(x).<p>Basically, this isn&#x27;t <i>even</i> a parlor trick. It&#x27;s a nothing burger, disguised as something <i>by means of</i> a parlor trick.<p>0: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Chaitin%27s_constant" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Chaitin%27s_constant</a><p>1: And so strictly-containing-rational-numbers, although predicting <i>which</i> rational numbers is nontrivial.<p>2: The rounding error from assuming all machines that halt after y steps actually run forever scales as O(1&#x2F;y) in the worst case.</div><br/></div></div></div></div><div id="41150420" class="c"><input type="checkbox" id="c-41150420" checked=""/><div class="controls bullet"><span class="by">NegativeK</span><span>|</span><a href="#41150122">parent</a><span>|</span><a href="#41150342">prev</a><span>|</span><a href="#41150863">next</a><span>|</span><label class="collapse" for="c-41150420">[-]</label><label class="expand" for="c-41150420">[4 more]</label></div><br/><div class="children"><div class="content">Is it specifically the fact that it&#x27;s a physical process that makes it earth shattering?<p>Physical models of computers ( <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Billiard-ball_computer" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Billiard-ball_computer</a> ) have been around for a long time, which means that noncomputability has been tangible for a long time.<p>I might be numb, though, to the fact that much of what want to understand can&#x27;t be. If the universe isn&#x27;t discrete, then it seems like noncomputability is the default.</div><br/><div id="41151315" class="c"><input type="checkbox" id="c-41151315" checked=""/><div class="controls bullet"><span class="by">vinnyvichy</span><span>|</span><a href="#41150122">root</a><span>|</span><a href="#41150420">parent</a><span>|</span><a href="#41150863">next</a><span>|</span><label class="collapse" for="c-41151315">[-]</label><label class="expand" for="c-41151315">[3 more]</label></div><br/><div class="children"><div class="content">Hey, I feel you, my first thought was that continuously differentiable functions aren&#x27;t physical :)</div><br/><div id="41151552" class="c"><input type="checkbox" id="c-41151552" checked=""/><div class="controls bullet"><span class="by">jpt4</span><span>|</span><a href="#41150122">root</a><span>|</span><a href="#41151315">parent</a><span>|</span><a href="#41150863">next</a><span>|</span><label class="collapse" for="c-41151552">[-]</label><label class="expand" for="c-41151552">[2 more]</label></div><br/><div class="children"><div class="content">The first order theories of the real numbers using addition and multiplication are decidable [0], while FO theories of the integers under the same operations are not.<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Decidability_of_first-order_theories_of_the_real_numbers" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Decidability_of_first-order_th...</a></div><br/><div id="41151833" class="c"><input type="checkbox" id="c-41151833" checked=""/><div class="controls bullet"><span class="by">vinnyvichy</span><span>|</span><a href="#41150122">root</a><span>|</span><a href="#41151552">parent</a><span>|</span><a href="#41150863">next</a><span>|</span><label class="collapse" for="c-41151833">[-]</label><label class="expand" for="c-41151833">[1 more]</label></div><br/><div class="children"><div class="content">Wikipedia can be confusing..<p><a href="https:&#x2F;&#x2F;mathoverflow.net&#x2F;questions&#x2F;134259&#x2F;is-the-first-order-theory-with-of-real-numbers-with-addition-and-multiplicat" rel="nofollow">https:&#x2F;&#x2F;mathoverflow.net&#x2F;questions&#x2F;134259&#x2F;is-the-first-order...</a></div><br/></div></div></div></div></div></div></div></div><div id="41150863" class="c"><input type="checkbox" id="c-41150863" checked=""/><div class="controls bullet"><span class="by">dooglius</span><span>|</span><a href="#41150122">parent</a><span>|</span><a href="#41150420">prev</a><span>|</span><a href="#41150367">next</a><span>|</span><label class="collapse" for="c-41150863">[-]</label><label class="expand" for="c-41150863">[4 more]</label></div><br/><div class="children"><div class="content">I would consider the Myhill proof to be constructive, curious why you don&#x27;t think so?<p>Set A as desired that is non-recursive, recursively enumerable is conceptually easy to construct: let A be the binary encoding of all Turing Machines that halt. This is well known not to be recursive (computable), but you can recursively enumerate them by taking a bijection from s: N -&gt; NxN (possible since NxN is known to be countable) and on step i emit M if Turing Machine with binary encoding M halts on step B, where s(i)=(M,B).<p>The resulting Myhill function f is indeed computable and derivative non-computable, but it is highly dubious that such a function would be physically realizable. Why and how would we expect such a function to possibly arise in nature, based on a non-computable set A? For one thing, it&#x27;s second derivative diverges so hard it can&#x27;t be bounded as x -&gt; 0 by any computable function. Also, one very quickly is dealing with x and y scopes far below Plank limits.</div><br/><div id="41150881" class="c"><input type="checkbox" id="c-41150881" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#41150122">root</a><span>|</span><a href="#41150863">parent</a><span>|</span><a href="#41150367">next</a><span>|</span><label class="collapse" for="c-41150881">[-]</label><label class="expand" for="c-41150881">[3 more]</label></div><br/><div class="children"><div class="content">&gt; curious why you don&#x27;t think so?<p>Uh, because Myhill says so?  &quot;We first define the function f non-constructively...&quot;<p>But I agree with your analysis.  It seems constructive to me too.<p>I don&#x27;t understand his proof that f is recursive though.</div><br/><div id="41151023" class="c"><input type="checkbox" id="c-41151023" checked=""/><div class="controls bullet"><span class="by">dooglius</span><span>|</span><a href="#41150122">root</a><span>|</span><a href="#41150881">parent</a><span>|</span><a href="#41150367">next</a><span>|</span><label class="collapse" for="c-41151023">[-]</label><label class="expand" for="c-41151023">[2 more]</label></div><br/><div class="children"><div class="content">Ah, I think the non-constructive comment is just about presentation order; he gives a sketch of how f works first then later he gives an explicit formula partway through page 2 after theta, alpha, beta, and h are defined.<p>For why f is recursive (computable), here&#x27;s maybe a helpful way of thinking about it: Let&#x27;s think about the halting behavior of an input Turing Machine M. Consider the following pseudocode infinitary program which &quot;outputs&quot; two variables A_M and B_M after infinite time:<p><pre><code>  for each integer n:
    if M halts on step n:
      return A_M = 2^(-n) ; B_M = 1
  if M never halts, return A_M = 0 ; B_M = 0
</code></pre>
Clearly, B_M is not computable; that&#x27;s the halting problem. However, A_M is actually computable, as computability of real-valued functions is defined as the ability to give an estimate to arbitrarily small queried precision: for precision epsilon, pick 2^(-c) &lt; epsilon and run our algorithm above for just the first c steps; then pass on the value if it returned, or we can return zero and that&#x27;s fine as we are within epsilon of the true A_M. So, A_M is computable whereas B_M is not.<p>The trick then is to observe that we can construct theta-functions with arbitrarily small values but constant-sized derivatives; so by summing a bunch of these together we get a function whose value at 2^(-M) behaves like A_M and whose derivative at 2^(-M) behaves like B_M.</div><br/><div id="41151734" class="c"><input type="checkbox" id="c-41151734" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#41150122">root</a><span>|</span><a href="#41151023">parent</a><span>|</span><a href="#41150367">next</a><span>|</span><label class="collapse" for="c-41151734">[-]</label><label class="expand" for="c-41151734">[1 more]</label></div><br/><div class="children"><div class="content">Ah, that makes sense.  Thanks!</div><br/></div></div></div></div></div></div></div></div><div id="41150513" class="c"><input type="checkbox" id="c-41150513" checked=""/><div class="controls bullet"><span class="by">fgdorais</span><span>|</span><a href="#41150122">parent</a><span>|</span><a href="#41150367">prev</a><span>|</span><a href="#41150667">next</a><span>|</span><label class="collapse" for="c-41150513">[-]</label><label class="expand" for="c-41150513">[1 more]</label></div><br/><div class="children"><div class="content">The relevant book <i>Computability in Analysis and Physics</i> by Pour-El and Richards is from 1989 but it is quite readable. The main requirements are a strong mathematical background (mostly in analysis and PDEs and an acquaintance with computability theory) and perhaps some appreciation for physics.</div><br/></div></div><div id="41150667" class="c"><input type="checkbox" id="c-41150667" checked=""/><div class="controls bullet"><span class="by">roywiggins</span><span>|</span><a href="#41150122">parent</a><span>|</span><a href="#41150513">prev</a><span>|</span><a href="#41150143">next</a><span>|</span><label class="collapse" for="c-41150667">[-]</label><label class="expand" for="c-41150667">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  If it really is an example of an uncomputable physical process<p>I guess first you&#x27;d have to prove that there are physical processes are <i>actually</i> continuous, and that this continuum is genuinely the continuum of the reals.<p>It is already known that a computer with access to real numbers with infinite precision can perform hypercomputation, I&#x27;m not sure how much this is relevant, but:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Real_computation" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Real_computation</a></div><br/></div></div><div id="41150143" class="c"><input type="checkbox" id="c-41150143" checked=""/><div class="controls bullet"><span class="by">almostgotcaught</span><span>|</span><a href="#41150122">parent</a><span>|</span><a href="#41150667">prev</a><span>|</span><a href="#41150814">next</a><span>|</span><label class="collapse" for="c-41150143">[-]</label><label class="expand" for="c-41150143">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Big News<p>The paper is from May 2022. Don&#x27;t you have the answer to whether it&#x27;s big news? Whether the news is big is (usually) apparent&#x2F;assessed when it is <i>new</i>.</div><br/><div id="41150154" class="c"><input type="checkbox" id="c-41150154" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#41150122">root</a><span>|</span><a href="#41150143">parent</a><span>|</span><a href="#41150814">next</a><span>|</span><label class="collapse" for="c-41150154">[-]</label><label class="expand" for="c-41150154">[1 more]</label></div><br/><div class="children"><div class="content">Two years it not that old, and the topic is obscure enough that it could plausibly have gone unnoticed.  Bell&#x27;s inequality went virtually unnoticed when it was first published.<p>My money is definitely on parlor trick, but I would still like to understand why.</div><br/></div></div></div></div></div></div><div id="41150814" class="c"><input type="checkbox" id="c-41150814" checked=""/><div class="controls bullet"><span class="by">dooglius</span><span>|</span><a href="#41150122">prev</a><span>|</span><a href="#41150303">next</a><span>|</span><label class="collapse" for="c-41150814">[-]</label><label class="expand" for="c-41150814">[1 more]</label></div><br/><div class="children"><div class="content">At a glance, this paper seems extremely questionable. It appears to take an offhand comment by Kahneman in a Lex Friedman podcast regarding the limits of AI and interpret it as asking whether there is a problem that humans can solve but machines cannot -- which is definitely not a reasonable interpretation IMO as in context Kahneman is talking about the limitations of present AI systems, and computability is a totally different question. The paper&#x27;s claim to have found such a class of problem would mean the Church-Turing thesis is false, and so it is quite surprising that the Church-Turing thesis and existing discussion around it does not appear to be mentioned or cited. Anyway, the paper constructs at some length a non-computable problem and then declares, &quot;Nevertheless, a human can certainly solve this problem by creative work.&quot; While I haven&#x27;t gone through the construction in-depth to see whether that&#x27;s reasonable, this certainly doesn&#x27;t come across as a very rigorous proof. Also, in the introduction, it makes the bold claim that &quot;digital computers ... are able to compute with finite sequences of rational numbers only,&quot; (and suggests that analog and quantum computers lack such limitations) which is certainly false as can be seen by programs such as Mathematica that easily solve many systems involving irrational and transcendental numbers.</div><br/></div></div><div id="41150303" class="c"><input type="checkbox" id="c-41150303" checked=""/><div class="controls bullet"><span class="by">jfoutz</span><span>|</span><a href="#41150814">prev</a><span>|</span><a href="#41150804">next</a><span>|</span><label class="collapse" for="c-41150303">[-]</label><label class="expand" for="c-41150303">[14 more]</label></div><br/><div class="children"><div class="content">This reminds me of this reddit question <a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;askmath&#x2F;comments&#x2F;1eakt5c&#x2F;if_you_pick_a_real_number_from_0_to_1_what_is_the&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;askmath&#x2F;comments&#x2F;1eakt5c&#x2F;if_you_pic...</a>
&quot;If you pick a real number from 0 to 1, what is the probability that it is rational?&quot;<p>and the first response,
&quot;
With a uniform random process over an interval (a, b), you can find the probability of picking an element from a set X by integrating 1&#x2F;(b - a) over the set X.<p>Since the (lebesgue) integral of the rational numbers is 0, the probability of picking a rational number is 0. 
&quot;
And that kinda broke my brain for an afternoon.<p>So, when a computer represents a number, it&#x27;s always rational. You can have a lot of memory, but always finite.<p>Now, you can go further, and represent things symbolically, like sage math or a bunch of other systems. But (I believe) at the end of the day Godel always wins. There are always true statements that can&#x27;t be proved. If I remember right, computable stuff is a subset (maybe improper?) of provable stuff.<p>Looks interesting. Thank you for posting it. I&#x27;ll try to read it later. Although, I&#x27;m a math tourist. I probably won&#x27;t be able to give you any grand insight.</div><br/><div id="41150727" class="c"><input type="checkbox" id="c-41150727" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41150303">parent</a><span>|</span><a href="#41150714">next</a><span>|</span><label class="collapse" for="c-41150727">[-]</label><label class="expand" for="c-41150727">[1 more]</label></div><br/><div class="children"><div class="content">Sets of measure 0 that are not empty or are even infinite are indeed mind-bending when first encountered. But a set of cardinality 1 may be fun, too.<p>Take a real-valued stochastic processb<i>S</i>, and an arbitrary time <i>t</i>. The process generates a value, <i>v = S(t)</i>.<p>Since the width of the range from <i>v</i> to <i>v</i> is zero, the probability that <i>S</i> generates this number is also zero.<p>We can replace it with a physical stochastic process. Say, take the voltage in your electric socket. It fluctuates randomly around the nominal value. At every moment there is <i>some</i> voltage in the socket, and <i>the probability to encounter this voltage is zero</i>. It looks like the impossible is actually happening at every moment!<p>This is, of course, thevprobability being a chance to encounter a <i>given</i> value. If we pick a value first, and then start sampling our stochastic process, there&#x27;s zero probability that we&#x27;re going to encounter our (infinitely precise) number, no matter how long we&#x27;d try.<p>(A physical voltmeter has a finite resolution, say, 0.10 V, so it&#x27;s going to show you a predetermined voltage pretty often. But it would be a rounded approximation of the unpredictable real value.)</div><br/></div></div><div id="41150714" class="c"><input type="checkbox" id="c-41150714" checked=""/><div class="controls bullet"><span class="by">yarg</span><span>|</span><a href="#41150303">parent</a><span>|</span><a href="#41150727">prev</a><span>|</span><a href="#41150722">next</a><span>|</span><label class="collapse" for="c-41150714">[-]</label><label class="expand" for="c-41150714">[1 more]</label></div><br/><div class="children"><div class="content">You can provide definitions for irrational numbers, but they&#x27;ll be expressed in terms of infinite serieses (what the hell is the plural form of series?).<p>So, if ever you try to expand them, you&#x27;ll need to truncate at some point.<p>There will however, be situations where you can perform operations directly on the serieses, and in those cases (but not the ones requiring expansion and truncation) you&#x27;ll be able to perform the operations losslessly.<p>Of course, no one would ever bother with that - even NASA truncates pi to 3.141592653589793 (<a href="https:&#x2F;&#x2F;www.jpl.nasa.gov&#x2F;edu&#x2F;news&#x2F;2016&#x2F;3&#x2F;16&#x2F;how-many-decimals-of-pi-do-we-really-need&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.jpl.nasa.gov&#x2F;edu&#x2F;news&#x2F;2016&#x2F;3&#x2F;16&#x2F;how-many-decimal...</a>).<p>(And anyway, the distance from any irrational number to the &#x27;nearest&#x27; rational is always infinitessimal, so it&#x27;s generally a moot point unless you&#x27;re doing calculus.)</div><br/></div></div><div id="41150722" class="c"><input type="checkbox" id="c-41150722" checked=""/><div class="controls bullet"><span class="by">llm_trw</span><span>|</span><a href="#41150303">parent</a><span>|</span><a href="#41150714">prev</a><span>|</span><a href="#41150336">next</a><span>|</span><label class="collapse" for="c-41150722">[-]</label><label class="expand" for="c-41150722">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a bit like using a steam hammer to crack a nut.<p>A much simpler way of thinking about it is:<p>What is the chance that if I pick an infinite number of random natural numbers between 0 and 9 that all of them are 0?<p>You&#x27;re missing the repeating fractions but it gets the flavor of what&#x27;s actually happening across much better than a Lebesgue integral.</div><br/></div></div><div id="41150518" class="c"><input type="checkbox" id="c-41150518" checked=""/><div class="controls bullet"><span class="by">rjurney</span><span>|</span><a href="#41150303">parent</a><span>|</span><a href="#41150336">prev</a><span>|</span><a href="#41150804">next</a><span>|</span><label class="collapse" for="c-41150518">[-]</label><label class="expand" for="c-41150518">[9 more]</label></div><br/><div class="children"><div class="content">I got this one without realizing the complex basis for it... there&#x27;s an infinite number of real numbers between 0 and 1, compared with a limited proportion of rational numbers.</div><br/><div id="41150550" class="c"><input type="checkbox" id="c-41150550" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#41150303">root</a><span>|</span><a href="#41150518">parent</a><span>|</span><a href="#41150557">next</a><span>|</span><label class="collapse" for="c-41150550">[-]</label><label class="expand" for="c-41150550">[7 more]</label></div><br/><div class="children"><div class="content">There&#x27;s an infinite number of both.<p>A way to intuit why you have a zero probability of choosing a rational is to consider randomly picking digits one at a time. Suppose you start with a &quot;3&quot;. What is necessary to get one third as your random choice? You must now uniformly randomly select an infinite number of 3s. You can think of that as just a contradiction without much loss here, in that selecting an infinite number of 3s is infinite proof that your process must not be random.<p>(Putting rigor on that might be a challenge but I think it&#x27;s a fine intuition.)<p>This argument similarly holds for any rational, because no matter how large any given rational&#x27;s repeat may be, it is always finite, and in order for that rational to be your choice you have still fully determined the result of a putatively uniformly random process for an infinite number of exact picks, and if it is truly random, the probability of that process producing the exact necessary repeat infinitely is always 0.</div><br/><div id="41150591" class="c"><input type="checkbox" id="c-41150591" checked=""/><div class="controls bullet"><span class="by">kaashif</span><span>|</span><a href="#41150303">root</a><span>|</span><a href="#41150550">parent</a><span>|</span><a href="#41150633">next</a><span>|</span><label class="collapse" for="c-41150591">[-]</label><label class="expand" for="c-41150591">[2 more]</label></div><br/><div class="children"><div class="content">That argument works for any number. The probability of picking any particular number is zero, there&#x27;s nothing special about rationals from that perspective. This has no bearing on the measure of the set as a whole.</div><br/><div id="41150674" class="c"><input type="checkbox" id="c-41150674" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#41150303">root</a><span>|</span><a href="#41150591">parent</a><span>|</span><a href="#41150633">next</a><span>|</span><label class="collapse" for="c-41150674">[-]</label><label class="expand" for="c-41150674">[1 more]</label></div><br/><div class="children"><div class="content">Which is why I very, very explicitly presented it as a way to gain some intuition and not as a rigorous mathematical argument. That wasn&#x27;t an accident.</div><br/></div></div></div></div><div id="41150633" class="c"><input type="checkbox" id="c-41150633" checked=""/><div class="controls bullet"><span class="by">roywiggins</span><span>|</span><a href="#41150303">root</a><span>|</span><a href="#41150550">parent</a><span>|</span><a href="#41150591">prev</a><span>|</span><a href="#41150557">next</a><span>|</span><label class="collapse" for="c-41150633">[-]</label><label class="expand" for="c-41150633">[4 more]</label></div><br/><div class="children"><div class="content">That argument proves too much: you similarly will never pick Pi, or any other irrational. And yet, the probability you pick <i>some</i> irrational is 1.<p>In fact, the probability you pick an <i>uncomputable</i> number is 1, too.</div><br/><div id="41150668" class="c"><input type="checkbox" id="c-41150668" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#41150303">root</a><span>|</span><a href="#41150633">parent</a><span>|</span><a href="#41150557">next</a><span>|</span><label class="collapse" for="c-41150668">[-]</label><label class="expand" for="c-41150668">[3 more]</label></div><br/><div class="children"><div class="content">I agree with you, except your claim that it proves too much. You will indeed never pick pi or any other specific number you can name. I don&#x27;t know if you were trying to say my argument leads to those results you consider absurd, but they are in fact the correct results.<p>One way of interpreting this result is to say that randomly selecting a real number isn&#x27;t physically meaningful and this does not fit into our human brains well. You can do math on the &quot;random number&quot;, but you can&#x27;t ever actually have one in hand (as a sibling comment to yours points out correctly, it is guaranteed to be uncomputable as well), not even mathematically, so you should expect counterintuitive results. Which is generally true of the real numbers when you get close enough to them anyhow. They are popular for a reason but they have rather more spiky bits and strange behaviors than one might expect from a number called &quot;real&quot;.<p>I think both of you may be thinking of &quot;random number&quot; as something like what you get out of a RNG or something, but random reals are much stranger than random ints from a finite range.</div><br/><div id="41150698" class="c"><input type="checkbox" id="c-41150698" checked=""/><div class="controls bullet"><span class="by">roywiggins</span><span>|</span><a href="#41150303">root</a><span>|</span><a href="#41150668">parent</a><span>|</span><a href="#41150842">next</a><span>|</span><label class="collapse" for="c-41150698">[-]</label><label class="expand" for="c-41150698">[1 more]</label></div><br/><div class="children"><div class="content">No, I mean that if you start with &quot;you won&#x27;t land on any given rational&quot; and sum that up to mean &quot;you land on any rationals&quot;, that argument also seems to prove that you can&#x27;t ever land on any <i>irrationals</i> either, so as an intuitive argument it doesn&#x27;t really point toward why you&#x27;ll always land on an irrational and not a rational.<p>(&quot;You&#x27;ll never land on Pi because the odds of picking out the infinitely many digits is zero&quot;- repeat that for every irrational, and naively sum that up, and it looks like you&#x27;ll never land on an irrational either, which is not true.)</div><br/></div></div><div id="41150842" class="c"><input type="checkbox" id="c-41150842" checked=""/><div class="controls bullet"><span class="by">scarmig</span><span>|</span><a href="#41150303">root</a><span>|</span><a href="#41150668">parent</a><span>|</span><a href="#41150698">prev</a><span>|</span><a href="#41150557">next</a><span>|</span><label class="collapse" for="c-41150842">[-]</label><label class="expand" for="c-41150842">[1 more]</label></div><br/><div class="children"><div class="content">Suppose you construct a fat Cantor set of measure 0.5. You then select a random real from [0,1]. Similar to the rationals, any particular number in the fat Cantor set has zero chance of being selected. Does that mean that the chance of selecting a member of that set is 0?</div><br/></div></div></div></div></div></div></div></div><div id="41150557" class="c"><input type="checkbox" id="c-41150557" checked=""/><div class="controls bullet"><span class="by">Quekid5</span><span>|</span><a href="#41150303">root</a><span>|</span><a href="#41150518">parent</a><span>|</span><a href="#41150550">prev</a><span>|</span><a href="#41150804">next</a><span>|</span><label class="collapse" for="c-41150557">[-]</label><label class="expand" for="c-41150557">[1 more]</label></div><br/><div class="children"><div class="content">EDIT: Honestly, just read the wiki article on Cantor&#x27;s Diagonal Argument[0].<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cantor&#x27;s_diagonal_argument" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cantor&#x27;s_diagonal_argument</a></div><br/></div></div></div></div></div></div><div id="41150804" class="c"><input type="checkbox" id="c-41150804" checked=""/><div class="controls bullet"><span class="by">nlewycky</span><span>|</span><a href="#41150303">prev</a><span>|</span><a href="#41151731">next</a><span>|</span><label class="collapse" for="c-41150804">[-]</label><label class="expand" for="c-41150804">[1 more]</label></div><br/><div class="children"><div class="content">From the abstract, &quot;simulations of such systems are usually done on digital computers, which are able to compute with finite sequences of rational numbers only.&quot;<p>Not at all! Digital computers can use computable reals which are defined as any function from a rational value (the error bound) to a rational value which is within the supplied error-bounds from the true value. Do not mistake this for computing in the rationals, these functions which perform the described task are the computable real numbers. There are countable-infinity many of these functions, one for each computable real. For instance, note that you can always compare two rationals for equality, but you can&#x27;t always compare two computable reals for equality, just like reals.<p>Hans Boehm (of Boehm garbage collector fame) has been working on this for a long time, here is a recent paper on it: <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;3385412.3386037" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;3385412.3386037</a></div><br/></div></div><div id="41151731" class="c"><input type="checkbox" id="c-41151731" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41150804">prev</a><span>|</span><a href="#41150172">next</a><span>|</span><label class="collapse" for="c-41151731">[-]</label><label class="expand" for="c-41151731">[1 more]</label></div><br/><div class="children"><div class="content">Most fractal functions don&#x27;t have a well-defined derivative. If the length of the fractal curve increases indefinitely as you zoom in, the concept of a local slope is not meaningful. More direction changes appear as you zoom in.<p>Is there more to this result than that observation?</div><br/></div></div><div id="41150172" class="c"><input type="checkbox" id="c-41150172" checked=""/><div class="controls bullet"><span class="by">ekez</span><span>|</span><a href="#41151731">prev</a><span>|</span><a href="#41150439">next</a><span>|</span><label class="collapse" for="c-41150172">[-]</label><label class="expand" for="c-41150172">[14 more]</label></div><br/><div class="children"><div class="content">why is it impossible to decide whether x&lt;0, x=0, or x&gt;0 as in Example 1?</div><br/><div id="41150263" class="c"><input type="checkbox" id="c-41150263" checked=""/><div class="controls bullet"><span class="by">fgdorais</span><span>|</span><a href="#41150172">parent</a><span>|</span><a href="#41150206">next</a><span>|</span><label class="collapse" for="c-41150263">[-]</label><label class="expand" for="c-41150263">[1 more]</label></div><br/><div class="children"><div class="content">This is better known as the Table Maker&#x27;s Dilemma.<p>Say you have some computable number p, that means you can compute a (rational) approximation p&#x27; to p within any given tolerance eps &gt; 0 (i.e. you know |p - p&#x27;| &lt; eps). To determine whether p &gt; 0, p = 0, or p &lt; 0, you compute an approximation p&#x27; to a certain tolerance eps. If p&#x27; &gt; eps then you know p &gt; 0, if p &lt; -eps then you know p &lt; 0, otherwise you need a better approximation... Without further knowledge about p, there is no point where you can assert p = 0.</div><br/></div></div><div id="41150206" class="c"><input type="checkbox" id="c-41150206" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#41150172">parent</a><span>|</span><a href="#41150263">prev</a><span>|</span><a href="#41150519">next</a><span>|</span><label class="collapse" for="c-41150206">[-]</label><label class="expand" for="c-41150206">[11 more]</label></div><br/><div class="children"><div class="content">Only x=0 is undecidable.  It&#x27;s because you have to check an infinite number of digits past the decimal point to see if all of them are zero, and that will not halt.</div><br/><div id="41150239" class="c"><input type="checkbox" id="c-41150239" checked=""/><div class="controls bullet"><span class="by">teraflop</span><span>|</span><a href="#41150172">root</a><span>|</span><a href="#41150206">parent</a><span>|</span><a href="#41150519">next</a><span>|</span><label class="collapse" for="c-41150239">[-]</label><label class="expand" for="c-41150239">[10 more]</label></div><br/><div class="children"><div class="content">&gt; Only x=0 is undecidable.<p>That cannot be true, because if both x&lt;0 and x&gt;0 are decidable then x=0 is also decidable.</div><br/><div id="41150305" class="c"><input type="checkbox" id="c-41150305" checked=""/><div class="controls bullet"><span class="by">nyrikki</span><span>|</span><a href="#41150172">root</a><span>|</span><a href="#41150239">parent</a><span>|</span><a href="#41150356">next</a><span>|</span><label class="collapse" for="c-41150305">[-]</label><label class="expand" for="c-41150305">[5 more]</label></div><br/><div class="children"><div class="content">Equality of real numbers is undecidable.  Specifically recursively undecidable, which is the same as uncomputable.<p>The Real numbers are topologically weird when you dig into it.<p>Random example.<p><a href="https:&#x2F;&#x2F;mathworld.wolfram.com&#x2F;RichardsonsTheorem.html" rel="nofollow">https:&#x2F;&#x2F;mathworld.wolfram.com&#x2F;RichardsonsTheorem.html</a></div><br/><div id="41150340" class="c"><input type="checkbox" id="c-41150340" checked=""/><div class="controls bullet"><span class="by">teraflop</span><span>|</span><a href="#41150172">root</a><span>|</span><a href="#41150305">parent</a><span>|</span><a href="#41150356">next</a><span>|</span><label class="collapse" for="c-41150340">[-]</label><label class="expand" for="c-41150340">[4 more]</label></div><br/><div class="children"><div class="content">I agree that given two computable real numbers x,y, asking whether x=y is undecidable.<p>The point I&#x27;m making is that it can&#x27;t be true that x&lt;y or x&gt;y are decidable, because then x=y would also be decidable, and it isn&#x27;t.</div><br/><div id="41150498" class="c"><input type="checkbox" id="c-41150498" checked=""/><div class="controls bullet"><span class="by">nyrikki</span><span>|</span><a href="#41150172">root</a><span>|</span><a href="#41150340">parent</a><span>|</span><a href="#41150356">next</a><span>|</span><label class="collapse" for="c-41150498">[-]</label><label class="expand" for="c-41150498">[3 more]</label></div><br/><div class="children"><div class="content">A computable number is real number that can be computed to by a finite, terminating algorithm.<p>x&lt;y meets that definition because you can compare digits until one doesn&#x27;t match.<p>The same can be done for not equal, testing until there is a difference.<p>Real real numbers are infinite precision.<p>Showing that a number is not, not equal always requires you to normalize, truncate etc...<p>No matter how many digits you test, there is an uncountable infinity of real numbers between you epsilon.<p>That means you do not have a finite terminating algorithm.</div><br/><div id="41151685" class="c"><input type="checkbox" id="c-41151685" checked=""/><div class="controls bullet"><span class="by">WithinReason</span><span>|</span><a href="#41150172">root</a><span>|</span><a href="#41150498">parent</a><span>|</span><a href="#41150664">next</a><span>|</span><label class="collapse" for="c-41151685">[-]</label><label class="expand" for="c-41151685">[1 more]</label></div><br/><div class="children"><div class="content">What if you want to decide if x&lt;y when actually x==y? Then your comparator doesn&#x27;t halt.</div><br/></div></div><div id="41150664" class="c"><input type="checkbox" id="c-41150664" checked=""/><div class="controls bullet"><span class="by">nequo</span><span>|</span><a href="#41150172">root</a><span>|</span><a href="#41150498">parent</a><span>|</span><a href="#41151685">prev</a><span>|</span><a href="#41150356">next</a><span>|</span><label class="collapse" for="c-41150664">[-]</label><label class="expand" for="c-41150664">[1 more]</label></div><br/><div class="children"><div class="content">Is x &lt; y decidable or semidecidable?<p>If x and y are the same number, then a Turing machine that compares the digits of x and y to determine whether x &lt; y will never terminate. Doesnât this mean that x &lt; y is not decidable?</div><br/></div></div></div></div></div></div></div></div><div id="41150356" class="c"><input type="checkbox" id="c-41150356" checked=""/><div class="controls bullet"><span class="by">mgsouth</span><span>|</span><a href="#41150172">root</a><span>|</span><a href="#41150239">parent</a><span>|</span><a href="#41150305">prev</a><span>|</span><a href="#41150752">next</a><span>|</span><label class="collapse" for="c-41150356">[-]</label><label class="expand" for="c-41150356">[1 more]</label></div><br/><div class="children"><div class="content">Haven&#x27;t seen the paper, but I&#x27;d guess the argument is something like &quot;if the domain for x includes 0, then [edit: whenever x = 0] the Turing machine will get into an infinite loop looking for the first inverted bit[1]. _None_ of the three states will ever be provably true or false. If the domain _excludes_ 0 then you can prove that the machine will hit a non-zero bit in finite time, thus terminate, and either x&lt;0 or x&gt;0 will be shown true. But if you exclude 0 then you&#x27;ve also shown that the =0 state will never be true.&quot;<p>[1] multiple zero bits and a one bit is &gt;0, multiple 1 bits and a zero bit is &lt;0. Infinite zero bits (even if followed by a one bit) is +0, infinite 1 bits (even if followed by a zero bit) is -0.</div><br/></div></div><div id="41150752" class="c"><input type="checkbox" id="c-41150752" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41150172">root</a><span>|</span><a href="#41150239">parent</a><span>|</span><a href="#41150356">prev</a><span>|</span><a href="#41150267">next</a><span>|</span><label class="collapse" for="c-41150752">[-]</label><label class="expand" for="c-41150752">[1 more]</label></div><br/><div class="children"><div class="content">An <i>exact</i> comparison is undecidable. You can only say if the numbers <i>sufficiently</i> differ. This  is equivalent to saying that <i>x &gt; 0 + Îµ</i> or <i>x &lt; 0 - Îµ</i>, where <i>Îµ &gt; 0</i>. If you represent numbers in binary, <i>Îµ = 2^(-n)</i>, where <i>n</i> is the maximum number of bits you allocate to represent a number. Obviously you have <i>n &lt; â</i> in any finite machine.</div><br/></div></div><div id="41150267" class="c"><input type="checkbox" id="c-41150267" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#41150172">root</a><span>|</span><a href="#41150239">parent</a><span>|</span><a href="#41150752">prev</a><span>|</span><a href="#41150519">next</a><span>|</span><label class="collapse" for="c-41150267">[-]</label><label class="expand" for="c-41150267">[2 more]</label></div><br/><div class="children"><div class="content">Nope.  You&#x27;re thinking about this mathematically, not algorithmically.  The question is essentially to decide whether the output of a TM is all zeros or whether it will eventually output a 1.  If it outputs a 1 you will know that in a finite amount of time by running the program, but if it never outputs a 1 then you can&#x27;t tell that by running the program, and it&#x27;s impossible in general to tell any other way because that would be tantamount to solving the halting problem.<p>Here is a concrete example: write a program that systematically tests all numbers for counterexamples to the Goldback conjecture.  Every time a number fails to be a counterexample, output a zero, otherwise output a 1.  Consider the output of that program to be a real number expressed as a binary decimal.  If that number is not zero you will know in a finite amount of time, but if it is zero you will not know that until someone proves the Goldbach conjecture.</div><br/><div id="41150334" class="c"><input type="checkbox" id="c-41150334" checked=""/><div class="controls bullet"><span class="by">teraflop</span><span>|</span><a href="#41150172">root</a><span>|</span><a href="#41150267">parent</a><span>|</span><a href="#41150519">next</a><span>|</span><label class="collapse" for="c-41150334">[-]</label><label class="expand" for="c-41150334">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Nope. You&#x27;re thinking about this mathematically, not algorithmically.<p>I don&#x27;t know what you mean by this, and I&#x27;m not sure how it relates to what I said. I&#x27;m using &quot;decidable&quot; in the strict, computer-science sense of the word.<p>The statement in example 1 of the paper, which we&#x27;re discussing, is about computable <i>real numbers</i>. A computable real number is one for which there is a Turing machine that can calculate it to any desired finite precision in finite time.<p>A <i>semidecidable</i> problem is one for which there is a program that halts if the answer is &quot;yes&quot;, but may not halt if the answer is &quot;no&quot;. The halting problem is in this category.<p>Given a computable real number x, asking whether x&lt;0 or x&gt;0 are semidecidable but not decidable problems.</div><br/></div></div></div></div></div></div></div></div><div id="41150519" class="c"><input type="checkbox" id="c-41150519" checked=""/><div class="controls bullet"><span class="by">scarmig</span><span>|</span><a href="#41150172">parent</a><span>|</span><a href="#41150206">prev</a><span>|</span><a href="#41150439">next</a><span>|</span><label class="collapse" for="c-41150519">[-]</label><label class="expand" for="c-41150519">[1 more]</label></div><br/><div class="children"><div class="content">x &gt; 0 and x &lt; 0 are both semidecidable. Which is to say, they can be decided, but their converses cannot. So if either of those are true, they will halt (by running them in parallel, and halting once one halts), but if neither of them are, it may not halt.<p>If you remove 0 from possible inputs, you no longer need to worry about that possibility, and the problem is then decidable.</div><br/></div></div></div></div><div id="41150439" class="c"><input type="checkbox" id="c-41150439" checked=""/><div class="controls bullet"><span class="by">transfire</span><span>|</span><a href="#41150172">prev</a><span>|</span><a href="#41150168">next</a><span>|</span><label class="collapse" for="c-41150439">[-]</label><label class="expand" for="c-41150439">[1 more]</label></div><br/><div class="children"><div class="content">I havenât read the whole article yet, but Iâm guessing it boils down to a Halting Problem?<p>And I assume if a Turing machine canât, neither can a human. If that is not the case, something smells fishy in Denmark.</div><br/></div></div><div id="41150168" class="c"><input type="checkbox" id="c-41150168" checked=""/><div class="controls bullet"><span class="by">BraveNewCurency</span><span>|</span><a href="#41150439">prev</a><span>|</span><a href="#41150193">next</a><span>|</span><label class="collapse" for="c-41150168">[-]</label><label class="expand" for="c-41150168">[9 more]</label></div><br/><div class="children"><div class="content">All models are wrong. Some (wrong) models are useful.<p>Computers can&#x27;t represent 0.1 (in floating point), yet that hasn&#x27;t stopped anyone from doing finances on their computer.<p>I don&#x27;t think this is big news OR a parlor trick. It&#x27;s just some obscure thing computers can&#x27;t do that nobody has noticed for 70 years because nobody needed it.</div><br/><div id="41150196" class="c"><input type="checkbox" id="c-41150196" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#41150168">parent</a><span>|</span><a href="#41150396">next</a><span>|</span><label class="collapse" for="c-41150196">[-]</label><label class="expand" for="c-41150196">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Computers can&#x27;t represent 0.1 (in floating point)<p>Of course they can.  They just can&#x27;t do it in <i>binary</i> [EDIT: base 2].  But they can certainly do it in (say) BCD [EDIT: base 10].</div><br/><div id="41150212" class="c"><input type="checkbox" id="c-41150212" checked=""/><div class="controls bullet"><span class="by">brewmarche</span><span>|</span><a href="#41150168">root</a><span>|</span><a href="#41150196">parent</a><span>|</span><a href="#41150276">next</a><span>|</span><label class="collapse" for="c-41150212">[-]</label><label class="expand" for="c-41150212">[1 more]</label></div><br/><div class="children"><div class="content">.NETâs decimal datatype for example represents a decimal floating point number</div><br/></div></div><div id="41150276" class="c"><input type="checkbox" id="c-41150276" checked=""/><div class="controls bullet"><span class="by">pvg</span><span>|</span><a href="#41150168">root</a><span>|</span><a href="#41150196">parent</a><span>|</span><a href="#41150212">prev</a><span>|</span><a href="#41150396">next</a><span>|</span><label class="collapse" for="c-41150276">[-]</label><label class="expand" for="c-41150276">[4 more]</label></div><br/><div class="children"><div class="content">Just as a total pedantipoint, they also do that in binary (hence the B in BCD, in that specific case).</div><br/><div id="41150311" class="c"><input type="checkbox" id="c-41150311" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#41150168">root</a><span>|</span><a href="#41150276">parent</a><span>|</span><a href="#41150396">next</a><span>|</span><label class="collapse" for="c-41150311">[-]</label><label class="expand" for="c-41150311">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve updated my comment with appropriate pedantedits.</div><br/><div id="41151025" class="c"><input type="checkbox" id="c-41151025" checked=""/><div class="controls bullet"><span class="by">BraveNewCurency</span><span>|</span><a href="#41150168">root</a><span>|</span><a href="#41150311">parent</a><span>|</span><a href="#41150396">next</a><span>|</span><label class="collapse" for="c-41151025">[-]</label><label class="expand" for="c-41151025">[2 more]</label></div><br/><div class="children"><div class="content">But BCD is not floating point (generally shorthand for the IEEE 754 Floating Point standard, which nearly every CPU and GPU have hardware support for). And I don&#x27;t know much about BCD, but it is probably missing niceties like NaN and Inf for capturing edge cases that happen deep inside your equations. These matter if your system is to be reliable.</div><br/><div id="41151724" class="c"><input type="checkbox" id="c-41151724" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#41150168">root</a><span>|</span><a href="#41151025">parent</a><span>|</span><a href="#41150396">next</a><span>|</span><label class="collapse" for="c-41151724">[-]</label><label class="expand" for="c-41151724">[1 more]</label></div><br/><div class="children"><div class="content">&gt; generally shorthand for the IEEE 754 Floating Point standard<p>Yes, <i>generally</i>, but that is just a social convention.  There is nothing stopping you from doing floating point in base 10 rather than base 2, and if you do, 0.1 becomes representable exactly.  It&#x27;s just a quirk that 1&#x2F;10 happens to be a repeating decimal in base 2.  It is in no way a reflection of a limitation on computation.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41150396" class="c"><input type="checkbox" id="c-41150396" checked=""/><div class="controls bullet"><span class="by">TacticalCoder</span><span>|</span><a href="#41150168">parent</a><span>|</span><a href="#41150196">prev</a><span>|</span><a href="#41150268">next</a><span>|</span><label class="collapse" for="c-41150396">[-]</label><label class="expand" for="c-41150396">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Computers can&#x27;t represent 0.1 (in floating point), yet that hasn&#x27;t stopped anyone from doing finances on their computer.<p>floating point for financial data may have made sense back when my 386 DX CPU has a FP coprocessor and computation were dog slow.<p>In this day and age though you&#x27;ll typically be not just a bit but much better using an abstraction that can represent numbers with decimals precisely, which frees you from a great many rounding error, epsilon computation, error propagation, etc.</div><br/></div></div></div></div></div></div></div></div></div></body></html>