<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1733130057877" as="style"/><link rel="stylesheet" href="styles.css?v=1733130057877"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://docs.racket-lang.org/ctp/index.html">Category Theory in Programming</a> <span class="domain">(<a href="https://docs.racket-lang.org">docs.racket-lang.org</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>47 comments</span></div><br/><div><div id="42291655" class="c"><input type="checkbox" id="c-42291655" checked=""/><div class="controls bullet"><span class="by">jmugan</span><span>|</span><a href="#42292857">next</a><span>|</span><label class="collapse" for="c-42291655">[-]</label><label class="expand" for="c-42291655">[36 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve gone down this rabbit hole a few times, and I always return pissed off and a dozen hours poorer. Maybe someday I&#x27;ll get it.</div><br/><div id="42292840" class="c"><input type="checkbox" id="c-42292840" checked=""/><div class="controls bullet"><span class="by">j2kun</span><span>|</span><a href="#42291655">parent</a><span>|</span><a href="#42291999">next</a><span>|</span><label class="collapse" for="c-42292840">[-]</label><label class="expand" for="c-42292840">[4 more]</label></div><br/><div class="children"><div class="content">The main problem is that category theorists keep writing stuff claiming that, if only you get through the math, you&#x27;ll eventually be able to apply the category theory to typical everyday programming problems. And by the time they get to the Yoneda lemma or whatever, they&#x27;ve forgotten they&#x27;re supposed to show some applications. All they show is how to express category theoretical concepts in a program. And it is mostly because the demonstrated applications are few (I have spent a lot of time looking and have found little convincing evidence).<p>Having learned the subject myself, I&#x27;m not convinced it&#x27;s useful for programmers. Hell, it&#x27;s not even useful for all areas of mathematics, and that is its raison d&#x27;etre.</div><br/><div id="42293259" class="c"><input type="checkbox" id="c-42293259" checked=""/><div class="controls bullet"><span class="by">wenc</span><span>|</span><a href="#42291655">root</a><span>|</span><a href="#42292840">parent</a><span>|</span><a href="#42293216">next</a><span>|</span><label class="collapse" for="c-42293259">[-]</label><label class="expand" for="c-42293259">[1 more]</label></div><br/><div class="children"><div class="content">I often go back to this post by John D Cook. Quote below:
<a href="https:&#x2F;&#x2F;www.johndcook.com&#x2F;blog&#x2F;applied-category-theory&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.johndcook.com&#x2F;blog&#x2F;applied-category-theory&#x2F;</a><p><pre><code>    Category theory can be very useful, but you don’t use it the same way you use other kinds of math. You can apply optimization theory, for example, by noticing that a problem has a certain form, and therefore a certain algorithm will converge to a solution. Applications of category theory are usually more subtle. You’re not likely to quote some theorem from category theory that finishes off a problem the way the selecting an optimization algorithm does.

    I had been skeptical of applications of category theory, and to some extent I still am. Many reported applications of category theory aren’t that applied, and they’re not so much applications as post hoc glosses.

    At the same time, I’ve seen real applications of categories, such as the design of LINQ mentioned above. I’ve been a part of projects where we used category theory to guide mathematical modeling and software development. Category theory can spot inconsistencies and errors similar to the way dimensional analysis does in engineering, or type checking in software development. It can help you ask the right questions. It can guide you to including the right things, and leaving the right things out.

</code></pre>
Category theory in LINQ<p><a href="https:&#x2F;&#x2F;queue.acm.org&#x2F;detail.cfm?id=2024658" rel="nofollow">https:&#x2F;&#x2F;queue.acm.org&#x2F;detail.cfm?id=2024658</a></div><br/></div></div><div id="42293216" class="c"><input type="checkbox" id="c-42293216" checked=""/><div class="controls bullet"><span class="by">endgame</span><span>|</span><a href="#42291655">root</a><span>|</span><a href="#42292840">parent</a><span>|</span><a href="#42293259">prev</a><span>|</span><a href="#42293859">next</a><span>|</span><label class="collapse" for="c-42293216">[-]</label><label class="expand" for="c-42293216">[1 more]</label></div><br/><div class="children"><div class="content">This two-part keynote might give you a good flavour:<p>* <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=4WMfKhKKVN4" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=4WMfKhKKVN4</a><p>* <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=zooYfk5-yPY" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=zooYfk5-yPY</a><p>If you can stand up a Cartesian-closed category, it is a model of a lambda calculus. So you can make a compiler plugin that takes lambda terms (a large subset of Haskell) and compiles it into all sorts of exotic settings (dataflow diagrams, derivatives of the function, ...)<p>KittyHawk used it to compile Haskell to C in <a href="https:&#x2F;&#x2F;github.com&#x2F;sellout&#x2F;compiling-anything-to-categories">https:&#x2F;&#x2F;github.com&#x2F;sellout&#x2F;compiling-anything-to-categories</a> and someone talks about their work here: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=VUBj8NW7uMA" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=VUBj8NW7uMA</a></div><br/></div></div><div id="42293859" class="c"><input type="checkbox" id="c-42293859" checked=""/><div class="controls bullet"><span class="by">roenxi</span><span>|</span><a href="#42291655">root</a><span>|</span><a href="#42292840">parent</a><span>|</span><a href="#42293216">prev</a><span>|</span><a href="#42291999">next</a><span>|</span><label class="collapse" for="c-42293859">[-]</label><label class="expand" for="c-42293859">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Having learned the subject myself, I&#x27;m not convinced it&#x27;s useful for programmers.<p>I think it is demonstrably useful to people who design programming languages with strong type systems. Not a very common use case in practice, but it did find an application. Damned with faint praise, perhaps. I haven&#x27;t seen anyone demonstrate a use outside that niche.</div><br/></div></div></div></div><div id="42291999" class="c"><input type="checkbox" id="c-42291999" checked=""/><div class="controls bullet"><span class="by">Ericson2314</span><span>|</span><a href="#42291655">parent</a><span>|</span><a href="#42292840">prev</a><span>|</span><a href="#42291689">next</a><span>|</span><label class="collapse" for="c-42291999">[-]</label><label class="expand" for="c-42291999">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s hard to write something that is both accessible and well-motivated.<p>The best uses of category theory is when the morphisms are far more exotic than &quot;regular functions&quot;. E.g. it would be nice to describe a circuit of live queries (like <a href="https:&#x2F;&#x2F;materialize.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;materialize.com&#x2F;</a> stuff) with proper caching, joins, etc. Figuring this out is a bit of an open problem.<p>Haskell&#x27;s standard library&#x27;s Monad and stuff are watered down to the point that they are barely category theory, but they are also quite useful and would not have been readily invented without category theory. See even if you have no taste for &quot;abstract nonsense&quot;, maybe you can still accept the fact that its left a trail of more accessible &quot;semi-abstract semi-nonsense&quot; in its wake.<p>This stuff takes time. If it&#x27;s not your cup of tea, no need to make yourself an early adopter. See also things like Lean where fancy type systems are finally reaching &quot;regular non-CS&quot; mathematicians with great success.</div><br/><div id="42292017" class="c"><input type="checkbox" id="c-42292017" checked=""/><div class="controls bullet"><span class="by">Ericson2314</span><span>|</span><a href="#42291655">root</a><span>|</span><a href="#42291999">parent</a><span>|</span><a href="#42292786">next</a><span>|</span><label class="collapse" for="c-42292017">[-]</label><label class="expand" for="c-42292017">[2 more]</label></div><br/><div class="children"><div class="content">On the pure math side, Locales (<a href="https:&#x2F;&#x2F;ncatlab.org&#x2F;nlab&#x2F;show&#x2F;locale" rel="nofollow">https:&#x2F;&#x2F;ncatlab.org&#x2F;nlab&#x2F;show&#x2F;locale</a>) are <i>so much more beautiful</i> an axiomatization scheme than regular topological spaces, even if one is just doing regular classical rather than constructive math. We would have not discovered them except for category theory.</div><br/><div id="42292277" class="c"><input type="checkbox" id="c-42292277" checked=""/><div class="controls bullet"><span class="by">Ericson2314</span><span>|</span><a href="#42291655">root</a><span>|</span><a href="#42292017">parent</a><span>|</span><a href="#42292786">next</a><span>|</span><label class="collapse" for="c-42292277">[-]</label><label class="expand" for="c-42292277">[1 more]</label></div><br/><div class="children"><div class="content">I would also check out <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Algebraic_logic#Algebras_as_models_of_logics" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Algebraic_logic#Algebras_as_mo...</a><p>The basic (pre-category theory) idea is instead of making up new weird math just for logical purposes, start thinking more abstractly and using &quot;regular&quot; math concepts. The section says &quot;models&quot; but it should work for syntax too not just semantics (the syntax is the &quot;initial&quot; semantics).<p>Category theory takes all that order&#x2F;lattice stuff and generalizes it in the same way programming generalizes logic (&quot;whether&quot; true&#x2F;false to &quot;which&quot; inhabitant of a type). So it is definitely useful for people trying to explore the space of programming language designs.<p>The reason category theory might be useful to &quot;regular programmers&quot; not programming language designers, basically boils down to the belief that programming and language design are not so different after all. I can&#x27;t really argue that explicitly, but think &quot;where does designing a library interface end, and designing a domain-specific language being?&quot;. That&#x27;s the basic idea.</div><br/></div></div></div></div><div id="42292786" class="c"><input type="checkbox" id="c-42292786" checked=""/><div class="controls bullet"><span class="by">dustingetz</span><span>|</span><a href="#42291655">root</a><span>|</span><a href="#42291999">parent</a><span>|</span><a href="#42292017">prev</a><span>|</span><a href="#42291689">next</a><span>|</span><label class="collapse" for="c-42292786">[-]</label><label class="expand" for="c-42292786">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;hyperfiddle&#x2F;electric">https:&#x2F;&#x2F;github.com&#x2F;hyperfiddle&#x2F;electric</a></div><br/></div></div></div></div><div id="42291689" class="c"><input type="checkbox" id="c-42291689" checked=""/><div class="controls bullet"><span class="by">analog31</span><span>|</span><a href="#42291655">parent</a><span>|</span><a href="#42291999">prev</a><span>|</span><a href="#42291699">next</a><span>|</span><label class="collapse" for="c-42291689">[-]</label><label class="expand" for="c-42291689">[3 more]</label></div><br/><div class="children"><div class="content">I was a college math major. Category theory wasn&#x27;t one of the offered courses at my college, so I didn&#x27;t study it specifically. But I didn&#x27;t get through any of my math classes without working the problems and proofs, and without having a teacher to help guide me through the material. It can&#x27;t be read like a book. At least that&#x27;s my experience.<p>And as I get older, being <i>interested</i> in the topic helps more and more.</div><br/><div id="42293480" class="c"><input type="checkbox" id="c-42293480" checked=""/><div class="controls bullet"><span class="by">kqr</span><span>|</span><a href="#42291655">root</a><span>|</span><a href="#42291689">parent</a><span>|</span><a href="#42293301">next</a><span>|</span><label class="collapse" for="c-42293480">[-]</label><label class="expand" for="c-42293480">[1 more]</label></div><br/><div class="children"><div class="content">As a counterexample, I have self-studied queuing theory, extreme value analysis, combinatorics, generalised linear regression, etc. and had no problem with it.<p>Category theory I just can&#x27;t get through. Either it does not fit with my brain or I fail to see the practical implications, but something makes it not stick.<p>(Curiously, differential equations (beyond the basics) are in a similar spot for me, even though they are obviously immediately practical in a huge number of areas!)</div><br/></div></div><div id="42293301" class="c"><input type="checkbox" id="c-42293301" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#42291655">root</a><span>|</span><a href="#42291689">parent</a><span>|</span><a href="#42293480">prev</a><span>|</span><a href="#42291699">next</a><span>|</span><label class="collapse" for="c-42293301">[-]</label><label class="expand" for="c-42293301">[1 more]</label></div><br/><div class="children"><div class="content">This is the only right attitude. Thank you for saying it.</div><br/></div></div></div></div><div id="42291699" class="c"><input type="checkbox" id="c-42291699" checked=""/><div class="controls bullet"><span class="by">ferfumarma</span><span>|</span><a href="#42291655">parent</a><span>|</span><a href="#42291689">prev</a><span>|</span><a href="#42293180">next</a><span>|</span><label class="collapse" for="c-42291699">[-]</label><label class="expand" for="c-42291699">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s such an amazing description of my experience as well. I find the topic inscrutable.</div><br/></div></div><div id="42293180" class="c"><input type="checkbox" id="c-42293180" checked=""/><div class="controls bullet"><span class="by">weitendorf</span><span>|</span><a href="#42291655">parent</a><span>|</span><a href="#42291699">prev</a><span>|</span><a href="#42292250">next</a><span>|</span><label class="collapse" for="c-42293180">[-]</label><label class="expand" for="c-42293180">[1 more]</label></div><br/><div class="children"><div class="content">Even though I went pretty deep in math&#x2F;cs in college and worked as a SWE for five years, I never really &quot;got&quot; the connection between category theory and actual practical software problems until I started working on a new project with complex uses of types and functional programming. IMO most programmers are not working on projects like that where category theory is even relevant. And for me even though it was relevant, other than being to identify something by its category theory vocab term, it wasn&#x27;t really helpful to actually know category theory.<p>Also, you probably should study axiomatic set theory and abstract algebra before taking on category theory and even in materials like this where they try to bring you up to speed on them, you&#x27;ll not have had the exposure time to those subjects (or perhaps higher math in general) to understand things well. You&#x27;ll also skip over stuff like <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Multiplicative_group_of_integers_modulo_n#Group_axioms" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Multiplicative_group_of_intege...</a> which aren&#x27;t category theory per se but prime your brain into thinking about the properties of sets, relations within&#x2F;between sets, and repeatable &quot;structures&quot; across sets.<p>The other problem I ran into is that most programming languages do not have sophisticated enough type&#x2F;functional systems to be able to properly implement a lot of fancy stuff where category theory is relevant. For example, even though typescript had all the information necessary to know that class A is abstract and B extends it, or that class C is templatized by types subject to some constraint, it can&#x27;t at compile time implement a lot of checks that it technically should to handle Functors (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Functor_(functional_programming)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Functor_(functional_programmin...</a>). The languages that do handle these things properly are typically lacking in other ways that made them not worth it (for me) to use - it was better to handle the problem inelegantly in the less sophisticated language.</div><br/></div></div><div id="42292250" class="c"><input type="checkbox" id="c-42292250" checked=""/><div class="controls bullet"><span class="by">liontwist</span><span>|</span><a href="#42291655">parent</a><span>|</span><a href="#42293180">prev</a><span>|</span><a href="#42291872">next</a><span>|</span><label class="collapse" for="c-42292250">[-]</label><label class="expand" for="c-42292250">[5 more]</label></div><br/><div class="children"><div class="content">Category theory is a great tool for thinking about programming language design (especially types in functional programming). In some sense that translates to better programming, but there’s a lot more math topics that are likely to be directly applicable day to day.<p>Do you know how to evaluate a polynomial efficiently? Fit a curve to points? Solve a linear system? What the Fourier transform is for? If no, hold off on the categories.</div><br/><div id="42292990" class="c"><input type="checkbox" id="c-42292990" checked=""/><div class="controls bullet"><span class="by">prakashrj</span><span>|</span><a href="#42291655">root</a><span>|</span><a href="#42292250">parent</a><span>|</span><a href="#42291872">next</a><span>|</span><label class="collapse" for="c-42292990">[-]</label><label class="expand" for="c-42292990">[4 more]</label></div><br/><div class="children"><div class="content">Is Bézier curves not enough to fit curve to points? Just checking as I am very curious about this problem.</div><br/><div id="42294308" class="c"><input type="checkbox" id="c-42294308" checked=""/><div class="controls bullet"><span class="by">HappMacDonald</span><span>|</span><a href="#42291655">root</a><span>|</span><a href="#42292990">parent</a><span>|</span><a href="#42293893">next</a><span>|</span><label class="collapse" for="c-42294308">[-]</label><label class="expand" for="c-42294308">[1 more]</label></div><br/><div class="children"><div class="content">To expand upon roenxi&#x27;s answer: Bezier curves are an example of creating a cubic (degree 3) parametric polynomial curve by using four points to describe where you want it to go.<p>Curve fitting is about starting with a cloud of points, and trying to decide how to draw a polynomial (of whatever degree you want) that does a good job of describing the trend line of those points.<p>Then you can use that polynomial to approximately interpolate points between the samples, or extrapolate points beyond the samples as an example.</div><br/></div></div><div id="42293893" class="c"><input type="checkbox" id="c-42293893" checked=""/><div class="controls bullet"><span class="by">roenxi</span><span>|</span><a href="#42291655">root</a><span>|</span><a href="#42292990">parent</a><span>|</span><a href="#42294308">prev</a><span>|</span><a href="#42293307">next</a><span>|</span><label class="collapse" for="c-42293893">[-]</label><label class="expand" for="c-42293893">[1 more]</label></div><br/><div class="children"><div class="content">Bézier curves parameterise a curve with points. When people talk about &quot;fitting a curve&quot; I would expect they mean fitting a model rather than that the curve is fully determined by the points. Typically people fit linear or low-order polynomials, it&#x27;d be a weird day where someone wanted to use a Bézier for their model - those curves weren&#x27;t designed for being statistically tractable or interesting.<p>See <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Curve_fitting" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Curve_fitting</a></div><br/></div></div><div id="42293307" class="c"><input type="checkbox" id="c-42293307" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#42291655">root</a><span>|</span><a href="#42292990">parent</a><span>|</span><a href="#42293893">prev</a><span>|</span><a href="#42291872">next</a><span>|</span><label class="collapse" for="c-42293307">[-]</label><label class="expand" for="c-42293307">[1 more]</label></div><br/><div class="children"><div class="content">The answer is obviously no, but I’m not the right person to explain (biochemist).<p>For some reason you were downvoted down to oblivion, and I think that was unfair.</div><br/></div></div></div></div></div></div><div id="42291872" class="c"><input type="checkbox" id="c-42291872" checked=""/><div class="controls bullet"><span class="by">agnishom</span><span>|</span><a href="#42291655">parent</a><span>|</span><a href="#42292250">prev</a><span>|</span><a href="#42291761">next</a><span>|</span><label class="collapse" for="c-42291872">[-]</label><label class="expand" for="c-42291872">[1 more]</label></div><br/><div class="children"><div class="content">I feel that the main thing that can change it is having a plethora of examples. Also, I think math has much better examples than programming.</div><br/></div></div><div id="42291761" class="c"><input type="checkbox" id="c-42291761" checked=""/><div class="controls bullet"><span class="by">sega_sai</span><span>|</span><a href="#42291655">parent</a><span>|</span><a href="#42291872">prev</a><span>|</span><a href="#42292869">next</a><span>|</span><label class="collapse" for="c-42291761">[-]</label><label class="expand" for="c-42291761">[4 more]</label></div><br/><div class="children"><div class="content">As a math course, I felt category theory was interesting as a way of unifying ideas across different areas of mathematics. But I never quite seen a value of it for programming (but maybe it&#x27;s just me)</div><br/><div id="42292083" class="c"><input type="checkbox" id="c-42292083" checked=""/><div class="controls bullet"><span class="by">lambdas</span><span>|</span><a href="#42291655">root</a><span>|</span><a href="#42291761">parent</a><span>|</span><a href="#42292070">next</a><span>|</span><label class="collapse" for="c-42292083">[-]</label><label class="expand" for="c-42292083">[1 more]</label></div><br/><div class="children"><div class="content">As primarily an engineer doing maths, with code on the side, I feel the exact same.<p>It’s been way more of use to me in pulling together parts of topology, linear algebra, geometric algebra, homology et al than discovering furtive programming abstractions.</div><br/></div></div><div id="42292070" class="c"><input type="checkbox" id="c-42292070" checked=""/><div class="controls bullet"><span class="by">ants_everywhere</span><span>|</span><a href="#42291655">root</a><span>|</span><a href="#42291761">parent</a><span>|</span><a href="#42292083">prev</a><span>|</span><a href="#42292869">next</a><span>|</span><label class="collapse" for="c-42292070">[-]</label><label class="expand" for="c-42292070">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s IMO the right setting to talk about logic. That&#x27;s one of the reasons it unifies ideas in math.<p>Computer science is mostly an application of logic which is why category theory has become a useful tool in theoretical computer science.</div><br/><div id="42293007" class="c"><input type="checkbox" id="c-42293007" checked=""/><div class="controls bullet"><span class="by">CarpaDorada</span><span>|</span><a href="#42291655">root</a><span>|</span><a href="#42292070">parent</a><span>|</span><a href="#42292869">next</a><span>|</span><label class="collapse" for="c-42293007">[-]</label><label class="expand" for="c-42293007">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re talking about toposes, many logics do not correspond to them. It&#x27;s the other way around: many category theorists&#x2F;logicians needed jobs and found computer jobs and hence the category theoretic perspective in CS.</div><br/></div></div></div></div></div></div><div id="42292869" class="c"><input type="checkbox" id="c-42292869" checked=""/><div class="controls bullet"><span class="by">UltraSane</span><span>|</span><a href="#42291655">parent</a><span>|</span><a href="#42291761">prev</a><span>|</span><a href="#42291724">next</a><span>|</span><label class="collapse" for="c-42292869">[-]</label><label class="expand" for="c-42292869">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. While Category Theory is interesting and the way it can abstract things like the Diagonal argument is very elegant every time I try to learn it I end up feeling I would have been better off learning almost anything else.</div><br/></div></div><div id="42291724" class="c"><input type="checkbox" id="c-42291724" checked=""/><div class="controls bullet"><span class="by">puzzledobserver</span><span>|</span><a href="#42291655">parent</a><span>|</span><a href="#42292869">prev</a><span>|</span><a href="#42292857">next</a><span>|</span><label class="collapse" for="c-42291724">[-]</label><label class="expand" for="c-42291724">[11 more]</label></div><br/><div class="children"><div class="content">I share this experience.<p>Perhaps another way of asking the question is: Are there any results, either about individual programs or in PL theory as a whole, that were made simpler &#x2F; clarified &#x2F; generalized because of category theoretic insights?</div><br/><div id="42291765" class="c"><input type="checkbox" id="c-42291765" checked=""/><div class="controls bullet"><span class="by">throwaway81523</span><span>|</span><a href="#42291655">root</a><span>|</span><a href="#42291724">parent</a><span>|</span><a href="#42293063">next</a><span>|</span><label class="collapse" for="c-42291765">[-]</label><label class="expand" for="c-42291765">[7 more]</label></div><br/><div class="children"><div class="content">Sure, Haskell&#x27;s type system (and type systems in general) are informed by categories:<p><a href="https:&#x2F;&#x2F;en.wikibooks.org&#x2F;wiki&#x2F;Haskell&#x2F;Category_theory" rel="nofollow">https:&#x2F;&#x2F;en.wikibooks.org&#x2F;wiki&#x2F;Haskell&#x2F;Category_theory</a><p>This article is also nice:<p><a href="https:&#x2F;&#x2F;www.haskellforall.com&#x2F;2012&#x2F;08&#x2F;the-category-design-pattern.html" rel="nofollow">https:&#x2F;&#x2F;www.haskellforall.com&#x2F;2012&#x2F;08&#x2F;the-category-design-pa...</a><p>It explins how Haskell&#x27;s monad laws follow directly from how categories work.</div><br/><div id="42292295" class="c"><input type="checkbox" id="c-42292295" checked=""/><div class="controls bullet"><span class="by">BoiledCabbage</span><span>|</span><a href="#42291655">root</a><span>|</span><a href="#42291765">parent</a><span>|</span><a href="#42292026">next</a><span>|</span><label class="collapse" for="c-42292295">[-]</label><label class="expand" for="c-42292295">[3 more]</label></div><br/><div class="children"><div class="content">Yes, but it&#x27;s much, muvh faster and more productivr to just learn Haskell&#x27;s type system (mainly Functors, Monads and Applicatives) as 3 individual &quot;design patterns&quot; than it is to figure it how you can even begin to apply the Yoneda Lemma to whatever programing problem you have in front of you.<p>Category Theory has birthed some useful abstraction, but you don&#x27;t really need any of CT to learn and use the abstractions.<p>The basics of Abstract Algebra on the otherhand are absolutely worth the bit of time it takes to learn them.<p>Groups, semi-groups, rings, fields, monoids - distribution, identity, zeros, associstivity, communitavity are pretty trivia to learn - most people already know the underlying concepts and they pop up all the time in programing.<p>Monoids are <i>incredibly</i> useful - most people already know them, and intuitively use them, but it&#x27;s helpful naming and understanding the pattern.<p>Category Therory just doesn&#x27;t have the same return on investment for software development.</div><br/><div id="42292559" class="c"><input type="checkbox" id="c-42292559" checked=""/><div class="controls bullet"><span class="by">matt-noonan</span><span>|</span><a href="#42291655">root</a><span>|</span><a href="#42292295">parent</a><span>|</span><a href="#42292555">next</a><span>|</span><label class="collapse" for="c-42292559">[-]</label><label class="expand" for="c-42292559">[1 more]</label></div><br/><div class="children"><div class="content">There is a very useful perspective in which categories are just typed monoids, and the monoid operation can only be applied when the types &quot;line up&quot;. For example, here are some useful operations which do not form a monoid:<p>- PUSH(n) where n is a floating-point number<p>- POP<p>- CLEAR<p>- ADD, SUB, MUL, DIV<p>- ID<p>These can be interpreted as operations on a stack of floating-point numbers in the obvious way, PUSH(1.2) * [3.14] == [1.2, 3.14], POP * [1, 2, 3] == [2, 3], ADD * [1, 2, 5] == [3, 5], CLEAR * [1, 2, 3] == [], ID * [1, 2, 3] == [1, 2, 3], etc. However, not all of the compositions of stack operations are legal. For example, ADD * PUSH(1) * PUSH(2) is fine and equivalent to PUSH(3), but ADD * PUSH(1) * CLEAR is illegal.<p>Ok, so our stack operations don&#x27;t form a monoid. But they obviously can still be composed, sometimes, so what do we have if not a monoid? They form a category! There is one object for each natural number, representing the height of the stack. So there are arrows like PUSH(3.14) : Height_{n} -&gt; Height_{n+1} for all n, and POP : Height_{n} -&gt; Height_{n-1} whenever n &gt;= 1, and ADD : Height_{n} -&gt; Height_{n-2} whenever n &gt;= 2.<p>Another common example is matrices. Square matrices form a monoid, but what about arbitrary rectangular matrices? They don&#x27;t form a monoid, but they <i>do</i> form a category where the objects are natural numbers, and the arrows N -&gt; M are just the MxN matrices. You can&#x27;t multiply any two matrices, but if you have a P -&gt; Q matrix (QxP) and a Q -&gt; R (RxQ) matrix then you can multiply them to get a P -&gt; R matrix (RxP).</div><br/></div></div><div id="42292555" class="c"><input type="checkbox" id="c-42292555" checked=""/><div class="controls bullet"><span class="by">throwaway81523</span><span>|</span><a href="#42291655">root</a><span>|</span><a href="#42292295">parent</a><span>|</span><a href="#42292559">prev</a><span>|</span><a href="#42292026">next</a><span>|</span><label class="collapse" for="c-42292555">[-]</label><label class="expand" for="c-42292555">[1 more]</label></div><br/><div class="children"><div class="content">Monads are a traditional stumbling block for Haskell newbies, including me when I was one.  I found that those articles I linked demystified them more than any number of &quot;monad tutorials&quot; ever could do.</div><br/></div></div></div></div><div id="42292026" class="c"><input type="checkbox" id="c-42292026" checked=""/><div class="controls bullet"><span class="by">Koshkin</span><span>|</span><a href="#42291655">root</a><span>|</span><a href="#42291765">parent</a><span>|</span><a href="#42292295">prev</a><span>|</span><a href="#42292036">next</a><span>|</span><label class="collapse" for="c-42292026">[-]</label><label class="expand" for="c-42292026">[2 more]</label></div><br/><div class="children"><div class="content">Indeed; Haskell is purely functional, and Category Theory is nothing but a purely functional language of mathematics.</div><br/><div id="42293322" class="c"><input type="checkbox" id="c-42293322" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#42291655">root</a><span>|</span><a href="#42292026">parent</a><span>|</span><a href="#42292036">next</a><span>|</span><label class="collapse" for="c-42293322">[-]</label><label class="expand" for="c-42293322">[1 more]</label></div><br/><div class="children"><div class="content">Category theory is not “purely functional”, it is about morphisms, and morphisms are more abstract than functions.<p>Category theory envelopes relations as well, as well as arguably anything else that can be formalized.</div><br/></div></div></div></div><div id="42292036" class="c"><input type="checkbox" id="c-42292036" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#42291655">root</a><span>|</span><a href="#42291765">parent</a><span>|</span><a href="#42292026">prev</a><span>|</span><a href="#42293063">next</a><span>|</span><label class="collapse" for="c-42292036">[-]</label><label class="expand" for="c-42292036">[1 more]</label></div><br/><div class="children"><div class="content">But what does that buy you?</div><br/></div></div></div></div><div id="42293063" class="c"><input type="checkbox" id="c-42293063" checked=""/><div class="controls bullet"><span class="by">pizza</span><span>|</span><a href="#42291655">root</a><span>|</span><a href="#42291724">parent</a><span>|</span><a href="#42291765">prev</a><span>|</span><a href="#42292483">next</a><span>|</span><label class="collapse" for="c-42293063">[-]</label><label class="expand" for="c-42293063">[1 more]</label></div><br/><div class="children"><div class="content">The thing about questions like this is that the complexity of mathematical explanations is highly dependent on what each reader considers &quot;simple.&quot; Consider two different approaches to understanding a concept, expressed in information-theoretic terms:<p><pre><code>  H(concept) + H(existing explanation|concept) 
</code></pre>
vs<p><pre><code>  H(concept) + H(existing explanation|concept) + H(categorical explanation|existing explanation, concept)
</code></pre>
This additional complexity layer of categorical framing has a nonzero cognitive cost, which varies based on the learner&#x27;s intuitions and background. The investment in learning categorical thinking only becomes worthwhile when the learner can amortize its cost by envisioning its broad applicability - when they can see how categorical frameworks enable systematic problem decomposition and generalization. This implies they&#x27;ve already recognized the limitations and redundancies of non-categorical approaches, understanding intuitively how many concepts would need to be reinvented as the problem evolves within its conceptual framework (gestell).<p>However, there exists a middle path that often goes unrecognized as categorical thinking, despite embodying its essence. This approach involves incrementally discovering generalizations -- &quot;oh, this can be generalized with this type&quot; or &quot;oh, if I wrap this in another type I can do something else later on&quot; or &quot;oh this syntactic sugar for this particular operator overload feels quite nice&quot;</div><br/></div></div><div id="42292483" class="c"><input type="checkbox" id="c-42292483" checked=""/><div class="controls bullet"><span class="by">matt-noonan</span><span>|</span><a href="#42291655">root</a><span>|</span><a href="#42291724">parent</a><span>|</span><a href="#42293063">prev</a><span>|</span><a href="#42293310">next</a><span>|</span><label class="collapse" for="c-42292483">[-]</label><label class="expand" for="c-42292483">[1 more]</label></div><br/><div class="children"><div class="content">Yes, there are a number of them. Here are some examples off the top of my head:<p>- Moggi was studying the problem of equivalence of programs, and noted that the traditional approach to modeling a program as a total function Input -&gt; Output is problematic. He pioneered the use of monads and Kleisli categories as a foundation for reasoning about equivalence of real programs, including all the real-world nastiness like non-termination, partiality (e.g. throwing an exception that kills the program), non-determinism, and so on. <a href="https:&#x2F;&#x2F;person.dibris.unige.it&#x2F;moggi-eugenio&#x2F;ftp&#x2F;lics89.pdf" rel="nofollow">https:&#x2F;&#x2F;person.dibris.unige.it&#x2F;moggi-eugenio&#x2F;ftp&#x2F;lics89.pdf</a><p>- Linear logic (and it&#x27;s close relative affine logic) was the inspiration behind Rust&#x27;s ownership model, from what I understand. Linear logic was originally described in terms of the sequent calculus by Girard (<a href="http:&#x2F;&#x2F;girard.perso.math.cnrs.fr&#x2F;linear.pdf" rel="nofollow">http:&#x2F;&#x2F;girard.perso.math.cnrs.fr&#x2F;linear.pdf</a>), but later work used certain categories as a model of linear logic (<a href="https:&#x2F;&#x2F;ncatlab.org&#x2F;nlab&#x2F;files&#x2F;SeelyLinearLogic.pdf" rel="nofollow">https:&#x2F;&#x2F;ncatlab.org&#x2F;nlab&#x2F;files&#x2F;SeelyLinearLogic.pdf</a>). This answered and clarified a number of questions stemming from Girard&#x27;s original work.<p>- Cartesian-closed categories (CCCs) form models of the simply-typed lambda calculus, in the sense that any lambda term can be interpreted as a value in a CCC. Conal Elliott pointed out that this means that a lambda term doesn&#x27;t have just one natural meaning; it can be given a multitude of meanings by interpreting the same term in different CCCs. He shows how to use this idea to &quot;interpret&quot; a program into a circuit that implements the program. <a href="http:&#x2F;&#x2F;conal.net&#x2F;papers&#x2F;compiling-to-categories&#x2F;" rel="nofollow">http:&#x2F;&#x2F;conal.net&#x2F;papers&#x2F;compiling-to-categories&#x2F;</a><p>- Mokhov, Mitchell, and Jones studied the similarities and differences between real-world build systems and explained them using different kinds of categories. <a href="https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;uploads&#x2F;prod&#x2F;2018&#x2F;03&#x2F;build-systems.pdf" rel="nofollow">https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;uploads&#x2F;prod&#x2F;2018&#x2F;0...</a><p>- There is a classical construction about minimizing a DFA due to Brzozowski which is a bit magical. Given a DFA, do the following process <i>twice</i>: (a) get an NFA for the reverse language by reversing all edges in the DFA and swapping start &#x2F; accept nodes, then (b) drop any nodes which are not reachable from a start node in the NFA. The result will be the <i>minimal</i> DFA that accepts the same language as your original DFA! Bonchi, Bonsangue, Rutten, and Silva analyzed Brzozowski&#x27;s algorithm from a categorical perspective, which allowed them to give a very clear explanation of why it works along with a novel generalization of Brzozowski&#x27;s algorithm to other kinds of automata. <a href="https:&#x2F;&#x2F;alexandrasilva.org&#x2F;files&#x2F;RechabilityObservability.pdf" rel="nofollow">https:&#x2F;&#x2F;alexandrasilva.org&#x2F;files&#x2F;RechabilityObservability.pd...</a><p>- I would also put the development of lenses in this list, but they haven&#x27;t leaked very far outside of the Haskell universe yet so I don&#x27;t think they are a compelling example. Check back in 5 years perhaps. Here&#x27;s a blog post describing how lenses relate to jq and xpath: <a href="https:&#x2F;&#x2F;chrispenner.ca&#x2F;posts&#x2F;traversal-systems" rel="nofollow">https:&#x2F;&#x2F;chrispenner.ca&#x2F;posts&#x2F;traversal-systems</a><p>- I&#x27;ve personally had success in finding useful generalizations of existing algorithms by finding a monoid in the algorithm and replacing it with a category, using the fact that categories are like &quot;many-kinded monoids&quot; in some sense. I haven&#x27;t written any of these cases up yet, so check back in 2 years or so. In any case, they&#x27;ve been useful enough to drive some unique user-facing features.</div><br/></div></div><div id="42293310" class="c"><input type="checkbox" id="c-42293310" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#42291655">root</a><span>|</span><a href="#42291724">parent</a><span>|</span><a href="#42292483">prev</a><span>|</span><a href="#42292857">next</a><span>|</span><label class="collapse" for="c-42293310">[-]</label><label class="expand" for="c-42293310">[1 more]</label></div><br/><div class="children"><div class="content">Yes?</div><br/></div></div></div></div></div></div><div id="42292857" class="c"><input type="checkbox" id="c-42292857" checked=""/><div class="controls bullet"><span class="by">CarpaDorada</span><span>|</span><a href="#42291655">prev</a><span>|</span><a href="#42293156">next</a><span>|</span><label class="collapse" for="c-42292857">[-]</label><label class="expand" for="c-42292857">[1 more]</label></div><br/><div class="children"><div class="content">This is a phony work in progress (I do not mean to disparage the author, just the work itself, or perhaps the YC submission). There&#x27;s no direction, it&#x27;s just &quot;let&#x27;s do it because ... ?&quot; Here is the authors&#x27; answer to &quot;Why Category theory?&quot;:<p>&gt;The answer lies in the abstraction and generalization capabilities provided by category theory. It allows us to see beyond the specifics of a particular programming language, problem, or system, revealing the underlying structures that are common across different domains<p>Rest assured you will not find much of that by reading category theory (CT). This type of studying of CT reminds me of Shaolin monks trying to fight boxers (hint: the boxer wins).<p>Another peculiar thing about these notes is that the author colored every CT diagram (and worse even, there is no logic to the color choices, it&#x27;s just randomized.)<p>CT is a nice subject as any other, and useful to those doing research. You don&#x27;t need it if you&#x27;re not doing specific math&#x2F;CS research that uses it. Anything that could be useful to you from CT can be explained in one afternoon over some coffee or beer. For example, the notion of universality could be useful to many programmers: the &quot;most general&quot; object of its kind, and how that is reflected in relation to other objects of its kind; a brief example would be that the &quot;free&quot; language of all strings in the letters A and B is universal amongst all languages of strings A, B with relations, (relations such as AAAB = A.)<p>Don&#x27;t enter turbulent waters if you&#x27;re not a swimmer! Maybe you can take a boat instead. For those who already know CT because of other motivations (in particular, because they&#x27;re mathematicians who have spent many years studying mathematics), the applications of CT to computer science can come somewhat naturally, but for others, it&#x27;s an uphill battle and a waste of time.</div><br/></div></div><div id="42293156" class="c"><input type="checkbox" id="c-42293156" checked=""/><div class="controls bullet"><span class="by">galaxyLogic</span><span>|</span><a href="#42292857">prev</a><span>|</span><a href="#42292917">next</a><span>|</span><label class="collapse" for="c-42293156">[-]</label><label class="expand" for="c-42293156">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t CT much about higher-order parameterized type-signatures of a set of &quot;classes&quot; that can usefully work and be combined with each other?<p>Then instead of grokking the CT and its theorems as a whole it would seem to be useful to learn about such type-signatures among a set of collaborating (OOP-like) classes which are useful for many programming tasks?<p>In a sense categories then could be seen as formalization of &quot;Design Patterns&quot;?<p>Something like that?</div><br/><div id="42293329" class="c"><input type="checkbox" id="c-42293329" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#42293156">parent</a><span>|</span><a href="#42292917">next</a><span>|</span><label class="collapse" for="c-42293329">[-]</label><label class="expand" for="c-42293329">[1 more]</label></div><br/><div class="children"><div class="content">I was going to say “not at all”… But not really, no.</div><br/></div></div></div></div><div id="42292917" class="c"><input type="checkbox" id="c-42292917" checked=""/><div class="controls bullet"><span class="by">munchler</span><span>|</span><a href="#42293156">prev</a><span>|</span><a href="#42293733">next</a><span>|</span><label class="collapse" for="c-42292917">[-]</label><label class="expand" for="c-42292917">[3 more]</label></div><br/><div class="children"><div class="content">The section on &quot;Mapping Category to Programming&quot; seems to totally miss the point of how category theory is actually relevant in programming. Functors, applicatives, and monads are category theory concepts that are particularly useful in programming, but they aren&#x27;t even mentioned here.<p>Category theory is <i>way</i> more abstract than programming, so
the truth is that you don&#x27;t need to know what these concepts mean in category theory; just understand them as programming concepts to start with.  For example, monoids are ubiquitous in programming, but the category theory view of a monoid as a one-object category is too abstract to be helpful. Instead, it&#x27;s much more useful to just think of a monoid as a set equipped with an associative binary operation and an identity element. Then you can easily see that strings, list, and numbers (with their applicable operations) are all monoids.</div><br/><div id="42293340" class="c"><input type="checkbox" id="c-42293340" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#42292917">parent</a><span>|</span><a href="#42293733">next</a><span>|</span><label class="collapse" for="c-42293340">[-]</label><label class="expand" for="c-42293340">[2 more]</label></div><br/><div class="children"><div class="content">&gt; the category theory view of a monoid as a one-object category is too abstract to be helpful<p>That’s not true at all! It goes to the essence of what it means for a thing to be foldable unto itself, ie.: the things that you can reduce() or fold().<p>There’s an entire paradigm of data processing where all you do is map-and-reduce, so there’s something very important and practical there.</div><br/><div id="42293458" class="c"><input type="checkbox" id="c-42293458" checked=""/><div class="controls bullet"><span class="by">munchler</span><span>|</span><a href="#42292917">root</a><span>|</span><a href="#42293340">parent</a><span>|</span><a href="#42293733">next</a><span>|</span><label class="collapse" for="c-42293458">[-]</label><label class="expand" for="c-42293458">[1 more]</label></div><br/><div class="children"><div class="content">Sure, but my point is just that the category theory view of a monoid is harder for most people to understand.<p>For example, it&#x27;s easy to see that integer addition is an operation that combines two elements of the set &quot;Integer&quot; into another element of the same set. E.g. 1 + 2 = 3. From there, it&#x27;s a small step to seeing the same pattern elsewhere, and recognizing it as the &quot;monoid&quot; pattern. E.g. &quot;foo&quot; + &quot;bar&quot; = &quot;foobar&quot; for string concatenation.<p>In category theory, one instead has to think of this as the composition of two morphisms being equivalent to another morphism. E.g. +2 ∘ +1 = +3. That is much less intuitive for most people, I think.<p>I have nothing against category theory. It is very powerful precisely because it is so abstract. But if you want to learn how to apply the relevant concepts to programming, that abstraction is often more of an obstacle than a help.</div><br/></div></div></div></div></div></div><div id="42293733" class="c"><input type="checkbox" id="c-42293733" checked=""/><div class="controls bullet"><span class="by">sgt_bilko</span><span>|</span><a href="#42292917">prev</a><span>|</span><a href="#42292980">next</a><span>|</span><label class="collapse" for="c-42293733">[-]</label><label class="expand" for="c-42293733">[1 more]</label></div><br/><div class="children"><div class="content">&quot;In the following chapters, we will explore the core concepts of category theory — objects, morphisms, categories, functors, natural transformations, Yoneda Lemma, 2-categories, (co)limits, sketches, Cartesion closed categories &amp; typed lambda, Curry–Howard–Lambek corresponding, adjunctions, (co)monads, kan-extensions, toposes, and more...&quot;<p>That&#x27;ll be a no from me</div><br/></div></div><div id="42292980" class="c"><input type="checkbox" id="c-42292980" checked=""/><div class="controls bullet"><span class="by">revskill</span><span>|</span><a href="#42293733">prev</a><span>|</span><a href="#42292565">next</a><span>|</span><label class="collapse" for="c-42292980">[-]</label><label class="expand" for="c-42292980">[2 more]</label></div><br/><div class="children"><div class="content">It is all about functor, and functions between them. So what is functor for ?</div><br/><div id="42293547" class="c"><input type="checkbox" id="c-42293547" checked=""/><div class="controls bullet"><span class="by">ta_1138</span><span>|</span><a href="#42292980">parent</a><span>|</span><a href="#42292565">next</a><span>|</span><label class="collapse" for="c-42293547">[-]</label><label class="expand" for="c-42293547">[1 more]</label></div><br/><div class="children"><div class="content">In computer science, we can squint and claim that a functor is just something that has a .map function, taking a function. Option, Promise, List... all functors.<p>The fact that functor is a concept, and follows specific laws, allows us to have other abstractions that work across all functors without having to repeat ourselves over and over again. See, for instance, Scala&#x27;s for comprehension. it offers different iterating capabilities over basically anything, and it will give you more capabilities if instead of just functor, you pass a monad, or something that supports .filter.<p>Also see the possibilities of generic transformations. Every language that supports Promise needs some way to turn a list of Promises into a Promise holding a list, and vice versa. We can do this with options, or Eithers, or some home-made thing that is holding on to any other property we like... but it&#x27;s so much easier to do so without having to write every possible combination of two things, and rely on the fact that one might be a monoid, or a monad, and not have to write all the boilerplate.<p>In languages that take this very seriously, you can do things like, say, apply a tracing library to an http request, or a logger, or manage creation of resources, all throught category theory concepts, and have all the wiring basically disappear, instead of havign to either pass a million parameters, or relying on some dubious Aspect-oriented-programming instrumentation that might or might not work. All visible, and checkable at compile time. And you get there by making all your abstractions are functors, monoids, monads and such.</div><br/></div></div></div></div><div id="42292565" class="c"><input type="checkbox" id="c-42292565" checked=""/><div class="controls bullet"><span class="by">gremgoth</span><span>|</span><a href="#42292980">prev</a><span>|</span><label class="collapse" for="c-42292565">[-]</label><label class="expand" for="c-42292565">[1 more]</label></div><br/><div class="children"><div class="content">If you have a compositional system, such as a programming language, you can use category theory to predict its behavior, in the same way that if you have a symmetric system, such as particles in a box, you can predict its behavior.  In the former, maybe you prove that your programming language &quot;can&#x27;t go wrong&quot;; in the latter, maybe you prove your physical system &quot;conserves energy&quot;.  (Or, do both at once: <a href="https:&#x2F;&#x2F;conferences.inf.ed.ac.uk&#x2F;clapscotland&#x2F;atkey.pdf" rel="nofollow">https:&#x2F;&#x2F;conferences.inf.ed.ac.uk&#x2F;clapscotland&#x2F;atkey.pdf</a>).  In any case, the point of category theory is to model compositional systems, which may or may not be worthwhile in any given context.</div><br/></div></div></div></div></div></div></div></body></html>