<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1685264459835" as="style"/><link rel="stylesheet" href="styles.css?v=1685264459835"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://mitchellh.com/writing/zig-and-swiftui">Integrating Zig and SwiftUI</a> <span class="domain">(<a href="https://mitchellh.com">mitchellh.com</a>)</span></div><div class="subtext"><span>ingve</span> | <span>41 comments</span></div><br/><div><div id="36097977" class="c"><input type="checkbox" id="c-36097977" checked=""/><div class="controls bullet"><span class="by">WhereIsTheTruth</span><span>|</span><a href="#36101660">next</a><span>|</span><label class="collapse" for="c-36097977">[-]</label><label class="expand" for="c-36097977">[19 more]</label></div><br/><div class="children"><div class="content">SwiftUI shines because you get to write Swift code and embrace the DSL<p>You&#x27;ll never be able to write that kind of code with Zig, or C or C++, it&#x27;s impossible: <a href="https:&#x2F;&#x2F;github.com&#x2F;amosgyamfi&#x2F;open-swiftui-animations">https:&#x2F;&#x2F;github.com&#x2F;amosgyamfi&#x2F;open-swiftui-animations</a><p>So the main advantage here would be to be able to consume your Zig code&#x2F;libraries with your Swift application, and that does look interesting, so you could write your crossplatform app logic in Zig, and only use Swift the UI<p>That&#x27;s the advantage that should be advertised, Kotlin tried with Kotlin-Native, seems like a good strategy</div><br/><div id="36099055" class="c"><input type="checkbox" id="c-36099055" checked=""/><div class="controls bullet"><span class="by">turdprincess</span><span>|</span><a href="#36097977">parent</a><span>|</span><a href="#36098285">next</a><span>|</span><label class="collapse" for="c-36099055">[-]</label><label class="expand" for="c-36099055">[5 more]</label></div><br/><div class="children"><div class="content">The downside of this kind of strategy is that for an engineer to work on it, they need to be proficient in iOS, Android, and zig&#x2F;c&#x2F;c++.  It’s somewhat uncommon to have engineers known just iOS and Android, let alone a 3rd language &#x2F; stack.<p>Another issue is maintenance and debugging - even something trivial like not being able to set breakpoints in the shared code can be a significant slowdown to an engineer.  Not to mention the extra wrapping layers your native code needs to smooth out the interactions between the shared and native layers.<p>For sure there are settings where it makes sense to take this approach, especially if code is shared across more than two platforms.  But just for iOS and Android I wouldn’t necessarily say it’s a more efficient solution.<p>Working on such shared code is also pretty stressful.  In a pure native codebase I can simply make the change and test it, but with shared code I have to worry about consequences across many platforms - did I just fix something on one platform only to introduce an issue on another?</div><br/><div id="36102133" class="c"><input type="checkbox" id="c-36102133" checked=""/><div class="controls bullet"><span class="by">kristoff_it</span><span>|</span><a href="#36097977">root</a><span>|</span><a href="#36099055">parent</a><span>|</span><a href="#36099695">next</a><span>|</span><label class="collapse" for="c-36102133">[-]</label><label class="expand" for="c-36102133">[1 more]</label></div><br/><div class="children"><div class="content">&gt; even something trivial like not being able to set breakpoints in the shared code<p>I think your overall point still stands, but you can setup breakpoints in Zig and have the normal tooling work correctly with it.</div><br/></div></div><div id="36099695" class="c"><input type="checkbox" id="c-36099695" checked=""/><div class="controls bullet"><span class="by">andrekandre</span><span>|</span><a href="#36097977">root</a><span>|</span><a href="#36099055">parent</a><span>|</span><a href="#36102133">prev</a><span>|</span><a href="#36101786">next</a><span>|</span><label class="collapse" for="c-36099695">[-]</label><label class="expand" for="c-36099695">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  &gt; Working on such shared code is also pretty stressful. In a pure native codebase I can simply make the change and test it, but with shared code I have to worry about consequences across many platforms - did I just fix something on one platform only to introduce an issue on another?
</code></pre>
this is one of the biggest downsides<p>the other big one is the code → write → test → deploy scenario is extremely slow to the point of extreme frustration (at least for kotlin multiplatform anyways) with these kinds of tools</div><br/></div></div><div id="36101786" class="c"><input type="checkbox" id="c-36101786" checked=""/><div class="controls bullet"><span class="by">jb1991</span><span>|</span><a href="#36097977">root</a><span>|</span><a href="#36099055">parent</a><span>|</span><a href="#36099695">prev</a><span>|</span><a href="#36098285">next</a><span>|</span><label class="collapse" for="c-36101786">[-]</label><label class="expand" for="c-36101786">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It’s somewhat uncommon to have engineers known just iOS<p>This is very common in the iOS world. Not sure about other areas.</div><br/><div id="36102088" class="c"><input type="checkbox" id="c-36102088" checked=""/><div class="controls bullet"><span class="by">JimDabell</span><span>|</span><a href="#36097977">root</a><span>|</span><a href="#36101786">parent</a><span>|</span><a href="#36098285">next</a><span>|</span><label class="collapse" for="c-36102088">[-]</label><label class="expand" for="c-36102088">[1 more]</label></div><br/><div class="children"><div class="content">Why did you break off mid-sentence? If you continue reading the rest of the sentence, you will see that they are saying the opposite of what you think they are:<p>&gt; It’s somewhat uncommon to have engineers known just iOS and Android, let alone a 3rd language &#x2F; stack.</div><br/></div></div></div></div></div></div><div id="36098285" class="c"><input type="checkbox" id="c-36098285" checked=""/><div class="controls bullet"><span class="by">nusaru</span><span>|</span><a href="#36097977">parent</a><span>|</span><a href="#36099055">prev</a><span>|</span><a href="#36099688">next</a><span>|</span><label class="collapse" for="c-36098285">[-]</label><label class="expand" for="c-36098285">[1 more]</label></div><br/><div class="children"><div class="content">Second paragraph in OP:<p>&gt; One approach to building a native GUI for a cross-platform application is to write all of the business logic in a cross-platform language (C, Rust, Zig, etc.) and then write the platform-specific GUI code. This is the approach I take with my my terminal emulator and it works really well. As of the current date writing this post, 93% of my repository is business logic in Zig and C, and 4% is macOS-specific GUI code in Swift.</div><br/></div></div><div id="36099688" class="c"><input type="checkbox" id="c-36099688" checked=""/><div class="controls bullet"><span class="by">wudangmonk</span><span>|</span><a href="#36097977">parent</a><span>|</span><a href="#36098285">prev</a><span>|</span><a href="#36098434">next</a><span>|</span><label class="collapse" for="c-36099688">[-]</label><label class="expand" for="c-36099688">[8 more]</label></div><br/><div class="children"><div class="content">React native and all these similar DSLs always seemed like a bad idea to me. I can forgive it on the web as you have no other choice than to use the 3 broken pillars which is html, css, and js and build your sand castles on top of that.<p>I wonder though, was the development of swift UI influenced by the abundance of react developers or is this what peak UI development looks like?. In the history of GUI applications does react represent the best we have managed to come up with?. I&#x27;ve used it as to me it kinda sucks but I have never worked on the UI side of anything except for small web frontends<p>I always just assumed that in the 40+ years there were some better UI libraries but apparently not?.</div><br/><div id="36099906" class="c"><input type="checkbox" id="c-36099906" checked=""/><div class="controls bullet"><span class="by">deergomoo</span><span>|</span><a href="#36097977">root</a><span>|</span><a href="#36099688">parent</a><span>|</span><a href="#36101973">next</a><span>|</span><label class="collapse" for="c-36099906">[-]</label><label class="expand" for="c-36099906">[5 more]</label></div><br/><div class="children"><div class="content">The main benefit of declarative UI frameworks is that they remove the need to manually reconcile changes in state with changes in the representation of that state (with the caveat that it often becomes difficult to do so if the DSL doesn’t cover the behaviour you want).<p>UIs inherently have a hell of a lot of state that is constantly in flux, so it can become very difficult to manage those transitions correctly and efficiently. By providing a description of how an interface should look given some program state, the developer only need be concerned with the flow of data, and the framework can automatically create and apply the delta to update the UI in the most efficient way. For example, there’s no possibility to forget to re-enable a button in that rarely-used code path, because the “enabled” state is derived from the rest of your app state and any changes to that automatically cascade downwards.<p>I’m not saying these things are a silver bullet (and I don’t even really do much UI stuff anymore), but when my job involved frontend web stuff, moving from jQuery to Vue was both an unbelievable jump in both productivity and a massive decrease in UI bugs (and LoC!).</div><br/><div id="36100893" class="c"><input type="checkbox" id="c-36100893" checked=""/><div class="controls bullet"><span class="by">benatkin</span><span>|</span><a href="#36097977">root</a><span>|</span><a href="#36099906">parent</a><span>|</span><a href="#36101973">next</a><span>|</span><label class="collapse" for="c-36100893">[-]</label><label class="expand" for="c-36100893">[4 more]</label></div><br/><div class="children"><div class="content">DSL stands for Domain Specific Language, not declarative. It is possible to be declarative without a hybrid DSL like JSX. Angular is declarative, but it doesn&#x27;t mix html structures and js in the same way.</div><br/><div id="36101799" class="c"><input type="checkbox" id="c-36101799" checked=""/><div class="controls bullet"><span class="by">jb1991</span><span>|</span><a href="#36097977">root</a><span>|</span><a href="#36100893">parent</a><span>|</span><a href="#36101973">next</a><span>|</span><label class="collapse" for="c-36101799">[-]</label><label class="expand" for="c-36101799">[3 more]</label></div><br/><div class="children"><div class="content">I wonder if you responded to the wrong comment.</div><br/><div id="36101864" class="c"><input type="checkbox" id="c-36101864" checked=""/><div class="controls bullet"><span class="by">benatkin</span><span>|</span><a href="#36097977">root</a><span>|</span><a href="#36101799">parent</a><span>|</span><a href="#36101973">next</a><span>|</span><label class="collapse" for="c-36101864">[-]</label><label class="expand" for="c-36101864">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the one I intended to respond to. React isn&#x27;t declarative in a new way. Backbone.js popularized declarative event bindings long before it. It is a bit of a unique DSL though.</div><br/><div id="36101944" class="c"><input type="checkbox" id="c-36101944" checked=""/><div class="controls bullet"><span class="by">jb1991</span><span>|</span><a href="#36097977">root</a><span>|</span><a href="#36101864">parent</a><span>|</span><a href="#36101973">next</a><span>|</span><label class="collapse" for="c-36101944">[-]</label><label class="expand" for="c-36101944">[1 more]</label></div><br/><div class="children"><div class="content">It was odd because the comment you were responding to does not make the point that you seem to be debating against.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36101973" class="c"><input type="checkbox" id="c-36101973" checked=""/><div class="controls bullet"><span class="by">ShadowBanThis01</span><span>|</span><a href="#36097977">root</a><span>|</span><a href="#36099688">parent</a><span>|</span><a href="#36099906">prev</a><span>|</span><a href="#36099983">next</a><span>|</span><label class="collapse" for="c-36101973">[-]</label><label class="expand" for="c-36101973">[1 more]</label></div><br/><div class="children"><div class="content">I suspect it would be influenced more by QML than React. Why jump to the conclusion that it&#x27;s React?</div><br/></div></div><div id="36099983" class="c"><input type="checkbox" id="c-36099983" checked=""/><div class="controls bullet"><span class="by">madeofpalk</span><span>|</span><a href="#36097977">root</a><span>|</span><a href="#36099688">parent</a><span>|</span><a href="#36101973">prev</a><span>|</span><a href="#36098434">next</a><span>|</span><label class="collapse" for="c-36099983">[-]</label><label class="expand" for="c-36099983">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In the history of GUI applications does react represent the best we have managed to come up with<p>tl;dr, yes.<p>Ignore the DSL syntax of React (or SwiftUI or whatever), and understand that React&#x27;s model is that UI is a function of state. In my experience, being able to <i>declare</i> how your application should look given it&#x27;s current state (and just let the engine figure out how to get there) is a significantly more productive.<p>This works <i>very</i> well with React on the Web because the primitives there are pretty basic, and there&#x27;s a well understood way to break out back down to the imperative DOM APIs. Others (SwiftUI, WinUI XAML from my experience) haven&#x27;t quite seem to have gotten the mix right yet, so you have a harder time once you need to do more complicated things.<p>SwiftUI (like React Web) has some really neat benefits from this - views can be serialized down and rendered without your application running. This is how lock+home screen widgets, and watch complications work - the app is intermittently asked to provide snapshots at certain points in time, which the OS serializes and shows later. This is easily possible with SwiftUI because it fundamentally is data.</div><br/></div></div></div></div><div id="36098434" class="c"><input type="checkbox" id="c-36098434" checked=""/><div class="controls bullet"><span class="by">benatkin</span><span>|</span><a href="#36097977">parent</a><span>|</span><a href="#36099688">prev</a><span>|</span><a href="#36098624">next</a><span>|</span><label class="collapse" for="c-36098434">[-]</label><label class="expand" for="c-36098434">[1 more]</label></div><br/><div class="children"><div class="content">Are you suggesting that Zig never lets you just think about the problem? That&#x27;s some terrible preoccupation with an idealized concept of a DSL.<p>The swift code examples look kinda slick but it isn&#x27;t a different paradigm any more than JSX is for building HTML.<p>It seems like a form of The Bipolar Lisp Programmer. <a href="https:&#x2F;&#x2F;www.marktarver.com&#x2F;bipolar.html" rel="nofollow">https:&#x2F;&#x2F;www.marktarver.com&#x2F;bipolar.html</a><p>&gt; Lisp is like wielding an air gun with power and precision.<p>Those Swift examples you show are very exciting, but it&#x27;s best not to get carried away. It&#x27;s the same as those that say that vim is terrible because it&#x27;s modal and don&#x27;t believe that vim programmers can think about the problem while they&#x27;re typing because their brain is distracted with switching between modes.</div><br/></div></div><div id="36098624" class="c"><input type="checkbox" id="c-36098624" checked=""/><div class="controls bullet"><span class="by">FpUser</span><span>|</span><a href="#36097977">parent</a><span>|</span><a href="#36098434">prev</a><span>|</span><a href="#36101660">next</a><span>|</span><label class="collapse" for="c-36098624">[-]</label><label class="expand" for="c-36098624">[3 more]</label></div><br/><div class="children"><div class="content">&gt;&quot;So the main advantage here would be to be able to consume your Zig code&#x2F;libraries with your Swift application&quot;<p>I&#x27;ve heard that BS from MS reps when they visited our company sometime in 90s. They were telling us how we should have monkeys drawing forms in VB and gurus making main code in C&#x2F;C++. Then I showed them Delphi. You had to see how sour their faces turned.<p>&gt;&quot;You&#x27;ll never be able to write that kind of code with Zig, or C or C++&quot;<p>Your statement looks totally wrong. Looking at code seems like simple &quot;fluent&quot; notation that is quite possible in languages you mentioned.</div><br/><div id="36099402" class="c"><input type="checkbox" id="c-36099402" checked=""/><div class="controls bullet"><span class="by">benatkin</span><span>|</span><a href="#36097977">root</a><span>|</span><a href="#36098624">parent</a><span>|</span><a href="#36098755">prev</a><span>|</span><a href="#36101660">next</a><span>|</span><label class="collapse" for="c-36099402">[-]</label><label class="expand" for="c-36099402">[1 more]</label></div><br/><div class="children"><div class="content">&quot;you could write your crossplatform app logic in Zig, and only use Swift the UI&quot;<p>The UI glue code would be nothing special, and not improved by Swift vs Java. The UI would be designed in a design tool. I like open source, so perhaps Penpot.</div><br/></div></div></div></div></div></div><div id="36101660" class="c"><input type="checkbox" id="c-36101660" checked=""/><div class="controls bullet"><span class="by">dgellow</span><span>|</span><a href="#36097977">prev</a><span>|</span><a href="#36097586">next</a><span>|</span><label class="collapse" for="c-36101660">[-]</label><label class="expand" for="c-36101660">[3 more]</label></div><br/><div class="children"><div class="content">IMHO that’s one of the main benefits of following the Model-View-ViewModel architecture pattern for GUIs. You can have all the models and viewmodels defined in a platform agnostic library, and your views are the only thing to implement in a platform specific way. The core library can be implemented in any language, you just need a way to call methods and setters when the user interacts, and handle update events to update the UI.</div><br/><div id="36101781" class="c"><input type="checkbox" id="c-36101781" checked=""/><div class="controls bullet"><span class="by">skrebbel</span><span>|</span><a href="#36101660">parent</a><span>|</span><a href="#36097586">next</a><span>|</span><label class="collapse" for="c-36101781">[-]</label><label class="expand" for="c-36101781">[2 more]</label></div><br/><div class="children"><div class="content">This seems like a really good idea! But at second glance, won’t differences between the UI designs on different platforms require subtly different viewmodels for each platform?<p>Not if you make the exqct same UI on each platform I bet, but if you do that, you might as well use something like Flutter or React Native and only code the whole thing once, no?</div><br/><div id="36102017" class="c"><input type="checkbox" id="c-36102017" checked=""/><div class="controls bullet"><span class="by">dgellow</span><span>|</span><a href="#36101660">root</a><span>|</span><a href="#36101781">parent</a><span>|</span><a href="#36097586">next</a><span>|</span><label class="collapse" for="c-36102017">[-]</label><label class="expand" for="c-36102017">[1 more]</label></div><br/><div class="children"><div class="content">Yes, there are differences between platforms, complicating the picture a bit. There is a bit of a trade off&#x2F;judgement calls when deciding what needs to be in the core library and what to keep on the platform specific code. You can always wrap a shared view model with a more specific one if you have to account for a few differences, or just decide to keep a bit of logic in the view. If you have &gt;80% of your viewmodels that can be shared between platforms, MVVM can be really useful (just my own rule of thumb). If you have more differences between platforms I guess you will want to try something else.<p>Regarding Flutter, then yes I agree with you, their approach is different, it’s more adapted if you want to design a single UI that will be rendered the same on every platform, without relying on native controls.</div><br/></div></div></div></div></div></div><div id="36097586" class="c"><input type="checkbox" id="c-36097586" checked=""/><div class="controls bullet"><span class="by">conradev</span><span>|</span><a href="#36101660">prev</a><span>|</span><a href="#36097736">next</a><span>|</span><label class="collapse" for="c-36097586">[-]</label><label class="expand" for="c-36097586">[2 more]</label></div><br/><div class="children"><div class="content">Rust also works quite well from Swift, in the same way<p>The key to a nice developer experience is making the build from source flow as easy&#x2F;integrated as possible<p>I use a build script in Xcode to build a Rust static library automatically when building an app. This is the latest version in a project I am helping with: <a href="https:&#x2F;&#x2F;github.com&#x2F;hackclub&#x2F;burrow&#x2F;blob&#x2F;main&#x2F;Apple&#x2F;NetworkExtension&#x2F;libburrow&#x2F;build-rust.sh">https:&#x2F;&#x2F;github.com&#x2F;hackclub&#x2F;burrow&#x2F;blob&#x2F;main&#x2F;Apple&#x2F;NetworkEx...</a><p>It would be cool to write a similar adapter but to run build.zig!</div><br/><div id="36098880" class="c"><input type="checkbox" id="c-36098880" checked=""/><div class="controls bullet"><span class="by">synergy20</span><span>|</span><a href="#36097586">parent</a><span>|</span><a href="#36097736">next</a><span>|</span><label class="collapse" for="c-36098880">[-]</label><label class="expand" for="c-36098880">[1 more]</label></div><br/><div class="children"><div class="content">the key to 90% programmer is though, zig seems to be 100 times easier to master.<p>to me, use zig for c,use rust for c++</div><br/></div></div></div></div><div id="36097736" class="c"><input type="checkbox" id="c-36097736" checked=""/><div class="controls bullet"><span class="by">Arathorn</span><span>|</span><a href="#36097586">prev</a><span>|</span><a href="#36102090">next</a><span>|</span><label class="collapse" for="c-36097736">[-]</label><label class="expand" for="c-36097736">[1 more]</label></div><br/><div class="children"><div class="content">this is also how the Element X rewrite of the Element Matrix client works - although with Rust rather than Zig. We had to add async support to uniffi for a good experience from Swift (and Kotlin) tho! <a href="https:&#x2F;&#x2F;youtu.be&#x2F;eUPJ9zFV5IE?t=1280" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;eUPJ9zFV5IE?t=1280</a> has some deets.</div><br/></div></div><div id="36102090" class="c"><input type="checkbox" id="c-36102090" checked=""/><div class="controls bullet"><span class="by">bsaul</span><span>|</span><a href="#36097736">prev</a><span>|</span><a href="#36100162">next</a><span>|</span><label class="collapse" for="c-36102090">[-]</label><label class="expand" for="c-36102090">[2 more]</label></div><br/><div class="children"><div class="content">this approach gets me really interested. What are the improvements i should expect in zig compared to C ? And how does zig stdlib compare to something like the go stdlib ( which to me remains the gold standard)</div><br/><div id="36102127" class="c"><input type="checkbox" id="c-36102127" checked=""/><div class="controls bullet"><span class="by">kristoff_it</span><span>|</span><a href="#36102090">parent</a><span>|</span><a href="#36100162">next</a><span>|</span><label class="collapse" for="c-36102127">[-]</label><label class="expand" for="c-36102127">[1 more]</label></div><br/><div class="children"><div class="content">&gt;What are the improvements i should expect in zig compared to C ?<p><a href="https:&#x2F;&#x2F;ziglang.org&#x2F;learn&#x2F;overview&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ziglang.org&#x2F;learn&#x2F;overview&#x2F;</a><p>&gt;And how does zig stdlib compare to something like the go stdlib<p>the stdlib is still work in progress and not the current focus of development. right now things get added to it organically (ie things needed by the compiler itself, the toolchain, or as a proof of concept for other important functionality, like an event loop). as we move forward we will have a phase where we make a final decision on what should stay in, what should be improved, and and what should be cut.<p>In the meantime you can quickly get a feel for what&#x27;s in the stdlib by browsing the online docs:<p><a href="https:&#x2F;&#x2F;ziglang.org&#x2F;documentation&#x2F;master&#x2F;std&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ziglang.org&#x2F;documentation&#x2F;master&#x2F;std&#x2F;</a></div><br/></div></div></div></div><div id="36100162" class="c"><input type="checkbox" id="c-36100162" checked=""/><div class="controls bullet"><span class="by">felipefar</span><span>|</span><a href="#36102090">prev</a><span>|</span><a href="#36099938">next</a><span>|</span><label class="collapse" for="c-36100162">[-]</label><label class="expand" for="c-36100162">[2 more]</label></div><br/><div class="children"><div class="content">Nice post!<p>I&#x27;m not sure if the same result is applicable to most software projects. A console emulator doesn&#x27;t need several types of GUI objects, while most other projects need to display and handle input for several different types of data.<p>In most projects I&#x27;ve worked on, the proportion of GUI code to business code was different: I saw apprx. 70% GUI code to 30% business code.<p>So a cross platform GUI layer saves a lot more development time.</div><br/><div id="36100667" class="c"><input type="checkbox" id="c-36100667" checked=""/><div class="controls bullet"><span class="by">filleduchaos</span><span>|</span><a href="#36100162">parent</a><span>|</span><a href="#36099938">next</a><span>|</span><label class="collapse" for="c-36100667">[-]</label><label class="expand" for="c-36100667">[1 more]</label></div><br/><div class="children"><div class="content">Is 70% of the code actually GUI code, or is it business-and-platform-logic-coupled-to-GUI code?</div><br/></div></div></div></div><div id="36099938" class="c"><input type="checkbox" id="c-36099938" checked=""/><div class="controls bullet"><span class="by">bestinterest</span><span>|</span><a href="#36100162">prev</a><span>|</span><a href="#36099298">next</a><span>|</span><label class="collapse" for="c-36099938">[-]</label><label class="expand" for="c-36099938">[7 more]</label></div><br/><div class="children"><div class="content">Noob question,<p>What makes languages like Zig, Rust, C and C++ the best fit for cross platform applications over many garbage collected languages? Why is bringing the language runtime a problem?<p>What does it mean to compile to a C-compatible library?<p>EDIT:<p>I decided to ChatGPT my question instead.<p><a href="https:&#x2F;&#x2F;chat.openai.com&#x2F;share&#x2F;9a5f9f7a-0f5d-4cf6-95fc-4e0ec957c669" rel="nofollow">https:&#x2F;&#x2F;chat.openai.com&#x2F;share&#x2F;9a5f9f7a-0f5d-4cf6-95fc-4e0ec9...</a></div><br/><div id="36100187" class="c"><input type="checkbox" id="c-36100187" checked=""/><div class="controls bullet"><span class="by">alecthomas</span><span>|</span><a href="#36099938">parent</a><span>|</span><a href="#36100878">next</a><span>|</span><label class="collapse" for="c-36100187">[-]</label><label class="expand" for="c-36100187">[1 more]</label></div><br/><div class="children"><div class="content">ChatGPT&#x27;s responses start accurate then quickly go off the rails. The section from this point onwards is completely incorrect:<p>&gt; Say I called a bunch of goroutines when I was in the Add function of the example you gave, would this be a problem?<p>The Go runtime is initialised once only in c-shared mode for the lifetime of the application - it would make no sense to do it on every function invocation, and be incredibly slow. So the answer to this section and the next one are just largely bogus.<p>ie. this response<p>&gt; However, once you call a function via a C or Swift bridge, it becomes a synchronous operation and will block the calling thread until all goroutines have completed execution. Therefore, you would need to effectively manage the synchronization of these goroutines to avoid unnecessary blocking of the calling thread.<p>And the response to this question:<p>&gt; You said in 4 the Go runtime may not keep running, does this mean that every invocation of the Add function has to spin up the whole Go runtime every time? Why cant it just stay alive inside the Swift process?<p>Are completely incorrect.</div><br/></div></div><div id="36100878" class="c"><input type="checkbox" id="c-36100878" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#36099938">parent</a><span>|</span><a href="#36100187">prev</a><span>|</span><a href="#36100088">next</a><span>|</span><label class="collapse" for="c-36100878">[-]</label><label class="expand" for="c-36100878">[1 more]</label></div><br/><div class="children"><div class="content">Pretty much every modern language (Zig, Rust, C, and C++ included) depends on a runtime.  The C runtime is privileged because it is already present on all 3 desktop OSes.<p>It is also a lot smaller than most other runtimes, which makes bundling the C runtime with the program more palatable.<p>A &quot;C-compatible library&quot; is a library (i.e. a collection of functions) that is callable in the same way that functions written in C are called.  Nearly all non-C languages provide a way to call C functions (because, again on all modern desktop OSes, the operating-system interface is written in C).<p>If everyone wrote OS interfaces in perl, then you would want to compile to a perl-compatible library.  If the Lisp machines had won, then you would be compiling to a Common Lisp compatible library.</div><br/></div></div><div id="36100088" class="c"><input type="checkbox" id="c-36100088" checked=""/><div class="controls bullet"><span class="by">dhab</span><span>|</span><a href="#36099938">parent</a><span>|</span><a href="#36100878">prev</a><span>|</span><a href="#36100369">next</a><span>|</span><label class="collapse" for="c-36100088">[-]</label><label class="expand" for="c-36100088">[3 more]</label></div><br/><div class="children"><div class="content">Curious to know from experts in the above to see if ChatGPTs response is valid?
Me as someone who knows nothing about either, looking at a nuanced response from ChatGPT, puts me at awe - esp. response to the question: &quot;Say I called a bunch of goroutines when I was in the Add function of the example you gave, would this be a problem?&quot;</div><br/><div id="36100345" class="c"><input type="checkbox" id="c-36100345" checked=""/><div class="controls bullet"><span class="by">alecthomas</span><span>|</span><a href="#36099938">root</a><span>|</span><a href="#36100088">parent</a><span>|</span><a href="#36100140">next</a><span>|</span><label class="collapse" for="c-36100345">[-]</label><label class="expand" for="c-36100345">[1 more]</label></div><br/><div class="children"><div class="content">As I responded in a sibling comment, this is the point where ChatGPT goes completely off the rails and starts fabricating responses. Temper your awe :)</div><br/></div></div></div></div><div id="36100369" class="c"><input type="checkbox" id="c-36100369" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#36099938">parent</a><span>|</span><a href="#36100088">prev</a><span>|</span><a href="#36099298">next</a><span>|</span><label class="collapse" for="c-36100369">[-]</label><label class="expand" for="c-36100369">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s about the libraries usually, ui lib are all made in c&#x2F;c++ and those &quot;natives&quot; langage have better integration with it ( ffi ).<p>For example calling C from Go is doable, but it&#x27;s not encouraged and sometime a bit slow.<p>On the other hand Go and Java are trully multi platform and it&#x27;s well supported and usually easier to do than other native langages.</div><br/></div></div></div></div><div id="36099298" class="c"><input type="checkbox" id="c-36099298" checked=""/><div class="controls bullet"><span class="by">parhamn</span><span>|</span><a href="#36099938">prev</a><span>|</span><a href="#36098793">next</a><span>|</span><label class="collapse" for="c-36099298">[-]</label><label class="expand" for="c-36099298">[3 more]</label></div><br/><div class="children"><div class="content">How does the api and &quot;bridge&quot; look in this type of setup? I&#x27;m trying to wrap my head around which parts you&#x27;d keep in the cross-platform layer (and whether that layer might be very thin in many applications I&#x27;ve built).<p>If the application is heavy in UI state, does this sort of thing still make sense? I can&#x27;t imagine what hell bidirectional data binding would be in this setup.</div><br/><div id="36099730" class="c"><input type="checkbox" id="c-36099730" checked=""/><div class="controls bullet"><span class="by">mitchellh</span><span>|</span><a href="#36099298">parent</a><span>|</span><a href="#36098793">next</a><span>|</span><label class="collapse" for="c-36099730">[-]</label><label class="expand" for="c-36099730">[2 more]</label></div><br/><div class="children"><div class="content">OP here. UI state lives in the GUI code. For a GUI toolkit like SwiftUI, that&#x27;s quite important ergonomically.<p>I&#x27;m unsure how to really describe how the &quot;bridge&quot; code looks. All GUI interaction code happens in Swift, and when buttons are pressed and so on, I call functions back into Zig, and so on.<p>There are certain scenarios where my Zig code calls back into Swift (via function pointers provided). For example, requesting to quit the application. These are handled using NSNotificationCenter accordingly.<p>As I stated in the post, my cross-platform layer is &gt;90% of my lines of code, and this isn&#x27;t a trivial program, so for my use case this is working great.</div><br/><div id="36099864" class="c"><input type="checkbox" id="c-36099864" checked=""/><div class="controls bullet"><span class="by">parhamn</span><span>|</span><a href="#36099298">root</a><span>|</span><a href="#36099730">parent</a><span>|</span><a href="#36098793">next</a><span>|</span><label class="collapse" for="c-36099864">[-]</label><label class="expand" for="c-36099864">[1 more]</label></div><br/><div class="children"><div class="content">The post is great, hope I didn&#x27;t seem to be critiquing it! I liked the idea so much I wondered if theres a magic reactive layer with data bindings so I could use it in UI heavy cross platform apps.</div><br/></div></div></div></div></div></div><div id="36098793" class="c"><input type="checkbox" id="c-36098793" checked=""/><div class="controls bullet"><span class="by">ellis0n</span><span>|</span><a href="#36099298">prev</a><span>|</span><label class="collapse" for="c-36098793">[-]</label><label class="expand" for="c-36098793">[1 more]</label></div><br/><div class="children"><div class="content">Good job. Please add a few words about debugging.</div><br/></div></div></div></div></div></div></div></body></html>