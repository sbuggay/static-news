<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1717923671388" as="style"/><link rel="stylesheet" href="styles.css?v=1717923671388"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://queue.acm.org/detail.cfm?id=3664645">Zero Tolerance for Bias</a> <span class="domain">(<a href="https://queue.acm.org">queue.acm.org</a>)</span></div><div class="subtext"><span>Harmohit</span> | <span>57 comments</span></div><br/><div><div id="40620655" class="c"><input type="checkbox" id="c-40620655" checked=""/><div class="controls bullet"><span class="by">IAmLiterallyAB</span><span>|</span><a href="#40622802">next</a><span>|</span><label class="collapse" for="c-40620655">[-]</label><label class="expand" for="c-40620655">[18 more]</label></div><br/><div class="children"><div class="content">Interesting, but there&#x27;s one part I&#x27;m not sure I agree with.<p>&gt; Pseudo-random number generators are useful for many purposes, but unbiased shuffling isn&#x27;t one of them.<p>A properly seeded CSPRNG is perfectly fine at this. And if it&#x27;s not, then all of our cryptography is pretty much screwed. This is why in modern kernels, &#x2F;dev&#x2F;random and &#x2F;dev&#x2F;urandom are the same (minus differences in behavior when the initialization isn&#x27;t complete). As D.J. Bernstein put it, it&#x27;s superstition to not trust CSPRNGs. <a href="https:&#x2F;&#x2F;www.mail-archive.com&#x2F;cryptography@randombit.net&#x2F;msg04763.html" rel="nofollow">https:&#x2F;&#x2F;www.mail-archive.com&#x2F;cryptography@randombit.net&#x2F;msg0...</a> And if it&#x27;s good enough for crypto, it&#x27;s good enough for card shuffling.<p>FYI I am not a cryptographer</div><br/><div id="40620950" class="c"><input type="checkbox" id="c-40620950" checked=""/><div class="controls bullet"><span class="by">mlyle</span><span>|</span><a href="#40620655">parent</a><span>|</span><a href="#40620953">next</a><span>|</span><label class="collapse" for="c-40620950">[-]</label><label class="expand" for="c-40620950">[11 more]</label></div><br/><div class="children"><div class="content">There are 52! possible decks of cards— if you don’t have more than 230 bits of entropy in your prng per deck shuffled things go badly pretty quick.  You also tend to share deck state so far with the adversary.<p>Shuffling cards is a surprisingly demanding prng application.</div><br/><div id="40621544" class="c"><input type="checkbox" id="c-40621544" checked=""/><div class="controls bullet"><span class="by">slaymaker1907</span><span>|</span><a href="#40620655">root</a><span>|</span><a href="#40620950">parent</a><span>|</span><a href="#40621287">next</a><span>|</span><label class="collapse" for="c-40621544">[-]</label><label class="expand" for="c-40621544">[3 more]</label></div><br/><div class="children"><div class="content">It’s almost certainly still good enough since it’s unlikely to be biased in ways that matter. Most hand shuffling methods have nasty biases as well.<p>For standard riffle shuffling, there is often a bias in pulling from the pile opposite from the last pulled card (so alternating pairs of left and right). The model saying “7 shuffles is sufficient” as people like to quote presumes you pull from a pile only proportional to the size of the pile (so you get many fewer alternating runs).</div><br/><div id="40622130" class="c"><input type="checkbox" id="c-40622130" checked=""/><div class="controls bullet"><span class="by">Harmohit</span><span>|</span><a href="#40620655">root</a><span>|</span><a href="#40621544">parent</a><span>|</span><a href="#40622480">next</a><span>|</span><label class="collapse" for="c-40622130">[-]</label><label class="expand" for="c-40622130">[1 more]</label></div><br/><div class="children"><div class="content">That is such an interesting idea! I wonder if someone has systematically studied hand shuffling biases and what consequences it has (or should have) for brick and mortar casinos</div><br/></div></div><div id="40622480" class="c"><input type="checkbox" id="c-40622480" checked=""/><div class="controls bullet"><span class="by">tzs</span><span>|</span><a href="#40620655">root</a><span>|</span><a href="#40621544">parent</a><span>|</span><a href="#40622130">prev</a><span>|</span><a href="#40621287">next</a><span>|</span><label class="collapse" for="c-40622480">[-]</label><label class="expand" for="c-40622480">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not even obvious to me that repeated shuffles of this form<p>• Given a deck of 52 cards (C1, C2, ... C52) pick some k near 26 and split the deck into two piles, (C1, C2, ..., Ck) and (Ck+1, ..., C52). Call these piles P1 and P2,<p>• Make a new empty pile, and then repeatedly take cards from the front of P1 or P2 and append those cards to the new pile. Cards from the same source pile should be in the same relative order in the new pile. Continue until all the cards are in the new pile,<p>• When taking cards from P1 or P2 to append to the new pile, take about the same number each time,<p>are capable of resulting in all possible 52! permutations. That kind of shuffle preserves a lot of order so I wondered if there might be some order that it cannot remove.<p>It turns out that you can in fact reach all permutations. I don&#x27;t know of any elegant way to prove this though. I have an ugly way to do so.<p>Let R be a perfect out riffle shuffle, where the deck is split exactly in half (k = 26), and cards are merged by pulling one at a time from alternate piles starting with P1. In other words the deck after one shuffle is (C1, C26, C2, C27, ..., C26, C52).<p>Let S(n) be a shuffle just like R with one exception: when the cards that would end up at positions n and n+1 from the bottom of the shuffled deck are the next two cards to be pulled from P1 and P2 switch the order you pull them.<p>The resulting shuffle is the same as if you did R and then swapped the cards at positions n and n+1 from the bottom.<p>Let O(X) be the &quot;order&quot; of a shuffle X. The order of a shuffle is how many times you have to do apply the shuffle consecutively to get back to where you started. O(R) for example is 8. Start with a new deck and do 8 perfect out riffle shuffles and you will be back to the original order.<p>It turns out that if you take a deck and do O(S(n))-1 shuffles using S(n) and then do an R you get back to where you started except the cards n and n+1 from the bottom are swapped.<p>A swap of any two cards can be accomplished using a series of swaps of adjacent cards and so this gives us a method to swap any two cards in the deck using only R and S shuffles. Since any permutation can be generated using only pair swaps this means any of the 52! possible permutations can be reached using only R and S shuffles.<p>This isn&#x27;t very efficient. Just swapping n and n+1 in the deck this way takes at least 16 shuffles, and many more for some values of n. Here&#x27;s a table:<p><pre><code>      n           # of shuffles
   0, 50            72
   1, 49            56
  16, 17, 33, 34    40
  22, 28           120
   other            16
</code></pre>
Remember, adjacent swaps are just one small step in getting to a given permutation. Actually reaching an arbitrary permutation using R and S shuffles this particular way would take tens of thousands or more shuffles. But it does show that all permutations are reachable using reasonably normal shuffles.</div><br/></div></div></div></div><div id="40621287" class="c"><input type="checkbox" id="c-40621287" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#40620655">root</a><span>|</span><a href="#40620950">parent</a><span>|</span><a href="#40621544">prev</a><span>|</span><a href="#40621256">next</a><span>|</span><label class="collapse" for="c-40621287">[-]</label><label class="expand" for="c-40621287">[3 more]</label></div><br/><div class="children"><div class="content">Counterpoint, even if you only have 256 bits of entropy (which is common for many widely used PRNGs), you can prove that there&#x27;s bias due to the pigeon hole principal, but finding a shuffle that is under-represented is computationally impossible.</div><br/><div id="40621456" class="c"><input type="checkbox" id="c-40621456" checked=""/><div class="controls bullet"><span class="by">pvillano</span><span>|</span><a href="#40620655">root</a><span>|</span><a href="#40621287">parent</a><span>|</span><a href="#40622886">prev</a><span>|</span><a href="#40621256">next</a><span>|</span><label class="collapse" for="c-40621456">[-]</label><label class="expand" for="c-40621456">[1 more]</label></div><br/><div class="children"><div class="content">I can say, infalsifiably, it will be computationally possible eventually</div><br/></div></div></div></div><div id="40621256" class="c"><input type="checkbox" id="c-40621256" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#40620655">root</a><span>|</span><a href="#40620950">parent</a><span>|</span><a href="#40621287">prev</a><span>|</span><a href="#40622111">next</a><span>|</span><label class="collapse" for="c-40621256">[-]</label><label class="expand" for="c-40621256">[1 more]</label></div><br/><div class="children"><div class="content">How many shuffled decks do you need to with 99% confidence determine if I used say Mersenne Twister or a hardware-based RNG?<p>edit: I know MT has a rather large state, but it has some issues. Alternatively what about say one of the 128bit state PCG generators?</div><br/></div></div><div id="40622111" class="c"><input type="checkbox" id="c-40622111" checked=""/><div class="controls bullet"><span class="by">omoikane</span><span>|</span><a href="#40620655">root</a><span>|</span><a href="#40620950">parent</a><span>|</span><a href="#40621256">prev</a><span>|</span><a href="#40621887">next</a><span>|</span><label class="collapse" for="c-40622111">[-]</label><label class="expand" for="c-40622111">[1 more]</label></div><br/><div class="children"><div class="content">&gt; if you don’t have more than 230 bits of entropy<p>Should this be 226 instead of 230, since 2**225 &lt; 52! &lt; 2**226 ?</div><br/></div></div><div id="40621887" class="c"><input type="checkbox" id="c-40621887" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#40620655">root</a><span>|</span><a href="#40620950">parent</a><span>|</span><a href="#40622111">prev</a><span>|</span><a href="#40620953">next</a><span>|</span><label class="collapse" for="c-40621887">[-]</label><label class="expand" for="c-40621887">[2 more]</label></div><br/><div class="children"><div class="content">How fast things go badly is proportional to how well you can measure the bias, isn&#x27;t it?  If you need 2^200 hands to do so, good luck getting there.<p>And a CSPRNG has to be robust to sharing every single bit so far with your adversary.</div><br/><div id="40622035" class="c"><input type="checkbox" id="c-40622035" checked=""/><div class="controls bullet"><span class="by">ilya_m</span><span>|</span><a href="#40620655">root</a><span>|</span><a href="#40621887">parent</a><span>|</span><a href="#40620953">next</a><span>|</span><label class="collapse" for="c-40622035">[-]</label><label class="expand" for="c-40622035">[1 more]</label></div><br/><div class="children"><div class="content">Exactly.<p>&gt; things go badly pretty quick.<p>Dealing 2^200 hands, assuming that one hand takes 1ns, is more than ... pretty much any conceivable physical quantity one can think of. (Technically, the heat death of the universe takes longer than that but all card decks will be long gone, having been consumed by black holes.)<p>This is a long-winded way of saying that cryptography with 2^256 security margin ought to be sufficient for all human-scale applications.</div><br/></div></div></div></div></div></div><div id="40620953" class="c"><input type="checkbox" id="c-40620953" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#40620655">parent</a><span>|</span><a href="#40620950">prev</a><span>|</span><a href="#40622802">next</a><span>|</span><label class="collapse" for="c-40620953">[-]</label><label class="expand" for="c-40620953">[6 more]</label></div><br/><div class="children"><div class="content">A Mersenne twister or another PRNG with a long sequence length is fine for deck shuffling.  A CSPRNG is more comfortable.<p>As to the idea that it&#x27;s superstition not to trust CSPRNGs: sometimes, you want to eliminate the variable, and sometimes your CSPRNG is actually worth attacking.  A lot of CSPRNGs also involve secret state, so if you are worried that this state might get exfiltrated, some paranoia is ok.<p>The post here recommends using Intel&#x27;s RDSEED, which is ironically trusted <i>far</i> less than &#x2F;dev&#x2F;urandom by most people who have a secret to keep or a process to protect.</div><br/><div id="40622063" class="c"><input type="checkbox" id="c-40622063" checked=""/><div class="controls bullet"><span class="by">ilya_m</span><span>|</span><a href="#40620655">root</a><span>|</span><a href="#40620953">parent</a><span>|</span><a href="#40621786">next</a><span>|</span><label class="collapse" for="c-40622063">[-]</label><label class="expand" for="c-40622063">[2 more]</label></div><br/><div class="children"><div class="content">&gt; A Mersenne twister ... is fine for deck shuffling<p>It isn&#x27;t. Please don&#x27;t do that! Mersenne Twister is fully reversible given its 624 consecutive outputs (see, for instance, this pretty good write-up: <a href="https:&#x2F;&#x2F;blog.ollien.com&#x2F;posts&#x2F;reverse-mersenne-twister" rel="nofollow">https:&#x2F;&#x2F;blog.ollien.com&#x2F;posts&#x2F;reverse-mersenne-twister</a>). In other words, someone who can observe 624 outputs can reconstruct its entire output sequence <i>forward</i> and <i>backward</i>.</div><br/><div id="40622907" class="c"><input type="checkbox" id="c-40622907" checked=""/><div class="controls bullet"><span class="by">bluecalm</span><span>|</span><a href="#40620655">root</a><span>|</span><a href="#40622063">parent</a><span>|</span><a href="#40621786">next</a><span>|</span><label class="collapse" for="c-40622907">[-]</label><label class="expand" for="c-40622907">[1 more]</label></div><br/><div class="children"><div class="content">This is very interesting, thank you!
When I was implementing random shuffling I used xoroshiro128+ instead of Mersenne twister and felt pretty good about it but only because it was used for randomness needed for Monte Carlo simulations, not for gambling games where there are potential adversaries looking to break it. 
Are you aware of how that one (xoroshiro128+) or other pseudo random generators fare against adversaries?</div><br/></div></div></div></div><div id="40621786" class="c"><input type="checkbox" id="c-40621786" checked=""/><div class="controls bullet"><span class="by">IAmLiterallyAB</span><span>|</span><a href="#40620655">root</a><span>|</span><a href="#40620953">parent</a><span>|</span><a href="#40622063">prev</a><span>|</span><a href="#40621576">next</a><span>|</span><label class="collapse" for="c-40621786">[-]</label><label class="expand" for="c-40621786">[1 more]</label></div><br/><div class="children"><div class="content">What secret state do you mean? All PRNGs have state right? Which you need to keep secret if you don&#x27;t want the sequence to be predictable. Is there something more I&#x27;m missing?</div><br/></div></div><div id="40621576" class="c"><input type="checkbox" id="c-40621576" checked=""/><div class="controls bullet"><span class="by">kurikuri</span><span>|</span><a href="#40620655">root</a><span>|</span><a href="#40620953">parent</a><span>|</span><a href="#40621786">prev</a><span>|</span><a href="#40622802">next</a><span>|</span><label class="collapse" for="c-40621576">[-]</label><label class="expand" for="c-40621576">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The post here recommends using Intel&#x27;s RDSEED, which is ironically trusted far less than &#x2F;dev&#x2F;urandom by most people who have a secret to keep or a process to protect.<p>What? If security is a special consideration for some form of data, why would someone choose a non-physical noise source over a hardware-based noise source?</div><br/><div id="40621701" class="c"><input type="checkbox" id="c-40621701" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#40620655">root</a><span>|</span><a href="#40621576">parent</a><span>|</span><a href="#40622802">next</a><span>|</span><label class="collapse" for="c-40621701">[-]</label><label class="expand" for="c-40621701">[1 more]</label></div><br/><div class="children"><div class="content">Trust. It&#x27;s suspected that RDSEED is essentially backdoored based on the published structure of the RNG. TRNGs are allowed to use a cryptographic conditioning component on top of a non-full-entropy physical stream, and that is what Intel does, using a long-lived secret key. The output you see is actually the result of cryptographic postprocessing, which may be partially transparent to the entity that has the secret key.<p>Intel has no published third-party audits of their silicon, and has a very close relationship with some three-letter agencies. Hence the concern.<p>By contrast, urandom is completely open, and is reseeded relatively frequently with entropy. If both are effectively acting as a CSPRNG, the one with public attention and no secret key that can be handed to a third party is better.</div><br/></div></div></div></div></div></div></div></div><div id="40620280" class="c"><input type="checkbox" id="c-40620280" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#40622802">prev</a><span>|</span><a href="#40621082">next</a><span>|</span><label class="collapse" for="c-40620280">[-]</label><label class="expand" for="c-40620280">[7 more]</label></div><br/><div class="children"><div class="content">I recently stumbled across some other ways that random number generation can go wrong.<p>Suppose you want reproducible results from a seed, along with parallelism. Algorithmic random number generators are usually mutable and generate a <i>sequence</i> of results, limiting parallelism. Rather than a sequence, you want something tree-shaped where you can create an independent random stream for each child task. In higher-level API&#x27;s, a <i>jump</i> or <i>split</i> operator can be useful.<p>Counter-based random number generators [1] seem pretty useful in that context. An immutable random number generator works like a hash algorithm that maps each input to an output that&#x27;s difficult to predict. The problem with this is being careful to avoid using the same input twice. You can think of it as allocating random numbers from a very large address space in a reproducible way. How do you partition the address space, predictably, so that every address is used at most once, and nobody runs out?<p>Giving each child a unique ID and generating a stream from that is one way. If the tree is deeper, you&#x27;ll want a unique seed for each <i>path</i>.<p>When a mutable random number generator is copied to a child task (or maybe just to an iterator), the same random numbers might be generated in two places. Avoiding this is the sort of thing that Rust&#x27;s borrow checker can prevent - borrowing is okay, but you want to prevent multiple concurrent ownership.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Counter-based_random_number_generator" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Counter-based_random_number_ge...</a></div><br/><div id="40621043" class="c"><input type="checkbox" id="c-40621043" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#40620280">parent</a><span>|</span><a href="#40620876">next</a><span>|</span><label class="collapse" for="c-40621043">[-]</label><label class="expand" for="c-40621043">[2 more]</label></div><br/><div class="children"><div class="content">Another fun one for reproducibility -- rounding. It can happen when compiled for multiple architectures, compiling a second time with different optimizations, .... Things like normal random numbers are generated through _some_ kind of rejection sampling, and crossing that threshold from different rounding behavior will give you a wildly different result. Even if all your application code is tolerant of small perturbations, the result isn&#x27;t reasonably reproducible.<p>Another way things go wrong with the prng tree idea (assuming the implementation is correct and you actually have independent streams) is race conditions in other parts of your code. E.g., say you have two workers reading a queue and using fancy tree-based randomness. You don&#x27;t have &quot;race&quot; conditions (data races) in safe Rust without a compiler bug, but the language doesn&#x27;t define which worker will read which item from the queue. You wind up using a different part of the stream for different inputs.</div><br/><div id="40621376" class="c"><input type="checkbox" id="c-40621376" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#40620280">root</a><span>|</span><a href="#40621043">parent</a><span>|</span><a href="#40620876">next</a><span>|</span><label class="collapse" for="c-40621376">[-]</label><label class="expand" for="c-40621376">[1 more]</label></div><br/><div class="children"><div class="content">With the counter-based RNG approach, apparently one idea is that you uniquely identify child nodes in your tree somehow. That is, each work unit is a node with a unique ID that&#x27;s deterministically assigned and has nothing to do with random number generation at all. Then you use that to pick the random stream.<p>An API that uses <i>split</i> or <i>jump</i> seems a little easier to screw up.</div><br/></div></div></div></div><div id="40620876" class="c"><input type="checkbox" id="c-40620876" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#40620280">parent</a><span>|</span><a href="#40621043">prev</a><span>|</span><a href="#40621766">next</a><span>|</span><label class="collapse" for="c-40620876">[-]</label><label class="expand" for="c-40620876">[3 more]</label></div><br/><div class="children"><div class="content">&gt; When a mutable random number generator is copied to a child task<p>When you make a child task, the parent adds one to the internal state of the random number generator and advances the random sequence by one.  The child adds two to the internal state and advances the random sequence by one.<p>Now you can make any arbitrary tree of tasks, and those tasks each get their own random stream, there is no shared-between-task state or locking needed, and the whole thing is reproducible, even if parent and child tasks are scheduled arbitrarily.   fork-ing and use of random numbers can be arbitrarily intermingled.</div><br/><div id="40620960" class="c"><input type="checkbox" id="c-40620960" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#40620280">root</a><span>|</span><a href="#40620876">parent</a><span>|</span><a href="#40621766">next</a><span>|</span><label class="collapse" for="c-40620960">[-]</label><label class="expand" for="c-40620960">[2 more]</label></div><br/><div class="children"><div class="content">Makes sense. Do you have any particular implementations in mind that work this way?<p>I think this depends on the random number generator. For a counter-based RNG, the &quot;internal state&quot; is just a counter, so adding 1 or 2 would result in reusing random numbers in different streams.</div><br/><div id="40621306" class="c"><input type="checkbox" id="c-40621306" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#40620280">root</a><span>|</span><a href="#40620960">parent</a><span>|</span><a href="#40621766">next</a><span>|</span><label class="collapse" for="c-40621306">[-]</label><label class="expand" for="c-40621306">[1 more]</label></div><br/><div class="children"><div class="content">Julia&#x27;s random number generator does this. See <a href="https:&#x2F;&#x2F;github.com&#x2F;JuliaLang&#x2F;julia&#x2F;blob&#x2F;94a0ee8637b66ab67445aecc5895d79c960ab50d&#x2F;src&#x2F;task.c#L853">https:&#x2F;&#x2F;github.com&#x2F;JuliaLang&#x2F;julia&#x2F;blob&#x2F;94a0ee8637b66ab67445...</a></div><br/></div></div></div></div></div></div><div id="40621766" class="c"><input type="checkbox" id="c-40621766" checked=""/><div class="controls bullet"><span class="by">jerry1979</span><span>|</span><a href="#40620280">parent</a><span>|</span><a href="#40620876">prev</a><span>|</span><a href="#40621082">next</a><span>|</span><label class="collapse" for="c-40621766">[-]</label><label class="expand" for="c-40621766">[1 more]</label></div><br/><div class="children"><div class="content">You may want to have a look at how they do Extended Keys over in bitcoin: <a href="https:&#x2F;&#x2F;learnmeabitcoin.com&#x2F;technical&#x2F;keys&#x2F;hd-wallets&#x2F;extended-keys&#x2F;" rel="nofollow">https:&#x2F;&#x2F;learnmeabitcoin.com&#x2F;technical&#x2F;keys&#x2F;hd-wallets&#x2F;extend...</a></div><br/></div></div></div></div><div id="40621082" class="c"><input type="checkbox" id="c-40621082" checked=""/><div class="controls bullet"><span class="by">tomcam</span><span>|</span><a href="#40620280">prev</a><span>|</span><a href="#40620021">next</a><span>|</span><label class="collapse" for="c-40621082">[-]</label><label class="expand" for="c-40621082">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure I&#x27;ll get roasted for this, but getting the right answer will scratch a years-old itch. Why aren&#x27;t most random number generators seeded using the system clock in addition to the existing algos?</div><br/><div id="40621182" class="c"><input type="checkbox" id="c-40621182" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#40621082">parent</a><span>|</span><a href="#40621421">next</a><span>|</span><label class="collapse" for="c-40621182">[-]</label><label class="expand" for="c-40621182">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not entirely useless, but as a source of entropy, it&#x27;s pretty predictable. You&#x27;d only get a few bits.</div><br/></div></div><div id="40621421" class="c"><input type="checkbox" id="c-40621421" checked=""/><div class="controls bullet"><span class="by">YZF</span><span>|</span><a href="#40621082">parent</a><span>|</span><a href="#40621182">prev</a><span>|</span><a href="#40620021">next</a><span>|</span><label class="collapse" for="c-40621421">[-]</label><label class="expand" for="c-40621421">[1 more]</label></div><br/><div class="children"><div class="content">seeding PRNGs from the system clock is quite common. Using the system time as a source of entropy for generating secure random numbers is problematic because it&#x27;s not random. You want sources that are &quot;noisy&quot; to contribute.<p>Let&#x27;s say we&#x27;re generating some private key, and using the time as a source, and then writing the cert to a file, you&#x27;d probably be able to get a pretty good idea from the timestamp of that file what the system time was when the private key was generated.</div><br/></div></div></div></div><div id="40620021" class="c"><input type="checkbox" id="c-40620021" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#40621082">prev</a><span>|</span><a href="#40619802">next</a><span>|</span><label class="collapse" for="c-40620021">[-]</label><label class="expand" for="c-40620021">[16 more]</label></div><br/><div class="children"><div class="content">Here is a trivial shuffle algorithm that is completely unbiased and only requires an unbiased coin (or random number generator giving bits):<p>1. Randomly assign each element to list A or list B.
2. Recursively shuffle lists A and B.
3. Concatenate lists A and B.<p>To prove it&#x27;s correct, note that assigning a random real number to each element and sorting based on that number is an unbiased shuffle. Then we note the above does in fact do that by considering the fractional base-2 expansion of the random numbers, and noting the above is in fact a base-2 radix sort of these numbers. We can sort these random real numbers even though they have an infinite amount of random bits, as we can stop expanding the digits when the prefix of digits is unique (which corresponds to the event that a list is down to a single element).<p>I call the above algorithm RadixShuffle. You can do it in base-2, but also in other bases. For base-2 you can make it in-place similar to how the partition for Quicksort is implemented in-place, for other bases you either have to do it out-of-place or in two passes (the first pass only counting how many elements go in each bucket to compute offsets).<p>The above can be combined with a fallback algorithm for small N such as Fisher-Yates. I believe even though the above is N log N it can be faster than Fisher-Yates for larger N because it is exceptionally cache-efficient as well as RNG-efficient whereas Fisher-Yates requires a call to the RNG and invokes an expected cache miss for each element.<p>---<p>Another fun fact: you can turn any biased memoryless coin into an unbiased one with a simple trick. Throw the coin twice, if it gives HH or TT you throw away the toss, if it&#x27;s HT or TH you use the first toss as your unbiased coin.<p>This works because if p is the probability that heads comes up we have:<p><pre><code>    HH: p^2
    HT: p(1-p)
    TH: (1-p)p
    TT: (1-p)^2
</code></pre>
Naturally, p(1-p) and (1-p)p are equiprobable, thus if we reject the other outcomes we have distilled an unbiased coin out of our biased coin.</div><br/><div id="40622156" class="c"><input type="checkbox" id="c-40622156" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#40620021">parent</a><span>|</span><a href="#40621061">next</a><span>|</span><label class="collapse" for="c-40622156">[-]</label><label class="expand" for="c-40622156">[2 more]</label></div><br/><div class="children"><div class="content">This is a nice, practical algorithm. Beware though that in theory it can take an unbounded amount of time, since in order for it to make progress it must generate at least one heads <i>and</i> one tails on the input, and although runs of all-heads or all-tails become exponentially unlikely as input size increases (or as the number of passes performed on a fixed-size input increases), there&#x27;s still no guarantee that a mixed run will happen before any fixed amount of computation has been done.<p>If it&#x27;s implemented to run in the typical &quot;depth-first sequential&quot; manner of a recursive algorithm, in which each problem generates its own subproblems, solves them all, and then immediately continues execution until it is itself solved, then it <i>is</i> guaranteed to eventually terminate, since the only way to stall progress forever in this situation would be an infinite, uninterrupted sequence of one outcome (e.g., heads), and that would contradict the assumption that P(heads) = 0.5. OTOH, if a &quot;breadth-first&quot; computation was used, in which all subproblems at a given recursion depth are solved in sequence before any higher-level subproblems, the algorithm could run forever: The top-level problem could produce a mixed run, resulting in two equal-sized subproblems, each of which never makes any progress due to one subproblem always getting all-heads, the other always all-tails.</div><br/><div id="40622869" class="c"><input type="checkbox" id="c-40622869" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#40620021">root</a><span>|</span><a href="#40622156">parent</a><span>|</span><a href="#40621061">next</a><span>|</span><label class="collapse" for="c-40622869">[-]</label><label class="expand" for="c-40622869">[1 more]</label></div><br/><div class="children"><div class="content">Any unbiased algorithm that uses an unbiased coin to shuffle n &gt; 2 elements must be potentially unbounded.<p>Proof: there are n! possible permutations. If the algorithm always finishes within k coin tosses then there are 2^k possible outcomes. For n &gt; 2 we have that n! does not divide 2^k, so not all outcomes can be equiprobable.</div><br/></div></div></div></div><div id="40621061" class="c"><input type="checkbox" id="c-40621061" checked=""/><div class="controls bullet"><span class="by">mlochbaum</span><span>|</span><a href="#40620021">parent</a><span>|</span><a href="#40622156">prev</a><span>|</span><a href="#40621754">next</a><span>|</span><label class="collapse" for="c-40621061">[-]</label><label class="expand" for="c-40621061">[4 more]</label></div><br/><div class="children"><div class="content">I was able to make a variant of the higher-base version that runs in a single pass, by stopping when one partition fills up and using a different method for the remaining (asymptotically few) elements. I described the idea, which is based on another effort called MergeShuffle, here: <a href="https:&#x2F;&#x2F;mlochbaum.github.io&#x2F;BQN&#x2F;implementation&#x2F;primitive&#x2F;random.html#shuffling" rel="nofollow">https:&#x2F;&#x2F;mlochbaum.github.io&#x2F;BQN&#x2F;implementation&#x2F;primitive&#x2F;ran...</a><p>And it is better when N gets large. My implementation set the cutoff at 2^19 elements, although the effect isn&#x27;t too big for a few more powers of two. Here&#x27;s the main radix loop: <a href="https:&#x2F;&#x2F;github.com&#x2F;dzaima&#x2F;CBQN&#x2F;blob&#x2F;v0.7.0&#x2F;src&#x2F;builtins&#x2F;sysfn.c#L476-L486">https:&#x2F;&#x2F;github.com&#x2F;dzaima&#x2F;CBQN&#x2F;blob&#x2F;v0.7.0&#x2F;src&#x2F;builtins&#x2F;sysf...</a></div><br/><div id="40621111" class="c"><input type="checkbox" id="c-40621111" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#40620021">root</a><span>|</span><a href="#40621061">parent</a><span>|</span><a href="#40621754">next</a><span>|</span><label class="collapse" for="c-40621111">[-]</label><label class="expand" for="c-40621111">[3 more]</label></div><br/><div class="children"><div class="content">I found another in-place approach which also does a higher-base version described here: <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2302.03317" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2302.03317</a>, with an open source implementation: <a href="https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;rip_shuffle" rel="nofollow">https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;rip_shuffle</a>. Might want to compare it with your version.</div><br/><div id="40621357" class="c"><input type="checkbox" id="c-40621357" checked=""/><div class="controls bullet"><span class="by">mlochbaum</span><span>|</span><a href="#40620021">root</a><span>|</span><a href="#40621111">parent</a><span>|</span><a href="#40621754">next</a><span>|</span><label class="collapse" for="c-40621357">[-]</label><label class="expand" for="c-40621357">[2 more]</label></div><br/><div class="children"><div class="content">Performance-oriented library with no benchmarking instructions, fun. I get 850ms to shuffle 32-bit integers up to 1e8 with this library versus 400ms in BQN (•rand.Deal•_timed 1e8). However, BQN also has a large advantage at smaller sizes, such as 425us versus 120us for 1e5 elements, so a lot of this may be the random number generator. I haven&#x27;t figured out how to get PCG working yet. BQN uses wyrand which is faster but I now know has quality issues (can&#x27;t even generate every possible output; I need to update the page I linked...).<p>It&#x27;s substantially the same algorithm so any differences would just be down to implementation details. Other than multi-threading which BQN doesn&#x27;t do. The usage is also a little different as BQN generates shuffled integers directly; generating the integers is 100ms of the 850ms for rip_shuffle but I&#x27;m not sure whether it makes sense to subtract that or not.</div><br/><div id="40621468" class="c"><input type="checkbox" id="c-40621468" checked=""/><div class="controls bullet"><span class="by">mlochbaum</span><span>|</span><a href="#40620021">root</a><span>|</span><a href="#40621357">parent</a><span>|</span><a href="#40621754">next</a><span>|</span><label class="collapse" for="c-40621468">[-]</label><label class="expand" for="c-40621468">[1 more]</label></div><br/><div class="children"><div class="content">Not quite the same, rip_shuffle does have some contortions to be able to run in-place (I&#x27;m still scratching my head about who&#x27;s running these sorts of high-performance algorithms with no auxiliary memory available), so if those cost anything they could contribute to the difference.</div><br/></div></div></div></div></div></div></div></div><div id="40621754" class="c"><input type="checkbox" id="c-40621754" checked=""/><div class="controls bullet"><span class="by">tzs</span><span>|</span><a href="#40620021">parent</a><span>|</span><a href="#40621061">prev</a><span>|</span><a href="#40621562">next</a><span>|</span><label class="collapse" for="c-40621754">[-]</label><label class="expand" for="c-40621754">[1 more]</label></div><br/><div class="children"><div class="content">That reminds me of a method for rolling a dN if all you have is a dM.<p>Divide the interval [0, 1) into M equal pieces, [0, 1&#x2F;N), [1&#x2F;N, 2&#x2F;N), ..., [(N-1)&#x2F;N, 1).<p>Use the dM to generate a real number in [0, 1). If that real number is in the interval [(k-1)&#x2F;N, k&#x2F;N), your simulated dN roll is k.<p>To generate a real number in [0, 1) with the dM you simply roll the dM an infinite number of times, and take each roll as a successive base M digit in a base M fraction 0.abcd... where a, b, c, d, etc are base M digits.<p>You don&#x27;t actually have to roll an infinite number of times. You can stop when you have enough digits to tell which interval the number is in. For example if you were trying to roll a d12 using a d10, and the first two d10 rolls are 0 and 7 you can stop, because all base 10 numbers that start with 0.07 are in [0, 1&#x2F;12).<p>If the first two rolls had been 0 and 8 you would have to keep rolling, because although 0.08 is in [0, 1&#x2F;12) subsequent rolls could change that because 1&#x2F;12 = 0.083333(3).<p>For any particular N and M this can be turned into a state graph where you start at the start node and then select links to follow with your dM until you reach a terminal node labeled with the simulated dN value.<p>Here are such graphs for rolling a d7 with a d2 [1], a d7 with a d6 [2], and a d5 with a d8 [3].<p>[1] <a href="https:&#x2F;&#x2F;imgur.com&#x2F;a&#x2F;Qk2kexn" rel="nofollow">https:&#x2F;&#x2F;imgur.com&#x2F;a&#x2F;Qk2kexn</a><p>[2] <a href="https:&#x2F;&#x2F;imgur.com&#x2F;a&#x2F;EhW7lkc" rel="nofollow">https:&#x2F;&#x2F;imgur.com&#x2F;a&#x2F;EhW7lkc</a><p>[3] <a href="https:&#x2F;&#x2F;imgur.com&#x2F;yFmHbnp" rel="nofollow">https:&#x2F;&#x2F;imgur.com&#x2F;yFmHbnp</a></div><br/></div></div><div id="40621562" class="c"><input type="checkbox" id="c-40621562" checked=""/><div class="controls bullet"><span class="by">slaymaker1907</span><span>|</span><a href="#40620021">parent</a><span>|</span><a href="#40621754">prev</a><span>|</span><a href="#40621057">next</a><span>|</span><label class="collapse" for="c-40621562">[-]</label><label class="expand" for="c-40621562">[1 more]</label></div><br/><div class="children"><div class="content">I implemented this for GPUs back in college and you’re right, it’s really good for parallelism. This shuffle is also great if you want to do a completely unbiased shuffle with real cards. Fischer-Yates is impractical to do with a real deck of cards.</div><br/></div></div><div id="40621057" class="c"><input type="checkbox" id="c-40621057" checked=""/><div class="controls bullet"><span class="by">jmount</span><span>|</span><a href="#40620021">parent</a><span>|</span><a href="#40621562">prev</a><span>|</span><a href="#40620124">next</a><span>|</span><label class="collapse" for="c-40621057">[-]</label><label class="expand" for="c-40621057">[1 more]</label></div><br/><div class="children"><div class="content">Nice shuffle, and explanation.  I like how the &quot;no items assign to one of the lists&quot; &quot;wasted&quot; recursions throws out coin flips (which is needed to get the uniform permutation distribution).</div><br/></div></div><div id="40620124" class="c"><input type="checkbox" id="c-40620124" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#40620021">parent</a><span>|</span><a href="#40621057">prev</a><span>|</span><a href="#40621321">next</a><span>|</span><label class="collapse" for="c-40620124">[-]</label><label class="expand" for="c-40620124">[3 more]</label></div><br/><div class="children"><div class="content">Regarding your second fact: if we need N tosses, then is your method the most efficient one?</div><br/><div id="40620201" class="c"><input type="checkbox" id="c-40620201" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#40620021">root</a><span>|</span><a href="#40620124">parent</a><span>|</span><a href="#40621321">next</a><span>|</span><label class="collapse" for="c-40620201">[-]</label><label class="expand" for="c-40620201">[2 more]</label></div><br/><div class="children"><div class="content">Looking into it a bit, it appears that this particular fun fact was first thought of (or at least put to paper) by von Neumann in &quot;Various techniques used in connection with random digits&quot; in 1951. Yuval Peres proves in &quot;Iterating von Neumann&#x27;s procedure for extracting random bits&quot; that if N goes to infinity it approaches the entropy limit.<p>So for particular small choices of N there might be more clever schemes, but for large N you can&#x27;t do a whole lot better.</div><br/></div></div></div></div><div id="40621321" class="c"><input type="checkbox" id="c-40621321" checked=""/><div class="controls bullet"><span class="by">zaik</span><span>|</span><a href="#40620021">parent</a><span>|</span><a href="#40620124">prev</a><span>|</span><a href="#40620605">next</a><span>|</span><label class="collapse" for="c-40621321">[-]</label><label class="expand" for="c-40621321">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you can turn any biased memoryless coin into an unbiased one with a simple trick<p>This trick is mentioned in the article towards the end.</div><br/></div></div><div id="40620605" class="c"><input type="checkbox" id="c-40620605" checked=""/><div class="controls bullet"><span class="by">thaumasiotes</span><span>|</span><a href="#40620021">parent</a><span>|</span><a href="#40621321">prev</a><span>|</span><a href="#40619802">next</a><span>|</span><label class="collapse" for="c-40620605">[-]</label><label class="expand" for="c-40620605">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Here is a trivial shuffle algorithm that is completely unbiased and only requires an unbiased coin (or random number generator giving bits):<p>How does this compare to a regular Knuth shuffle where, since you only have a 1-bit generator, when you need (for example) an integer between 0 and 23, you treat the bits you generate as the binary expansion of a real number in [0, 1), and generate them until floor(24*n) is unambiguous?<p>(Obviously, the random number generation is more conceptually complex, but aside from that.)</div><br/><div id="40621587" class="c"><input type="checkbox" id="c-40621587" checked=""/><div class="controls bullet"><span class="by">slaymaker1907</span><span>|</span><a href="#40620021">root</a><span>|</span><a href="#40620605">parent</a><span>|</span><a href="#40619802">next</a><span>|</span><label class="collapse" for="c-40621587">[-]</label><label class="expand" for="c-40621587">[1 more]</label></div><br/><div class="children"><div class="content">You need at least nlog(n) bits for the same reason as regular shuffling. There are n! permutations and it therefore takes log(n!) bits to uniquely describe a shuffle. nlog(n) is the same as log(n^n) which is obviously greater than log(n!) (this is Stirling’s approximation).</div><br/></div></div></div></div></div></div><div id="40619802" class="c"><input type="checkbox" id="c-40619802" checked=""/><div class="controls bullet"><span class="by">zug_zug</span><span>|</span><a href="#40620021">prev</a><span>|</span><a href="#40619788">next</a><span>|</span><label class="collapse" for="c-40619802">[-]</label><label class="expand" for="c-40619802">[4 more]</label></div><br/><div class="children"><div class="content">Kinda interesting.<p>There are N! permutations in a shuffle (no duplicates) and there&#x27;s an algorithm where you pick one random number between 1-&gt;N! and then bring up that permutation (though I don&#x27;t know how to do it better than N log N with an order-statistic tree). I like this because it requires exactly one random number.<p>A trivial solution in functional programming (for those of us who find this swap stuff really unreadable and error-prone) would be something like:<p>[1,2,3,4,5,6].map(x =&gt; {return {value: x, order: Math.random()}}).sort((a,b) =&gt; (a.order - b.order)).map(x =&gt; x.value)<p>Of course this is N-Log-N, but personally I think it&#x27;s easy to forget how small logN grows. Like log10(number of atoms in universe) = 82, so if your dataset is smaller than the number of atoms in the universe you could think of it as less than the constant 82.</div><br/><div id="40619992" class="c"><input type="checkbox" id="c-40619992" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40619802">parent</a><span>|</span><a href="#40621664">next</a><span>|</span><label class="collapse" for="c-40619992">[-]</label><label class="expand" for="c-40619992">[2 more]</label></div><br/><div class="children"><div class="content">The number of permissions of a deck of cards is 2^225 according to the article. Permissions grow quite quick</div><br/><div id="40620234" class="c"><input type="checkbox" id="c-40620234" checked=""/><div class="controls bullet"><span class="by">zug_zug</span><span>|</span><a href="#40619802">root</a><span>|</span><a href="#40619992">parent</a><span>|</span><a href="#40621664">next</a><span>|</span><label class="collapse" for="c-40620234">[-]</label><label class="expand" for="c-40620234">[1 more]</label></div><br/><div class="children"><div class="content">Yeah. So something like a 50-digit number. I guess your point is this would require a BigInt?<p>From a performance perspective it&#x27;s negligible. Like when doing RSA for example the primes are usually 2^512 in length.</div><br/></div></div></div></div><div id="40621664" class="c"><input type="checkbox" id="c-40621664" checked=""/><div class="controls bullet"><span class="by">pvillano</span><span>|</span><a href="#40619802">parent</a><span>|</span><a href="#40619992">prev</a><span>|</span><a href="#40619788">next</a><span>|</span><label class="collapse" for="c-40621664">[-]</label><label class="expand" for="c-40621664">[1 more]</label></div><br/><div class="children"><div class="content">A real pendant would handle collisions<p>If Math.random() is truly uniform, it has about 53 bits of entropy. We can find the likelyhood of a collision with the birthday paradox<p>... the post ends here because WolframAlpha keeps choking on computations with numbers very, very close to one. I&#x27;m not doing derivatives.<p>Fun fact: Math.random(a,b) always has about 53 bits of randomness, unless b&#x2F;a is close to 1</div><br/></div></div></div></div><div id="40619788" class="c"><input type="checkbox" id="c-40619788" checked=""/><div class="controls bullet"><span class="by">tbrownaw</span><span>|</span><a href="#40619802">prev</a><span>|</span><a href="#40619893">next</a><span>|</span><label class="collapse" for="c-40619788">[-]</label><label class="expand" for="c-40619788">[1 more]</label></div><br/><div class="children"><div class="content">Trusting a broken library seems like a different <i>kind</i> of error than implementing an algorithm that isn&#x27;t quite the algorithm you meant to implement.</div><br/></div></div><div id="40619893" class="c"><input type="checkbox" id="c-40619893" checked=""/><div class="controls bullet"><span class="by">im3w1l</span><span>|</span><a href="#40619788">prev</a><span>|</span><label class="collapse" for="c-40619893">[-]</label><label class="expand" for="c-40619893">[6 more]</label></div><br/><div class="children"><div class="content">Fisher Yates is simple, fast and correct. The only area of improvement I can think of is reducing cache misses.</div><br/><div id="40620306" class="c"><input type="checkbox" id="c-40620306" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#40619893">parent</a><span>|</span><a href="#40620908">next</a><span>|</span><label class="collapse" for="c-40620306">[-]</label><label class="expand" for="c-40620306">[4 more]</label></div><br/><div class="children"><div class="content">That needs some conditions:<p>* original Fisher-Yates is slow; Knuth&#x27;s variation is what makes it fast<p>* Fisher-Yates relies on &quot;generate integer in range&quot;, which is often implemented badly (with bias, or with unnecessary slowness). See the PCG blog for the best-known solution.<p><a href="https:&#x2F;&#x2F;www.pcg-random.org&#x2F;posts&#x2F;bounded-rands.html" rel="nofollow">https:&#x2F;&#x2F;www.pcg-random.org&#x2F;posts&#x2F;bounded-rands.html</a></div><br/><div id="40621969" class="c"><input type="checkbox" id="c-40621969" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#40619893">root</a><span>|</span><a href="#40620306">parent</a><span>|</span><a href="#40620460">next</a><span>|</span><label class="collapse" for="c-40621969">[-]</label><label class="expand" for="c-40621969">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s unnecessary slowness in this situation?  Are we worried about a single division per random number?<p>I wish this page showed some separate charts for fast and slow RNGs and some better slow options.  If you actually care about proper shuffling and the minuscule bias you get from 2^64 % 52 then you should be using a CSPRNG, not a cheap method.</div><br/></div></div><div id="40620460" class="c"><input type="checkbox" id="c-40620460" checked=""/><div class="controls bullet"><span class="by">im3w1l</span><span>|</span><a href="#40619893">root</a><span>|</span><a href="#40620306">parent</a><span>|</span><a href="#40621969">prev</a><span>|</span><a href="#40620908">next</a><span>|</span><label class="collapse" for="c-40620460">[-]</label><label class="expand" for="c-40620460">[2 more]</label></div><br/><div class="children"><div class="content">Modern languages usually provide a generate integer in range primitive.<p>Edit: Even C++ seems to have it nowadays in std::uniform_int_distribution</div><br/><div id="40620787" class="c"><input type="checkbox" id="c-40620787" checked=""/><div class="controls bullet"><span class="by">jltsiren</span><span>|</span><a href="#40619893">root</a><span>|</span><a href="#40620460">parent</a><span>|</span><a href="#40620908">next</a><span>|</span><label class="collapse" for="c-40620787">[-]</label><label class="expand" for="c-40620787">[1 more]</label></div><br/><div class="children"><div class="content">The C++ distributions are problematic, because the standard does not specify the algorithms. If you specify the generator and the seed, you can still get different random numbers on different platforms. Which is why applications that need reproducible results must use another library or implement their own distributions.</div><br/></div></div></div></div></div></div><div id="40620908" class="c"><input type="checkbox" id="c-40620908" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#40619893">parent</a><span>|</span><a href="#40620306">prev</a><span>|</span><label class="collapse" for="c-40620908">[-]</label><label class="expand" for="c-40620908">[1 more]</label></div><br/><div class="children"><div class="content">Floyd optimal sampling is also an interesting algorithm along these lines.</div><br/></div></div></div></div></div></div></div></div></div></body></html>