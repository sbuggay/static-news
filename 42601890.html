<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1736326879435" as="style"/><link rel="stylesheet" href="styles.css?v=1736326879435"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.ganssle.com/debouncing.htm">How to Debounce a Contact (2014)</a> <span class="domain">(<a href="https://www.ganssle.com">www.ganssle.com</a>)</span></div><div class="subtext"><span>user_7832</span> | <span>10 comments</span></div><br/><div><div id="42631459" class="c"><input type="checkbox" id="c-42631459" checked=""/><div class="controls bullet"><span class="by">theamk</span><span>|</span><a href="#42632325">next</a><span>|</span><label class="collapse" for="c-42631459">[-]</label><label class="expand" for="c-42631459">[3 more]</label></div><br/><div class="children"><div class="content">Analysis is nice, although the graph style is very much 2005. 
The conclusion is that as long as you don&#x27;t get a crappy switch, 10mS debounce interval should be sufficient.<p>I would not pay much attention to the rest of the text.<p>The hardware debouncer advice is pretty stale - most of the modern small MCUs have no problem with intermediate levels, nor with high frequency glitches. Schmidt triggers are pretty common, so feel free to ignore the advice and connect cap to MCU input directly. Or skip the cap, and do everything in firmware, MCU will be fine, even with interrupts.<p>(Also, I don&#x27;t get why the text makes firmware debouncer sound hard? There are some very simple and reliable examples, include the last one in the text which only takes a few lines of code.)</div><br/><div id="42632128" class="c"><input type="checkbox" id="c-42632128" checked=""/><div class="controls bullet"><span class="by">michaelt</span><span>|</span><a href="#42631459">parent</a><span>|</span><a href="#42632325">next</a><span>|</span><label class="collapse" for="c-42632128">[-]</label><label class="expand" for="c-42632128">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Also, I don&#x27;t get why the text makes firmware debouncer sound hard?</i><p>The article links to Microchip&#x27;s PIC12F629 which is presumably the type of chip the author was working with at the time.<p>This would usually have been programmed in assembly language. Your program could be no longer than 1024 instructions, and you only had 64 bytes of RAM available.<p>No floating point support, and if you want to multiply or divide integers? You&#x27;ll need to do it in software, using up some of your precious 1024 instructions. You <i>could</i> get a C compiler for the chips, but it cost a week&#x27;s wages - and between the chip&#x27;s incredibly clunky support for indirect addressing and the fact there were only 64 bytes of RAM, languages that needed a stack came at a high price in size and performance too.<p>And while we PC programmers can just get the time as a 64-bit count of milliseconds and not have to worry about rollovers or whether the time changed while you were in the process of reading it - when you only have an 8-bit microcontroller that was an unimaginable luxury. You&#x27;d get an 8-bit clock and a 16-bit clock, and if you needed more than that you&#x27;d use interrupt handlers.<p>It&#x27;s still a neat chip, though - and the entire instruction set could be defined on a single sheet of paper, so although it was assembly language programming it was a lot easier than x86 assembly programming.</div><br/><div id="42632187" class="c"><input type="checkbox" id="c-42632187" checked=""/><div class="controls bullet"><span class="by">Cumpiler69</span><span>|</span><a href="#42631459">root</a><span>|</span><a href="#42632128">parent</a><span>|</span><a href="#42632325">next</a><span>|</span><label class="collapse" for="c-42632187">[-]</label><label class="expand" for="c-42632187">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt;No floating point support, and if you want to multiply or divide integers? You&#x27;ll need to do it in software</i><p>Very much not true as almost nobody ever used floating point in commercial embedded applications. What you use is fractional fixed point integer math. Used to be working in Automotive EV motor control in the past and even though the MCUs&#x2F;DSPs we used had floating point HW for a long time now, we still never ued it for safety and code portability reasons. All math was fractional integer. Maybe today&#x27;s ECUs started using floating point but that was definitely not the case in the past, and every embedded dev wort his salt should be comfortable doing DSP math in without floating point.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fixed-point_arithmetic" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fixed-point_arithmetic</a><p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Q_(number_format)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Q_(number_format)</a></div><br/></div></div></div></div></div></div><div id="42632325" class="c"><input type="checkbox" id="c-42632325" checked=""/><div class="controls bullet"><span class="by">neuroelectron</span><span>|</span><a href="#42631459">prev</a><span>|</span><a href="#42631445">next</a><span>|</span><label class="collapse" for="c-42632325">[-]</label><label class="expand" for="c-42632325">[1 more]</label></div><br/><div class="children"><div class="content">I just bought a horrible Lenovo keyboard with terrible debouncing. For some reason, it seems to only affect the vowels... is this sabotage?</div><br/></div></div><div id="42631445" class="c"><input type="checkbox" id="c-42631445" checked=""/><div class="controls bullet"><span class="by">geerlingguy</span><span>|</span><a href="#42632325">prev</a><span>|</span><a href="#42631541">next</a><span>|</span><label class="collapse" for="c-42631445">[-]</label><label class="expand" for="c-42631445">[1 more]</label></div><br/><div class="children"><div class="content">This is one of the best treatises on debounce, I&#x27;ve read it a number of times and probably will again.<p>One of the best things I&#x27;ve done to help with really bad debounce is spend time testing a number of buttons to find the designs that have, at the hardware&#x2F;contact level, much less bounce. Some buttons wind up with tens of ms of bounce, and it&#x27;s hard to correct for it and meet expectations all in software.</div><br/></div></div><div id="42631541" class="c"><input type="checkbox" id="c-42631541" checked=""/><div class="controls bullet"><span class="by">khafra</span><span>|</span><a href="#42631445">prev</a><span>|</span><a href="#42631423">next</a><span>|</span><label class="collapse" for="c-42631541">[-]</label><label class="expand" for="c-42631541">[1 more]</label></div><br/><div class="children"><div class="content">&gt; One vendor told me reliability simply isn&#x27;t important as users will subconsciously hit the button again and again till the channel changes.<p>Orthogonally to the point of this excellent article, I found it striking how this was probably true, once--and then TVs got smart enough that it took seconds to change channels, instead of milliseconds. And then it was no longer possible for input failures to be corrected subconsciously.</div><br/></div></div><div id="42631423" class="c"><input type="checkbox" id="c-42631423" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#42631541">prev</a><span>|</span><a href="#42601954">next</a><span>|</span><label class="collapse" for="c-42631423">[-]</label><label class="expand" for="c-42631423">[2 more]</label></div><br/><div class="children"><div class="content">My test whenever I get handed someone else&#x27;s code with a debounce routine is to hammer the buttons with rapid presses, gradually slowing down. That shows if the filter is too aggressive and misses legitimate presses. I also see strange behavior when they&#x27;re implemented wrong like extra presses that didn&#x27;t happen or getting stuck thinking the button is still held when it isn&#x27;t.</div><br/><div id="42631691" class="c"><input type="checkbox" id="c-42631691" checked=""/><div class="controls bullet"><span class="by">SOLAR_FIELDS</span><span>|</span><a href="#42631423">parent</a><span>|</span><a href="#42601954">next</a><span>|</span><label class="collapse" for="c-42631691">[-]</label><label class="expand" for="c-42631691">[1 more]</label></div><br/><div class="children"><div class="content">What kind of line of work gives you the ability to discuss debounce routines as an everyday enough occurrence to speak with authority on the matter, if you don’t mind me asking?</div><br/></div></div></div></div><div id="42601954" class="c"><input type="checkbox" id="c-42601954" checked=""/><div class="controls bullet"><span class="by">user_7832</span><span>|</span><a href="#42631423">prev</a><span>|</span><label class="collapse" for="c-42601954">[-]</label><label class="expand" for="c-42601954">[1 more]</label></div><br/><div class="children"><div class="content">I saw this site in one of the comments on <a href="https:&#x2F;&#x2F;hackaday.com&#x2F;2025&#x2F;01&#x2F;04&#x2F;button-debouncing-with-smart-interrupts&#x2F;" rel="nofollow">https:&#x2F;&#x2F;hackaday.com&#x2F;2025&#x2F;01&#x2F;04&#x2F;button-debouncing-with-smart...</a></div><br/></div></div></div></div></div></div></div></body></html>