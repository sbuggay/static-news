<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1710234066489" as="style"/><link rel="stylesheet" href="styles.css?v=1710234066489"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://bughunters.google.com/blog/5108747984306176/google-s-threat-model-for-post-quantum-cryptography">Google&#x27;s threat model for post-quantum cryptography</a> <span class="domain">(<a href="https://bughunters.google.com">bughunters.google.com</a>)</span></div><div class="subtext"><span>yuedongze</span> | <span>48 comments</span></div><br/><div><div id="39673739" class="c"><input type="checkbox" id="c-39673739" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#39676248">next</a><span>|</span><label class="collapse" for="c-39673739">[-]</label><label class="expand" for="c-39673739">[19 more]</label></div><br/><div class="children"><div class="content"><i>Stateless tokens come with independent security concerns, and moving towards stateful tokens is prudent just to ensure more robust systems. [...] Our main recommendation is to use stateful tokens where possible, given their additional security benefits.</i><p>This is smart. PQC schemes often add too much overhead for interoperable cookie sizes. Instead of trying to cram a PQC signature into a cookie, just stop using the stateless cookie designs that require asymmetric signatures.<p>I&#x27;m not sure I buy the Global Risk Institute chart. I get that they need to motivate adoption, but practical cryptanalytic work with quantum computers seems unpromising right now.</div><br/><div id="39674493" class="c"><input type="checkbox" id="c-39674493" checked=""/><div class="controls bullet"><span class="by">adtac</span><span>|</span><a href="#39673739">parent</a><span>|</span><a href="#39674798">next</a><span>|</span><label class="collapse" for="c-39674493">[-]</label><label class="expand" for="c-39674493">[7 more]</label></div><br/><div class="children"><div class="content">Even if the cookie size limit was 8192 bytes instead of 4096, I think it&#x27;s insane to include a several KB signature on every request over the network (literally worth multiple packets). It&#x27;s not a big deal if the payload is a large media file, but JWTs are most commonly used in the kind of API requests where the body is often empty or something tiny like {&quot;success&quot;: true}. It&#x27;d be a shame to undo all the wins from things like smaller TLS handshakes using ECDSA (more of a pleasant side effect, but still).</div><br/><div id="39674638" class="c"><input type="checkbox" id="c-39674638" checked=""/><div class="controls bullet"><span class="by">esprehn</span><span>|</span><a href="#39673739">root</a><span>|</span><a href="#39674493">parent</a><span>|</span><a href="#39674798">next</a><span>|</span><label class="collapse" for="c-39674638">[-]</label><label class="expand" for="c-39674638">[6 more]</label></div><br/><div class="children"><div class="content">The header dictionary for http2 makes large headers like cookies less of an issue:
<a href="https:&#x2F;&#x2F;blog.cloudflare.com&#x2F;hpack-the-silent-killer-feature-of-http-2&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.cloudflare.com&#x2F;hpack-the-silent-killer-feature-...</a><p>Which means it&#x27;s only sent once per connection.</div><br/><div id="39674728" class="c"><input type="checkbox" id="c-39674728" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#39673739">root</a><span>|</span><a href="#39674638">parent</a><span>|</span><a href="#39674798">next</a><span>|</span><label class="collapse" for="c-39674728">[-]</label><label class="expand" for="c-39674728">[5 more]</label></div><br/><div class="children"><div class="content">This is good for browsers which do a ton of requests to the same resource. It&#x27;s less useful for service-oriented architecture where services would more often talk to other services through an LB, often contacting different nodes.</div><br/><div id="39675752" class="c"><input type="checkbox" id="c-39675752" checked=""/><div class="controls bullet"><span class="by">nimih</span><span>|</span><a href="#39673739">root</a><span>|</span><a href="#39674728">parent</a><span>|</span><a href="#39674798">next</a><span>|</span><label class="collapse" for="c-39675752">[-]</label><label class="expand" for="c-39675752">[4 more]</label></div><br/><div class="children"><div class="content">Are you regularly using stateless, asymmetrically-encrypted tokens during service-to-service communication? That strikes me as a rather odd architecture decision, but maybe there&#x27;s something I&#x27;m missing.</div><br/><div id="39676660" class="c"><input type="checkbox" id="c-39676660" checked=""/><div class="controls bullet"><span class="by">YeBanKo</span><span>|</span><a href="#39673739">root</a><span>|</span><a href="#39675752">parent</a><span>|</span><a href="#39674798">next</a><span>|</span><label class="collapse" for="c-39676660">[-]</label><label class="expand" for="c-39676660">[3 more]</label></div><br/><div class="children"><div class="content">Istio with JWT seems petty common.</div><br/><div id="39676686" class="c"><input type="checkbox" id="c-39676686" checked=""/><div class="controls bullet"><span class="by">andy_ppp</span><span>|</span><a href="#39673739">root</a><span>|</span><a href="#39676660">parent</a><span>|</span><a href="#39674798">next</a><span>|</span><label class="collapse" for="c-39676686">[-]</label><label class="expand" for="c-39676686">[2 more]</label></div><br/><div class="children"><div class="content">True, but I think doing something just because a lot of other people are doing it doesn’t make it good or correct.</div><br/><div id="39676779" class="c"><input type="checkbox" id="c-39676779" checked=""/><div class="controls bullet"><span class="by">YeBanKo</span><span>|</span><a href="#39673739">root</a><span>|</span><a href="#39676686">parent</a><span>|</span><a href="#39674798">next</a><span>|</span><label class="collapse" for="c-39676779">[-]</label><label class="expand" for="c-39676779">[1 more]</label></div><br/><div class="children"><div class="content">Well, the question was about how often is it used, not how well it serves the purpose. So I&#x27;d say pretty often.<p>Having a data storage accessible for every service that needs authentication and authorization (and ideally every service needs at least authentication) is non trivial in distributed enterprise environment. To have a stateful token, you need to have a distributed scalable storage, unless you have only one instance. You need to be able to connect to it, hence distribute and manage database password. Anything symmetric requires a more sophisticated secret management.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="39674798" class="c"><input type="checkbox" id="c-39674798" checked=""/><div class="controls bullet"><span class="by">_tk_</span><span>|</span><a href="#39673739">parent</a><span>|</span><a href="#39674493">prev</a><span>|</span><a href="#39674159">next</a><span>|</span><label class="collapse" for="c-39674798">[-]</label><label class="expand" for="c-39674798">[1 more]</label></div><br/><div class="children"><div class="content">They mention they are working on their own QC. In corporate logic, using a third party projection to make a statement about where you are headed seems absolutely legit to me.</div><br/></div></div><div id="39674348" class="c"><input type="checkbox" id="c-39674348" checked=""/><div class="controls bullet"><span class="by">dist-epoch</span><span>|</span><a href="#39673739">parent</a><span>|</span><a href="#39674159">prev</a><span>|</span><a href="#39676248">next</a><span>|</span><label class="collapse" for="c-39674348">[-]</label><label class="expand" for="c-39674348">[9 more]</label></div><br/><div class="children"><div class="content">Is there any insight why there is no PQC signature with a short signature?<p>Is it just us failing to find one, or something more fundamental prevents a quantum resistant short signature like?</div><br/><div id="39675564" class="c"><input type="checkbox" id="c-39675564" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#39673739">root</a><span>|</span><a href="#39674348">parent</a><span>|</span><a href="#39675031">next</a><span>|</span><label class="collapse" for="c-39675564">[-]</label><label class="expand" for="c-39675564">[1 more]</label></div><br/><div class="children"><div class="content">Keep in mind it took us quite a while to move to short (ECC based) public key schemes for classical crypto. Although some of that is for non-technical reasons.</div><br/></div></div><div id="39675031" class="c"><input type="checkbox" id="c-39675031" checked=""/><div class="controls bullet"><span class="by">maple3142</span><span>|</span><a href="#39673739">root</a><span>|</span><a href="#39674348">parent</a><span>|</span><a href="#39675564">prev</a><span>|</span><a href="#39674873">next</a><span>|</span><label class="collapse" for="c-39675031">[-]</label><label class="expand" for="c-39675031">[2 more]</label></div><br/><div class="children"><div class="content">SQIsign is relatively small and fast to verify, but it is pretty slow to sign.</div><br/><div id="39677256" class="c"><input type="checkbox" id="c-39677256" checked=""/><div class="controls bullet"><span class="by">nmadden</span><span>|</span><a href="#39673739">root</a><span>|</span><a href="#39675031">parent</a><span>|</span><a href="#39674873">next</a><span>|</span><label class="collapse" for="c-39677256">[-]</label><label class="expand" for="c-39677256">[1 more]</label></div><br/><div class="children"><div class="content">Well, SQIsign signatures are about the same size (204 bytes) than RSA-2048 (256 bytes). So ok, but most people who care about size on the wire have moved to EC sigs, which are much smaller (64 bytes). And “fast to verify” is not really true: 50ms is not fast — both RSA and Ed25519 signature verification is &lt;0.1ms.</div><br/></div></div></div></div><div id="39674873" class="c"><input type="checkbox" id="c-39674873" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#39673739">root</a><span>|</span><a href="#39674348">parent</a><span>|</span><a href="#39675031">prev</a><span>|</span><a href="#39674585">next</a><span>|</span><label class="collapse" for="c-39674873">[-]</label><label class="expand" for="c-39674873">[1 more]</label></div><br/><div class="children"><div class="content">There is! It just takes milliseconds to verify and has questionable security</div><br/></div></div><div id="39674585" class="c"><input type="checkbox" id="c-39674585" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#39673739">root</a><span>|</span><a href="#39674348">parent</a><span>|</span><a href="#39674873">prev</a><span>|</span><a href="#39674445">next</a><span>|</span><label class="collapse" for="c-39674585">[-]</label><label class="expand" for="c-39674585">[3 more]</label></div><br/><div class="children"><div class="content">I’m confused because there are such things. What you want here is authentication, and there are hashing modes which provide that.</div><br/><div id="39674690" class="c"><input type="checkbox" id="c-39674690" checked=""/><div class="controls bullet"><span class="by">some_furry</span><span>|</span><a href="#39673739">root</a><span>|</span><a href="#39674585">parent</a><span>|</span><a href="#39674445">next</a><span>|</span><label class="collapse" for="c-39674690">[-]</label><label class="expand" for="c-39674690">[2 more]</label></div><br/><div class="children"><div class="content">They specifically asked about PQC signatures, not MACs.</div><br/><div id="39677176" class="c"><input type="checkbox" id="c-39677176" checked=""/><div class="controls bullet"><span class="by">nmadden</span><span>|</span><a href="#39673739">root</a><span>|</span><a href="#39674690">parent</a><span>|</span><a href="#39674445">next</a><span>|</span><label class="collapse" for="c-39677176">[-]</label><label class="expand" for="c-39677176">[1 more]</label></div><br/><div class="children"><div class="content">Well, there are PQC (public key) signature schemes based on hash functions, but they all have large signatures (in the multi-kB range) and other drawbacks (eg being stateful).<p>Moving to a MAC is also not a crazy idea in a lot of deployments. You can horizontally scale an internal MAC validation service. I believe Facebook use MAC-based tokens internally (CATs).</div><br/></div></div></div></div></div></div><div id="39674445" class="c"><input type="checkbox" id="c-39674445" checked=""/><div class="controls bullet"><span class="by">some_furry</span><span>|</span><a href="#39673739">root</a><span>|</span><a href="#39674348">parent</a><span>|</span><a href="#39674585">prev</a><span>|</span><a href="#39676248">next</a><span>|</span><label class="collapse" for="c-39674445">[-]</label><label class="expand" for="c-39674445">[1 more]</label></div><br/><div class="children"><div class="content">The kind of math problems that are hard for quantum computers to break tend to produce kilobyte+ outputs at our target security levels.</div><br/></div></div></div></div></div></div><div id="39676248" class="c"><input type="checkbox" id="c-39676248" checked=""/><div class="controls bullet"><span class="by">thadt</span><span>|</span><a href="#39673739">prev</a><span>|</span><a href="#39674287">next</a><span>|</span><label class="collapse" for="c-39676248">[-]</label><label class="expand" for="c-39676248">[1 more]</label></div><br/><div class="children"><div class="content">A counter-point that perhaps everyone is taking PQ a bit too seriously [1].<p>Personally, it seems reasonable to at least spend some effort preparing for it, given the rather long lead time required to develop, study and stress the constructions needed. It might be a long time (if ever) before cryptographically relevant quantum computers show up, but if they do, we&#x27;ll be glad we had a decade or two to get ready. The alternative of scrambling at the last minute while everything gets cracked seems unenviable.<p>[1] <a href="https:&#x2F;&#x2F;www.cs.auckland.ac.nz&#x2F;~pgut001&#x2F;pubs&#x2F;heffalump_crypto.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cs.auckland.ac.nz&#x2F;~pgut001&#x2F;pubs&#x2F;heffalump_crypto...</a></div><br/></div></div><div id="39674287" class="c"><input type="checkbox" id="c-39674287" checked=""/><div class="controls bullet"><span class="by">JanisErdmanis</span><span>|</span><a href="#39676248">prev</a><span>|</span><a href="#39674271">next</a><span>|</span><label class="collapse" for="c-39674287">[-]</label><label class="expand" for="c-39674287">[5 more]</label></div><br/><div class="children"><div class="content">The threat estimate for a quantum computer that breaks cryptography shall be based on currently available data and the understanding that only the Schor algorithm is known to provide exponential speedup for factorisation.<p>Let’s give IBM credit for attempting to factor in the number 35 in 2022, although they failed there [1]. Before that, the successful factorisation happened for the number 21 in 2012 [2] and the first factorisation of 15 in 2001 [3].<p>Now we have three points. There is a trend that the factorised number grows by a number of 10 for every ten years. Thus, to get a quantum computer that facilitates RSA-2048, we shall wait for 2^2048 years.<p>[1]: <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2103.13855v1.pdf" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2103.13855v1.pdf</a><p>[2]: <a href="https:&#x2F;&#x2F;www.nature.com&#x2F;articles&#x2F;nphoton.2012.259" rel="nofollow">https:&#x2F;&#x2F;www.nature.com&#x2F;articles&#x2F;nphoton.2012.259</a><p>[3]: <a href="https:&#x2F;&#x2F;www.nature.com&#x2F;articles&#x2F;414883a" rel="nofollow">https:&#x2F;&#x2F;www.nature.com&#x2F;articles&#x2F;414883a</a></div><br/><div id="39674880" class="c"><input type="checkbox" id="c-39674880" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#39674287">parent</a><span>|</span><a href="#39674357">next</a><span>|</span><label class="collapse" for="c-39674880">[-]</label><label class="expand" for="c-39674880">[1 more]</label></div><br/><div class="children"><div class="content">I think they must not be planning on the trend being linear. Maybe we’re at the linear looking beginning of a sigmoid.<p>It seems like a reasonable bet on their part, in the sense that Google has a lot of money to play with. Even if it is unlikely that it takes off, behind hit by quantum attacks would be pretty bad for them, so maybe they see it as insurance against an unlikely but catastrophic event.</div><br/></div></div><div id="39674357" class="c"><input type="checkbox" id="c-39674357" checked=""/><div class="controls bullet"><span class="by">smburdick</span><span>|</span><a href="#39674287">parent</a><span>|</span><a href="#39674880">prev</a><span>|</span><a href="#39674271">next</a><span>|</span><label class="collapse" for="c-39674357">[-]</label><label class="expand" for="c-39674357">[3 more]</label></div><br/><div class="children"><div class="content">From [1]:<p>&gt; We implemented the algorithm on IBM quantum processors using only 5 qubits<p>Last December, a team based out of Harvard demonstrated the ability to scale up to 48 logical qubits: <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2312.03982" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2312.03982</a><p>It has been shown that, to factor an integer with n bits, Shor&#x27;s algorithm requires ~2n logical qubits: <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;quant-ph&#x2F;0205095.pdf" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;quant-ph&#x2F;0205095.pdf</a></div><br/><div id="39675869" class="c"><input type="checkbox" id="c-39675869" checked=""/><div class="controls bullet"><span class="by">fsh</span><span>|</span><a href="#39674287">root</a><span>|</span><a href="#39674357">parent</a><span>|</span><a href="#39674468">next</a><span>|</span><label class="collapse" for="c-39675869">[-]</label><label class="expand" for="c-39675869">[1 more]</label></div><br/><div class="children"><div class="content">Running Shor&#x27;s algorithm requires essentially error-free logical qubits. Not a single logical qubit of that quality has ever been demonstrated. The Harvard results are impressive, but their logical qubits are worse than some physical qubits.</div><br/></div></div><div id="39674468" class="c"><input type="checkbox" id="c-39674468" checked=""/><div class="controls bullet"><span class="by">JanisErdmanis</span><span>|</span><a href="#39674287">root</a><span>|</span><a href="#39674357">parent</a><span>|</span><a href="#39675869">prev</a><span>|</span><a href="#39674271">next</a><span>|</span><label class="collapse" for="c-39674468">[-]</label><label class="expand" for="c-39674468">[1 more]</label></div><br/><div class="children"><div class="content">It is not enough to place qubits on a single chip or on a grid. We already know how to do that. The hard part is keeping them isolated while allowing arbitrary control of their interference.<p>The core issue why Schor algorithm is hard is that it requires exponential supppression of error with number of qubits to produce meaningful results. Therefore we don’t actually see much results here as the error rates have not yet reached thresholds to do it with more qubits. The error correction would not be a panacea either because it would necessitate it’s repeated application to get necessary threshold to run Schor algorithm. This would require unreasonable amount of physical qubits.</div><br/></div></div></div></div></div></div><div id="39674271" class="c"><input type="checkbox" id="c-39674271" checked=""/><div class="controls bullet"><span class="by">xyst</span><span>|</span><a href="#39674287">prev</a><span>|</span><a href="#39674340">next</a><span>|</span><label class="collapse" for="c-39674271">[-]</label><label class="expand" for="c-39674271">[7 more]</label></div><br/><div class="children"><div class="content">Besides encrypting your user data at rest using these post-quantum cryptography algo.<p>What can be done from a design point of view to make it as hard as possible to deter attackers?<p>Would it make sense to segregate different types of data into other dbs rather than as a separate table?<p>“Name DB”
“Account DB”
“Address DB”<p>An attacker would need to have advanced knowledge of the app backend to know you have to snag both the account db and address db. Otherwise, the decrypted data is useless with only 1 db.<p>Drawbacks of course include “performance degradation”, “increasingly complex app”.<p>Ideally, if you did not need to store sensitive data or collect other user info such as address or zip code. Then not asking for it at all would be optimal. Maybe regulation is needed here.</div><br/><div id="39674428" class="c"><input type="checkbox" id="c-39674428" checked=""/><div class="controls bullet"><span class="by">ogurechny</span><span>|</span><a href="#39674271">parent</a><span>|</span><a href="#39674825">next</a><span>|</span><label class="collapse" for="c-39674428">[-]</label><label class="expand" for="c-39674428">[1 more]</label></div><br/><div class="children"><div class="content">Assumed attackers owning quantum computers probably have much better “Address DB” than yours.<p>As for regular assessment of your secure infrastructure, you can read latest “Algorithms, Key Size and Protocols Report”:<p><a href="https:&#x2F;&#x2F;www.ecrypt.eu.org&#x2F;csa&#x2F;documents&#x2F;D5.4-FinalAlgKeySizeProt.pdf" rel="nofollow">https:&#x2F;&#x2F;www.ecrypt.eu.org&#x2F;csa&#x2F;documents&#x2F;D5.4-FinalAlgKeySize...</a><p>and practical part of ENISA report:<p><a href="https:&#x2F;&#x2F;www.enisa.europa.eu&#x2F;publications&#x2F;post-quantum-cryptography-integration-study" rel="nofollow">https:&#x2F;&#x2F;www.enisa.europa.eu&#x2F;publications&#x2F;post-quantum-crypto...</a></div><br/></div></div><div id="39674825" class="c"><input type="checkbox" id="c-39674825" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#39674271">parent</a><span>|</span><a href="#39674428">prev</a><span>|</span><a href="#39674335">next</a><span>|</span><label class="collapse" for="c-39674825">[-]</label><label class="expand" for="c-39674825">[1 more]</label></div><br/><div class="children"><div class="content">If I were an adversary possessing a (quantum) code-breaking device, who can break into your infra that uses a (pre-quantum) encryption for authorization, I probably would attach a debugger to your worker process, and find out about all your databases, and maybe hijacked a live connection to one.<p>If I only could get access to nothing but one database, and every table &#x2F; segment of it were encrypted differently, it would likely take as much effort to break into each of them, as if they were &quot;physically separate&quot; databases.</div><br/></div></div><div id="39674335" class="c"><input type="checkbox" id="c-39674335" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#39674271">parent</a><span>|</span><a href="#39674825">prev</a><span>|</span><a href="#39674378">next</a><span>|</span><label class="collapse" for="c-39674335">[-]</label><label class="expand" for="c-39674335">[3 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t make sense:<p>- i think encryption at rest would probably just use symmeyric encryption which is unaffected by shor<p>- how does the attacker get into your network in this scenario. Stuff encrypted at rest by definition is not flying around the network.<p>- what sort of scenario would be involved where the attacker knows how to get one db but not the others? The hard part is figuring out the first db<p>&gt; Drawbacks of course include “performance degradation”, “increasingly complex app”.<p>On the contrary, sharding is a super common performance technique.</div><br/><div id="39675077" class="c"><input type="checkbox" id="c-39675077" checked=""/><div class="controls bullet"><span class="by">4death4</span><span>|</span><a href="#39674271">root</a><span>|</span><a href="#39674335">parent</a><span>|</span><a href="#39674378">next</a><span>|</span><label class="collapse" for="c-39675077">[-]</label><label class="expand" for="c-39675077">[2 more]</label></div><br/><div class="children"><div class="content">Minor nit, symmetric encryption is “impacted” by QC, see Grover’s algorithm. The speed up isn’t as fast, though.</div><br/><div id="39675516" class="c"><input type="checkbox" id="c-39675516" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#39674271">root</a><span>|</span><a href="#39675077">parent</a><span>|</span><a href="#39674378">next</a><span>|</span><label class="collapse" for="c-39675516">[-]</label><label class="expand" for="c-39675516">[1 more]</label></div><br/><div class="children"><div class="content">it is also trivial to work around by just doubling the key length. But even without that the speed up is slow enough that we will be well within the quantum age before this matters. The article talks about this a bit.</div><br/></div></div></div></div></div></div><div id="39674378" class="c"><input type="checkbox" id="c-39674378" checked=""/><div class="controls bullet"><span class="by">arccy</span><span>|</span><a href="#39674271">parent</a><span>|</span><a href="#39674335">prev</a><span>|</span><a href="#39674340">next</a><span>|</span><label class="collapse" for="c-39674378">[-]</label><label class="expand" for="c-39674378">[1 more]</label></div><br/><div class="children"><div class="content">Typically once you get access you just try to dump everything and figure it out later. Splitting into separate stores is just convoluting your day to day for minimal inconvenience to a possibly non-existent an adversary.<p>The only real protection is encryption.</div><br/></div></div></div></div><div id="39674340" class="c"><input type="checkbox" id="c-39674340" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#39674271">prev</a><span>|</span><a href="#39675790">next</a><span>|</span><label class="collapse" for="c-39674340">[-]</label><label class="expand" for="c-39674340">[2 more]</label></div><br/><div class="children"><div class="content">&gt; There are several alternatives to simply replacing classical signatures with quantum-safe signatures, which could address the performance issues when it comes to PKI. We are currently looking to experiment in this space to gather data for more solid recommendations, which we will share in a future blog post.<p>Does anyone know what those alternatives might be?  Some way to collapse a chain of signatures into one?  Long-term symmetric session keys?  Neither of those sound like good ideas but I&#x27;m grasping at straws.</div><br/><div id="39674495" class="c"><input type="checkbox" id="c-39674495" checked=""/><div class="controls bullet"><span class="by">agl</span><span>|</span><a href="#39674340">parent</a><span>|</span><a href="#39675790">next</a><span>|</span><label class="collapse" for="c-39674495">[-]</label><label class="expand" for="c-39674495">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;draft-davidben-tls-merkle-tree-certs&#x2F;" rel="nofollow">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;draft-davidben-tls-merkle-t...</a></div><br/></div></div></div></div><div id="39675790" class="c"><input type="checkbox" id="c-39675790" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#39674340">prev</a><span>|</span><a href="#39674082">next</a><span>|</span><label class="collapse" for="c-39675790">[-]</label><label class="expand" for="c-39675790">[2 more]</label></div><br/><div class="children"><div class="content">Just from reading this it&#x27;s a bit unclear to me why they recommend only SPHINCS+ for &quot;Firmware Signatures&quot;, while for  &quot;Software Signatures&quot; they recommend Dilithium3+hybrid <i>or</i> SPHINCS+.<p>Is SPHINCS+ more lightweight?</div><br/><div id="39676688" class="c"><input type="checkbox" id="c-39676688" checked=""/><div class="controls bullet"><span class="by">eyeofthenico</span><span>|</span><a href="#39675790">parent</a><span>|</span><a href="#39674082">next</a><span>|</span><label class="collapse" for="c-39676688">[-]</label><label class="expand" for="c-39676688">[1 more]</label></div><br/><div class="children"><div class="content">SPHINX+ is actually slower (which does not matter much as firmware signatures generation or verification are not time critical) but it is the most conservative choice available (avoids only relying on the security of lattices for signatures), which is very valuable for firmware that cannot be easily updated if a security issue arises with lattice-based signatures. It also offers the smallest public key size, which may help for devices with limited storage.</div><br/></div></div></div></div><div id="39674082" class="c"><input type="checkbox" id="c-39674082" checked=""/><div class="controls bullet"><span class="by">dvh</span><span>|</span><a href="#39675790">prev</a><span>|</span><a href="#39675354">next</a><span>|</span><label class="collapse" for="c-39674082">[-]</label><label class="expand" for="c-39674082">[4 more]</label></div><br/><div class="children"><div class="content">This may be a naive question but why not go back to Vernam? Storage is cheap.</div><br/><div id="39674469" class="c"><input type="checkbox" id="c-39674469" checked=""/><div class="controls bullet"><span class="by">GuB-42</span><span>|</span><a href="#39674082">parent</a><span>|</span><a href="#39674196">next</a><span>|</span><label class="collapse" for="c-39674469">[-]</label><label class="expand" for="c-39674469">[1 more]</label></div><br/><div class="children"><div class="content">In addition to the usual argument about the impracticality of the one time pad. There is also that it is symmetric cryptography (the one time pad is a shared secret).<p>Symmetric algorithms (AES-256 in particular) are generally considered to be quantum resistant. Here is what written about it in the article.<p>&gt; Symmetric cryptography, using a single secret key to encrypt and authenticate data: In our current understanding, symmetric cryptography is not impacted by quantum computers for all practical purposes. Grover&#x27;s algorithm could be used as an attack here, but is currently considered infeasible for even medium-term quantum computers. (See &quot;Reassessing Grover&#x27;s Algorithm, 2017&quot;)<p>The algorithms most affected by quantum cryptanalysis are public key (asymmetrical) algorithms, because we already have effective quantum algorithms against them (Shor&#x27;s in particular). We are not even close to having the computer though.</div><br/></div></div><div id="39674196" class="c"><input type="checkbox" id="c-39674196" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#39674082">parent</a><span>|</span><a href="#39674469">prev</a><span>|</span><a href="#39674692">next</a><span>|</span><label class="collapse" for="c-39674196">[-]</label><label class="expand" for="c-39674196">[1 more]</label></div><br/><div class="children"><div class="content">OTP is deeply impractical.<p>How do you distribute your pads? (hint: it&#x27;s a chicken-and-egg problem, you need a secure channel)<p>How do you ensure they&#x27;re only ever used once?<p>In its most obvious instantiation, you get no authentication. So now you have to build an authentication mechanism on top. There&#x27;s simply no point, when we have better solutions already.<p>And to top it all off, symmetric ciphers aren&#x27;t threatened by quantum computing in the first place.</div><br/></div></div><div id="39674692" class="c"><input type="checkbox" id="c-39674692" checked=""/><div class="controls bullet"><span class="by">Analemma_</span><span>|</span><a href="#39674082">parent</a><span>|</span><a href="#39674196">prev</a><span>|</span><a href="#39675354">next</a><span>|</span><label class="collapse" for="c-39674692">[-]</label><label class="expand" for="c-39674692">[1 more]</label></div><br/><div class="children"><div class="content">One-time pads just trade an encryption problem for a secure key distribution problem, the latter being much, much harder.</div><br/></div></div></div></div><div id="39675354" class="c"><input type="checkbox" id="c-39675354" checked=""/><div class="controls bullet"><span class="by">deadbabe</span><span>|</span><a href="#39674082">prev</a><span>|</span><a href="#39673737">next</a><span>|</span><label class="collapse" for="c-39675354">[-]</label><label class="expand" for="c-39675354">[2 more]</label></div><br/><div class="children"><div class="content">How close or far do people speculate we are from Q-Day?</div><br/><div id="39676998" class="c"><input type="checkbox" id="c-39676998" checked=""/><div class="controls bullet"><span class="by">asystole</span><span>|</span><a href="#39675354">parent</a><span>|</span><a href="#39673737">next</a><span>|</span><label class="collapse" for="c-39676998">[-]</label><label class="expand" for="c-39676998">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a chart (referenced from [0]) in TFA.<p>[0]: <a href="https:&#x2F;&#x2F;globalriskinstitute.org&#x2F;publication&#x2F;2023-quantum-threat-timeline-report&#x2F;" rel="nofollow">https:&#x2F;&#x2F;globalriskinstitute.org&#x2F;publication&#x2F;2023-quantum-thr...</a></div><br/></div></div></div></div><div id="39672707" class="c"><input type="checkbox" id="c-39672707" checked=""/><div class="controls bullet"><span class="by">rihegher</span><span>|</span><a href="#39673737">prev</a><span>|</span><label class="collapse" for="c-39672707">[-]</label><label class="expand" for="c-39672707">[3 more]</label></div><br/><div class="children"><div class="content">In short all encrypted data transiting through internet will get uncrypted once quantum computing is there. As if we didn&#x27;t already had enough threats to worry about...</div><br/></div></div></div></div></div></div></div></body></html>