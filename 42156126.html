<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1731834066719" as="style"/><link rel="stylesheet" href="styles.css?v=1731834066719"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/pyro-ppl/numpyro">Numpyro: Probabilistic programming with NumPy powered by Jax</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>lnyan</span> | <span>22 comments</span></div><br/><div><div id="42157303" class="c"><input type="checkbox" id="c-42157303" checked=""/><div class="controls bullet"><span class="by">ghgr</span><span>|</span><a href="#42162285">next</a><span>|</span><label class="collapse" for="c-42157303">[-]</label><label class="expand" for="c-42157303">[4 more]</label></div><br/><div class="children"><div class="content">If you are struggling to understand the README, I highly recommend the book <i>Statistical Rethinking: A Bayesian Course with Examples in R and Stan</i> by Richard McElreath. Although the examples are in R, the same concepts apply to Pyro (and NumPyro)<p>[1] <a href="https:&#x2F;&#x2F;www.goodreads.com&#x2F;book&#x2F;show&#x2F;26619686-statistical-rethinking" rel="nofollow">https:&#x2F;&#x2F;www.goodreads.com&#x2F;book&#x2F;show&#x2F;26619686-statistical-ret...</a></div><br/><div id="42157459" class="c"><input type="checkbox" id="c-42157459" checked=""/><div class="controls bullet"><span class="by">nsingh2</span><span>|</span><a href="#42157303">parent</a><span>|</span><a href="#42161237">next</a><span>|</span><label class="collapse" for="c-42157459">[-]</label><label class="expand" for="c-42157459">[1 more]</label></div><br/><div class="children"><div class="content">I read through the second edition, and would recommend as well [1] (has numpyro, pyro, pymc code). He also has a great lecture series on youtube [2]<p>[1] <a href="https:&#x2F;&#x2F;xcelab.net&#x2F;rm&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xcelab.net&#x2F;rm&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=FdnMWdICdRs&amp;list=PLDcUM9US4XdPz-KxHM4XHt7uUVGWWVSus" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=FdnMWdICdRs&amp;list=PLDcUM9US4X...</a></div><br/></div></div><div id="42161237" class="c"><input type="checkbox" id="c-42161237" checked=""/><div class="controls bullet"><span class="by">almostgotcaught</span><span>|</span><a href="#42157303">parent</a><span>|</span><a href="#42157459">prev</a><span>|</span><a href="#42160751">next</a><span>|</span><label class="collapse" for="c-42161237">[-]</label><label class="expand" for="c-42161237">[1 more]</label></div><br/><div class="children"><div class="content">it&#x27;s not that complicated that you need to read a whole book just to get a rough idea: it&#x27;s just a cutesy way to specify a &quot;plate model&quot;[1] and then run inference using that model.<p>[1]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Plate_notation" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Plate_notation</a></div><br/></div></div><div id="42160751" class="c"><input type="checkbox" id="c-42160751" checked=""/><div class="controls bullet"><span class="by">Iwan-Zotow</span><span>|</span><a href="#42157303">parent</a><span>|</span><a href="#42161237">prev</a><span>|</span><a href="#42162285">next</a><span>|</span><label class="collapse" for="c-42160751">[-]</label><label class="expand" for="c-42160751">[1 more]</label></div><br/><div class="children"><div class="content">There are examples from the book done in PyMC:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;pymc-devs&#x2F;pymc-resources&#x2F;tree&#x2F;main&#x2F;Rethinking_2">https:&#x2F;&#x2F;github.com&#x2F;pymc-devs&#x2F;pymc-resources&#x2F;tree&#x2F;main&#x2F;Rethin...</a><p>or, for first edition<p><a href="https:&#x2F;&#x2F;github.com&#x2F;pymc-devs&#x2F;pymc-resources&#x2F;tree&#x2F;main&#x2F;Rethinking">https:&#x2F;&#x2F;github.com&#x2F;pymc-devs&#x2F;pymc-resources&#x2F;tree&#x2F;main&#x2F;Rethin...</a></div><br/></div></div></div></div><div id="42162285" class="c"><input type="checkbox" id="c-42162285" checked=""/><div class="controls bullet"><span class="by">snthpy</span><span>|</span><a href="#42157303">prev</a><span>|</span><a href="#42157783">next</a><span>|</span><label class="collapse" for="c-42162285">[-]</label><label class="expand" for="c-42162285">[3 more]</label></div><br/><div class="children"><div class="content">Related question: are there there any algorithms &#x2F; optimizations for probabilistic programming in an online context?<p>What i mean is that I have a model and I&#x27;ve run my inference on my historical data. Now I have new observations streaming in and I want to update my inference in an efficient manner. Basically I&#x27;d like something like a Kalman Filter for general probabilistic models.</div><br/><div id="42162860" class="c"><input type="checkbox" id="c-42162860" checked=""/><div class="controls bullet"><span class="by">tfehring</span><span>|</span><a href="#42162285">parent</a><span>|</span><a href="#42162407">next</a><span>|</span><label class="collapse" for="c-42162860">[-]</label><label class="expand" for="c-42162860">[1 more]</label></div><br/><div class="children"><div class="content">One way I&#x27;ve seen this done in practice is to construct an offline model that produces an initial set of posterior samples, then construct a second, online model that takes posterior samples and new observations as input and constructs a new posterior. This probably wouldn&#x27;t make sense computationally in a high-frequency streaming context, but (micro)batching works fine.<p>I&#x27;ve seen lots of other approaches proposed for this over the years, here&#x27;s a recent Stan forum thread with some links: <a href="https:&#x2F;&#x2F;discourse.mc-stan.org&#x2F;t&#x2F;updating-model-based-on-new-data-via-psis&#x2F;37196" rel="nofollow">https:&#x2F;&#x2F;discourse.mc-stan.org&#x2F;t&#x2F;updating-model-based-on-new-...</a></div><br/></div></div><div id="42162407" class="c"><input type="checkbox" id="c-42162407" checked=""/><div class="controls bullet"><span class="by">Onavo</span><span>|</span><a href="#42162285">parent</a><span>|</span><a href="#42162860">prev</a><span>|</span><a href="#42157783">next</a><span>|</span><label class="collapse" for="c-42162407">[-]</label><label class="expand" for="c-42162407">[1 more]</label></div><br/><div class="children"><div class="content">Update the model with the new data and recompute it (hopefully the unchanged parts are cached). Most probabilistic programming models are not black boxes like neural nets.</div><br/></div></div></div></div><div id="42157783" class="c"><input type="checkbox" id="c-42157783" checked=""/><div class="controls bullet"><span class="by">diab0lic</span><span>|</span><a href="#42162285">prev</a><span>|</span><a href="#42161217">next</a><span>|</span><label class="collapse" for="c-42157783">[-]</label><label class="expand" for="c-42157783">[8 more]</label></div><br/><div class="children"><div class="content">For those with more experience how does (Num)Pyro compare with PyMC? I haven’t had the good fortune of working with any of these libraries since before Pyro (and presumably numpyro), and with PyMC3 back when it used Theano under the hood.<p>Are the two libraries in competition? Or complimentary? I’ve been playing with PyMC for a personal project and am curious what I might gain from investigating (Num)Pyro?</div><br/><div id="42162773" class="c"><input type="checkbox" id="c-42162773" checked=""/><div class="controls bullet"><span class="by">tfehring</span><span>|</span><a href="#42157783">parent</a><span>|</span><a href="#42160314">next</a><span>|</span><label class="collapse" for="c-42162773">[-]</label><label class="expand" for="c-42162773">[1 more]</label></div><br/><div class="children"><div class="content">PyMC can use NumPyro as a backend. PyMC&#x27;s syntax and primitives for declaring models are much nicer than (Num)Pyro&#x27;s, as is the developer experience overall. But those come at the cost of having to deal with PyTensor (a fork of a fork of Theano), which is quite bad IMO, instead of just working with Numpy or PyTorch.</div><br/></div></div><div id="42160314" class="c"><input type="checkbox" id="c-42160314" checked=""/><div class="controls bullet"><span class="by">szvsw</span><span>|</span><a href="#42157783">parent</a><span>|</span><a href="#42162773">prev</a><span>|</span><a href="#42158049">next</a><span>|</span><label class="collapse" for="c-42160314">[-]</label><label class="expand" for="c-42160314">[2 more]</label></div><br/><div class="children"><div class="content">I would say that, at least for me, PyMC’s main advantage was in DX. I just found model construction much more straightforward and better aligned with how I wanted to assemble the model.<p>This textbook&#x2F;walkthrough is great:
<a href="https:&#x2F;&#x2F;a.co&#x2F;d&#x2F;9dWXDTK" rel="nofollow">https:&#x2F;&#x2F;a.co&#x2F;d&#x2F;9dWXDTK</a></div><br/><div id="42160677" class="c"><input type="checkbox" id="c-42160677" checked=""/><div class="controls bullet"><span class="by">diab0lic</span><span>|</span><a href="#42157783">root</a><span>|</span><a href="#42160314">parent</a><span>|</span><a href="#42158049">next</a><span>|</span><label class="collapse" for="c-42160677">[-]</label><label class="expand" for="c-42160677">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the textbook link, this looks right up my alley!</div><br/></div></div></div></div><div id="42158049" class="c"><input type="checkbox" id="c-42158049" checked=""/><div class="controls bullet"><span class="by">nsingh2</span><span>|</span><a href="#42157783">parent</a><span>|</span><a href="#42160314">prev</a><span>|</span><a href="#42158146">next</a><span>|</span><label class="collapse" for="c-42158049">[-]</label><label class="expand" for="c-42158049">[1 more]</label></div><br/><div class="children"><div class="content">I tired both a while back, but nothing too big or serious. One thing that numpyro benefits from is JAX&#x27;s speed, so it might be faster for larger models. Though PyTensor, which is the backend for PyMC can apparently also generate JAX code, so the difference might not be drastic. The PyMC API also seemed to me easier to get started with for those learning Bayesian stats.<p>One thing I remember that I disliked about PyMC was the PyTensor API, it feels too much like Theano&#x2F;TensorFlow. I much prefer using JAX for writing custom models.</div><br/></div></div><div id="42158146" class="c"><input type="checkbox" id="c-42158146" checked=""/><div class="controls bullet"><span class="by">ailun</span><span>|</span><a href="#42157783">parent</a><span>|</span><a href="#42158049">prev</a><span>|</span><a href="#42158456">next</a><span>|</span><label class="collapse" for="c-42158146">[-]</label><label class="expand" for="c-42158146">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;ll lose a lot of the PyMC convenience functions with Numpyro but gain a lot of control and flexibility over your model specification. If you&#x27;re doing variational inference, Numpyro is the way to go.<p>You can use the Numpyro NUTS sampler in PyMC with pm.sample(nuts_sampler=&quot;numpyro&quot;) and it will significantly speed up sampling. It is less stable in my experience.</div><br/></div></div><div id="42158456" class="c"><input type="checkbox" id="c-42158456" checked=""/><div class="controls bullet"><span class="by">wthomp</span><span>|</span><a href="#42157783">parent</a><span>|</span><a href="#42158146">prev</a><span>|</span><a href="#42158588">next</a><span>|</span><label class="collapse" for="c-42158456">[-]</label><label class="expand" for="c-42158456">[1 more]</label></div><br/><div class="children"><div class="content">This is maybe not the place, but we did some apples to apples comparisons between PyMC, Dynesty, and the Julia Turing.jl package.<p>A little to my surprise, despite being a Julia fan, Turing really outperformed both the Python solutions.
I think JAX should be competitive in raw speed, so it might come down to the maturity of the samplers we used.</div><br/></div></div><div id="42158588" class="c"><input type="checkbox" id="c-42158588" checked=""/><div class="controls bullet"><span class="by">sampo</span><span>|</span><a href="#42157783">parent</a><span>|</span><a href="#42158456">prev</a><span>|</span><a href="#42161217">next</a><span>|</span><label class="collapse" for="c-42158588">[-]</label><label class="expand" for="c-42158588">[1 more]</label></div><br/><div class="children"><div class="content">I find the PyMC situation confusing. But PyMC should be able to use JAX in the backend: <a href="https:&#x2F;&#x2F;www.pymc.io&#x2F;projects&#x2F;examples&#x2F;en&#x2F;latest&#x2F;samplers&#x2F;fast_sampling_with_jax_and_numba.html" rel="nofollow">https:&#x2F;&#x2F;www.pymc.io&#x2F;projects&#x2F;examples&#x2F;en&#x2F;latest&#x2F;samplers&#x2F;fas...</a></div><br/></div></div></div></div><div id="42161217" class="c"><input type="checkbox" id="c-42161217" checked=""/><div class="controls bullet"><span class="by">whimsicalism</span><span>|</span><a href="#42157783">prev</a><span>|</span><a href="#42160367">next</a><span>|</span><label class="collapse" for="c-42161217">[-]</label><label class="expand" for="c-42161217">[2 more]</label></div><br/><div class="children"><div class="content">What is probabilistic programming actually useful for? Interpretable inference or something like that?<p>It seems like if raw prediction of a data distribution is what you are interested in, explicitly specified statistical models are probably less useful? At least if you have lots of data and can tolerate a model with lots of &#x27;variance&#x27;</div><br/><div id="42161350" class="c"><input type="checkbox" id="c-42161350" checked=""/><div class="controls bullet"><span class="by">Karrot_Kream</span><span>|</span><a href="#42161217">parent</a><span>|</span><a href="#42160367">next</a><span>|</span><label class="collapse" for="c-42161350">[-]</label><label class="expand" for="c-42161350">[1 more]</label></div><br/><div class="children"><div class="content">Yeah interpretability is the main reason that I know. If you need to make decisions based on statistics of the data, I think it&#x27;s a lot easier with explicit statistical models.</div><br/></div></div></div></div><div id="42160367" class="c"><input type="checkbox" id="c-42160367" checked=""/><div class="controls bullet"><span class="by">uptownfunk</span><span>|</span><a href="#42161217">prev</a><span>|</span><a href="#42158089">next</a><span>|</span><label class="collapse" for="c-42160367">[-]</label><label class="expand" for="c-42160367">[3 more]</label></div><br/><div class="children"><div class="content">What is this used for?</div><br/><div id="42160872" class="c"><input type="checkbox" id="c-42160872" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#42160367">parent</a><span>|</span><a href="#42160541">next</a><span>|</span><label class="collapse" for="c-42160872">[-]</label><label class="expand" for="c-42160872">[1 more]</label></div><br/><div class="children"><div class="content">MCMC and Bayesian models.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Probabilistic_programming" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Probabilistic_programming</a></div><br/></div></div><div id="42160541" class="c"><input type="checkbox" id="c-42160541" checked=""/><div class="controls bullet"><span class="by">downrightmike</span><span>|</span><a href="#42160367">parent</a><span>|</span><a href="#42160872">prev</a><span>|</span><a href="#42158089">next</a><span>|</span><label class="collapse" for="c-42160541">[-]</label><label class="expand" for="c-42160541">[1 more]</label></div><br/><div class="children"><div class="content">They&#x27;re trying to drum up interest in Jax. They do this time to time, but yeah, good for them doing what they like.</div><br/></div></div></div></div><div id="42158089" class="c"><input type="checkbox" id="c-42158089" checked=""/><div class="controls bullet"><span class="by">svilen_dobrev</span><span>|</span><a href="#42160367">prev</a><span>|</span><label class="collapse" for="c-42158089">[-]</label><label class="expand" for="c-42158089">[1 more]</label></div><br/><div class="children"><div class="content">side note: the Pyro used here - or actually pyro-ppl - is not to be confused with Pyro as of python-remote-objects..</div><br/></div></div></div></div></div></div></div></body></html>