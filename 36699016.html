<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1689238853539" as="style"/><link rel="stylesheet" href="styles.css?v=1689238853539"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://xata.io/blog/postgres-full-text-search-engine">Creating a search engine with PostgreSQL</a> <span class="domain">(<a href="https://xata.io">xata.io</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>149 comments</span></div><br/><div><div id="36702433" class="c"><input type="checkbox" id="c-36702433" checked=""/><div class="controls bullet"><span class="by">jsdwarf</span><span>|</span><a href="#36699521">next</a><span>|</span><label class="collapse" for="c-36702433">[-]</label><label class="expand" for="c-36702433">[35 more]</label></div><br/><div class="children"><div class="content">Looking forward for part 2 &#x2F; postgres vs elasticsearch. One application at my company uses PG for CRUD on objects and elastic for searching them. We completely underestimated the effort of keeping the two datastores in sync and are actually contemplating to get rid of elasticsearch.</div><br/><div id="36703961" class="c"><input type="checkbox" id="c-36703961" checked=""/><div class="controls bullet"><span class="by">plasma</span><span>|</span><a href="#36702433">parent</a><span>|</span><a href="#36704994">next</a><span>|</span><label class="collapse" for="c-36703961">[-]</label><label class="expand" for="c-36703961">[4 more]</label></div><br/><div class="children"><div class="content">A technique I&#x27;ve used before is to treat Elasticsearch as rebuildable at any time, consider this approach:<p>A cron runs every 5 minutes that looks at your database for any objects you&#x27;re indexing where last_modified_at timestamp &gt; last_indexing_started_timestamp.<p>Index the objects into Elasticsearch, then update the last_indexing_started_timestamp value to be when you started the original sync process, so we catch any modified objects between the start&#x2F;end of the update run, next run.<p>Then if Elasticsearch needs rebuilding you can just clear out the last indexing timestamp and resync from the start of time, and its self-recovering &#x2F; won&#x27;t get out of sync.</div><br/><div id="36706481" class="c"><input type="checkbox" id="c-36706481" checked=""/><div class="controls bullet"><span class="by">xps</span><span>|</span><a href="#36702433">root</a><span>|</span><a href="#36703961">parent</a><span>|</span><a href="#36705620">next</a><span>|</span><label class="collapse" for="c-36706481">[-]</label><label class="expand" for="c-36706481">[2 more]</label></div><br/><div class="children"><div class="content">Tried this as well but the difficulty is that Postgres is a relational database whereas ElasticSearch stores schema-less documents.<p>Your record in ES might include data from many different tables, and figuring out what to (efficiently) update when there is a change in Postgres is not a simple task.</div><br/><div id="36706553" class="c"><input type="checkbox" id="c-36706553" checked=""/><div class="controls bullet"><span class="by">dgb23</span><span>|</span><a href="#36702433">root</a><span>|</span><a href="#36706481">parent</a><span>|</span><a href="#36705620">next</a><span>|</span><label class="collapse" for="c-36706553">[-]</label><label class="expand" for="c-36706553">[1 more]</label></div><br/><div class="children"><div class="content">This issue comes up in several domains and tech layers (back to front, bottom up etc.)<p>Are there any generic, algorithmic or even just heuristics that help with this?<p>It’s something I‘ve been thinking about over some time now. Any pointers, strategies and tips are appreciated.</div><br/></div></div></div></div><div id="36705620" class="c"><input type="checkbox" id="c-36705620" checked=""/><div class="controls bullet"><span class="by">mesarvagya</span><span>|</span><a href="#36702433">root</a><span>|</span><a href="#36703961">parent</a><span>|</span><a href="#36706481">prev</a><span>|</span><a href="#36704994">next</a><span>|</span><label class="collapse" for="c-36705620">[-]</label><label class="expand" for="c-36705620">[1 more]</label></div><br/><div class="children"><div class="content">Or we can also use Logstash</div><br/></div></div></div></div><div id="36704994" class="c"><input type="checkbox" id="c-36704994" checked=""/><div class="controls bullet"><span class="by">drewpc</span><span>|</span><a href="#36702433">parent</a><span>|</span><a href="#36703961">prev</a><span>|</span><a href="#36705785">next</a><span>|</span><label class="collapse" for="c-36704994">[-]</label><label class="expand" for="c-36704994">[1 more]</label></div><br/><div class="children"><div class="content">I went a similar route (Postgres for CRUD and Elastic for searching) and also underestimated the effort of keeping the two datastore in sync as well as underestimated the effort in maintaining a reliable Elastic cluster with limited manpower&#x2F;experience.  After moving to Postgres full text search with indexes and query boosting, I accomplished everything I needed inside Postgres with update triggers and search queries that were incredibly performant.</div><br/></div></div><div id="36705785" class="c"><input type="checkbox" id="c-36705785" checked=""/><div class="controls bullet"><span class="by">baur</span><span>|</span><a href="#36702433">parent</a><span>|</span><a href="#36704994">prev</a><span>|</span><a href="#36704180">next</a><span>|</span><label class="collapse" for="c-36705785">[-]</label><label class="expand" for="c-36705785">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m wondering if CrateDB [<a href="https:&#x2F;&#x2F;github.com&#x2F;crate&#x2F;crate">https:&#x2F;&#x2F;github.com&#x2F;crate&#x2F;crate</a>] could fit your use case without keeping 2 places to store and sync data.<p>It&#x27;s a relational SQL database which aims for compatibility with PostgreSQL. Internally it uses Lucene as a storage and such can offer fulltext functionality which is exposed via MATCH.</div><br/><div id="36706384" class="c"><input type="checkbox" id="c-36706384" checked=""/><div class="controls bullet"><span class="by">worldsayshi</span><span>|</span><a href="#36702433">root</a><span>|</span><a href="#36705785">parent</a><span>|</span><a href="#36704180">next</a><span>|</span><label class="collapse" for="c-36706384">[-]</label><label class="expand" for="c-36706384">[1 more]</label></div><br/><div class="children"><div class="content">CrateDB is very promising. It&#x27;s not acid though.<p>Another potential of to use zombodb (haven&#x27;t tried it myself).</div><br/></div></div></div></div><div id="36704180" class="c"><input type="checkbox" id="c-36704180" checked=""/><div class="controls bullet"><span class="by">danielheath</span><span>|</span><a href="#36702433">parent</a><span>|</span><a href="#36705785">prev</a><span>|</span><a href="#36702868">next</a><span>|</span><label class="collapse" for="c-36704180">[-]</label><label class="expand" for="c-36704180">[1 more]</label></div><br/><div class="children"><div class="content">I have done this. It was a challenging task, even with significant experience, and some results aren’t as good (most are as good, very few are better).<p>Overall it was a success - our ops work is very much reduced, enough so to have easily paid for the engineering time invested. Not to be undertaken lightly though.<p>Depending on your needs, you may be better served by materialised views, normal views, or triggers. The builtin text search may not suit your use cases; it’s not necessarily hard to come up with alternative schemes.</div><br/></div></div><div id="36702868" class="c"><input type="checkbox" id="c-36702868" checked=""/><div class="controls bullet"><span class="by">jarym</span><span>|</span><a href="#36702433">parent</a><span>|</span><a href="#36704180">prev</a><span>|</span><a href="#36702610">next</a><span>|</span><label class="collapse" for="c-36702868">[-]</label><label class="expand" for="c-36702868">[3 more]</label></div><br/><div class="children"><div class="content">Curious, did you try zombodb? [<a href="https:&#x2F;&#x2F;www.zombodb.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.zombodb.com&#x2F;</a>]</div><br/><div id="36705630" class="c"><input type="checkbox" id="c-36705630" checked=""/><div class="controls bullet"><span class="by">worthless-trash</span><span>|</span><a href="#36702433">root</a><span>|</span><a href="#36702868">parent</a><span>|</span><a href="#36702610">next</a><span>|</span><label class="collapse" for="c-36705630">[-]</label><label class="expand" for="c-36705630">[2 more]</label></div><br/><div class="children"><div class="content">For a moment I thought it was from zombo.com</div><br/><div id="36706315" class="c"><input type="checkbox" id="c-36706315" checked=""/><div class="controls bullet"><span class="by">mekoka</span><span>|</span><a href="#36702433">root</a><span>|</span><a href="#36705630">parent</a><span>|</span><a href="#36702610">next</a><span>|</span><label class="collapse" for="c-36706315">[-]</label><label class="expand" for="c-36706315">[1 more]</label></div><br/><div class="children"><div class="content">The site was updated just to replace flash and add TLS. Amazing!</div><br/></div></div></div></div></div></div><div id="36702610" class="c"><input type="checkbox" id="c-36702610" checked=""/><div class="controls bullet"><span class="by">valzam</span><span>|</span><a href="#36702433">parent</a><span>|</span><a href="#36702868">prev</a><span>|</span><a href="#36702569">next</a><span>|</span><label class="collapse" for="c-36702610">[-]</label><label class="expand" for="c-36702610">[9 more]</label></div><br/><div class="children"><div class="content">I had a similar setup at a previous gig and didn&#x27;t find it particularly challenging. Whenever an update happens to an entity in PG we send a message to async replicate that entity in ES (via ID lookup in PG). As always you need good monitoring and retries for async computation but ES is quite stable and fast so we rarely had any issues.<p>Now, we had pretty lax consistency requirements, as long as the &quot;latest state&quot; of PG ended up in ES within a reasonable timeframe everything was fine so maybe your requirements are different.</div><br/><div id="36702948" class="c"><input type="checkbox" id="c-36702948" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#36702433">root</a><span>|</span><a href="#36702610">parent</a><span>|</span><a href="#36702569">next</a><span>|</span><label class="collapse" for="c-36702948">[-]</label><label class="expand" for="c-36702948">[8 more]</label></div><br/><div class="children"><div class="content">Yeah, I think more folks should learn about postgres LISTEN and NOTIFY functionality, <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;sql-notify.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;sql-notify.html</a>, it&#x27;s great for stuff like this, and there are now various client libraries like pg-listen in NPM that make this really easy to use.<p>This is especially useful if you have lots of different teams&#x2F;code paths that may update your DB - just set up a trigger that causes a NOTIFY message to get sent, then have a client responsible for reading for PG and populating ES. Alternatively, if you can accept a bit more latency, just have a trigger that sets a &quot;needsESIndexing&quot; dirty column somewhere and have a polling process that picks rows WHERE needsESIndexing = TRUE and just updates this to FALSE when the indexing is complete.</div><br/><div id="36703321" class="c"><input type="checkbox" id="c-36703321" checked=""/><div class="controls bullet"><span class="by">macNchz</span><span>|</span><a href="#36702433">root</a><span>|</span><a href="#36702948">parent</a><span>|</span><a href="#36703279">next</a><span>|</span><label class="collapse" for="c-36703321">[-]</label><label class="expand" for="c-36703321">[3 more]</label></div><br/><div class="children"><div class="content">It has been several years since I worked on a system that implemented listen&#x2F;notify, but I recall there was a significant caveat that if the listener was unavailable at the exact moment the NOTIFY executes, the message would be lost.<p>That’s a significant risk for things that need to be in sync between two systems, so we stuck with listen&#x2F;notify for info-level ops things and used polling&#x2F;queue systems that offered better guarantees for more important tasks. Don’t want to be in a position where   a quiet hiccup with a deploy or something results in fun bugs like 0.5% of rows being silently out of sync between ES and Postgres.</div><br/><div id="36703355" class="c"><input type="checkbox" id="c-36703355" checked=""/><div class="controls bullet"><span class="by">xupybd</span><span>|</span><a href="#36702433">root</a><span>|</span><a href="#36703321">parent</a><span>|</span><a href="#36703279">next</a><span>|</span><label class="collapse" for="c-36703355">[-]</label><label class="expand" for="c-36703355">[2 more]</label></div><br/><div class="children"><div class="content">You could put a Nats JetStream connection in line and you&#x27;d have a good buffer to catch the notifications. Not fool proof but then you&#x27;d need some kind of batch process that looks for any outstanding changes and syncs them.<p>We do something like this with our systems. External events get written to the event bus but all operations are idempotent on the event bus. So at night we send another round of the days events to clean up any inconsistencies.</div><br/><div id="36703509" class="c"><input type="checkbox" id="c-36703509" checked=""/><div class="controls bullet"><span class="by">stoniejohnson</span><span>|</span><a href="#36702433">root</a><span>|</span><a href="#36703355">parent</a><span>|</span><a href="#36703279">next</a><span>|</span><label class="collapse" for="c-36703509">[-]</label><label class="expand" for="c-36703509">[1 more]</label></div><br/><div class="children"><div class="content">Making jobs idempotent forces good design imo.</div><br/></div></div></div></div></div></div><div id="36703279" class="c"><input type="checkbox" id="c-36703279" checked=""/><div class="controls bullet"><span class="by">valzam</span><span>|</span><a href="#36702433">root</a><span>|</span><a href="#36702948">parent</a><span>|</span><a href="#36703321">prev</a><span>|</span><a href="#36702569">next</a><span>|</span><label class="collapse" for="c-36703279">[-]</label><label class="expand" for="c-36703279">[4 more]</label></div><br/><div class="children"><div class="content">Or a bit more &#x27;web scale&#x27;s use wal_insert and the outbox pattern to transactionally replicate events to a messaging system (Kafka etc).</div><br/><div id="36704402" class="c"><input type="checkbox" id="c-36704402" checked=""/><div class="controls bullet"><span class="by">lyu07282</span><span>|</span><a href="#36702433">root</a><span>|</span><a href="#36703279">parent</a><span>|</span><a href="#36702569">next</a><span>|</span><label class="collapse" for="c-36704402">[-]</label><label class="expand" for="c-36704402">[3 more]</label></div><br/><div class="children"><div class="content">you can also just use a CDC to import from Postgres into Kafka using Debezium and then on the other end Kafka Connect to write into Elasticsearch, no need to write any code at all with this setup ymmv ofc</div><br/><div id="36704630" class="c"><input type="checkbox" id="c-36704630" checked=""/><div class="controls bullet"><span class="by">paulryanrogers</span><span>|</span><a href="#36702433">root</a><span>|</span><a href="#36704402">parent</a><span>|</span><a href="#36702569">next</a><span>|</span><label class="collapse" for="c-36704630">[-]</label><label class="expand" for="c-36704630">[2 more]</label></div><br/><div class="children"><div class="content">Sounds like a lot of moving parts though, unless the team is already familiar with maintaining all those parts</div><br/><div id="36704775" class="c"><input type="checkbox" id="c-36704775" checked=""/><div class="controls bullet"><span class="by">lyu07282</span><span>|</span><a href="#36702433">root</a><span>|</span><a href="#36704630">parent</a><span>|</span><a href="#36702569">next</a><span>|</span><label class="collapse" for="c-36704775">[-]</label><label class="expand" for="c-36704775">[1 more]</label></div><br/><div class="children"><div class="content">if you already use Kafka anyway its a valid solution, I wouldn&#x27;t introduce Kafka for this obviously. Also Kafka Connect and Debezium are mature well maintained open source projects in case that wasn&#x27;t clear enough.<p><a href="https:&#x2F;&#x2F;debezium.io&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;debezium.io&#x2F;</a><p><a href="https:&#x2F;&#x2F;docs.confluent.io&#x2F;platform&#x2F;current&#x2F;connect&#x2F;index.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.confluent.io&#x2F;platform&#x2F;current&#x2F;connect&#x2F;index.htm...</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36702569" class="c"><input type="checkbox" id="c-36702569" checked=""/><div class="controls bullet"><span class="by">dqv</span><span>|</span><a href="#36702433">parent</a><span>|</span><a href="#36702610">prev</a><span>|</span><a href="#36705567">next</a><span>|</span><label class="collapse" for="c-36702569">[-]</label><label class="expand" for="c-36702569">[1 more]</label></div><br/><div class="children"><div class="content">&gt;We completely underestimated the effort of keeping the two datastores in sync and are actually contemplating to get rid of elasticsearch.<p>Can you expand on this? Is it that it&#x27;s tedious to write code that updates both? I&#x27;ve been meaning to play around with meilisearch and was trying to think about the synchronization issue.</div><br/></div></div><div id="36705567" class="c"><input type="checkbox" id="c-36705567" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#36702433">parent</a><span>|</span><a href="#36702569">prev</a><span>|</span><a href="#36703118">next</a><span>|</span><label class="collapse" for="c-36705567">[-]</label><label class="expand" for="c-36705567">[1 more]</label></div><br/><div class="children"><div class="content">I want a public standard for a WAL format that disparate databases can share to stay in sync.</div><br/></div></div><div id="36703118" class="c"><input type="checkbox" id="c-36703118" checked=""/><div class="controls bullet"><span class="by">devoutsalsa</span><span>|</span><a href="#36702433">parent</a><span>|</span><a href="#36705567">prev</a><span>|</span><a href="#36703040">next</a><span>|</span><label class="collapse" for="c-36703118">[-]</label><label class="expand" for="c-36703118">[2 more]</label></div><br/><div class="children"><div class="content">The easiest log retention setup I&#x27;ve ever used was just a server w&#x2F; logs dumped into a text file searched by zgrep.  I&#x27;m not it&#x27;s not ideal for all use cases, but I miss the simplicity it.</div><br/><div id="36703166" class="c"><input type="checkbox" id="c-36703166" checked=""/><div class="controls bullet"><span class="by">chrismarlow9</span><span>|</span><a href="#36702433">root</a><span>|</span><a href="#36703118">parent</a><span>|</span><a href="#36703040">next</a><span>|</span><label class="collapse" for="c-36703166">[-]</label><label class="expand" for="c-36703166">[1 more]</label></div><br/><div class="children"><div class="content">This can be done and centralized with rsyslog and it&#x27;s magical. And yes it can scale.</div><br/></div></div></div></div><div id="36703040" class="c"><input type="checkbox" id="c-36703040" checked=""/><div class="controls bullet"><span class="by">softwaredoug</span><span>|</span><a href="#36702433">parent</a><span>|</span><a href="#36703118">prev</a><span>|</span><a href="#36703960">next</a><span>|</span><label class="collapse" for="c-36703040">[-]</label><label class="expand" for="c-36703040">[2 more]</label></div><br/><div class="children"><div class="content">You might trade for a different problem, which is that search could end up being a very different query load on the Postgres cluster compared to existing queries. That might make it hard to scale it out for both use cases.</div><br/><div id="36703342" class="c"><input type="checkbox" id="c-36703342" checked=""/><div class="controls bullet"><span class="by">selcuka</span><span>|</span><a href="#36702433">root</a><span>|</span><a href="#36703040">parent</a><span>|</span><a href="#36703960">next</a><span>|</span><label class="collapse" for="c-36703342">[-]</label><label class="expand" for="c-36703342">[1 more]</label></div><br/><div class="children"><div class="content">You can always have a separate, streaming replica [1] used for full text searches.<p>[1] <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;warm-standby.html#STREAMING-REPLICATION" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;warm-standby.html#ST...</a></div><br/></div></div></div></div><div id="36703960" class="c"><input type="checkbox" id="c-36703960" checked=""/><div class="controls bullet"><span class="by">riverdroid</span><span>|</span><a href="#36702433">parent</a><span>|</span><a href="#36703040">prev</a><span>|</span><a href="#36702557">next</a><span>|</span><label class="collapse" for="c-36703960">[-]</label><label class="expand" for="c-36703960">[1 more]</label></div><br/><div class="children"><div class="content">I was researching this recently and came across this article: <a href="https:&#x2F;&#x2F;pganalyze.com&#x2F;blog&#x2F;gin-index" rel="nofollow noreferrer">https:&#x2F;&#x2F;pganalyze.com&#x2F;blog&#x2F;gin-index</a><p>The GIN index has some similarities to Elasticsearch&#x27;s inverted indices (last I knew anyway), which also can be quite expensive to write to. If you&#x27;re doing heavy writes, something to test and consider carefully.<p>TLDR; writes get a lot more expensive with GIN indices.</div><br/></div></div><div id="36702557" class="c"><input type="checkbox" id="c-36702557" checked=""/><div class="controls bullet"><span class="by">cameronpm</span><span>|</span><a href="#36702433">parent</a><span>|</span><a href="#36703960">prev</a><span>|</span><a href="#36704170">next</a><span>|</span><label class="collapse" for="c-36702557">[-]</label><label class="expand" for="c-36702557">[3 more]</label></div><br/><div class="children"><div class="content">Normally best practice is to return primary keys in ES and then do a lookup query in the db. Did you attempt this?</div><br/><div id="36703786" class="c"><input type="checkbox" id="c-36703786" checked=""/><div class="controls bullet"><span class="by">rajamaka</span><span>|</span><a href="#36702433">root</a><span>|</span><a href="#36702557">parent</a><span>|</span><a href="#36704170">next</a><span>|</span><label class="collapse" for="c-36703786">[-]</label><label class="expand" for="c-36703786">[2 more]</label></div><br/><div class="children"><div class="content">Got any links or documentation about this method by any chance? Not sure if you are talking about querying or syncing data here.</div><br/><div id="36704476" class="c"><input type="checkbox" id="c-36704476" checked=""/><div class="controls bullet"><span class="by">lyu07282</span><span>|</span><a href="#36702433">root</a><span>|</span><a href="#36703786">parent</a><span>|</span><a href="#36704170">next</a><span>|</span><label class="collapse" for="c-36704476">[-]</label><label class="expand" for="c-36704476">[1 more]</label></div><br/><div class="children"><div class="content">I think what they just mean is that you only have all your searchable fields indexed in ES and then, when you do a search query, the only thing ES returns is PKs which you then do a second roundtrip to the database (or cache) with to get all the actual records from. Which means you don&#x27;t have to worry too much about all the record information being in sync perfectly.</div><br/></div></div></div></div></div></div><div id="36704170" class="c"><input type="checkbox" id="c-36704170" checked=""/><div class="controls bullet"><span class="by">jdpedrie</span><span>|</span><a href="#36702433">parent</a><span>|</span><a href="#36702557">prev</a><span>|</span><a href="#36703594">next</a><span>|</span><label class="collapse" for="c-36704170">[-]</label><label class="expand" for="c-36704170">[2 more]</label></div><br/><div class="children"><div class="content">Check out debezium.</div><br/><div id="36706403" class="c"><input type="checkbox" id="c-36706403" checked=""/><div class="controls bullet"><span class="by">worldsayshi</span><span>|</span><a href="#36702433">root</a><span>|</span><a href="#36704170">parent</a><span>|</span><a href="#36703594">next</a><span>|</span><label class="collapse" for="c-36706403">[-]</label><label class="expand" for="c-36706403">[1 more]</label></div><br/><div class="children"><div class="content">Has anyone tried it on a large and frequently updated database?</div><br/></div></div></div></div><div id="36703594" class="c"><input type="checkbox" id="c-36703594" checked=""/><div class="controls bullet"><span class="by">throwaway2990</span><span>|</span><a href="#36702433">parent</a><span>|</span><a href="#36704170">prev</a><span>|</span><a href="#36703461">next</a><span>|</span><label class="collapse" for="c-36703594">[-]</label><label class="expand" for="c-36703594">[1 more]</label></div><br/><div class="children"><div class="content">We did that at my previous job. Because we had a really good idea of what was searched and used we indexed everything really well. We only had around ~ 6b records but it turned out to be faster to search than ES. And we didn’t have nodes turning bad every other month.</div><br/></div></div><div id="36703461" class="c"><input type="checkbox" id="c-36703461" checked=""/><div class="controls bullet"><span class="by">pmarreck</span><span>|</span><a href="#36702433">parent</a><span>|</span><a href="#36703594">prev</a><span>|</span><a href="#36699521">next</a><span>|</span><label class="collapse" for="c-36703461">[-]</label><label class="expand" for="c-36703461">[1 more]</label></div><br/><div class="children"><div class="content">This is exactly why I (as a solo developer at the time) just used Postgres&#x27; built-in fulltext search when that was a requirement. Worked out great, although the &quot;simple&quot; interface to it was a bit too simple and I ended up having to build up a DSL to translate searches into the more complex interface to the fulltext index.<p>And any modifications to any field that was indexed, or having to update how things were indexed, was a chore thanks to referential integrity enforcement at the DB level: I had to remove and afterwards reapply things like foreign key constraints, triggers, stored procs, etc.... for both the &quot;up&quot; AND the &quot;down&quot;! Fortunately, since Postgres lets you make schema changes in a transaction, there usually wasn&#x27;t anything to worry about integrity-wise.</div><br/></div></div></div></div><div id="36699521" class="c"><input type="checkbox" id="c-36699521" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#36702433">prev</a><span>|</span><a href="#36700935">next</a><span>|</span><label class="collapse" for="c-36699521">[-]</label><label class="expand" for="c-36699521">[36 more]</label></div><br/><div class="children"><div class="content">p50&#x2F;p99 retrieval times at realistic loads or it didn&#x27;t happen. A search engine that returns results in, say, a minute is not &quot;advanced&quot;. Of course a relational database like Postgres can do it on paper.</div><br/><div id="36699962" class="c"><input type="checkbox" id="c-36699962" checked=""/><div class="controls bullet"><span class="by">tudorg</span><span>|</span><a href="#36699521">parent</a><span>|</span><a href="#36699897">next</a><span>|</span><label class="collapse" for="c-36699962">[-]</label><label class="expand" for="c-36699962">[10 more]</label></div><br/><div class="children"><div class="content">(disclaimer: author of the post)<p>I plan a follow up to compare it with Elasticsearch, however, I don&#x27;t think I&#x27;m going to attempt benchmarking, because whatever realistic scenario I come up with, it will not necessarily be relevant to your use case.<p>I mostly agree with you and I probably wouldn&#x27;t use this at large scale (say, more than a few million records). I was primarily interested how much of the functionality I can replicate. Because for small search use cases this has some clear advantages: less infra to maintain, strong consistency, joins, etc.<p>Also, at Xata we&#x27;re thinking about having a smooth transition between using Postgres at small scale, then migrating to use Elasticsearch with minimal breaking changes.</div><br/><div id="36700159" class="c"><input type="checkbox" id="c-36700159" checked=""/><div class="controls bullet"><span class="by">bshipp</span><span>|</span><a href="#36699521">root</a><span>|</span><a href="#36699962">parent</a><span>|</span><a href="#36701458">next</a><span>|</span><label class="collapse" for="c-36700159">[-]</label><label class="expand" for="c-36700159">[7 more]</label></div><br/><div class="children"><div class="content">Using measured comparisons and making informed choices is certainly the best way.<p>If you can start with Postgres to have a relational database with the benefit of Full Text Search (i.e. avoid Elastisearch) as well as JSON fields (i.e. avoid MongoDB) then you end up simplifying initial hardware&#x2F;software requirements while retaining the ability to migrate to those solutions when user demand requires it.<p>So many developers seem to build with the idea that they&#x27;ll become the next FAANG when actual (or reasonably forecasted) user load doesn&#x27;t remotely require such a complex software stack.</div><br/><div id="36703491" class="c"><input type="checkbox" id="c-36703491" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#36699521">root</a><span>|</span><a href="#36700159">parent</a><span>|</span><a href="#36701458">next</a><span>|</span><label class="collapse" for="c-36703491">[-]</label><label class="expand" for="c-36703491">[6 more]</label></div><br/><div class="children"><div class="content">I think you’re being ungenerous in the reasoning. The initial setup to get something running is similar while a specific technology may scale better. From that perspective, you may be better off picking ES to avoid paying back technical debt if you do need to grow. Early strategic investments help - sure, you won’t get everything right, but getting enough things right can be the difference between the sales channel being bottlenecks on deal flow vs on engineering. The former can be a lot faster to resolve than the latter.</div><br/><div id="36703953" class="c"><input type="checkbox" id="c-36703953" checked=""/><div class="controls bullet"><span class="by">sebmellen</span><span>|</span><a href="#36699521">root</a><span>|</span><a href="#36703491">parent</a><span>|</span><a href="#36704681">next</a><span>|</span><label class="collapse" for="c-36703953">[-]</label><label class="expand" for="c-36703953">[4 more]</label></div><br/><div class="children"><div class="content">No failed company ever failed because of a lack of technical complexity, nor have successful companies been held back by not adopting complex architectures early.<p>&gt; <i>&quot;It is hard for less experienced developers to appreciate how rarely architecting for future requirements &#x2F; applications turns out net-positive.&quot;</i><p>— John Carmack<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;You_aren%27t_gonna_need_it" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;You_aren%27t_gonna_need_it</a></div><br/><div id="36704537" class="c"><input type="checkbox" id="c-36704537" checked=""/><div class="controls bullet"><span class="by">lyu07282</span><span>|</span><a href="#36699521">root</a><span>|</span><a href="#36703953">parent</a><span>|</span><a href="#36704681">next</a><span>|</span><label class="collapse" for="c-36704537">[-]</label><label class="expand" for="c-36704537">[3 more]</label></div><br/><div class="children"><div class="content">I think picking lucene&#x2F;es for search is hardly &quot;architecting for future requirements&quot; if your task is to build search functionality. Using Postgres FTS for search feels much more like cutting corners for me and an under-appreciation of the complexity inherent in full-text search, a complexity that ES solves competently and Postgres barely even addresses.</div><br/><div id="36704583" class="c"><input type="checkbox" id="c-36704583" checked=""/><div class="controls bullet"><span class="by">sebmellen</span><span>|</span><a href="#36699521">root</a><span>|</span><a href="#36704537">parent</a><span>|</span><a href="#36704847">next</a><span>|</span><label class="collapse" for="c-36704583">[-]</label><label class="expand" for="c-36704583">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not against picking the right tool for the job.<p>My only point is that making an architecture decision because it will <i>immediately reduce complexity</i> is much more sensible than basing your choice on potential future needs.<p>Evaluating needs from a &quot;complexity reduction&quot; standpoint is safe and will net returns. Evaluating needs from a &quot;potential risks&quot; standpoint is a lot harder, and easy to do wrong; the true risk is <i>not growing at all</i>, so the heuristic for any new project should be to do the simplest possible thing that solves the problem and starts the scaling process (i.e. whatever produces a saleable product).<p>The other benefit to starting with uncomplicated architecture is that you leave yourself with more scaling vectors, so once you deeply understand the problem(s) you actually need to solve, you can pick the right tool.<p>For us, Postgres FTS covered 95% of our use-cases. If we had started by just using ElasticSearch, we would have had a lot <i>more</i> complexity to maintain, <i>and</i> we would never have discovered our current (surprisingly elegant) architecture.</div><br/></div></div><div id="36704847" class="c"><input type="checkbox" id="c-36704847" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#36699521">root</a><span>|</span><a href="#36704537">parent</a><span>|</span><a href="#36704583">prev</a><span>|</span><a href="#36704681">next</a><span>|</span><label class="collapse" for="c-36704847">[-]</label><label class="expand" for="c-36704847">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re talking about application complexity when the parent is talking about operational complexity. The difference between some app servers talking to a Postgres instance with a replica and that plus an ES cluster is jump. If you&#x27;re paying for something managed then it probably doesn&#x27;t matter much to you. In my experience it&#x27;s actually quite rare that teams working on a product where search is a feature and not the product itself ever graduate from what Postgres offers so I tend to push back on ES when it isn&#x27;t free.</div><br/></div></div></div></div></div></div><div id="36704681" class="c"><input type="checkbox" id="c-36704681" checked=""/><div class="controls bullet"><span class="by">paulryanrogers</span><span>|</span><a href="#36699521">root</a><span>|</span><a href="#36703491">parent</a><span>|</span><a href="#36703953">prev</a><span>|</span><a href="#36701458">next</a><span>|</span><label class="collapse" for="c-36704681">[-]</label><label class="expand" for="c-36704681">[1 more]</label></div><br/><div class="children"><div class="content">You may be able to hedge your bets by separating the Postures search DB from the OLTP. Perhaps it could use FDW or similar to make them appear the same from the app layer.<p>Then if FTS won&#x27;t scale to unpredictable future needs it should be easier to rip out and replace with ES or anything else. And one doesn&#x27;t have to pay that cost if&#x2F;until it&#x27;s certainly a requirement.</div><br/></div></div></div></div></div></div><div id="36701458" class="c"><input type="checkbox" id="c-36701458" checked=""/><div class="controls bullet"><span class="by">bagels</span><span>|</span><a href="#36699521">root</a><span>|</span><a href="#36699962">parent</a><span>|</span><a href="#36700159">prev</a><span>|</span><a href="#36700182">next</a><span>|</span><label class="collapse" for="c-36701458">[-]</label><label class="expand" for="c-36701458">[1 more]</label></div><br/><div class="children"><div class="content">Sure, benchmarks won&#x27;t prove that it works in ALL cases, but it can at least prove it works in SOME cases?</div><br/></div></div><div id="36700182" class="c"><input type="checkbox" id="c-36700182" checked=""/><div class="controls bullet"><span class="by">TX81Z</span><span>|</span><a href="#36699521">root</a><span>|</span><a href="#36699962">parent</a><span>|</span><a href="#36701458">prev</a><span>|</span><a href="#36699897">next</a><span>|</span><label class="collapse" for="c-36700182">[-]</label><label class="expand" for="c-36700182">[1 more]</label></div><br/><div class="children"><div class="content">I had done something similar recently.  Goal was to take a huge Postgres database and make it searchable and usable.<p>It ended up that doing a offline batch job to boil down the much bigger dataset into a single pre-optimized table was the best approach for us. Once optimized and tsvectored it was fairly performant and not a huge gain with Elastic. Still keeping the elastic code around “in case”, but yeah, Postgres search can be “good enough” when you aren’t serving a ton of clients.</div><br/></div></div></div></div><div id="36699897" class="c"><input type="checkbox" id="c-36699897" checked=""/><div class="controls bullet"><span class="by">nanidin</span><span>|</span><a href="#36699521">parent</a><span>|</span><a href="#36699962">prev</a><span>|</span><a href="#36701221">next</a><span>|</span><label class="collapse" for="c-36699897">[-]</label><label class="expand" for="c-36699897">[16 more]</label></div><br/><div class="children"><div class="content">I interviewed somewhere with an ex-Googler who revealed they cache all of the search results for terms they have seen before, then when they update the index they also update the cached results. From that perspective, fast search results aren&#x27;t actually that exciting since you can constantly run a background task to update the cached results and just serve those as the requests come in. This caching and response time seem orthogonal to the speed of the actual act of calculating search results.</div><br/><div id="36703462" class="c"><input type="checkbox" id="c-36703462" checked=""/><div class="controls bullet"><span class="by">nosefrog</span><span>|</span><a href="#36699521">root</a><span>|</span><a href="#36699897">parent</a><span>|</span><a href="#36700212">next</a><span>|</span><label class="collapse" for="c-36703462">[-]</label><label class="expand" for="c-36703462">[1 more]</label></div><br/><div class="children"><div class="content">I work on Google Search infrastructure. Of course, caching is important, but a large percentage of queries don&#x27;t hit the cache. The backend that serves results that aren&#x27;t cached has very strict latency bounds.<p>&gt; From that perspective, fast search results aren&#x27;t actually that exciting since you can constantly run a background task to update the cached results and just serve those as the requests come in.<p>If that&#x27;s how it worked, I agree, it wouldn&#x27;t be that impressive (every search result would just be a 1-1 cache lookup). That&#x27;s not how it works, though, and as someone who works adjacent to the system, it is pretty impressive how fast it is when the work it&#x27;s doing is actually pretty expensive.</div><br/></div></div><div id="36700212" class="c"><input type="checkbox" id="c-36700212" checked=""/><div class="controls bullet"><span class="by">TX81Z</span><span>|</span><a href="#36699521">root</a><span>|</span><a href="#36699897">parent</a><span>|</span><a href="#36703462">prev</a><span>|</span><a href="#36701221">next</a><span>|</span><label class="collapse" for="c-36700212">[-]</label><label class="expand" for="c-36700212">[14 more]</label></div><br/><div class="children"><div class="content">Almost everything is faster if you can precompute.</div><br/><div id="36700316" class="c"><input type="checkbox" id="c-36700316" checked=""/><div class="controls bullet"><span class="by">bshipp</span><span>|</span><a href="#36699521">root</a><span>|</span><a href="#36700212">parent</a><span>|</span><a href="#36701026">next</a><span>|</span><label class="collapse" for="c-36700316">[-]</label><label class="expand" for="c-36700316">[7 more]</label></div><br/><div class="children"><div class="content">For sure, but the approach is quite viable. If 19 out of 20 searches by a user are almost instantaneous and single novel one requires a few seconds, they&#x27;ll assume a hiccup in their internet connection and still view the site as &quot;really fast&quot;.  It&#x27;s certainly useful for limiting demands on expensive hardware.</div><br/><div id="36700795" class="c"><input type="checkbox" id="c-36700795" checked=""/><div class="controls bullet"><span class="by">teej</span><span>|</span><a href="#36699521">root</a><span>|</span><a href="#36700316">parent</a><span>|</span><a href="#36701026">next</a><span>|</span><label class="collapse" for="c-36700795">[-]</label><label class="expand" for="c-36700795">[6 more]</label></div><br/><div class="children"><div class="content">20% of all Google searches are brand new</div><br/><div id="36701889" class="c"><input type="checkbox" id="c-36701889" checked=""/><div class="controls bullet"><span class="by">bagels</span><span>|</span><a href="#36699521">root</a><span>|</span><a href="#36700795">parent</a><span>|</span><a href="#36701083">next</a><span>|</span><label class="collapse" for="c-36701889">[-]</label><label class="expand" for="c-36701889">[3 more]</label></div><br/><div class="children"><div class="content">Then 80% aren&#x27;t, and those ones will perform very well.</div><br/><div id="36703516" class="c"><input type="checkbox" id="c-36703516" checked=""/><div class="controls bullet"><span class="by">paxys</span><span>|</span><a href="#36699521">root</a><span>|</span><a href="#36701889">parent</a><span>|</span><a href="#36701083">next</a><span>|</span><label class="collapse" for="c-36703516">[-]</label><label class="expand" for="c-36703516">[2 more]</label></div><br/><div class="children"><div class="content">The other 20% also perform well. I have quite literally never encountered a Google search that took more than some tens of milliseconds for a round trip.</div><br/><div id="36704667" class="c"><input type="checkbox" id="c-36704667" checked=""/><div class="controls bullet"><span class="by">bshipp</span><span>|</span><a href="#36699521">root</a><span>|</span><a href="#36703516">parent</a><span>|</span><a href="#36701083">next</a><span>|</span><label class="collapse" for="c-36704667">[-]</label><label class="expand" for="c-36704667">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re absolutely correct. Caching common search queries allows the site to allocate hardware for processing &quot;expensive&quot; queries, with the objective of having both complete at near the same time.<p>Without caching, the cost of operating the site would dramatically escalate.</div><br/></div></div></div></div></div></div><div id="36701083" class="c"><input type="checkbox" id="c-36701083" checked=""/><div class="controls bullet"><span class="by">andrelaszlo</span><span>|</span><a href="#36699521">root</a><span>|</span><a href="#36700795">parent</a><span>|</span><a href="#36701889">prev</a><span>|</span><a href="#36703305">next</a><span>|</span><label class="collapse" for="c-36701083">[-]</label><label class="expand" for="c-36701083">[1 more]</label></div><br/><div class="children"><div class="content">And use 80% of the resources?</div><br/></div></div><div id="36703305" class="c"><input type="checkbox" id="c-36703305" checked=""/><div class="controls bullet"><span class="by">TX81Z</span><span>|</span><a href="#36699521">root</a><span>|</span><a href="#36700795">parent</a><span>|</span><a href="#36701083">prev</a><span>|</span><a href="#36701026">next</a><span>|</span><label class="collapse" for="c-36703305">[-]</label><label class="expand" for="c-36703305">[1 more]</label></div><br/><div class="children"><div class="content">Eh, a non trivial % of those are likely just brand new misspellings.</div><br/></div></div></div></div></div></div><div id="36701026" class="c"><input type="checkbox" id="c-36701026" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#36699521">root</a><span>|</span><a href="#36700212">parent</a><span>|</span><a href="#36700316">prev</a><span>|</span><a href="#36703821">next</a><span>|</span><label class="collapse" for="c-36701026">[-]</label><label class="expand" for="c-36701026">[4 more]</label></div><br/><div class="children"><div class="content">Yup, all FastComments threads are precomputed for all sort directions! Each page comes from the DB in &lt; 1.5ms 75% of the time.<p>It gets tough with pages with 100k+ comments though, so there are different tricks and switches for different flows and data sizes.</div><br/><div id="36702714" class="c"><input type="checkbox" id="c-36702714" checked=""/><div class="controls bullet"><span class="by">qingcharles</span><span>|</span><a href="#36699521">root</a><span>|</span><a href="#36701026">parent</a><span>|</span><a href="#36703821">next</a><span>|</span><label class="collapse" for="c-36702714">[-]</label><label class="expand" for="c-36702714">[3 more]</label></div><br/><div class="children"><div class="content">Your site is killing me. Every page I visit I have to accept the cookies :(</div><br/><div id="36704342" class="c"><input type="checkbox" id="c-36704342" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#36699521">root</a><span>|</span><a href="#36702714">parent</a><span>|</span><a href="#36703908">next</a><span>|</span><label class="collapse" for="c-36704342">[-]</label><label class="expand" for="c-36704342">[1 more]</label></div><br/><div class="children"><div class="content">Fixed. Was an issue specific to certain countries - my bad!</div><br/></div></div><div id="36703908" class="c"><input type="checkbox" id="c-36703908" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#36699521">root</a><span>|</span><a href="#36702714">parent</a><span>|</span><a href="#36704342">prev</a><span>|</span><a href="#36703821">next</a><span>|</span><label class="collapse" for="c-36703908">[-]</label><label class="expand" for="c-36703908">[1 more]</label></div><br/><div class="children"><div class="content">Oh, that&#x27;s weird...</div><br/></div></div></div></div></div></div><div id="36703821" class="c"><input type="checkbox" id="c-36703821" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#36699521">root</a><span>|</span><a href="#36700212">parent</a><span>|</span><a href="#36701026">prev</a><span>|</span><a href="#36702656">next</a><span>|</span><label class="collapse" for="c-36703821">[-]</label><label class="expand" for="c-36703821">[1 more]</label></div><br/><div class="children"><div class="content">I recall reading about the local transit department which had gotten some fancy accelerator card to help with route searches, ie when a customer wanted to go from A to B, which busses, trams etc to take.<p>Can&#x27;t recall if it was &quot;just&quot; a bunch of FPGAs but it was a big-ass PCI card.<p>Some years later I tried to find this story again, and to check if they still used it. Turned out they had ditched it after just a couple of years. As memory sizes had increased, they could just precompute all possible routes for the next day and keep them all in memory...</div><br/></div></div><div id="36702656" class="c"><input type="checkbox" id="c-36702656" checked=""/><div class="controls bullet"><span class="by">winddude</span><span>|</span><a href="#36699521">root</a><span>|</span><a href="#36700212">parent</a><span>|</span><a href="#36703821">prev</a><span>|</span><a href="#36701221">next</a><span>|</span><label class="collapse" for="c-36702656">[-]</label><label class="expand" for="c-36702656">[1 more]</label></div><br/><div class="children"><div class="content">which is why es uses multiple levels of caching</div><br/></div></div></div></div></div></div><div id="36701221" class="c"><input type="checkbox" id="c-36701221" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#36699521">parent</a><span>|</span><a href="#36699897">prev</a><span>|</span><a href="#36699947">next</a><span>|</span><label class="collapse" for="c-36701221">[-]</label><label class="expand" for="c-36701221">[2 more]</label></div><br/><div class="children"><div class="content">&gt; p50&#x2F;p99 retrieval times at realistic loads or it didn&#x27;t happen.<p>Therein lies the problem - how do you generate actual realistic loads for a search engine without having a large number of people use it for searches? Simply hitting it with random search terms isn&#x27;t realistic.<p>Some people will be on slow connections, search terms for something specific might spike in only a certain region (earthquake, etc), etc.<p>If your terms are too random, it&#x27;ll perform worse than it should (results not in the cache), and if not random enough it will perform  better than it should.</div><br/><div id="36702466" class="c"><input type="checkbox" id="c-36702466" checked=""/><div class="controls bullet"><span class="by">gleenn</span><span>|</span><a href="#36699521">root</a><span>|</span><a href="#36701221">parent</a><span>|</span><a href="#36699947">next</a><span>|</span><label class="collapse" for="c-36702466">[-]</label><label class="expand" for="c-36702466">[1 more]</label></div><br/><div class="children"><div class="content">One actual solution is to use historical search logs. Just because &quot;random&quot; is a bad answer doesn&#x27;t mean people don&#x27;t try and make reasonable reproductions of load to replay and benchmark. Cacheing is also a big factor.</div><br/></div></div></div></div><div id="36699947" class="c"><input type="checkbox" id="c-36699947" checked=""/><div class="controls bullet"><span class="by">karmakaze</span><span>|</span><a href="#36699521">parent</a><span>|</span><a href="#36701221">prev</a><span>|</span><a href="#36700966">next</a><span>|</span><label class="collapse" for="c-36699947">[-]</label><label class="expand" for="c-36699947">[1 more]</label></div><br/><div class="children"><div class="content">Lucene (what Elasticsearch and Solr use) are based on inverted indexes which is what the GIN in the article also uses.<p>So the benefits of ES&#x2F;etc are being able to scale horizontally scale across nodes or any additional features it adds on top of the main index.</div><br/></div></div><div id="36700966" class="c"><input type="checkbox" id="c-36700966" checked=""/><div class="controls bullet"><span class="by">ramraj07</span><span>|</span><a href="#36699521">parent</a><span>|</span><a href="#36699947">prev</a><span>|</span><a href="#36699773">next</a><span>|</span><label class="collapse" for="c-36700966">[-]</label><label class="expand" for="c-36700966">[4 more]</label></div><br/><div class="children"><div class="content">We use postgres fts and it works fine, you just gotta how you rank order the rows in the query - if you only use ts_rank then it&#x27;s perfect but you likely want to use some other relevance metric to adjust the ranking but then you can&#x27;t rank order primarily by that metric. Once you nail this the results are as fast as any other typical db table query with an index.</div><br/><div id="36701273" class="c"><input type="checkbox" id="c-36701273" checked=""/><div class="controls bullet"><span class="by">glintik</span><span>|</span><a href="#36699521">root</a><span>|</span><a href="#36700966">parent</a><span>|</span><a href="#36699773">next</a><span>|</span><label class="collapse" for="c-36701273">[-]</label><label class="expand" for="c-36701273">[3 more]</label></div><br/><div class="children"><div class="content">Actually good ranking is the most valuable thing in search engine.</div><br/><div id="36704010" class="c"><input type="checkbox" id="c-36704010" checked=""/><div class="controls bullet"><span class="by">ramraj07</span><span>|</span><a href="#36699521">root</a><span>|</span><a href="#36701273">parent</a><span>|</span><a href="#36702734">next</a><span>|</span><label class="collapse" for="c-36704010">[-]</label><label class="expand" for="c-36704010">[1 more]</label></div><br/><div class="children"><div class="content">What I mean is you can&#x27;t do<p><pre><code>    select * 
      from table 
     where ts_query(...)
  order by relevance_metric
</code></pre>
but instead do<p><pre><code>    select * 
      from (
        select * 
          from table 
         where ts_query(...) 
      order by ts_rank(...)
         limit 1000
    ) 
  order by relevance_metric 
     limit 10</code></pre></div><br/></div></div><div id="36702734" class="c"><input type="checkbox" id="c-36702734" checked=""/><div class="controls bullet"><span class="by">qingcharles</span><span>|</span><a href="#36699521">root</a><span>|</span><a href="#36701273">parent</a><span>|</span><a href="#36704010">prev</a><span>|</span><a href="#36699773">next</a><span>|</span><label class="collapse" for="c-36702734">[-]</label><label class="expand" for="c-36702734">[1 more]</label></div><br/><div class="children"><div class="content">Good ranking is what made Google a trillion dollar company.<p>Google indexed the same sites as Altavista, but Google Page Rank made the right sites bubble to the top and made Sergey and Larry billionaires...</div><br/></div></div></div></div></div></div></div></div><div id="36700935" class="c"><input type="checkbox" id="c-36700935" checked=""/><div class="controls bullet"><span class="by">0xbadcafebee</span><span>|</span><a href="#36699521">prev</a><span>|</span><a href="#36706032">next</a><span>|</span><label class="collapse" for="c-36700935">[-]</label><label class="expand" for="c-36700935">[4 more]</label></div><br/><div class="children"><div class="content">When I was a teenager I made a search engine and database from scratch, not knowing anything about either. I just wanted to see how far I could get, how fast I could make it, returning somewhat relevant search results.<p>It&#x27;s actually very easy to make a fast basic database and search engine, even as an amateur programmer. As long as you understand basic CS algorithms and how to exploit the operating system and hardware, you can put one together in a month or two. Speed is not bad even with high-level languages; something like 250K QPS, back in 2003, on a laptop. Scalability isn&#x27;t much of an issue either if you shard it. Indexing, locking, and consistency are more complicated than the storage and retrieval parts.<p>The big problem to overcome is the subjective nature of search. What do I <i>really</i> want to find? How do I find something when I don&#x27;t know what I&#x27;m looking for? How do I get around people trying to game the system? How do I handle complex queries and datasets? That&#x27;s when it gets orders of magnitude harder.</div><br/><div id="36703566" class="c"><input type="checkbox" id="c-36703566" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#36700935">parent</a><span>|</span><a href="#36703555">next</a><span>|</span><label class="collapse" for="c-36703566">[-]</label><label class="expand" for="c-36703566">[1 more]</label></div><br/><div class="children"><div class="content">250k RPS seems like a lot when SQLite can’t do that today and I feel like inverted indices are more expensive (eg RocksDB gets to ~130k RPS but I think their numbers are on beefier hardware than my laptop or my machine isn’t set up well). Are you sure you wrote a general purpose database and those numbers are correct? I’m curious what you did to outperform these engines (I agree it’s possible, but I’m curious what techniques you employed)</div><br/></div></div><div id="36703555" class="c"><input type="checkbox" id="c-36703555" checked=""/><div class="controls bullet"><span class="by">paxys</span><span>|</span><a href="#36700935">parent</a><span>|</span><a href="#36703566">prev</a><span>|</span><a href="#36702213">next</a><span>|</span><label class="collapse" for="c-36703555">[-]</label><label class="expand" for="c-36703555">[1 more]</label></div><br/><div class="children"><div class="content">When building a search engine the biggest problem isn&#x27;t QPS but the size of the data set you are indexing. If your search structures can fit in memory of a single machine then you can serve effective infinite QPS with ~zero latency. When it grows beyond that you have to get creative, and that&#x27;s when all the different tradeoffs come into the picture.</div><br/></div></div><div id="36702213" class="c"><input type="checkbox" id="c-36702213" checked=""/><div class="controls bullet"><span class="by">gomezjdaniel</span><span>|</span><a href="#36700935">parent</a><span>|</span><a href="#36703555">prev</a><span>|</span><a href="#36706032">next</a><span>|</span><label class="collapse" for="c-36702213">[-]</label><label class="expand" for="c-36702213">[1 more]</label></div><br/><div class="children"><div class="content">It is open sourced anywhere? I am curious</div><br/></div></div></div></div><div id="36706032" class="c"><input type="checkbox" id="c-36706032" checked=""/><div class="controls bullet"><span class="by">kaveh_h</span><span>|</span><a href="#36700935">prev</a><span>|</span><a href="#36705780">next</a><span>|</span><label class="collapse" for="c-36706032">[-]</label><label class="expand" for="c-36706032">[1 more]</label></div><br/><div class="children"><div class="content">Nice article, although the part on fuzzy search not being supported by PostgreSQL is partly incorrect. The pg_trgm extension and an GIN trigram index supports the use case of fuzzy search like in the example in this article:<p><a href="https:&#x2F;&#x2F;www.postgresonline.com&#x2F;article_pfriendly&#x2F;169.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.postgresonline.com&#x2F;article_pfriendly&#x2F;169.html</a><p>This could wastly speed up query but with added cost of more memory usage and operation time during updates.</div><br/></div></div><div id="36703371" class="c"><input type="checkbox" id="c-36703371" checked=""/><div class="controls bullet"><span class="by">v0idzer0</span><span>|</span><a href="#36705780">prev</a><span>|</span><a href="#36700251">next</a><span>|</span><label class="collapse" for="c-36703371">[-]</label><label class="expand" for="c-36703371">[4 more]</label></div><br/><div class="children"><div class="content">FYI it’s “Darth” Vader not “Dark” Vader. I too thought it was “Dark” as a kid</div><br/><div id="36706045" class="c"><input type="checkbox" id="c-36706045" checked=""/><div class="controls bullet"><span class="by">tudorg</span><span>|</span><a href="#36703371">parent</a><span>|</span><a href="#36704498">next</a><span>|</span><label class="collapse" for="c-36706045">[-]</label><label class="expand" for="c-36706045">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, fixed it. That was embarrassing :)</div><br/></div></div><div id="36704498" class="c"><input type="checkbox" id="c-36704498" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#36703371">parent</a><span>|</span><a href="#36706045">prev</a><span>|</span><a href="#36703518">next</a><span>|</span><label class="collapse" for="c-36704498">[-]</label><label class="expand" for="c-36704498">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s actually Dark Vador in some translations such as French, which makes the &quot;error&quot; common.</div><br/></div></div><div id="36703518" class="c"><input type="checkbox" id="c-36703518" checked=""/><div class="controls bullet"><span class="by">topato</span><span>|</span><a href="#36703371">parent</a><span>|</span><a href="#36704498">prev</a><span>|</span><a href="#36700251">next</a><span>|</span><label class="collapse" for="c-36703518">[-]</label><label class="expand" for="c-36703518">[1 more]</label></div><br/><div class="children"><div class="content">I couldn&#x27;t concentrate on anything in this post, it was so distracting. How can you know Yoda quotes, but you&#x27;re still saying Dark Vader?!</div><br/></div></div></div></div><div id="36700251" class="c"><input type="checkbox" id="c-36700251" checked=""/><div class="controls bullet"><span class="by">quartz</span><span>|</span><a href="#36703371">prev</a><span>|</span><a href="#36700939">next</a><span>|</span><label class="collapse" for="c-36700251">[-]</label><label class="expand" for="c-36700251">[13 more]</label></div><br/><div class="children"><div class="content">You can also marry these techniques with pgvector to find related content through embeddings. I&#x27;ve found this to be pretty magical.</div><br/><div id="36700455" class="c"><input type="checkbox" id="c-36700455" checked=""/><div class="controls bullet"><span class="by">jstummbillig</span><span>|</span><a href="#36700251">parent</a><span>|</span><a href="#36700578">next</a><span>|</span><label class="collapse" for="c-36700455">[-]</label><label class="expand" for="c-36700455">[2 more]</label></div><br/><div class="children"><div class="content">Could you get into some more detail or point at something that does?</div><br/><div id="36700496" class="c"><input type="checkbox" id="c-36700496" checked=""/><div class="controls bullet"><span class="by">kaycebasques</span><span>|</span><a href="#36700251">root</a><span>|</span><a href="#36700455">parent</a><span>|</span><a href="#36700578">next</a><span>|</span><label class="collapse" for="c-36700496">[-]</label><label class="expand" for="c-36700496">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;supabase.com&#x2F;blog&#x2F;openai-embeddings-postgres-vector">https:&#x2F;&#x2F;supabase.com&#x2F;blog&#x2F;openai-embeddings-postgres-vector</a><p><a href="https:&#x2F;&#x2F;supabase.com&#x2F;blog&#x2F;chatgpt-supabase-docs">https:&#x2F;&#x2F;supabase.com&#x2F;blog&#x2F;chatgpt-supabase-docs</a></div><br/></div></div></div></div><div id="36700578" class="c"><input type="checkbox" id="c-36700578" checked=""/><div class="controls bullet"><span class="by">binarymax</span><span>|</span><a href="#36700251">parent</a><span>|</span><a href="#36700455">prev</a><span>|</span><a href="#36700939">next</a><span>|</span><label class="collapse" for="c-36700578">[-]</label><label class="expand" for="c-36700578">[10 more]</label></div><br/><div class="children"><div class="content">It&#x27;s interesting that folks go down this hacky route when they can use something like Vespa, which is orders of magnitude better from a performance, relevance, scalability, and developer ergonomics perspective.</div><br/><div id="36700876" class="c"><input type="checkbox" id="c-36700876" checked=""/><div class="controls bullet"><span class="by">LunaSea</span><span>|</span><a href="#36700251">root</a><span>|</span><a href="#36700578">parent</a><span>|</span><a href="#36700782">next</a><span>|</span><label class="collapse" for="c-36700876">[-]</label><label class="expand" for="c-36700876">[6 more]</label></div><br/><div class="children"><div class="content">The advantage of pg_vector is that you don&#x27;t need a second, specialised database and you also don&#x27;t need to synchronise data.<p>It makes much more operational sense to use pg_vector if your use case can be implemented tha way.</div><br/><div id="36700961" class="c"><input type="checkbox" id="c-36700961" checked=""/><div class="controls bullet"><span class="by">binarymax</span><span>|</span><a href="#36700251">root</a><span>|</span><a href="#36700876">parent</a><span>|</span><a href="#36700782">next</a><span>|</span><label class="collapse" for="c-36700961">[-]</label><label class="expand" for="c-36700961">[5 more]</label></div><br/><div class="children"><div class="content">It makes terrible operational sense.  What are the HA&#x2F;DR, sharding, replica, and backup strategies and tools for pg_vector?  What are the embedding integration and relevance tools?  What are the reindexing strategies?  What are the scaling, caching, and CPU thrashing resolution paths?<p>You&#x27;re going to spend a bunch of time writing integrations that already exist for actual search engines, and you&#x27;re going to be stuck and need to back out when search becomes a necessity rather than an afterthought.</div><br/><div id="36701625" class="c"><input type="checkbox" id="c-36701625" checked=""/><div class="controls bullet"><span class="by">philipbjorge</span><span>|</span><a href="#36700251">root</a><span>|</span><a href="#36700961">parent</a><span>|</span><a href="#36702788">next</a><span>|</span><label class="collapse" for="c-36701625">[-]</label><label class="expand" for="c-36701625">[1 more]</label></div><br/><div class="children"><div class="content">What makes most operational sense is going to depend on your context.<p>From my vantage point, you’re both right in the appropriate context.</div><br/></div></div><div id="36702788" class="c"><input type="checkbox" id="c-36702788" checked=""/><div class="controls bullet"><span class="by">djbusby</span><span>|</span><a href="#36700251">root</a><span>|</span><a href="#36700961">parent</a><span>|</span><a href="#36701625">prev</a><span>|</span><a href="#36702647">next</a><span>|</span><label class="collapse" for="c-36702788">[-]</label><label class="expand" for="c-36702788">[1 more]</label></div><br/><div class="children"><div class="content">The HA&#x2F;DR, Sharing, Replica and Backup would all be the same as before. Its all in PG so you use the existing method.<p>If you have two systems, then you have two (unique) answers for HA,DR,Shard,Replica,Backup - the PG set and the Vespa.<p>That&#x27;s more complicated, from an operational perspective.<p>PG FTS is quite good, and there are in-pg methods that can improve it.<p>And, from experience, when it&#x27;s item to upscale to Solr&#x2F;ES&#x2F;etc it&#x27;s not a very heavy lift.</div><br/></div></div><div id="36702647" class="c"><input type="checkbox" id="c-36702647" checked=""/><div class="controls bullet"><span class="by">whakim</span><span>|</span><a href="#36700251">root</a><span>|</span><a href="#36700961">parent</a><span>|</span><a href="#36702788">prev</a><span>|</span><a href="#36701757">next</a><span>|</span><label class="collapse" for="c-36702647">[-]</label><label class="expand" for="c-36702647">[1 more]</label></div><br/><div class="children"><div class="content">What if you don&#x27;t need those things yet and you just have some embeddings you want to query for cosine similarity? A dedicated vector database is way, way overkill for many people.</div><br/></div></div></div></div></div></div><div id="36700782" class="c"><input type="checkbox" id="c-36700782" checked=""/><div class="controls bullet"><span class="by">moomoo11</span><span>|</span><a href="#36700251">root</a><span>|</span><a href="#36700578">parent</a><span>|</span><a href="#36700876">prev</a><span>|</span><a href="#36700601">next</a><span>|</span><label class="collapse" for="c-36700782">[-]</label><label class="expand" for="c-36700782">[2 more]</label></div><br/><div class="children"><div class="content">Is that a different system?<p>Sorry I’m on spotty mobile that can’t open anything besides HN lol (God bless this website).<p>Sometimes it is just easier to use the existing systems and squeeze them as much as possible. Especially when it’s a small team or solo without much $$</div><br/><div id="36700853" class="c"><input type="checkbox" id="c-36700853" checked=""/><div class="controls bullet"><span class="by">binarymax</span><span>|</span><a href="#36700251">root</a><span>|</span><a href="#36700782">parent</a><span>|</span><a href="#36700601">next</a><span>|</span><label class="collapse" for="c-36700853">[-]</label><label class="expand" for="c-36700853">[1 more]</label></div><br/><div class="children"><div class="content">When it comes to search I cannot disagree more.<p><a href="https:&#x2F;&#x2F;vespa.ai" rel="nofollow noreferrer">https:&#x2F;&#x2F;vespa.ai</a> is a purpose built search engine.<p>If you start bolting search onto your database, your relevance will be terrible, you&#x27;ll be rewriting a lot of table stakes tools&#x2F;features from scratch, and your technical debt will skyrocket.</div><br/></div></div></div></div></div></div></div></div><div id="36700939" class="c"><input type="checkbox" id="c-36700939" checked=""/><div class="controls bullet"><span class="by">daitangio</span><span>|</span><a href="#36700251">prev</a><span>|</span><a href="#36702636">next</a><span>|</span><label class="collapse" for="c-36700939">[-]</label><label class="expand" for="c-36700939">[3 more]</label></div><br/><div class="children"><div class="content">Very nice and clear article.
Also SQLite offers advanced indexing functionality and stemming with a standard plugin.
For english SQLite works well too</div><br/><div id="36706341" class="c"><input type="checkbox" id="c-36706341" checked=""/><div class="controls bullet"><span class="by">daitangio</span><span>|</span><a href="#36700939">parent</a><span>|</span><a href="#36704742">next</a><span>|</span><label class="collapse" for="c-36706341">[-]</label><label class="expand" for="c-36706341">[1 more]</label></div><br/><div class="children"><div class="content">I have found my experiments with SQLite here
<a href="https:&#x2F;&#x2F;github.com&#x2F;daitangio&#x2F;knowledge">https:&#x2F;&#x2F;github.com&#x2F;daitangio&#x2F;knowledge</a><p>Give it a try, it is very powerful</div><br/></div></div><div id="36704742" class="c"><input type="checkbox" id="c-36704742" checked=""/><div class="controls bullet"><span class="by">paulryanrogers</span><span>|</span><a href="#36700939">parent</a><span>|</span><a href="#36706341">prev</a><span>|</span><a href="#36702636">next</a><span>|</span><label class="collapse" for="c-36704742">[-]</label><label class="expand" for="c-36704742">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if a FDW could do this. Since just replicating the to-be-searched data should have only a few writers it could work well for moderately sized data.</div><br/></div></div></div></div><div id="36702636" class="c"><input type="checkbox" id="c-36702636" checked=""/><div class="controls bullet"><span class="by">fizx</span><span>|</span><a href="#36700939">prev</a><span>|</span><a href="#36700071">next</a><span>|</span><label class="collapse" for="c-36702636">[-]</label><label class="expand" for="c-36702636">[4 more]</label></div><br/><div class="children"><div class="content">One of the many problems with search inside Postgres is that search is very CPU-heavy (and starting to become GPU-heavy).  Ideally, you&#x27;d like to reserve CPU in your database for transactional updates to your core data model.<p>I&#x27;ve seen a lot of ES and Solr clusters operating at 100% of 10+ nodes during a re-index, or just 30-50% of 10+ nodes during normal operation.  The corresponding database would be say an AWS L&#x2F;XL instance at 50-100GB of data and 30% CPU utilization.  Moving all of the search CPU into your primary DB means now you&#x27;d have to shard it.<p>But I love PG extensions for search, recursive joins, vectors, etc on side projects.  It can keep things fun and simple.</div><br/><div id="36702754" class="c"><input type="checkbox" id="c-36702754" checked=""/><div class="controls bullet"><span class="by">nbgoodall</span><span>|</span><a href="#36702636">parent</a><span>|</span><a href="#36700071">next</a><span>|</span><label class="collapse" for="c-36702754">[-]</label><label class="expand" for="c-36702754">[3 more]</label></div><br/><div class="children"><div class="content">Could you solve this by searching on a read-only replica?</div><br/><div id="36705086" class="c"><input type="checkbox" id="c-36705086" checked=""/><div class="controls bullet"><span class="by">fizx</span><span>|</span><a href="#36702636">root</a><span>|</span><a href="#36702754">parent</a><span>|</span><a href="#36704916">next</a><span>|</span><label class="collapse" for="c-36705086">[-]</label><label class="expand" for="c-36705086">[1 more]</label></div><br/><div class="children"><div class="content">Some of it, yes.<p>But in practice, you want to fix a bug in chinese tokenization, or OpenAI releases the next version of its embeddings, or you want to add a few synonyms, or change the aggressiveness of the stemmer.<p>Then you have to rewrite your whole search index, and if its part of your primary db, you&#x27;re pretty sad.</div><br/></div></div><div id="36704916" class="c"><input type="checkbox" id="c-36704916" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#36702636">root</a><span>|</span><a href="#36702754">parent</a><span>|</span><a href="#36705086">prev</a><span>|</span><a href="#36700071">next</a><span>|</span><label class="collapse" for="c-36704916">[-]</label><label class="expand" for="c-36704916">[1 more]</label></div><br/><div class="children"><div class="content">Convincing your devs to keep two handles two the db, one for reads one for writes from the beginning is a <i>blessing.</i></div><br/></div></div></div></div></div></div><div id="36700071" class="c"><input type="checkbox" id="c-36700071" checked=""/><div class="controls bullet"><span class="by">b1zguy</span><span>|</span><a href="#36702636">prev</a><span>|</span><a href="#36703954">next</a><span>|</span><label class="collapse" for="c-36700071">[-]</label><label class="expand" for="c-36700071">[17 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been meaning to attempt running a custom search engine for particular sites I&#x27;ve &#x27;bookmarked&#x27;. Some sites contain gold that could be useful in the future and is not often discovered in Google results.<p>Should I go the Postgres&#x2F;Elasticsearch route or are somewhat out-of-the-box solutions available?</div><br/><div id="36700216" class="c"><input type="checkbox" id="c-36700216" checked=""/><div class="controls bullet"><span class="by">bshipp</span><span>|</span><a href="#36700071">parent</a><span>|</span><a href="#36700726">next</a><span>|</span><label class="collapse" for="c-36700216">[-]</label><label class="expand" for="c-36700216">[1 more]</label></div><br/><div class="children"><div class="content">For such a light demand and fixed site requirements, a single-file sqlite dB is probably best.  Modern Sqlite has full-text capabilities that are quite powerful and relatively easy to implement.<p><a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;fts5.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.sqlite.org&#x2F;fts5.html</a></div><br/></div></div><div id="36700726" class="c"><input type="checkbox" id="c-36700726" checked=""/><div class="controls bullet"><span class="by">binarymax</span><span>|</span><a href="#36700071">parent</a><span>|</span><a href="#36700216">prev</a><span>|</span><a href="#36700149">next</a><span>|</span><label class="collapse" for="c-36700726">[-]</label><label class="expand" for="c-36700726">[6 more]</label></div><br/><div class="children"><div class="content">For something small with a minimal footprint, I&#x27;d recommend Typesense.  <a href="https:&#x2F;&#x2F;github.com&#x2F;typesense&#x2F;typesense">https:&#x2F;&#x2F;github.com&#x2F;typesense&#x2F;typesense</a><p>Elasticsearch is heavy, and relational databases with search bolted on (like Postgres or SQLite) aren&#x27;t great.</div><br/><div id="36701168" class="c"><input type="checkbox" id="c-36701168" checked=""/><div class="controls bullet"><span class="by">bshipp</span><span>|</span><a href="#36700071">root</a><span>|</span><a href="#36700726">parent</a><span>|</span><a href="#36700149">next</a><span>|</span><label class="collapse" for="c-36701168">[-]</label><label class="expand" for="c-36701168">[5 more]</label></div><br/><div class="children"><div class="content">It depends on what the user requirements are. FTS works pretty well with both Postgres and SQLite, in my experience.<p>Here&#x27;s a git repo someone can modify to do a cross comparison on a specific dataset, if they are interested. It doesn&#x27;t seem to indicate the RMDBs are outclassed in a small-scale FTS implementation.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;VADOSWARE&#x2F;fts-benchmark">https:&#x2F;&#x2F;github.com&#x2F;VADOSWARE&#x2F;fts-benchmark</a></div><br/><div id="36701397" class="c"><input type="checkbox" id="c-36701397" checked=""/><div class="controls bullet"><span class="by">binarymax</span><span>|</span><a href="#36700071">root</a><span>|</span><a href="#36701168">parent</a><span>|</span><a href="#36701471">next</a><span>|</span><label class="collapse" for="c-36701397">[-]</label><label class="expand" for="c-36701397">[3 more]</label></div><br/><div class="children"><div class="content">For personal use nobody cares about 100ms vs 10ms response.  What they do care about is relevance.  Consider the following from those repo outputs:<p>Typesense<p><pre><code>    [timing] phrase [superman]: returned [28] results in 4.222797.ms
    [timing] phrase [suprman]: returned [28] results in 3.663458.ms
</code></pre>
SQLite<p><pre><code>    [timing] phrase [superman]: returned [47] results in 0.351138.ms
    [timing] phrase [suprman]: returned [0] results in 0.07513.ms
</code></pre>
So SQLite is faster, but who cares?  I want things like relevance and typo resilience without having to configure anything.</div><br/><div id="36702738" class="c"><input type="checkbox" id="c-36702738" checked=""/><div class="controls bullet"><span class="by">evdubs</span><span>|</span><a href="#36700071">root</a><span>|</span><a href="#36701397">parent</a><span>|</span><a href="#36702688">next</a><span>|</span><label class="collapse" for="c-36702738">[-]</label><label class="expand" for="c-36702738">[1 more]</label></div><br/><div class="children"><div class="content">The article covers typo resilience in the section &quot;Typo tolerance &#x2F; fuzzy search&quot;.<p>This adds a step between query entry and text search where you find the similarity of query words to unique lexemes if the word is not a lexeme. Seems like a reasonable compromise to me?</div><br/></div></div><div id="36702688" class="c"><input type="checkbox" id="c-36702688" checked=""/><div class="controls bullet"><span class="by">bshipp</span><span>|</span><a href="#36700071">root</a><span>|</span><a href="#36701397">parent</a><span>|</span><a href="#36702738">prev</a><span>|</span><a href="#36701471">next</a><span>|</span><label class="collapse" for="c-36702688">[-]</label><label class="expand" for="c-36702688">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not trying to be argumentative. As long as people find a solution they&#x27;re happy with, I think that&#x27;s great. For me, I&#x27;m far less interested in handling typos, but I can see how it would be valuable in many applications. I&#x27;m usually less interested in tying in and learning another set of services if I can get 90% of the way there with one, but leaving the option of adding it later if additional requirements make it necessary.</div><br/></div></div></div></div><div id="36701471" class="c"><input type="checkbox" id="c-36701471" checked=""/><div class="controls bullet"><span class="by">hardwaresofton</span><span>|</span><a href="#36700071">root</a><span>|</span><a href="#36701168">parent</a><span>|</span><a href="#36701397">prev</a><span>|</span><a href="#36700149">next</a><span>|</span><label class="collapse" for="c-36701471">[-]</label><label class="expand" for="c-36701471">[1 more]</label></div><br/><div class="children"><div class="content">Also I’ve got a small project in which I try to compare meilisearch and postgres fts w&#x2F; pg_trm, it’s called podcastsaver:<p>Podcastsaver.com (click on the nerds tab in the top right)<p>Never got to it but there are a bunch of other search engines worth adding — Sonic, Typesense, etc. Maybe some day</div><br/></div></div></div></div></div></div><div id="36700149" class="c"><input type="checkbox" id="c-36700149" checked=""/><div class="controls bullet"><span class="by">sudobash1</span><span>|</span><a href="#36700071">parent</a><span>|</span><a href="#36700726">prev</a><span>|</span><a href="#36701062">next</a><span>|</span><label class="collapse" for="c-36700149">[-]</label><label class="expand" for="c-36700149">[4 more]</label></div><br/><div class="children"><div class="content">I am wanting to do something similar. Archivebox seems to be the best solution for this sort of self-hosted, searchable web archive. It has multiple search back-ends and plugins to sync browser bookmarks (or even history).<p>I haven&#x27;t finished getting it set up though, so take this recommendation with a hefty grain of salt.</div><br/><div id="36700267" class="c"><input type="checkbox" id="c-36700267" checked=""/><div class="controls bullet"><span class="by">SpriglyElixir12</span><span>|</span><a href="#36700071">root</a><span>|</span><a href="#36700149">parent</a><span>|</span><a href="#36701062">next</a><span>|</span><label class="collapse" for="c-36700267">[-]</label><label class="expand" for="c-36700267">[3 more]</label></div><br/><div class="children"><div class="content">How would something like this work in practice? Would you generate any tags or summaries per site when inserting it into the db?</div><br/><div id="36703143" class="c"><input type="checkbox" id="c-36703143" checked=""/><div class="controls bullet"><span class="by">sudobash1</span><span>|</span><a href="#36700071">root</a><span>|</span><a href="#36700267">parent</a><span>|</span><a href="#36702008">next</a><span>|</span><label class="collapse" for="c-36703143">[-]</label><label class="expand" for="c-36703143">[1 more]</label></div><br/><div class="children"><div class="content">ArchiveBox can extract text from HTML (and possibly PDFs too). I think it can be configured to extract subtitles from YouTube videos as well. So it can do full text searches. Basically you could have your own, offline &amp; curated search-engine.</div><br/></div></div><div id="36702008" class="c"><input type="checkbox" id="c-36702008" checked=""/><div class="controls bullet"><span class="by">janalsncm</span><span>|</span><a href="#36700071">root</a><span>|</span><a href="#36700267">parent</a><span>|</span><a href="#36703143">prev</a><span>|</span><a href="#36701062">next</a><span>|</span><label class="collapse" for="c-36702008">[-]</label><label class="expand" for="c-36702008">[1 more]</label></div><br/><div class="children"><div class="content">You could run a full text search or search against an auto-generated summary. Or if you want to be fancy, use semantic search like in Retrieval Augmented Generation.</div><br/></div></div></div></div></div></div><div id="36701062" class="c"><input type="checkbox" id="c-36701062" checked=""/><div class="controls bullet"><span class="by">b1zguy</span><span>|</span><a href="#36700071">parent</a><span>|</span><a href="#36700149">prev</a><span>|</span><a href="#36700253">next</a><span>|</span><label class="collapse" for="c-36701062">[-]</label><label class="expand" for="c-36701062">[3 more]</label></div><br/><div class="children"><div class="content">Edit: I forgot to add how would I add the webpage to the databases already suggested here? Do I need to use a separate program to spider&#x2F;index each site, and check for its updates?</div><br/><div id="36701271" class="c"><input type="checkbox" id="c-36701271" checked=""/><div class="controls bullet"><span class="by">bshipp</span><span>|</span><a href="#36700071">root</a><span>|</span><a href="#36701062">parent</a><span>|</span><a href="#36700253">next</a><span>|</span><label class="collapse" for="c-36701271">[-]</label><label class="expand" for="c-36701271">[2 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re looking for a turn-key solution, I&#x27;d have to dig a little. I generally write a scraper in python that dumps into a database or flat file (depending on number of records I&#x27;m hunting).<p>Scraping is a separate subject, but once you write one you can generally reuse relevant portions for many others. If you can get adept at a scraping framework like Scrapy you can do it fairly quickly, but there aren&#x27;t many tools that work out of the box for every site you&#x27;ll encounter.<p>Once you&#x27;ve written the spider, it&#x27;s generally able to be rerun for updates unless the site code is dramatically altered. It really comes down to how brittle the spider is coded (i.e. hunting for specific heading sizes or fonts or something) instead of grabbing the underlying JSON&#x2F;XHR that doesn&#x27;t usually change frequently.<p>1. <a href="https:&#x2F;&#x2F;scrapy.org" rel="nofollow noreferrer">https:&#x2F;&#x2F;scrapy.org</a></div><br/><div id="36706026" class="c"><input type="checkbox" id="c-36706026" checked=""/><div class="controls bullet"><span class="by">busymom0</span><span>|</span><a href="#36700071">root</a><span>|</span><a href="#36701271">parent</a><span>|</span><a href="#36700253">next</a><span>|</span><label class="collapse" for="c-36706026">[-]</label><label class="expand" for="c-36706026">[1 more]</label></div><br/><div class="children"><div class="content">Depending upon the type of content, one might want to look into using the Readability (Browder&#x27;s reader view) to parse the webpage. It will give you all the useful info without the junk. Then you can put it in the DB as needed.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;mozilla&#x2F;readability">https:&#x2F;&#x2F;github.com&#x2F;mozilla&#x2F;readability</a><p>Btw, readability, is also available in few other languages like Kotlin:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;dankito&#x2F;Readability4J">https:&#x2F;&#x2F;github.com&#x2F;dankito&#x2F;Readability4J</a></div><br/></div></div></div></div></div></div><div id="36700253" class="c"><input type="checkbox" id="c-36700253" checked=""/><div class="controls bullet"><span class="by">tudorg</span><span>|</span><a href="#36700071">parent</a><span>|</span><a href="#36701062">prev</a><span>|</span><a href="#36700143">next</a><span>|</span><label class="collapse" for="c-36700253">[-]</label><label class="expand" for="c-36700253">[1 more]</label></div><br/><div class="children"><div class="content">Do you prefer it locally or in the cloud? If in the cloud, check out Xata (the domain of the blog post here).</div><br/></div></div><div id="36700143" class="c"><input type="checkbox" id="c-36700143" checked=""/><div class="controls bullet"><span class="by">Alifatisk</span><span>|</span><a href="#36700071">parent</a><span>|</span><a href="#36700253">prev</a><span>|</span><a href="#36703954">next</a><span>|</span><label class="collapse" for="c-36700143">[-]</label><label class="expand" for="c-36700143">[1 more]</label></div><br/><div class="children"><div class="content">Searchkick gem + Elasticsearch is a good combo</div><br/></div></div></div></div><div id="36703954" class="c"><input type="checkbox" id="c-36703954" checked=""/><div class="controls bullet"><span class="by">catsarebetter</span><span>|</span><a href="#36700071">prev</a><span>|</span><a href="#36706110">next</a><span>|</span><label class="collapse" for="c-36703954">[-]</label><label class="expand" for="c-36703954">[1 more]</label></div><br/><div class="children"><div class="content">This is the first I&#x27;m seeing this. So it&#x27;s abstracting the business logic of the API (ie. GraphQL) into the database? What are we trading off here?</div><br/></div></div><div id="36706110" class="c"><input type="checkbox" id="c-36706110" checked=""/><div class="controls bullet"><span class="by">almost</span><span>|</span><a href="#36703954">prev</a><span>|</span><a href="#36701834">next</a><span>|</span><label class="collapse" for="c-36706110">[-]</label><label class="expand" for="c-36706110">[1 more]</label></div><br/><div class="children"><div class="content">PostgreSQL’s pg_trgm extension is also very useful. If you want to be able to search and find partial words etc then trigram indexes can be more useful than full text indexes. I’ve made the mistake of just chucking full text search at the problem before and often it doesn’t give the results you might want.</div><br/></div></div><div id="36701834" class="c"><input type="checkbox" id="c-36701834" checked=""/><div class="controls bullet"><span class="by">_s_a_m_</span><span>|</span><a href="#36706110">prev</a><span>|</span><a href="#36699821">next</a><span>|</span><label class="collapse" for="c-36701834">[-]</label><label class="expand" for="c-36701834">[1 more]</label></div><br/><div class="children"><div class="content">Has the word &quot;advanced&quot;, must be good ..</div><br/></div></div><div id="36699821" class="c"><input type="checkbox" id="c-36699821" checked=""/><div class="controls bullet"><span class="by">asadawadia</span><span>|</span><a href="#36701834">prev</a><span>|</span><a href="#36700193">next</a><span>|</span><label class="collapse" for="c-36699821">[-]</label><label class="expand" for="c-36699821">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;rcs.aawadia.dev&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;rcs.aawadia.dev&#x2F;</a> is also using pg search</div><br/></div></div><div id="36700193" class="c"><input type="checkbox" id="c-36700193" checked=""/><div class="controls bullet"><span class="by">lettergram</span><span>|</span><a href="#36699821">prev</a><span>|</span><a href="#36704017">next</a><span>|</span><label class="collapse" for="c-36700193">[-]</label><label class="expand" for="c-36700193">[1 more]</label></div><br/><div class="children"><div class="content">I’ve actually done this before and made it pretty damn fast -<p><a href="https:&#x2F;&#x2F;austingwalters.com&#x2F;fast-full-text-search-in-postgresql&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;austingwalters.com&#x2F;fast-full-text-search-in-postgres...</a><p>The website is <a href="https:&#x2F;&#x2F;askhn.ai" rel="nofollow noreferrer">https:&#x2F;&#x2F;askhn.ai</a> for the moment</div><br/></div></div><div id="36704017" class="c"><input type="checkbox" id="c-36704017" checked=""/><div class="controls bullet"><span class="by">xhax</span><span>|</span><a href="#36700193">prev</a><span>|</span><a href="#36699946">next</a><span>|</span><label class="collapse" for="c-36704017">[-]</label><label class="expand" for="c-36704017">[1 more]</label></div><br/><div class="children"><div class="content">This looks cool as heck. +1</div><br/></div></div><div id="36699946" class="c"><input type="checkbox" id="c-36699946" checked=""/><div class="controls bullet"><span class="by">rane</span><span>|</span><a href="#36704017">prev</a><span>|</span><a href="#36700820">next</a><span>|</span><label class="collapse" for="c-36699946">[-]</label><label class="expand" for="c-36699946">[18 more]</label></div><br/><div class="children"><div class="content">How does SQLite fare against PostgreSQL for this particular use case?</div><br/><div id="36699961" class="c"><input type="checkbox" id="c-36699961" checked=""/><div class="controls bullet"><span class="by">shortrounddev2</span><span>|</span><a href="#36699946">parent</a><span>|</span><a href="#36700020">next</a><span>|</span><label class="collapse" for="c-36699961">[-]</label><label class="expand" for="c-36699961">[14 more]</label></div><br/><div class="children"><div class="content">Why do I see so much discussion about SQLite on HN? I&#x27;ve literally never seen it used in production, my usage of it is purely as a database for local testing</div><br/><div id="36700136" class="c"><input type="checkbox" id="c-36700136" checked=""/><div class="controls bullet"><span class="by">samwillis</span><span>|</span><a href="#36699946">root</a><span>|</span><a href="#36699961">parent</a><span>|</span><a href="#36700059">next</a><span>|</span><label class="collapse" for="c-36700136">[-]</label><label class="expand" for="c-36700136">[2 more]</label></div><br/><div class="children"><div class="content">With the move to the &quot;edge&quot; for compute, having your database at the edge reduces latency and basically makes it viable. So the theory is that SQLite read replicas will be the answer to a lot of these plans. See what Fly and Cloudflare are investing in with the edge network and SQLite plans.<p>On top of that SQLite is now viable in the browser with WASM and the &quot;origin privet file system&quot; api. And so people are increasing looking at moving more state and persistence to the browser with an eventually consistent sync. This is what the &quot;Local First&quot; movement, myself included, are excited about.</div><br/><div id="36706561" class="c"><input type="checkbox" id="c-36706561" checked=""/><div class="controls bullet"><span class="by">vmfunction</span><span>|</span><a href="#36699946">root</a><span>|</span><a href="#36700136">parent</a><span>|</span><a href="#36700059">next</a><span>|</span><label class="collapse" for="c-36706561">[-]</label><label class="expand" for="c-36706561">[1 more]</label></div><br/><div class="children"><div class="content">It is what Deno is doing, by putting what traditionally known as the middleware on the edge with a db (localStore). Essentially emulating the browser stack in some ways. Be very interesting to see different kind of code sharing amongst Deno edge nodes and browser.</div><br/></div></div></div></div><div id="36700059" class="c"><input type="checkbox" id="c-36700059" checked=""/><div class="controls bullet"><span class="by">bshipp</span><span>|</span><a href="#36699946">root</a><span>|</span><a href="#36699961">parent</a><span>|</span><a href="#36700136">prev</a><span>|</span><a href="#36701829">next</a><span>|</span><label class="collapse" for="c-36700059">[-]</label><label class="expand" for="c-36700059">[1 more]</label></div><br/><div class="children"><div class="content">Sqlite is extremely powerful for any locally-embedded databases, such as apps with an offline component.  For example, searching text in notes, books, cached news, etc.  It&#x27;s very simple to implement inside Sqlite with much less overhead than including a Postgres&#x2F;Mysql instance.</div><br/></div></div><div id="36701829" class="c"><input type="checkbox" id="c-36701829" checked=""/><div class="controls bullet"><span class="by">osrec</span><span>|</span><a href="#36699946">root</a><span>|</span><a href="#36699961">parent</a><span>|</span><a href="#36700059">prev</a><span>|</span><a href="#36700110">next</a><span>|</span><label class="collapse" for="c-36701829">[-]</label><label class="expand" for="c-36701829">[1 more]</label></div><br/><div class="children"><div class="content">It is used in a huge number of production environments, including within your browser (most probably).<p>Probably not something you want to run a multi tenant SaaS database with, but it is useful if you are going the one tenant per database route.</div><br/></div></div><div id="36700110" class="c"><input type="checkbox" id="c-36700110" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#36699946">root</a><span>|</span><a href="#36699961">parent</a><span>|</span><a href="#36701829">prev</a><span>|</span><a href="#36701023">next</a><span>|</span><label class="collapse" for="c-36700110">[-]</label><label class="expand" for="c-36700110">[1 more]</label></div><br/><div class="children"><div class="content">It’s used in production quite a bit, probably just not in your field as much. Anytime I’m thinking about storing something in a file I use SQLite instead</div><br/></div></div><div id="36701023" class="c"><input type="checkbox" id="c-36701023" checked=""/><div class="controls bullet"><span class="by">0xbadcafebee</span><span>|</span><a href="#36699946">root</a><span>|</span><a href="#36699961">parent</a><span>|</span><a href="#36700110">prev</a><span>|</span><a href="#36700171">next</a><span>|</span><label class="collapse" for="c-36701023">[-]</label><label class="expand" for="c-36701023">[4 more]</label></div><br/><div class="children"><div class="content">HN has fads like everything else. If this were 10 years ago they&#x27;d be asking about MongoDB. 5 years ago they&#x27;d be asking if the Blockchain could power their search engine. Now they want an AI search engine.</div><br/><div id="36701815" class="c"><input type="checkbox" id="c-36701815" checked=""/><div class="controls bullet"><span class="by">thewataccount</span><span>|</span><a href="#36699946">root</a><span>|</span><a href="#36701023">parent</a><span>|</span><a href="#36701269">next</a><span>|</span><label class="collapse" for="c-36701815">[-]</label><label class="expand" for="c-36701815">[1 more]</label></div><br/><div class="children"><div class="content">Sqlite has nothing to do with AI searching in the way I think you&#x27;re suggesting.<p>It was not designed for &quot;AI usage&quot; or as a &quot;AI database&quot;<p>SQlite is from 2000 and is more comparable to a single file postgres&#x2F;mysql database.<p>It&#x27;s also on literally billions of devices including whatever you&#x27;re reading this on.</div><br/></div></div><div id="36701269" class="c"><input type="checkbox" id="c-36701269" checked=""/><div class="controls bullet"><span class="by">appletrotter</span><span>|</span><a href="#36699946">root</a><span>|</span><a href="#36701023">parent</a><span>|</span><a href="#36701815">prev</a><span>|</span><a href="#36700171">next</a><span>|</span><label class="collapse" for="c-36701269">[-]</label><label class="expand" for="c-36701269">[2 more]</label></div><br/><div class="children"><div class="content">I feel like MongoDB was on the wane  even 5 years ago.</div><br/><div id="36701551" class="c"><input type="checkbox" id="c-36701551" checked=""/><div class="controls bullet"><span class="by">callalex</span><span>|</span><a href="#36699946">root</a><span>|</span><a href="#36701269">parent</a><span>|</span><a href="#36700171">next</a><span>|</span><label class="collapse" for="c-36701551">[-]</label><label class="expand" for="c-36701551">[1 more]</label></div><br/><div class="children"><div class="content">Also, the interest may not have all been…organic.</div><br/></div></div></div></div></div></div><div id="36700171" class="c"><input type="checkbox" id="c-36700171" checked=""/><div class="controls bullet"><span class="by">Mustachio</span><span>|</span><a href="#36699946">root</a><span>|</span><a href="#36699961">parent</a><span>|</span><a href="#36701023">prev</a><span>|</span><a href="#36700115">next</a><span>|</span><label class="collapse" for="c-36700171">[-]</label><label class="expand" for="c-36700171">[1 more]</label></div><br/><div class="children"><div class="content">We do natural language processing with some custom tokenisation, the data it uses at runtime is put into an sqlite db at build-time. Works fine for our usecase.</div><br/></div></div><div id="36700115" class="c"><input type="checkbox" id="c-36700115" checked=""/><div class="controls bullet"><span class="by">TX81Z</span><span>|</span><a href="#36699946">root</a><span>|</span><a href="#36699961">parent</a><span>|</span><a href="#36700171">prev</a><span>|</span><a href="#36701802">next</a><span>|</span><label class="collapse" for="c-36700115">[-]</label><label class="expand" for="c-36700115">[2 more]</label></div><br/><div class="children"><div class="content">Lol, you’re using it “in production” right now!  SQLite is everywhere, almost definitely in the browser you’re using to view this post.</div><br/><div id="36700349" class="c"><input type="checkbox" id="c-36700349" checked=""/><div class="controls bullet"><span class="by">shortrounddev2</span><span>|</span><a href="#36699946">root</a><span>|</span><a href="#36700115">parent</a><span>|</span><a href="#36701802">next</a><span>|</span><label class="collapse" for="c-36700349">[-]</label><label class="expand" for="c-36700349">[1 more]</label></div><br/><div class="children"><div class="content">I guess it&#x27;s a difference in industry. Everything I do is accessed over a network, and for caching we use simpler key-store libraries rather than relational databases. I don&#x27;t develop client software</div><br/></div></div></div></div><div id="36701802" class="c"><input type="checkbox" id="c-36701802" checked=""/><div class="controls bullet"><span class="by">thewataccount</span><span>|</span><a href="#36699946">root</a><span>|</span><a href="#36699961">parent</a><span>|</span><a href="#36700115">prev</a><span>|</span><a href="#36700020">next</a><span>|</span><label class="collapse" for="c-36701802">[-]</label><label class="expand" for="c-36701802">[1 more]</label></div><br/><div class="children"><div class="content">Put simply - SQLite is incredibly powerful and simple - it can handle a lot more then people might think - and AFAIK it is the most &quot;used in production&quot; database whether you&#x27;re aware of it or not.<p>Depending on the use case it can scale incredibly well, and is tiny and battle hardened.<p>It&#x27;s the most deployed database, it&#x27;s on every smartphone, &quot;smart device&quot;, computer, it&#x27;s inside of many of your apps, powers many of the websites you use, etc.<p>---<p>tl;dr - If you&#x27;re following &quot;use the simplest, but reliable tool for the job&quot; then sqlite is a valid option for a crapload of use cases, most people aren&#x27;t aware of what it can actually do because it doesn&#x27;t &quot;web scale&quot;.<p>Sqlite isn&#x27;t new, it&#x27;s old, and it&#x27;s &quot;used in production&quot; count is in the literal billions.</div><br/></div></div></div></div><div id="36700020" class="c"><input type="checkbox" id="c-36700020" checked=""/><div class="controls bullet"><span class="by">bshipp</span><span>|</span><a href="#36699946">parent</a><span>|</span><a href="#36699961">prev</a><span>|</span><a href="#36699992">next</a><span>|</span><label class="collapse" for="c-36700020">[-]</label><label class="expand" for="c-36700020">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve had good luck using FTS5 in Sqlite for small-scale use scenarios, such as examining scraped data, etc.  It&#x27;s remarkably powerful and quick.<p><a href="https:&#x2F;&#x2F;www.sqlitetutorial.net&#x2F;sqlite-full-text-search&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.sqlitetutorial.net&#x2F;sqlite-full-text-search&#x2F;</a><p><a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;fts5.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.sqlite.org&#x2F;fts5.html</a></div><br/><div id="36703219" class="c"><input type="checkbox" id="c-36703219" checked=""/><div class="controls bullet"><span class="by">anitil</span><span>|</span><a href="#36699946">root</a><span>|</span><a href="#36700020">parent</a><span>|</span><a href="#36699992">next</a><span>|</span><label class="collapse" for="c-36703219">[-]</label><label class="expand" for="c-36703219">[1 more]</label></div><br/><div class="children"><div class="content">I put together a demo of this for work where I pulled all our private repos and built an index, then used datasette as the front end.<p>It was incredibly fast, so much so that I found it more useful than github search. The index is pretty out of date now but I still use it purely based on convenience and speed</div><br/></div></div></div></div><div id="36699992" class="c"><input type="checkbox" id="c-36699992" checked=""/><div class="controls bullet"><span class="by">rahkiin</span><span>|</span><a href="#36699946">parent</a><span>|</span><a href="#36700020">prev</a><span>|</span><a href="#36700820">next</a><span>|</span><label class="collapse" for="c-36699992">[-]</label><label class="expand" for="c-36699992">[1 more]</label></div><br/><div class="children"><div class="content">There is <a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;fts5.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.sqlite.org&#x2F;fts5.html</a> but I cannot deduce if it has the same features; the way of working is completely different</div><br/></div></div></div></div><div id="36700820" class="c"><input type="checkbox" id="c-36700820" checked=""/><div class="controls bullet"><span class="by">endisneigh</span><span>|</span><a href="#36699946">prev</a><span>|</span><label class="collapse" for="c-36700820">[-]</label><label class="expand" for="c-36700820">[6 more]</label></div><br/><div class="children"><div class="content">For something like this I&#x27;d use FoundationDB to store the entries redundantly and consistently with high availability and TypeSense for searching through the records and regenerating the index as necessary from FDB.</div><br/><div id="36700952" class="c"><input type="checkbox" id="c-36700952" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#36700820">parent</a><span>|</span><label class="collapse" for="c-36700952">[-]</label><label class="expand" for="c-36700952">[5 more]</label></div><br/><div class="children"><div class="content">Does Typesense work with external vector databases?</div><br/><div id="36701228" class="c"><input type="checkbox" id="c-36701228" checked=""/><div class="controls bullet"><span class="by">jabo</span><span>|</span><a href="#36700820">root</a><span>|</span><a href="#36700952">parent</a><span>|</span><label class="collapse" for="c-36701228">[-]</label><label class="expand" for="c-36701228">[4 more]</label></div><br/><div class="children"><div class="content">Typesense has a vector store &#x2F; search built-in: <a href="https:&#x2F;&#x2F;typesense.org&#x2F;docs&#x2F;0.24.1&#x2F;api&#x2F;vector-search.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;typesense.org&#x2F;docs&#x2F;0.24.1&#x2F;api&#x2F;vector-search.html</a><p>In the upcoming version, we&#x27;ve also added the ability to automatically generate embeddings from within Typesense either using OpenAI, PaLM API or a built-in model like s-bert or E5. So you only have to send json and pick a model, Typesense will then do a hybrid vector+keyword search for queries.</div><br/><div id="36702037" class="c"><input type="checkbox" id="c-36702037" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#36700820">root</a><span>|</span><a href="#36701228">parent</a><span>|</span><label class="collapse" for="c-36702037">[-]</label><label class="expand" for="c-36702037">[3 more]</label></div><br/><div class="children"><div class="content">I see you run hnswlib but do you (plan to) support external vector databases, so users can upgrade?</div><br/><div id="36702180" class="c"><input type="checkbox" id="c-36702180" checked=""/><div class="controls bullet"><span class="by">jabo</span><span>|</span><a href="#36700820">root</a><span>|</span><a href="#36702037">parent</a><span>|</span><label class="collapse" for="c-36702180">[-]</label><label class="expand" for="c-36702180">[2 more]</label></div><br/><div class="children"><div class="content">We don&#x27;t plan to support external vector databases, since we want to build Typesense as a vector + keyword search datastore by itself.</div><br/><div id="36702222" class="c"><input type="checkbox" id="c-36702222" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#36700820">root</a><span>|</span><a href="#36702180">parent</a><span>|</span><label class="collapse" for="c-36702222">[-]</label><label class="expand" for="c-36702222">[1 more]</label></div><br/><div class="children"><div class="content">I see. Do you plan to replace hnswlib with your own technology?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>