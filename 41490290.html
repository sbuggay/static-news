<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1725958871810" as="style"/><link rel="stylesheet" href="styles.css?v=1725958871810"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blogsystem5.substack.com/p/windows-nt-vs-unix-design">Windows NT vs. Unix: A design comparison</a> <span class="domain">(<a href="https://blogsystem5.substack.com">blogsystem5.substack.com</a>)</span></div><div class="subtext"><span>LorenDB</span> | <span>347 comments</span></div><br/><div><div id="41493177" class="c"><input type="checkbox" id="c-41493177" checked=""/><div class="controls bullet"><span class="by">runjake</span><span>|</span><a href="#41494789">next</a><span>|</span><label class="collapse" for="c-41493177">[-]</label><label class="expand" for="c-41493177">[105 more]</label></div><br/><div class="children"><div class="content">The NT kernel is pretty nifty, albeit an aging design.<p>My issue with Windows as an OS, is that there&#x27;s so much cruft, often adopted from Microsoft&#x27;s older OSes, stacked on top of the NT kernel effectively circumventing it&#x27;s design.<p>You frequently see examples of this in vulnerability write-ups: &quot;NT has mechanisms in place to secure $thing, but unfortunately, this upper level component effectively bypasses those protections&quot;.<p>I know Microsoft would like to, if they considered it &quot;possible&quot;, but they really need to move away from the Win32 and MS-DOS paradigms and rethink a more native OS design based solely on NT and evolving principles.</div><br/><div id="41494546" class="c"><input type="checkbox" id="c-41494546" checked=""/><div class="controls bullet"><span class="by">robotnikman</span><span>|</span><a href="#41493177">parent</a><span>|</span><a href="#41494610">next</a><span>|</span><label class="collapse" for="c-41494546">[-]</label><label class="expand" for="c-41494546">[40 more]</label></div><br/><div class="children"><div class="content">The backwards compatibility though is one of the major features of windows as an OS. That fact that a company can still load some software made 20 years ago developed by a company that is no longer in business is pretty cool (and I&#x27;ve worked at such places using ancient software on some windows box, sometimes there&#x27;s no time or money for alternatives)</div><br/><div id="41497921" class="c"><input type="checkbox" id="c-41497921" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41494546">parent</a><span>|</span><a href="#41494698">next</a><span>|</span><label class="collapse" for="c-41497921">[-]</label><label class="expand" for="c-41497921">[5 more]</label></div><br/><div class="children"><div class="content">If you look at more recent Windows APIs, I&#x27;m really thankful that the traditional Win32 APIs still work. On average the older APIs are much nicer to work with.</div><br/><div id="41498477" class="c"><input type="checkbox" id="c-41498477" checked=""/><div class="controls bullet"><span class="by">alt227</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41497921">parent</a><span>|</span><a href="#41498483">next</a><span>|</span><label class="collapse" for="c-41498477">[-]</label><label class="expand" for="c-41498477">[1 more]</label></div><br/><div class="children"><div class="content">&gt; On average the older APIs are much nicer to work with<p>IMO this is because they are better written, by people who had deeper understanding of the entire OS picture and cared more about writing performant and maintainable code.</div><br/></div></div><div id="41498483" class="c"><input type="checkbox" id="c-41498483" checked=""/><div class="controls bullet"><span class="by">bboygravity</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41497921">parent</a><span>|</span><a href="#41498477">prev</a><span>|</span><a href="#41494698">next</a><span>|</span><label class="collapse" for="c-41498483">[-]</label><label class="expand" for="c-41498483">[3 more]</label></div><br/><div class="children"><div class="content">Nicer to work with?<p>I can&#x27;t think of any worse API in the entire world?</div><br/><div id="41498735" class="c"><input type="checkbox" id="c-41498735" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41498483">parent</a><span>|</span><a href="#41498705">next</a><span>|</span><label class="collapse" for="c-41498735">[-]</label><label class="expand" for="c-41498735">[1 more]</label></div><br/><div class="children"><div class="content">There are some higher level COM APIs which are not exactly great, but the core Win32 DLL APIs (kernel32, user32, gdi32) are quite good, also the DirectX APIs after ca 2002 (e.g. since D3D9) - because even though the DirectX APIs are built on top of COM, they are doing it in a somewhat sane way.</div><br/></div></div><div id="41498705" class="c"><input type="checkbox" id="c-41498705" checked=""/><div class="controls bullet"><span class="by">sirwhinesalot</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41498483">parent</a><span>|</span><a href="#41498735">prev</a><span>|</span><a href="#41494698">next</a><span>|</span><label class="collapse" for="c-41498705">[-]</label><label class="expand" for="c-41498705">[1 more]</label></div><br/><div class="children"><div class="content">The various WinRT APIs are even worse. At least Win32 is &quot;battle tested&quot;</div><br/></div></div></div></div></div></div><div id="41494698" class="c"><input type="checkbox" id="c-41494698" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41494546">parent</a><span>|</span><a href="#41497921">prev</a><span>|</span><a href="#41498184">next</a><span>|</span><label class="collapse" for="c-41494698">[-]</label><label class="expand" for="c-41494698">[18 more]</label></div><br/><div class="children"><div class="content">That and it&#x27;s 30+ years (NT was released in 1993). Backwards compatibility is certainly one of the greatest business value Microsoft provides to its customers.</div><br/><div id="41495524" class="c"><input type="checkbox" id="c-41495524" checked=""/><div class="controls bullet"><span class="by">MarkSweep</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41494698">parent</a><span>|</span><a href="#41497256">next</a><span>|</span><label class="collapse" for="c-41495524">[-]</label><label class="expand" for="c-41495524">[8 more]</label></div><br/><div class="children"><div class="content">If you include the ability of 32-bit versions of Windows to run 16-but Windows and DOS applications with NTVDM, it is more like 40+ years.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Virtual_DOS_machine" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Virtual_DOS_machine</a><p>(Math on the 40 years: windows 1.0 was released in 1985, the last consumer version of Windows 10 (which is the last Windows NT version to support 32-bit install and thus NTVDM) goes out of support in 2025. DOS was first released in 1981, more than 40 years ago. I don’t know when it was released, but I’ve used a pretty old 16-bit DOS app on Windows 10: a C compiler for the Intel 80186)</div><br/><div id="41496674" class="c"><input type="checkbox" id="c-41496674" checked=""/><div class="controls bullet"><span class="by">winter_blue</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495524">parent</a><span>|</span><a href="#41496097">next</a><span>|</span><label class="collapse" for="c-41496674">[-]</label><label class="expand" for="c-41496674">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I’ve used a pretty old 16-bit DOS app on Windows 10: a C compiler for the Intel 80186<p>It’s amazing that stuff still runs on Windows 10. I’m guessing Windows 10 has a VM layer both for 32-bit and 16-bit Windows + DOS apps?</div><br/><div id="41497155" class="c"><input type="checkbox" id="c-41497155" checked=""/><div class="controls bullet"><span class="by">JonathonW</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41496674">parent</a><span>|</span><a href="#41497546">next</a><span>|</span><label class="collapse" for="c-41497155">[-]</label><label class="expand" for="c-41497155">[1 more]</label></div><br/><div class="children"><div class="content">Windows 10 only does 16-bit DOS and Windows apps on the 32-bit version of Windows 10, so it only has a VM layer for those 16-bit apps.  (On x86, NTVDM uses the processor&#x27;s virtual 8086 mode to do its thing; that doesn&#x27;t exist in 64-bit mode on x86-64 and MS didn&#x27;t build an emulator for x86-64 like they did for some other architectures back in the NT on Alpha&#x2F;PowerPC era, so no DOS or 16-bit Windows apps on 64-bit Windows at all.)</div><br/></div></div><div id="41497546" class="c"><input type="checkbox" id="c-41497546" checked=""/><div class="controls bullet"><span class="by">pajko</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41496674">parent</a><span>|</span><a href="#41497155">prev</a><span>|</span><a href="#41496097">next</a><span>|</span><label class="collapse" for="c-41497546">[-]</label><label class="expand" for="c-41497546">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;leecher1337&#x2F;ntvdmx64">https:&#x2F;&#x2F;github.com&#x2F;leecher1337&#x2F;ntvdmx64</a></div><br/></div></div></div></div><div id="41496097" class="c"><input type="checkbox" id="c-41496097" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495524">parent</a><span>|</span><a href="#41496674">prev</a><span>|</span><a href="#41497256">next</a><span>|</span><label class="collapse" for="c-41496097">[-]</label><label class="expand" for="c-41496097">[4 more]</label></div><br/><div class="children"><div class="content">True. I just assumed that 16-bit support got dropped since Windows 11 was 64-bit only.</div><br/><div id="41497306" class="c"><input type="checkbox" id="c-41497306" checked=""/><div class="controls bullet"><span class="by">EvanAnderson</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41496097">parent</a><span>|</span><a href="#41497256">next</a><span>|</span><label class="collapse" for="c-41497306">[-]</label><label class="expand" for="c-41497306">[3 more]</label></div><br/><div class="children"><div class="content">Microsoft decided not to type &quot;make&quot; for NTVDM on 64-bit versions of Windows (I would argue arbitrarily). It has been unofficially built for 64-bit versions of Windows as a proof-of-concept: <a href="https:&#x2F;&#x2F;github.com&#x2F;leecher1337&#x2F;ntvdmx64">https:&#x2F;&#x2F;github.com&#x2F;leecher1337&#x2F;ntvdmx64</a></div><br/><div id="41497843" class="c"><input type="checkbox" id="c-41497843" checked=""/><div class="controls bullet"><span class="by">badgersnake</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41497306">parent</a><span>|</span><a href="#41497256">next</a><span>|</span><label class="collapse" for="c-41497843">[-]</label><label class="expand" for="c-41497843">[2 more]</label></div><br/><div class="children"><div class="content">That’s okay, and if people want to test their specific use case on that and use it then great.<p>It’s a pretty different amount of effort to Microsoft having to do a full 16 bit regression suite and make everything work and then support it for the fewer and fewer customers using it. And you can run a 32 bit windows in a VM pretty easily if you really want to.</div><br/><div id="41498434" class="c"><input type="checkbox" id="c-41498434" checked=""/><div class="controls bullet"><span class="by">Timwi</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41497843">parent</a><span>|</span><a href="#41497256">next</a><span>|</span><label class="collapse" for="c-41498434">[-]</label><label class="expand" for="c-41498434">[1 more]</label></div><br/><div class="children"><div class="content">Or you can run 16-bit Windows 3.1 in DOSBox.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41497256" class="c"><input type="checkbox" id="c-41497256" checked=""/><div class="controls bullet"><span class="by">dartharva</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41494698">parent</a><span>|</span><a href="#41495524">prev</a><span>|</span><a href="#41495027">next</a><span>|</span><label class="collapse" for="c-41497256">[-]</label><label class="expand" for="c-41497256">[4 more]</label></div><br/><div class="children"><div class="content">But only to a degree, right? Only the last two decades of software is what the OS ideally needs to support, beyond that you can just use emulators.</div><br/><div id="41498305" class="c"><input type="checkbox" id="c-41498305" checked=""/><div class="controls bullet"><span class="by">da_chicken</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41497256">parent</a><span>|</span><a href="#41497592">next</a><span>|</span><label class="collapse" for="c-41498305">[-]</label><label class="expand" for="c-41498305">[1 more]</label></div><br/><div class="children"><div class="content">Pretty much the only 16-bit software that people commonly encounter is an old setup program.<p>For a very long time those were all 16-bit because they didn&#x27;t need the address space and they were typically smaller when compiled. This means that a lot of 32-bit software from the late 90s that would otherwise work fine is locked inside a 16-bit InstallShield box.</div><br/></div></div><div id="41497592" class="c"><input type="checkbox" id="c-41497592" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41497256">parent</a><span>|</span><a href="#41498305">prev</a><span>|</span><a href="#41497302">next</a><span>|</span><label class="collapse" for="c-41497592">[-]</label><label class="expand" for="c-41497592">[1 more]</label></div><br/><div class="children"><div class="content">Software is written against APIs, not years, so the problem with this sort of thinking is that software written -say- 10 years ago might still be using APIs from more than 20 years ago, so if you decide to break&#x2F;remove&#x2F;whatever the more-than-20-year-ago APIs you not only break the more-than-20-year-ago software but also the 10 year old software that used those APIs - as well as any other software, older or newer, that did the same.<p>(also i&#x27;m using &quot;API&quot; for convenience here, replace it with anything that can affect backwards compatibility)<p>EDIT: simple example in practice: WinExec was deprecated when Windows switched from 16bit to 32bit several decades ago, yet programs are still using it to this day.</div><br/></div></div><div id="41497302" class="c"><input type="checkbox" id="c-41497302" checked=""/><div class="controls bullet"><span class="by">NegativeLatency</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41497256">parent</a><span>|</span><a href="#41497592">prev</a><span>|</span><a href="#41495027">next</a><span>|</span><label class="collapse" for="c-41497302">[-]</label><label class="expand" for="c-41497302">[1 more]</label></div><br/><div class="children"><div class="content">Maybe, but your app could also be an interface to some super expensive scientific&#x2F;industrial equipment that does weird IO or something.</div><br/></div></div></div></div><div id="41495027" class="c"><input type="checkbox" id="c-41495027" checked=""/><div class="controls bullet"><span class="by">ozim</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41494698">parent</a><span>|</span><a href="#41497256">prev</a><span>|</span><a href="#41498184">next</a><span>|</span><label class="collapse" for="c-41495027">[-]</label><label class="expand" for="c-41495027">[5 more]</label></div><br/><div class="children"><div class="content">People tend to forget that it already is 2024.</div><br/><div id="41498147" class="c"><input type="checkbox" id="c-41498147" checked=""/><div class="controls bullet"><span class="by">ExoticPearTree</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495027">parent</a><span>|</span><a href="#41495580">next</a><span>|</span><label class="collapse" for="c-41498147">[-]</label><label class="expand" for="c-41498147">[1 more]</label></div><br/><div class="children"><div class="content">Not long ago, it was posted here a link to a job advert for the german railway looking for a Win 3.11 specialist.<p>As I see it, the problem is the laziness&#x2F;cheapness of companies when it comes to upgrades and vendor&#x27;s reluctance to get rid of dead stuff for fear of losing business.<p>APIs could be deprecated&#x2F;updated at set intervals, like Current -2&#x2F;-3 versions back and be done with it.</div><br/></div></div><div id="41495580" class="c"><input type="checkbox" id="c-41495580" checked=""/><div class="controls bullet"><span class="by">xattt</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495027">parent</a><span>|</span><a href="#41498147">prev</a><span>|</span><a href="#41498184">next</a><span>|</span><label class="collapse" for="c-41495580">[-]</label><label class="expand" for="c-41495580">[3 more]</label></div><br/><div class="children"><div class="content">Short of driver troubles at the jump from Win 9x to 2k&#x2F;XP, and the shedding of Win16 compatibility layers at the time of release of Win XP x64, backwards compatibility had always been baked into Windows. I don’t know if there was any loss of compatibility during the MS-DOS days either.<p>It’s just <i>expected</i> at this point.</div><br/><div id="41497844" class="c"><input type="checkbox" id="c-41497844" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495580">parent</a><span>|</span><a href="#41498184">next</a><span>|</span><label class="collapse" for="c-41497844">[-]</label><label class="expand" for="c-41497844">[2 more]</label></div><br/><div class="children"><div class="content">On DOS, if you borrow ReactOS&#x27; NTVDM under XP&#x2F;2003 and Maybe Vista&#x2F;7 under 32 bit (IDK about 64 bit binaries), you can run DOS games in a much better way than Windows&#x27; counterpart.</div><br/><div id="41497910" class="c"><input type="checkbox" id="c-41497910" checked=""/><div class="controls bullet"><span class="by">rasz</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41497844">parent</a><span>|</span><a href="#41498184">next</a><span>|</span><label class="collapse" for="c-41497910">[-]</label><label class="expand" for="c-41497910">[1 more]</label></div><br/><div class="children"><div class="content">Afaik due to POPF not trapping Reactos implemented NTVDM as a software emulator.<p><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20170723164052&#x2F;http:&#x2F;&#x2F;community.reactos.org&#x2F;index.php&#x2F;news&#x2F;years-progress-ntvdm-part-1" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20170723164052&#x2F;http:&#x2F;&#x2F;community....</a> <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20151216085857&#x2F;http:&#x2F;&#x2F;community.reactos.org&#x2F;index.php&#x2F;news&#x2F;years-progress-ntvdm-part-2" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20151216085857&#x2F;http:&#x2F;&#x2F;community....</a><p>At this point you might as well use DOSBOX.<p>Intel Protected Mode POPF fail:<p><a href="https:&#x2F;&#x2F;docs.oracle.com&#x2F;en&#x2F;virtualization&#x2F;virtualbox&#x2F;6.0&#x2F;admin&#x2F;swvirt-details.html" rel="nofollow">https:&#x2F;&#x2F;docs.oracle.com&#x2F;en&#x2F;virtualization&#x2F;virtualbox&#x2F;6.0&#x2F;adm...</a><p><a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20160411-00&#x2F;?p=93281" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20160411-00&#x2F;?p=93...</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="41498184" class="c"><input type="checkbox" id="c-41498184" checked=""/><div class="controls bullet"><span class="by">ksec</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41494546">parent</a><span>|</span><a href="#41494698">prev</a><span>|</span><a href="#41495004">next</a><span>|</span><label class="collapse" for="c-41498184">[-]</label><label class="expand" for="c-41498184">[3 more]</label></div><br/><div class="children"><div class="content">My question is why cant M$ ship the old OS running as VM. And free themselves from Backward compatibility on a newer OS.</div><br/><div id="41498235" class="c"><input type="checkbox" id="c-41498235" checked=""/><div class="controls bullet"><span class="by">galaxyLogic</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41498184">parent</a><span>|</span><a href="#41495004">next</a><span>|</span><label class="collapse" for="c-41498235">[-]</label><label class="expand" for="c-41498235">[2 more]</label></div><br/><div class="children"><div class="content">Users will want to  use applications that require features of the earlier OS version, and newer ones that require newer features. They don&#x27;t want to have to switch to using a VM because old apps would only run on that VM.</div><br/><div id="41498331" class="c"><input type="checkbox" id="c-41498331" checked=""/><div class="controls bullet"><span class="by">wongogue</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41498235">parent</a><span>|</span><a href="#41495004">next</a><span>|</span><label class="collapse" for="c-41498331">[-]</label><label class="expand" for="c-41498331">[1 more]</label></div><br/><div class="children"><div class="content">Putting apps from the VM on the primary desktop is something they have already done on WSLg. Launching Linux and X server is all taken care of when you click the app shortcut. Similar to the parent’s ask, WSL2&#x2F;WSLg is a lightweight VM running Linux.</div><br/></div></div></div></div></div></div><div id="41495004" class="c"><input type="checkbox" id="c-41495004" checked=""/><div class="controls bullet"><span class="by">runjake</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41494546">parent</a><span>|</span><a href="#41498184">prev</a><span>|</span><a href="#41497943">next</a><span>|</span><label class="collapse" for="c-41495004">[-]</label><label class="expand" for="c-41495004">[7 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  &gt; The backwards compatibility though is one of the major features of windows as an OS.
</code></pre>
It is. That&#x27;s even been stated by MSFT leadership time and time again.<p>But at what point does that become a liability?<p>I&#x27;m arguing that point was about 15-20 years ago.</div><br/><div id="41496976" class="c"><input type="checkbox" id="c-41496976" checked=""/><div class="controls bullet"><span class="by">efitz</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495004">parent</a><span>|</span><a href="#41497133">next</a><span>|</span><label class="collapse" for="c-41496976">[-]</label><label class="expand" for="c-41496976">[3 more]</label></div><br/><div class="children"><div class="content">There is another very active article on HN today about the launch of the new Apple iPhone 16 models.<p>The top discussion thread on that post is about “my old iPhone $version is good enough, why would I upgrade”.<p>It’s funny, if you ask tech people, a lot fall into the “I have to have the latest and greatest” but also a lot fall into the “I’ll upgrade when they pry the rusting hardware from my cold dead hands”.<p>For Microsoft, the driver for backwards compatibility is economic: Microsoft wants people to buy new Windows, but in order to do that, they have to (1) convince customers that all their existing stuff is going to continue to work, and (2) convince developers that they don’t have to rewrite (or even recompile) all their stuff whenever there’s a new version of Windows.<p>Objectively, it seems like Microsoft made the right decision, based on revenue over the decades.<p>Full disclosure: I worked for Microsoft for 17 years, mostly in and around Windows, but left over a decade ago.</div><br/><div id="41498272" class="c"><input type="checkbox" id="c-41498272" checked=""/><div class="controls bullet"><span class="by">ruthmarx</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41496976">parent</a><span>|</span><a href="#41497133">next</a><span>|</span><label class="collapse" for="c-41498272">[-]</label><label class="expand" for="c-41498272">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It’s funny, if you ask tech people, a lot fall into the “I have to have the latest and greatest”<p>This is almost never a technical decision, but a &#x27;showing off&#x27; decision IMO.</div><br/><div id="41498678" class="c"><input type="checkbox" id="c-41498678" checked=""/><div class="controls bullet"><span class="by">HPsquared</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41498272">parent</a><span>|</span><a href="#41497133">next</a><span>|</span><label class="collapse" for="c-41498678">[-]</label><label class="expand" for="c-41498678">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a &quot;fun toys&quot; decision.</div><br/></div></div></div></div></div></div><div id="41497133" class="c"><input type="checkbox" id="c-41497133" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495004">parent</a><span>|</span><a href="#41496976">prev</a><span>|</span><a href="#41495328">next</a><span>|</span><label class="collapse" for="c-41497133">[-]</label><label class="expand" for="c-41497133">[1 more]</label></div><br/><div class="children"><div class="content">It is not a liability because most of what you are talking about is just <i>compatibility</i> not <i>backwards compatibility</i>.  What makes an operating system Windows?  Fundamentally it is something that runs Windows apps.  Windows apps existed 15-20 years ago as much as they exist today.  If you make an OS that doesn&#x27;t run Windows apps then it just isn&#x27;t Windows anymore.<p>The little weird things that exist due to backwards compatibility really don&#x27;t matter.  They&#x27;re not harming anything.</div><br/></div></div><div id="41495328" class="c"><input type="checkbox" id="c-41495328" checked=""/><div class="controls bullet"><span class="by">dgfitz</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495004">parent</a><span>|</span><a href="#41497133">prev</a><span>|</span><a href="#41497943">next</a><span>|</span><label class="collapse" for="c-41495328">[-]</label><label class="expand" for="c-41495328">[2 more]</label></div><br/><div class="children"><div class="content">New frameworks have vulnerabilities. Old OS flavors have vulnerabilities. OpenSSh keeps making the news for vulnerabilities.<p>I’d argue that software is never finished, only abandoned, and I absolutely did not generate that quote.<p>Stop. Just stop.</div><br/><div id="41497857" class="c"><input type="checkbox" id="c-41497857" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495328">parent</a><span>|</span><a href="#41497943">next</a><span>|</span><label class="collapse" for="c-41497857">[-]</label><label class="expand" for="c-41497857">[1 more]</label></div><br/><div class="children"><div class="content">&gt;OpenSSH<p>Yes, just stop... with the bullshit. OpenBSD didn&#x27;t make vulnerabilities. <i>Foreign</i> Linux distros (OpenSSH comes from OpenBSD, and they release a portable tgz too) adding non-core features and libraries did.</div><br/></div></div></div></div></div></div><div id="41497943" class="c"><input type="checkbox" id="c-41497943" checked=""/><div class="controls bullet"><span class="by">tippytippytango</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41494546">parent</a><span>|</span><a href="#41495004">prev</a><span>|</span><a href="#41495353">next</a><span>|</span><label class="collapse" for="c-41497943">[-]</label><label class="expand" for="c-41497943">[1 more]</label></div><br/><div class="children"><div class="content">If 20 years is so ancient, why did they go by so fast....</div><br/></div></div><div id="41495353" class="c"><input type="checkbox" id="c-41495353" checked=""/><div class="controls bullet"><span class="by">johannes1234321</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41494546">parent</a><span>|</span><a href="#41497943">prev</a><span>|</span><a href="#41496386">next</a><span>|</span><label class="collapse" for="c-41495353">[-]</label><label class="expand" for="c-41495353">[4 more]</label></div><br/><div class="children"><div class="content">It is a great achievement. But the question is: Is it really relevant? Couldn&#x27;t they move the compatibility for larger parts to a VM or other independent Subsystem?<p>Of course even that isn&#x27;t trivial, as one wants to share filesystem access (while I can imagine some overlay limiting access), might need COM and access to devices ... but I would assume they could push that a lot more actively. If they decided which GUI framework to focus on.</div><br/><div id="41495614" class="c"><input type="checkbox" id="c-41495614" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495353">parent</a><span>|</span><a href="#41497845">next</a><span>|</span><label class="collapse" for="c-41495614">[-]</label><label class="expand" for="c-41495614">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Couldn&#x27;t they move the compatibility for larger parts to a VM or other independent Subsystem?<p>A huge amount of the compatibility stuff is already moved out into separate code that isn&#x27;t loaded unless needed.<p>The problem too, though, is users don&#x27;t want independent subsystems -- they want their OS to operate as a singular environment.  Raymond Chen has mentioned this a few times on his blog when this sort of thing comes up.<p>Backwards compatibility also really isn&#x27;t the issue that people seem to think it is.</div><br/></div></div><div id="41497845" class="c"><input type="checkbox" id="c-41497845" checked=""/><div class="controls bullet"><span class="by">nitwit005</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495353">parent</a><span>|</span><a href="#41495614">prev</a><span>|</span><a href="#41495507">next</a><span>|</span><label class="collapse" for="c-41497845">[-]</label><label class="expand" for="c-41497845">[1 more]</label></div><br/><div class="children"><div class="content">Generally speaking, the waste is only hard disk space. If no one ever loads some old DLL, it just sits there.</div><br/></div></div><div id="41495507" class="c"><input type="checkbox" id="c-41495507" checked=""/><div class="controls bullet"><span class="by">486sx33</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495353">parent</a><span>|</span><a href="#41497845">prev</a><span>|</span><a href="#41496386">next</a><span>|</span><label class="collapse" for="c-41495507">[-]</label><label class="expand" for="c-41495507">[1 more]</label></div><br/><div class="children"><div class="content">I think that VM software like Parallels has shown us that we are just now at the point where VMs can handle it all and feel native. Certainly NT could use a re write to eliminate all the legacy stuff…but instead they focus on copilot and nagging me not to leave windows edge internet explorer</div><br/></div></div></div></div><div id="41496386" class="c"><input type="checkbox" id="c-41496386" checked=""/><div class="controls bullet"><span class="by">hnfong</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41494546">parent</a><span>|</span><a href="#41495353">prev</a><span>|</span><a href="#41494610">next</a><span>|</span><label class="collapse" for="c-41496386">[-]</label><label class="expand" for="c-41496386">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s possible that wine is more &quot;backwards compatible&quot; than the latest version of Windows though.<p>And while wine doesn&#x27;t run everything, at least it doesn&#x27;t circumvent security measures put in place by the OS...</div><br/></div></div></div></div><div id="41494610" class="c"><input type="checkbox" id="c-41494610" checked=""/><div class="controls bullet"><span class="by">phendrenad2</span><span>|</span><a href="#41493177">parent</a><span>|</span><a href="#41494546">prev</a><span>|</span><a href="#41495162">next</a><span>|</span><label class="collapse" for="c-41494610">[-]</label><label class="expand" for="c-41494610">[11 more]</label></div><br/><div class="children"><div class="content">&gt; an aging design<p>What does that mean, exactly? Linux is also an &quot;aging design&quot;, unless I missed a big announcement where they redesigned it at any point since 1994.</div><br/><div id="41495049" class="c"><input type="checkbox" id="c-41495049" checked=""/><div class="controls bullet"><span class="by">runjake</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41494610">parent</a><span>|</span><a href="#41495753">next</a><span>|</span><label class="collapse" for="c-41495049">[-]</label><label class="expand" for="c-41495049">[2 more]</label></div><br/><div class="children"><div class="content">That was in response to the beginning of the article:<p>&quot;I’ve repeatedly heard that Windows NT is a very advanced operating system&quot;<p>It&#x27;s <i>very advanced</i> for decades ago. It&#x27;s not meant as an insult.<p>About 20 years ago, despite being a Linux&#x2F;UNIX&#x2F;BSD diehard, I went through the entire Inside Windows NT book word by word and took up low-level NT programming and gained a deep respect for it and Dave Cutler. Also a h&#x2F;t to Russinovich who despite having better things to do running Winternals Software[1], would always patiently answer all my questions.<p>1. <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sysinternals" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sysinternals</a></div><br/></div></div><div id="41495753" class="c"><input type="checkbox" id="c-41495753" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41494610">parent</a><span>|</span><a href="#41495049">prev</a><span>|</span><a href="#41495921">next</a><span>|</span><label class="collapse" for="c-41495753">[-]</label><label class="expand" for="c-41495753">[1 more]</label></div><br/><div class="children"><div class="content">Linux actually did have some pretty significant redesigns with some notable breaking changes. It wasn&#x27;t until the 2.4 line ended in the late oughts that Linux as we know it today came fully into existence.</div><br/></div></div><div id="41495921" class="c"><input type="checkbox" id="c-41495921" checked=""/><div class="controls bullet"><span class="by">ofrzeta</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41494610">parent</a><span>|</span><a href="#41495753">prev</a><span>|</span><a href="#41494773">next</a><span>|</span><label class="collapse" for="c-41495921">[-]</label><label class="expand" for="c-41495921">[2 more]</label></div><br/><div class="children"><div class="content">FWIW Linux got support for kernel modules in January 1995.</div><br/><div id="41496827" class="c"><input type="checkbox" id="c-41496827" checked=""/><div class="controls bullet"><span class="by">IgorPartola</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495921">parent</a><span>|</span><a href="#41494773">next</a><span>|</span><label class="collapse" for="c-41496827">[-]</label><label class="expand" for="c-41496827">[1 more]</label></div><br/><div class="children"><div class="content">Yeah this was one thing I spotted as well. The author seems to confuse the fact that the norm for Unix&#x2F;Linux is that the OS should have the drivers whereas MS assumes the manufacturer should provide it with the capability to have this.<p>It also entirely overlooks how the system that allows a user with know specialized knowledge to authorize random code to run in a privileged environment which led to vulnerabilities that had their own vulnerabilities.</div><br/></div></div></div></div><div id="41494773" class="c"><input type="checkbox" id="c-41494773" checked=""/><div class="controls bullet"><span class="by">HPsquared</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41494610">parent</a><span>|</span><a href="#41495921">prev</a><span>|</span><a href="#41495162">next</a><span>|</span><label class="collapse" for="c-41494773">[-]</label><label class="expand" for="c-41494773">[5 more]</label></div><br/><div class="children"><div class="content">cf Terry Davis saying &quot;Linux wants to be a 1970s mainframe&quot;.</div><br/><div id="41497122" class="c"><input type="checkbox" id="c-41497122" checked=""/><div class="controls bullet"><span class="by">jonathaneunice</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41494773">parent</a><span>|</span><a href="#41498498">next</a><span>|</span><label class="collapse" for="c-41497122">[-]</label><label class="expand" for="c-41497122">[2 more]</label></div><br/><div class="children"><div class="content">Every new system wants to be a mainframe when it grows up. VMS, Unix, Linux, NT...they all started &quot;small&quot; and gradually added the capabilities and approaches of the Bigger Iron that came before them.<p>Call that the mainframe--though it too has been evolving all along and is a much more moving target than the caricatures suggest. Clustering, partitions, cryptographic offload, new Web and Linux and data analytics execution environments, most recently data streaming and AI--many new use modes have been added since the 60s and 70s inception.</div><br/><div id="41498231" class="c"><input type="checkbox" id="c-41498231" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41497122">parent</a><span>|</span><a href="#41498498">next</a><span>|</span><label class="collapse" for="c-41498231">[-]</label><label class="expand" for="c-41498231">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Every new system wants to be a mainframe when it grows up. VMS, Unix, Linux, NT...they all started &quot;small&quot; and gradually added the capabilities and approaches of the Bigger Iron that came before them<p>MacOS started on desktop, moved from there to smartphones and from there to smartwatches. Linux also moved ‘down’ quite a bit. NT has an embedded variant, too (<a href="https:&#x2F;&#x2F;betawiki.net&#x2F;wiki&#x2F;Windows_NT_Embedded_4.0" rel="nofollow">https:&#x2F;&#x2F;betawiki.net&#x2F;wiki&#x2F;Windows_NT_Embedded_4.0</a>, <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Windows_XP_editions#Windows_XP_Embedded" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Windows_XP_editions#Windows_XP...</a>, <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Windows_IoT" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Windows_IoT</a>).</div><br/></div></div></div></div><div id="41498498" class="c"><input type="checkbox" id="c-41498498" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41494773">parent</a><span>|</span><a href="#41497122">prev</a><span>|</span><a href="#41496546">next</a><span>|</span><label class="collapse" for="c-41498498">[-]</label><label class="expand" for="c-41498498">[1 more]</label></div><br/><div class="children"><div class="content">Every modern OS wants to be that, even iOS, at least internally.</div><br/></div></div><div id="41496546" class="c"><input type="checkbox" id="c-41496546" checked=""/><div class="controls bullet"><span class="by">beeflet</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41494773">parent</a><span>|</span><a href="#41498498">prev</a><span>|</span><a href="#41495162">next</a><span>|</span><label class="collapse" for="c-41496546">[-]</label><label class="expand" for="c-41496546">[1 more]</label></div><br/><div class="children"><div class="content">TD had some interesting ideas when it came to simplifying the system, but I think the average person wants something inbetween a mainframe and a microcomputer.<p>In linux&#x2F;unix there is too much focus on the &quot;multiuser&quot; and &quot;timesharing&quot; aspect of the system, when in the modern day you generally have one user with a ton of daemons so you forced to run daemons as their own users and then have some sort of init system to wrangle them all. A lot of the unixisms are not as elegant as they should be (see plan9, gobolinux, etc).<p>TempleOS is more like a commodore 64 environment than an OS: there&#x27;s not really any sort of timesharing going on and the threading is managed manually by userspace programs. One thing I like is that the shell language is the same as the general programming language (HolyC).</div><br/></div></div></div></div></div></div><div id="41495162" class="c"><input type="checkbox" id="c-41495162" checked=""/><div class="controls bullet"><span class="by">apatheticonion</span><span>|</span><a href="#41493177">parent</a><span>|</span><a href="#41494610">prev</a><span>|</span><a href="#41497974">next</a><span>|</span><label class="collapse" for="c-41495162">[-]</label><label class="expand" for="c-41495162">[27 more]</label></div><br/><div class="children"><div class="content">My understanding is that the portion of revenue Microsoft makes from Windows these days is nearly negligible (under 10%). Both XBox and Office individually make more money for Microsoft than Windows, which indicates that they don&#x27;t have a compelling incentive to improve it technically. This would explain their infatuation with value extraction initiatives like ads in Explorer and Recall.<p>My understanding is that the main thing keeping Windows relevant is the support for legacy software, so they&#x27;d be hesitant to jeopardize that with any bold changes to the kernel or system APIs.<p>That said. Given my imagined cost of maintaining a kernel plus my small, idiolistic, naive world view; I&#x27;d love if it Microsoft simply abandoned NT and threw their weight behind the Linux kernel (or if GNU is too restrictive, BSD or alternatively write their own POSIX compliant kernel like MacOS).<p>Linux would be ideal given its features; containers, support for Android apps without emulation, abundance of supported devices, helpful system capabilities like UNIX sockets (I know they started to made progress there but they abandoned further development), and support for things like ROCm (which only works on Linux right now).<p>Microsoft could build Windows on top of that POSIX kernel and provide a compatibility layer for NT calls and Win32 APIs. I don&#x27;t even care if it&#x27;s open source.<p>The biggest value for me is development capabilities (my day job is writing a performance sensitive application that needs to run cross-platform and Windows is a constant thorn in my side).<p>Cygwin, msys2&#x2F;git-bash are all fantastic but they are no replacement for the kind of development experience you get on Linux &amp; MacOS.<p>WSL1 was a great start and gave me hope, but is now abandonware.<p>WSL2 is a joke, if I wanted to run Linux in a VM, I&#x27;d run Linux in a VM.<p>I guess a less extreme option would be for Microsoft to extend NT to be POSIX compliant - If I could target unix syscalls during development and produce binaries that worked on Windows, I supposed I&#x27;d be happy with that.</div><br/><div id="41495313" class="c"><input type="checkbox" id="c-41495313" checked=""/><div class="controls bullet"><span class="by">delta_p_delta_x</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495162">parent</a><span>|</span><a href="#41498351">next</a><span>|</span><label class="collapse" for="c-41495313">[-]</label><label class="expand" for="c-41495313">[14 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;d love if it Microsoft simply abandoned NT and threw their weight behind the Linux kernel<p>I don&#x27;t understand why people keep repeating this wish, rather than the arguably better, more competitive option: <i>open-source the NT and Windows codebase</i>, prepare an &#x27;OpenWindows&#x27; (nice pun there, really) release, and simultaneously support enterprise customers with paid support licences, like places like Red Hat currently do.<p>&gt; Cygwin, msys2&#x2F;git-bash are all fantastic but they are no replacement for the kind of development experience you get on Linux &amp; MacOS.<p>I couldn&#x27;t disagree more. As someone who comes from a mostly-Windows pedigree, UNIX is... pretty backwards, and I look upon any attempt to shoehorn UNIX-on-Windows with a fair bit of disapproval, even if I concede that their individual developers and maintainers have done a decent job. Visual Studio (not Code) is a massively superior development and debugging tool to anything that the Unix crowd have cooked up (gdb? perf? Tell me when you can get flame graphs in <i>one</i> click).</div><br/><div id="41495892" class="c"><input type="checkbox" id="c-41495892" checked=""/><div class="controls bullet"><span class="by">apatheticonion</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495313">parent</a><span>|</span><a href="#41497728">next</a><span>|</span><label class="collapse" for="c-41495892">[-]</label><label class="expand" for="c-41495892">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s an interesting idea. Some thoughts come to mind:<p>- The relatively low revenue of Windows for Microsoft means that they have the potential opportunity of increasing Windows profitability by dropping the engineering costs associated with NT (though on the flipside, they&#x27;d acquire the engineering cost of developing Linux).<p>- Open sourcing NT would likely see a majority of it ported into Linux compatibility layers which would enable competitors (not that this is bad for us as consumers, it&#x27;s just not good for business)<p>- Adopting the Linux kernel and writing a closed source NT compatibility layer, init system, and closed source desktop environment means that the &quot;desktop&quot; and Microsoft aspects of the OS could be retained as private IP - which is the part that they could charge for. I know I&#x27;d certainly pay for a Linux distribution that has a well made DE.<p>&gt; UNIX is... pretty backwards,<p>I honestly agree. Many of the APIs show their age and, in the age of high level languages, it&#x27;s frustrating to read C docs to understand function signatures&#x2F;semantics. It&#x27;s certainly not ergonomic - though that&#x27;s not to say there isn&#x27;t room to innovate here.<p>Ultimately, I value sameness. Aside from ergonomics, NT doesn&#x27;t offer _more_ than POSIX and language bindings take care of the ergonomics issues with unix, so in many ways I&#x27;d argue that NT offers less.<p>&gt; Visual Studio (not Code) is a massively superior development and debugging too [...] Tell me when you can get flame graphs in one click<p>Just because the tooling isn&#x27;t as nice to use now doesn&#x27;t mean that Microsoft couldn&#x27;t make it better (and charge for that) if they adopted Linux. This isn&#x27;t something entirely contingent on the kernel.</div><br/><div id="41496054" class="c"><input type="checkbox" id="c-41496054" checked=""/><div class="controls bullet"><span class="by">delta_p_delta_x</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495892">parent</a><span>|</span><a href="#41497728">next</a><span>|</span><label class="collapse" for="c-41496054">[-]</label><label class="expand" for="c-41496054">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see why everything has to be Linux (which I will continue to maintain has neither the better kernel- nor user-mode).<p>Windows and NT have their own strengths as detailed in the very article that this thread links to. When open-sourced they could develop entirely independently, and it is good to have reasonable competition. Porting NT and the Windows shell to the Linux kernel for porting&#x27;s sake could easily take <i>years</i>, which is wasted time and effort on satisfying someone&#x27;s not-invented-here syndrome. It will mean throwing away 30+ years of hardware and software backward compatibility just to satisfy an imperfect and impractical ideal.<p>For perspective: something like WINE <i>still</i> can&#x27;t run many Office programs. The vast majority of its development in recent years has been focused on getting video games to work by porting Direct3D to Vulkan (which is comparatively straightforward because most GPUs have only a single device API that both graphics APIs expose, and also given the fact that both D3D and Vulkan shader code compile to SPIR-V). Office programs are the bread and butter of Windows users. The OpenOffice equivalents are barely shadows of MS Office. To be sure, they&#x27;re admirable efforts, but that only gets the developers pats on the back.</div><br/></div></div></div></div><div id="41497728" class="c"><input type="checkbox" id="c-41497728" checked=""/><div class="controls bullet"><span class="by">dajtxx</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495313">parent</a><span>|</span><a href="#41495892">prev</a><span>|</span><a href="#41495532">next</a><span>|</span><label class="collapse" for="c-41497728">[-]</label><label class="expand" for="c-41497728">[2 more]</label></div><br/><div class="children"><div class="content">I can imagine the effort of open source Windows would be prohibitive.<p>Having to go through every source file to ensure there is nothing to cause offense in there; there may be licensed things they&#x27;d have to remove; optionally make it buildable outside of their own environment...<p>Or there may be just plain embarrassing code in there they don&#x27;t feel the need to let outsiders see, and they don&#x27;t want to spend the time to check. But you can be sure a very small group of nerds will be waiting to go through it and shout about some crappy thing they found.</div><br/><div id="41498129" class="c"><input type="checkbox" id="c-41498129" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41497728">parent</a><span>|</span><a href="#41495532">next</a><span>|</span><label class="collapse" for="c-41498129">[-]</label><label class="expand" for="c-41498129">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d venture that even more nerds would go through it and fix their specific problems.<p>It&#x27;s always been quite clear that FOSS projects that have sufficient traction are the pinnicle of getting something polished. No matter how architecturally flawed or no matter how bad the design is: many eyes seem to make light work of all edge cases over time.<p>On the other hand, FOSS projects tend to lack the might of a large business to hit a particular business case or criticality, at least in the short term.<p>Open sourcing is probably impossible for the same reasons open sourcing Solaris was really difficult. The issues that were affecting solaris affect Windows at least two orders of magnitude harder.<p>It&#x27;s the smart play, though they&#x27;d lose huge revenues from Servers that are locked in... but otherwise, Windows is a dying operating system, it&#x27;s not the captive audience it once was as many people are moving to web-apps, games are slowly leaving the platform and it&#x27;s hanging on mostly due to inertia. The user hostile moves are not helping to slow the decline either.</div><br/></div></div></div></div><div id="41495532" class="c"><input type="checkbox" id="c-41495532" checked=""/><div class="controls bullet"><span class="by">EvanAnderson</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495313">parent</a><span>|</span><a href="#41497728">prev</a><span>|</span><a href="#41495407">next</a><span>|</span><label class="collapse" for="c-41495532">[-]</label><label class="expand" for="c-41495532">[2 more]</label></div><br/><div class="children"><div class="content">I have a fever dream vision of a &quot;distribution&quot; of an open source NT running in text mode with a resurrected Interix. Service Control Manager instead of systemd, NTFS (with ACLs and compression and encryption!), the registry, compatibility with scads of hardware drivers. It would be so much fun!</div><br/><div id="41498392" class="c"><input type="checkbox" id="c-41498392" checked=""/><div class="controls bullet"><span class="by">ruthmarx</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495532">parent</a><span>|</span><a href="#41495407">next</a><span>|</span><label class="collapse" for="c-41498392">[-]</label><label class="expand" for="c-41498392">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t ReactOS close enough?</div><br/></div></div></div></div><div id="41495407" class="c"><input type="checkbox" id="c-41495407" checked=""/><div class="controls bullet"><span class="by">cherryteastain</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495313">parent</a><span>|</span><a href="#41495532">prev</a><span>|</span><a href="#41495947">next</a><span>|</span><label class="collapse" for="c-41495407">[-]</label><label class="expand" for="c-41495407">[3 more]</label></div><br/><div class="children"><div class="content">&gt; open-source the NT and Windows codebase<p>May be very difficult or impossible if the Windows codebase has third-party IP (e.g. for hardware compatibility) with restrictive licensing</div><br/><div id="41495960" class="c"><input type="checkbox" id="c-41495960" checked=""/><div class="controls bullet"><span class="by">jen20</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495407">parent</a><span>|</span><a href="#41495947">next</a><span>|</span><label class="collapse" for="c-41495960">[-]</label><label class="expand" for="c-41495960">[2 more]</label></div><br/><div class="children"><div class="content">Sun managed it with Solaris (before Oracle undid that work) - indeed they had to create a license which didn&#x27;t cause problems with the third party components (the CDDL).</div><br/><div id="41498300" class="c"><input type="checkbox" id="c-41498300" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495960">parent</a><span>|</span><a href="#41495947">next</a><span>|</span><label class="collapse" for="c-41498300">[-]</label><label class="expand" for="c-41498300">[1 more]</label></div><br/><div class="children"><div class="content">The license happened less about third party components (GPLv2 would have worked for that, too, even if it&#x27;s less understood area), but because GPLv3 was late, Sun wanted patent clause in license, and AFAIK engineers rebelled against licensing that would have prevented BSDs (or other) from using the code.<p>(For those who still believe &quot;CDDL was designed to be incompatible with GPL&quot;, the same issues show up when trying to mix GPLv2 and GPLv3 code if you can&#x27;t relicense the former to v3)</div><br/></div></div></div></div></div></div><div id="41495947" class="c"><input type="checkbox" id="c-41495947" checked=""/><div class="controls bullet"><span class="by">jen20</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495313">parent</a><span>|</span><a href="#41495407">prev</a><span>|</span><a href="#41496162">next</a><span>|</span><label class="collapse" for="c-41495947">[-]</label><label class="expand" for="c-41495947">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Visual Studio (not Code) is a massively superior development and debugging tool to anything that the Unix crowd have cooked up (gdb? perf? Tell me when you can get flame graphs in one click).<p>Hard disagree on the development aspect of VS, which (last time I used it, in 2015) couldn&#x27;t even keep up with my fairly slow typing speed.<p>The debugging tools are excellent, but they are certainly not any more excellent than those in Instruments on macOS (which is largely backed by DTrace).</div><br/><div id="41498567" class="c"><input type="checkbox" id="c-41498567" checked=""/><div class="controls bullet"><span class="by">Timwi</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495947">parent</a><span>|</span><a href="#41496026">next</a><span>|</span><label class="collapse" for="c-41498567">[-]</label><label class="expand" for="c-41498567">[1 more]</label></div><br/><div class="children"><div class="content">2015 is 9 years ago. We shouldn&#x27;t keep comparing Windows&#x2F;Microsoft software from that long ago with modern alternatives on Linux and Mac.<p>That said, I agree that Visual Studio was extremely slow and clunky in the first half of the 2010s.</div><br/></div></div><div id="41496026" class="c"><input type="checkbox" id="c-41496026" checked=""/><div class="controls bullet"><span class="by">pathartl</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495947">parent</a><span>|</span><a href="#41498567">prev</a><span>|</span><a href="#41496162">next</a><span>|</span><label class="collapse" for="c-41496026">[-]</label><label class="expand" for="c-41496026">[1 more]</label></div><br/><div class="children"><div class="content">VS2022 is actually pretty damn slick. I use it on the daily and it&#x27;s much more stable than any previous version. It&#x27;s still not as fast as a text editor (I _do_ miss Sublime&#x27;s efficiency), but even going back to 2019 is extremely hard.</div><br/></div></div></div></div><div id="41496162" class="c"><input type="checkbox" id="c-41496162" checked=""/><div class="controls bullet"><span class="by">juunpp</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495313">parent</a><span>|</span><a href="#41495947">prev</a><span>|</span><a href="#41498351">next</a><span>|</span><label class="collapse" for="c-41496162">[-]</label><label class="expand" for="c-41496162">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Visual Studio (not Code) is a massively superior development and debugging tool to anything that the Unix crowd have cooked up (gdb? perf?)<p>VS is dogshit full of bloat and a UI that takes a PhD to navigate. CLion and QTCreator embed gdb&#x2F;lldb and do the debugging just fine. perf also gets you more system metrics than Visual Studio does; the click vs CLI workflow is mostly just workflow preference. But if you&#x27;re going to do a UI, at least don&#x27;t do it the way VS does.</div><br/></div></div></div></div><div id="41498351" class="c"><input type="checkbox" id="c-41498351" checked=""/><div class="controls bullet"><span class="by">ruthmarx</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495162">parent</a><span>|</span><a href="#41495313">prev</a><span>|</span><a href="#41496657">next</a><span>|</span><label class="collapse" for="c-41498351">[-]</label><label class="expand" for="c-41498351">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;d love if it Microsoft simply abandoned NT and threw their weight behind the Linux kernel<p>Oh hell no!<p>Diversity in operating systems is important, and the NT architecture has several advantages over the Linux approach. I definitely don&#x27;t want just one kernel reigning supreme, not yet at least - although that is probably inevitable.</div><br/></div></div><div id="41496657" class="c"><input type="checkbox" id="c-41496657" checked=""/><div class="controls bullet"><span class="by">SideQuark</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495162">parent</a><span>|</span><a href="#41498351">prev</a><span>|</span><a href="#41495281">next</a><span>|</span><label class="collapse" for="c-41496657">[-]</label><label class="expand" for="c-41496657">[1 more]</label></div><br/><div class="children"><div class="content">20+B annually is not “nearly negligible.” That’s more revenue than all but 3 other software companies: oracle 46B, SAP $33B, and salesforce 430B. It’s more annual revenue than Adobe and every other software company.</div><br/></div></div><div id="41495281" class="c"><input type="checkbox" id="c-41495281" checked=""/><div class="controls bullet"><span class="by">EvanAnderson</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495162">parent</a><span>|</span><a href="#41496657">prev</a><span>|</span><a href="#41498134">next</a><span>|</span><label class="collapse" for="c-41495281">[-]</label><label class="expand" for="c-41495281">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I guess a less extreme option would be for Microsoft to extend NT to be POSIX compliant...<p>Microsoft had this and abandoned it. I was building GNU software on NT in 2000 under Interix. It became Services for Unix and then was finally abandoned.</div><br/></div></div><div id="41498134" class="c"><input type="checkbox" id="c-41498134" checked=""/><div class="controls bullet"><span class="by">PeterStuer</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495162">parent</a><span>|</span><a href="#41495281">prev</a><span>|</span><a href="#41498109">next</a><span>|</span><label class="collapse" for="c-41498134">[-]</label><label class="expand" for="c-41498134">[1 more]</label></div><br/><div class="children"><div class="content">&quot;I guess a less extreme option would be for Microsoft to extend NT to be POSIX compliant&quot;<p>Their was a time MS sales posted NT to be more POSIX compatible than UNIXes.</div><br/></div></div><div id="41498109" class="c"><input type="checkbox" id="c-41498109" checked=""/><div class="controls bullet"><span class="by">PeterStuer</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495162">parent</a><span>|</span><a href="#41498134">prev</a><span>|</span><a href="#41498495">next</a><span>|</span><label class="collapse" for="c-41498109">[-]</label><label class="expand" for="c-41498109">[3 more]</label></div><br/><div class="children"><div class="content">In Microsoft&#x27;s perfect world your local machines would just be lightweight terminals to their Azure mainframe.</div><br/><div id="41498521" class="c"><input type="checkbox" id="c-41498521" checked=""/><div class="controls bullet"><span class="by">alt227</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41498109">parent</a><span>|</span><a href="#41498495">next</a><span>|</span><label class="collapse" for="c-41498521">[-]</label><label class="expand" for="c-41498521">[2 more]</label></div><br/><div class="children"><div class="content">This is coming. IMO in 20 years this will be how all devices, including phones, work.</div><br/><div id="41498728" class="c"><input type="checkbox" id="c-41498728" checked=""/><div class="controls bullet"><span class="by">alternatex</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41498521">parent</a><span>|</span><a href="#41498495">next</a><span>|</span><label class="collapse" for="c-41498728">[-]</label><label class="expand" for="c-41498728">[1 more]</label></div><br/><div class="children"><div class="content">Without massive (exponential) battery&#x2F;efficiency improvements it won&#x27;t happen. Networking isn&#x27;t something you can magically wave away. It has a cost.</div><br/></div></div></div></div></div></div><div id="41498495" class="c"><input type="checkbox" id="c-41498495" checked=""/><div class="controls bullet"><span class="by">7bit</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495162">parent</a><span>|</span><a href="#41498109">prev</a><span>|</span><a href="#41496458">next</a><span>|</span><label class="collapse" for="c-41498495">[-]</label><label class="expand" for="c-41498495">[1 more]</label></div><br/><div class="children"><div class="content">&gt; My understanding is that the main thing keeping Windows relevant is the support for legacy software, so they&#x27;d be hesitant to jeopardize that with any bold changes to the kernel or system APIs.<p>Without Windows, there would be no platform to sell office (macOS aside). That as a side note.<p>The important piece you are missing is this: The entirety of Azure runs on an optimized Variant of Hyper-V, hence all of Azure runs on Windows. That is SUBSTANTIAL!</div><br/></div></div><div id="41496458" class="c"><input type="checkbox" id="c-41496458" checked=""/><div class="controls bullet"><span class="by">shiroiushi</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495162">parent</a><span>|</span><a href="#41498495">prev</a><span>|</span><a href="#41495517">next</a><span>|</span><label class="collapse" for="c-41496458">[-]</label><label class="expand" for="c-41496458">[1 more]</label></div><br/><div class="children"><div class="content">&gt;threw their weight behind the Linux kernel (or if GNU is too restrictive<p>The GPL isn&#x27;t too restrictive.  Google has no issue with it on Android (which uses a modified Linux kernel).  GPL doesn&#x27;t mean you have to open-source everything, just the GPL components, which in the case of the Linux kernel, is just the kernel itself.  MS already contributes a bunch of drivers (for their hypervisor) to the Linux kernel.  They could easily make a Linux-based OS with their own proprietary crap on top if they wanted to.<p>&gt;support for Android apps without emulation<p>They wouldn&#x27;t need CPU-level emulation, but the API would need some kind of compatibility layer, similar to how WINE serves this purpose for Windows applications on Linux.<p>&gt;Microsoft could build Windows on top of that POSIX kernel and provide a compatibility layer for NT calls and Win32 APIs.<p>They don&#x27;t need to: they can just use WINE.  They could improve that, or maybe fork it and add some proprietary parts like CodeWeavers does, or they could even just buy out CodeWeavers.</div><br/></div></div><div id="41495517" class="c"><input type="checkbox" id="c-41495517" checked=""/><div class="controls bullet"><span class="by">486sx33</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495162">parent</a><span>|</span><a href="#41496458">prev</a><span>|</span><a href="#41495446">next</a><span>|</span><label class="collapse" for="c-41495517">[-]</label><label class="expand" for="c-41495517">[1 more]</label></div><br/><div class="children"><div class="content">Pulling WSL from windows 10 was particularly nasty</div><br/></div></div><div id="41495446" class="c"><input type="checkbox" id="c-41495446" checked=""/><div class="controls bullet"><span class="by">therein</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495162">parent</a><span>|</span><a href="#41495517">prev</a><span>|</span><a href="#41497974">next</a><span>|</span><label class="collapse" for="c-41495446">[-]</label><label class="expand" for="c-41495446">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Cygwin, msys2&#x2F;git-bash are all fantastic but they are no replacement for the kind of development experience you get on Linux &amp; MacOS.<p>&gt; WSL1 was a great start and gave me hope, but is now abandonware.<p>Exactly my thoughts. I really admired the design and how far WSL1 got. It is just sad to see it abandoned.<p>&gt; WSL2 is a joke, if I wanted to run Linux in a VM, I&#x27;d run Linux in a VM.<p>I couldn&#x27;t have said it better. If I wanted to run Linux in a VM, I&#x27;d run Linux in a VM, why are we pretending something special is going on.</div><br/><div id="41496078" class="c"><input type="checkbox" id="c-41496078" checked=""/><div class="controls bullet"><span class="by">wkat4242</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495446">parent</a><span>|</span><a href="#41497974">next</a><span>|</span><label class="collapse" for="c-41496078">[-]</label><label class="expand" for="c-41496078">[1 more]</label></div><br/><div class="children"><div class="content">Yes WSL1 was really special. Talking to the NT kernel from a Linux environment.<p>I think it was mainly the docker crowd that kept asking for compatibility there :(</div><br/></div></div></div></div></div></div><div id="41497974" class="c"><input type="checkbox" id="c-41497974" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41493177">parent</a><span>|</span><a href="#41495162">prev</a><span>|</span><a href="#41493479">next</a><span>|</span><label class="collapse" for="c-41497974">[-]</label><label class="expand" for="c-41497974">[2 more]</label></div><br/><div class="children"><div class="content">Didn&#x27;t the article say that unix&#x27;s were even more full of cruft?</div><br/><div id="41498294" class="c"><input type="checkbox" id="c-41498294" checked=""/><div class="controls bullet"><span class="by">ruthmarx</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41497974">parent</a><span>|</span><a href="#41493479">next</a><span>|</span><label class="collapse" for="c-41498294">[-]</label><label class="expand" for="c-41498294">[1 more]</label></div><br/><div class="children"><div class="content">Did it?</div><br/></div></div></div></div><div id="41493479" class="c"><input type="checkbox" id="c-41493479" checked=""/><div class="controls bullet"><span class="by">fortran77</span><span>|</span><a href="#41493177">parent</a><span>|</span><a href="#41497974">prev</a><span>|</span><a href="#41493954">next</a><span>|</span><label class="collapse" for="c-41493479">[-]</label><label class="expand" for="c-41493479">[10 more]</label></div><br/><div class="children"><div class="content">&gt; The NT kernel is pretty nifty, albeit an aging design.<p>Unix is an Apollo-era technology! Also an aging design.</div><br/><div id="41494545" class="c"><input type="checkbox" id="c-41494545" checked=""/><div class="controls bullet"><span class="by">UniverseHacker</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41493479">parent</a><span>|</span><a href="#41493954">next</a><span>|</span><label class="collapse" for="c-41494545">[-]</label><label class="expand" for="c-41494545">[9 more]</label></div><br/><div class="children"><div class="content">Except unix nowadays is just a set of concepts and conventions incorporated into modern OSs</div><br/><div id="41494827" class="c"><input type="checkbox" id="c-41494827" checked=""/><div class="controls bullet"><span class="by">ElectricalUnion</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41494545">parent</a><span>|</span><a href="#41494684">next</a><span>|</span><label class="collapse" for="c-41494827">[-]</label><label class="expand" for="c-41494827">[1 more]</label></div><br/><div class="children"><div class="content">If by &quot;modern&quot; you mean stuff between 1930 and 1970, sure, most contemporany OSes can trace roots from that era.</div><br/></div></div><div id="41494684" class="c"><input type="checkbox" id="c-41494684" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41494545">parent</a><span>|</span><a href="#41494827">prev</a><span>|</span><a href="#41494629">next</a><span>|</span><label class="collapse" for="c-41494684">[-]</label><label class="expand" for="c-41494684">[3 more]</label></div><br/><div class="children"><div class="content">How “modern” are they when they’re just a bunch of shell scripts on top of POSIX? SystemD caught up to NT4 and the original MacOS.</div><br/><div id="41495632" class="c"><input type="checkbox" id="c-41495632" checked=""/><div class="controls bullet"><span class="by">xattt</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41494684">parent</a><span>|</span><a href="#41494629">next</a><span>|</span><label class="collapse" for="c-41495632">[-]</label><label class="expand" for="c-41495632">[2 more]</label></div><br/><div class="children"><div class="content">&gt; SystemD caught up to NT4 and the original MacOS.<p>The transition happened to the huffing and puffing&#x2F;kicking and screaming of many sysadmins.</div><br/><div id="41498462" class="c"><input type="checkbox" id="c-41498462" checked=""/><div class="controls bullet"><span class="by">ruthmarx</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495632">parent</a><span>|</span><a href="#41494629">next</a><span>|</span><label class="collapse" for="c-41498462">[-]</label><label class="expand" for="c-41498462">[1 more]</label></div><br/><div class="children"><div class="content">Still a minority of sysadmins though. Most seem to have embraced it to an extent that&#x27;s honestly a little sad to see. I liked to think of the linux community as generally being a more technical community, and that was true for a long time when you needed more grit to get everything running, but nowadays many just want Linux to be &#x27;free windows&#x27;.</div><br/></div></div></div></div></div></div><div id="41494629" class="c"><input type="checkbox" id="c-41494629" checked=""/><div class="controls bullet"><span class="by">phendrenad2</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41494545">parent</a><span>|</span><a href="#41494684">prev</a><span>|</span><a href="#41493954">next</a><span>|</span><label class="collapse" for="c-41494629">[-]</label><label class="expand" for="c-41494629">[4 more]</label></div><br/><div class="children"><div class="content">What percent of Unix users are using a &quot;modern OS&quot; and what percentage are using Linux, which hasn&#x27;t significantly changed since it was released in 1994?</div><br/><div id="41498337" class="c"><input type="checkbox" id="c-41498337" checked=""/><div class="controls bullet"><span class="by">SoothingSorbet</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41494629">parent</a><span>|</span><a href="#41495230">next</a><span>|</span><label class="collapse" for="c-41498337">[-]</label><label class="expand" for="c-41498337">[1 more]</label></div><br/><div class="children"><div class="content">Linux has changed dramatically since its first release. It has major parts rewritten every decade or so, even. It just doesn&#x27;t break its ABI with userspace.</div><br/></div></div><div id="41495230" class="c"><input type="checkbox" id="c-41495230" checked=""/><div class="controls bullet"><span class="by">UniverseHacker</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41494629">parent</a><span>|</span><a href="#41498337">prev</a><span>|</span><a href="#41495076">next</a><span>|</span><label class="collapse" for="c-41495230">[-]</label><label class="expand" for="c-41495230">[1 more]</label></div><br/><div class="children"><div class="content">My point was that most people are using things like Linux, MacOS, etc. nowadays, which are all also pretty old by now but not nearly as old as ATT Unix</div><br/></div></div><div id="41495076" class="c"><input type="checkbox" id="c-41495076" checked=""/><div class="controls bullet"><span class="by">SSLy</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41494629">parent</a><span>|</span><a href="#41495230">prev</a><span>|</span><a href="#41493954">next</a><span>|</span><label class="collapse" for="c-41495076">[-]</label><label class="expand" for="c-41495076">[1 more]</label></div><br/><div class="children"><div class="content">let&#x27;s be charitable, removal of global lock was fairly big change.</div><br/></div></div></div></div></div></div></div></div><div id="41493954" class="c"><input type="checkbox" id="c-41493954" checked=""/><div class="controls bullet"><span class="by">marcodiego</span><span>|</span><a href="#41493177">parent</a><span>|</span><a href="#41493479">prev</a><span>|</span><a href="#41494600">next</a><span>|</span><label class="collapse" for="c-41493954">[-]</label><label class="expand" for="c-41493954">[4 more]</label></div><br/><div class="children"><div class="content">I created a file named aux.docx on a pendrive with Linux. Tried to open it on windows 7. It crashed word with a strange error. Don&#x27;t know what would happen on 8+.</div><br/><div id="41494450" class="c"><input type="checkbox" id="c-41494450" checked=""/><div class="controls bullet"><span class="by">uncanneyvalley</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41493954">parent</a><span>|</span><a href="#41494398">next</a><span>|</span><label class="collapse" for="c-41494450">[-]</label><label class="expand" for="c-41494450">[2 more]</label></div><br/><div class="children"><div class="content">It would fail, too. ‘CON’ has been a reserved name since the days of DOS (actually CP&#x2F;M, though that doesn’t have direct lineage to Windows) where it acted as a device name for the console. You can still use it that way. In a CMD window:<p>`type CON &gt; file.txt`, then type some stuff and press CTRL+Z.<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;fileio&#x2F;naming-a-file" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;fileio&#x2F;namin...</a></div><br/><div id="41494949" class="c"><input type="checkbox" id="c-41494949" checked=""/><div class="controls bullet"><span class="by">nullindividual</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41494450">parent</a><span>|</span><a href="#41494398">next</a><span>|</span><label class="collapse" for="c-41494949">[-]</label><label class="expand" for="c-41494949">[1 more]</label></div><br/><div class="children"><div class="content">This is a Win32-ism rather than an NT-ism. This will work:<p><pre><code>    mkdir \\.\C:\COM1</code></pre></div><br/></div></div></div></div><div id="41494398" class="c"><input type="checkbox" id="c-41494398" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41493954">parent</a><span>|</span><a href="#41494450">prev</a><span>|</span><a href="#41494600">next</a><span>|</span><label class="collapse" for="c-41494398">[-]</label><label class="expand" for="c-41494398">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a dos holdover implemented in the win32 side of things in user space.  I&#x27;m pretty sure it still exists on win11.<p><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;40794287&#x2F;cannot-write-to-any-path-with-filename-aux" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;40794287&#x2F;cannot-write-to...</a></div><br/></div></div></div></div><div id="41494600" class="c"><input type="checkbox" id="c-41494600" checked=""/><div class="controls bullet"><span class="by">nox101</span><span>|</span><a href="#41493177">parent</a><span>|</span><a href="#41493954">prev</a><span>|</span><a href="#41497404">next</a><span>|</span><label class="collapse" for="c-41494600">[-]</label><label class="expand" for="c-41494600">[6 more]</label></div><br/><div class="children"><div class="content">Seems to me they should pull an Apple. Run everything old in some &quot;rosetta&quot; like system and then make something 100% new and try to get people to switch, like say no new updates except security updates for the old system so that apps are incentivized to use the new one.</div><br/><div id="41495631" class="c"><input type="checkbox" id="c-41495631" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41494600">parent</a><span>|</span><a href="#41495567">next</a><span>|</span><label class="collapse" for="c-41495631">[-]</label><label class="expand" for="c-41495631">[1 more]</label></div><br/><div class="children"><div class="content">Nobody wants something 100% new.  Users don&#x27;t want it.  Developers don&#x27;t want it.  You can make a new OS but then you&#x27;ll have zero developers and zero users.<p>Yet this fantasy exists.<p>And as soon as you make something new, it&#x27;ll be old, and people will call for its replacement.</div><br/></div></div><div id="41495567" class="c"><input type="checkbox" id="c-41495567" checked=""/><div class="controls bullet"><span class="by">wannacboatmovie</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41494600">parent</a><span>|</span><a href="#41495631">prev</a><span>|</span><a href="#41494753">next</a><span>|</span><label class="collapse" for="c-41495567">[-]</label><label class="expand" for="c-41495567">[1 more]</label></div><br/><div class="children"><div class="content">You left out the important part: abandon the Rosetta-like system a mere few years later once you&#x27;ve lured them in, then fuck everyone over by breaking backwards compatibility every OS release. Apple really has the &quot;extinguish&quot; part nailed down.</div><br/></div></div><div id="41494753" class="c"><input type="checkbox" id="c-41494753" checked=""/><div class="controls bullet"><span class="by">mepian</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41494600">parent</a><span>|</span><a href="#41495567">prev</a><span>|</span><a href="#41497404">next</a><span>|</span><label class="collapse" for="c-41494753">[-]</label><label class="expand" for="c-41494753">[3 more]</label></div><br/><div class="children"><div class="content">Carbon is a better Apple-related comparison since it&#x27;s basically a cleaned-up version of the classic Mac OS API as a library that ran on both Mac OS X and classic.</div><br/><div id="41495798" class="c"><input type="checkbox" id="c-41495798" checked=""/><div class="controls bullet"><span class="by">nullindividual</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41494753">parent</a><span>|</span><a href="#41497404">next</a><span>|</span><label class="collapse" for="c-41495798">[-]</label><label class="expand" for="c-41495798">[2 more]</label></div><br/><div class="children"><div class="content">Win32 runs on Linux by way of SQL Server.</div><br/><div id="41497253" class="c"><input type="checkbox" id="c-41497253" checked=""/><div class="controls bullet"><span class="by">chem83</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41495798">parent</a><span>|</span><a href="#41497404">next</a><span>|</span><label class="collapse" for="c-41497253">[-]</label><label class="expand" for="c-41497253">[1 more]</label></div><br/><div class="children"><div class="content">uhhhhhh yes, but not really? All Win32 calls are intercepted and handled by SQLPAL, instead. <a href="https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;sql-server&#x2F;blog&#x2F;2016&#x2F;12&#x2F;16&#x2F;sql-server-on-linux-how-introduction" rel="nofollow">https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;sql-server&#x2F;blog&#x2F;2016&#x2F;12&#x2F;16&#x2F;s...</a></div><br/></div></div></div></div></div></div></div></div><div id="41497404" class="c"><input type="checkbox" id="c-41497404" checked=""/><div class="controls bullet"><span class="by">Andrex</span><span>|</span><a href="#41493177">parent</a><span>|</span><a href="#41494600">prev</a><span>|</span><a href="#41493365">next</a><span>|</span><label class="collapse" for="c-41497404">[-]</label><label class="expand" for="c-41497404">[1 more]</label></div><br/><div class="children"><div class="content">Imagine the alternate reality where we got Longhorn with WinFS instead of Vista.</div><br/></div></div><div id="41493365" class="c"><input type="checkbox" id="c-41493365" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#41493177">parent</a><span>|</span><a href="#41497404">prev</a><span>|</span><a href="#41494789">next</a><span>|</span><label class="collapse" for="c-41493365">[-]</label><label class="expand" for="c-41493365">[3 more]</label></div><br/><div class="children"><div class="content">Win32 is not the issue, MS could just create shims for these in a secure way.
It&#x27;s 2024, not 1997.<p>Ditto with GNU&#x2F;Linux and old SVGAlib games. It already should have been some a wrapper against SDL2.</div><br/><div id="41494605" class="c"><input type="checkbox" id="c-41494605" checked=""/><div class="controls bullet"><span class="by">runjake</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41493365">parent</a><span>|</span><a href="#41494789">next</a><span>|</span><label class="collapse" for="c-41494605">[-]</label><label class="expand" for="c-41494605">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure what you&#x27;re trying to say here, but those &quot;shims&quot; exist. Apps generally do not talk directly to the Executive (kernel). Instead, the OS has protected subsystems that publish APIs.<p>Apps talk to the subsystem, and the subsystem talks to the Executive (kernel).<p>Traditionally, Windows apps talk to the Win32 subsystem[1]. This subsystem, as currently designed, is an issue as described in my previous comment.<p>1. <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Architecture_of_Windows_NT#Win32_environment_subsystem" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Architecture_of_Windows_NT#Win...</a><p>Caveat: Details of this may have changed in the last couple major Windows versions. I&#x27;ve been out of the NT game for a bit. Someone correct me, if so.</div><br/><div id="41497984" class="c"><input type="checkbox" id="c-41497984" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#41493177">root</a><span>|</span><a href="#41494605">parent</a><span>|</span><a href="#41494789">next</a><span>|</span><label class="collapse" for="c-41497984">[-]</label><label class="expand" for="c-41497984">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I will correct you. Direct Draw games with run dog slow under Windows 8 and up. You can run them at full speed with WineD3D as it has libraries to map both GDI and DDraw to OpenGL.</div><br/></div></div></div></div></div></div></div></div><div id="41494789" class="c"><input type="checkbox" id="c-41494789" checked=""/><div class="controls bullet"><span class="by">phendrenad2</span><span>|</span><a href="#41493177">prev</a><span>|</span><a href="#41490688">next</a><span>|</span><label class="collapse" for="c-41494789">[-]</label><label class="expand" for="c-41494789">[7 more]</label></div><br/><div class="children"><div class="content">One thing I don&#x27;t see mentioned in this article, and I consider to be the #1 difference between NT and Unix, is the approach to drivers.<p>It seems like NT was designed to fix a lot of the problems with drivers in Windows 3.x&#x2F;95&#x2F;98. Drivers in those OSs came from 3rd party vendors and couldn&#x27;t be trusted to not crash the system. So ample facilities were created to help the user out, such as &quot;Safe Mode&quot; , fallback drivers, and a graphics driver interface that disables itself if it crashes too many times (yes really).<p>Compare that to any Unix. Historic, AT&amp;T Unix, Solaris, Linux, BSD 4.x, Net&#x2F;Free&#x2F;OpenBSD, any research Unix being taught at universities, or any of the new crop of Unix-likes such as Redox. Universally, the philosophy there is that drivers are high-reliability components vetted and likely written by the kernel devs.<p>(Windows also has a stable driver API and I have yet to see a Unix with that, but that&#x27;s another tangent)</div><br/><div id="41496802" class="c"><input type="checkbox" id="c-41496802" checked=""/><div class="controls bullet"><span class="by">hernandipietro</span><span>|</span><a href="#41494789">parent</a><span>|</span><a href="#41497464">next</a><span>|</span><label class="collapse" for="c-41496802">[-]</label><label class="expand" for="c-41496802">[1 more]</label></div><br/><div class="children"><div class="content">Windows NT 3.x had graphics and printer drivers in user-mode for stability reasons. Windows NT 4 moved them to Ring 0 to speed-up graphics applications.</div><br/></div></div><div id="41497464" class="c"><input type="checkbox" id="c-41497464" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#41494789">parent</a><span>|</span><a href="#41496802">prev</a><span>|</span><a href="#41496521">next</a><span>|</span><label class="collapse" for="c-41497464">[-]</label><label class="expand" for="c-41497464">[2 more]</label></div><br/><div class="children"><div class="content">&gt; and a graphics driver interface that disables itself if it crashes too many times<p>That feature is one of the great ones that came with Windows Vista.</div><br/><div id="41498497" class="c"><input type="checkbox" id="c-41498497" checked=""/><div class="controls bullet"><span class="by">ruthmarx</span><span>|</span><a href="#41494789">root</a><span>|</span><a href="#41497464">parent</a><span>|</span><a href="#41496521">next</a><span>|</span><label class="collapse" for="c-41498497">[-]</label><label class="expand" for="c-41498497">[1 more]</label></div><br/><div class="children"><div class="content">It really was nice to be able to at least still use the system if the display driver is crashing. 800x600 at 16 bit or whatever it was is still better than nothing.</div><br/></div></div></div></div><div id="41496521" class="c"><input type="checkbox" id="c-41496521" checked=""/><div class="controls bullet"><span class="by">jonathanyc</span><span>|</span><a href="#41494789">parent</a><span>|</span><a href="#41497464">prev</a><span>|</span><a href="#41496545">next</a><span>|</span><label class="collapse" for="c-41496521">[-]</label><label class="expand" for="c-41496521">[2 more]</label></div><br/><div class="children"><div class="content">&gt; and a graphics driver interface that disables itself if it crashes too many times (yes really)<p>I actually ran into this while upgrading an AMD driver and was very impressed! On Linux and macOS I was used to just getting kernel panics.<p>It’s too bad whatever system Crowdstrike hooked into was not similarly isolated.</div><br/><div id="41497442" class="c"><input type="checkbox" id="c-41497442" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#41494789">root</a><span>|</span><a href="#41496521">parent</a><span>|</span><a href="#41496545">next</a><span>|</span><label class="collapse" for="c-41497442">[-]</label><label class="expand" for="c-41497442">[1 more]</label></div><br/><div class="children"><div class="content">APIs used by crowdstrike et al are also what made WSL1 unworkable performance-wise. Can’t have security without slowness nowadays it seems.</div><br/></div></div></div></div><div id="41496545" class="c"><input type="checkbox" id="c-41496545" checked=""/><div class="controls bullet"><span class="by">Dalewyn</span><span>|</span><a href="#41494789">parent</a><span>|</span><a href="#41496521">prev</a><span>|</span><a href="#41490688">next</a><span>|</span><label class="collapse" for="c-41496545">[-]</label><label class="expand" for="c-41496545">[1 more]</label></div><br/><div class="children"><div class="content">&gt;So ample facilities were created to help the user out, such as &quot;Safe Mode&quot; , fallback drivers, and a graphics driver interface that disables itself if it crashes too many times (yes really).<p>Pretty sure most of this was already in place with Windows 95; I know Safe Mode definitely was along with a very basic VGA driver that could drive any video card in the world.</div><br/></div></div></div></div><div id="41490688" class="c"><input type="checkbox" id="c-41490688" checked=""/><div class="controls bullet"><span class="by">nullindividual</span><span>|</span><a href="#41494789">prev</a><span>|</span><a href="#41496878">next</a><span>|</span><label class="collapse" for="c-41490688">[-]</label><label class="expand" for="c-41490688">[65 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a large debate whether a &#x27;hybrid&#x27; kernel is an actual thing, and&#x2F;or whether NT is just a monolithic kernel.<p>The processes section should be expanded upon. The NT kernel doesn&#x27;t execute processes, it executes _threads_. Threads can be created in a few milliseconds where as noted, processes are heavy weight; essentially the opposite of Unicies. This is a big distinction.<p>io_uring would be the first true non-blocking async I&#x2F;O implementation on Unicies.<p>It should also be noted that while NT as a product is much newer than Unicies, it&#x27;s history is rooted in VMS fundamentals thanks to it&#x27;s core team of ex-Digital devs lead by David Cutler. This pulls back that &#x27;feature history&#x27; by a decade or more. Still not as old as UNIX, but &quot;old enough&quot;, one could argue.<p>[0] <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;8768083&#x2F;difference-between-posix-aio-and-libaio-on-linux" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;8768083&#x2F;difference-betwe...</a></div><br/><div id="41491817" class="c"><input type="checkbox" id="c-41491817" checked=""/><div class="controls bullet"><span class="by">emily-c</span><span>|</span><a href="#41490688">parent</a><span>|</span><a href="#41491642">next</a><span>|</span><label class="collapse" for="c-41491817">[-]</label><label class="expand" for="c-41491817">[12 more]</label></div><br/><div class="children"><div class="content">Before VMS there was the family of RSX-11 operating systems which also had ASTs (now called APCs in NT parlance), IRPs, etc. Dave Cutler led the RSX-11M variant which significantly influenced VMS. The various concepts and design styles of the DEC family of operating systems that culminated in NT goes back to the 1960s.<p>It&#x27;s sad that the article didn&#x27;t mention VMS or MICA since NT didn&#x27;t magically appear out of the void two years after Microsoft hired the NT team. MICA was being designed for years at DEC West as part of the PRISM project.</div><br/><div id="41492683" class="c"><input type="checkbox" id="c-41492683" checked=""/><div class="controls bullet"><span class="by">rbanffy</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41491817">parent</a><span>|</span><a href="#41496668">next</a><span>|</span><label class="collapse" for="c-41492683">[-]</label><label class="expand" for="c-41492683">[8 more]</label></div><br/><div class="children"><div class="content">In many ways NT was a new, ground up implementation of “VMS NT”.<p>It started elegant, but all the backwards compatibility, technical debt, bad ideas, and dozens of versions later, with an endless list of perpetual features driven by whoever had a bigger wand at Microsoft at the time of their inception, takes a toll. Windows now is much more complicated than it could be.<p>It shocks me some apps get Windows NT4 style buttons even on Windows 11.</div><br/><div id="41492967" class="c"><input type="checkbox" id="c-41492967" checked=""/><div class="controls bullet"><span class="by">emily-c</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41492683">parent</a><span>|</span><a href="#41493492">next</a><span>|</span><label class="collapse" for="c-41492967">[-]</label><label class="expand" for="c-41492967">[1 more]</label></div><br/><div class="children"><div class="content">&gt;In many ways NT was a new, ground up implementation of “VMS NT”.<p>Most definitely. There was a lot of design cleanup from VMS (e.g. fork processes -&gt; DPCs, removing global PTEs and balance slots, etc), optimizations (converging VMS&#x27;s parallel array structure of the PFN database into one), and simplification (NT&#x27;s Io subsystem with the &quot;bring your own thread&quot; model, removing P1 space, and much more). SMP was also designed into NT from the beginning. You can start seeing the start of these ideas in the MICA design documents but their implementation in C instead of Pillar (variant of Pascal designed for Mica) in NT was definitely the right thing at the time.</div><br/></div></div><div id="41493492" class="c"><input type="checkbox" id="c-41493492" checked=""/><div class="controls bullet"><span class="by">markus_zhang</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41492683">parent</a><span>|</span><a href="#41492967">prev</a><span>|</span><a href="#41494461">next</a><span>|</span><label class="collapse" for="c-41493492">[-]</label><label class="expand" for="c-41493492">[5 more]</label></div><br/><div class="children"><div class="content">How do you get Windows NT4 style buttons on 11? That&#x27;s something I want to do with my application!</div><br/><div id="41493971" class="c"><input type="checkbox" id="c-41493971" checked=""/><div class="controls bullet"><span class="by">dspillett</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41493492">parent</a><span>|</span><a href="#41494461">next</a><span>|</span><label class="collapse" for="c-41493971">[-]</label><label class="expand" for="c-41493971">[4 more]</label></div><br/><div class="children"><div class="content">The GDI libraries&#x2F;APIs that provide that are all still there, you just need to find a framework that lets you see them, are kick through the abstraction walls of [insert chosen app framework] to access them more manually. Be prepared for a bit of extra work on what more modern UI libraries make more automatic, and having to discuss everything rather than just what you want to differ from default.</div><br/><div id="41494584" class="c"><input type="checkbox" id="c-41494584" checked=""/><div class="controls bullet"><span class="by">markus_zhang</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41493971">parent</a><span>|</span><a href="#41494461">next</a><span>|</span><label class="collapse" for="c-41494584">[-]</label><label class="expand" for="c-41494584">[3 more]</label></div><br/><div class="children"><div class="content">Oh thanks, I always think what is there is the native. I don&#x27;t realize the old graphics way is still there. Maybe the Win3.x style is still there too?</div><br/><div id="41494875" class="c"><input type="checkbox" id="c-41494875" checked=""/><div class="controls bullet"><span class="by">saratogacx</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41494584">parent</a><span>|</span><a href="#41494461">next</a><span>|</span><label class="collapse" for="c-41494875">[-]</label><label class="expand" for="c-41494875">[2 more]</label></div><br/><div class="children"><div class="content">I think you can get back to Win9x&#x2F;2k style controls by instructing the system to not add any theming.  If you&#x27;re finding a panel that is using 3.x controls, they&#x27;re likely in the resources of the app&#x2F;dll.  Although the 3.x file picker can still be found in a couple of rare corners of the OS.<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;api&#x2F;uxtheme&#x2F;nf-uxtheme-setthemeappproperties" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;api&#x2F;uxtheme&#x2F;...</a><p><pre><code>    STAP_ALLOW_NONCLIENT
</code></pre>
Specifies that the nonclient areas of application windows will have visual styles applied.</div><br/><div id="41495382" class="c"><input type="checkbox" id="c-41495382" checked=""/><div class="controls bullet"><span class="by">markus_zhang</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41494875">parent</a><span>|</span><a href="#41494461">next</a><span>|</span><label class="collapse" for="c-41495382">[-]</label><label class="expand" for="c-41495382">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, this is interesting!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41494461" class="c"><input type="checkbox" id="c-41494461" checked=""/><div class="controls bullet"><span class="by">heraldgeezer</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41492683">parent</a><span>|</span><a href="#41493492">prev</a><span>|</span><a href="#41496668">next</a><span>|</span><label class="collapse" for="c-41494461">[-]</label><label class="expand" for="c-41494461">[1 more]</label></div><br/><div class="children"><div class="content">&gt;It shocks me some apps get Windows NT4 style buttons even on Windows 11.<p>This is good, though. The alternative is that the app won&#x27;t run at all, right? Windows NT is good because of that background compatibility, both for business apps and games.</div><br/></div></div></div></div><div id="41496668" class="c"><input type="checkbox" id="c-41496668" checked=""/><div class="controls bullet"><span class="by">Taniwha</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41491817">parent</a><span>|</span><a href="#41492683">prev</a><span>|</span><a href="#41496921">next</a><span>|</span><label class="collapse" for="c-41496668">[-]</label><label class="expand" for="c-41496668">[1 more]</label></div><br/><div class="children"><div class="content">Vaxes also had hardware support for ASTs in VMS (unlike NT) - they were essentially software interrupts that only triggered when the CPU was in a process context and no enabled interrupts were pending - so you could set a bit in a mask in another thread&#x27;s context that would get loaded automatically on context switch and triggered once the thread was runnable in user mode .... device drivers could trigger a similar mechanism in kernel mode (and the 2 intermediate hardware modes&#x2F;rings). There were also atomic queue instructions that would dispatch waiting ASTs</div><br/></div></div><div id="41496921" class="c"><input type="checkbox" id="c-41496921" checked=""/><div class="controls bullet"><span class="by">jdougan</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41491817">parent</a><span>|</span><a href="#41496668">prev</a><span>|</span><a href="#41491642">next</a><span>|</span><label class="collapse" for="c-41496921">[-]</label><label class="expand" for="c-41496921">[2 more]</label></div><br/><div class="children"><div class="content">Especially since there was, apparently, MICA code copy pasted verbatim in NT.<p><a href="https:&#x2F;&#x2F;www.techmonitor.ai&#x2F;technology&#x2F;dec_forced_microsoft_into_alliance_with_legal_threat" rel="nofollow">https:&#x2F;&#x2F;www.techmonitor.ai&#x2F;technology&#x2F;dec_forced_microsoft_i...</a><p>I was wondering for years why MS continued to support DEC Alpha CPUs with NT.</div><br/><div id="41497387" class="c"><input type="checkbox" id="c-41497387" checked=""/><div class="controls bullet"><span class="by">rasz</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41496921">parent</a><span>|</span><a href="#41491642">next</a><span>|</span><label class="collapse" for="c-41497387">[-]</label><label class="expand" for="c-41497387">[1 more]</label></div><br/><div class="children"><div class="content">Didnt it end brilliantly for MS? Settlement involved MS supporting Alpha while DEC trained its enormous sales&#x2F;engineering arm to sell and support NT thus killing any incentives to buy DEC hw in the first place. DEC moved upstream the value chain and Microsoft moved tons of NT to all existing DEC corporate customers.</div><br/></div></div></div></div></div></div><div id="41491642" class="c"><input type="checkbox" id="c-41491642" checked=""/><div class="controls bullet"><span class="by">delta_p_delta_x</span><span>|</span><a href="#41490688">parent</a><span>|</span><a href="#41491817">prev</a><span>|</span><a href="#41491254">next</a><span>|</span><label class="collapse" for="c-41491642">[-]</label><label class="expand" for="c-41491642">[10 more]</label></div><br/><div class="children"><div class="content">&gt; The NT kernel doesn&#x27;t execute processes, it executes _threads_<p>This is amongst the most important and visible differences between NT and Unix-likes, really. The key idea is that processes <i>manage</i> threads. Pavel Yosifovich in <i>Windows 10 System Internals Part I</i> puts it succinctly:<p><pre><code>  A process is a containment and management object that represents a running instance of a program. The term “process runs” which is used fairly often, is inaccurate. Processes don’t run - processes manage. Threads are the ones that execute code and technically run.
</code></pre>
NtCreateProcess is <i>extremely</i> expensive and its direct use strongly discouraged (but Cygwin and MSYS2, in their IMO misguided intention to force Unix paradigms onto Windows, wrote fork() anyway), but thread creation and management is extremely straightforward, and the Windows threading API is as a result much nicer than pthreads.</div><br/><div id="41491757" class="c"><input type="checkbox" id="c-41491757" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41491642">parent</a><span>|</span><a href="#41492263">next</a><span>|</span><label class="collapse" for="c-41491757">[-]</label><label class="expand" for="c-41491757">[8 more]</label></div><br/><div class="children"><div class="content">It is hard to accept that this is written by someone with any idea about how Linux works (as a Unix).<p>A process (really, a &quot;task&quot;) is a containment and management object that represents a running instance of a program. A program (&quot;task&quot;) does not run, its threads do.<p>The significant difference between Windows-related OS kernels and Unix-y ones is that process creation is much more heavyweight on the former. Nevertheless, on both types of systems, it is <i>threads</i> that execute code and technically run.</div><br/><div id="41492062" class="c"><input type="checkbox" id="c-41492062" checked=""/><div class="controls bullet"><span class="by">delta_p_delta_x</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41491757">parent</a><span>|</span><a href="#41492042">next</a><span>|</span><label class="collapse" for="c-41492062">[-]</label><label class="expand" for="c-41492062">[2 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re splitting hairs, you&#x27;re correct; processes manage threads on all OSs.<p>However, from the application programmer&#x27;s perspective, the <i>convention</i> on Unix-likes (which is what really matters) is to fork and pipe between processes as IPC, whereas on Windows this is not the case. Clearly the process start-up time on Unix-likes is considered fast enough that parallelism on Unix until fairly recently was based on spinning up tens to hundreds of processes and IPC-ing between them.<p>I believe the point stands.</div><br/><div id="41494986" class="c"><input type="checkbox" id="c-41494986" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41492062">parent</a><span>|</span><a href="#41492042">next</a><span>|</span><label class="collapse" for="c-41494986">[-]</label><label class="expand" for="c-41494986">[1 more]</label></div><br/><div class="children"><div class="content">For a <i>certain kind of application programming</i>, that is and was true, yes.<p>But not for many other kinds of application programming, where you create threads using pthreads or some similar API, which are mapped 1:1 onto kernel threads that collectively form a &quot;process&quot;.<p>I&#x27;m not sure what your definition of &quot;fairly recently&quot; is, but in the mid-90s, when we wanted to test new SMP systems, we would typically write code that used pthreads for parallelism. The fact that there is indeed a story about process-level parallelism (with IPC) in Unix-y systems should not distract from the equally fact existence and use of thread-level parallelism for at least 35 years.</div><br/></div></div></div></div><div id="41492042" class="c"><input type="checkbox" id="c-41492042" checked=""/><div class="controls bullet"><span class="by">jjtheblunt</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41491757">parent</a><span>|</span><a href="#41492062">prev</a><span>|</span><a href="#41492183">next</a><span>|</span><label class="collapse" for="c-41492042">[-]</label><label class="expand" for="c-41492042">[3 more]</label></div><br/><div class="children"><div class="content">Mach before Linux was using task and threads as you seem to attribute to Linux.<p>A nice historical overview is…<p><a href="https:&#x2F;&#x2F;developer.apple.com&#x2F;library&#x2F;archive&#x2F;documentation&#x2F;Darwin&#x2F;Conceptual&#x2F;KernelProgramming&#x2F;Mach&#x2F;Mach.html" rel="nofollow">https:&#x2F;&#x2F;developer.apple.com&#x2F;library&#x2F;archive&#x2F;documentation&#x2F;Da...</a></div><br/><div id="41494998" class="c"><input type="checkbox" id="c-41494998" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41492042">parent</a><span>|</span><a href="#41492183">next</a><span>|</span><label class="collapse" for="c-41494998">[-]</label><label class="expand" for="c-41494998">[2 more]</label></div><br/><div class="children"><div class="content">I worked on Mach in the early 1990s :) For example:<p><a href="https:&#x2F;&#x2F;www.usenix.org&#x2F;conference&#x2F;usenix-mach-iii-symposium&#x2F;adding-scheduler-activations-mach-30" rel="nofollow">https:&#x2F;&#x2F;www.usenix.org&#x2F;conference&#x2F;usenix-mach-iii-symposium&#x2F;...</a></div><br/><div id="41496271" class="c"><input type="checkbox" id="c-41496271" checked=""/><div class="controls bullet"><span class="by">jjtheblunt</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41494998">parent</a><span>|</span><a href="#41492183">next</a><span>|</span><label class="collapse" for="c-41496271">[-]</label><label class="expand" for="c-41496271">[1 more]</label></div><br/><div class="children"><div class="content">i was programming on NeXT as a registered developer back then too.  Middle aged nerds unite!</div><br/></div></div></div></div></div></div><div id="41492183" class="c"><input type="checkbox" id="c-41492183" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41491757">parent</a><span>|</span><a href="#41492042">prev</a><span>|</span><a href="#41492263">next</a><span>|</span><label class="collapse" for="c-41492183">[-]</label><label class="expand" for="c-41492183">[2 more]</label></div><br/><div class="children"><div class="content">This was written about Windows kernels.<p>Linux is the only Unix-like kernel I actually know anything about. In Linux, processes essentially do not exist. You have threads, and thread groups. A thread group is what most of the user-space tooling calls a process. It doesn&#x27;t do very much by itself. As the name implies, it mostly just groups threads together under one identifier.<p>Linux threads and &quot;processes&quot; are both created using the &quot;clone&quot; system call, which allows the caller to specify how much state the new thread shares with the old thread. Share almost everything, and you have a &quot;thread&quot;. Share almost nothing, and you have a &quot;process&quot;. But the kernel treats them the same.<p>By contrast, processes in NT are real data structures that hold all kinds of attributes, none of which is a running piece of code, since that&#x27;s still handled by a thread in both designs.</div><br/><div id="41492601" class="c"><input type="checkbox" id="c-41492601" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41492183">parent</a><span>|</span><a href="#41492263">next</a><span>|</span><label class="collapse" for="c-41492601">[-]</label><label class="expand" for="c-41492601">[1 more]</label></div><br/><div class="children"><div class="content">IIRC indeed Linux preserves the time honoured  Unix semantics of a process ID by leveraging the thread group ID</div><br/></div></div></div></div></div></div><div id="41492263" class="c"><input type="checkbox" id="c-41492263" checked=""/><div class="controls bullet"><span class="by">netbsdusers</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41491642">parent</a><span>|</span><a href="#41491757">prev</a><span>|</span><a href="#41491254">next</a><span>|</span><label class="collapse" for="c-41492263">[-]</label><label class="expand" for="c-41492263">[1 more]</label></div><br/><div class="children"><div class="content">All kernels execute threads. It&#x27;s just that very old unixes had a unity of thread and process (and Linux having emulated that later introduced an unprecedented solution to bring in support for posix threads). The other unixes for their part all have a typical process and threads distinction today and have had for a while.</div><br/></div></div></div></div><div id="41491254" class="c"><input type="checkbox" id="c-41491254" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#41490688">parent</a><span>|</span><a href="#41491642">prev</a><span>|</span><a href="#41491722">next</a><span>|</span><label class="collapse" for="c-41491254">[-]</label><label class="expand" for="c-41491254">[22 more]</label></div><br/><div class="children"><div class="content">&gt; io_uring would be the first true non-blocking async I&#x2F;O implementation on Unices.<p>I would agree with that statement in isolation, except by that standard (no need for a syscall per operation) the first “true” asynchronous I&#x2F;O API on NT would be I&#x2F;O ring (2021), a very close copy of io_uring. (Registered I&#x2F;O, introduced in Windows 8, does not qualify because it only works on sockets.) The original NT API is absolutely in the same class as the FreeBSD and Solaris ones, it’s just that Linux didn’t have a satisfactory one for a long long time.</div><br/><div id="41491338" class="c"><input type="checkbox" id="c-41491338" checked=""/><div class="controls bullet"><span class="by">nullindividual</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41491254">parent</a><span>|</span><a href="#41496961">next</a><span>|</span><label class="collapse" for="c-41491338">[-]</label><label class="expand" for="c-41491338">[18 more]</label></div><br/><div class="children"><div class="content">POSIX AIO is not non-blocking async I&#x2F;O; it <i>can</i> block other threads requesting the resource. IOCP is a true non-blocking async I&#x2F;O. IOCP also extends to all forms of I&#x2F;O (file, TCP socket, network, mail slot, pipes, etc.) instead of a particular type.<p>POSIX AIO has usability problems also outlined in the previously linked thread.<p>Remember, all I&#x2F;O in NT is async at the kernel level. It&#x27;s not a &quot;bolt-on&quot;.<p>IoRing is limited to file reads, unlike io_uring.</div><br/><div id="41494409" class="c"><input type="checkbox" id="c-41494409" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41491338">parent</a><span>|</span><a href="#41491641">next</a><span>|</span><label class="collapse" for="c-41494409">[-]</label><label class="expand" for="c-41494409">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Remember, all I&#x2F;O in NT is async at the kernel level. It&#x27;s not a &quot;bolt-on&quot;.<p>All I&#x2F;O in Linux is also async at the kernel level! The problem has always been expressing that asynchronicity to userspace in a sane way.</div><br/><div id="41495763" class="c"><input type="checkbox" id="c-41495763" checked=""/><div class="controls bullet"><span class="by">netbsdusers</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41494409">parent</a><span>|</span><a href="#41491641">next</a><span>|</span><label class="collapse" for="c-41495763">[-]</label><label class="expand" for="c-41495763">[4 more]</label></div><br/><div class="children"><div class="content">Filesystem io (and probably more) is not async at the kernel level in Linux. (Just imagine trying to express the complexity of it in continuations or some sort od state machine!) As such io_uring takes the form of a kernel thread pool. Disk block io by contrast is much easier to be fundamentally async since its almost always a case of submitting a request to an HBA and waiting for an interrupt.</div><br/><div id="41496537" class="c"><input type="checkbox" id="c-41496537" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41495763">parent</a><span>|</span><a href="#41497006">next</a><span>|</span><label class="collapse" for="c-41496537">[-]</label><label class="expand" for="c-41496537">[2 more]</label></div><br/><div class="children"><div class="content"><i>Just imagine trying to express the complexity of [a filesystem] in continuations or some sort of state machine!</i><p>Arguably asyc&#x2F;await could help with this; obviously it didn&#x27;t exist in 1991 when Linux was created but it would be interesting to revisit this topic.</div><br/><div id="41498441" class="c"><input type="checkbox" id="c-41498441" checked=""/><div class="controls bullet"><span class="by">SoothingSorbet</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41496537">parent</a><span>|</span><a href="#41497006">next</a><span>|</span><label class="collapse" for="c-41498441">[-]</label><label class="expand" for="c-41498441">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Arguably asyc&#x2F;await could help with this; obviously it didn&#x27;t exist in 1991 when Linux was created<p>Wouldn&#x27;t that just consist of I&#x2F;O operations returning futures and then having an await() block the calling thread until the future is done (i.e. put it on a waitqueue)?</div><br/></div></div></div></div><div id="41497006" class="c"><input type="checkbox" id="c-41497006" checked=""/><div class="controls bullet"><span class="by">treyd</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41495763">parent</a><span>|</span><a href="#41496537">prev</a><span>|</span><a href="#41491641">next</a><span>|</span><label class="collapse" for="c-41497006">[-]</label><label class="expand" for="c-41497006">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Just imagine trying to express the complexity of it in continuations or some sort od state machine!<p>With Rust in the kernel this becomes somewhat possible to conceptualize.</div><br/></div></div></div></div></div></div><div id="41492731" class="c"><input type="checkbox" id="c-41492731" checked=""/><div class="controls bullet"><span class="by">jhallenworld</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41491338">parent</a><span>|</span><a href="#41491641">prev</a><span>|</span><a href="#41491417">next</a><span>|</span><label class="collapse" for="c-41492731">[-]</label><label class="expand" for="c-41492731">[4 more]</label></div><br/><div class="children"><div class="content">This is all fine, but Window-NT file access is still slow compared with Linux- this shows up in shell scripts.  The reason is supposedly that it insists on syncing during close, or maybe waiting for all closed files to sync before allowing the process to terminate.  Shouldn&#x27;t close finality be an optional async event or something?</div><br/><div id="41492906" class="c"><input type="checkbox" id="c-41492906" checked=""/><div class="controls bullet"><span class="by">nullindividual</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41492731">parent</a><span>|</span><a href="#41491417">next</a><span>|</span><label class="collapse" for="c-41492906">[-]</label><label class="expand" for="c-41492906">[3 more]</label></div><br/><div class="children"><div class="content">The reason is due to file system filters, of which Windows Defender is always there. There is a significant delay from Defender when performing CloseFile()[0].<p>&gt; As I was looking at the raw system calls related to I&#x2F;O, something immediately popped out: CloseFile() operations were frequently taking 1-5 milliseconds whereas other operations like opening, reading, and writing files only took 1-5 microseconds. That&#x27;s a 1000x difference!<p>This is why DevDrive was introduced[1]. You can either have Defender operate in async mode (default) or remove it entirely from the volume at your own risk.<p>The performance issue isn&#x27;t related to sync or async I&#x2F;O.<p>[0] <a href="https:&#x2F;&#x2F;gregoryszorc.com&#x2F;blog&#x2F;2015&#x2F;10&#x2F;22&#x2F;append-i&#x2F;o-performance-on-windows&#x2F;" rel="nofollow">https:&#x2F;&#x2F;gregoryszorc.com&#x2F;blog&#x2F;2015&#x2F;10&#x2F;22&#x2F;append-i&#x2F;o-performa...</a><p>[1] <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;visualstudio&#x2F;devdrive&#x2F;" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;visualstudio&#x2F;devdrive&#x2F;</a></div><br/><div id="41496132" class="c"><input type="checkbox" id="c-41496132" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41492906">parent</a><span>|</span><a href="#41491417">next</a><span>|</span><label class="collapse" for="c-41496132">[-]</label><label class="expand" for="c-41496132">[2 more]</label></div><br/><div class="children"><div class="content">Windows FS stack is still _way_ slower than Linux. Filesystem operations have to create IRPs and submit them for execution through a generic mechanism. These IRPs can get filtered and modified in-flight, providing quite a bit of overall flexibility.<p>In Linux, filesystem paths are super-optimized, with all the filtering (e.g. for SELinux) special-cased if needed.<p>But even still, Windows also had to cheat to avoid completely cratering the performance, there&#x27;s a shortcut called &quot;FastIO&quot;: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows-hardware&#x2F;drivers&#x2F;ifs&#x2F;registering-fast-i-o-dispatch-routines" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows-hardware&#x2F;drivers&#x2F;i...</a><p>I wrote a filesystem for Windows around 25 years ago, and I still remember how I implemented all the required prototypes and everything in Explorer worked. But notepad.exe was just showing me empty data. It took me several days to find a note tucked into MSDN that you need to implement FastIO for memory mapped files to work (which Notepad.exe used).</div><br/><div id="41498454" class="c"><input type="checkbox" id="c-41498454" checked=""/><div class="controls bullet"><span class="by">SoothingSorbet</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41496132">parent</a><span>|</span><a href="#41491417">next</a><span>|</span><label class="collapse" for="c-41498454">[-]</label><label class="expand" for="c-41498454">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s interesting, why would notepad.exe use mmapped files?</div><br/></div></div></div></div></div></div></div></div><div id="41491417" class="c"><input type="checkbox" id="c-41491417" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41491338">parent</a><span>|</span><a href="#41492731">prev</a><span>|</span><a href="#41492087">next</a><span>|</span><label class="collapse" for="c-41491417">[-]</label><label class="expand" for="c-41491417">[6 more]</label></div><br/><div class="children"><div class="content">POSIX AIO + FreeBSD kqueue or Solaris ports are functionally equivalent to IOCP as far as I can tell.</div><br/><div id="41491530" class="c"><input type="checkbox" id="c-41491530" checked=""/><div class="controls bullet"><span class="by">nullindividual</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41491417">parent</a><span>|</span><a href="#41492087">next</a><span>|</span><label class="collapse" for="c-41491530">[-]</label><label class="expand" for="c-41491530">[5 more]</label></div><br/><div class="children"><div class="content">This describes kqueue:<p><a href="https:&#x2F;&#x2F;speakerdeck.com&#x2F;trent&#x2F;pyparallel-how-we-removed-the-gil-and-exploited-all-cores?slide=37" rel="nofollow">https:&#x2F;&#x2F;speakerdeck.com&#x2F;trent&#x2F;pyparallel-how-we-removed-the-...</a></div><br/><div id="41491993" class="c"><input type="checkbox" id="c-41491993" checked=""/><div class="controls bullet"><span class="by">trentnelson</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41491530">parent</a><span>|</span><a href="#41492087">next</a><span>|</span><label class="collapse" for="c-41491993">[-]</label><label class="expand" for="c-41491993">[4 more]</label></div><br/><div class="children"><div class="content">I should do an updated version of that deck with io_uring and sans the PyParallel element.  I still think it’s a good resource for depicting the differences in I&#x2F;O between NT &amp; UNIX.<p>And yeah, IOCP has implicit awareness of concurrency, and can schedule optimal threads to service a port automatically.  There hasn’t been a way to do that on UNIX until io_uring.</div><br/><div id="41492306" class="c"><input type="checkbox" id="c-41492306" checked=""/><div class="controls bullet"><span class="by">nullindividual</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41491993">parent</a><span>|</span><a href="#41492087">next</a><span>|</span><label class="collapse" for="c-41492306">[-]</label><label class="expand" for="c-41492306">[3 more]</label></div><br/><div class="children"><div class="content">Yes, please! And if you&#x27;re interested, RegisteredIO and I assume you&#x27;d drop in IoRing.<p>In a nicely wrapped PDF :-)</div><br/><div id="41492469" class="c"><input type="checkbox" id="c-41492469" checked=""/><div class="controls bullet"><span class="by">trentnelson</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41492306">parent</a><span>|</span><a href="#41492087">next</a><span>|</span><label class="collapse" for="c-41492469">[-]</label><label class="expand" for="c-41492469">[2 more]</label></div><br/><div class="children"><div class="content">Yeah I’d definitely include RegisteredIO and IoRing.  When I was interviewing at Microsoft a few years back, I was actually interviewed by the chap that wrote RegisteredIO!  Thought that was neat.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41492087" class="c"><input type="checkbox" id="c-41492087" checked=""/><div class="controls bullet"><span class="by">netbsdusers</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41491338">parent</a><span>|</span><a href="#41491417">prev</a><span>|</span><a href="#41496961">next</a><span>|</span><label class="collapse" for="c-41492087">[-]</label><label class="expand" for="c-41492087">[1 more]</label></div><br/><div class="children"><div class="content">Posix AIO is just an interface. Windows also relies on thread pools for some async io (I.e. when reading files when all the data necessary to generate a disk request isn&#x27;t in cache - good luck writing <i>that</i> as purely asynchronous)</div><br/></div></div></div></div><div id="41496961" class="c"><input type="checkbox" id="c-41496961" checked=""/><div class="controls bullet"><span class="by">a-dub</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41491254">parent</a><span>|</span><a href="#41491338">prev</a><span>|</span><a href="#41492518">next</a><span>|</span><label class="collapse" for="c-41496961">[-]</label><label class="expand" for="c-41496961">[1 more]</label></div><br/><div class="children"><div class="content">notably the NT equivalent of select(): WaitForSingleObject and WaitForMultipleObjects had a benefit that one select&#x2F;wait type syscall could be tickled by any of a network, file or the NT equivalent of a pthread signal.</div><br/></div></div><div id="41492518" class="c"><input type="checkbox" id="c-41492518" checked=""/><div class="controls bullet"><span class="by">trentnelson</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41491254">parent</a><span>|</span><a href="#41496961">prev</a><span>|</span><a href="#41491348">next</a><span>|</span><label class="collapse" for="c-41492518">[-]</label><label class="expand" for="c-41492518">[1 more]</label></div><br/><div class="children"><div class="content">None of the UNIXes have the notion of WriteFile with an OVERLAPPED structure, that’s the key to NT’s asynchronous I&#x2F;O.<p>Nor do they have anything like IOCP, where the kernel is aware of the number of threads servicing a completion port, and can make sure you only have as many threads running as there are underlying cores, avoiding context switches.  If you write your programs to leverage these facilities (which are very unique to NT), you can max perform your hardware very nicely.</div><br/></div></div></div></div><div id="41491722" class="c"><input type="checkbox" id="c-41491722" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#41490688">parent</a><span>|</span><a href="#41491254">prev</a><span>|</span><a href="#41494134">next</a><span>|</span><label class="collapse" for="c-41491722">[-]</label><label class="expand" for="c-41491722">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The processes section should be expanded upon. The NT kernel doesn&#x27;t execute processes, it executes _threads_. Threads can be created in a few milliseconds where as noted, processes are heavy weight; essentially the opposite of Unicies. This is a big distinction.<p>I am not sure what point you are attempting to make here. As written, it is more or less completely wrong.<p>NT and Unix kernels both execute threads. Threads can be created in a few microseconds. Processes are heavy weight on both NT and Unix kernels.<p>The only thing I can think of is the long-standing idea that Unix tends to encourage creating new processes and Windows-related OS kernels tend to encourage creating new threads. This is not false - process creation on Windows-related OS kernels is an extremely heavyweight process, certainly comparing it with any Unix. But it doesn&#x27;t make the quote from you above correct.<p>On a separate note, the state of things at the point of creation of NT is really of very little interest other than than to computer historians. It has been more than 30 years, and every still-available Unix and presumably NT have continued to evolve since then. Linux has dozens to hundreds of design features in it that did not exist in any Unix when NT was released (and did not exist in NT either).</div><br/><div id="41493961" class="c"><input type="checkbox" id="c-41493961" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41491722">parent</a><span>|</span><a href="#41494134">next</a><span>|</span><label class="collapse" for="c-41493961">[-]</label><label class="expand" for="c-41493961">[3 more]</label></div><br/><div class="children"><div class="content">Processes and threads on NT are distinct nominative types of objects (in a system where “object” has a much more precise meaning) and the GP is at least correct that the former are not schedulable entities. This distinction doesn’t really exist on Linux for instance where there are at one approximation on the user side <i>only</i> processes (at least to use the verbiage of the clone syscall - look elsewhere and they’re threads in part due to having to support pthreads), and the scheduler schedules “tasks” (task_struct) (whereas in NT the “thread” nomenclature carries throughout). FreeBSD may have separate thread and proc internally but this is more an implementation detail. I guess this all to say at the level lower than an API like pthreads, process&#x2F;thread really isn’t easily comparable between NT and most Unixes.<p>It’s not so much “heavyweight” vs “lightweight” but that NT has been by design more limited in how you can create new virtual memory spaces.<p>For better or worse NT tied the creation of VM spaces to this relatively expensive object to create which has made emulating Unix like behavior historically a pain in the ass.</div><br/><div id="41494960" class="c"><input type="checkbox" id="c-41494960" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41493961">parent</a><span>|</span><a href="#41494134">next</a><span>|</span><label class="collapse" for="c-41494960">[-]</label><label class="expand" for="c-41494960">[2 more]</label></div><br/><div class="children"><div class="content">pthreads is a user-space API, and has nothing to do with the kernel. It is possible to implement pthreads entirely in user space (though somewhat horrific to do so). Linux does not have kernel threads in order to support pthreads (though they help).<p>Anyway, I see your point about the bleed between the different semantics of a task_t in the linux kernel.</div><br/><div id="41495464" class="c"><input type="checkbox" id="c-41495464" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41494960">parent</a><span>|</span><a href="#41494134">next</a><span>|</span><label class="collapse" for="c-41495464">[-]</label><label class="expand" for="c-41495464">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Linux does not have kernel threads in order to support pthreads<p>Yes, what I was alluding to somewhat cryptically was things like tgids and the related tkill&#x2F;tgkill syscalls that as far I am aware were added with the implementation of 1:1 pthread support in mind.</div><br/></div></div></div></div></div></div></div></div><div id="41494134" class="c"><input type="checkbox" id="c-41494134" checked=""/><div class="controls bullet"><span class="by">lr1970</span><span>|</span><a href="#41490688">parent</a><span>|</span><a href="#41491722">prev</a><span>|</span><a href="#41492511">next</a><span>|</span><label class="collapse" for="c-41494134">[-]</label><label class="expand" for="c-41494134">[3 more]</label></div><br/><div class="children"><div class="content">&gt; It should also be noted that while NT as a product is much newer than Unicies, it&#x27;s history is rooted in VMS fundamentals thanks to it&#x27;s core team of ex-Digital devs lead by David Cutler.<p>WNT = VMS + 1 (next letter in alphabet for all three)</div><br/><div id="41494298" class="c"><input type="checkbox" id="c-41494298" checked=""/><div class="controls bullet"><span class="by">amatwl</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41494134">parent</a><span>|</span><a href="#41492511">next</a><span>|</span><label class="collapse" for="c-41494298">[-]</label><label class="expand" for="c-41494298">[2 more]</label></div><br/><div class="children"><div class="content">For the record, NT comes from the codename for the Intel i860 (N10) which was the original target platform for NT.</div><br/><div id="41494964" class="c"><input type="checkbox" id="c-41494964" checked=""/><div class="controls bullet"><span class="by">nullindividual</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41494298">parent</a><span>|</span><a href="#41492511">next</a><span>|</span><label class="collapse" for="c-41494964">[-]</label><label class="expand" for="c-41494964">[1 more]</label></div><br/><div class="children"><div class="content">This is incorrect per David Cutler.<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=xi1Lq79mLeE&amp;t=4314s" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=xi1Lq79mLeE&amp;t=4314s</a></div><br/></div></div></div></div></div></div><div id="41492511" class="c"><input type="checkbox" id="c-41492511" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#41490688">parent</a><span>|</span><a href="#41494134">prev</a><span>|</span><a href="#41495527">next</a><span>|</span><label class="collapse" for="c-41492511">[-]</label><label class="expand" for="c-41492511">[2 more]</label></div><br/><div class="children"><div class="content">Threads aren&#x27;t created in milliseconds, that would be really slow.  It&#x27;s more like microseconds.</div><br/><div id="41492609" class="c"><input type="checkbox" id="c-41492609" checked=""/><div class="controls bullet"><span class="by">nullindividual</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41492511">parent</a><span>|</span><a href="#41495527">next</a><span>|</span><label class="collapse" for="c-41492609">[-]</label><label class="expand" for="c-41492609">[1 more]</label></div><br/><div class="children"><div class="content">Typo, thanks for the correction. Too late to edit :-)</div><br/></div></div></div></div><div id="41495527" class="c"><input type="checkbox" id="c-41495527" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#41490688">parent</a><span>|</span><a href="#41492511">prev</a><span>|</span><a href="#41491249">next</a><span>|</span><label class="collapse" for="c-41495527">[-]</label><label class="expand" for="c-41495527">[1 more]</label></div><br/><div class="children"><div class="content">Process is a way to segregate resources (memory, sockets, file descriptors, etc). 
You kill a proc - it will release all memory and file descriptors.<p>Thread is a way to segregate computation. You spawn a thread and it will run some code scheduled by the OS. you kill&#x2F;stop a thread and it will stop computation, but not the resources.</div><br/></div></div><div id="41491384" class="c"><input type="checkbox" id="c-41491384" checked=""/><div class="controls bullet"><span class="by">formerly_proven</span><span>|</span><a href="#41490688">parent</a><span>|</span><a href="#41491249">prev</a><span>|</span><a href="#41492935">next</a><span>|</span><label class="collapse" for="c-41491384">[-]</label><label class="expand" for="c-41491384">[2 more]</label></div><br/><div class="children"><div class="content">&gt; There&#x27;s a large debate whether a &#x27;hybrid&#x27; kernel is an actual thing, and&#x2F;or whether NT is just a monolithic kernel.<p>I don&#x27;t think it&#x27;s a concept that meaningfully exists. Microkernels are primarily concerned with isolating non-executive functions (e.g. device drivers) for stability and&#x2F;or security (POLA) reasons. NT achieves virtually none of that (see e.g. Crowdstrike). The fact that Windows ships a thin user-mode syscall shim which largely consists of thin-to-nonexistent wrappers of NtXXX functions is architecturally uninteresting at best. Arguably binfmt_misc would then also make Linux a hybrid kernel.</div><br/><div id="41496815" class="c"><input type="checkbox" id="c-41496815" checked=""/><div class="controls bullet"><span class="by">hernandipietro</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41491384">parent</a><span>|</span><a href="#41492935">next</a><span>|</span><label class="collapse" for="c-41496815">[-]</label><label class="expand" for="c-41496815">[1 more]</label></div><br/><div class="children"><div class="content">Originally, Windows NT 3.x was more &quot;microkernelithic&quot; as graphics and printer drivers where isolated.  NT 4 moved them to Kernel mode to speedup the system.</div><br/></div></div></div></div><div id="41492935" class="c"><input type="checkbox" id="c-41492935" checked=""/><div class="controls bullet"><span class="by">qsdf38100</span><span>|</span><a href="#41490688">parent</a><span>|</span><a href="#41491384">prev</a><span>|</span><a href="#41496878">next</a><span>|</span><label class="collapse" for="c-41492935">[-]</label><label class="expand" for="c-41492935">[7 more]</label></div><br/><div class="children"><div class="content">WNT is VMS+1<p>V-&gt;W<p>N-&gt;M<p>S-&gt;T</div><br/><div id="41498634" class="c"><input type="checkbox" id="c-41498634" checked=""/><div class="controls bullet"><span class="by">revskill</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41492935">parent</a><span>|</span><a href="#41492945">next</a><span>|</span><label class="collapse" for="c-41498634">[-]</label><label class="expand" for="c-41498634">[1 more]</label></div><br/><div class="children"><div class="content">Could you please explain on those characters ? What do they mean ? Thnks.</div><br/></div></div><div id="41492945" class="c"><input type="checkbox" id="c-41492945" checked=""/><div class="controls bullet"><span class="by">nullindividual</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41492935">parent</a><span>|</span><a href="#41498634">prev</a><span>|</span><a href="#41493826">next</a><span>|</span><label class="collapse" for="c-41492945">[-]</label><label class="expand" for="c-41492945">[4 more]</label></div><br/><div class="children"><div class="content">&gt; <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=xi1Lq79mLeE&amp;t=4314s" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=xi1Lq79mLeE&amp;t=4314s</a><p>&quot;New Technology&quot;, but yes, it&#x27;s funny</div><br/><div id="41494558" class="c"><input type="checkbox" id="c-41494558" checked=""/><div class="controls bullet"><span class="by">JeremyNT</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41492945">parent</a><span>|</span><a href="#41493113">next</a><span>|</span><label class="collapse" for="c-41494558">[-]</label><label class="expand" for="c-41494558">[1 more]</label></div><br/><div class="children"><div class="content">One of my very favorite facts about Windows 2000, as revealed in its boot screen, is that it&#x27;s based on New Technology Technology.<p>(I no longer work with Windows very much, but this little bit of trivia has stuck with me over the years)</div><br/></div></div><div id="41493113" class="c"><input type="checkbox" id="c-41493113" checked=""/><div class="controls bullet"><span class="by">steve1977</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41492945">parent</a><span>|</span><a href="#41494558">prev</a><span>|</span><a href="#41493826">next</a><span>|</span><label class="collapse" for="c-41493113">[-]</label><label class="expand" for="c-41493113">[2 more]</label></div><br/><div class="children"><div class="content">Initially actually (afaik) it stood for N10, for the Intel i860 CPU. I think “New Technology” came from marketing then.</div><br/><div id="41493276" class="c"><input type="checkbox" id="c-41493276" checked=""/><div class="controls bullet"><span class="by">nullindividual</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41493113">parent</a><span>|</span><a href="#41493826">next</a><span>|</span><label class="collapse" for="c-41493276">[-]</label><label class="expand" for="c-41493276">[1 more]</label></div><br/><div class="children"><div class="content">If you watch the interview with David Cutler to the time code I linked to, he explains that NT stands for New Technology which marketing <i>did not</i> want.</div><br/></div></div></div></div></div></div><div id="41493826" class="c"><input type="checkbox" id="c-41493826" checked=""/><div class="controls bullet"><span class="by">pmontra</span><span>|</span><a href="#41490688">root</a><span>|</span><a href="#41492935">parent</a><span>|</span><a href="#41492945">prev</a><span>|</span><a href="#41496878">next</a><span>|</span><label class="collapse" for="c-41493826">[-]</label><label class="expand" for="c-41493826">[1 more]</label></div><br/><div class="children"><div class="content">Actually<p>M-&gt;N</div><br/></div></div></div></div></div></div><div id="41496878" class="c"><input type="checkbox" id="c-41496878" checked=""/><div class="controls bullet"><span class="by">phibz</span><span>|</span><a href="#41490688">prev</a><span>|</span><a href="#41495584">next</a><span>|</span><label class="collapse" for="c-41496878">[-]</label><label class="expand" for="c-41496878">[1 more]</label></div><br/><div class="children"><div class="content">The article hit on some great high points of difference. But I feel like it misses Cutler and team&#x27;s history with OpenVMS and MICA. The hallmarks of their design are all over NT. With that context it reads less like NT was avoiding UNIX&#x27;s mistakes and more like it was built on years of learning from the various DEC offerings.</div><br/></div></div><div id="41495584" class="c"><input type="checkbox" id="c-41495584" checked=""/><div class="controls bullet"><span class="by">Const-me</span><span>|</span><a href="#41496878">prev</a><span>|</span><a href="#41491291">next</a><span>|</span><label class="collapse" for="c-41495584">[-]</label><label class="expand" for="c-41495584">[13 more]</label></div><br/><div class="children"><div class="content">I would add that on modern WinNT, Direct3D is an essential part of the kernel, see dxgkrnl.sys. This means D3D11 is guaranteed to be available. This is true even without any GPU, Windows comes with a software fallback called WARP.<p>This allows user-space processes to easily manipulate GPU resources, share them between processes if they want, and powers higher level technologies like Direct2D and Media Foundation.<p>Linux doesn’t have a good equivalent for these. Technically Linux has dma-buf subsystem which allows to share stuff between processes. Unfortunately, that thing is much harder to use than D3D, and very specific to particular drivers who export these buffers.</div><br/><div id="41495924" class="c"><input type="checkbox" id="c-41495924" checked=""/><div class="controls bullet"><span class="by">movedx</span><span>|</span><a href="#41495584">parent</a><span>|</span><a href="#41491291">next</a><span>|</span><label class="collapse" for="c-41495924">[-]</label><label class="expand" for="c-41495924">[12 more]</label></div><br/><div class="children"><div class="content">But why should Linux have an equivalent of such features?</div><br/><div id="41495985" class="c"><input type="checkbox" id="c-41495985" checked=""/><div class="controls bullet"><span class="by">lelandbatey</span><span>|</span><a href="#41495584">root</a><span>|</span><a href="#41495924">parent</a><span>|</span><a href="#41491291">next</a><span>|</span><label class="collapse" for="c-41495985">[-]</label><label class="expand" for="c-41495985">[11 more]</label></div><br/><div class="children"><div class="content">Why should a kernel have anything? Because it&#x27;s useful and convenient, as the OP mentioned.</div><br/><div id="41496213" class="c"><input type="checkbox" id="c-41496213" checked=""/><div class="controls bullet"><span class="by">movedx</span><span>|</span><a href="#41495584">root</a><span>|</span><a href="#41495985">parent</a><span>|</span><a href="#41491291">next</a><span>|</span><label class="collapse" for="c-41496213">[-]</label><label class="expand" for="c-41496213">[10 more]</label></div><br/><div class="children"><div class="content">It _can be_ useful. It can also _not_ be useful to others. It sounds like it&#x27;s not a choice in this case, but a forced feature, and that&#x27;s fine for some and not for others.<p>So again, why _must_ Linux have an equivalent?</div><br/><div id="41496392" class="c"><input type="checkbox" id="c-41496392" checked=""/><div class="controls bullet"><span class="by">scoodah</span><span>|</span><a href="#41495584">root</a><span>|</span><a href="#41496213">parent</a><span>|</span><a href="#41496577">next</a><span>|</span><label class="collapse" for="c-41496392">[-]</label><label class="expand" for="c-41496392">[3 more]</label></div><br/><div class="children"><div class="content">No one used the word must until you right now. The OP comment was posting a valid thing that Windows has that Linux does not. It’s fine if Linux doesn’t have it but I don’t understand where you’re coming from as presenting this as though someone said Linux must have this.</div><br/><div id="41497109" class="c"><input type="checkbox" id="c-41497109" checked=""/><div class="controls bullet"><span class="by">movedx</span><span>|</span><a href="#41495584">root</a><span>|</span><a href="#41496392">parent</a><span>|</span><a href="#41496577">next</a><span>|</span><label class="collapse" for="c-41497109">[-]</label><label class="expand" for="c-41497109">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Linux doesn’t have a good equivalent for these.<p>That implies Linux must or should have an equivalent to those features found in Windows -- you can choose any word you like, friend. There is no other reason to make that statement but to challenge the fact Linux doesn&#x27;t have those options.<p>Fun fact: I switched to Kubuntu recently and I didn&#x27;t even have to install a graphics driver. It was just there, just worked, and my AMD 7700 XTX is working fine and playing Windows &quot;only&quot; games via Proton just fine as well as Linux native games just fine.<p>I&#x27;m simply trying to get people to think about design choices and questioning or stating why one thing is better than another.</div><br/><div id="41498549" class="c"><input type="checkbox" id="c-41498549" checked=""/><div class="controls bullet"><span class="by">alt227</span><span>|</span><a href="#41495584">root</a><span>|</span><a href="#41497109">parent</a><span>|</span><a href="#41496577">next</a><span>|</span><label class="collapse" for="c-41498549">[-]</label><label class="expand" for="c-41498549">[1 more]</label></div><br/><div class="children"><div class="content">Dont read into the text too much, this doesnt imply what you are saying at all.<p>The reason to make that statement is to point out that there are differences in functionality.<p>Nobody in the thread said one situation was better than the other, until you did.</div><br/></div></div></div></div></div></div><div id="41496577" class="c"><input type="checkbox" id="c-41496577" checked=""/><div class="controls bullet"><span class="by">Dalewyn</span><span>|</span><a href="#41495584">root</a><span>|</span><a href="#41496213">parent</a><span>|</span><a href="#41496392">prev</a><span>|</span><a href="#41491291">next</a><span>|</span><label class="collapse" for="c-41496577">[-]</label><label class="expand" for="c-41496577">[6 more]</label></div><br/><div class="children"><div class="content">This line of thought is <i>precisely</i> why Linux continues to falter in mainstream acceptance.<p>Windows exists to enable the user to do whatever he wants. If the user wants to play a game or watch a video, Direct3D is there to let him do that. If he doesn&#x27;t, Direct3D doesn&#x27;t get in the way.<p>This is far better than Linux&#x27;s (neckbeards&#x27;?) philosophy of <i>Thou Shalt Not Divert From The One True Path</i> which will inevitably inconvenience many people and lead to, you guessed it, failure in the mainstream market.<p>Contrast Android, which took Linux and re-packaged it in a more Windows-like way so people could actually use the bloody thing.</div><br/><div id="41498552" class="c"><input type="checkbox" id="c-41498552" checked=""/><div class="controls bullet"><span class="by">SoothingSorbet</span><span>|</span><a href="#41495584">root</a><span>|</span><a href="#41496577">parent</a><span>|</span><a href="#41497046">next</a><span>|</span><label class="collapse" for="c-41498552">[-]</label><label class="expand" for="c-41498552">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Windows exists to enable the user to do whatever he wants<p>It&#x27;s very bad at that, then, considering it insists on getting in my way any time I want to do something (_especially_ something off of the beaten path).<p>&gt; If the user wants to play a game or watch a video, Direct3D is there to let him do that. If he doesn&#x27;t, Direct3D doesn&#x27;t get in the way.<p>I don&#x27;t see what the point you are trying to make is, this is no different on Linux. What does D3D being in the kernel have to do with _anything_? You can have a software rasterizer on Linux too. You can play games and watch videos. Your message is incoherent.</div><br/></div></div><div id="41497046" class="c"><input type="checkbox" id="c-41497046" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#41495584">root</a><span>|</span><a href="#41496577">parent</a><span>|</span><a href="#41498552">prev</a><span>|</span><a href="#41497097">next</a><span>|</span><label class="collapse" for="c-41497046">[-]</label><label class="expand" for="c-41497046">[1 more]</label></div><br/><div class="children"><div class="content">Not to contradict but it seems to me that *nixes have always split user interaction and &#x27;compute&#x27;. To them running a headless toaster is probably more valuable than a desktop UI.</div><br/></div></div><div id="41497097" class="c"><input type="checkbox" id="c-41497097" checked=""/><div class="controls bullet"><span class="by">movedx</span><span>|</span><a href="#41495584">root</a><span>|</span><a href="#41496577">parent</a><span>|</span><a href="#41497046">prev</a><span>|</span><a href="#41491291">next</a><span>|</span><label class="collapse" for="c-41497097">[-]</label><label class="expand" for="c-41497097">[3 more]</label></div><br/><div class="children"><div class="content">&gt; If the user wants to play a game or watch a video, Direct3D is there to let him do that. If he doesn&#x27;t, Direct3D doesn&#x27;t get in the way.<p>I _just_ moved from Windows 11 to Kubuntu. None of that stuff is missing. In fact, unlike Windows 10&#x2F;11, I didn&#x27;t even have to install a graphics driver. My AMD 7700 XTX literally just worked right out of the box. Instantly. Ironically that’s not the case for Windows 10&#x2F;11. This isn’t a “My OS is better than your OS” debate — we’re talking about why D3D being integrated into the kernel is a good idea. I’m playing devil’s advocate.<p>And thus, you missed my point: &quot;Why should Linux have an equivalent to Direct3D&quot; isn&#x27;t me arguing that Windows having it is bad, it&#x27;s me asking people to think about design choices and consider whether they&#x27;re good or bad.<p>&gt; This is far better than Linux&#x27;s (neckbeards&#x27;?) philosophy of Thou Shalt Not Divert From The One True Path which will inevitably inconvenience many people and lead to, you guessed it, failure in the mainstream market.<p>If you think Windows having Direct3D &quot;built in&quot; is why it has mainstream dominance, then you potentially have a very narrow view of history, market timing, economics, politics, and a whole range of other topics that actually led to the dominance of Windows.</div><br/><div id="41498343" class="c"><input type="checkbox" id="c-41498343" checked=""/><div class="controls bullet"><span class="by">Hikikomori</span><span>|</span><a href="#41495584">root</a><span>|</span><a href="#41497097">parent</a><span>|</span><a href="#41491291">next</a><span>|</span><label class="collapse" for="c-41498343">[-]</label><label class="expand" for="c-41498343">[2 more]</label></div><br/><div class="children"><div class="content">&gt;I _just_ moved from Windows 11 to Kubuntu. None of that stuff is missing. In fact, unlike Windows 10&#x2F;11, I didn&#x27;t even have to install a graphics driver. My AMD 7700 XTX literally just worked right out of the box. Instantly. Ironically that’s not the case for Windows 10&#x2F;11.<p>How did you install a driver on windows if your gpu didn&#x27;t work out of the box?</div><br/><div id="41498536" class="c"><input type="checkbox" id="c-41498536" checked=""/><div class="controls bullet"><span class="by">SoothingSorbet</span><span>|</span><a href="#41495584">root</a><span>|</span><a href="#41498343">parent</a><span>|</span><a href="#41491291">next</a><span>|</span><label class="collapse" for="c-41498536">[-]</label><label class="expand" for="c-41498536">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure Windows is perfectly capable of driving a GOP framebuffer. That doesn&#x27;t mean the kernel has an actual GPU driver.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41491291" class="c"><input type="checkbox" id="c-41491291" checked=""/><div class="controls bullet"><span class="by">kev009</span><span>|</span><a href="#41495584">prev</a><span>|</span><a href="#41498126">next</a><span>|</span><label class="collapse" for="c-41491291">[-]</label><label class="expand" for="c-41491291">[37 more]</label></div><br/><div class="children"><div class="content">This is great!  It would be interesting to see darwin&#x2F;macos in the mix.<p>On the philosophical side, one thing to consider is that NT is in effect a third system and therefore avoided some of the proverbial second system syndrome.. Cutler had been instrumental in building at least two prior operating systems (including the anti-UNIX.. VMS) and Microsoft was keen to divorce itself from OS&#x2F;2.<p>With the benefit of hindsight and to clear some misconceptions, OS&#x2F;2 was actually a nice system but was somewhat doomed both technically and organizationally.  Technically, it solved the wrong problem.. it occupies a basically unwanted niche above DOS and below multiuser systems like UNIX and NT.. the same niche that BeOS and classic Mac OS occupied.  Organizationally&#x2F;politically, for a short period it &#x2F;was&#x2F; a &quot;better DOS than DOS and better Windows than Windows&quot; with VM86 and Win API support, but as soon as Microsoft reclaimed their clown car of APIs and apps it would forever be playing second fiddle and IBM management never acknowledged this reality.  And that compatibility problem was still a hard one for Microsoft to deal with, remember that NT was not ubiquitous until Windows XP despite being a massive improvement.</div><br/><div id="41492212" class="c"><input type="checkbox" id="c-41492212" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#41491291">parent</a><span>|</span><a href="#41491579">next</a><span>|</span><label class="collapse" for="c-41492212">[-]</label><label class="expand" for="c-41492212">[10 more]</label></div><br/><div class="children"><div class="content">That “niche” you described was actually a desktop computing norm form more than a decade.<p>Let’s also not forget RISC OS, Atari TOS, AmigaOS, GEOS, SkyOS and numerous DOS frontends including, but not limited to, Microsoft Windows.</div><br/><div id="41495611" class="c"><input type="checkbox" id="c-41495611" checked=""/><div class="controls bullet"><span class="by">kev009</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41492212">parent</a><span>|</span><a href="#41492479">next</a><span>|</span><label class="collapse" for="c-41495611">[-]</label><label class="expand" for="c-41495611">[5 more]</label></div><br/><div class="children"><div class="content">I believe we are obliquely agreeing.<p>To further my thoughts a bit, the distinction I would place on OS&#x2F;2 over DOS is double:  1) first class memory protection 2) full preemptive multitasking.  The distinction I would place against all widely used modern desktop OSes is the lack of first class multi-user support.<p>Early Windows gains cooperative multi-tasking like Mac OS classic but neither fundamentally use memory protection the way later OSes normalize and that turns out to be a pretty clear dead end.  I believe there are extensions for both that retrofit protection in.  Both also have some add on approaches to multi-user but are not first class designs.<p>So, even the most robust single user system that implements full memory protection and preemptive multitasking still seems to be stuck in a valley.  I.e. whatever the actual cost in terms of implementation and increase in cognitive workload for single user systems (i.e. &quot;enter your administrative password&quot; prompts on current macOS or Windows administrative accept dialogs) seems to be accepted by the masses.<p>And note that this isn&#x27;t an implicit a negative judgement, for instance I find BeOS or those in your list can be absolutely fascinating.  And OS&#x2F;2 is lovely even today for certain niche or retrocomputing things.  Just pointing out that NT made a better bet for the long term, and some of that undoubtedly related to the difference of a couple years.. keep in mind OS&#x2F;2 ran on a 286, which NT completely bypassed.</div><br/><div id="41495850" class="c"><input type="checkbox" id="c-41495850" checked=""/><div class="controls bullet"><span class="by">nullindividual</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41495611">parent</a><span>|</span><a href="#41492479">next</a><span>|</span><label class="collapse" for="c-41495850">[-]</label><label class="expand" for="c-41495850">[4 more]</label></div><br/><div class="children"><div class="content">Windows 2.0 for i386 was the first to introduce protected mode and preemptive multitasking. These features had to wait for Intel but it was available in 1987.</div><br/><div id="41496043" class="c"><input type="checkbox" id="c-41496043" checked=""/><div class="controls bullet"><span class="by">kev009</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41495850">parent</a><span>|</span><a href="#41492479">next</a><span>|</span><label class="collapse" for="c-41496043">[-]</label><label class="expand" for="c-41496043">[3 more]</label></div><br/><div class="children"><div class="content">In a limited sense, yes, Windows (without NT) increasingly &#x2F;used&#x2F; memory protection hardware over its life but never in a holistic approach as we typically understand today to create a TCB.<p>I don&#x27;t believe Windows 2.0 implemented preemptive tasking, can you show a reference so I can learn?</div><br/><div id="41497273" class="c"><input type="checkbox" id="c-41497273" checked=""/><div class="controls bullet"><span class="by">jazzypants</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41496043">parent</a><span>|</span><a href="#41497000">prev</a><span>|</span><a href="#41492479">next</a><span>|</span><label class="collapse" for="c-41497273">[-]</label><label class="expand" for="c-41497273">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not that guy, but the Wikipedia article[1] is a decent jumping-off point, but I also found this blog article[2] talking about the different versions-- although it seems to get a couple things wrong according to discussion about it on lobste.rs[3] Finally, this long article from Another Boring Topic [4] includes several great sources.<p>1 - <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Windows_2.0#Release_versions" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Windows_2.0#Release_versions</a><p>2 - <a href="https:&#x2F;&#x2F;liam-on-linux.livejournal.com&#x2F;78006.html" rel="nofollow">https:&#x2F;&#x2F;liam-on-linux.livejournal.com&#x2F;78006.html</a><p>3 - <a href="https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;4xfswa&#x2F;what_was_difference_between_windows" rel="nofollow">https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;4xfswa&#x2F;what_was_difference_between_windo...</a><p>4 - <a href="https:&#x2F;&#x2F;anotherboringtopic.substack.com&#x2F;p&#x2F;the-rise-of-microsoft-windows-2x" rel="nofollow">https:&#x2F;&#x2F;anotherboringtopic.substack.com&#x2F;p&#x2F;the-rise-of-micros...</a></div><br/></div></div></div></div></div></div></div></div><div id="41492479" class="c"><input type="checkbox" id="c-41492479" checked=""/><div class="controls bullet"><span class="by">nullindividual</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41492212">parent</a><span>|</span><a href="#41495611">prev</a><span>|</span><a href="#41495929">next</a><span>|</span><label class="collapse" for="c-41492479">[-]</label><label class="expand" for="c-41492479">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t Windows more abstract than just a frontend[0]? I.e., Windows&#x2F;386 added protected mode and other features.<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Microsoft_Windows#Early_versions" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Microsoft_Windows#Early_versio...</a></div><br/><div id="41493370" class="c"><input type="checkbox" id="c-41493370" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41492479">parent</a><span>|</span><a href="#41495929">next</a><span>|</span><label class="collapse" for="c-41493370">[-]</label><label class="expand" for="c-41493370">[1 more]</label></div><br/><div class="children"><div class="content">To be honest I was being flippant with that Windows remark but you’re right to call me out for it.<p>Microsoft get a lot of stick but Windows of the 90s do bring a lot to table. And by 9x DOS was basically a boot loader.</div><br/></div></div></div></div><div id="41495929" class="c"><input type="checkbox" id="c-41495929" checked=""/><div class="controls bullet"><span class="by">hypercube33</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41492212">parent</a><span>|</span><a href="#41492479">prev</a><span>|</span><a href="#41491579">next</a><span>|</span><label class="collapse" for="c-41495929">[-]</label><label class="expand" for="c-41495929">[2 more]</label></div><br/><div class="children"><div class="content">How dare you ignore BeOS which isn&#x27;t Windows or Nix</div><br/><div id="41498009" class="c"><input type="checkbox" id="c-41498009" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41495929">parent</a><span>|</span><a href="#41491579">next</a><span>|</span><label class="collapse" for="c-41498009">[-]</label><label class="expand" for="c-41498009">[1 more]</label></div><br/><div class="children"><div class="content">It had already been mentioned and the point of my post was to give other examples</div><br/></div></div></div></div></div></div><div id="41491579" class="c"><input type="checkbox" id="c-41491579" checked=""/><div class="controls bullet"><span class="by">nullindividual</span><span>|</span><a href="#41491291">parent</a><span>|</span><a href="#41492212">prev</a><span>|</span><a href="#41492312">next</a><span>|</span><label class="collapse" for="c-41491579">[-]</label><label class="expand" for="c-41491579">[15 more]</label></div><br/><div class="children"><div class="content">&gt; And that compatibility problem was still a hard one for Microsoft to deal with, remember that NT was not ubiquitous until Windows XP despite being a massive improvement.<p>I think when it comes to this it is best to remember the home computing landscape of the time, and the most important part: DRAM prices.<p>They were absurdly high and NT4&#x2F;2000 required more of it.<p>My assumption is Microsoft would have made the NT4&#x2F;2000 jump much quicker if DRAM prices were driven in a downward direction.</div><br/><div id="41492259" class="c"><input type="checkbox" id="c-41492259" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41491579">parent</a><span>|</span><a href="#41491666">next</a><span>|</span><label class="collapse" for="c-41492259">[-]</label><label class="expand" for="c-41492259">[5 more]</label></div><br/><div class="children"><div class="content">DOS compatibility was a far bigger issue.<p>PC gaming was, back then, still very DOS-centric. It wasn’t until the late 90s that games started to target Windows. And even then, people still had older games they wanted supported.</div><br/><div id="41495944" class="c"><input type="checkbox" id="c-41495944" checked=""/><div class="controls bullet"><span class="by">hypercube33</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41492259">parent</a><span>|</span><a href="#41494069">next</a><span>|</span><label class="collapse" for="c-41495944">[-]</label><label class="expand" for="c-41495944">[3 more]</label></div><br/><div class="children"><div class="content">NT 4 had NTVDM and it worked well enough. Quake 1, command and conquer, sim games for DOS and a bunch of other stuff worked just fine. You&#x27;d run into issues with timing on crappier games or some games that talked directly to soundcards I forget what the details were but you&#x27;d just not have audio.</div><br/><div id="41497480" class="c"><input type="checkbox" id="c-41497480" checked=""/><div class="controls bullet"><span class="by">nikau</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41495944">parent</a><span>|</span><a href="#41496161">next</a><span>|</span><label class="collapse" for="c-41497480">[-]</label><label class="expand" for="c-41497480">[1 more]</label></div><br/><div class="children"><div class="content">I had a gravis ultrasound at the time and remember having to cut the reset signal line on the card.<p>I could then initialise the card in DOS and reboot into NT without it being reset and losing settings.   Then some sketchy modified driver was able to use it.</div><br/></div></div><div id="41496161" class="c"><input type="checkbox" id="c-41496161" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41495944">parent</a><span>|</span><a href="#41497480">prev</a><span>|</span><a href="#41494069">next</a><span>|</span><label class="collapse" for="c-41496161">[-]</label><label class="expand" for="c-41496161">[1 more]</label></div><br/><div class="children"><div class="content">I remember NT4 having problems with games that wanted to access SVGA resolutions and SoundBlaster. I kept a volume with Win98 back then specifically for the games.</div><br/></div></div></div></div><div id="41494069" class="c"><input type="checkbox" id="c-41494069" checked=""/><div class="controls bullet"><span class="by">dspillett</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41492259">parent</a><span>|</span><a href="#41495944">prev</a><span>|</span><a href="#41491666">next</a><span>|</span><label class="collapse" for="c-41494069">[-]</label><label class="expand" for="c-41494069">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d say both. IIRC the DOS story was better under OS&#x2F;2 than NT, but the RAM requirements were higher (at least until XP).<p>To add a third prong: hardware support was a big issue too as it is for any consumer OS, with legacy hardware being an issue just as it can be today if not more so. This hit both NT and OS&#x2F;2 similarly.</div><br/></div></div></div></div><div id="41491666" class="c"><input type="checkbox" id="c-41491666" checked=""/><div class="controls bullet"><span class="by">euroderf</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41491579">parent</a><span>|</span><a href="#41492259">prev</a><span>|</span><a href="#41491702">next</a><span>|</span><label class="collapse" for="c-41491666">[-]</label><label class="expand" for="c-41491666">[1 more]</label></div><br/><div class="children"><div class="content">I recall DRAM prices restricting the uptake of OS&#x2F;2 also.</div><br/></div></div><div id="41491702" class="c"><input type="checkbox" id="c-41491702" checked=""/><div class="controls bullet"><span class="by">kev009</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41491579">parent</a><span>|</span><a href="#41491666">prev</a><span>|</span><a href="#41492312">next</a><span>|</span><label class="collapse" for="c-41491702">[-]</label><label class="expand" for="c-41491702">[8 more]</label></div><br/><div class="children"><div class="content">Definitely impactful for NT4, not for 2000.</div><br/><div id="41492122" class="c"><input type="checkbox" id="c-41492122" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41491702">parent</a><span>|</span><a href="#41492312">next</a><span>|</span><label class="collapse" for="c-41492122">[-]</label><label class="expand" for="c-41492122">[7 more]</label></div><br/><div class="children"><div class="content">Was very impactful in early days of 2000. Seeing 64 MiB &quot;used up&quot; by barely loaded NT5.0 beta&#x2F;RC was honestly a sort of chilling effect. But prices shortly fell and 128MB became accessible option, just in time for Windows XP to nail Windows 9x dead</div><br/><div id="41492290" class="c"><input type="checkbox" id="c-41492290" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41492122">parent</a><span>|</span><a href="#41492420">next</a><span>|</span><label class="collapse" for="c-41492290">[-]</label><label class="expand" for="c-41492290">[5 more]</label></div><br/><div class="children"><div class="content">128MB was pretty common by the time Windows 2000 was released. I could afford it and I wasn’t paid well at that time.<p>Plus Windows ME wasn’t exactly nimble either. People talk about the disaster that was Vista and Windows 8 but ME was a thousand times worse. Thank god Windows 2000 was an option.</div><br/><div id="41493148" class="c"><input type="checkbox" id="c-41493148" checked=""/><div class="controls bullet"><span class="by">somat</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41492290">parent</a><span>|</span><a href="#41492420">next</a><span>|</span><label class="collapse" for="c-41493148">[-]</label><label class="expand" for="c-41493148">[4 more]</label></div><br/><div class="children"><div class="content">My understanding is that ME from a technological point of view was 98 with NT drivers. It probably was a critical step in getting vendors to make NT drivers for all of their screwball consumer hardware, and this made XP, the &quot;move the consumers to the NT kernel&quot; step a success. The lack of drivers is also what made XP 64 bit edition so fraught with peril, but xp-64&#x2F;vista was probably critical for win7&#x27;s success for the same reason.<p>But yeah, what a turd of a system.</div><br/><div id="41494864" class="c"><input type="checkbox" id="c-41494864" checked=""/><div class="controls bullet"><span class="by">mepian</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41493148">parent</a><span>|</span><a href="#41492420">next</a><span>|</span><label class="collapse" for="c-41494864">[-]</label><label class="expand" for="c-41494864">[3 more]</label></div><br/><div class="children"><div class="content">98 was the one that introduced NT drivers (WDM).</div><br/><div id="41495956" class="c"><input type="checkbox" id="c-41495956" checked=""/><div class="controls bullet"><span class="by">hypercube33</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41494864">parent</a><span>|</span><a href="#41492420">next</a><span>|</span><label class="collapse" for="c-41495956">[-]</label><label class="expand" for="c-41495956">[2 more]</label></div><br/><div class="children"><div class="content">Didn&#x27;t it still use VXD drivers for a lot of stuff though?</div><br/><div id="41496172" class="c"><input type="checkbox" id="c-41496172" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41495956">parent</a><span>|</span><a href="#41492420">next</a><span>|</span><label class="collapse" for="c-41496172">[-]</label><label class="expand" for="c-41496172">[1 more]</label></div><br/><div class="children"><div class="content">Yes, because WDM support was limited. It only allowed synchronous requests and was really only suitable for USB or storage drivers.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41492420" class="c"><input type="checkbox" id="c-41492420" checked=""/><div class="controls bullet"><span class="by">nullindividual</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41492122">parent</a><span>|</span><a href="#41492290">prev</a><span>|</span><a href="#41492312">next</a><span>|</span><label class="collapse" for="c-41492420">[-]</label><label class="expand" for="c-41492420">[1 more]</label></div><br/><div class="children"><div class="content">It was roughly $1&#x2F;MB in 1999. Or about $250 USD with inflation in 2024 dollars for a 128MB DIMM.</div><br/></div></div></div></div></div></div></div></div><div id="41492312" class="c"><input type="checkbox" id="c-41492312" checked=""/><div class="controls bullet"><span class="by">netbsdusers</span><span>|</span><a href="#41491291">parent</a><span>|</span><a href="#41491579">prev</a><span>|</span><a href="#41491406">next</a><span>|</span><label class="collapse" for="c-41492312">[-]</label><label class="expand" for="c-41492312">[3 more]</label></div><br/><div class="children"><div class="content">The second system for Cutler was really Mica - he discusses its outrageous scope in his recent interview with Dave Plummer.</div><br/><div id="41492605" class="c"><input type="checkbox" id="c-41492605" checked=""/><div class="controls bullet"><span class="by">markus_zhang</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41492312">parent</a><span>|</span><a href="#41492408">next</a><span>|</span><label class="collapse" for="c-41492605">[-]</label><label class="expand" for="c-41492605">[1 more]</label></div><br/><div class="children"><div class="content">Dave Cutler is really someone I look up to and wish I could be (but could never be due to numerous reasons). I strongly resonate with what he said in &quot;Showstopper&quot;:<p><pre><code>  What I really wanted to do was work on computers, not apply them to problems.
</code></pre>
And he sticks to it for half of a century.</div><br/></div></div><div id="41492408" class="c"><input type="checkbox" id="c-41492408" checked=""/><div class="controls bullet"><span class="by">nullindividual</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41492312">parent</a><span>|</span><a href="#41492605">prev</a><span>|</span><a href="#41491406">next</a><span>|</span><label class="collapse" for="c-41492408">[-]</label><label class="expand" for="c-41492408">[1 more]</label></div><br/><div class="children"><div class="content">Link to interview: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=xi1Lq79mLeE" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=xi1Lq79mLeE</a><p>(<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=xi1Lq79mLeE&amp;t=4314s" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=xi1Lq79mLeE&amp;t=4314s</a> - yes, it stands for New Technology)</div><br/></div></div></div></div><div id="41491406" class="c"><input type="checkbox" id="c-41491406" checked=""/><div class="controls bullet"><span class="by">tivert</span><span>|</span><a href="#41491291">parent</a><span>|</span><a href="#41492312">prev</a><span>|</span><a href="#41498126">next</a><span>|</span><label class="collapse" for="c-41491406">[-]</label><label class="expand" for="c-41491406">[8 more]</label></div><br/><div class="children"><div class="content">&gt; This is great! It would be interesting to see darwin&#x2F;macos in the mix.<p>But that&#x27;s just another UNIX.</div><br/><div id="41491454" class="c"><input type="checkbox" id="c-41491454" checked=""/><div class="controls bullet"><span class="by">kev009</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41491406">parent</a><span>|</span><a href="#41498126">next</a><span>|</span><label class="collapse" for="c-41491454">[-]</label><label class="expand" for="c-41491454">[7 more]</label></div><br/><div class="children"><div class="content">Only in the user&#x27;s perception.  The implementation is nothing like UNIX, being a Mach2.5 derivative and later additions like DriverKit.</div><br/><div id="41493210" class="c"><input type="checkbox" id="c-41493210" checked=""/><div class="controls bullet"><span class="by">steve1977</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41491454">parent</a><span>|</span><a href="#41498126">next</a><span>|</span><label class="collapse" for="c-41493210">[-]</label><label class="expand" for="c-41493210">[6 more]</label></div><br/><div class="children"><div class="content">macOS <i>is</i> a proper UNIX. As was OSF&#x2F;1 (aka Digital UNIX aka Tru64 UNIX), which also had Mach 2.5 kernel.</div><br/><div id="41493553" class="c"><input type="checkbox" id="c-41493553" checked=""/><div class="controls bullet"><span class="by">kev009</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41493210">parent</a><span>|</span><a href="#41498126">next</a><span>|</span><label class="collapse" for="c-41493553">[-]</label><label class="expand" for="c-41493553">[5 more]</label></div><br/><div class="children"><div class="content">So is z&#x2F;OS.  UNIX branding under The Open Group is correctly focused on the user&#x27;s perception and has little to do with kernel implementation.  Mach is is no more UNIX than NT is VMS, to call one the other in this context of kernel discussion is reductionist and impedes correct understanding of the historical roots and critical differences.</div><br/><div id="41494591" class="c"><input type="checkbox" id="c-41494591" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41493553">parent</a><span>|</span><a href="#41498126">next</a><span>|</span><label class="collapse" for="c-41494591">[-]</label><label class="expand" for="c-41494591">[4 more]</label></div><br/><div class="children"><div class="content">OSF&#x2F;1 however was a complete Unix system, even if it based its kernel on Mach (at least partially because it offered a fast path to SMP and threading), and formed the BSD side of Unix wars.<p>And NeXTSTEP didn&#x27;t diverge too much that when OSX was released they updated the code base with last OSFMK release.</div><br/><div id="41496422" class="c"><input type="checkbox" id="c-41496422" checked=""/><div class="controls bullet"><span class="by">icedchai</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41494591">parent</a><span>|</span><a href="#41496106">next</a><span>|</span><label class="collapse" for="c-41496422">[-]</label><label class="expand" for="c-41496422">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;d say SunOS (4.x and earlier, not Solaris) was the BSD side of the Unix wars. For most of the 90&#x27;s, SunOS was the gold standard for a Unix workstation. I worked at a couple of early Internet providers and the users demanded Sun systems for shell accounts. Anything else was &quot;too weird&quot; and would often have trouble compiling open source software.</div><br/><div id="41497010" class="c"><input type="checkbox" id="c-41497010" checked=""/><div class="controls bullet"><span class="by">kev009</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41496422">parent</a><span>|</span><a href="#41496106">next</a><span>|</span><label class="collapse" for="c-41497010">[-]</label><label class="expand" for="c-41497010">[1 more]</label></div><br/><div class="children"><div class="content">Correct, SunOS is a descendant of BSD and was the most widely used and renowned one during that time.  And like you said, it was the gold standard for easy builds of most contemporary software and enthusiastic support.<p>DEC Ultrix is also BSD kin and IBM AOS and HP-BSD were intentionally vanilla BSDs.  There were some commercial BSDs like Mt Xinu and BSDi that were episodically relevant.<p>BSD proper was alive and well especially in the academic and research circles into the 1990s and we get the current derivatives like Net, Free, and Open which are direct kin.<p>Mach is regularly BSD-affined because BSD was a typically ported server but Mach is decidedly its own thing (as a simple and drastic counterexample, there was MkLinux and OS&#x2F;2 for PowerPC which had little to do with BSD but are very much Mach).  NeXTSTEP and eventually Darwin&#x2F;macOS inherit BSD affinity.</div><br/></div></div></div></div><div id="41496106" class="c"><input type="checkbox" id="c-41496106" checked=""/><div class="controls bullet"><span class="by">kev009</span><span>|</span><a href="#41491291">root</a><span>|</span><a href="#41494591">parent</a><span>|</span><a href="#41496422">prev</a><span>|</span><a href="#41498126">next</a><span>|</span><label class="collapse" for="c-41496106">[-]</label><label class="expand" for="c-41496106">[1 more]</label></div><br/><div class="children"><div class="content">Again, so too is z&#x2F;OS a complete UNIX system (from the user perspective).<p>OSF&#x2F;1 is decidedly not the the BSD side of the Unix wars, it is its own alternative strand against its contemporaries BSD and System V.  More specifically, it took its initial UNIX personality from IBM AIX and was rapidly developed and redefined to accommodate the standards du jour which included BSD and System V APIs.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41498126" class="c"><input type="checkbox" id="c-41498126" checked=""/><div class="controls bullet"><span class="by">nmz</span><span>|</span><a href="#41491291">prev</a><span>|</span><a href="#41492317">next</a><span>|</span><label class="collapse" for="c-41498126">[-]</label><label class="expand" for="c-41498126">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Linux’s io_uring is a relatively recent addition that improves asynchronous I&#x2F;O, but it has been a significant source of security vulnerabilities and is not in widespread use.<p>Funny, opening the manpage of aio on freebsd you get this on the second paragraph<p>&gt;      Asynchronous I&#x2F;O operations on some file descriptor types may block an
&gt;      AIO daemon indefinitely resulting in process and&#x2F;or system hangs.
&gt;      Operations on these file descriptor types are considered “unsafe” and
&gt;      disabled by default.  They can be enabled by setting the
&gt;      vfs.aio.enable_unsafe sysctl node to a non-zero value.<p>So nothing is safe.</div><br/></div></div><div id="41492317" class="c"><input type="checkbox" id="c-41492317" checked=""/><div class="controls bullet"><span class="by">andrewla</span><span>|</span><a href="#41498126">prev</a><span>|</span><a href="#41491405">next</a><span>|</span><label class="collapse" for="c-41492317">[-]</label><label class="expand" for="c-41492317">[27 more]</label></div><br/><div class="children"><div class="content">Practically speaking there are a number of developer-facing concerns that are pretty noticeable. I&#x27;m primarily a Linux user but I worked in Windows for a long time and have grown to appreciate some of the differences.<p>For example, the way that command line and globbing works are night and day, and in my mind the Windows approach is far superior.  The fact that the shell is expected to do the globbing means that you can really only have one parameter that can expand. Whereas Win32 offers a FindFirstFile&#x2F;FindNextFile interface that lets command line parameters be expanded at runtime. A missing parameter in unix can cause crazy behavior -- &quot;cp *&quot; but on windows this can just be an error.<p>On the other hand, the Win32 insistence on wchar_t is a disaster. UTF-16 is ... just awful. The Win32 approach only works if you assume 64k unicode characters; beyond that things go to shit very quickly.</div><br/><div id="41492950" class="c"><input type="checkbox" id="c-41492950" checked=""/><div class="controls bullet"><span class="by">panzi</span><span>|</span><a href="#41492317">parent</a><span>|</span><a href="#41492478">next</a><span>|</span><label class="collapse" for="c-41492950">[-]</label><label class="expand" for="c-41492950">[7 more]</label></div><br/><div class="children"><div class="content">Hard disagree. The way Windows handles command line parameters is bonkers. It is one string and every program has to escape&#x2F;parse it themselve. Yes, there is CommandLineToArgvW(), but there is no inverse of this. You need to escape the arguments per hand and can&#x27;t be sure the program will really interpret them the way you&#x27;ve intended. Even different programs written by Microsoft have different interpretations. See the somewhat recent troubles in Rust: <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;security&#x2F;advisories&#x2F;GHSA-q455-m56c-85mh">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;security&#x2F;advisories&#x2F;GHSA-q...</a></div><br/><div id="41494659" class="c"><input type="checkbox" id="c-41494659" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#41492317">root</a><span>|</span><a href="#41492950">parent</a><span>|</span><a href="#41493241">next</a><span>|</span><label class="collapse" for="c-41494659">[-]</label><label class="expand" for="c-41494659">[1 more]</label></div><br/><div class="children"><div class="content">&gt; See the somewhat recent troubles in Rust: <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;security&#x2F;advisories&#x2F;GHSA-q455-m56c-85mh">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;security&#x2F;advisories&#x2F;GHSA-q...</a><p>FYI this started out as a vulnerability in yt-dlp [1]. Later it was found to impact many other languages [2]. Rust, along with other languages, also considered it a vulnerability to fix, while some other languages only updated the documentation or considered it as wontfix.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;yt-dlp&#x2F;yt-dlp&#x2F;security&#x2F;advisories&#x2F;GHSA-42h4-v29r-42qg">https:&#x2F;&#x2F;github.com&#x2F;yt-dlp&#x2F;yt-dlp&#x2F;security&#x2F;advisories&#x2F;GHSA-42...</a><p>[2]: <a href="https:&#x2F;&#x2F;flatt.tech&#x2F;research&#x2F;posts&#x2F;batbadbut-you-cant-securely-execute-commands-on-windows&#x2F;" rel="nofollow">https:&#x2F;&#x2F;flatt.tech&#x2F;research&#x2F;posts&#x2F;batbadbut-you-cant-securel...</a></div><br/></div></div><div id="41493241" class="c"><input type="checkbox" id="c-41493241" checked=""/><div class="controls bullet"><span class="by">andrewla</span><span>|</span><a href="#41492317">root</a><span>|</span><a href="#41492950">parent</a><span>|</span><a href="#41494659">prev</a><span>|</span><a href="#41494681">next</a><span>|</span><label class="collapse" for="c-41493241">[-]</label><label class="expand" for="c-41493241">[1 more]</label></div><br/><div class="children"><div class="content">Question of where the pain goes, I guess. In unix, having to deal with shell escaping when doing routine tasks is super annoying -- URLs with question marks and ampersands screwing everything up, and simple expansions (like the `cp *` example above) causing confusing.<p>Yes, Windows resolution and glob expansion can be inconsistent, but it usually isn&#x27;t, but Unix makes you eat the cruft every time you use it. And you still get tools like ImageMagick that have strange ad hoc syntax for wildcard because they can&#x27;t use the standard wildcarding, or even ancient tools like find that force you to do all sorts of stupid shit to be compatible with globbing.</div><br/></div></div><div id="41494681" class="c"><input type="checkbox" id="c-41494681" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#41492317">root</a><span>|</span><a href="#41492950">parent</a><span>|</span><a href="#41493241">prev</a><span>|</span><a href="#41494033">next</a><span>|</span><label class="collapse" for="c-41494681">[-]</label><label class="expand" for="c-41494681">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s really strange to me that Microsoft has never added an ArgvToCommandLineW(). This would solve most of the problems with Windows command line parsing.</div><br/></div></div><div id="41494033" class="c"><input type="checkbox" id="c-41494033" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#41492317">root</a><span>|</span><a href="#41492950">parent</a><span>|</span><a href="#41494681">prev</a><span>|</span><a href="#41493196">next</a><span>|</span><label class="collapse" for="c-41494033">[-]</label><label class="expand" for="c-41494033">[1 more]</label></div><br/><div class="children"><div class="content">I had to write something to deal with quoting Windows _spawnvp and it&#x27;s insane:<p><a href="https:&#x2F;&#x2F;gitlab.com&#x2F;nbdkit&#x2F;nbdkit&#x2F;-&#x2F;blob&#x2F;0b4a47b5430f8b757f51457aca5b37123eae5217&#x2F;wrapper.c#L141" rel="nofollow">https:&#x2F;&#x2F;gitlab.com&#x2F;nbdkit&#x2F;nbdkit&#x2F;-&#x2F;blob&#x2F;0b4a47b5430f8b757f51...</a></div><br/></div></div><div id="41493196" class="c"><input type="checkbox" id="c-41493196" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#41492317">root</a><span>|</span><a href="#41492950">parent</a><span>|</span><a href="#41494033">prev</a><span>|</span><a href="#41492478">next</a><span>|</span><label class="collapse" for="c-41493196">[-]</label><label class="expand" for="c-41493196">[2 more]</label></div><br/><div class="children"><div class="content">As I understand it, CMD.EXE came from OS&#x2F;2 and has had many revisions that allow more pervasive evaluation of variables (originally, they were expanded only once, at the beginning of a script).<p>The .BAT&#x2F;.CMD to build the Windows kernel must have originally been quite the kludge.<p>Including pdksh in the original Windows NT might have been a better move.<p><a href="https:&#x2F;&#x2F;blog.nullspace.io&#x2F;batch.html" rel="nofollow">https:&#x2F;&#x2F;blog.nullspace.io&#x2F;batch.html</a></div><br/><div id="41493951" class="c"><input type="checkbox" id="c-41493951" checked=""/><div class="controls bullet"><span class="by">pmontra</span><span>|</span><a href="#41492317">root</a><span>|</span><a href="#41493196">parent</a><span>|</span><a href="#41492478">next</a><span>|</span><label class="collapse" for="c-41493951">[-]</label><label class="expand" for="c-41493951">[1 more]</label></div><br/><div class="children"><div class="content">I quote URLs and &quot;file names&quot; with double quotes in Linux bash much like I quote &quot;Program Files&quot; in Windows cmd. It&#x27;s the same. I quote spaces\ with\ a\ backslash\ sometimes.</div><br/></div></div></div></div></div></div><div id="41492478" class="c"><input type="checkbox" id="c-41492478" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#41492317">parent</a><span>|</span><a href="#41492950">prev</a><span>|</span><a href="#41496715">next</a><span>|</span><label class="collapse" for="c-41492478">[-]</label><label class="expand" for="c-41492478">[4 more]</label></div><br/><div class="children"><div class="content">The wchar_t thing is made much worse by disagreements on what type that actually is.  On Win32, it&#x27;s a 16-bit type, guaranteed to be UTF-16 code points (or surrogate pairs).  But on some other compilers and operating systems, wchar_t could be a 32-bit type.<p>Another problem with UTF-16 on Windows is that it does not enforce that surrogate pairs are properly matched.  You can have valid filenames or passwords that cannot be encoded in UTF-8.  The solution was to create another encoding system called &quot;WTF-8&quot; that allows unmatched surrogate pairs to survive a round trip to and from UTF-16.</div><br/><div id="41495242" class="c"><input type="checkbox" id="c-41495242" checked=""/><div class="controls bullet"><span class="by">benchloftbrunch</span><span>|</span><a href="#41492317">root</a><span>|</span><a href="#41492478">parent</a><span>|</span><a href="#41494767">next</a><span>|</span><label class="collapse" for="c-41495242">[-]</label><label class="expand" for="c-41495242">[1 more]</label></div><br/><div class="children"><div class="content">WTF-8 barely qualifies as &quot;another encoding system&quot; - it&#x27;s a trivial superset of UTF-8 that omits the rule forbidding surrogate codes.<p>Imo that artificial restriction in UTF-8 is the problem.</div><br/></div></div><div id="41494767" class="c"><input type="checkbox" id="c-41494767" checked=""/><div class="controls bullet"><span class="by">progmetaldev</span><span>|</span><a href="#41492317">root</a><span>|</span><a href="#41492478">parent</a><span>|</span><a href="#41495242">prev</a><span>|</span><a href="#41496715">next</a><span>|</span><label class="collapse" for="c-41494767">[-]</label><label class="expand" for="c-41494767">[2 more]</label></div><br/><div class="children"><div class="content">Is this just a really good joke, or something real? I enjoyed it, regardless!</div><br/><div id="41494930" class="c"><input type="checkbox" id="c-41494930" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#41492317">root</a><span>|</span><a href="#41494767">parent</a><span>|</span><a href="#41496715">next</a><span>|</span><label class="collapse" for="c-41494930">[-]</label><label class="expand" for="c-41494930">[1 more]</label></div><br/><div class="children"><div class="content">It was previously discussed at <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9611710">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9611710</a></div><br/></div></div></div></div></div></div><div id="41496715" class="c"><input type="checkbox" id="c-41496715" checked=""/><div class="controls bullet"><span class="by">pie_flavor</span><span>|</span><a href="#41492317">parent</a><span>|</span><a href="#41492478">prev</a><span>|</span><a href="#41492899">next</a><span>|</span><label class="collapse" for="c-41496715">[-]</label><label class="expand" for="c-41496715">[1 more]</label></div><br/><div class="children"><div class="content">wchar_t was advanced for its time, Microsoft was an early adopter of Unicode and the ANSI codepage system it replaced was real hell but what almost everyone else was using. UTF-8&#x27;s dominance is much more recent than Linux users tend to assume - Linux didn&#x27;t (and in many places still doesn&#x27;t) support Unicode at all, but an API that passes through ASCII or locale-based ANSI can have its docs changed to say UTF-8 without really being wrong. Outside of the kernel interface, languages used UTF-16 for their string types, like Python and Java. Even for a UTF-8 protocol like HTTP, UTF-16 was assumed better for JS. Only now that it is obvious that UTF-16 is <i>worse</i> (as opposed to just having an air of &quot;legacy&quot;), is Microsoft transitioning to UTF-8 APIs.</div><br/></div></div><div id="41492899" class="c"><input type="checkbox" id="c-41492899" checked=""/><div class="controls bullet"><span class="by">rbanffy</span><span>|</span><a href="#41492317">parent</a><span>|</span><a href="#41496715">prev</a><span>|</span><a href="#41494638">next</a><span>|</span><label class="collapse" for="c-41492899">[-]</label><label class="expand" for="c-41492899">[5 more]</label></div><br/><div class="children"><div class="content">NT was more ambitious from the start, and this might be one of the reasons why it didn’t age so well: the fewer decisions you make, the fewer mistakes you’ll have to carry. GNU&#x2F;Linux (the kernel, GNU’s libc, and a handful of utilities) is a very simple, very focused OS. It does not concern itself about windows or buttons or mice or touchscreens. Because of that, it’s free to evolve and tend to different needs, some of which we are yet to see. Desktop environments come and go, X came and mostly went, but the core has evolved while keeping itself as lean as technically possible.</div><br/><div id="41493024" class="c"><input type="checkbox" id="c-41493024" checked=""/><div class="controls bullet"><span class="by">andrewla</span><span>|</span><a href="#41492317">root</a><span>|</span><a href="#41492899">parent</a><span>|</span><a href="#41495484">next</a><span>|</span><label class="collapse" for="c-41493024">[-]</label><label class="expand" for="c-41493024">[2 more]</label></div><br/><div class="children"><div class="content">This is more of a sweeping generalization than I think would be appropriate.<p>The command line handling as I note above is a really crufty old Unix thing that doesn&#x27;t make sense now and is confusing and offputting when you get papercuts from it.<p>Another notable thing that they talk about to an extent is process creation -- the fork&#x2F;exec model in Linux is basically completely broken in the presence of threads. The number of footguns involved in this process has now grown beyond the ability of a human to understand. The Windows model, while a bit more cumbersome seeming at first, is fully generalizable and very explicit about the handoff of handles between processes.<p>The file system model I think is mostly a wash -- on the one hand, Window&#x27;s file locking model means that you can&#x27;t always delete a file that&#x27;s open, which can be handy. On the other hand, it means that you can&#x27;t always delete a file that&#x27;s open, which can be painful. On Linux, it&#x27;s possible that trying to support POSIX file system semantics can result in unrecoverable sleeps that are nearly impossible to diagnose or fix.</div><br/><div id="41496895" class="c"><input type="checkbox" id="c-41496895" checked=""/><div class="controls bullet"><span class="by">simoncion</span><span>|</span><a href="#41492317">root</a><span>|</span><a href="#41493024">parent</a><span>|</span><a href="#41495484">next</a><span>|</span><label class="collapse" for="c-41496895">[-]</label><label class="expand" for="c-41496895">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The command line handling as I note above is a really crufty old Unix thing that doesn&#x27;t make sense now and is confusing and offputting when you get papercuts from it.<p>It&#x27;s a power tool, and one whose regularity and consistent presence is appreciated by many.<p>If it trips you up, then configure your interactive shell and&#x2F;or scripts to not glob. Bash has &#x27;set -f&#x27;, other shells surely have similar switches, and undoubtedly there are shells that do no globbing at all.<p>If your counterargument to this workaround is that now you definitely can&#x27;t use &quot;*?[]&quot; and friends, whereas you could maybe do that in some Windows software, my counterargument to that would be that leaving globbing &amp; etc up to the application software not only makes it inconsistent and unreliable, it does nothing to systematically prevent the &#x27;cp *&#x27; problem you mentioned above.</div><br/></div></div></div></div><div id="41495484" class="c"><input type="checkbox" id="c-41495484" checked=""/><div class="controls bullet"><span class="by">okanat</span><span>|</span><a href="#41492317">root</a><span>|</span><a href="#41492899">parent</a><span>|</span><a href="#41493024">prev</a><span>|</span><a href="#41494638">next</a><span>|</span><label class="collapse" for="c-41495484">[-]</label><label class="expand" for="c-41495484">[2 more]</label></div><br/><div class="children"><div class="content">Sorry but your argument is baseless. There is nothing in NT kernel that forces a certain UI toolset nor it deals with the UI anymore (it briefly did when PCs were less powerful via GDI API, not anymore). Linux kernel and its modesetting facilities are quite a bit invasive and it is Linux that forces a certain way of implementing GPU drivers.<p>Windows just requires a set of functions from the driver to implement. Win32 drawing APIs are now completely userspace APIs and Windows actually did implement a couple of different ones.<p>Browsers switched to using a single graphics API canvas component long ago. Instead of relying on high level OS graphics API, they come with their own direct renderers that&#x27;s opaque to the OS apart from the buffer requests. This approach can utilize GPUs better. Windows was among the first systems to implement the same as a UI component library. It is called WPF and it is still the backbone of many non-Win32 UI elements on Windows. On the Linux side, I think Qt was the first to implement such a concept with QML &#x2F; QtQuick which is much later than WPF.<p>Moreover your argument that Unix evolves better or more freely falls apart when you consider that we had to <i>replace</i> X. On Unix world, the tendency to design &quot;minimal&quot; APIs that are close to hardware is the source of all evil. Almost any new technology requires big refactoring projects from application developers in the Unix world since the system programmers haven&#x27;t bothered to design future-proof APIs (or they are researchers &#x2F; hobbyists who don&#x27;t have a clue about the current business and user needs nor upcoming tech).<p>Windows didn&#x27;t need to replace Win32 since it was designed by engineers who understood the needs of businesses and designed an abstract-enough API that can survive things like introduction of HiDPI screens (which is just a &quot;display changed please rerender&quot; event). It is simply a better API.<p>On the Unix side X was tightly designed as around 96 or 72 DPI screens and everything had to be bolted on or hacked since the APIs were minimal or tightly coupled with the hardware capabilities at the time. Doing direct rendering on X was a pain in the ass and had an intertwined web of silly hacks which was why the DEs in 2010s kept discovering weird synchronization bugs and it was why Wayland needed to be invented.</div><br/><div id="41497975" class="c"><input type="checkbox" id="c-41497975" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#41492317">root</a><span>|</span><a href="#41495484">parent</a><span>|</span><a href="#41494638">next</a><span>|</span><label class="collapse" for="c-41497975">[-]</label><label class="expand" for="c-41497975">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Qt...<p>Cairo and such predate QML for long...</div><br/></div></div></div></div></div></div><div id="41494638" class="c"><input type="checkbox" id="c-41494638" checked=""/><div class="controls bullet"><span class="by">jmmv</span><span>|</span><a href="#41492317">parent</a><span>|</span><a href="#41492899">prev</a><span>|</span><a href="#41492653">next</a><span>|</span><label class="collapse" for="c-41494638">[-]</label><label class="expand" for="c-41494638">[1 more]</label></div><br/><div class="children"><div class="content">OP here. I did not touch upon CLI argument handling in this article because I wanted to focus on the kernel but this is indeed a big difference. And... I had written about this too :) <a href="https:&#x2F;&#x2F;jmmv.dev&#x2F;2020&#x2F;11&#x2F;cmdline-args-unix-vs-windows.html" rel="nofollow">https:&#x2F;&#x2F;jmmv.dev&#x2F;2020&#x2F;11&#x2F;cmdline-args-unix-vs-windows.html</a></div><br/></div></div><div id="41492653" class="c"><input type="checkbox" id="c-41492653" checked=""/><div class="controls bullet"><span class="by">jhallenworld</span><span>|</span><a href="#41492317">parent</a><span>|</span><a href="#41494638">prev</a><span>|</span><a href="#41492398">next</a><span>|</span><label class="collapse" for="c-41492653">[-]</label><label class="expand" for="c-41492653">[2 more]</label></div><br/><div class="children"><div class="content">Wchar_t is definitely the biggest annoying difference in that it shows up everywhere in your C&#x2F;C++ source code.</div><br/><div id="41494255" class="c"><input type="checkbox" id="c-41494255" checked=""/><div class="controls bullet"><span class="by">TillE</span><span>|</span><a href="#41492317">root</a><span>|</span><a href="#41492653">parent</a><span>|</span><a href="#41492398">next</a><span>|</span><label class="collapse" for="c-41494255">[-]</label><label class="expand" for="c-41494255">[1 more]</label></div><br/><div class="children"><div class="content">It depends on what you&#x27;re doing, but after many years I&#x27;ve just settled on consistently using UTF-8 internally and converting to UCS-2 at the edges when interacting with Win32.<p>There&#x27;s just too much UTF-8 input I also need to take, and converting those to wstring hurts my heart.</div><br/></div></div></div></div><div id="41492398" class="c"><input type="checkbox" id="c-41492398" checked=""/><div class="controls bullet"><span class="by">stroupwaffle</span><span>|</span><a href="#41492317">parent</a><span>|</span><a href="#41492653">prev</a><span>|</span><a href="#41494151">next</a><span>|</span><label class="collapse" for="c-41492398">[-]</label><label class="expand" for="c-41492398">[2 more]</label></div><br/><div class="children"><div class="content">If wchar_t holds the majority of code points for given use, then there are some benefits to having a fixed-width character and certain algorithms.<p>But it is fairly easy to convert wchar_t to-and-from UTF8 depending on use.<p>UTF16 is not <i>awful</i> it is the same as an 8-bit character set but twice longer.</div><br/><div id="41492441" class="c"><input type="checkbox" id="c-41492441" checked=""/><div class="controls bullet"><span class="by">andrewla</span><span>|</span><a href="#41492317">root</a><span>|</span><a href="#41492398">parent</a><span>|</span><a href="#41494151">next</a><span>|</span><label class="collapse" for="c-41492441">[-]</label><label class="expand" for="c-41492441">[1 more]</label></div><br/><div class="children"><div class="content">UTF-16 is fine so long as you are in Plane 0. Once you have to deal with surrogate pairs, then it really is awful. Once you have to deal with byte-order-markers you might as well just throw in the towel.<p>UTF-8 is well-designed and has a consistent mechanism for expanding to the underlying code point; it is easy to resynchronize and for ASCII systems (like most protocols) the parsing can be dead simple.<p>Dealing with Unicode text and glyph handling is always going to be painful because this problem is intrinsically difficult. But expansion of byte strings to unicode code points should not be as difficult as UTF-16 makes it.<p>Windows was converted to UCS-2 before higher code planes were designed and they never recovered.</div><br/></div></div></div></div><div id="41494151" class="c"><input type="checkbox" id="c-41494151" checked=""/><div class="controls bullet"><span class="by">dspillett</span><span>|</span><a href="#41492317">parent</a><span>|</span><a href="#41492398">prev</a><span>|</span><a href="#41493481">next</a><span>|</span><label class="collapse" for="c-41494151">[-]</label><label class="expand" for="c-41494151">[2 more]</label></div><br/><div class="children"><div class="content">Not even UTF16. Just UCS2 for a long time.</div><br/><div id="41497167" class="c"><input type="checkbox" id="c-41497167" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#41492317">root</a><span>|</span><a href="#41494151">parent</a><span>|</span><a href="#41493481">next</a><span>|</span><label class="collapse" for="c-41497167">[-]</label><label class="expand" for="c-41497167">[1 more]</label></div><br/><div class="children"><div class="content">Windows, I believe, is WTF-16. It permits surrogates (e.g., you can stick an emoji in a filename) — thus it cannot be UCS-2. It permits unpaired surrogates — thus it cannot be UTF-16.</div><br/></div></div></div></div><div id="41493481" class="c"><input type="checkbox" id="c-41493481" checked=""/><div class="controls bullet"><span class="by">mixmastamyk</span><span>|</span><a href="#41492317">parent</a><span>|</span><a href="#41494151">prev</a><span>|</span><a href="#41491405">next</a><span>|</span><label class="collapse" for="c-41493481">[-]</label><label class="expand" for="c-41493481">[2 more]</label></div><br/><div class="children"><div class="content">&gt; command line and globbing<p>Both Unix and NT are suboptimal here.  I believe there was an OS lost to time (and my memory) that had globbing done by the program but using an OS-provided standard library.  Probably the best way to do it consistently.  That said, having to pick the runner up, I prefer the Unix way.  As the unpredictable results happened to me more often on NT than... for example your cp example, which though possible I don&#x27;t think I&#x27;ve ever done in my career.<p>The rest of command.com&#x2F;cmd.exe is so poorly designed as to be laughable, only forgiven for being targeted to the PC 5150, and should have been retired a few years later.  Makes sh&#x2F;bash look like a masterpiece.  ;-)</div><br/><div id="41493890" class="c"><input type="checkbox" id="c-41493890" checked=""/><div class="controls bullet"><span class="by">andrewla</span><span>|</span><a href="#41492317">root</a><span>|</span><a href="#41493481">parent</a><span>|</span><a href="#41491405">next</a><span>|</span><label class="collapse" for="c-41493890">[-]</label><label class="expand" for="c-41493890">[1 more]</label></div><br/><div class="children"><div class="content">Win32 in theory has globbing done by an OS-provided standard library -- the `FindFirstFile` and `FindNextFile` win32 calls process globbing internally, and they are what you are expected to use.<p>Some applications choose to handle things differently, though. For example, the RENAME builtin does rough pattern-matching; so &quot;REN <i>.jpg </i>.jpg.old&quot; will work pretty much the way that intuition demands that it work, but the latter parameter cannot be globbed as there no such files when this command begins to execute. Generally speaking this can get pretty messy if commands try to be clever about wildcard expansion against theoretical files.</div><br/></div></div></div></div></div></div><div id="41491405" class="c"><input type="checkbox" id="c-41491405" checked=""/><div class="controls bullet"><span class="by">nyrikki</span><span>|</span><a href="#41492317">prev</a><span>|</span><a href="#41495612">next</a><span>|</span><label class="collapse" for="c-41491405">[-]</label><label class="expand" for="c-41491405">[8 more]</label></div><br/><div class="children"><div class="content">There are a number of issues, like ignoring the role of VMS, that windows 3.1 had a registry, the performance problems of early NT that lead to the hybrid model, the hype of microkernels at the time, the influence of plan 9 on both etc...<p>Cutler knew about microkernels from his work at Digital, OS&#x2F;2 was a hybrid kernel, and NT was really a rewrite after that failed partnership.<p>The directory support was targeting Netware etc...</div><br/><div id="41491616" class="c"><input type="checkbox" id="c-41491616" checked=""/><div class="controls bullet"><span class="by">nullindividual</span><span>|</span><a href="#41491405">parent</a><span>|</span><a href="#41493164">next</a><span>|</span><label class="collapse" for="c-41491616">[-]</label><label class="expand" for="c-41491616">[1 more]</label></div><br/><div class="children"><div class="content">And don&#x27;t forget Alternate Data Streams for NTFS! Made specifically for Mac OS.</div><br/></div></div><div id="41493164" class="c"><input type="checkbox" id="c-41493164" checked=""/><div class="controls bullet"><span class="by">steve1977</span><span>|</span><a href="#41491405">parent</a><span>|</span><a href="#41491616">prev</a><span>|</span><a href="#41492044">next</a><span>|</span><label class="collapse" for="c-41493164">[-]</label><label class="expand" for="c-41493164">[2 more]</label></div><br/><div class="children"><div class="content">Also Richard Rashid - the project lead for Mach at CMU - joined Microsoft in 1991.<p>Which is kinda interesting - Rashid went to Microsoft, Avie Tevanian went to NeXT&#x2F;Apple.</div><br/><div id="41494943" class="c"><input type="checkbox" id="c-41494943" checked=""/><div class="controls bullet"><span class="by">__d</span><span>|</span><a href="#41491405">root</a><span>|</span><a href="#41493164">parent</a><span>|</span><a href="#41492044">next</a><span>|</span><label class="collapse" for="c-41494943">[-]</label><label class="expand" for="c-41494943">[1 more]</label></div><br/><div class="children"><div class="content">Rashid went to Microsoft _Research_, which is quite different.</div><br/></div></div></div></div><div id="41492044" class="c"><input type="checkbox" id="c-41492044" checked=""/><div class="controls bullet"><span class="by">netbsdusers</span><span>|</span><a href="#41491405">parent</a><span>|</span><a href="#41493164">prev</a><span>|</span><a href="#41492103">next</a><span>|</span><label class="collapse" for="c-41492044">[-]</label><label class="expand" for="c-41492044">[3 more]</label></div><br/><div class="children"><div class="content">What exactly was &quot;hybrid&quot; about the OS&#x2F;2 kernel? &quot;Hybrid&quot; has always been basically a made up concept, but in OS&#x2F;2 it seems especially bizarre to apply it to what&#x27;s obviously a monolithic kernel, even one that bears a lot of similarity with older unix.</div><br/><div id="41492654" class="c"><input type="checkbox" id="c-41492654" checked=""/><div class="controls bullet"><span class="by">nyrikki</span><span>|</span><a href="#41491405">root</a><span>|</span><a href="#41492044">parent</a><span>|</span><a href="#41492934">next</a><span>|</span><label class="collapse" for="c-41492654">[-]</label><label class="expand" for="c-41492654">[1 more]</label></div><br/><div class="children"><div class="content">Real systems rarely can pass idealistic academic ideals.<p>Balancing benefits and costs of microkernel and monolithic kernels is common.<p>It looks like Google SEO gaming by removal of old content is making it hard to find good sources, but look at how OS&#x2F;2 used ring 2 if you want to know.<p>Message passing and context switching between kernel and user mode is expensive, and if you ever used NT 3.51 that was clearly visible as were the BSoDs when MS shifted to more of a &#x27;hybrid&#x27; model.</div><br/></div></div><div id="41492934" class="c"><input type="checkbox" id="c-41492934" checked=""/><div class="controls bullet"><span class="by">AshamedCaptain</span><span>|</span><a href="#41491405">root</a><span>|</span><a href="#41492044">parent</a><span>|</span><a href="#41492654">prev</a><span>|</span><a href="#41492103">next</a><span>|</span><label class="collapse" for="c-41492934">[-]</label><label class="expand" for="c-41492934">[1 more]</label></div><br/><div class="children"><div class="content">You can even call Windows&#x2F;386 or 3.x &quot;hybrid&quot;, and in my opinion it would be more accurate to call Windows&#x2F;386 a hybrid kernel than calling NT one. There&#x27;s a microkernel that manages VMs, and there is a traditional, larger kernel inside each VM (either Windows itself, or DOS). The microkernel also arbitrates hardware between each of the VMs, but it is the VMs themselves that contain most of the drivers, which are running in &quot;user space&quot;!<p>In comparison Windows NT is basically a monolithic kernel. Everything runs in the same address space, so there&#x27;s 0 protection. Or at least, in any definition where you call NT a hybrid kernel then practically any modular kernel would be hybrid. In later versions of NT the separations between kernel-mode components this post is praising have almost completely disappeared and even the GUI is running in kernel mode...</div><br/></div></div></div></div><div id="41492103" class="c"><input type="checkbox" id="c-41492103" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#41491405">parent</a><span>|</span><a href="#41492044">prev</a><span>|</span><a href="#41495612">next</a><span>|</span><label class="collapse" for="c-41492103">[-]</label><label class="expand" for="c-41492103">[1 more]</label></div><br/><div class="children"><div class="content">AFAIK, Windows 3.1&#x27;s registry was only to store COM class information. It was just another type of single-purpose configuration file.</div><br/></div></div></div></div><div id="41495612" class="c"><input type="checkbox" id="c-41495612" checked=""/><div class="controls bullet"><span class="by">ThinkBeat</span><span>|</span><a href="#41491405">prev</a><span>|</span><a href="#41493400">next</a><span>|</span><label class="collapse" for="c-41495612">[-]</label><label class="expand" for="c-41495612">[6 more]</label></div><br/><div class="children"><div class="content">Architecturally WindowsNT was a much better designed system than Linux
when it came out.<p>I wish it had branched to one platform as a workstation OS (NTNext).<p>and one that gets dumber and worse in order to make it work well for gaming.
Windows 7&#x2F;8&#x2F;10&#x2F;11 etc,<p>Technically one would hope that NTNext would be Windows Server, but sadly
no.<p>I remember installing WindowsNT on my PC in awe how much better it was than 
Dos&#x2F;Windows3 and later 95.<p>And compatibility back then was not great.
There was a lot that didn&#x27;t work, and I was more than fine with that.<p>It could run win32, os&#x2F;2, and posix and it could be extended to run other 
systems in the same way.<p>Posix was added as a nessecity to bid for huge software contracts from the 
US government, and MS lost a huge contract and lost interest in the POSIX sub system, and in the os&#x2F;2 sub system.<p>Did away with it, until they re-invented a worse system for WSL.<p>Note subsystem in WindowsNT means something very different than subsystem 
for Linux.</div><br/><div id="41497184" class="c"><input type="checkbox" id="c-41497184" checked=""/><div class="controls bullet"><span class="by">kev009</span><span>|</span><a href="#41495612">parent</a><span>|</span><a href="#41495718">next</a><span>|</span><label class="collapse" for="c-41497184">[-]</label><label class="expand" for="c-41497184">[1 more]</label></div><br/><div class="children"><div class="content">Linux is one of the prime examples of the Worse is Better motif in UNIX history.  And to all your points I don&#x27;t think it&#x27;s outgrown this, it is not a particularly elegant kernel even by UNIX standards.<p>Linus and other early Linux people had a real good nose for performance.. not the gamesmanship kind just stacking often minuscule individual wins and avoiding too many layered architectural penalties.  When it came time to worry about scalability Linux got lucky with the IBM investment who had also just purchased Sequent and knew a thing or two about SMP and NUMA.<p>Most commercial systems are antithetical to performance (there are some occasional exceptions).  The infamous interaction of a Sun performance engineer trying to ridicule David Miller who was showing real world performance gains..<p>I think that keen performance really helped with adoption.  Since the early days you might install Linux on hardware that was rescued from the garbage and do meaningful things with it whereas the contemporary commercial systems had forced it obsolete.</div><br/></div></div><div id="41495718" class="c"><input type="checkbox" id="c-41495718" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#41495612">parent</a><span>|</span><a href="#41497184">prev</a><span>|</span><a href="#41493400">next</a><span>|</span><label class="collapse" for="c-41495718">[-]</label><label class="expand" for="c-41495718">[4 more]</label></div><br/><div class="children"><div class="content">WSL was a real subsystem. It worked in similar ways to the old subsystems. However, the Linux kernel is different enough from Windows, and evolves so much faster, that Microsoft wasn&#x27;t able to keep up. WSL2 is mostly just fancy virtualization but this approach has better compatibility and, thanks to modern hardware features, better performance, than WSL ever did.</div><br/><div id="41495767" class="c"><input type="checkbox" id="c-41495767" checked=""/><div class="controls bullet"><span class="by">Const-me</span><span>|</span><a href="#41495612">root</a><span>|</span><a href="#41495718">parent</a><span>|</span><a href="#41493400">next</a><span>|</span><label class="collapse" for="c-41495767">[-]</label><label class="expand" for="c-41495767">[3 more]</label></div><br/><div class="children"><div class="content">&gt; thanks to modern hardware, very little performance penalty<p>I would not call 1 order of magnitude performance penalty for accessing a local file system “little”: <a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;WSL&#x2F;issues&#x2F;4197">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;WSL&#x2F;issues&#x2F;4197</a></div><br/><div id="41495940" class="c"><input type="checkbox" id="c-41495940" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#41495612">root</a><span>|</span><a href="#41495767">parent</a><span>|</span><a href="#41493400">next</a><span>|</span><label class="collapse" for="c-41495940">[-]</label><label class="expand" for="c-41495940">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, that&#x27;s pretty bad. The fact that mounting the volume as a network share gets better performance is surprising and somewhat concerning.<p>However, what I was talking about performance-wise was the overhead of every system call. That overhead is gone under WSL2. Maybe it wasn&#x27;t worth it for that reason alone, but original WSL could never keep up with Linux kernel and ecosystem development.<p>Being able to run nearly all Linux programs with only some operations being slow is probably still better than being able to run only some Linux programs with all operations being slow.</div><br/><div id="41497196" class="c"><input type="checkbox" id="c-41497196" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#41495612">root</a><span>|</span><a href="#41495940">parent</a><span>|</span><a href="#41493400">next</a><span>|</span><label class="collapse" for="c-41497196">[-]</label><label class="expand" for="c-41497196">[1 more]</label></div><br/><div class="children"><div class="content">The problem with WSL1 was the very different file system semantics between Windows and Linux.  On Linux files are dumb and cheap.  On Windows files are smarter and more expensive.  Mapping Linux file system calls on Windows worked fine but you couldn&#x27;t avoid paying for that difference when it came up.<p>You can&#x27;t resolve that issue while mapping everything to Windows system calls.  If you&#x27;re not going to map to Windows system calls then you might as well virtualize the whole thing.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41493400" class="c"><input type="checkbox" id="c-41493400" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#41495612">prev</a><span>|</span><a href="#41498348">next</a><span>|</span><label class="collapse" for="c-41493400">[-]</label><label class="expand" for="c-41493400">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Internationalization: Microsoft, being the large company that was already shipping Windows 3.x across the world, understood that localization was important and made NT support such feature from the very beginning. Contrast this to Unix where UTF support didn’t start to show up until the late 1990s<p>I feel like this is a point for unix. Unix being late to the unicode party means utf-8 was adopted where windows was saddled with utf-16<p>---<p>The NT kernel does seem to have some elegance. Its too bad it is not open source; windows with a different userspace and desktop environment would be interesting.</div><br/><div id="41493505" class="c"><input type="checkbox" id="c-41493505" checked=""/><div class="controls bullet"><span class="by">chungy</span><span>|</span><a href="#41493400">parent</a><span>|</span><a href="#41498348">next</a><span>|</span><label class="collapse" for="c-41493505">[-]</label><label class="expand" for="c-41493505">[5 more]</label></div><br/><div class="children"><div class="content">Windows would be so much better if it were actually UTF-16. It&#x27;s worse than that: it&#x27;s from a world where Unicode thought &quot;16-bits ought to be enough for anybody&quot; and Windows NT baked that assumption deep into the system; it wasn&#x27;t until 1996 that Unicode had to course-correct, and UTF-16 was carved out to be mostly compatible with the older standard (now known as UCS-2). For as long as you don&#x27;t use the surrogate sequences in strings, you happen to be UTF-16 compatible; if you use the sequences appropriately, you happen to be UTF-16 compatible; if you use them in invalid ways to UTF-16, now you&#x27;ve got a mess that&#x27;s a valid name on the operating system.<p>I can&#x27;t really blame NT for this, it&#x27;s unfortunate timing and it remains for backwards compatibility purposes. Java and JavaScript suffer similar issues for similar reasons.</div><br/><div id="41493638" class="c"><input type="checkbox" id="c-41493638" checked=""/><div class="controls bullet"><span class="by">chungy</span><span>|</span><a href="#41493400">root</a><span>|</span><a href="#41493505">parent</a><span>|</span><a href="#41498348">next</a><span>|</span><label class="collapse" for="c-41493638">[-]</label><label class="expand" for="c-41493638">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll throw this out there too: UTF-8 isn&#x27;t necessarily better than UTF-16; they both support the entirety of the Unicode character space.<p>UTF-8 is convenient on Unix systems since it fits into 8-bit character slots that were already in place; file systems have traditionally only forbidden the NULL byte and forward-slash, and all other characters are valid. From this fact, you can use UTF-8 in file names with ease on legacy systems, you don&#x27;t need any operating system support for it.<p>UTF-8 is &quot;space optimized&quot; for ASCII text, while most extra-ASCII Latin, Cyrillic, Greek, Arabic characters need two bytes each (same as UTF-16); most of Chinese&#x2F;Japanese&#x2F;Korean script in the BMP requires three bytes in UTF-8, whereas you still only need two bytes in UTF-16. To go further beyond, all SMP characters (eg, most emoji) require four bytes each in both systems.<p>Essentially, UTF-8 is good space-wise for mostly-ASCII text. It remains on-par with UTF-16 for most western languages, and only becomes more inefficient than UTF-16 for east-Asian languages (in such regions, UTF-16 is already dominant).</div><br/><div id="41494728" class="c"><input type="checkbox" id="c-41494728" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#41493400">root</a><span>|</span><a href="#41493638">parent</a><span>|</span><a href="#41496526">next</a><span>|</span><label class="collapse" for="c-41494728">[-]</label><label class="expand" for="c-41494728">[2 more]</label></div><br/><div class="children"><div class="content">Space savings are irrelavent. Text is small, and after gzip its going to be the same anyways.<p>Seriously, when was the last time where you both cared about saving a single kb, but compression was not an option. I&#x27;m pretty sure the answer is never. It was never in the 90s, it is extra never now that we have hard drives hundreds of gb big.<p>UTF-8 is better because bytes are a natural unit. You dont have to worry about surrogates. You dont have to worry about de-synchronization issues. You dont have to worry about byte order.<p>Backwards compatibility with ascii and basically every interface ever, also helps. (Well not 7bit smtp..). The fact is, ascii is everywhere. Being able to treat it as just a subset of utf-8 makes a lot of things easier.<p>&gt; (eg, most emoji) require four bytes each in both systems.<p>This is misleading because most emoiji are not just a single astral character but a combination of many.</div><br/><div id="41498066" class="c"><input type="checkbox" id="c-41498066" checked=""/><div class="controls bullet"><span class="by">nmz</span><span>|</span><a href="#41493400">root</a><span>|</span><a href="#41494728">parent</a><span>|</span><a href="#41496526">next</a><span>|</span><label class="collapse" for="c-41498066">[-]</label><label class="expand" for="c-41498066">[1 more]</label></div><br/><div class="children"><div class="content">Saving disk space and synchronization is only important for network transmission. At the local level, you will need to convert to something where you can get&#x2F;know positioning, utf8 does not allow for this given its variability, this means a lot of operations are more expensive and you will have to convert to utf16 anyway.</div><br/></div></div></div></div><div id="41496526" class="c"><input type="checkbox" id="c-41496526" checked=""/><div class="controls bullet"><span class="by">mmoskal</span><span>|</span><a href="#41493400">root</a><span>|</span><a href="#41493638">parent</a><span>|</span><a href="#41494728">prev</a><span>|</span><a href="#41498348">next</a><span>|</span><label class="collapse" for="c-41496526">[-]</label><label class="expand" for="c-41496526">[1 more]</label></div><br/><div class="children"><div class="content">Interestingly in a Javascript or similar runtime most of text that hits the caches where the size actually matters is still ASCII even in far east because of identifiers. Utf8 for the win!</div><br/></div></div></div></div></div></div></div></div><div id="41498348" class="c"><input type="checkbox" id="c-41498348" checked=""/><div class="controls bullet"><span class="by">walki</span><span>|</span><a href="#41493400">prev</a><span>|</span><a href="#41492786">next</a><span>|</span><label class="collapse" for="c-41498348">[-]</label><label class="expand" for="c-41498348">[1 more]</label></div><br/><div class="children"><div class="content">I feel like the NT kernel is in maintenance only mode and will eventually be replaced by the Linux kernel. I submitted a Windows kernel bug to Microsoft a few years ago and even though they acknowledged the bug the issue was closed as a &quot;won&#x27;t fix&quot; because fixing the bug would require making backwards incompatible changes.<p>Windows currently has a significant scaling issue because of its Processor Groups design, it is actually more of an ugly hack that was added to Windows 7 to support more than 64 threads. Everyone makes bad decisions when developing a kernel, the difference between the Windows NT kernel and the Linux kernel is that fundamental design flaws tend to get eventually fixed in the Linux kernel while they rarely get fixed in the Windows NT kernel.</div><br/></div></div><div id="41492786" class="c"><input type="checkbox" id="c-41492786" checked=""/><div class="controls bullet"><span class="by">rbanffy</span><span>|</span><a href="#41498348">prev</a><span>|</span><a href="#41497747">next</a><span>|</span><label class="collapse" for="c-41492786">[-]</label><label class="expand" for="c-41492786">[13 more]</label></div><br/><div class="children"><div class="content">I don’t think the registry is a good idea. I don’t mind every program having its own dialect of a configuration language, all under the &#x2F;etc tree. If you think about it, the &#x2F;etc tree is just a hierarchical key-value store implemented as files where the persistent format of the leaf node is left to its implementer to decide.</div><br/><div id="41495266" class="c"><input type="checkbox" id="c-41495266" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#41492786">parent</a><span>|</span><a href="#41494687">next</a><span>|</span><label class="collapse" for="c-41495266">[-]</label><label class="expand" for="c-41495266">[5 more]</label></div><br/><div class="children"><div class="content">&gt; If you think about it, the &#x2F;etc tree is just a hierarchical key-value store<p>Well, you&#x27;re in luck, I have good news for you -- Windows also has its own version of this concept: it&#x27;s called &quot;The Registry&quot;. You might have heard of it?</div><br/><div id="41497821" class="c"><input type="checkbox" id="c-41497821" checked=""/><div class="controls bullet"><span class="by">rkagerer</span><span>|</span><a href="#41492786">root</a><span>|</span><a href="#41495266">parent</a><span>|</span><a href="#41495854">next</a><span>|</span><label class="collapse" for="c-41497821">[-]</label><label class="expand" for="c-41497821">[3 more]</label></div><br/><div class="children"><div class="content">The registry would have been better if there were a stronger concept of &quot;ownership&quot; of the data it contains, tying each key to the responsible app &#x2F; subsystem.  I&#x27;ve tracked hundreds of software uninstalls and I would bet only about 1% of them actually remove all the cruft they originally stick in (or populated during use).  The result is bloat, a larger surface area for corruption, and system slowdown.<p>Ironically in this respect it was a step backward... When settings lived in INI files, convention typically kept them in the same place as the program, so they were easy to find and were naturally extinguished when you deleted the software.<p>If you look at more modern OS&#x27;s like Android and iOS they tend to enforce more explicit ties between apps and their data.</div><br/><div id="41498654" class="c"><input type="checkbox" id="c-41498654" checked=""/><div class="controls bullet"><span class="by">ruthmarx</span><span>|</span><a href="#41492786">root</a><span>|</span><a href="#41497821">parent</a><span>|</span><a href="#41498590">next</a><span>|</span><label class="collapse" for="c-41498654">[-]</label><label class="expand" for="c-41498654">[1 more]</label></div><br/><div class="children"><div class="content">&gt; only about 1% of them actually remove all the cruft they originally stick in (or populated during use). The result is bloat, a larger surface area for corruption, and system slowdown.<p>I think this is a myth partly spread by commercial offerings that want to &#x27;clean and optimize&#x27; a windows install.<p>Most of the cruft left in the registry is the equivalent of config files in &#x2F;etc not removed after uninstalling an app. That stuff isn&#x27;t affecting performance.</div><br/></div></div><div id="41498590" class="c"><input type="checkbox" id="c-41498590" checked=""/><div class="controls bullet"><span class="by">alt227</span><span>|</span><a href="#41492786">root</a><span>|</span><a href="#41497821">parent</a><span>|</span><a href="#41498654">prev</a><span>|</span><a href="#41495854">next</a><span>|</span><label class="collapse" for="c-41498590">[-]</label><label class="expand" for="c-41498590">[1 more]</label></div><br/><div class="children"><div class="content">&gt; system slowdown<p>This is often touted as a downside for the registry, and indeed a whole ecosystem of apps have evolved around this concept to &#x27;clean&#x27; the registry and &#x27;speed it up&#x27;.<p>In my experience of 35 years of using windows, I have never noticed a bloated registry slowing down a computer. I have also never noticed a speed up of the system by removing some unused keys. The whole point of addresses and key pairs is that individual bits of data can be written or read without loading the whole hive.<p>I wonder where this idea of a bloated slow registry came from?</div><br/></div></div></div></div><div id="41495854" class="c"><input type="checkbox" id="c-41495854" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#41492786">root</a><span>|</span><a href="#41495266">parent</a><span>|</span><a href="#41497821">prev</a><span>|</span><a href="#41494687">next</a><span>|</span><label class="collapse" for="c-41495854">[-]</label><label class="expand" for="c-41495854">[1 more]</label></div><br/><div class="children"><div class="content">And since it supports variable-lenght binary values, it fully supports that &quot;the persistent format of the leaf node is left to its implementer to decide&quot;.</div><br/></div></div></div></div><div id="41494687" class="c"><input type="checkbox" id="c-41494687" checked=""/><div class="controls bullet"><span class="by">phendrenad2</span><span>|</span><a href="#41492786">parent</a><span>|</span><a href="#41495266">prev</a><span>|</span><a href="#41495643">next</a><span>|</span><label class="collapse" for="c-41494687">[-]</label><label class="expand" for="c-41494687">[5 more]</label></div><br/><div class="children"><div class="content">So what&#x27;s wrong with the registry if a file-based registry is okay? The registry could be an abstraction layer over a Unix &#x2F;etc filesystem, after all.</div><br/><div id="41498664" class="c"><input type="checkbox" id="c-41498664" checked=""/><div class="controls bullet"><span class="by">ruthmarx</span><span>|</span><a href="#41492786">root</a><span>|</span><a href="#41494687">parent</a><span>|</span><a href="#41498192">next</a><span>|</span><label class="collapse" for="c-41498664">[-]</label><label class="expand" for="c-41498664">[1 more]</label></div><br/><div class="children"><div class="content">I have no issue with the concept, but in practice the Windows registry is a lot more obfuscated than it needs to be. There can be trees and trees of UUIDs or similar, and there is no need for it to be so user unfriendly.<p>Part of this might be mixing internal stuff that people never need to see with stuff that people will need to access.</div><br/></div></div><div id="41498192" class="c"><input type="checkbox" id="c-41498192" checked=""/><div class="controls bullet"><span class="by">nmz</span><span>|</span><a href="#41492786">root</a><span>|</span><a href="#41494687">parent</a><span>|</span><a href="#41498664">prev</a><span>|</span><a href="#41498174">next</a><span>|</span><label class="collapse" for="c-41498192">[-]</label><label class="expand" for="c-41498192">[1 more]</label></div><br/><div class="children"><div class="content">Labeling, fstab is supposed to be a .tsv, what happens if I mistype something? where&#x27;s the safety? Does this need to be a DSL?</div><br/></div></div><div id="41498174" class="c"><input type="checkbox" id="c-41498174" checked=""/><div class="controls bullet"><span class="by">JackSlateur</span><span>|</span><a href="#41492786">root</a><span>|</span><a href="#41494687">parent</a><span>|</span><a href="#41498192">prev</a><span>|</span><a href="#41495643">next</a><span>|</span><label class="collapse" for="c-41498174">[-]</label><label class="expand" for="c-41498174">[2 more]</label></div><br/><div class="children"><div class="content">&quot;rm -rf &#x2F;etc&#x2F;nginx&quot; versus &quot;try to remember where are the miriads of random keys spread everywhere&quot;</div><br/><div id="41498632" class="c"><input type="checkbox" id="c-41498632" checked=""/><div class="controls bullet"><span class="by">alt227</span><span>|</span><a href="#41492786">root</a><span>|</span><a href="#41498174">parent</a><span>|</span><a href="#41495643">next</a><span>|</span><label class="collapse" for="c-41498632">[-]</label><label class="expand" for="c-41498632">[1 more]</label></div><br/><div class="children"><div class="content">Then it seems like the issue you have is how vendors are storing keys in the registry, not the registry itself. In your example, if nginx made a single node in the registry with all its keys under that then it would be just as easy to remove that single node as it would be to remove the single directory.<p>However in the real world it is never as simple as you suggest. Linux apps often litter the filesystem with data. an app might have files in &#x2F;etc and &#x2F;opt with shortcut scripts in &#x2F;root&#x2F;bin and &#x2F;usr&#x2F;sbin. Config files in &#x2F;home and &#x2F;usr directories. Linux file systems are just as littered as windows registries in my experience, if not worse because they differ in different distros.</div><br/></div></div></div></div></div></div><div id="41495643" class="c"><input type="checkbox" id="c-41495643" checked=""/><div class="controls bullet"><span class="by">delta_p_delta_x</span><span>|</span><a href="#41492786">parent</a><span>|</span><a href="#41494687">prev</a><span>|</span><a href="#41493562">next</a><span>|</span><label class="collapse" for="c-41495643">[-]</label><label class="expand" for="c-41495643">[1 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t quite decide if this comment is sarcasm or not.</div><br/></div></div><div id="41493562" class="c"><input type="checkbox" id="c-41493562" checked=""/><div class="controls bullet"><span class="by">mixmastamyk</span><span>|</span><a href="#41492786">parent</a><span>|</span><a href="#41495643">prev</a><span>|</span><a href="#41497747">next</a><span>|</span><label class="collapse" for="c-41493562">[-]</label><label class="expand" for="c-41493562">[1 more]</label></div><br/><div class="children"><div class="content">I like what the elektra project was trying to do, but it didn&#x27;t catch on.  Basically put config into the filesystem with a standard schema, etc.  Could use basic tools&#x2F;permissions on it, rsync it, etc.  Benefits of the registry but less prone to failure and no tools needed to be reinvented.</div><br/></div></div></div></div><div id="41497747" class="c"><input type="checkbox" id="c-41497747" checked=""/><div class="controls bullet"><span class="by">rkagerer</span><span>|</span><a href="#41492786">prev</a><span>|</span><a href="#41496424">next</a><span>|</span><label class="collapse" for="c-41497747">[-]</label><label class="expand" for="c-41497747">[2 more]</label></div><br/><div class="children"><div class="content">Can we talk about NT picoprocesses?<p><i>Up until this feature was added, processes in NT were quite heavyweight: new processes would get a bunch of the NT runtime libraries mapped in their address space at startup time. In a picoprocess, the process has minimal ties to the Windows architecture, and this is used to implement Linux-compatible processes in WSL 1.</i><p>They sound like an extremely useful construct.<p>Also, WSL 2 always felt like a &quot;cheat&quot; to me... is anyone else disappointed they went full-on VM and abandoned the original approach?  Did small file performance ever get adequately addressed?</div><br/><div id="41497774" class="c"><input type="checkbox" id="c-41497774" checked=""/><div class="controls bullet"><span class="by">tjoff</span><span>|</span><a href="#41497747">parent</a><span>|</span><a href="#41496424">next</a><span>|</span><label class="collapse" for="c-41497774">[-]</label><label class="expand" for="c-41497774">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m surprised they didn&#x27;t go the WSL2 route from the start. Seems much easier to do.<p>But WSL is so cool and since I mostly run windows in VMs without nested virtualization support I&#x27;ve pretty much only used that one and am super thankful for it.</div><br/></div></div></div></div><div id="41496424" class="c"><input type="checkbox" id="c-41496424" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#41497747">prev</a><span>|</span><a href="#41491872">next</a><span>|</span><label class="collapse" for="c-41496424">[-]</label><label class="expand" for="c-41496424">[3 more]</label></div><br/><div class="children"><div class="content">Controversial opinion: DOS-based Windows&#x2F;386 family (including 3.11 enhanced mode, 95, 98, up to the ill-fated ME) are even more advanced than NT. While Unix and NT, despite how different they are in the details are still &quot;traditional&quot; OSes, the lineage that started at Windows&#x2F;386 are hypervisors that run VMs under hardware-assisted virtualisation. IMHO not enough has been written about the details of this architecture, compared to Unix and NT. It&#x27;s a hypervisor that passes through most accesses to the hardware by default, which gave it a bad reputation for stability and security, but also a great reputation for performance and efficiency.</div><br/><div id="41496515" class="c"><input type="checkbox" id="c-41496515" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#41496424">parent</a><span>|</span><a href="#41496491">next</a><span>|</span><label class="collapse" for="c-41496515">[-]</label><label class="expand" for="c-41496515">[1 more]</label></div><br/><div class="children"><div class="content">Is that architecture actually good or is it just complex? If it&#x27;s more advanced, why did MS replace it with NT? It has long been known that you can trade off performance and protection; in retrospect 95&#x2F;98 just wasn&#x27;t reliable enough.</div><br/></div></div><div id="41496491" class="c"><input type="checkbox" id="c-41496491" checked=""/><div class="controls bullet"><span class="by">omnibrain</span><span>|</span><a href="#41496424">parent</a><span>|</span><a href="#41496515">prev</a><span>|</span><a href="#41491872">next</a><span>|</span><label class="collapse" for="c-41496491">[-]</label><label class="expand" for="c-41496491">[1 more]</label></div><br/><div class="children"><div class="content">Isn’t it similar when you use Hyper-V?</div><br/></div></div></div></div><div id="41491872" class="c"><input type="checkbox" id="c-41491872" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#41496424">prev</a><span>|</span><a href="#41497790">next</a><span>|</span><label class="collapse" for="c-41491872">[-]</label><label class="expand" for="c-41491872">[6 more]</label></div><br/><div class="children"><div class="content">(1) The has been some convergence such as FUSE in Linux which lets you implement file systems in user space, Proton emulates NT very well, and<p>(2) Win NT’s approach to file systems makes many file system operations very slow which makes npm and other dev systems designed for the Unix system terribly slow in NT.  Which is why Microsoft gave up on the otherwise excellent WSL1.  If you were writing this kind of thing natively for Windows you would stuff blobs into SQLLite (e.g. a true “user space filesystem”) or ZIP files or some other container instead of stuffing 100,000 files in directories.</div><br/><div id="41492008" class="c"><input type="checkbox" id="c-41492008" checked=""/><div class="controls bullet"><span class="by">nullindividual</span><span>|</span><a href="#41491872">parent</a><span>|</span><a href="#41492197">next</a><span>|</span><label class="collapse" for="c-41492008">[-]</label><label class="expand" for="c-41492008">[3 more]</label></div><br/><div class="children"><div class="content">&gt; NT’s approach to file systems makes many file system operations very slow<p>This is due to the file system filters. It shows when using DevDrive where there are significant performance improvements.</div><br/><div id="41492361" class="c"><input type="checkbox" id="c-41492361" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#41491872">root</a><span>|</span><a href="#41492008">parent</a><span>|</span><a href="#41492197">next</a><span>|</span><label class="collapse" for="c-41492361">[-]</label><label class="expand" for="c-41492361">[2 more]</label></div><br/><div class="children"><div class="content">Great!  I’m thinking of adding a new SSD to my machine and would love to try this out.</div><br/><div id="41492450" class="c"><input type="checkbox" id="c-41492450" checked=""/><div class="controls bullet"><span class="by">nullindividual</span><span>|</span><a href="#41491872">root</a><span>|</span><a href="#41492361">parent</a><span>|</span><a href="#41492197">next</a><span>|</span><label class="collapse" for="c-41492450">[-]</label><label class="expand" for="c-41492450">[1 more]</label></div><br/><div class="children"><div class="content">You can provision a VHDX on your pre-existing NTFS volume (IIRC VHDX overhead is &lt;=1% for Hyper-V, not sure if that&#x27;s still the case and&#x2F;or applies to DevDrive). But yes, I would say an additional drive is ideal. I did just that to put games on DevDrive.<p><a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;visualstudio&#x2F;devdrive&#x2F;" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;visualstudio&#x2F;devdrive&#x2F;</a><p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;dev-drive&#x2F;#set-up-options" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;dev-drive&#x2F;#set-up-...</a></div><br/></div></div></div></div></div></div><div id="41492197" class="c"><input type="checkbox" id="c-41492197" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#41491872">parent</a><span>|</span><a href="#41492008">prev</a><span>|</span><a href="#41497790">next</a><span>|</span><label class="collapse" for="c-41492197">[-]</label><label class="expand" for="c-41492197">[2 more]</label></div><br/><div class="children"><div class="content">I wonder how much of Linux&#x27;s performance is attributable to it <i>not</i> having such grand architectural visions (e.g. unified object manager) and therefore being able to optimize each specific code path more.</div><br/><div id="41493272" class="c"><input type="checkbox" id="c-41493272" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#41491872">root</a><span>|</span><a href="#41492197">parent</a><span>|</span><a href="#41497790">next</a><span>|</span><label class="collapse" for="c-41493272">[-]</label><label class="expand" for="c-41493272">[1 more]</label></div><br/><div class="children"><div class="content">Many Linux systems on TPC.org are running on XFS (everything rhel-based). It&#x27;s not simple, but it does appear to help SQL Server.</div><br/></div></div></div></div></div></div><div id="41491889" class="c"><input type="checkbox" id="c-41491889" checked=""/><div class="controls bullet"><span class="by">delta_p_delta_x</span><span>|</span><a href="#41497790">prev</a><span>|</span><a href="#41497192">next</a><span>|</span><label class="collapse" for="c-41491889">[-]</label><label class="expand" for="c-41491889">[28 more]</label></div><br/><div class="children"><div class="content">NT is why I like Windows so much and can&#x27;t stand Unix-likes. It is object-oriented from top to bottom, and I&#x27;m glad in the 21st century PowerShell has continued that legacy.<p>But as someone who&#x27;s used all versions of Windows since 95, this paragraph strikes me the most:<p>&gt; What I find disappointing is that, even though NT has all these solid design principles in place… bloat in the UI doesn’t let the design shine through. The sluggishness of the OS even on super-powerful machines is painful to witness and might even lead to the demise of this OS.<p>I couldn&#x27;t agree more. Windows 11 is irritatingly macOS-like and for some reason has animations that make it appear slow as molasses. What I really want is a Windows 2000-esque UI with dense, desktop-focused UIs (for an example, look at Visual Studio 2022 which is the last bastion of the late 1990s-early 2000s-style fan-out toolbar design that still persists in Microsoft&#x27;s products).<p>I want modern technologies from Windows 10 and 11 like UTF-8, SSD management, ClearType and high-quality typefaces, proper HiDPI scaling (something that took desktop Linux until this year to properly handle, and something that macOS doesn&#x27;t actually do correctly despite <i>appearing</i> to do so), Windows 11&#x27;s window management, and a deeper integration of .NET with Windows.<p>I&#x27;d like Microsoft to backport all that to the combined UI of Windows 2000 and Windows 7 (so probably Windows 7 with the &#x27;Classic&#x27; theme). I couldn&#x27;t care less about transparent menu bars. I don&#x27;t want iOS-style &#x27;switches&#x27;. I want clear tabs, radio buttons, checkboxes, and a slate-grey design that is so straightforward that it could be <i>software-rasterised</i> at 4K resolution, 144 frames per second without hiccups. I want the Windows 7-style control panel back.</div><br/><div id="41498693" class="c"><input type="checkbox" id="c-41498693" checked=""/><div class="controls bullet"><span class="by">ruthmarx</span><span>|</span><a href="#41491889">parent</a><span>|</span><a href="#41497229">next</a><span>|</span><label class="collapse" for="c-41498693">[-]</label><label class="expand" for="c-41498693">[1 more]</label></div><br/><div class="children"><div class="content">&gt; NT is why I like Windows so much and can&#x27;t stand Unix-likes. It is object-oriented from top to bottom,<p>This sounds like you are talking from a design perspective and the rest of your post seems to be from a usability perspective. Is this correct?<p>&gt; Windows 11 is irritatingly macOS-like<p>MacOS is such an objectively inferior design paradigm, very frustration to use. It&#x27;s Apple thinking &#x27;different&#x27; for the sake of being different, not because it&#x27;s good UI.<p>I only keep a W10 image around because it&#x27;s still supported and W11 seems like a lot more work to beat into shape. OpenShell at least makes things much better.</div><br/></div></div><div id="41497229" class="c"><input type="checkbox" id="c-41497229" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#41491889">parent</a><span>|</span><a href="#41498693">prev</a><span>|</span><a href="#41492370">next</a><span>|</span><label class="collapse" for="c-41497229">[-]</label><label class="expand" for="c-41497229">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Windows 11 is irritatingly macOS-like and for some reason<p>I bet dollars to donuts that all the designers who come up new Windows designs are using Macs.<p>The old Windows UI was designed out of painstaking end user testing which was famously responsible for the Start button.</div><br/><div id="41498653" class="c"><input type="checkbox" id="c-41498653" checked=""/><div class="controls bullet"><span class="by">SoothingSorbet</span><span>|</span><a href="#41491889">root</a><span>|</span><a href="#41497229">parent</a><span>|</span><a href="#41492370">next</a><span>|</span><label class="collapse" for="c-41498653">[-]</label><label class="expand" for="c-41498653">[1 more]</label></div><br/><div class="children"><div class="content">Indeed. And importantly, you could tell exactly which UI elements were which. It&#x27;s sometimes genuinely difficult to tell if an element is text, a button, or a button disguised as a link on Windows 10&#x2F;11.</div><br/></div></div></div></div><div id="41492370" class="c"><input type="checkbox" id="c-41492370" checked=""/><div class="controls bullet"><span class="by">nullindividual</span><span>|</span><a href="#41491889">parent</a><span>|</span><a href="#41497229">prev</a><span>|</span><a href="#41493467">next</a><span>|</span><label class="collapse" for="c-41492370">[-]</label><label class="expand" for="c-41492370">[3 more]</label></div><br/><div class="children"><div class="content">&gt; What I really want is a Windows 2000-esque UI with dense<p>Engineers like you and I want that. The common end user wants flashy, sleek, stylish (and apparently CandyCrush).<p>But don&#x27;t forget that that 2000 UI was flashy, sleek, and stylish with it&#x27;s fancy pants GDI+ and a mouse pointer with a <i>drop shadow</i>!</div><br/><div id="41492590" class="c"><input type="checkbox" id="c-41492590" checked=""/><div class="controls bullet"><span class="by">EvanAnderson</span><span>|</span><a href="#41491889">root</a><span>|</span><a href="#41492370">parent</a><span>|</span><a href="#41493467">next</a><span>|</span><label class="collapse" for="c-41492590">[-]</label><label class="expand" for="c-41492590">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The common end user wants flashy, sleek, stylish (and apparently CandyCrush).<p>Do they, though? I get the impression that nobody is actually testing with users. It seems more like UI developers want &quot;flashy, sleek, stylish&quot; and that&#x27;s what&#x27;s getting jammed down all our throats.</div><br/><div id="41492844" class="c"><input type="checkbox" id="c-41492844" checked=""/><div class="controls bullet"><span class="by">mattkevan</span><span>|</span><a href="#41491889">root</a><span>|</span><a href="#41492590">parent</a><span>|</span><a href="#41493467">next</a><span>|</span><label class="collapse" for="c-41492844">[-]</label><label class="expand" for="c-41492844">[1 more]</label></div><br/><div class="children"><div class="content">As a UI designer and developer, I would push the blame further along the stack and say that execs and shareholders want “flashy, sleek, stylish”, in the same way everything has to have AI jammed in now, lest the number start going down or not up quite as fast as hoped.</div><br/></div></div></div></div></div></div><div id="41493467" class="c"><input type="checkbox" id="c-41493467" checked=""/><div class="controls bullet"><span class="by">reisse</span><span>|</span><a href="#41491889">parent</a><span>|</span><a href="#41492370">prev</a><span>|</span><a href="#41497397">next</a><span>|</span><label class="collapse" for="c-41493467">[-]</label><label class="expand" for="c-41493467">[3 more]</label></div><br/><div class="children"><div class="content">Ah, it&#x27;s a cycle repeating itself. I remember when Microsoft first released XP it was considered bloated (UI-wise) compared to Windows 2000 and Windows 95&#x2F;98&#x2F;ME. Then Vista came and all of a sudden XP was in the limelight for being slim and fast!</div><br/><div id="41494286" class="c"><input type="checkbox" id="c-41494286" checked=""/><div class="controls bullet"><span class="by">aleph_minus_one</span><span>|</span><a href="#41491889">root</a><span>|</span><a href="#41493467">parent</a><span>|</span><a href="#41494893">next</a><span>|</span><label class="collapse" for="c-41494286">[-]</label><label class="expand" for="c-41494286">[1 more]</label></div><br/><div class="children"><div class="content">Even when Vista came, people told all the time that they consider Windows 2000 to be much less UI-bloated than Windows XP; it was just that of the &quot;UI bloat evils&quot; Windows XP was considered to be the lesser evil than Windows Vista. I really heard nobody saying that XP was slim and fast.<p>BTW: Windows 7 is another story: at that time PC magazines wrote deep analyses how some performance issues in the user interface code of Windows Vista that made Vista feel &quot;sluggish&quot; were fixed in Windows 7.</div><br/></div></div><div id="41494893" class="c"><input type="checkbox" id="c-41494893" checked=""/><div class="controls bullet"><span class="by">heraldgeezer</span><span>|</span><a href="#41491889">root</a><span>|</span><a href="#41493467">parent</a><span>|</span><a href="#41494286">prev</a><span>|</span><a href="#41497397">next</a><span>|</span><label class="collapse" for="c-41494893">[-]</label><label class="expand" for="c-41494893">[1 more]</label></div><br/><div class="children"><div class="content">I mean yes the default XP UI looks like bloated fisher price UI. But it has a classic mode that makes it look like Win 2000.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Windows_XP_visual_styles#Windows_Classic" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Windows_XP_visual_styles#Windo...</a></div><br/></div></div></div></div><div id="41497397" class="c"><input type="checkbox" id="c-41497397" checked=""/><div class="controls bullet"><span class="by">whoknowsidont</span><span>|</span><a href="#41491889">parent</a><span>|</span><a href="#41493467">prev</a><span>|</span><a href="#41494883">next</a><span>|</span><label class="collapse" for="c-41497397">[-]</label><label class="expand" for="c-41497397">[1 more]</label></div><br/><div class="children"><div class="content">&gt;It is object-oriented from top to bottom,<p>On what planet is this a good thing? What does this realistically and practically mean outside of some high level layer that provides syntax sugar for B2B dev&#x27;s. Lord knows you better not be talking about COM.<p>I honestly only see these types of comments from people who do NOT do systems programming.</div><br/></div></div><div id="41494883" class="c"><input type="checkbox" id="c-41494883" checked=""/><div class="controls bullet"><span class="by">Melatonic</span><span>|</span><a href="#41491889">parent</a><span>|</span><a href="#41497397">prev</a><span>|</span><a href="#41492666">next</a><span>|</span><label class="collapse" for="c-41494883">[-]</label><label class="expand" for="c-41494883">[2 more]</label></div><br/><div class="children"><div class="content">Agreed on you with everything here<p>That being said if you run something like Win10 LTSC (basically super stripped down win10 with no tracking and crapware) and turn off all window animations &#x2F; shadows &#x2F; etc you might be very surprised - it is snappy as hell. With a modern SSD stuff launches instantly and it is a totally different experience.</div><br/><div id="41496236" class="c"><input type="checkbox" id="c-41496236" checked=""/><div class="controls bullet"><span class="by">wkat4242</span><span>|</span><a href="#41491889">root</a><span>|</span><a href="#41494883">parent</a><span>|</span><a href="#41492666">next</a><span>|</span><label class="collapse" for="c-41496236">[-]</label><label class="expand" for="c-41496236">[1 more]</label></div><br/><div class="children"><div class="content">I run LTSC. You still get the tracking and some  crapware sadly.</div><br/></div></div></div></div><div id="41492666" class="c"><input type="checkbox" id="c-41492666" checked=""/><div class="controls bullet"><span class="by">EvanAnderson</span><span>|</span><a href="#41491889">parent</a><span>|</span><a href="#41494883">prev</a><span>|</span><a href="#41494714">next</a><span>|</span><label class="collapse" for="c-41492666">[-]</label><label class="expand" for="c-41492666">[1 more]</label></div><br/><div class="children"><div class="content">I love that NT was actually designed. I don&#x27;t necessarily like all of the design but I like that people actually thought about it.</div><br/></div></div><div id="41494714" class="c"><input type="checkbox" id="c-41494714" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#41491889">parent</a><span>|</span><a href="#41492666">prev</a><span>|</span><a href="#41492989">next</a><span>|</span><label class="collapse" for="c-41494714">[-]</label><label class="expand" for="c-41494714">[1 more]</label></div><br/><div class="children"><div class="content">&gt; slate-grey design that is so straightforward that it could be software-rasterised at 4K resolution, 144 frames per second without hiccups<p>This is not possible (measure software blitting performance and you&#x27;ll see), and for power reasons you wouldn&#x27;t want to even if it were.</div><br/></div></div><div id="41492989" class="c"><input type="checkbox" id="c-41492989" checked=""/><div class="controls bullet"><span class="by">AshamedCaptain</span><span>|</span><a href="#41491889">parent</a><span>|</span><a href="#41494714">prev</a><span>|</span><a href="#41492098">next</a><span>|</span><label class="collapse" for="c-41492989">[-]</label><label class="expand" for="c-41492989">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The sluggishness of the OS even on super-powerful machines is painful to witness and might even lead to the demise of this OS.<p>NT has been sluggish since _forever_. It is hardly a bloated GUI problem. On machines were 9x would literally fly NT would fail to boot due to low memory.</div><br/><div id="41493500" class="c"><input type="checkbox" id="c-41493500" checked=""/><div class="controls bullet"><span class="by">nullindividual</span><span>|</span><a href="#41491889">root</a><span>|</span><a href="#41492989">parent</a><span>|</span><a href="#41492098">next</a><span>|</span><label class="collapse" for="c-41493500">[-]</label><label class="expand" for="c-41493500">[1 more]</label></div><br/><div class="children"><div class="content">Not sure what NT4 systems you were dealing with, but I&#x27;ve dealt with ones thrashing the page file on spinning rust and the GUI is still responsive.<p>NT4 had a higher base RAM requirement than 9x. Significantly so.</div><br/></div></div></div></div><div id="41492098" class="c"><input type="checkbox" id="c-41492098" checked=""/><div class="controls bullet"><span class="by">kev009</span><span>|</span><a href="#41491889">parent</a><span>|</span><a href="#41492989">prev</a><span>|</span><a href="#41493600">next</a><span>|</span><label class="collapse" for="c-41492098">[-]</label><label class="expand" for="c-41492098">[9 more]</label></div><br/><div class="children"><div class="content">It&#x27;s never been commonplace but can&#x27;t you still run alternate shells (the Windows term for the GUI, not the command prompt in UNIX parlance)?</div><br/><div id="41492429" class="c"><input type="checkbox" id="c-41492429" checked=""/><div class="controls bullet"><span class="by">bragr</span><span>|</span><a href="#41491889">root</a><span>|</span><a href="#41492098">parent</a><span>|</span><a href="#41493206">next</a><span>|</span><label class="collapse" for="c-41492429">[-]</label><label class="expand" for="c-41492429">[5 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;List_of_alternative_shells_for_Windows" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;List_of_alternative_shells_for...</a></div><br/><div id="41493349" class="c"><input type="checkbox" id="c-41493349" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#41491889">root</a><span>|</span><a href="#41492429">parent</a><span>|</span><a href="#41493206">next</a><span>|</span><label class="collapse" for="c-41493349">[-]</label><label class="expand" for="c-41493349">[4 more]</label></div><br/><div class="children"><div class="content">The wiki that you posted does not include busybox.<p><a href="https:&#x2F;&#x2F;frippery.org&#x2F;busybox&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;frippery.org&#x2F;busybox&#x2F;index.html</a></div><br/><div id="41493602" class="c"><input type="checkbox" id="c-41493602" checked=""/><div class="controls bullet"><span class="by">kev009</span><span>|</span><a href="#41491889">root</a><span>|</span><a href="#41493349">parent</a><span>|</span><a href="#41493206">next</a><span>|</span><label class="collapse" for="c-41493602">[-]</label><label class="expand" for="c-41493602">[3 more]</label></div><br/><div class="children"><div class="content">You didn&#x27;t understand the parenthetical, busybox has no relation to the Windows shell.</div><br/><div id="41496907" class="c"><input type="checkbox" id="c-41496907" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#41491889">root</a><span>|</span><a href="#41493602">parent</a><span>|</span><a href="#41493206">next</a><span>|</span><label class="collapse" for="c-41496907">[-]</label><label class="expand" for="c-41496907">[2 more]</label></div><br/><div class="children"><div class="content">It <i>is</i> a Windows shell. A POSIX Windows shell.<p>Such as should have been present at the beginning, not the OS&#x2F;2 affliction.</div><br/><div id="41497026" class="c"><input type="checkbox" id="c-41497026" checked=""/><div class="controls bullet"><span class="by">kev009</span><span>|</span><a href="#41491889">root</a><span>|</span><a href="#41496907">parent</a><span>|</span><a href="#41493206">next</a><span>|</span><label class="collapse" for="c-41497026">[-]</label><label class="expand" for="c-41497026">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately it is still clear you don&#x27;t understand my comment nor the linked wikipedia page at all.  Windows Shell isn&#x27;t the same use of the word you are overloading here in this thread and you are out in left field from what everyone else is talking about.  Maybe revisit the wikipedia page and read a little more, look at the project descriptions&amp;screencaps, and it will make sense to you.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41493206" class="c"><input type="checkbox" id="c-41493206" checked=""/><div class="controls bullet"><span class="by">EricE</span><span>|</span><a href="#41491889">root</a><span>|</span><a href="#41492098">parent</a><span>|</span><a href="#41492429">prev</a><span>|</span><a href="#41492144">next</a><span>|</span><label class="collapse" for="c-41493206">[-]</label><label class="expand" for="c-41493206">[1 more]</label></div><br/><div class="children"><div class="content">Indeed the first thing I do on a new Windows install is load Open Shell.</div><br/></div></div><div id="41492144" class="c"><input type="checkbox" id="c-41492144" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#41491889">root</a><span>|</span><a href="#41492098">parent</a><span>|</span><a href="#41493206">prev</a><span>|</span><a href="#41493333">next</a><span>|</span><label class="collapse" for="c-41492144">[-]</label><label class="expand" for="c-41492144">[1 more]</label></div><br/><div class="children"><div class="content">You still can, and it&#x27;s even exposed specifically for making constrained setups (though not everyone knows to use it)</div><br/></div></div><div id="41493333" class="c"><input type="checkbox" id="c-41493333" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#41491889">root</a><span>|</span><a href="#41492098">parent</a><span>|</span><a href="#41492144">prev</a><span>|</span><a href="#41493600">next</a><span>|</span><label class="collapse" for="c-41493333">[-]</label><label class="expand" for="c-41493333">[1 more]</label></div><br/><div class="children"><div class="content">Busybox has a great shell in the Windows port.<p>It calls itself &quot;bash&quot; but it is really the Almquist shell with a bit of added bash syntactic sugar. It does not support arrays.<p><a href="https:&#x2F;&#x2F;frippery.org&#x2F;busybox&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;frippery.org&#x2F;busybox&#x2F;index.html</a></div><br/></div></div></div></div><div id="41493600" class="c"><input type="checkbox" id="c-41493600" checked=""/><div class="controls bullet"><span class="by">markus_zhang</span><span>|</span><a href="#41491889">parent</a><span>|</span><a href="#41492098">prev</a><span>|</span><a href="#41497192">next</a><span>|</span><label class="collapse" for="c-41493600">[-]</label><label class="expand" for="c-41493600">[2 more]</label></div><br/><div class="children"><div class="content">Win 2000 was the pinnacle. I stuck to it until WinXP was almost out of breath and reluctantly moved to it. Everything afterwards is pretty meh.</div><br/><div id="41498701" class="c"><input type="checkbox" id="c-41498701" checked=""/><div class="controls bullet"><span class="by">ruthmarx</span><span>|</span><a href="#41491889">root</a><span>|</span><a href="#41493600">parent</a><span>|</span><a href="#41497192">next</a><span>|</span><label class="collapse" for="c-41498701">[-]</label><label class="expand" for="c-41498701">[1 more]</label></div><br/><div class="children"><div class="content">Windows 7 was pretty great.</div><br/></div></div></div></div></div></div><div id="41497192" class="c"><input type="checkbox" id="c-41497192" checked=""/><div class="controls bullet"><span class="by">IgorPartola</span><span>|</span><a href="#41491889">prev</a><span>|</span><a href="#41495448">next</a><span>|</span><label class="collapse" for="c-41497192">[-]</label><label class="expand" for="c-41497192">[1 more]</label></div><br/><div class="children"><div class="content">What I don’t see in the comments here is the argument I remember hearing in the late 90s and early 2000s: that Unix is simpler than Windows. I certainly feel like it was easier for me to grasp the POSIX API compared to what Windows was doing at the time.</div><br/></div></div><div id="41495448" class="c"><input type="checkbox" id="c-41495448" checked=""/><div class="controls bullet"><span class="by">desdenova</span><span>|</span><a href="#41497192">prev</a><span>|</span><a href="#41496672">next</a><span>|</span><label class="collapse" for="c-41495448">[-]</label><label class="expand" for="c-41495448">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately NT doesn&#x27;t have any usable distribution, so it&#x27;s still a theoretical OS design.</div><br/></div></div><div id="41496672" class="c"><input type="checkbox" id="c-41496672" checked=""/><div class="controls bullet"><span class="by">AdeptusAquinas</span><span>|</span><a href="#41495448">prev</a><span>|</span><a href="#41494278">next</a><span>|</span><label class="collapse" for="c-41496672">[-]</label><label class="expand" for="c-41496672">[2 more]</label></div><br/><div class="children"><div class="content">Could someone explain the &#x27;sluggish ui responsiveness&#x27; talked about in the conclusion? I&#x27;ve never experienced it in 11, 10, 8 or 7 etc - but maybe thats because my windows machines are always gaming machines and have a contemporary powerful graphics card. I&#x27;ve used a mac pro for work a couple of times and never noticed that being snippier than my home machine.</div><br/><div id="41497182" class="c"><input type="checkbox" id="c-41497182" checked=""/><div class="controls bullet"><span class="by">IgorPartola</span><span>|</span><a href="#41496672">parent</a><span>|</span><a href="#41494278">next</a><span>|</span><label class="collapse" for="c-41497182">[-]</label><label class="expand" for="c-41497182">[1 more]</label></div><br/><div class="children"><div class="content">I think this is taking about a much older version of Windows, such as XP and Vista. Vista was particularly bad.</div><br/></div></div></div></div><div id="41494278" class="c"><input type="checkbox" id="c-41494278" checked=""/><div class="controls bullet"><span class="by">Circlecrypto2</span><span>|</span><a href="#41496672">prev</a><span>|</span><a href="#41496631">next</a><span>|</span><label class="collapse" for="c-41494278">[-]</label><label class="expand" for="c-41494278">[2 more]</label></div><br/><div class="children"><div class="content">A great article that taught me a lot of history. As a long time Linux user and advocate for that history, I learned there is actually a lot to appreciate from the work that went into NT.</div><br/><div id="41494371" class="c"><input type="checkbox" id="c-41494371" checked=""/><div class="controls bullet"><span class="by">RachelF</span><span>|</span><a href="#41494278">parent</a><span>|</span><a href="#41496631">next</a><span>|</span><label class="collapse" for="c-41494371">[-]</label><label class="expand" for="c-41494371">[1 more]</label></div><br/><div class="children"><div class="content">The original NT was a great design, built by people who knew what they were doing and had done it before (for VMS). It was superior to the Unix design when it came out, benefiting from the knowledge of 15 years.<p>I worked on kernel drivers starting in with NT 3.5. However, over the years, the kernel has become bloated. The bloat is both in code and in architecture.<p>I guess this is inevitable as the original team has long gone, and it is now too large for anyone to understand the whole thing.</div><br/></div></div></div></div><div id="41496631" class="c"><input type="checkbox" id="c-41496631" checked=""/><div class="controls bullet"><span class="by">lukeh</span><span>|</span><a href="#41494278">prev</a><span>|</span><a href="#41496821">next</a><span>|</span><label class="collapse" for="c-41496631">[-]</label><label class="expand" for="c-41496631">[1 more]</label></div><br/><div class="children"><div class="content">No one was using X.500 for user accounts on Solaris, until LDAP and RFC 2307 came along. And at that point hardly anyone was using X.500. A bit more research would have mentioned NIS.</div><br/></div></div><div id="41496821" class="c"><input type="checkbox" id="c-41496821" checked=""/><div class="controls bullet"><span class="by">virgulino</span><span>|</span><a href="#41496631">prev</a><span>|</span><a href="#41494343">next</a><span>|</span><label class="collapse" for="c-41496821">[-]</label><label class="expand" for="c-41496821">[1 more]</label></div><br/><div class="children"><div class="content">Inside Windows NT, the 1st edition, by Helen Custer, is one of my all-time favorite books! A forgotten gem. It&#x27;s good to see it being praised.</div><br/></div></div><div id="41494343" class="c"><input type="checkbox" id="c-41494343" checked=""/><div class="controls bullet"><span class="by">parl_match</span><span>|</span><a href="#41496821">prev</a><span>|</span><a href="#41491572">next</a><span>|</span><label class="collapse" for="c-41494343">[-]</label><label class="expand" for="c-41494343">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Unix’s history is long—much longer than NT’s<p>Fun fact: NT is a spiritual (and in some cases, literal) successor of VMS, which itself is a direct descendant of the RSX family of operating systems, which are themselves a descendant of a process control family of task runners from 1960. Unix goes back to 1964 - Multics.<p>Although yeah, Unix definitely has a much longer unbroken chain.</div><br/></div></div><div id="41491572" class="c"><input type="checkbox" id="c-41491572" checked=""/><div class="controls bullet"><span class="by">stevekemp</span><span>|</span><a href="#41494343">prev</a><span>|</span><a href="#41492529">next</a><span>|</span><label class="collapse" for="c-41491572">[-]</label><label class="expand" for="c-41491572">[2 more]</label></div><br/><div class="children"><div class="content">I wonder how many of the features which other operating systems got much later, such as the unified buffer cache, were due to worries of software patents?</div><br/><div id="41491668" class="c"><input type="checkbox" id="c-41491668" checked=""/><div class="controls bullet"><span class="by">kev009</span><span>|</span><a href="#41491572">parent</a><span>|</span><a href="#41492529">next</a><span>|</span><label class="collapse" for="c-41491668">[-]</label><label class="expand" for="c-41491668">[1 more]</label></div><br/><div class="children"><div class="content">UBC is one of the more technically challenging things to retrofit onto BSD, see <a href="https:&#x2F;&#x2F;www.usenix.org&#x2F;legacy&#x2F;event&#x2F;usenix2000&#x2F;freenix&#x2F;full_papers&#x2F;silvers&#x2F;silvers.pdf" rel="nofollow">https:&#x2F;&#x2F;www.usenix.org&#x2F;legacy&#x2F;event&#x2F;usenix2000&#x2F;freenix&#x2F;full_...</a> -- in particular note that it wasn&#x27;t a universal performance improvement as of that paper.  Some long lived UNIX like HP-UX never accomplished it.<p>See <a href="http:&#x2F;&#x2F;mcvoy.com&#x2F;lm&#x2F;papers&#x2F;SunOS.vm_arch.pdf" rel="nofollow">http:&#x2F;&#x2F;mcvoy.com&#x2F;lm&#x2F;papers&#x2F;SunOS.vm_arch.pdf</a> and <a href="http:&#x2F;&#x2F;mcvoy.com&#x2F;lm&#x2F;papers&#x2F;SunOS.vfs_arch.pdf" rel="nofollow">http:&#x2F;&#x2F;mcvoy.com&#x2F;lm&#x2F;papers&#x2F;SunOS.vfs_arch.pdf</a></div><br/></div></div></div></div><div id="41492529" class="c"><input type="checkbox" id="c-41492529" checked=""/><div class="controls bullet"><span class="by">jhallenworld</span><span>|</span><a href="#41491572">prev</a><span>|</span><a href="#41494948">next</a><span>|</span><label class="collapse" for="c-41492529">[-]</label><label class="expand" for="c-41492529">[2 more]</label></div><br/><div class="children"><div class="content">NT has its object manager.. the problem with it is visibility.  Yes, object manager type functionality was bolted-on to UNIX, but at least it&#x27;s all visible in the filesystem.  In NT, you need a special utility WinObj to browse it.</div><br/><div id="41492539" class="c"><input type="checkbox" id="c-41492539" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#41492529">parent</a><span>|</span><a href="#41494948">next</a><span>|</span><label class="collapse" for="c-41492539">[-]</label><label class="expand" for="c-41492539">[1 more]</label></div><br/><div class="children"><div class="content">Under ReactOS you have a bundled NT obj explorer under explorer.exe and maybe shell32.dll.<p>Maybe if you can run that explorer under NT systems you could explore them under the original NT OSes too.<p>Edit: <a href="https:&#x2F;&#x2F;winclassic.net&#x2F;thread&#x2F;1852&#x2F;reactos-registry-ntobjectnamespace-folders-windows" rel="nofollow">https:&#x2F;&#x2F;winclassic.net&#x2F;thread&#x2F;1852&#x2F;reactos-registry-ntobject...</a></div><br/></div></div></div></div><div id="41494948" class="c"><input type="checkbox" id="c-41494948" checked=""/><div class="controls bullet"><span class="by">p0seidon</span><span>|</span><a href="#41492529">prev</a><span>|</span><a href="#41497938">next</a><span>|</span><label class="collapse" for="c-41494948">[-]</label><label class="expand" for="c-41494948">[1 more]</label></div><br/><div class="children"><div class="content">This is such a well-written read, just so insightful and broad in its knowledge. I learned a lot, thank you (loved NT at that time - now I know why).</div><br/></div></div><div id="41497938" class="c"><input type="checkbox" id="c-41497938" checked=""/><div class="controls bullet"><span class="by">davidczech</span><span>|</span><a href="#41494948">prev</a><span>|</span><a href="#41497913">next</a><span>|</span><label class="collapse" for="c-41497938">[-]</label><label class="expand" for="c-41497938">[1 more]</label></div><br/><div class="children"><div class="content">Neo</div><br/></div></div><div id="41497913" class="c"><input type="checkbox" id="c-41497913" checked=""/><div class="controls bullet"><span class="by">chriscappuccio</span><span>|</span><a href="#41497938">prev</a><span>|</span><label class="collapse" for="c-41497913">[-]</label><label class="expand" for="c-41497913">[1 more]</label></div><br/><div class="children"><div class="content">Windows was great at running word processors. BSD and Linux were great as internet scale servers. It was until Microsoft tried running Hotmail on NT that they had any idea there was a problem. Microsoft used this experience to fix problms that ultimately made Windows better for all users across many use cases.<p>All the talk here about how Windows had a better architecture into he beginning conveniently avoids the fact that windows was well known for being over-designed while delivering much less than its counterparts in the networking arena for a long time.<p>Its not wrong to admire what windows got right, but Unix got so much right by putting attention where it was needed.</div><br/></div></div></div></div></div></div></div></body></html>