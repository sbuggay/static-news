<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1692003665494" as="style"/><link rel="stylesheet" href="styles.css?v=1692003665494"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://korban.net/posts/2023-08-11-thoughts-on-elixir-phoenix-liveview/">Thoughts on Elixir, Phoenix and LiveView after 18 months of commercial use</a> <span class="domain">(<a href="https://korban.net">korban.net</a>)</span></div><div class="subtext"><span>clessg</span> | <span>64 comments</span></div><br/><div><div id="37118722" class="c"><input type="checkbox" id="c-37118722" checked=""/><div class="controls bullet"><span class="by">josevalim</span><span>|</span><a href="#37117155">next</a><span>|</span><label class="collapse" for="c-37118722">[-]</label><label class="expand" for="c-37118722">[2 more]</label></div><br/><div class="children"><div class="content">Hi @SupremumLimit, that was a great article, thanks for sharing. Here are some tiny remarks, in case they help:<p>* About dot when calling anonymous functions, I have just published an article I have been sitting on. I hope it clarifies a bit why it exists and its benefits for code readability: <a href="https:&#x2F;&#x2F;dashbit.co&#x2F;blog&#x2F;why-the-dot" rel="nofollow noreferrer">https:&#x2F;&#x2F;dashbit.co&#x2F;blog&#x2F;why-the-dot</a><p>* Regarding keywords, I actually don&#x27;t consider them to be a replacement for named arguments. However, given they are called &quot;keyword lists&quot;, it is an easy association to make. I will make sure we focus more on them as _optional arguments_.<p>* There is a distinction about `is_map` vs `keyword?` but of course you can still argue it is inconsistent from an external perspective. With a potential type system arriving, it may be something we could start enforcing more explicitly.<p>* Your approach to using contexts is absolutely fine. Phoenix typically does not care how you answer the context question, as long as you answer it. The goal is to avoid the case where you build an application for 18 months without considering how it should be organized.<p>* You are 100% correct on functional components vs live components. I will make it clearer in the docs the former should be preferred.</div><br/><div id="37118898" class="c"><input type="checkbox" id="c-37118898" checked=""/><div class="controls bullet"><span class="by">SupremumLimit</span><span>|</span><a href="#37118722">parent</a><span>|</span><a href="#37117155">next</a><span>|</span><label class="collapse" for="c-37118898">[-]</label><label class="expand" for="c-37118898">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the post about the dot, interesting stuff and the TL;DR is excellent.</div><br/></div></div></div></div><div id="37117155" class="c"><input type="checkbox" id="c-37117155" checked=""/><div class="controls bullet"><span class="by">sodapopcan</span><span>|</span><a href="#37118722">prev</a><span>|</span><a href="#37118591">next</a><span>|</span><label class="collapse" for="c-37117155">[-]</label><label class="expand" for="c-37117155">[13 more]</label></div><br/><div class="children"><div class="content">Very solid article with many points I agree with.<p>Some notes:<p>Keywords are not simply &quot;another pragmatic solution that won over finding a more elegant way to support named arguments&quot; and they are inherently different than maps and serve different purposes.  Maps are unordered hashes, keyword lists are constant time, ordered list that can have duplicate keys.  For example, in the language core, duplicate keys are used:<p><pre><code>    import Foo, only: [bar: 1, bar: 2]
</code></pre>
Ecto&#x27;s query syntax makes use of both duplicate keys and ordering:<p><pre><code>    from q in query,
      join: t in assoc(q, :table),
      on: q.table_id = t.id,
      join: o in assoc(t, :other),
      on: t.other_id = o.id
</code></pre>
Everyone complains about the f.() syntax.  It&#x27;s necessary as explained in the guides in the Anonymous Functions section [0].  There is also a nice little parallel to Erlang in that a regular function call looks like `f()` whereas an anonymous function call looks like `F()`.<p>Contexts can be confusing, unfortunately.  They&#x27;re based off of bounded contexts from Domain Driven Design.  I wouldn&#x27;t say there is one <i>right</i> way to use Phoenix contexts, though reading up on DDD&#x27;s bounded contexts really helps.  I already had DDD experience before I learned Elixir, though, so it&#x27;s easy for me to say and maybe more of a pain for others who don&#x27;t want to do that.<p>Comprehensions can be much more concise in certain situations.  You can certainly get away with avoiding them, but they can really come in handy sometimes.  Not gonna give examples as this is getting too long.  A short example would be Cartesian products.<p>Finally, I don&#x27;t quite understand the gripe with `on_mount` or even `live_session` but that&#x27;s been addressed in another comment.<p>[0] <a href="https:&#x2F;&#x2F;elixir-lang.org&#x2F;getting-started&#x2F;basic-types.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;elixir-lang.org&#x2F;getting-started&#x2F;basic-types.html</a></div><br/><div id="37117731" class="c"><input type="checkbox" id="c-37117731" checked=""/><div class="controls bullet"><span class="by">rapnie</span><span>|</span><a href="#37117155">parent</a><span>|</span><a href="#37118580">next</a><span>|</span><label class="collapse" for="c-37117731">[-]</label><label class="expand" for="c-37117731">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Contexts can be confusing, unfortunately. They&#x27;re based off of bounded contexts from Domain Driven Design. I wouldn&#x27;t say there is one right way to use Phoenix contexts, though reading up on DDD&#x27;s bounded contexts really helps. I already had DDD experience before I learned Elixir, though, so it&#x27;s easy for me to say and maybe more of a pain for others who don&#x27;t want to do that.<p>Jenny Shih gave a talk comparing Phoenix contexts with DDD bounded contexts.<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=vr-qhHrN5_4">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=vr-qhHrN5_4</a></div><br/></div></div><div id="37117246" class="c"><input type="checkbox" id="c-37117246" checked=""/><div class="controls bullet"><span class="by">jkhdigital</span><span>|</span><a href="#37117155">parent</a><span>|</span><a href="#37118580">prev</a><span>|</span><a href="#37118411">next</a><span>|</span><label class="collapse" for="c-37117246">[-]</label><label class="expand" for="c-37117246">[1 more]</label></div><br/><div class="children"><div class="content">Another note:<p>The “inconsistent” naming is actually a way to distinguish between guard and non-guard functions: is_map can be used in guards while empty? cannot.</div><br/></div></div><div id="37118411" class="c"><input type="checkbox" id="c-37118411" checked=""/><div class="controls bullet"><span class="by">boxed</span><span>|</span><a href="#37117155">parent</a><span>|</span><a href="#37117246">prev</a><span>|</span><a href="#37117488">next</a><span>|</span><label class="collapse" for="c-37118411">[-]</label><label class="expand" for="c-37118411">[2 more]</label></div><br/><div class="children"><div class="content">Maps can be ordered though. In Python they are, and keyword arguments in Python are implemented as these ordered maps (dicts), and they disallow duplicate keys. So I do understand how it can be confusing coming from another language for example.</div><br/><div id="37118644" class="c"><input type="checkbox" id="c-37118644" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#37117155">root</a><span>|</span><a href="#37118411">parent</a><span>|</span><a href="#37117488">next</a><span>|</span><label class="collapse" for="c-37118644">[-]</label><label class="expand" for="c-37118644">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s just a matter of algorithmic complexity. A hashmap, ordered or not, is more complicated than a linked list, which is what Keywords are built upon.<p>The former requires turning an arbitrary piece of data, hashing it to an integer, and indexing a cell based off this value, dealing with potential collisions on the way. In C terms it&#x27;s 50 lines long.<p>The latter is a simple iteration and string comparison. In C terms it&#x27;s 5 lines long.<p>It is confusing if you&#x27;ve never programmed close to the metal and only know high level languages. Maps are good for data that you need to access in random order, linked lists&#x2F;keyword lists for data that either you access in linear order, or it is so small the overhead of a map is too much.<p>If you have less than 10 elements, a linked list will always be faster than any hashmap on modern CPUs.</div><br/></div></div></div></div><div id="37117488" class="c"><input type="checkbox" id="c-37117488" checked=""/><div class="controls bullet"><span class="by">SupremumLimit</span><span>|</span><a href="#37117155">parent</a><span>|</span><a href="#37118411">prev</a><span>|</span><a href="#37117964">next</a><span>|</span><label class="collapse" for="c-37117488">[-]</label><label class="expand" for="c-37117488">[5 more]</label></div><br/><div class="children"><div class="content">[I am the author of the post.] I know that keyword lists are different from maps, but I think their superficial similarity to maps isn’t ideal, and I don’t think that they’re the best possible solution (eg consider pattern matching on keyword lists which is order dependent, it’s not intuitive in the case of named args). They’re confusing to newcomers because of these things.</div><br/><div id="37118697" class="c"><input type="checkbox" id="c-37118697" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#37117155">root</a><span>|</span><a href="#37117488">parent</a><span>|</span><a href="#37117773">next</a><span>|</span><label class="collapse" for="c-37118697">[-]</label><label class="expand" for="c-37118697">[2 more]</label></div><br/><div class="children"><div class="content">&gt; They’re confusing to newcomers because of these things.<p>Then they learn how they work and stop being confused.<p>I struggle to see why we are so terribly afraid of people learning. Programming is not an innate instinct after all.<p>A programmer that doesn&#x27;t understand linked lists yet is basically a newbie, but it&#x27;s a topic you learn in one day and makes you a better programmer.<p>This should be encouraged, rather than listed as a con.</div><br/><div id="37118795" class="c"><input type="checkbox" id="c-37118795" checked=""/><div class="controls bullet"><span class="by">foldr</span><span>|</span><a href="#37117155">root</a><span>|</span><a href="#37118697">parent</a><span>|</span><a href="#37117773">next</a><span>|</span><label class="collapse" for="c-37118795">[-]</label><label class="expand" for="c-37118795">[1 more]</label></div><br/><div class="children"><div class="content">The main problem with them in Elixir is that you can&#x27;t pattern match on keyword arguments without imposing an arbitrary order.</div><br/></div></div></div></div><div id="37117773" class="c"><input type="checkbox" id="c-37117773" checked=""/><div class="controls bullet"><span class="by">sethcalebweeks</span><span>|</span><a href="#37117155">root</a><span>|</span><a href="#37117488">parent</a><span>|</span><a href="#37118697">prev</a><span>|</span><a href="#37117964">next</a><span>|</span><label class="collapse" for="c-37117773">[-]</label><label class="expand" for="c-37117773">[2 more]</label></div><br/><div class="children"><div class="content">Keyword lists were certainly confusing as a newcomer. But, FWIW, they existed well before maps. The AST is made up of only tuples and keyword lists on top of atoms and other literals. (Actually, if I&#x27;m not mistaken, keyword lists themselves are just lists with tuples of atom&#x2F;value pairs. If you dig far enough down, it&#x27;s incredible just how much of the language is built on top of a tiny number of primitives. Almost every bit of syntax you can think of is probably several layers of macros.)</div><br/><div id="37118279" class="c"><input type="checkbox" id="c-37118279" checked=""/><div class="controls bullet"><span class="by">bobwaycott</span><span>|</span><a href="#37117155">root</a><span>|</span><a href="#37117773">parent</a><span>|</span><a href="#37117964">next</a><span>|</span><label class="collapse" for="c-37118279">[-]</label><label class="expand" for="c-37118279">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Actually, if I&#x27;m not mistaken, keyword lists themselves are just lists with tuples of atom&#x2F;value pairs.</i><p>You are correct. A keyword list is `[{atom, any}]`.</div><br/></div></div></div></div></div></div><div id="37117964" class="c"><input type="checkbox" id="c-37117964" checked=""/><div class="controls bullet"><span class="by">foldr</span><span>|</span><a href="#37117155">parent</a><span>|</span><a href="#37117488">prev</a><span>|</span><a href="#37118591">next</a><span>|</span><label class="collapse" for="c-37117964">[-]</label><label class="expand" for="c-37117964">[2 more]</label></div><br/><div class="children"><div class="content">&gt; keyword lists are constant time, ordered list<p>Unless there’s some kind of behind-the-scenes magic that I’m unaware of, keyword list look up is O(n), not O(1).</div><br/><div id="37118175" class="c"><input type="checkbox" id="c-37118175" checked=""/><div class="controls bullet"><span class="by">bitwalker</span><span>|</span><a href="#37117155">root</a><span>|</span><a href="#37117964">parent</a><span>|</span><a href="#37118591">next</a><span>|</span><label class="collapse" for="c-37118175">[-]</label><label class="expand" for="c-37118175">[1 more]</label></div><br/><div class="children"><div class="content">No, you’re exactly right, they are just regular singly-linked lists of tuples, nothing more.</div><br/></div></div></div></div></div></div><div id="37118591" class="c"><input type="checkbox" id="c-37118591" checked=""/><div class="controls bullet"><span class="by">dns_snek</span><span>|</span><a href="#37117155">prev</a><span>|</span><a href="#37117827">next</a><span>|</span><label class="collapse" for="c-37118591">[-]</label><label class="expand" for="c-37118591">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Live components are best avoided if possible, in my view. The documentation is quite bullish on them, presenting them as just another thing alongside functional components, but I think they should be more of a last resort, with functional components used whenever possible.<p>That&#x27;s an interesting view. I tend to use Live Components whenever I&#x27;m rendering a list, because if you don&#x27;t, you&#x27;ll quickly notice how the entire list gets re-rendered and sent over the wire whenever one of the elements on the list changes.<p>Live Components act as a sort of a barrier for this, they have a long-lived persistent ID that uniquely identifies the component, so when you&#x27;re rendering a list of them, only the modified component gets sent over the wire. The effect this has on bandwidth usage can be dramatic, depending on the number of items in your list.</div><br/><div id="37118621" class="c"><input type="checkbox" id="c-37118621" checked=""/><div class="controls bullet"><span class="by">LukaD</span><span>|</span><a href="#37118591">parent</a><span>|</span><a href="#37117827">next</a><span>|</span><label class="collapse" for="c-37118621">[-]</label><label class="expand" for="c-37118621">[2 more]</label></div><br/><div class="children"><div class="content">&gt; That&#x27;s an interesting view. I tend to use Live Components whenever I&#x27;m rendering a list, because if you don&#x27;t, you&#x27;ll quickly notice how the entire list gets re-rendered and sent over the wire whenever one of the elements on the list changes.<p>That&#x27;s what streams are for <a href="https:&#x2F;&#x2F;hexdocs.pm&#x2F;phoenix_live_view&#x2F;Phoenix.LiveView.html#stream&#x2F;4" rel="nofollow noreferrer">https:&#x2F;&#x2F;hexdocs.pm&#x2F;phoenix_live_view&#x2F;Phoenix.LiveView.html#s...</a></div><br/><div id="37118686" class="c"><input type="checkbox" id="c-37118686" checked=""/><div class="controls bullet"><span class="by">dns_snek</span><span>|</span><a href="#37118591">root</a><span>|</span><a href="#37118621">parent</a><span>|</span><a href="#37117827">next</a><span>|</span><label class="collapse" for="c-37118686">[-]</label><label class="expand" for="c-37118686">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s new! I&#x27;ll go have a look, thanks.</div><br/></div></div></div></div></div></div><div id="37117827" class="c"><input type="checkbox" id="c-37117827" checked=""/><div class="controls bullet"><span class="by">cschmatzler</span><span>|</span><a href="#37118591">prev</a><span>|</span><a href="#37117035">next</a><span>|</span><label class="collapse" for="c-37117827">[-]</label><label class="expand" for="c-37117827">[16 more]</label></div><br/><div class="children"><div class="content">&gt; or inconsistent naming (is_map vs empty?).<p>fyi, this isn’t inconsistent. <a href="https:&#x2F;&#x2F;hexdocs.pm&#x2F;elixir&#x2F;1.15&#x2F;naming-conventions.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;hexdocs.pm&#x2F;elixir&#x2F;1.15&#x2F;naming-conventions.html</a></div><br/><div id="37118014" class="c"><input type="checkbox" id="c-37118014" checked=""/><div class="controls bullet"><span class="by">Munksgaard</span><span>|</span><a href="#37117827">parent</a><span>|</span><a href="#37117035">next</a><span>|</span><label class="collapse" for="c-37118014">[-]</label><label class="expand" for="c-37118014">[15 more]</label></div><br/><div class="children"><div class="content">While true, I think the larger problem is that it is not intuitive (at least to me) when I can expect a function to be of the `is_` vs `?` form. It&#x27;s a leaky abstraction.</div><br/><div id="37118163" class="c"><input type="checkbox" id="c-37118163" checked=""/><div class="controls bullet"><span class="by">bitwalker</span><span>|</span><a href="#37117827">root</a><span>|</span><a href="#37118014">parent</a><span>|</span><a href="#37118249">next</a><span>|</span><label class="collapse" for="c-37118163">[-]</label><label class="expand" for="c-37118163">[5 more]</label></div><br/><div class="children"><div class="content">The only time `is_` is used, is with functions permitted in guards. These are functions defined in Erlang, and only a small handful exist, and you learn them very early on. With the advent of `defguard`, it is conventional to use `is_` with custom guards as well, but that’s the intuition - guards vs general predicates.</div><br/><div id="37118277" class="c"><input type="checkbox" id="c-37118277" checked=""/><div class="controls bullet"><span class="by">Munksgaard</span><span>|</span><a href="#37117827">root</a><span>|</span><a href="#37118163">parent</a><span>|</span><a href="#37118249">next</a><span>|</span><label class="collapse" for="c-37118277">[-]</label><label class="expand" for="c-37118277">[4 more]</label></div><br/><div class="children"><div class="content">Sure thing. My point is that, if I want to check whether an argument is a keyword list, I have to do extra mental work to guess whether the correct function to use is `is_keyword` or `keyword?`. There also doesn&#x27;t seem to be a consistent rule I can apply to figure out whether it&#x27;s one or the other. Conversely, I also get tripped up every time I want to add a guard to a function like, &quot;is the thing I want to test written as a macro or not?&quot;.<p>I understand the reasoning for the distinction and its roots in Erlang, it&#x27;s just not very elegant to work with.</div><br/><div id="37118511" class="c"><input type="checkbox" id="c-37118511" checked=""/><div class="controls bullet"><span class="by">bobwaycott</span><span>|</span><a href="#37117827">root</a><span>|</span><a href="#37118277">parent</a><span>|</span><a href="#37118249">next</a><span>|</span><label class="collapse" for="c-37118511">[-]</label><label class="expand" for="c-37118511">[3 more]</label></div><br/><div class="children"><div class="content">If you’re having to do extra mental work to <i>guess</i>, it means you don’t have enough familiarity with the language, its type checks&#x2F;guards, and the standard library. That’s not the language’s fault.<p>If you want to check the type of a thing, you <i>always</i> want the matching `is_&lt;type&gt;`. It can be used <i>anywhere</i> in your code, including guards. There’s no guesswork involved here. That <i>is</i> the consistent rule.<p>When you see a function with a `?`, look at the typespec and the function name—give it the argument(s) it expects and it will answer the question on the tin with a boolean. Again, there’s no guesswork. These functions can be used anywhere <i>except</i> guards—that is the consistent rule for boolean functions.<p>&gt; <i>Is the thing I want to test written as a macro or not?</i><p>I have never had to ask myself this question, and I struggle to parse it. Is the “thing” you want to test referring to the <i>value</i> or to the <i>test</i> you wish to perform on that value? Since you’re asking about macros, I’m assuming you mean the <i>guard test</i>. For that, just learn what guards are available[0] (you can also write your own :D ).<p>[0]: <a href="https:&#x2F;&#x2F;hexdocs.pm&#x2F;elixir&#x2F;1.15.4&#x2F;Kernel.html#guards" rel="nofollow noreferrer">https:&#x2F;&#x2F;hexdocs.pm&#x2F;elixir&#x2F;1.15.4&#x2F;Kernel.html#guards</a></div><br/><div id="37118617" class="c"><input type="checkbox" id="c-37118617" checked=""/><div class="controls bullet"><span class="by">out_of_protocol</span><span>|</span><a href="#37117827">root</a><span>|</span><a href="#37118511">parent</a><span>|</span><a href="#37118249">next</a><span>|</span><label class="collapse" for="c-37118617">[-]</label><label class="expand" for="c-37118617">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If you’re having to do extra mental work to guess, .... That’s not the language’s fault.<p>Depends. In this case there are definite rule in place which you can learn. Overall, that&#x27;s definitely language&#x27;s fault. On other note, Elixir actually very good at consistent naming<p>-  standard library is designed, not meshed up and grew  layer by layer like js&#x2F;php abomination (erlang one is not consistent and it leaks sometimes)<p>- Pipe operator by its mere presence enforces correct order of arguments, even in 3rd party code</div><br/><div id="37118640" class="c"><input type="checkbox" id="c-37118640" checked=""/><div class="controls bullet"><span class="by">bobwaycott</span><span>|</span><a href="#37117827">root</a><span>|</span><a href="#37118617">parent</a><span>|</span><a href="#37118249">next</a><span>|</span><label class="collapse" for="c-37118640">[-]</label><label class="expand" for="c-37118640">[1 more]</label></div><br/><div class="children"><div class="content">It is not a tool’s fault that, upon providing the relevant material that describes its usage and helps a user learn how to use it, the user ignores that and then blames the tool for not working how they want it to work.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37118249" class="c"><input type="checkbox" id="c-37118249" checked=""/><div class="controls bullet"><span class="by">bobwaycott</span><span>|</span><a href="#37117827">root</a><span>|</span><a href="#37118014">parent</a><span>|</span><a href="#37118163">prev</a><span>|</span><a href="#37117035">next</a><span>|</span><label class="collapse" for="c-37118249">[-]</label><label class="expand" for="c-37118249">[9 more]</label></div><br/><div class="children"><div class="content">The larger problem is not reading the docs to understand and learn language conventions. If one reads the docs, it is immediately clear that the `is_` prefix denotes a function that returns a boolean and can be used in guards. The `?` form is for all other functions that return a boolean. Which means one will gain an intuitive sense of every function you see in the `is_` and `?` forms.<p>It’d be immensely more helpful and productive if coming into a language meant one would spend the time to read, learn, and understand that language’s conventions and  standard library—and read the source code for it! It pays serious and continuous dividends, and is the fastest way to gain an intuitive sense for the language.</div><br/><div id="37118291" class="c"><input type="checkbox" id="c-37118291" checked=""/><div class="controls bullet"><span class="by">Munksgaard</span><span>|</span><a href="#37117827">root</a><span>|</span><a href="#37118249">parent</a><span>|</span><a href="#37117035">next</a><span>|</span><label class="collapse" for="c-37118291">[-]</label><label class="expand" for="c-37118291">[8 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no need to be rude. My point is that it is not obvious, given some arbitrary value and some property to test for, whether that property can be expressed using a guard or not.</div><br/><div id="37118377" class="c"><input type="checkbox" id="c-37118377" checked=""/><div class="controls bullet"><span class="by">bobwaycott</span><span>|</span><a href="#37117827">root</a><span>|</span><a href="#37118291">parent</a><span>|</span><a href="#37117035">next</a><span>|</span><label class="collapse" for="c-37118377">[-]</label><label class="expand" for="c-37118377">[7 more]</label></div><br/><div class="children"><div class="content">I was not being rude.<p>What you say is not obvious is, to me, a result of not reading the docs, guides, and source code of the language and its standard library. I have seen this pattern repeatedly—those engineers who have learned the language find these things obvious. It’s not an insult, but a push to fill in those gaps. Elixir and Phoenix both have some of the best documentation you will find.</div><br/><div id="37118794" class="c"><input type="checkbox" id="c-37118794" checked=""/><div class="controls bullet"><span class="by">Supermancho</span><span>|</span><a href="#37117827">root</a><span>|</span><a href="#37118377">parent</a><span>|</span><a href="#37118490">next</a><span>|</span><label class="collapse" for="c-37118794">[-]</label><label class="expand" for="c-37118794">[1 more]</label></div><br/><div class="children"><div class="content">Let&#x27;s burn some karma to point out the toxicity found in many individuals from the functional language crowd.<p>&gt; I was not being rude.<p>Translation: the person asking needs to RTFM because they have a problem with something that is obvious or I don&#x27;t understand and it doesn&#x27;t matter which. This isn&#x27;t being rude.<p>&gt; It’d be immensely more helpful and productive if coming into a language meant one would spend the time to read, learn, and understand that language’s conventions and standard library and read the source code for it!<p>Translation: the person asking is wasting time, being unhelpful and unproductive asking questions<p>&gt; I still have enough of it learned because that is my job. It’s what we get paid well to do.<p>Translation: the person asking must not be doing their job because they don&#x27;t understand things the way I do (I&#x27;m a software perfectionist, ofc)<p>I believe The Erlang (and through extension, Elixir) community seems to engender and defend this kind of back-handed approach to &quot;helping&quot;. It doesn&#x27;t just come off as elitist, it is often little more than taunting. Suggesting that someone pours over documentation (and laughably source code) to explain patterns (or a lack thereof) in a highly abstracted language is counter-productive.<p>For the record, I&#x27;ll just hide your posts from now on as you cannot seem to help yourself bob.</div><br/></div></div><div id="37118490" class="c"><input type="checkbox" id="c-37118490" checked=""/><div class="controls bullet"><span class="by">Munksgaard</span><span>|</span><a href="#37117827">root</a><span>|</span><a href="#37118377">parent</a><span>|</span><a href="#37118794">prev</a><span>|</span><a href="#37117035">next</a><span>|</span><label class="collapse" for="c-37118490">[-]</label><label class="expand" for="c-37118490">[5 more]</label></div><br/><div class="children"><div class="content">Then explain to me, purely by referencing the Elixir documentation, why URI.char_reserved?&#x2F;1 is not instead called URI.is_char_reserved&#x2F;1 such that I can use it in a guard.<p>There&#x27;s nothing intuitive about memorizing dozens of built-in functions that are (for opaque reasons) different from all the other built-in functions.</div><br/><div id="37118737" class="c"><input type="checkbox" id="c-37118737" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#37117827">root</a><span>|</span><a href="#37118490">parent</a><span>|</span><a href="#37118604">next</a><span>|</span><label class="collapse" for="c-37118737">[-]</label><label class="expand" for="c-37118737">[2 more]</label></div><br/><div class="children"><div class="content">Guards are very small, very fast functions built in the BEAM VM.<p><i>is_integer</i> is a guard (in pseudocode: cell.type == TYPE_INTEGER).<p><i>URI.char_reserved?</i> is too high level to be builtin the VM.<p>Same for the hypothetical <i>is_keyword_list</i> mentioned above. How would you know if something is a keyword list?<p>1. It is a list<p>2. The first element is a tuple of 2 elements<p>3. The first element of the first tuple is a keyword<p>4. Every other element in the list obeys #2 and #3<p>What if you pass a list with a million elements to a guard like that? The VM would grind to a halt traversing every single element to make sure the whole thing is a Keyword. This is why there is no such guard.<p>So sure, you might have to consult the docs for what&#x27;s a guard and what is not, but can also be understood intuitively.</div><br/><div id="37118802" class="c"><input type="checkbox" id="c-37118802" checked=""/><div class="controls bullet"><span class="by">Munksgaard</span><span>|</span><a href="#37117827">root</a><span>|</span><a href="#37118737">parent</a><span>|</span><a href="#37118604">next</a><span>|</span><label class="collapse" for="c-37118802">[-]</label><label class="expand" for="c-37118802">[1 more]</label></div><br/><div class="children"><div class="content">Your point is rendered moot by the fact that `in` is allowed in guards. See my other response as well.</div><br/></div></div></div></div><div id="37118604" class="c"><input type="checkbox" id="c-37118604" checked=""/><div class="controls bullet"><span class="by">bobwaycott</span><span>|</span><a href="#37117827">root</a><span>|</span><a href="#37118490">parent</a><span>|</span><a href="#37118737">prev</a><span>|</span><a href="#37117035">next</a><span>|</span><label class="collapse" for="c-37118604">[-]</label><label class="expand" for="c-37118604">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Then explain to me, … why URI.char_reserved?&#x2F;1 is not instead called URI.is_char_reserved&#x2F;1 such that I can use it in a guard.</i><p>Because it is not meant to be a guard—it cannot further empower a function head and pattern match and be optimized and&#x2F;or inlined by the compiler. Simple as that.<p><pre><code>    Not all expressions are allowed in guard clauses, but only a handful of them. This is a deliberate choice. This way, Elixir (and Erlang) can make sure that nothing bad happens while executing guards and no mutations happen anywhere. It also allows the compiler to optimize the code related to guards efficiently.[0]
</code></pre>
&gt; <i>There&#x27;s nothing intuitive about memorizing dozens of built-in functions that are (for opaque reasons) different from all the other built-in functions.</i><p>I’m sorry, but I’m now struggling to believe you’re discussing this in good faith. Opaque reasons? I see none. It sounds like you either do not <i>like</i> or <i>understand</i> the reasons. It also sounds like you have an expectation that the existence of a boolean function means you can use it in a guard. But that’s your expectations not matching the language’s features and reasoning, neither of which are opaque. There’s nothing intuitive about memorizing dozens of functions? Assuming you’re a software engineer, <i>that is your job</i>. I probably have <i>hundreds</i> of functions memorized, across <i>dozens</i> of standard library modules, in <i>multiple languages</i>. Even if I don’t recall what specific options or arity a function has, I still have enough of it learned because <i>that is my job</i>. It’s what we get paid well to do.<p>[0]: <a href="https:&#x2F;&#x2F;hexdocs.pm&#x2F;elixir&#x2F;main&#x2F;patterns-and-guards.html#guards" rel="nofollow noreferrer">https:&#x2F;&#x2F;hexdocs.pm&#x2F;elixir&#x2F;main&#x2F;patterns-and-guards.html#guar...</a></div><br/><div id="37118780" class="c"><input type="checkbox" id="c-37118780" checked=""/><div class="controls bullet"><span class="by">Munksgaard</span><span>|</span><a href="#37117827">root</a><span>|</span><a href="#37118604">parent</a><span>|</span><a href="#37117035">next</a><span>|</span><label class="collapse" for="c-37118780">[-]</label><label class="expand" for="c-37118780">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Because it is not meant to be a guard—it cannot further empower a function head and pattern match and be optimized and&#x2F;or inlined by the compiler. Simple as that.<p>First of all, that&#x27;s not an explanation, that is handwaving. The real explanation is that URI.char_reserved? could be rewritten using defguard, because it only uses `in`[0]. An arbitrary choice (whether conscious or unconscious) was taken, that this particular standard library function is not allowed to be used in guards. But there is no good reason for it.<p>Secondly, are you claiming that it is not useful to be able to use URI.char_reserved?&#x2F;1 in a guard? That&#x27;s obviously bullshit.<p>Finally: The real reason why some things can be used in guards and other can&#x27;t, is that Elixir must be able to guarantee that no side-effects happen while evaluating a guard[1]. This is a good reason (a good follow-up question is, &quot;why must guards be side-effect free?&quot;) and something you can use to form a mental model of which functions you can use in guards and which you cannot, but it is not described anywhere in the Elixir documentation. It&#x27;s not an easy thing to form a mental model around, but it can be done.<p>To be fair, I think this is a shortcoming in Erlang as well. It would be better to be able to look at the type of a function and be able to tell whether I can use it in a guard or not. Or just allow all functions to be used in guards, such as in Haskell.<p>0: <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;Munksgaard&#x2F;ccac61310651d3402571506e4b4ef424" rel="nofollow noreferrer">https:&#x2F;&#x2F;gist.github.com&#x2F;Munksgaard&#x2F;ccac61310651d3402571506e4...</a><p>1: <a href="https:&#x2F;&#x2F;www.erlang.org&#x2F;docs&#x2F;22&#x2F;reference_manual&#x2F;expressions#guard-sequences" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.erlang.org&#x2F;docs&#x2F;22&#x2F;reference_manual&#x2F;expressions#...</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="37117035" class="c"><input type="checkbox" id="c-37117035" checked=""/><div class="controls bullet"><span class="by">paradox460</span><span>|</span><a href="#37117827">prev</a><span>|</span><a href="#37116168">next</a><span>|</span><label class="collapse" for="c-37117035">[-]</label><label class="expand" for="c-37117035">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;d encourage the author, and anyone else using Phoenix and liveview, to check out Surface<p><a href="https:&#x2F;&#x2F;surface-ui.org&#x2F;documentation" rel="nofollow noreferrer">https:&#x2F;&#x2F;surface-ui.org&#x2F;documentation</a><p>It basically brings some conveniences from Vue&#x2F;react to live view components, and is wonderful</div><br/><div id="37117449" class="c"><input type="checkbox" id="c-37117449" checked=""/><div class="controls bullet"><span class="by">SupremumLimit</span><span>|</span><a href="#37117035">parent</a><span>|</span><a href="#37116168">next</a><span>|</span><label class="collapse" for="c-37117449">[-]</label><label class="expand" for="c-37117449">[1 more]</label></div><br/><div class="children"><div class="content">[I am the author of the post.] I have! Didn’t quite see enough value and for me something like Petal makes more sense.</div><br/></div></div></div></div><div id="37116168" class="c"><input type="checkbox" id="c-37116168" checked=""/><div class="controls bullet"><span class="by">FinalDestiny</span><span>|</span><a href="#37117035">prev</a><span>|</span><a href="#37117452">next</a><span>|</span><label class="collapse" for="c-37116168">[-]</label><label class="expand" for="c-37116168">[5 more]</label></div><br/><div class="children"><div class="content">As a new Phoenix convert I agree with a lot of these points from my experience too. The functional components make more sense in the majority of cases (and I think the docs point this out) and having the duplicate auth logic with on_mount feels less than ideal.<p>Hopefully the team will see this and make it even better!</div><br/><div id="37116868" class="c"><input type="checkbox" id="c-37116868" checked=""/><div class="controls bullet"><span class="by">bobwaycott</span><span>|</span><a href="#37116168">parent</a><span>|</span><a href="#37117452">next</a><span>|</span><label class="collapse" for="c-37116868">[-]</label><label class="expand" for="c-37116868">[4 more]</label></div><br/><div class="children"><div class="content">I find a lot of engineers I work with don’t understand on_mount. You shouldn’t have duplicate logic in on_mount—if you do, that code should be in a module. You only have the logic once, but you <i>may</i> call the function twice (though you don’t have to).<p>All your auth logic (and any other bits you need to set while starting up request state) should be a function in a module somewhere that returns expected values. Then, you just care to set these values to Conn and Socket assigns appropriately, keeping in mind that Conns and Sockets aren’t the same—when you have one, you don’t have the other. Thus, on_mount to the rescue:<p>1. Use Plug pipeline(s) to call your module function to compute and add bits to Conn.assigns (and you can add those values to the session to avoid computing again, if you’d like).<p>2. Use on_mount to assign_new:<p>2a. assign_new pulls from Conn.assigns by key for the dead render while you have a Conn.<p>2b. The fallback function gets that value again when you no longer have a Conn (recompute or pull from session if already there).<p>Your actual logic should only exist in one place. And there are easy strategies you can use to avoid expensive computations if necessary.<p>[Edit]: Not suggesting <i>you</i> don’t understand it, just to be clear. I’ve just experienced a lot of coworkers fighting against, abusing, and misunderstanding Conns, Sockets, and assigns.</div><br/><div id="37117071" class="c"><input type="checkbox" id="c-37117071" checked=""/><div class="controls bullet"><span class="by">AlchemistCamp</span><span>|</span><a href="#37116168">root</a><span>|</span><a href="#37116868">parent</a><span>|</span><a href="#37117452">next</a><span>|</span><label class="collapse" for="c-37117071">[-]</label><label class="expand" for="c-37117071">[3 more]</label></div><br/><div class="children"><div class="content">Exactly.<p>Since mix phx.gen.auth handles the authN side, it’s really just authZ that will be idiosyncratic to your application logic.<p>In every authorization system I’ve written in a Phoenix app (which 8 now), I’ve taken this approach above.<p>Make a pipeline of rules that take a conn or socket and authorize or not based on what’s in the assigns. Better yet, at the very top of the pipleline, wrap the conn or socket with an auth struct that holds metadata like authorization status and any redirection to be done. Unwrap that struct into the conn or the socket at the end of the pipeline, where the status is resolved.<p>This way, every request can be default unauthorized and you can apply complex, composable rules for granting permission to take various actions on resources.</div><br/><div id="37118801" class="c"><input type="checkbox" id="c-37118801" checked=""/><div class="controls bullet"><span class="by">bongobingo1</span><span>|</span><a href="#37116168">root</a><span>|</span><a href="#37117071">parent</a><span>|</span><a href="#37118310">next</a><span>|</span><label class="collapse" for="c-37118801">[-]</label><label class="expand" for="c-37118801">[1 more]</label></div><br/><div class="children"><div class="content">Do you mind briefly expanding on your pipeline process?</div><br/></div></div><div id="37118310" class="c"><input type="checkbox" id="c-37118310" checked=""/><div class="controls bullet"><span class="by">conradfr</span><span>|</span><a href="#37116168">root</a><span>|</span><a href="#37117071">parent</a><span>|</span><a href="#37118801">prev</a><span>|</span><a href="#37117452">next</a><span>|</span><label class="collapse" for="c-37118310">[-]</label><label class="expand" for="c-37118310">[1 more]</label></div><br/><div class="children"><div class="content">In other words phx.gen.auth generates a lot of code that may or may not in part suits your authentification needs and Phoenix gives you nothing for Authorization ;)</div><br/></div></div></div></div></div></div></div></div><div id="37117452" class="c"><input type="checkbox" id="c-37117452" checked=""/><div class="controls bullet"><span class="by">Alacart</span><span>|</span><a href="#37116168">prev</a><span>|</span><a href="#37117666">next</a><span>|</span><label class="collapse" for="c-37117452">[-]</label><label class="expand" for="c-37117452">[2 more]</label></div><br/><div class="children"><div class="content">A possible counter point to the dislike of comprehension, depending on why you don&#x27;t like them:<p><a href="https:&#x2F;&#x2F;www.mitchellhanberg.com&#x2F;the-comprehensive-guide-to-elixirs-for-comprehension" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.mitchellhanberg.com&#x2F;the-comprehensive-guide-to-e...</a><p>I discovered a lot of things in this post that made me see them as much more valuable than I&#x27;d originally thought.</div><br/><div id="37117860" class="c"><input type="checkbox" id="c-37117860" checked=""/><div class="controls bullet"><span class="by">mcintyre1994</span><span>|</span><a href="#37117452">parent</a><span>|</span><a href="#37117666">next</a><span>|</span><label class="collapse" for="c-37117860">[-]</label><label class="expand" for="c-37117860">[1 more]</label></div><br/><div class="children"><div class="content">Bitstring parsing examples using Elixir comprehensions always seem so much nicer than anything I’ve seen anywhere else. I need to play with Nerves to have an excuse to learn them properly!</div><br/></div></div></div></div><div id="37117666" class="c"><input type="checkbox" id="c-37117666" checked=""/><div class="controls bullet"><span class="by">pdntspa</span><span>|</span><a href="#37117452">prev</a><span>|</span><a href="#37116379">next</a><span>|</span><label class="collapse" for="c-37117666">[-]</label><label class="expand" for="c-37117666">[12 more]</label></div><br/><div class="children"><div class="content">Why do so many feel so strongly against state?<p>In my 10+ year programming career not once have I ever wished something was functional. State simply is, dealing with it is a foundational concept in writing code.<p>&quot;It&#x27;s harder to test&quot; -- so mock it in the tests.<p>&quot;It&#x27;s harder to reason about&quot; -- you can see the references in your code and you can punch it into the debugger. If the state is implicit it is mentioned in the documentation that you&#x27;ve read right??<p>&quot;It&#x27;s hard to tell where changes come from&quot; -- again, stepping through with a debugger makes this somewhat trivial. Find the line that turns state bad, then drill into whatever that line calls, repeat.<p>I&#x27;m not saying we should be adding external state willy-nilly. But it is hardly evil -- the dumb hacks that have appeared when a class or instance var would have done the trick boggle the mind.<p>Can someone please prove to me how FP isn&#x27;t just another cargo cult?</div><br/><div id="37118771" class="c"><input type="checkbox" id="c-37118771" checked=""/><div class="controls bullet"><span class="by">josevalim</span><span>|</span><a href="#37117666">parent</a><span>|</span><a href="#37118233">next</a><span>|</span><label class="collapse" for="c-37118771">[-]</label><label class="expand" for="c-37118771">[1 more]</label></div><br/><div class="children"><div class="content">You may be misunderstanding the relationship between FP and state.<p>We are not against state, quite the opposite, FP likes state so much that we put it on a pedestal! We make it explicit, often with functionality that makes it easy to spot, understand, and manipulate.<p>If you think about your questions, here is how I would answer it:<p>&quot;It&#x27;s harder to test&quot; -- so let&#x27;s make them simple to test without mocking them out (which would effectively remove them from the test).<p>&quot;It&#x27;s harder to reason about&quot; -- so let&#x27;s make it easy to reason about by making it explicit.<p>&quot;It&#x27;s hard to tell where changes come from&quot; -- so let&#x27;s add constructs for manipulating it.<p>It is not about antagonizing it, it is about making sure it is clear and intentional.<p>---<p>PS: the &quot;evil bit&quot; is more often associated to global mutable state, but don&#x27;t let any FP language fool you, they all have global mutable state with explicit tools for manipulating them. In Elixir, you can even use tools such as LiveDashboard [1] to navigate all global mutable state in your application, making it very easy to introspect.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;phoenixframework&#x2F;phoenix_live_dashboard&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;phoenixframework&#x2F;phoenix_live_dashboard&#x2F;</a></div><br/></div></div><div id="37118233" class="c"><input type="checkbox" id="c-37118233" checked=""/><div class="controls bullet"><span class="by">el_oni</span><span>|</span><a href="#37117666">parent</a><span>|</span><a href="#37118771">prev</a><span>|</span><a href="#37118434">next</a><span>|</span><label class="collapse" for="c-37118233">[-]</label><label class="expand" for="c-37118233">[1 more]</label></div><br/><div class="children"><div class="content">Erlang and Elixir are what could be called pragmatic FP.<p>The idea is that your base abstraction should be functional, you can then have a genserver for that abstraction which is stateful.<p>So let&#x27;s take lists for example. Building up a list is functional. But I could have a ListServer which takes an item and prepends it to a list. And just holds on to that. So lots of processes can send it messages to add things in, and order in the list is determined by order the messages arrived.<p>The way the server manages state is<p>State -&gt; function -&gt; State&#x27;<p>And those functions are easy to test.<p>It makes for a nice experience building software, the default is functional and you drop in processes which hold state when you need them. Compared to classes where the default is state.</div><br/></div></div><div id="37118434" class="c"><input type="checkbox" id="c-37118434" checked=""/><div class="controls bullet"><span class="by">boxed</span><span>|</span><a href="#37117666">parent</a><span>|</span><a href="#37118233">prev</a><span>|</span><a href="#37118650">next</a><span>|</span><label class="collapse" for="c-37118434">[-]</label><label class="expand" for="c-37118434">[2 more]</label></div><br/><div class="children"><div class="content">&gt; In my 10+ year programming career not once have I ever wished something was functional.<p>I.. have trouble with this statement. I bet you have, but you thought about it differently. A function that COULD be a pure function but that takes some data structure then mutates it and returns nothing, well that&#x27;s just bad programming.<p>Now, wanting the entire program to be functional, that&#x27;s a different matter.</div><br/><div id="37118727" class="c"><input type="checkbox" id="c-37118727" checked=""/><div class="controls bullet"><span class="by">pdntspa</span><span>|</span><a href="#37117666">root</a><span>|</span><a href="#37118434">parent</a><span>|</span><a href="#37118650">next</a><span>|</span><label class="collapse" for="c-37118727">[-]</label><label class="expand" for="c-37118727">[1 more]</label></div><br/><div class="children"><div class="content">&gt; well that&#x27;s just bad programming.<p>There are a lot of situations where it is&#x2F;may seem prudent to pass a reference to something, mutate it, then return</div><br/></div></div></div></div><div id="37118650" class="c"><input type="checkbox" id="c-37118650" checked=""/><div class="controls bullet"><span class="by">dns_snek</span><span>|</span><a href="#37117666">parent</a><span>|</span><a href="#37118434">prev</a><span>|</span><a href="#37117728">next</a><span>|</span><label class="collapse" for="c-37118650">[-]</label><label class="expand" for="c-37118650">[2 more]</label></div><br/><div class="children"><div class="content">You can &quot;just&quot; do any of those things but code that is understandable without a debugger is strictly better than code that requires a debugger to grok.<p>&gt; &quot;It&#x27;s harder to test&quot; -- so mock it in the tests.<p>This however doesn&#x27;t make sense, you can&#x27;t &quot;mock&quot; state - the state and its side effects is what you&#x27;re testing.</div><br/><div id="37118703" class="c"><input type="checkbox" id="c-37118703" checked=""/><div class="controls bullet"><span class="by">pdntspa</span><span>|</span><a href="#37117666">root</a><span>|</span><a href="#37118650">parent</a><span>|</span><a href="#37117728">next</a><span>|</span><label class="collapse" for="c-37118703">[-]</label><label class="expand" for="c-37118703">[1 more]</label></div><br/><div class="children"><div class="content">I guess it depends on the specific language but in my experience one can mock nearly anything the code references</div><br/></div></div></div></div><div id="37117728" class="c"><input type="checkbox" id="c-37117728" checked=""/><div class="controls bullet"><span class="by">pjerem</span><span>|</span><a href="#37117666">parent</a><span>|</span><a href="#37118650">prev</a><span>|</span><a href="#37117830">next</a><span>|</span><label class="collapse" for="c-37117728">[-]</label><label class="expand" for="c-37117728">[3 more]</label></div><br/><div class="children"><div class="content">What do you mean by state ?<p>Nobody is against &quot;state&quot;, like, for sure, you need your data anyway.<p>What I see that people are calling &quot;state&quot; is just deriving your final state from your original data, like in FP but saving your derived data into memory with a different lifetime than your og data.<p>FP style don’t promote anything complicated other than just don’t save your derived data, just recalculate it each time. Doesn’t mean that you can’t have performance : in fact most of the time, the memory is the bottleneck anyway.<p>Storing your state makes you responsible for synchronization which is where your bugs are going to hide.</div><br/><div id="37117753" class="c"><input type="checkbox" id="c-37117753" checked=""/><div class="controls bullet"><span class="by">pdntspa</span><span>|</span><a href="#37117666">root</a><span>|</span><a href="#37117728">parent</a><span>|</span><a href="#37117830">next</a><span>|</span><label class="collapse" for="c-37117753">[-]</label><label class="expand" for="c-37117753">[2 more]</label></div><br/><div class="children"><div class="content">&gt; What do you mean by state ?<p>External state. Class vars, instance vars, even (gasp) globals. OP goes on some slight tangents&#x2F;comments regarding FP and state management which inspired my comment.</div><br/><div id="37117833" class="c"><input type="checkbox" id="c-37117833" checked=""/><div class="controls bullet"><span class="by">youraverageuser</span><span>|</span><a href="#37117666">root</a><span>|</span><a href="#37117753">parent</a><span>|</span><a href="#37117830">next</a><span>|</span><label class="collapse" for="c-37117833">[-]</label><label class="expand" for="c-37117833">[1 more]</label></div><br/><div class="children"><div class="content">Probably because it is very easy to mess up when using state incorrectly. It has been years since the last time my program run without bugs for the first time. If you&#x27;re a genius, then sure, whatever tool you may be using, you&#x27;ll do fine. But I noticed that many mainstream programming languages introduce concepts that are easy to misuse, even the same global variables. I recently wrote a small python script in 40-50, having concise and separate functions, etc. And I still was stuck on a bug that turned out be a consequence of shared state. The real issue was far from the location I was observing the bug. I think those kind of bugs is quite common.<p>What it boils down to in the end, is your priorities. If you want a program that works 90% of the time and you don&#x27;t care about the last 10%, then sure, stating your way through is quite natural. If you&#x27;re sick of the small bugs that is the consequence of the language semantics and not the logic or design, then you&#x27;ll start nailing down the factors that contribute to the erroneous nature, with state being just one part of it.<p>Based on my experience in python and trying to teach other python developers some fp (spoiler, it didn&#x27;t work)</div><br/></div></div></div></div></div></div><div id="37117830" class="c"><input type="checkbox" id="c-37117830" checked=""/><div class="controls bullet"><span class="by">travisgriggs</span><span>|</span><a href="#37117666">parent</a><span>|</span><a href="#37117728">prev</a><span>|</span><a href="#37118422">next</a><span>|</span><label class="collapse" for="c-37117830">[-]</label><label class="expand" for="c-37117830">[1 more]</label></div><br/><div class="children"><div class="content">I view it as pendulum. I cut my teeth during the sunrise of OO doing Smalltalk, dining in the halls of Smalltalk and CLOS. And then like a religious explosion, everyone went &quot;all in&quot; for random and arbitrary definitions of &quot;all in&quot; to OO and we ended up with a huge mess. Now, everyone hates on OO. It&#x27;s sad to me.<p>While OO has been on the outs for the last 10ish years, I feel like we&#x27;ve been awash in the other side of the coin. Instead of &quot;all objects all the way down&quot; we get all &quot;all functions (and monads)&quot; all the way down.<p>There seems to be two &quot;middle of the road&quot; paths out of this. You either get &quot;multi paradigm&quot; approaches where you get incomplete and difficult to reconcile partial implementations of a smorgasboard of the author&#x27;s preferences and formative experiences writ large. The other is the less popular but kind of &quot;let&#x27;s just be pragmatic&quot; approaches like Elixir&#x2F;Erlang. Personally, I&#x27;m finding the latter more appealing. Multi paradigm languages create a &quot;too many knobs&quot; problem when solving problems. The simpler, pragmatic, but sometimes kind of kludgy&#x2F;goofy languages allow me to just solve problems (even if I have to jump through a couple of hoops some times), instead of wondering which hoops are the best hoops to jump through.</div><br/></div></div><div id="37118422" class="c"><input type="checkbox" id="c-37118422" checked=""/><div class="controls bullet"><span class="by">elbear</span><span>|</span><a href="#37117666">parent</a><span>|</span><a href="#37117830">prev</a><span>|</span><a href="#37116379">next</a><span>|</span><label class="collapse" for="c-37118422">[-]</label><label class="expand" for="c-37118422">[1 more]</label></div><br/><div class="children"><div class="content">The point is that it&#x27;s desirable to reason about your state just from reading the code and not by using a debugger. And when state is changed and passed around explicitly, it&#x27;s easier to do that.</div><br/></div></div></div></div><div id="37116379" class="c"><input type="checkbox" id="c-37116379" checked=""/><div class="controls bullet"><span class="by">denvaar</span><span>|</span><a href="#37117666">prev</a><span>|</span><a href="#37117867">next</a><span>|</span><label class="collapse" for="c-37116379">[-]</label><label class="expand" for="c-37116379">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Grouped aliases&#x2F;imports&#x2F;requires are a mis-feature in my view. They save a few characters when typing but they complicate searching for module uses and refactoring.<p>Totally agree with this. I prefer to not use aliases most of the time, or to explicitly list out each module path separately if they are too long to fit inline. All preferences though.<p>&gt; Similarly, I don’t like comprehensions as everything they do can be achieved with functions, and they are not composable.<p>I don&#x27;t use comprehensions too often, but I would miss them if they vanished. Some things are just plain easier with them. They are also valuable in unit tests to show better error messages[1]:<p># Don&#x27;t do...
assert Enum.all?(posts, fn post -&gt; %Post{} == post end)<p># Do...
for post &lt;- posts, do: assert %Post{} == post<p>EDIT: Although I suppose you could just use Enum.each as well.<p>[1] <a href="https:&#x2F;&#x2F;keathley.io&#x2F;blog&#x2F;good-and-bad-elixir.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;keathley.io&#x2F;blog&#x2F;good-and-bad-elixir.html</a></div><br/></div></div><div id="37117867" class="c"><input type="checkbox" id="c-37117867" checked=""/><div class="controls bullet"><span class="by">travisgriggs</span><span>|</span><a href="#37116379">prev</a><span>|</span><a href="#37118049">next</a><span>|</span><label class="collapse" for="c-37117867">[-]</label><label class="expand" for="c-37117867">[1 more]</label></div><br/><div class="children"><div class="content">Good article. My experience using it to do an API endpoint system to a proprietary MQTT system has been really enjoyable. I really like the Elixir community. The slack channel is really helpful. The documentation is pretty good. And I like the fact that I could solve my problems with out needing a huge tone of micro packages that I have to constantly keep up with.<p>I haven&#x27;t done much LiveView&#x2F;Phoenix with it, but my biggest &quot;wish this were otherwise&quot; is the chasm between Elixir and Erlang. There&#x27;s a ton of basic stuff that when you ask, you get told to jump into this other domain with this other set of documentation. It&#x27;s like being in Wales or something, and sometimes English works, and othertimes, you get told you have to switch to Welsh to enjoy the local experience (not meant as a diss to those that are trying to retain various indigenous languages against English throughout the Isles).</div><br/></div></div><div id="37118049" class="c"><input type="checkbox" id="c-37118049" checked=""/><div class="controls bullet"><span class="by">POiNTx</span><span>|</span><a href="#37117867">prev</a><span>|</span><a href="#37118751">next</a><span>|</span><label class="collapse" for="c-37118049">[-]</label><label class="expand" for="c-37118049">[1 more]</label></div><br/><div class="children"><div class="content">I tend to ignore the whole context thing in Phoenix, it confused me in the beginning when I was learning about Elixir and Phoenix. It&#x27;s a design pattern instead of a core functionality of the framework.<p>Just think about what are good interfaces and abstractions. Seperate your core functionality from your &quot;view&quot; functionality as Phoenix sets it up for you anyway (App = core and AppWeb is your external view layer, being a webpage, json api, liveview, etc). You might end up with something that looks like a context and that&#x27;s ok, but it shouldn&#x27;t be what you start from.</div><br/></div></div><div id="37118751" class="c"><input type="checkbox" id="c-37118751" checked=""/><div class="controls bullet"><span class="by">jongjong</span><span>|</span><a href="#37118049">prev</a><span>|</span><label class="collapse" for="c-37118751">[-]</label><label class="expand" for="c-37118751">[5 more]</label></div><br/><div class="children"><div class="content">Elixir gets way too much coverage on HN considering that so few people use it.<p>Unfortunately Elixir doesn&#x27;t solve any problem which isn&#x27;t already solved by more popular languages such as Golang, JavaScript&#x2F;Node.js, Java, C# or Python and the result is neither more efficient nor more maintainable... But its lack of adoption is a problem as it limits your ability to access many powerful libraries and tools that are available when using other more popular languages.<p>Programming languages aren&#x27;t so different from spoken languages... Linguists can nit pick various pros and cons of different languages but ultimately it&#x27;s not an author&#x27;s language which determines whether or not their novel will earn them a Pulitzer prize in literature... Yet there is a good reason why no serious author will write a novel in Klingon (and it has nothing to do with the characteristics of the language itself). Same goes for programming languages and programmers.</div><br/><div id="37118900" class="c"><input type="checkbox" id="c-37118900" checked=""/><div class="controls bullet"><span class="by">emerongi</span><span>|</span><a href="#37118751">parent</a><span>|</span><a href="#37118902">next</a><span>|</span><label class="collapse" for="c-37118900">[-]</label><label class="expand" for="c-37118900">[1 more]</label></div><br/><div class="children"><div class="content">&gt; nor more maintainable<p>My humble opinion is that it is more maintainable (although Golang could take the cake in this list). Additionally: more fun to use, has less warts than the other languages mentioned and provides really powerful tools out of the box in an easy-to-use manner. I&#x27;d be interested in a study observing work stress levels of employees using various languages - my assumption is that Elixir users have less stress.</div><br/></div></div><div id="37118902" class="c"><input type="checkbox" id="c-37118902" checked=""/><div class="controls bullet"><span class="by">hmmokidk</span><span>|</span><a href="#37118751">parent</a><span>|</span><a href="#37118900">prev</a><span>|</span><a href="#37118851">next</a><span>|</span><label class="collapse" for="c-37118902">[-]</label><label class="expand" for="c-37118902">[1 more]</label></div><br/><div class="children"><div class="content">I love how all of the example langs you used make me want to claw my eyes out (except for maybe Go which I don’t know much about).</div><br/></div></div><div id="37118851" class="c"><input type="checkbox" id="c-37118851" checked=""/><div class="controls bullet"><span class="by">dns_snek</span><span>|</span><a href="#37118751">parent</a><span>|</span><a href="#37118902">prev</a><span>|</span><a href="#37118834">next</a><span>|</span><label class="collapse" for="c-37118851">[-]</label><label class="expand" for="c-37118851">[1 more]</label></div><br/><div class="children"><div class="content">How much hands-on experience do you have with Elixir and Phoenix?<p>At the end of the day, every programming language can be used to solve problems, but you need hands-on experience to be able to judge the ease of writing, reading and maintaining a codebase in that ecosystem.</div><br/></div></div><div id="37118834" class="c"><input type="checkbox" id="c-37118834" checked=""/><div class="controls bullet"><span class="by">tacker2000</span><span>|</span><a href="#37118751">parent</a><span>|</span><a href="#37118851">prev</a><span>|</span><label class="collapse" for="c-37118834">[-]</label><label class="expand" for="c-37118834">[1 more]</label></div><br/><div class="children"><div class="content">I fully agree. And since you are talking about popularity of languages in Web backend dev, don’t forget about PHP, which is still the silent beast in this area.</div><br/></div></div></div></div></div></div></div></div></div></body></html>