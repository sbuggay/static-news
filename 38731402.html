<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1703408453838" as="style"/><link rel="stylesheet" href="styles.css?v=1703408453838"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://trofi.github.io/posts/295-ssh-over-https.html">SSH over HTTPS</a> <span class="domain">(<a href="https://trofi.github.io">trofi.github.io</a>)</span></div><div class="subtext"><span>jandeboevrie</span> | <span>36 comments</span></div><br/><div><div id="38752183" class="c"><input type="checkbox" id="c-38752183" checked=""/><div class="controls bullet"><span class="by">debarshri</span><span>|</span><a href="#38751119">next</a><span>|</span><label class="collapse" for="c-38752183">[-]</label><label class="expand" for="c-38752183">[1 more]</label></div><br/><div class="children"><div class="content">A bit of a shameless plugin here.<p>At Adaptive [1] we building a data security infrastructure. In one of our product we do SSH and various other protocols over http3. It allows users to connect to databases, servers, and other resources over an outbound port. Similar to Ngrok and others but can be self-hosted You can access it in a passwordless manner or with temporary credentials, with a maker-checker protection.<p>[1] <a href="https:&#x2F;&#x2F;adaptive.live&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;adaptive.live&#x2F;</a></div><br/></div></div><div id="38751119" class="c"><input type="checkbox" id="c-38751119" checked=""/><div class="controls bullet"><span class="by">joveian</span><span>|</span><a href="#38752183">prev</a><span>|</span><a href="#38752091">next</a><span>|</span><label class="collapse" for="c-38751119">[-]</label><label class="expand" for="c-38751119">[1 more]</label></div><br/><div class="children"><div class="content">There is often also option 3, put ssh on port 80 and&#x2F;or 443 on a different host and ProxyJump to the intended destination (and&#x2F;or use SOCKS to that host to generally get a less filtered internet connection).  I use SOCKS and also forward DNS over TLS over the ssh connection via port forwarding.<p>At least several years ago when I first set up my SOCKS proxy and was using wifi quite a bit I never found one that did anything more than check the port, although I have heard they exist and could be more common now (and of course it doesn&#x27;t matter how common they are if one is in your way).</div><br/></div></div><div id="38752091" class="c"><input type="checkbox" id="c-38752091" checked=""/><div class="controls bullet"><span class="by">lrvick</span><span>|</span><a href="#38751119">prev</a><span>|</span><a href="#38751976">next</a><span>|</span><label class="collapse" for="c-38752091">[-]</label><label class="expand" for="c-38752091">[1 more]</label></div><br/><div class="children"><div class="content">I find simply having openssh listening on port 443 alone bypasses most firewalls in practice.</div><br/></div></div><div id="38751976" class="c"><input type="checkbox" id="c-38751976" checked=""/><div class="controls bullet"><span class="by">coppsilgold</span><span>|</span><a href="#38752091">prev</a><span>|</span><a href="#38752137">next</a><span>|</span><label class="collapse" for="c-38751976">[-]</label><label class="expand" for="c-38751976">[1 more]</label></div><br/><div class="children"><div class="content">In general, tunneling through HTTP2 turns out to be a great choice. There is an RPC protocol built on top of HTTP2: gRPC[1].<p>This is because HTTP2 is great at exploiting a TCP connection to transmit and receive multiple data structures concurrently - multiplexing.<p>There may not be a reason to use HTTP3 however, as QUIC already provides multiplexing.<p>I expect that in the future most communications will be over encrypted HTTP2 and QUIC simply because middleware creators can not resist to discriminate. It may even be necessary to serve some random (perhaps AI generated) HTTP2&#x2F;HTTP3 content to mitigate active probing[2].<p>[1] &lt;<a href="https:&#x2F;&#x2F;grpc.io" rel="nofollow noreferrer">https:&#x2F;&#x2F;grpc.io</a>&gt;<p>[2] &lt;<a href="https:&#x2F;&#x2F;blog.torproject.org&#x2F;learning-more-about-gfws-active-probing-system" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.torproject.org&#x2F;learning-more-about-gfws-active-...</a>&gt;</div><br/></div></div><div id="38752137" class="c"><input type="checkbox" id="c-38752137" checked=""/><div class="controls bullet"><span class="by">28304283409234</span><span>|</span><a href="#38751976">prev</a><span>|</span><a href="#38751568">next</a><span>|</span><label class="collapse" for="c-38752137">[-]</label><label class="expand" for="c-38752137">[2 more]</label></div><br/><div class="children"><div class="content">No love for sslh?<p>“ Probes for HTTP, TLS&#x2F;SSL (including SNI and ALPN), SSH, OpenVPN, tinc, XMPP, SOCKS5, are implemented, and any other protocol that can be tested using a regular expression, can be recognised. A typical use case is to allow serving several services on port 443 (e.g. to connect to SSH from inside a corporate firewall, which almost never block port 443) while still serving HTTPS on that port.”<p><a href="https:&#x2F;&#x2F;www.rutschle.net&#x2F;tech&#x2F;sslh&#x2F;README.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.rutschle.net&#x2F;tech&#x2F;sslh&#x2F;README.html</a></div><br/><div id="38752201" class="c"><input type="checkbox" id="c-38752201" checked=""/><div class="controls bullet"><span class="by">kvdveer</span><span>|</span><a href="#38752137">parent</a><span>|</span><a href="#38751568">next</a><span>|</span><label class="collapse" for="c-38752201">[-]</label><label class="expand" for="c-38752201">[1 more]</label></div><br/><div class="children"><div class="content">The author dedicated the first half of the article to the choice between sslh and full encapsulation.
They chose for full encapsulation because:
* it&#x27;s one fewer service to set up
* the http server handles the connection, so remote address is correct in the logs
* (presumably the hacker spirit favors novel solutions over existing ones)</div><br/></div></div></div></div><div id="38751568" class="c"><input type="checkbox" id="c-38751568" checked=""/><div class="controls bullet"><span class="by">dlenski</span><span>|</span><a href="#38752137">prev</a><span>|</span><a href="#38752146">next</a><span>|</span><label class="collapse" for="c-38751568">[-]</label><label class="expand" for="c-38751568">[3 more]</label></div><br/><div class="children"><div class="content">From the article:<p>&gt; Ubiquitous presence of HTTPS allows you to pass your data through very restrictive middle boxes!<p>This is, in fact, why all — or nearly all — proprietary VPN protocols (so-called &quot;SSL VPNs&quot;) implement a mode that initiates a tunnel via HTTPS, at least as a fallback if not as the primary mode of operation: precisely in order to have a mode of operation that works with <i>almost any</i> connection to the global Internet.<p>I&#x27;m one of the main developers of <a href="https:&#x2F;&#x2F;gitlab.com&#x2F;openconnect&#x2F;openconnect" rel="nofollow noreferrer">https:&#x2F;&#x2F;gitlab.com&#x2F;openconnect&#x2F;openconnect</a>, which implements many such protocols, and wrote <a href="https:&#x2F;&#x2F;github.com&#x2F;dlenski&#x2F;what-vpn">https:&#x2F;&#x2F;github.com&#x2F;dlenski&#x2F;what-vpn</a>, which sniffs or identifies even more flavors of TLS-based VPN servers.</div><br/><div id="38751657" class="c"><input type="checkbox" id="c-38751657" checked=""/><div class="controls bullet"><span class="by">smolder</span><span>|</span><a href="#38751568">parent</a><span>|</span><a href="#38751628">next</a><span>|</span><label class="collapse" for="c-38751657">[-]</label><label class="expand" for="c-38751657">[1 more]</label></div><br/><div class="children"><div class="content">It is tragic that we can&#x27;t seem to use ports for their intended purposes because of crude attempts to limit the utility of a connection.</div><br/></div></div></div></div><div id="38752146" class="c"><input type="checkbox" id="c-38752146" checked=""/><div class="controls bullet"><span class="by">thomashabets2</span><span>|</span><a href="#38751568">prev</a><span>|</span><a href="#38751328">next</a><span>|</span><label class="collapse" for="c-38752146">[-]</label><label class="expand" for="c-38752146">[1 more]</label></div><br/><div class="children"><div class="content">Nice. My solution involved more code: <a href="https:&#x2F;&#x2F;github.com&#x2F;ThomasHabets&#x2F;huproxy">https:&#x2F;&#x2F;github.com&#x2F;ThomasHabets&#x2F;huproxy</a></div><br/></div></div><div id="38751328" class="c"><input type="checkbox" id="c-38751328" checked=""/><div class="controls bullet"><span class="by">hackernudes</span><span>|</span><a href="#38752146">prev</a><span>|</span><a href="#38731894">next</a><span>|</span><label class="collapse" for="c-38751328">[-]</label><label class="expand" for="c-38751328">[2 more]</label></div><br/><div class="children"><div class="content">Nice, for some reason I never thought about the CONNECT method like a reverse proxy instead of a forward proxy.<p>However, CONNECT wasn&#x27;t good enough for me. I did ssh over websocket to bust through a corp proxy (it inspected https connections with a custom CA).<p>I modified socat to serve my ssh server over websocket through apache. I also used it on the client end with openssh&#x27;s ProxyCommand. I keep meaning to upload that patch, but there are other options around (websocat, for example).</div><br/><div id="38752239" class="c"><input type="checkbox" id="c-38752239" checked=""/><div class="controls bullet"><span class="by">duhast2020</span><span>|</span><a href="#38751328">parent</a><span>|</span><a href="#38731894">next</a><span>|</span><label class="collapse" for="c-38752239">[-]</label><label class="expand" for="c-38752239">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like you accidentally reinvented huproxy</div><br/></div></div></div></div><div id="38731894" class="c"><input type="checkbox" id="c-38731894" checked=""/><div class="controls bullet"><span class="by">somat</span><span>|</span><a href="#38751328">prev</a><span>|</span><a href="#38751213">next</a><span>|</span><label class="collapse" for="c-38731894">[-]</label><label class="expand" for="c-38731894">[9 more]</label></div><br/><div class="children"><div class="content">I prefer the opposite,  http over ssh.<p>Only half joking. I would love to have ssh equivalent identity management baked into a browser. I got all excited when first reading about hobo, which is a proposal for public key http auth. only to find out that not only did a server implementation not exist(i could work around this) but no client(browser) implementation exists(sort of, there is a javascript implementation, but that is not what I wanted.</div><br/><div id="38751379" class="c"><input type="checkbox" id="c-38751379" checked=""/><div class="controls bullet"><span class="by">manofmanysmiles</span><span>|</span><a href="#38731894">parent</a><span>|</span><a href="#38750984">next</a><span>|</span><label class="collapse" for="c-38751379">[-]</label><label class="expand" for="c-38751379">[1 more]</label></div><br/><div class="children"><div class="content">What about HTTPS client certificate?<p><a href="https:&#x2F;&#x2F;techcommunity.microsoft.com&#x2F;t5&#x2F;iis-support-blog&#x2F;client-certificate-authentication-part-1" rel="nofollow noreferrer">https:&#x2F;&#x2F;techcommunity.microsoft.com&#x2F;t5&#x2F;iis-support-blog&#x2F;clie...</a><p>I don&#x27;t know enough about this to know if it meets your need but I&#x27;ve used them to authenticate to servers in college.</div><br/></div></div><div id="38750984" class="c"><input type="checkbox" id="c-38750984" checked=""/><div class="controls bullet"><span class="by">upon_drumhead</span><span>|</span><a href="#38731894">parent</a><span>|</span><a href="#38751379">prev</a><span>|</span><a href="#38751474">next</a><span>|</span><label class="collapse" for="c-38750984">[-]</label><label class="expand" for="c-38750984">[2 more]</label></div><br/><div class="children"><div class="content">Isn’t passkeys what you are describing?</div><br/><div id="38751751" class="c"><input type="checkbox" id="c-38751751" checked=""/><div class="controls bullet"><span class="by">computerfriend</span><span>|</span><a href="#38731894">root</a><span>|</span><a href="#38750984">parent</a><span>|</span><a href="#38751474">next</a><span>|</span><label class="collapse" for="c-38751751">[-]</label><label class="expand" for="c-38751751">[1 more]</label></div><br/><div class="children"><div class="content">Passkeys are at the application layer.</div><br/></div></div></div></div><div id="38751474" class="c"><input type="checkbox" id="c-38751474" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#38731894">parent</a><span>|</span><a href="#38750984">prev</a><span>|</span><a href="#38751386">next</a><span>|</span><label class="collapse" for="c-38751474">[-]</label><label class="expand" for="c-38751474">[3 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    ssh -D “*:8080” host
</code></pre>
This fires up a SOCKS proxy on port 8080. I use it all the time within Firefox. Legendary OG VPN.<p>It’s handy for nefarious use cases, but I also use it to access rmq dashboards on non-public networks in AWS.</div><br/><div id="38752163" class="c"><input type="checkbox" id="c-38752163" checked=""/><div class="controls bullet"><span class="by">_joel</span><span>|</span><a href="#38731894">root</a><span>|</span><a href="#38751474">parent</a><span>|</span><a href="#38751791">next</a><span>|</span><label class="collapse" for="c-38752163">[-]</label><label class="expand" for="c-38752163">[1 more]</label></div><br/><div class="children"><div class="content">You can use this with socksify[1] to make any application SOCKS capable too. It was a godsend in days of old, for me.<p>[1] <a href="https:&#x2F;&#x2F;linux.die.net&#x2F;man&#x2F;1&#x2F;socksify" rel="nofollow noreferrer">https:&#x2F;&#x2F;linux.die.net&#x2F;man&#x2F;1&#x2F;socksify</a></div><br/></div></div></div></div><div id="38751386" class="c"><input type="checkbox" id="c-38751386" checked=""/><div class="controls bullet"><span class="by">Cloudef</span><span>|</span><a href="#38731894">parent</a><span>|</span><a href="#38751474">prev</a><span>|</span><a href="#38751659">next</a><span>|</span><label class="collapse" for="c-38751386">[-]</label><label class="expand" for="c-38751386">[1 more]</label></div><br/><div class="children"><div class="content">If only ssh:&#x2F;&#x2F;google.com was thing in browsers</div><br/></div></div><div id="38751659" class="c"><input type="checkbox" id="c-38751659" checked=""/><div class="controls bullet"><span class="by">password4321</span><span>|</span><a href="#38731894">parent</a><span>|</span><a href="#38751386">prev</a><span>|</span><a href="#38751213">next</a><span>|</span><label class="collapse" for="c-38751659">[-]</label><label class="expand" for="c-38751659">[1 more]</label></div><br/><div class="children"><div class="content">In case you missed it last week, a nudge in a similar direction:<p><i>SSH3: SSHv2 using HTTP&#x2F;3 and QUIC</i><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38664729">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38664729</a></div><br/></div></div></div></div><div id="38751213" class="c"><input type="checkbox" id="c-38751213" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#38731894">prev</a><span>|</span><a href="#38751764">next</a><span>|</span><label class="collapse" for="c-38751213">[-]</label><label class="expand" for="c-38751213">[5 more]</label></div><br/><div class="children"><div class="content">Dumb question, but couldn&#x27;t you just tell the OpenSSH server to use port 80 or port 443 or something and just connect like `ssh me@host -p 80`?</div><br/><div id="38751926" class="c"><input type="checkbox" id="c-38751926" checked=""/><div class="controls bullet"><span class="by">hddqsb</span><span>|</span><a href="#38751213">parent</a><span>|</span><a href="#38751226">next</a><span>|</span><label class="collapse" for="c-38751926">[-]</label><label class="expand" for="c-38751926">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that&#x27;s likely to work on many firewalls, but:<p>- it means you can&#x27;t also serve HTTP on those ports (so you&#x27;d need a dedicated IP address for SSH), and<p>- as @charcircuit wrote, it won&#x27;t resist deep packet inspection.<p>(But if DPI is a problem and you have a spare IP address, you could just use SSH over TLS without needing the HTTP CONNECT stuff and Apache.)</div><br/></div></div><div id="38751226" class="c"><input type="checkbox" id="c-38751226" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38751213">parent</a><span>|</span><a href="#38751926">prev</a><span>|</span><a href="#38751764">next</a><span>|</span><label class="collapse" for="c-38751226">[-]</label><label class="expand" for="c-38751226">[3 more]</label></div><br/><div class="children"><div class="content">That just changes the port it uses. It wouldn&#x27;t change the protocol.</div><br/><div id="38751231" class="c"><input type="checkbox" id="c-38751231" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#38751213">root</a><span>|</span><a href="#38751226">parent</a><span>|</span><a href="#38751764">next</a><span>|</span><label class="collapse" for="c-38751231">[-]</label><label class="expand" for="c-38751231">[2 more]</label></div><br/><div class="children"><div class="content">Fair, I guess I was not sure if it was <i>just</i> blocking the port, or doing something to directly block the protocols as well.</div><br/><div id="38751258" class="c"><input type="checkbox" id="c-38751258" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38751213">root</a><span>|</span><a href="#38751231">parent</a><span>|</span><a href="#38751764">next</a><span>|</span><label class="collapse" for="c-38751258">[-]</label><label class="expand" for="c-38751258">[1 more]</label></div><br/><div class="children"><div class="content">The author values having a robust solution since he mentions the DPI resistance near the end of the article. If he was going to mask ssh as https, he might as well do it properly.</div><br/></div></div></div></div></div></div></div></div><div id="38751764" class="c"><input type="checkbox" id="c-38751764" checked=""/><div class="controls bullet"><span class="by">petabyt</span><span>|</span><a href="#38751213">prev</a><span>|</span><a href="#38751565">next</a><span>|</span><label class="collapse" for="c-38751764">[-]</label><label class="expand" for="c-38751764">[1 more]</label></div><br/><div class="children"><div class="content">Reminds me of when I was in high school, I made a port scan script to find unblocked IPs for me to route my server SSH through. I was able to get it working through a port thats supposed to be used for printers. Still have SSH on the same port to this day.</div><br/></div></div><div id="38751565" class="c"><input type="checkbox" id="c-38751565" checked=""/><div class="controls bullet"><span class="by">Gabrys1</span><span>|</span><a href="#38751764">prev</a><span>|</span><a href="#38751317">next</a><span>|</span><label class="collapse" for="c-38751565">[-]</label><label class="expand" for="c-38751565">[1 more]</label></div><br/><div class="children"><div class="content">This is a really nice idea! Excellent encapsulation with minimal setup. You could slap a SOCKS proxy (via -D) on top of that for even more usability (although, oddly I find that these days all I ever need is DNS, HTTPs and SSH...)</div><br/></div></div><div id="38751317" class="c"><input type="checkbox" id="c-38751317" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#38751565">prev</a><span>|</span><a href="#38751112">next</a><span>|</span><label class="collapse" for="c-38751317">[-]</label><label class="expand" for="c-38751317">[2 more]</label></div><br/><div class="children"><div class="content">You should try httpssh<p><a href="https:&#x2F;&#x2F;pkg.go.dev&#x2F;github.com&#x2F;HimbeerserverDE&#x2F;httpssh" rel="nofollow noreferrer">https:&#x2F;&#x2F;pkg.go.dev&#x2F;github.com&#x2F;HimbeerserverDE&#x2F;httpssh</a><p>&gt; httpssh listens for HTTP(S) and SSH connections on the same port and forwards the traffic to the corresponding service.</div><br/><div id="38751364" class="c"><input type="checkbox" id="c-38751364" checked=""/><div class="controls bullet"><span class="by">hackernudes</span><span>|</span><a href="#38751317">parent</a><span>|</span><a href="#38751112">next</a><span>|</span><label class="collapse" for="c-38751364">[-]</label><label class="expand" for="c-38751364">[1 more]</label></div><br/><div class="children"><div class="content">The article mentions sslh which works like httpssh. It also possible to achieve this with haproxy like this:<p><pre><code>    frontend https
      bind *:443
      mode tcp
      tcp-request inspect-delay 2s
      use_backend https_loopback if { req.ssl_ver gt 0 }
      default_backend ssh
</code></pre>
Another option is to use TLS SNI (Server Name Indication) like a virtualhost-style ssh server (<a href="https:&#x2F;&#x2F;www.haproxy.com&#x2F;blog&#x2F;route-ssh-connections-with-haproxy" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.haproxy.com&#x2F;blog&#x2F;route-ssh-connections-with-hapr...</a>). You can use the &#x27;openssl&#x27; command in your ProxyCommand which is pretty readily available.</div><br/></div></div></div></div><div id="38751112" class="c"><input type="checkbox" id="c-38751112" checked=""/><div class="controls bullet"><span class="by">kiririn</span><span>|</span><a href="#38751317">prev</a><span>|</span><a href="#38751607">next</a><span>|</span><label class="collapse" for="c-38751112">[-]</label><label class="expand" for="c-38751112">[1 more]</label></div><br/><div class="children"><div class="content">I have always kept an SSTP VPN server handy after experiencing this exact scenario of hospital WiFi that only allows HTTPS traffic, but this is an interesting alternative</div><br/></div></div><div id="38751607" class="c"><input type="checkbox" id="c-38751607" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#38751112">prev</a><span>|</span><label class="collapse" for="c-38751607">[-]</label><label class="expand" for="c-38751607">[4 more]</label></div><br/><div class="children"><div class="content">Why block outbound SSH connections? Inbound I understand. And given how easy it is to tunnel over HTTPS this seems to be targeted an accidental or unsophisticated clients - neither of which seems to be a likely descriptor of an SSH connection.</div><br/><div id="38751970" class="c"><input type="checkbox" id="c-38751970" checked=""/><div class="controls bullet"><span class="by">m1keil</span><span>|</span><a href="#38751607">parent</a><span>|</span><a href="#38751662">next</a><span>|</span><label class="collapse" for="c-38751970">[-]</label><label class="expand" for="c-38751970">[2 more]</label></div><br/><div class="children"><div class="content">This is most likely just a security &quot;best practice&quot; that goes unquestioned. It is pretty much on the same level as blocking ICMP.<p>I remember in the past how I lost couple of hours trying to understand why I can&#x27;t reach a remote instance via RDP, only to finally figure it was the port blocking on the office firewall.<p>I spent quite a while trying to convince the local sysadmin that this doesn&#x27;t make any sense. His only explanation was &quot;security&quot; without any actual explanation of what is he securing us from.</div><br/><div id="38752035" class="c"><input type="checkbox" id="c-38752035" checked=""/><div class="controls bullet"><span class="by">anilakar</span><span>|</span><a href="#38751607">root</a><span>|</span><a href="#38751970">parent</a><span>|</span><a href="#38751662">next</a><span>|</span><label class="collapse" for="c-38752035">[-]</label><label class="expand" for="c-38752035">[1 more]</label></div><br/><div class="children"><div class="content">Russian and Chinese ISPs are blocked on out network in the name of &quot;security&quot; as if real attackers would not use AWS or a western VPS provider.<p>It is a pain when you need to download material from your hardware suppliers&#x27; web sites.</div><br/></div></div></div></div><div id="38751662" class="c"><input type="checkbox" id="c-38751662" checked=""/><div class="controls bullet"><span class="by">quasarj</span><span>|</span><a href="#38751607">parent</a><span>|</span><a href="#38751970">prev</a><span>|</span><label class="collapse" for="c-38751662">[-]</label><label class="expand" for="c-38751662">[1 more]</label></div><br/><div class="children"><div class="content">They just blanket block <i>every</i> port that isn&#x27;t 80 or 443. I see this everywhere.</div><br/></div></div></div></div></div></div></div></div></div></body></html>