<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1736413274805" as="style"/><link rel="stylesheet" href="styles.css?v=1736413274805"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://8dcc.github.io/programming/pool-allocator.html">Writing a simple pool allocator in C</a> <span class="domain">(<a href="https://8dcc.github.io">8dcc.github.io</a>)</span></div><div class="subtext"><span>8dcc</span> | <span>28 comments</span></div><br/><div><div id="42643129" class="c"><input type="checkbox" id="c-42643129" checked=""/><div class="controls bullet"><span class="by">8fingerlouie</span><span>|</span><a href="#42641993">next</a><span>|</span><label class="collapse" for="c-42643129">[-]</label><label class="expand" for="c-42643129">[1 more]</label></div><br/><div class="children"><div class="content">A long time ago, in a galaxy far far away, i wrote something similar for an embedded platform. I was implementing a WAP Browser at the time (yes, WAP, <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Wireless_Application_Protocol" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Wireless_Application_Protocol</a>), and we needed dynamic memory allocation in an environment where everything was static due to realtime constraints.<p>So i ended up with this : <a href="https:&#x2F;&#x2F;github.com&#x2F;jinie&#x2F;memmgr">https:&#x2F;&#x2F;github.com&#x2F;jinie&#x2F;memmgr</a></div><br/></div></div><div id="42641993" class="c"><input type="checkbox" id="c-42641993" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#42643129">prev</a><span>|</span><a href="#42641581">next</a><span>|</span><label class="collapse" for="c-42641993">[-]</label><label class="expand" for="c-42641993">[3 more]</label></div><br/><div class="children"><div class="content">If you write your own allocator in C, do yourself a favor and use the valgrind API inside it. Its use can be conditional so you can &quot;compile it out&quot;. Or should I say it has to be, so you can build the code in an environment where there&#x27;s no valgrind API.</div><br/><div id="42642157" class="c"><input type="checkbox" id="c-42642157" checked=""/><div class="controls bullet"><span class="by">gopalv</span><span>|</span><a href="#42641993">parent</a><span>|</span><a href="#42641581">next</a><span>|</span><label class="collapse" for="c-42642157">[-]</label><label class="expand" for="c-42642157">[2 more]</label></div><br/><div class="children"><div class="content">+1 - this isn&#x27;t even that hard, it is include a single header + annotate allocations&#x2F;frees, with some redzones around the actual allocation to know when the user-code is writing into the pool pointer areas.<p><a href="https:&#x2F;&#x2F;developers.redhat.com&#x2F;articles&#x2F;2022&#x2F;03&#x2F;23&#x2F;use-valgrind-memcheck-custom-memory-manager" rel="nofollow">https:&#x2F;&#x2F;developers.redhat.com&#x2F;articles&#x2F;2022&#x2F;03&#x2F;23&#x2F;use-valgri...</a></div><br/><div id="42643292" class="c"><input type="checkbox" id="c-42643292" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#42641993">root</a><span>|</span><a href="#42642157">parent</a><span>|</span><a href="#42641581">next</a><span>|</span><label class="collapse" for="c-42643292">[-]</label><label class="expand" for="c-42643292">[1 more]</label></div><br/><div class="children"><div class="content">[delayed]</div><br/></div></div></div></div></div></div><div id="42641581" class="c"><input type="checkbox" id="c-42641581" checked=""/><div class="controls bullet"><span class="by">keyle</span><span>|</span><a href="#42641993">prev</a><span>|</span><a href="#42642136">next</a><span>|</span><label class="collapse" for="c-42641581">[-]</label><label class="expand" for="c-42641581">[1 more]</label></div><br/><div class="children"><div class="content">The parent article is quite interesting and slightly different being cpp [1]. There is also a post about writing a memory allocator [2].<p>[1]: <a href="http:&#x2F;&#x2F;dmitrysoshnikov.com&#x2F;compilers&#x2F;writing-a-pool-allocator&#x2F;" rel="nofollow">http:&#x2F;&#x2F;dmitrysoshnikov.com&#x2F;compilers&#x2F;writing-a-pool-allocato...</a><p>[2]: <a href="http:&#x2F;&#x2F;dmitrysoshnikov.com&#x2F;compilers&#x2F;writing-a-memory-allocator&#x2F;" rel="nofollow">http:&#x2F;&#x2F;dmitrysoshnikov.com&#x2F;compilers&#x2F;writing-a-memory-alloca...</a></div><br/></div></div><div id="42642136" class="c"><input type="checkbox" id="c-42642136" checked=""/><div class="controls bullet"><span class="by">accelbred</span><span>|</span><a href="#42641581">prev</a><span>|</span><a href="#42641976">next</a><span>|</span><label class="collapse" for="c-42642136">[-]</label><label class="expand" for="c-42642136">[4 more]</label></div><br/><div class="children"><div class="content">Note that using this will likely violate strict aliasing due to using the void pointer returned as one type, freeing it, and then getting that same chunk again and using it as another type. You&#x27;ll probably want to compile with -fno-strict-aliasing to be safe.<p>A good reference on strict aliasing: <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;shafik&#x2F;848ae25ee209f698763cffee272a58f8" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;shafik&#x2F;848ae25ee209f698763cffee272a5...</a></div><br/><div id="42643275" class="c"><input type="checkbox" id="c-42643275" checked=""/><div class="controls bullet"><span class="by">alextingle</span><span>|</span><a href="#42642136">parent</a><span>|</span><a href="#42642551">next</a><span>|</span><label class="collapse" for="c-42643275">[-]</label><label class="expand" for="c-42643275">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no reason an allocator should ever trip over strict aliasing rules.<p>malloc() returns an address. The user code writes a value, and then reads a value of the same type. No problem.<p>Later, malloc() returns the same address. The user code writes a value of another type then reads a value of that same type. Again, no problem. There&#x27;s no aliasing going on here.<p>The act of writing a value of a different type tells the compiler that the lifetime of the previous object has ended. There&#x27;s no special magic required.<p>Strict aliasing is about situations where we write a value of one type, and then attempt to read a value of a different type from the same location. If you want to do that, then you have to be extremely cautious. But memory allocators don&#x27;t do that, so it&#x27;s not an issue.<p>(Obviously just talking about C here, or POD in C++ terms. If you are dealing with C++ objects with destructors, then you have an extra layer of complexity to deal with, but again that&#x27;s nothing to do with aliasing.)</div><br/></div></div><div id="42642551" class="c"><input type="checkbox" id="c-42642551" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#42642136">parent</a><span>|</span><a href="#42643275">prev</a><span>|</span><a href="#42641976">next</a><span>|</span><label class="collapse" for="c-42642551">[-]</label><label class="expand" for="c-42642551">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what allocators do. If C&#x27;s object model doesn&#x27;t allow users of the language to write their own allocators then that object model is broken.<p>C++ relatively has fixes to allow allocators to work, it requires calls to std::launder.</div><br/><div id="42642801" class="c"><input type="checkbox" id="c-42642801" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#42642136">root</a><span>|</span><a href="#42642551">parent</a><span>|</span><a href="#42641976">next</a><span>|</span><label class="collapse" for="c-42642801">[-]</label><label class="expand" for="c-42642801">[1 more]</label></div><br/><div class="children"><div class="content">I understand the C standard hides such actions behind a wall of &quot;this is the allocator&quot;, and expected the compiler authors to also be the allocator authors, allowing them to know when&#x2F;how they can break such rules (in the context of their own compiler)</div><br/></div></div></div></div></div></div><div id="42641976" class="c"><input type="checkbox" id="c-42641976" checked=""/><div class="controls bullet"><span class="by">ch33zer</span><span>|</span><a href="#42642136">prev</a><span>|</span><a href="#42641578">next</a><span>|</span><label class="collapse" for="c-42641976">[-]</label><label class="expand" for="c-42641976">[1 more]</label></div><br/><div class="children"><div class="content">Some interesting things that would be interesting to add to this:<p>- thread safety ( not too hard to add on top of your liked list)
- variable sized allocations. Ideally something more akin to malloc. Could be done wastefully by rounding up to the nearest chunk size
- (as mentioned in the article) variable chunk sizes
- zeroing of memory before handing it back to users
- double free detection or even better full asan support</div><br/></div></div><div id="42641578" class="c"><input type="checkbox" id="c-42641578" checked=""/><div class="controls bullet"><span class="by">liontwist</span><span>|</span><a href="#42641976">prev</a><span>|</span><a href="#42620183">next</a><span>|</span><label class="collapse" for="c-42641578">[-]</label><label class="expand" for="c-42641578">[7 more]</label></div><br/><div class="children"><div class="content">The pool struct Is two pointers, why are you allocating it with Malloc?</div><br/><div id="42643258" class="c"><input type="checkbox" id="c-42643258" checked=""/><div class="controls bullet"><span class="by">unwind</span><span>|</span><a href="#42641578">parent</a><span>|</span><a href="#42641765">next</a><span>|</span><label class="collapse" for="c-42643258">[-]</label><label class="expand" for="c-42643258">[1 more]</label></div><br/><div class="children"><div class="content">Next question: why are there two calls to `malloc()`, one for the Pool structure and one for the Chunks?<p>It is trivial to co-allocate them which removes the risk of memory fragmentation and is just generally a good idea if you&#x27;re chasing performance.<p>The answer might be &quot;for clarity&#x2F;simplicity&quot; which I guess is fine in an informative article, but it could at least be highlighted in the text which I didn&#x27;t see.</div><br/></div></div><div id="42641765" class="c"><input type="checkbox" id="c-42641765" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#42641578">parent</a><span>|</span><a href="#42643258">prev</a><span>|</span><a href="#42620183">next</a><span>|</span><label class="collapse" for="c-42641765">[-]</label><label class="expand" for="c-42641765">[5 more]</label></div><br/><div class="children"><div class="content">Some people are allergic to `main() { Foo foo; foo_init(&amp;foo); }`<p>Admittedly, sometimes for good reason - it locks in the ABI.</div><br/><div id="42642006" class="c"><input type="checkbox" id="c-42642006" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#42641578">root</a><span>|</span><a href="#42641765">parent</a><span>|</span><a href="#42641864">next</a><span>|</span><label class="collapse" for="c-42642006">[-]</label><label class="expand" for="c-42642006">[1 more]</label></div><br/><div class="children"><div class="content">Mainly just the size and alignment. If you make the structure oversized, and with strict alignment, it can be future proofed. Old binary clients will provide a structure big enough and aligned enough for the new version.<p>The dynamic constructor API can allocate the structure exactly sized without the padding.</div><br/></div></div><div id="42641864" class="c"><input type="checkbox" id="c-42641864" checked=""/><div class="controls bullet"><span class="by">liontwist</span><span>|</span><a href="#42641578">root</a><span>|</span><a href="#42641765">parent</a><span>|</span><a href="#42642006">prev</a><span>|</span><a href="#42641798">next</a><span>|</span><label class="collapse" for="c-42641864">[-]</label><label class="expand" for="c-42641864">[1 more]</label></div><br/><div class="children"><div class="content">ABI? Better make it an anonymous struct too.<p>It’s a performance oriented custom memory allocator.</div><br/></div></div><div id="42641798" class="c"><input type="checkbox" id="c-42641798" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#42641578">root</a><span>|</span><a href="#42641765">parent</a><span>|</span><a href="#42641864">prev</a><span>|</span><a href="#42620183">next</a><span>|</span><label class="collapse" for="c-42641798">[-]</label><label class="expand" for="c-42641798">[2 more]</label></div><br/><div class="children"><div class="content">Is that why some structs have &quot;char reserved[16]&quot; data members? I think I saw this in NGINX, though that might have been to allow module compatibility between the open source offering and the paid version.</div><br/><div id="42642254" class="c"><input type="checkbox" id="c-42642254" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#42641578">root</a><span>|</span><a href="#42641798">parent</a><span>|</span><a href="#42620183">next</a><span>|</span><label class="collapse" for="c-42642254">[-]</label><label class="expand" for="c-42642254">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that slightly improves ABI flexibility, though the fact that callers can still access fields limits that.<p>An alternative is to make the <i>only</i> member `char opaque[16]` (IIRC some locale-related thing in glibc does this, also I think libpng went through a transition of some sort related to this?), but calculating the size can be difficult outside of trivial cases since you can&#x27;t use sizeof&#x2F;offsetof.</div><br/></div></div></div></div></div></div></div></div><div id="42620183" class="c"><input type="checkbox" id="c-42620183" checked=""/><div class="controls bullet"><span class="by">pajko</span><span>|</span><a href="#42641578">prev</a><span>|</span><a href="#42641598">next</a><span>|</span><label class="collapse" for="c-42620183">[-]</label><label class="expand" for="c-42620183">[2 more]</label></div><br/><div class="children"><div class="content">ThreadX has pool allocators: <a href="https:&#x2F;&#x2F;github.com&#x2F;eclipse-threadx&#x2F;threadx&#x2F;blob&#x2F;master&#x2F;common&#x2F;src&#x2F;tx_byte_allocate.c">https:&#x2F;&#x2F;github.com&#x2F;eclipse-threadx&#x2F;threadx&#x2F;blob&#x2F;master&#x2F;commo...</a></div><br/><div id="42642012" class="c"><input type="checkbox" id="c-42642012" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#42620183">parent</a><span>|</span><a href="#42641598">next</a><span>|</span><label class="collapse" for="c-42642012">[-]</label><label class="expand" for="c-42642012">[1 more]</label></div><br/><div class="children"><div class="content">Everyone and his dog who has programmed C for a few decades has several as well. :)</div><br/></div></div></div></div><div id="42641598" class="c"><input type="checkbox" id="c-42641598" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#42620183">prev</a><span>|</span><label class="collapse" for="c-42641598">[-]</label><label class="expand" for="c-42641598">[8 more]</label></div><br/><div class="children"><div class="content">I recommend against using linked lists for bookkeeping the free blocks. It seems to be the data structure that every malloc&#x2F;free implementation reaches for, and I don&#x27;t know why - the slowness of pointer-chasing makes it terrible for almost any real-world use case. A balanced tree would be a much better idea, given that all the essential operations would take O(log n) time instead of O(n). Even if one insists on a linear search, a bitset is much more cache friendly than pointer-chasing and it can trivially benefit from SIMD optimizations.</div><br/><div id="42641741" class="c"><input type="checkbox" id="c-42641741" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#42641598">parent</a><span>|</span><a href="#42641751">next</a><span>|</span><label class="collapse" for="c-42641741">[-]</label><label class="expand" for="c-42641741">[1 more]</label></div><br/><div class="children"><div class="content">For the `Chunk` list, this isn&#x27;t one of the cases where linked lists are harmful. Each use <i>only</i> touches the top of the stack, never iterates. Also, linked lists are much easier to make thread-safe.<p>For the `LinkedPtr` list, the bad case is only hit during the destruction of the pool, and then only if you allocate a lot of memory. And given the overhead of deallocation I&#x27;m not sure the array approach would measurably help.<p>I don&#x27;t see anywhere a binary tree search would be useful here, since there are no loops used for lookup (on allocation they&#x27;re pushed in order, but when freed chunks are pushed in arbitrary order; this does mean no double-free protection).</div><br/></div></div><div id="42641751" class="c"><input type="checkbox" id="c-42641751" checked=""/><div class="controls bullet"><span class="by">elchananHaas</span><span>|</span><a href="#42641598">parent</a><span>|</span><a href="#42641741">prev</a><span>|</span><a href="#42642035">next</a><span>|</span><label class="collapse" for="c-42641751">[-]</label><label class="expand" for="c-42641751">[1 more]</label></div><br/><div class="children"><div class="content">The reason linked lists are used is for large enough allocations, there is no overhead. You use the space the application isn&#x27;t using. In addition, if all allocations are the same size it is O(1), you just look at the head of the list.<p>More sophisticated strategies bucket allocations by size, this has fixed overhead. You can also use balanced trees for more memory efficiency, but this is slower.<p>For small allocations (8 bytes) that are too small to contain pointers allocators will allocate a block and use bitsets.</div><br/></div></div><div id="42642035" class="c"><input type="checkbox" id="c-42642035" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#42641598">parent</a><span>|</span><a href="#42641751">prev</a><span>|</span><a href="#42641778">next</a><span>|</span><label class="collapse" for="c-42642035">[-]</label><label class="expand" for="c-42642035">[1 more]</label></div><br/><div class="children"><div class="content">Suppose the information did happen to search through the free blocks. Suppose you put them into an array instead of a linked list. They can&#x27;t actually be in the array, you see? The blocks are in the pool heap wherever they happen to be. So the array has to point to them. As you walk through the array you have to do reference the pointers. The only way it&#x27;s better is that they are not dependent loads. But you have this array to manage now.</div><br/></div></div><div id="42641778" class="c"><input type="checkbox" id="c-42641778" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#42641598">parent</a><span>|</span><a href="#42642035">prev</a><span>|</span><a href="#42641761">next</a><span>|</span><label class="collapse" for="c-42641778">[-]</label><label class="expand" for="c-42641778">[1 more]</label></div><br/><div class="children"><div class="content">Which pool operation is made more costly by the linked list? Both allocate and free are constant time, and trivial too.<p>The only thing that I can imagine being faster is a bump allocator, but that precludes free.</div><br/></div></div><div id="42641761" class="c"><input type="checkbox" id="c-42641761" checked=""/><div class="controls bullet"><span class="by">JJOmeo</span><span>|</span><a href="#42641598">parent</a><span>|</span><a href="#42641778">prev</a><span>|</span><a href="#42641734">next</a><span>|</span><label class="collapse" for="c-42641761">[-]</label><label class="expand" for="c-42641761">[2 more]</label></div><br/><div class="children"><div class="content">Pool allocators don&#x27;t walk the list or search anything though. All interactions are only at the list head and O(1), as all free nodes are just that, free and equal.</div><br/><div id="42643084" class="c"><input type="checkbox" id="c-42643084" checked=""/><div class="controls bullet"><span class="by">ceving</span><span>|</span><a href="#42641598">root</a><span>|</span><a href="#42641761">parent</a><span>|</span><a href="#42641734">next</a><span>|</span><label class="collapse" for="c-42643084">[-]</label><label class="expand" for="c-42643084">[1 more]</label></div><br/><div class="children"><div class="content">Then it might be a misnomber. Calling it &quot;stack&quot; instead of &quot;list&quot; might be better.</div><br/></div></div></div></div><div id="42641734" class="c"><input type="checkbox" id="c-42641734" checked=""/><div class="controls bullet"><span class="by">ben-schaaf</span><span>|</span><a href="#42641598">parent</a><span>|</span><a href="#42641761">prev</a><span>|</span><label class="collapse" for="c-42641734">[-]</label><label class="expand" for="c-42641734">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think you understand how the allocator in the article works. Allocating and freeing are already O(1), creating and closing the allocator are necessarily O(n). There is no search being done here.</div><br/></div></div></div></div></div></div></div></div></div></body></html>