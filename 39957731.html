<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1712480451597" as="style"/><link rel="stylesheet" href="styles.css?v=1712480451597"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/tazjin/nix-1p/blob/master/README.md">Nix – A One Pager</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>peter_d_sherman</span> | <span>20 comments</span></div><br/><div><div id="39959088" class="c"><input type="checkbox" id="c-39959088" checked=""/><div class="controls bullet"><span class="by">waldrews</span><span>|</span><a href="#39958872">next</a><span>|</span><label class="collapse" for="c-39959088">[-]</label><label class="expand" for="c-39959088">[4 more]</label></div><br/><div class="children"><div class="content">A restricted purely functional language for configuration is a great idea.  But why not a lisp?  The syntax is well thought out, but who needs to remember yet another set of syntax rules.  And it&#x27;s not like lisp syntax would scare off the Nix crow anymore than it scared off the Emacs crowd.</div><br/><div id="39959337" class="c"><input type="checkbox" id="c-39959337" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#39959088">parent</a><span>|</span><a href="#39959112">next</a><span>|</span><label class="collapse" for="c-39959337">[-]</label><label class="expand" for="c-39959337">[1 more]</label></div><br/><div class="children"><div class="content">Nix-the-language is isomorphic to JSON, which makes a lot more sense than clinging to some outdated 1970&#x27;s legacy.</div><br/></div></div><div id="39959112" class="c"><input type="checkbox" id="c-39959112" checked=""/><div class="controls bullet"><span class="by">nemoniac</span><span>|</span><a href="#39959088">parent</a><span>|</span><a href="#39959337">prev</a><span>|</span><a href="#39959180">next</a><span>|</span><label class="collapse" for="c-39959112">[-]</label><label class="expand" for="c-39959112">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;guix.gnu.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;guix.gnu.org&#x2F;</a></div><br/></div></div><div id="39959180" class="c"><input type="checkbox" id="c-39959180" checked=""/><div class="controls bullet"><span class="by">exe34</span><span>|</span><a href="#39959088">parent</a><span>|</span><a href="#39959112">prev</a><span>|</span><a href="#39958872">next</a><span>|</span><label class="collapse" for="c-39959180">[-]</label><label class="expand" for="c-39959180">[1 more]</label></div><br/><div class="children"><div class="content">I considered guix, but they seem a bit more religious about non-free. It might be cool to create a lisp-&gt;nix transpiler, but nixpkgs is in nix, and you spend a lot of time reading that when doing anything nix.</div><br/></div></div></div></div><div id="39958872" class="c"><input type="checkbox" id="c-39958872" checked=""/><div class="controls bullet"><span class="by">pulkitsh1234</span><span>|</span><a href="#39959088">prev</a><span>|</span><a href="#39958891">next</a><span>|</span><label class="collapse" for="c-39958872">[-]</label><label class="expand" for="c-39958872">[13 more]</label></div><br/><div class="children"><div class="content">Missing info: Why was this programming language needed in the first place? What is so special about it that the rest of the languages cannot achieve?</div><br/><div id="39959021" class="c"><input type="checkbox" id="c-39959021" checked=""/><div class="controls bullet"><span class="by">one-punch</span><span>|</span><a href="#39958872">parent</a><span>|</span><a href="#39959146">next</a><span>|</span><label class="collapse" for="c-39959021">[-]</label><label class="expand" for="c-39959021">[4 more]</label></div><br/><div class="children"><div class="content">Quoting <a href="https:&#x2F;&#x2F;nix.dev&#x2F;tutorials&#x2F;nix-language.html" rel="nofollow">https:&#x2F;&#x2F;nix.dev&#x2F;tutorials&#x2F;nix-language.html</a>:<p><pre><code>    The Nix language is designed for conveniently creating and composing derivations – precise descriptions of how contents of existing files are used to derive new files. It is a domain-specific, purely functional, lazily evaluated, dynamically typed programming language.
</code></pre>
So, its key features are:<p>1. domain-specific: designed for conveniently creating and composing derivations. This reason alone already justifies a new language, or an embedded domain-specific language (embedded in the Guile&#x2F;Scheme for guix), or a mix of both (Starlark, the build language of Bazel embedded in a restricted Python-variant).<p>2. purely functional: this underlies the philosophy of the Nix package manager, which aims to be purely functional (also known as hermeticity in other build systems, such as Bazel). Being purely functional in turn underlies the <i>congruence</i> of the NixOS operating system, where you declare <i>what</i> the state the system should be in (as opposed to being <i>convergent</i>, so that you specify <i>how</i> to achieve the desired state).<p>3. lazily evaluated: similar to other build systems (including Bazel), so that you can build only what you need on demand.<p>4. dynamically typed: this one is controversial. Being dynamically typed—in other words, not developing a type system—gets Nix out of the door 20 years ago. But users often complain about the lack of proper types and modularity. There are experiments to add a type-and-contract system to Nix, such as Nickel (<a href="https:&#x2F;&#x2F;github.com&#x2F;tweag&#x2F;nickel">https:&#x2F;&#x2F;github.com&#x2F;tweag&#x2F;nickel</a>).<p>Most of the above are also listed in the Overview of the One Pager.</div><br/><div id="39959099" class="c"><input type="checkbox" id="c-39959099" checked=""/><div class="controls bullet"><span class="by">orbital-decay</span><span>|</span><a href="#39958872">root</a><span>|</span><a href="#39959021">parent</a><span>|</span><a href="#39959146">next</a><span>|</span><label class="collapse" for="c-39959099">[-]</label><label class="expand" for="c-39959099">[3 more]</label></div><br/><div class="children"><div class="content">Is it that much of a DSL when domain-specific primitives are mostly abstracted away in a standard library written in Nix itself, with underlying machinery written in shell, and when it heavily relies on shell and foreign config snippets to do the job?</div><br/><div id="39959227" class="c"><input type="checkbox" id="c-39959227" checked=""/><div class="controls bullet"><span class="by">kreetx</span><span>|</span><a href="#39958872">root</a><span>|</span><a href="#39959099">parent</a><span>|</span><a href="#39959146">next</a><span>|</span><label class="collapse" for="c-39959227">[-]</label><label class="expand" for="c-39959227">[2 more]</label></div><br/><div class="children"><div class="content">Much of JavaScript&#x27;s underlying machinery is also written in C++, how do you feel about that?</div><br/><div id="39959384" class="c"><input type="checkbox" id="c-39959384" checked=""/><div class="controls bullet"><span class="by">orbital-decay</span><span>|</span><a href="#39958872">root</a><span>|</span><a href="#39959227">parent</a><span>|</span><a href="#39959146">next</a><span>|</span><label class="collapse" for="c-39959384">[-]</label><label class="expand" for="c-39959384">[1 more]</label></div><br/><div class="children"><div class="content">I usually don&#x27;t need to write C++ when writing in JavaScript, though. Writing derivations in Nix in real world implies using the standard library and writing shell scripts for mkDerivation &amp; co. (&quot;domain specific&quot; shell scripts that use stdenv)</div><br/></div></div></div></div></div></div></div></div><div id="39959146" class="c"><input type="checkbox" id="c-39959146" checked=""/><div class="controls bullet"><span class="by">Valodim</span><span>|</span><a href="#39958872">parent</a><span>|</span><a href="#39959021">prev</a><span>|</span><a href="#39959324">next</a><span>|</span><label class="collapse" for="c-39959146">[-]</label><label class="expand" for="c-39959146">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s worth mentioning that Nix is pretty old at this point, it feels a little younger due to its recent surge in popularity. But 20 years ago (that is 8 years before v8!), the programming languages market looked quite different from today.<p>Guix shows that it&#x27;s possible to use a different frontend language technically, but switching the nixpkgs repo itself over to anything else at this point would be an enormous community effort where it&#x27;s hard to say whether it&#x27;s worth it.</div><br/><div id="39959211" class="c"><input type="checkbox" id="c-39959211" checked=""/><div class="controls bullet"><span class="by">kreetx</span><span>|</span><a href="#39958872">root</a><span>|</span><a href="#39959146">parent</a><span>|</span><a href="#39959324">next</a><span>|</span><label class="collapse" for="c-39959211">[-]</label><label class="expand" for="c-39959211">[1 more]</label></div><br/><div class="children"><div class="content">Yeah. I guess the answer is that there weren&#x27;t (m)any configuration languages which had functions - even YAML itself (which doesn&#x27;t have functions) came out a few years before nix. Cue, starlark, dhall are all much later.</div><br/></div></div></div></div><div id="39959324" class="c"><input type="checkbox" id="c-39959324" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#39958872">parent</a><span>|</span><a href="#39959146">prev</a><span>|</span><a href="#39959034">next</a><span>|</span><label class="collapse" for="c-39959324">[-]</label><label class="expand" for="c-39959324">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not really a programming language. It&#x27;s a lot like JSON except with lambda functions and variables. Compared to the &quot;template yaml&quot; monstrosity gifted to us by the pointy-haired corporations, the Nix language makes a thousand times more sense.</div><br/></div></div><div id="39959034" class="c"><input type="checkbox" id="c-39959034" checked=""/><div class="controls bullet"><span class="by">Tomis02</span><span>|</span><a href="#39958872">parent</a><span>|</span><a href="#39959324">prev</a><span>|</span><a href="#39958949">next</a><span>|</span><label class="collapse" for="c-39959034">[-]</label><label class="expand" for="c-39959034">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Nix only exists to be the language for Nix, the package manager. While people have occasionally used it for other use-cases, it is explicitly not a general-purpose language.<p>The next question is why is the Nix package manager needed  and why should a software developer care. I don&#x27;t know the answer.</div><br/><div id="39959239" class="c"><input type="checkbox" id="c-39959239" checked=""/><div class="controls bullet"><span class="by">grumbel</span><span>|</span><a href="#39958872">root</a><span>|</span><a href="#39959034">parent</a><span>|</span><a href="#39959338">next</a><span>|</span><label class="collapse" for="c-39959239">[-]</label><label class="expand" for="c-39959239">[1 more]</label></div><br/><div class="children"><div class="content">Nix allows you to install packages without naming or version conflicts. It allows you to make source repositories act as first-class packages. It can be installed on any Linux distribution and MacOS. Changing and customizing packages is trivial. All the building and installing happens outside of the source tree, so you don&#x27;t clutter up your $HOME. It&#x27;s reproducible. It&#x27;s simple. And it&#x27;s build with the needs of Free Software in mind (unlike snap or flatpak which seem mostly concerned with packaging proprietary software). Also Nix is 20 years old at this point.<p>Simply put, with Nix I can do:<p><pre><code>   nix run github:project&#x2F;name
</code></pre>
to run a program. Not many other package managers are capable of that.</div><br/></div></div><div id="39959338" class="c"><input type="checkbox" id="c-39959338" checked=""/><div class="controls bullet"><span class="by">one-punch</span><span>|</span><a href="#39958872">root</a><span>|</span><a href="#39959034">parent</a><span>|</span><a href="#39959239">prev</a><span>|</span><a href="#39959188">next</a><span>|</span><label class="collapse" for="c-39959338">[-]</label><label class="expand" for="c-39959338">[1 more]</label></div><br/><div class="children"><div class="content">Software developers often want to customize:<p>1. their home environments: for packages (some reach for brew on MacOS) and configurations (dotfiles, and some reach for stow).<p>2. their development shells: for build dependencies (compilers, SDKs, libraries), tools (LSP, linters, formatters, debuggers), and services (runtime, database). Some reach for devcontainers here.<p>3. or even their operating systems: for development, for CI, for deployment, or for personal use.<p>Nix provision all of the above in the same language, with Nixpkgs, NixOS, home-manager, and devShells such as <a href="https:&#x2F;&#x2F;devenv.sh&#x2F;" rel="nofollow">https:&#x2F;&#x2F;devenv.sh&#x2F;</a>. What&#x27;s more, Nix is (<a href="https:&#x2F;&#x2F;nixos.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nixos.org&#x2F;</a>):<p>- reproducible: what works on your dev machine also works in CI and in prod,<p>- declarative: you version control and review your configurations and infrastructure as code, at a reasonable level of abstraction, to specify <i>what</i> the system should be, not <i>how</i> to get there,<p>- reliable: all changes (switching generations or profiles) are atomic with easy roll back.</div><br/></div></div><div id="39959188" class="c"><input type="checkbox" id="c-39959188" checked=""/><div class="controls bullet"><span class="by">exe34</span><span>|</span><a href="#39958872">root</a><span>|</span><a href="#39959034">parent</a><span>|</span><a href="#39959338">prev</a><span>|</span><a href="#39958949">next</a><span>|</span><label class="collapse" for="c-39959188">[-]</label><label class="expand" for="c-39959188">[1 more]</label></div><br/><div class="children"><div class="content">Have you tried Google?</div><br/></div></div></div></div><div id="39958949" class="c"><input type="checkbox" id="c-39958949" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#39958872">parent</a><span>|</span><a href="#39959034">prev</a><span>|</span><a href="#39958891">next</a><span>|</span><label class="collapse" for="c-39958949">[-]</label><label class="expand" for="c-39958949">[1 more]</label></div><br/><div class="children"><div class="content">The thing that is special about Nix the language is everything it <i>doesn&#x27;t</i> have (no side effects[1], no state, no mutability). It&#x27;s a very small and simple language.<p>Those constraints are really important for the rest of the Nix ecosystem to work.<p>[1]: technically there is one side effect - putting a derivation (i.e. a recipe for how to build a package) into the nix store.</div><br/></div></div></div></div><div id="39958891" class="c"><input type="checkbox" id="c-39958891" checked=""/><div class="controls bullet"><span class="by">forgotpwd16</span><span>|</span><a href="#39958872">prev</a><span>|</span><label class="collapse" for="c-39958891">[-]</label><label class="expand" for="c-39958891">[2 more]</label></div><br/><div class="children"><div class="content">A one pager regarding the language. Not the entire system.</div><br/><div id="39959366" class="c"><input type="checkbox" id="c-39959366" checked=""/><div class="controls bullet"><span class="by">zufallsheld</span><span>|</span><a href="#39958891">parent</a><span>|</span><label class="collapse" for="c-39959366">[-]</label><label class="expand" for="c-39959366">[1 more]</label></div><br/><div class="children"><div class="content">Well, isn&#x27;t the entire system called nixOS?</div><br/></div></div></div></div></div></div></div></div></div></body></html>