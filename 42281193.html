<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1733648455680" as="style"/><link rel="stylesheet" href="styles.css?v=1733648455680"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://embear.ch/blog/drm-framebuffer">Accessing a DRM Framebuffer to display an image</a> <span class="domain">(<a href="https://embear.ch">embear.ch</a>)</span></div><div class="subtext"><span>compressedgas</span> | <span>16 comments</span></div><br/><div><div id="42349817" class="c"><input type="checkbox" id="c-42349817" checked=""/><div class="controls bullet"><span class="by">dividuum</span><span>|</span><a href="#42348796">next</a><span>|</span><label class="collapse" for="c-42349817">[-]</label><label class="expand" for="c-42349817">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve worked a lot this year on writing DRM&#x2F;KMS code while porting my digital signage player (<a href="https:&#x2F;&#x2F;info-beamer.com" rel="nofollow">https:&#x2F;&#x2F;info-beamer.com</a>) to support the Raspberry Pi5. Since they moved away from their proprietary Broadcom provided graphical APIs (OMX&#x2F;dispmanx) the Pi now fully supports DRM and the implementation is really solid by now.<p>There is a ton more to learn: KMS (kernel mode setting) allows fine control over the video mode in case you cannot or do not want to rely on auto-detection.<p>Then there&#x27;s the atomic API: Unlike in the blog post, all changes applied to the output (from video mode to plane positions or assigned framebuffers...) are gathered and then applied atomically in a single commit. If necessary you can test if your atomic commit is correct and will work by doing a &quot;Test only commit&quot; before doing the real commit. Making changes atomically avoids all kinds of race conditions resulting in, for example, screen tearing.<p>Then there&#x27;s the interaction with video decoding: Using FFmpeg on the Pi allows you to access to hardware decoder. They produce DRM framebuffers for each video frame. You can then directly assign them to planes and position them on the screen. The resulting playback is zero-copy and as fast as it gets on the Pi.<p>Another fun feature is the Writeback connector, which unlike the one ending up as an HDMI signal allows you to write your output to a new DRM framebuffer. This can, for example, be used to take screenshots of your output or even feed the buffer back into a video encoder.<p>One very frustration aspect is that there is basically no real documentation, especially about semantics. I guess it makes sense if you consider that there&#x27;s probably only a limited number of API consumers (like desktop compositors, special video players).</div><br/><div id="42355921" class="c"><input type="checkbox" id="c-42355921" checked=""/><div class="controls bullet"><span class="by">mrgriffin</span><span>|</span><a href="#42349817">parent</a><span>|</span><a href="#42353798">next</a><span>|</span><label class="collapse" for="c-42355921">[-]</label><label class="expand" for="c-42355921">[1 more]</label></div><br/><div class="children"><div class="content">&gt; One very frustration aspect is that there is basically no real documentation<p>I looked at DRM&#x2F;KMS briefly earlier in the year and this is what made me abandon it in the end. Can you recommend any sources of information?<p>The atomic API and &quot;test only commit&quot; both sound really useful.</div><br/></div></div><div id="42353798" class="c"><input type="checkbox" id="c-42353798" checked=""/><div class="controls bullet"><span class="by">casta</span><span>|</span><a href="#42349817">parent</a><span>|</span><a href="#42355921">prev</a><span>|</span><a href="#42354091">next</a><span>|</span><label class="collapse" for="c-42353798">[-]</label><label class="expand" for="c-42353798">[2 more]</label></div><br/><div class="children"><div class="content">The drm atomic test is not only to verify if it&#x27;s &quot;correct&quot;, it is also used to check if the display controller can scan out that configuration of planes&#x2F;buffers, given buffer modifiers, plane properties&#x2F;sizes, etc. and current status of the display controller.  If it can&#x27;t, you probably need to simplify the configuration via some GPU compositing.<p>This is what we were doing on ChromeOS.</div><br/><div id="42355443" class="c"><input type="checkbox" id="c-42355443" checked=""/><div class="controls bullet"><span class="by">dividuum</span><span>|</span><a href="#42349817">root</a><span>|</span><a href="#42353798">parent</a><span>|</span><a href="#42354091">next</a><span>|</span><label class="collapse" for="c-42355443">[-]</label><label class="expand" for="c-42355443">[1 more]</label></div><br/><div class="children"><div class="content">Right. The number of times I got an EINVAL just to discover yet another reason was quiet something :) (Is there a better way to discover the true reason other than scrolling back through dmesg?)<p>I&#x27;m also falling back to GL composition in some cases or while taking screenshots to avoid composing twice (HDMI + Writeback) if the scene is too complex or if other restrictions make that mandatory: Planes can only be rotated 0&#x2F;180 degrees on the Pi HVS, so rotating a video to a portrait orientation is done on the GPU.</div><br/></div></div></div></div><div id="42354091" class="c"><input type="checkbox" id="c-42354091" checked=""/><div class="controls bullet"><span class="by">ge96</span><span>|</span><a href="#42349817">parent</a><span>|</span><a href="#42353798">prev</a><span>|</span><a href="#42348796">next</a><span>|</span><label class="collapse" for="c-42354091">[-]</label><label class="expand" for="c-42354091">[2 more]</label></div><br/><div class="children"><div class="content">Is an entire pi for signage affordable? I saw someone add VGA to an Arduino but I&#x27;ve seen some holiday cards have a video player in them, bare bones Linux</div><br/><div id="42354315" class="c"><input type="checkbox" id="c-42354315" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#42349817">root</a><span>|</span><a href="#42354091">parent</a><span>|</span><a href="#42348796">next</a><span>|</span><label class="collapse" for="c-42354315">[-]</label><label class="expand" for="c-42354315">[1 more]</label></div><br/><div class="children"><div class="content">“Digital signage” refers to screens showing ads on billboards, announcements on public transport, menus in fast-food restaurants, and the like. Those aren’t cheap devices: consider that not so long ago you’d encounter humongous plasma displays there. Using a full (industrial) PC to drive one is totally normal, and the cost of an RPi is likely negligible. Don’t know if an RPi is well-built enough though, as some signage installations may need to exist in pretty hostile environments (vibration, dirt, EMI, etc.).</div><br/></div></div></div></div></div></div><div id="42348796" class="c"><input type="checkbox" id="c-42348796" checked=""/><div class="controls bullet"><span class="by">mdp2021</span><span>|</span><a href="#42349817">prev</a><span>|</span><a href="#42350080">next</a><span>|</span><label class="collapse" for="c-42348796">[-]</label><label class="expand" for="c-42348796">[2 more]</label></div><br/><div class="children"><div class="content">In case anyone misinterprets it:<p>DRM here is for Direct Rendering Manager (not e.g. interfaces studied to limit access to content).</div><br/><div id="42355882" class="c"><input type="checkbox" id="c-42355882" checked=""/><div class="controls bullet"><span class="by">Varriount</span><span>|</span><a href="#42348796">parent</a><span>|</span><a href="#42350080">next</a><span>|</span><label class="collapse" for="c-42355882">[-]</label><label class="expand" for="c-42355882">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always wondered why the name &quot;Direct Rendering Manager&quot; was chosen, given the existing definition of DRM. It could have just as easily been &quot;Direct Rendering Layer&quot; or some other alternative.</div><br/></div></div></div></div><div id="42350080" class="c"><input type="checkbox" id="c-42350080" checked=""/><div class="controls bullet"><span class="by">maplant</span><span>|</span><a href="#42348796">prev</a><span>|</span><a href="#42354070">next</a><span>|</span><label class="collapse" for="c-42350080">[-]</label><label class="expand" for="c-42350080">[1 more]</label></div><br/><div class="children"><div class="content">DRM Framebuffers are also the preferred way to interface with Vulkan renderers in GTK. For example, if you wanted to make a game scene editor with gnome, you could render the scene to a DRM Framebuffer and use a GTKGraphicsOffload widget to indicate that it will continue to be updated outside of the event loop.<p>In practice I’ve never been able to get this work. Static images totally fine. Graphics offloading fails and manually refreshing the image causes some sort of memory leak in the GPU</div><br/></div></div><div id="42354070" class="c"><input type="checkbox" id="c-42354070" checked=""/><div class="controls bullet"><span class="by">ghosty141</span><span>|</span><a href="#42350080">prev</a><span>|</span><a href="#42349285">next</a><span>|</span><label class="collapse" for="c-42354070">[-]</label><label class="expand" for="c-42354070">[1 more]</label></div><br/><div class="children"><div class="content">I had the pleasure to access the framebuffer via the DRM and pull the data with DMA for a vnc server I wrote at work. Learning how to use the api was like half the work, an article like this would‘ve certainly helped!</div><br/></div></div><div id="42349285" class="c"><input type="checkbox" id="c-42349285" checked=""/><div class="controls bullet"><span class="by">rjsw</span><span>|</span><a href="#42354070">prev</a><span>|</span><a href="#42349237">next</a><span>|</span><label class="collapse" for="c-42349285">[-]</label><label class="expand" for="c-42349285">[1 more]</label></div><br/><div class="children"><div class="content">For a bit more complicated application also using DRM directly there is kmscube [1].<p>[1] <a href="https:&#x2F;&#x2F;gitlab.freedesktop.org&#x2F;mesa&#x2F;kmscube" rel="nofollow">https:&#x2F;&#x2F;gitlab.freedesktop.org&#x2F;mesa&#x2F;kmscube</a></div><br/></div></div><div id="42349237" class="c"><input type="checkbox" id="c-42349237" checked=""/><div class="controls bullet"><span class="by">thebruce87m</span><span>|</span><a href="#42349285">prev</a><span>|</span><a href="#42353486">next</a><span>|</span><label class="collapse" for="c-42349237">[-]</label><label class="expand" for="c-42349237">[1 more]</label></div><br/><div class="children"><div class="content">Excellent, succinct article. Having fought to understand this process years ago I would have loved to find this exact article at the time.</div><br/></div></div><div id="42353486" class="c"><input type="checkbox" id="c-42353486" checked=""/><div class="controls bullet"><span class="by">leighleighleigh</span><span>|</span><a href="#42349237">prev</a><span>|</span><a href="#42352159">next</a><span>|</span><label class="collapse" for="c-42353486">[-]</label><label class="expand" for="c-42353486">[1 more]</label></div><br/><div class="children"><div class="content">Really helpful introduction to DRM for the uninitiated, thanks</div><br/></div></div><div id="42352159" class="c"><input type="checkbox" id="c-42352159" checked=""/><div class="controls bullet"><span class="by">sunk1st</span><span>|</span><a href="#42353486">prev</a><span>|</span><label class="collapse" for="c-42352159">[-]</label><label class="expand" for="c-42352159">[2 more]</label></div><br/><div class="children"><div class="content">Can this be done on Mac OS?</div><br/><div id="42352487" class="c"><input type="checkbox" id="c-42352487" checked=""/><div class="controls bullet"><span class="by">krackers</span><span>|</span><a href="#42352159">parent</a><span>|</span><label class="collapse" for="c-42352487">[-]</label><label class="expand" for="c-42352487">[1 more]</label></div><br/><div class="children"><div class="content">Only before 10.7 from userspace with CGDisplayBaseAddress<p><a href="https:&#x2F;&#x2F;developer.apple.com&#x2F;library&#x2F;archive&#x2F;documentation&#x2F;GraphicsImaging&#x2F;Conceptual&#x2F;QuartzDisplayServicesConceptual&#x2F;Articles&#x2F;DisplayCapture.html" rel="nofollow">https:&#x2F;&#x2F;developer.apple.com&#x2F;library&#x2F;archive&#x2F;documentation&#x2F;Gr...</a><p>After 10.7 (and certainly post-Metal) I don&#x27;t think the framebuffer is accessible via userspace, you&#x27;d probably need to create a kernel extension to expose it somehow.<p>Although windowserver must write to the framebuffer somehow so there&#x27;s probably a private API as well</div><br/></div></div></div></div></div></div></div></div></div></body></html>