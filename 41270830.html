<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1723885262457" as="style"/><link rel="stylesheet" href="styles.css?v=1723885262457"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://dashbit.co/blog/soft-deletes-with-ecto">Soft Deletes with Ecto and PostgreSQL</a> <span class="domain">(<a href="https://dashbit.co">dashbit.co</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>34 comments</span></div><br/><div><div id="41271862" class="c"><input type="checkbox" id="c-41271862" checked=""/><div class="controls bullet"><span class="by">Terr_</span><span>|</span><a href="#41271851">next</a><span>|</span><label class="collapse" for="c-41271862">[-]</label><label class="expand" for="c-41271862">[12 more]</label></div><br/><div class="children"><div class="content">Soft-deletes in relational databases are almost always a mistake. Most use-cases are actually business rules&#x2F;processes which need to be clearly examined and done more explicitly and contextually, at least if you ever want to restore anything.<p>For example, you don&#x27;t soft-delete a customer row, you &quot;deactivate&quot; a customer, and change logic that looks at customer-related entities to fit that. The &quot;Customers&quot; page that shouldn&#x27;t show those anymore gets retitled to &quot;Active Customers.&quot; Later there will be either process for reactivating customers or for using a <i>permanently</i> deactivated customer as a template for a new one.<p>What goes wrong with the classic soft-delete approach? The one where every table has a boolean is_deleted column and <i>hopefully</i> the deleting code updates the correct subgraph of records at the same time?<p>It typically <i>rots</i> as you expand your model and add features. It&#x27;s not clear what significance different tables have, and you you can&#x27;t &quot;restore&quot; things with any reliability or safety. That may be because of relational&#x2F;index conflicts, or because you don&#x27;t have enough information about how it was originally deleted to actually &quot;restore&quot; something that is both correct and useful, or because there are actually 3 different kinds of restoration schemes&#x2F;scopes but current problem calls for a fourth.</div><br/><div id="41272406" class="c"><input type="checkbox" id="c-41272406" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#41271862">parent</a><span>|</span><a href="#41272848">prev</a><span>|</span><a href="#41272372">next</a><span>|</span><label class="collapse" for="c-41272406">[-]</label><label class="expand" for="c-41272406">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What goes wrong with the classic soft-delete approach? The one where every table has a boolean is_deleted column and hopefully the deleting code updates the correct subgraph of records at the same time?<p>&gt; It typically rots as you expand your model and add features. It&#x27;s not clear what significance different tables have, and you you can&#x27;t &quot;restore&quot; things with any reliability or safety. That may be because of relational&#x2F;index conflicts, or because you don&#x27;t have enough information about how it was originally deleted to actually &quot;restore&quot; something that is both correct and useful, or because there are actually 3 different kinds of restoration schemes&#x2F;scopes but current problem calls for a fourth.<p>The long and short of soft deletes is that it breaks my data&#x27;s correctness guarantees WRT referential integrity: i.e. I &#x27;delete&#x27; a record while there are still references to it, and the RDBMS cannot even warn me, much less stop me!<p>If I wanted broken data, I&#x27;d use a NoSQL DB, or flat files even.</div><br/></div></div><div id="41272372" class="c"><input type="checkbox" id="c-41272372" checked=""/><div class="controls bullet"><span class="by">kristiandupont</span><span>|</span><a href="#41271862">parent</a><span>|</span><a href="#41272406">prev</a><span>|</span><a href="#41272350">next</a><span>|</span><label class="collapse" for="c-41272372">[-]</label><label class="expand" for="c-41272372">[7 more]</label></div><br/><div class="children"><div class="content">This is a problem but IMO, the bigger problem is that you create a pit of failure rather than a pit of success because you now have to remember to add &quot;and deleted_at is null&quot; everywhere and forgetting to do so often doesn&#x27;t look like a bug until the day some user sees something they thought had been deleted still appear.</div><br/><div id="41272679" class="c"><input type="checkbox" id="c-41272679" checked=""/><div class="controls bullet"><span class="by">remus</span><span>|</span><a href="#41271862">root</a><span>|</span><a href="#41272372">parent</a><span>|</span><a href="#41272386">next</a><span>|</span><label class="collapse" for="c-41272679">[-]</label><label class="expand" for="c-41272679">[3 more]</label></div><br/><div class="children"><div class="content">Perhaps it&#x27;s a scale thing, but I get more &quot;oh crap, I just deleted this thing, can you get it back for me?&quot; requests than I do bug reports about soft deleted records showing up incorrectly. Being able to restore records immediately is a big win imo.</div><br/><div id="41272734" class="c"><input type="checkbox" id="c-41272734" checked=""/><div class="controls bullet"><span class="by">treve</span><span>|</span><a href="#41271862">root</a><span>|</span><a href="#41272679">parent</a><span>|</span><a href="#41272705">prev</a><span>|</span><a href="#41272386">next</a><span>|</span><label class="collapse" for="c-41272734">[-]</label><label class="expand" for="c-41272734">[1 more]</label></div><br/><div class="children"><div class="content">Being able to contact a dev to undelete a record from a database does sound like a thing that&#x27;s hard to scale. If this happens a lot, it could be worth examining if there&#x27;s a  UX problem.</div><br/></div></div></div></div><div id="41272386" class="c"><input type="checkbox" id="c-41272386" checked=""/><div class="controls bullet"><span class="by">Fire-Dragon-DoL</span><span>|</span><a href="#41271862">root</a><span>|</span><a href="#41272372">parent</a><span>|</span><a href="#41272679">prev</a><span>|</span><a href="#41272350">next</a><span>|</span><label class="collapse" for="c-41272386">[-]</label><label class="expand" for="c-41272386">[3 more]</label></div><br/><div class="children"><div class="content">Postgres supports rules for rewriting queries</div><br/><div id="41272682" class="c"><input type="checkbox" id="c-41272682" checked=""/><div class="controls bullet"><span class="by">setr</span><span>|</span><a href="#41271862">root</a><span>|</span><a href="#41272386">parent</a><span>|</span><a href="#41272410">next</a><span>|</span><label class="collapse" for="c-41272682">[-]</label><label class="expand" for="c-41272682">[1 more]</label></div><br/><div class="children"><div class="content">too much magic for my taste. I think the more proper thing would be to simply use views, and expose the natural absurdity of the design with one-view-per-table.</div><br/></div></div><div id="41272410" class="c"><input type="checkbox" id="c-41272410" checked=""/><div class="controls bullet"><span class="by">kristiandupont</span><span>|</span><a href="#41271862">root</a><span>|</span><a href="#41272386">parent</a><span>|</span><a href="#41272682">prev</a><span>|</span><a href="#41272350">next</a><span>|</span><label class="collapse" for="c-41272410">[-]</label><label class="expand" for="c-41272410">[1 more]</label></div><br/><div class="children"><div class="content">Right. I have never tried those but they sound unappealing to me. I would expect edge cases where they don&#x27;t work and unpredictable performance implications. But as I said, I have no experience so this is just my imagination.</div><br/></div></div></div></div></div></div><div id="41272350" class="c"><input type="checkbox" id="c-41272350" checked=""/><div class="controls bullet"><span class="by">gonzo41</span><span>|</span><a href="#41271862">parent</a><span>|</span><a href="#41272372">prev</a><span>|</span><a href="#41271851">next</a><span>|</span><label class="collapse" for="c-41272350">[-]</label><label class="expand" for="c-41272350">[2 more]</label></div><br/><div class="children"><div class="content">IDK. I think people can overthink the problem a bit.<p>I done the is_deleted flag with a deleted_at timestamp that gets cascaded down the table relations. Restoring is an admin job and the logic is to follow the table relations down again restoring linked objects with the same deleted_at timestamp.<p>I have this in a metadata database that controls a data warehouse. Accidentally knocking out a metadata record could nuke large parts of the warehouse so i have to have this and a  locked flag that prevents records from being removed or even soft deleted once data is in the warehouse.</div><br/><div id="41272732" class="c"><input type="checkbox" id="c-41272732" checked=""/><div class="controls bullet"><span class="by">namaria</span><span>|</span><a href="#41271862">root</a><span>|</span><a href="#41272350">parent</a><span>|</span><a href="#41271851">next</a><span>|</span><label class="collapse" for="c-41272732">[-]</label><label class="expand" for="c-41272732">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think people can overthink the problem a bit.<p>&gt; I have this in a metadata database that controls a data warehouse. Accidentally knocking out a metadata record could nuke large parts of the warehouse<p>I think you might be underthinking your problem.</div><br/></div></div></div></div></div></div><div id="41271851" class="c"><input type="checkbox" id="c-41271851" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#41271862">prev</a><span>|</span><a href="#41272726">next</a><span>|</span><label class="collapse" for="c-41271851">[-]</label><label class="expand" for="c-41271851">[13 more]</label></div><br/><div class="children"><div class="content">Pretty much every soft-delete implementation I&#x27;ve seen involves modifying a tables schema to add a deleted_at column.<p>Invariably, this becomes a rather annoying thorn in my side when I need to do more advanced indexing, like unique indexes for upserts. Nothing impossible, but I&#x27;m quickly swimming upstream against whatever ORM I happen to be using (I&#x27;m looking at you, Prisma).<p>What I haven&#x27;t seen much of is a trigger-based system which moves the deleted record into an entirely new table. Is it possible to make a deletions table that always mirrors the source tables schema? I know table inheritance is a thing but I don&#x27;t know if that applies to future schema changes.<p>Anyways, I know deleted_at quite well, but I long for something better.</div><br/><div id="41272745" class="c"><input type="checkbox" id="c-41272745" checked=""/><div class="controls bullet"><span class="by">code_biologist</span><span>|</span><a href="#41271851">parent</a><span>|</span><a href="#41271972">next</a><span>|</span><label class="collapse" for="c-41272745">[-]</label><label class="expand" for="c-41272745">[1 more]</label></div><br/><div class="children"><div class="content">For Django, django-simple-history [1] is killer at this. It doesn&#x27;t track perfectly in the same way as temporal tables (if a DB operation doesn&#x27;t trigger a save hook, it won&#x27;t be tracked) but the ergonomics for Django work is pretty unbeatable. Great integration into the ORM + auth + admin. History tables automatically derived from model definitions with sane nullability defaults, sane migration strategy, and hackability where needed.<p>It&#x27;s made &quot;can we get an audit table &#x2F; undo delete for XYZ?&quot; feature requests really easy.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;jazzband&#x2F;django-simple-history">https:&#x2F;&#x2F;github.com&#x2F;jazzband&#x2F;django-simple-history</a></div><br/></div></div><div id="41271972" class="c"><input type="checkbox" id="c-41271972" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#41271851">parent</a><span>|</span><a href="#41272745">prev</a><span>|</span><a href="#41272400">next</a><span>|</span><label class="collapse" for="c-41271972">[-]</label><label class="expand" for="c-41271972">[2 more]</label></div><br/><div class="children"><div class="content">I wonder if this could be solved with partitioning on the deleted_at column; you’d only need two partitions: one for live data (deleted_at is null) and one for deleted data. Then, in Postgres at least, you could just query the live partition directly when you want to skip deleted records.</div><br/><div id="41272669" class="c"><input type="checkbox" id="c-41272669" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41271851">root</a><span>|</span><a href="#41271972">parent</a><span>|</span><a href="#41272400">next</a><span>|</span><label class="collapse" for="c-41272669">[-]</label><label class="expand" for="c-41272669">[1 more]</label></div><br/><div class="children"><div class="content">You can just build  an index with a condition, without even.partitioning the table.</div><br/></div></div></div></div><div id="41272400" class="c"><input type="checkbox" id="c-41272400" checked=""/><div class="controls bullet"><span class="by">kristiandupont</span><span>|</span><a href="#41271851">parent</a><span>|</span><a href="#41271972">prev</a><span>|</span><a href="#41271903">next</a><span>|</span><label class="collapse" for="c-41272400">[-]</label><label class="expand" for="c-41272400">[1 more]</label></div><br/><div class="children"><div class="content">I like this (1). Like anything related to triggers, you need to be mindful of tables with heavy throughput and maybe move the logic to &quot;code&quot; so you can batch or skip things, but for most tables it works like a charm.<p>1. <a href="https:&#x2F;&#x2F;brandur.org&#x2F;fragments&#x2F;deleted-record-insert" rel="nofollow">https:&#x2F;&#x2F;brandur.org&#x2F;fragments&#x2F;deleted-record-insert</a></div><br/></div></div><div id="41271903" class="c"><input type="checkbox" id="c-41271903" checked=""/><div class="controls bullet"><span class="by">pikdum</span><span>|</span><a href="#41271851">parent</a><span>|</span><a href="#41272400">prev</a><span>|</span><a href="#41271931">next</a><span>|</span><label class="collapse" for="c-41271903">[-]</label><label class="expand" for="c-41271903">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What I haven&#x27;t seen much of is a trigger-based system which moves the deleted record into an entirely new table.<p>I&#x27;ve used <a href="https:&#x2F;&#x2F;github.com&#x2F;nearform&#x2F;temporal_tables">https:&#x2F;&#x2F;github.com&#x2F;nearform&#x2F;temporal_tables</a> before for that, has been pretty solid. Still need to manually keep the schema in sync, though.</div><br/></div></div><div id="41271931" class="c"><input type="checkbox" id="c-41271931" checked=""/><div class="controls bullet"><span class="by">atonse</span><span>|</span><a href="#41271851">parent</a><span>|</span><a href="#41271903">prev</a><span>|</span><a href="#41272388">next</a><span>|</span><label class="collapse" for="c-41271931">[-]</label><label class="expand" for="c-41271931">[2 more]</label></div><br/><div class="children"><div class="content">What about foreign keys referencing the row you moved?</div><br/><div id="41272741" class="c"><input type="checkbox" id="c-41272741" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41271851">root</a><span>|</span><a href="#41271931">parent</a><span>|</span><a href="#41272388">next</a><span>|</span><label class="collapse" for="c-41272741">[-]</label><label class="expand" for="c-41272741">[1 more]</label></div><br/><div class="children"><div class="content">I suppose &quot;on delete cascade&quot; would fire appropriate triggers in the downstream tables, and &quot;on delete set null&quot; will take care of upstream and peer tables.<p>If this is not sufficient,  and a live record in one table may legitimately refer to a &quot;dead&quot; record in another table, then well, maybe &quot;soft delete&quot; is what you need, and your data just has a deactivated state.</div><br/></div></div></div></div><div id="41272388" class="c"><input type="checkbox" id="c-41272388" checked=""/><div class="controls bullet"><span class="by">Fire-Dragon-DoL</span><span>|</span><a href="#41271851">parent</a><span>|</span><a href="#41271931">prev</a><span>|</span><a href="#41272118">next</a><span>|</span><label class="collapse" for="c-41272388">[-]</label><label class="expand" for="c-41272388">[1 more]</label></div><br/><div class="children"><div class="content">Couldn&#x27;t you apply all the indices as partial where deleted at is null?</div><br/></div></div><div id="41272118" class="c"><input type="checkbox" id="c-41272118" checked=""/><div class="controls bullet"><span class="by">MarceColl</span><span>|</span><a href="#41271851">parent</a><span>|</span><a href="#41272388">prev</a><span>|</span><a href="#41271927">next</a><span>|</span><label class="collapse" for="c-41272118">[-]</label><label class="expand" for="c-41272118">[2 more]</label></div><br/><div class="children"><div class="content">I mean, Prisma is just awful, that&#x27;s hardly a problem of soft deletes.<p>At my previous job we used prisma, and what a terrible system, the amount of problems I saw there. Some have been fixed since, but it shouldnt take 3 major versions of an ORM to use an actual upsert operation instead of doing<p>if select() then update() else insert() at the client side, which is all sorts of wrong.
Or the 50ms of latency it introduced per query by starting a separate process that generated the queries, or the lack of schema flexibility, or the idiotic new join features that transforms rows into jsons in a destructive way.<p>It&#x27;s just bad software</div><br/><div id="41272791" class="c"><input type="checkbox" id="c-41272791" checked=""/><div class="controls bullet"><span class="by">mnahkies</span><span>|</span><a href="#41271851">root</a><span>|</span><a href="#41272118">parent</a><span>|</span><a href="#41271927">next</a><span>|</span><label class="collapse" for="c-41272791">[-]</label><label class="expand" for="c-41272791">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve hit a lot of rough edges with it too. A few off the top of my head:<p>- in memory joins (until they added the preview relationalJoin feature)<p>- no partial indexes<p>- no select for update<p>- no table partitioning (though if you do this out of band it all works fine)<p>- use of create type enum instead of check constraints makes maintenance of enumerated columns more challenging (IMO)<p>- little support for less common (but useful!) data types like geospatial, intervals, ltree, etc<p>- the reliance on wasm&#x2F;rust makes debugging what it&#x27;s doing difficult<p>- the connection pooling defaults are surprising (never reaps idle connections, AFAIK not cgroups aware and over provisions the pool size based on host CPU count)<p>For simple use cases it&#x27;s appealing, and I suspect it&#x27;s probably a better experience with nosql databases, but when you&#x27;re used to taking full advantage of postgres&#x27; feature set it gets frustrating quickly.<p>There&#x27;s issues in the tracker for basically everything above, and some may have even been solved by now - in a few more years it might be a better experience.</div><br/></div></div></div></div><div id="41271927" class="c"><input type="checkbox" id="c-41271927" checked=""/><div class="controls bullet"><span class="by">out_of_protocol</span><span>|</span><a href="#41271851">parent</a><span>|</span><a href="#41272118">prev</a><span>|</span><a href="#41272730">next</a><span>|</span><label class="collapse" for="c-41271927">[-]</label><label class="expand" for="c-41271927">[1 more]</label></div><br/><div class="children"><div class="content">&gt; unique indexes for upserts<p>Would simple 
&quot;create unique index on .... where deleted_at is null&quot; work for you?</div><br/></div></div><div id="41272730" class="c"><input type="checkbox" id="c-41272730" checked=""/><div class="controls bullet"><span class="by">NicoJuicy</span><span>|</span><a href="#41271851">parent</a><span>|</span><a href="#41271927">prev</a><span>|</span><a href="#41272726">next</a><span>|</span><label class="collapse" for="c-41272730">[-]</label><label class="expand" for="c-41272730">[1 more]</label></div><br/><div class="children"><div class="content">Uh. Why? Deleted at is the last ModifiedOn timestamp.<p>Nothing should modify it anymore after that.</div><br/></div></div></div></div><div id="41272726" class="c"><input type="checkbox" id="c-41272726" checked=""/><div class="controls bullet"><span class="by">zero_kool</span><span>|</span><a href="#41271851">prev</a><span>|</span><a href="#41272366">next</a><span>|</span><label class="collapse" for="c-41272726">[-]</label><label class="expand" for="c-41272726">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m currently in the process of migrating back to hard-delete from soft-delete on my current company&#x27;s codebase. We use a slightly different approach of using triggers to do cascade deletes. It&#x27;s just very difficult to maintain as the product grows bigger. All those additional overhead to create additional rules for every table and the scope for human error. Overall, I dont recommend anyone take the route of soft-deletes unless it&#x27;s absolutely required.</div><br/></div></div><div id="41272366" class="c"><input type="checkbox" id="c-41272366" checked=""/><div class="controls bullet"><span class="by">vbilopav</span><span>|</span><a href="#41272726">prev</a><span>|</span><a href="#41272070">next</a><span>|</span><label class="collapse" for="c-41272366">[-]</label><label class="expand" for="c-41272366">[3 more]</label></div><br/><div class="children"><div class="content">Please don&#x27;t do this. It&#x27;s a design&#x2F; architectural sin. It messes up your queries, commands and indexes and it&#x27;s constant source of trouble.<p>Here&#x27;s a better way:
<a href="https:&#x2F;&#x2F;medium.com&#x2F;@vbilopav&#x2F;custom-temporal-tables-in-postgresql-5a0e4045ab30" rel="nofollow">https:&#x2F;&#x2F;medium.com&#x2F;@vbilopav&#x2F;custom-temporal-tables-in-postg...</a></div><br/><div id="41272435" class="c"><input type="checkbox" id="c-41272435" checked=""/><div class="controls bullet"><span class="by">dqv</span><span>|</span><a href="#41272366">parent</a><span>|</span><a href="#41272070">next</a><span>|</span><label class="collapse" for="c-41272435">[-]</label><label class="expand" for="c-41272435">[2 more]</label></div><br/><div class="children"><div class="content">What does it do when a table that already has that trigger on it gets altered (<i>i.e.</i> a new column is added)?</div><br/><div id="41272558" class="c"><input type="checkbox" id="c-41272558" checked=""/><div class="controls bullet"><span class="by">vbilopav</span><span>|</span><a href="#41272366">root</a><span>|</span><a href="#41272435">parent</a><span>|</span><a href="#41272070">next</a><span>|</span><label class="collapse" for="c-41272558">[-]</label><label class="expand" for="c-41272558">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s already built into code to check does trigger exists, check it out.<p>As far as changes(alter table ) goes, I need to take history tables into consideration when writing migration scripts. Since I&#x27;m doing my migrations always with SQL scripts that not an issue.<p>However, there&#x27;s a concept of system event triggers in PostgreSQL that can intercept alter table statements, so I&#x27;m thinking to expand my solution to alter history tables automatically. Check it out:
<a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;event-triggers.html" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;event-triggers.html</a></div><br/></div></div></div></div></div></div><div id="41272070" class="c"><input type="checkbox" id="c-41272070" checked=""/><div class="controls bullet"><span class="by">hu3</span><span>|</span><a href="#41272366">prev</a><span>|</span><label class="collapse" for="c-41272070">[-]</label><label class="expand" for="c-41272070">[4 more]</label></div><br/><div class="children"><div class="content">Anyone has experience with Softdeletes? Any links?<p>I&#x27;ve worked both ways. Hard DELETE and soft UPDATE deleted_at = NOW().<p>They both have tradeoffs.<p>It seems to me that delete_at columns allow for faster development at the cost of more runtime bugs. Like why is this deleted row being listed in this &lt;select&gt;? Did I forget to add `WHERE deleted_at IS NULL` again?<p>Meanwhile a hard DELETE usually means I get to copy rows to a cemetery table just in case. And it forces me to think about what to do with Foreign Keys that point to the row being deleted. Can I really delete this row if 3 other tables point to it? It makes some business rules evident.<p>I&#x27;m thinking, perhaps I can serialize hard DELETED rows as JSON and store all system deleted rows in a trash table. This way I don&#x27;t have to keep schema in sync there too.</div><br/><div id="41272903" class="c"><input type="checkbox" id="c-41272903" checked=""/><div class="controls bullet"><span class="by">KronisLV</span><span>|</span><a href="#41272070">parent</a><span>|</span><a href="#41272324">next</a><span>|</span><label class="collapse" for="c-41272903">[-]</label><label class="expand" for="c-41272903">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Did I forget to add `WHERE deleted_at IS NULL` again?<p>This seems like an unaddressed use case on the part of the RDBMS to me, a feature that shouldn’t be reinvented by ORMs or each individual project.<p>Instead, you should be able to just do DELETE SOFT FROM … in your queries and have the DB make the rows unavailable in all queries.<p>Or maybe even set it up, so that regular DELETE is treated like a soft delete, so that suddenly all of the ORMs and users wouldn’t be able to drop data on accident.<p>Maybe allow overwriting it with DELETE &#x2F;*+DELETE_HARD*&#x2F; FROM … if you so choose, as well as do SELECT &#x2F;*+WITH_SOFT_DELETED*&#x2F; … if you don’t want to introduce any historical incompatibility.<p>If such features don’t exist at the DB or a DB extension level, then we’ll be doomed to deal with ORMs reimplementing it which will be pretty bad if you ever need more than one tech stack connected to it, alongside the issues of all of your queries needing additional conditions.</div><br/></div></div><div id="41272324" class="c"><input type="checkbox" id="c-41272324" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#41272070">parent</a><span>|</span><a href="#41272903">prev</a><span>|</span><a href="#41272716">next</a><span>|</span><label class="collapse" for="c-41272324">[-]</label><label class="expand" for="c-41272324">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Like why is this deleted row being listed in this &lt;select&gt;? Did I forget to add `WHERE deleted_at IS NULL` again?<p>This is adding more complexity but... views?<p>For example: rename the &quot;foo&quot; table to &quot;all_foo&quot; and &quot;CREATE VIEW foo AS SELECT * FROM all_foo WHERE deleted_at IS NULL&quot;<p>I think you could even create a trigger on the view so &quot;DELETE FROM foo&quot; gets replaced with an &quot;UPDATE all_foo SET deleted_at = NOW()&quot;, but I&#x27;ve never tried that before.</div><br/></div></div><div id="41272716" class="c"><input type="checkbox" id="c-41272716" checked=""/><div class="controls bullet"><span class="by">setr</span><span>|</span><a href="#41272070">parent</a><span>|</span><a href="#41272324">prev</a><span>|</span><label class="collapse" for="c-41272716">[-]</label><label class="expand" for="c-41272716">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m thinking, perhaps I can serialize hard DELETED rows as JSON and store all system deleted rows in a trash table. This way I don&#x27;t have to keep schema in sync there too.<p>this is normally known as an audit table.<p>The problem with all of these methods though is that data is persisted, but the strategy to actually recover it is left as an exercise for the reader. And in my experience, never implemented and data is never actually reviewed&#x2F;recovered in practice. The scenarios where a &quot;recycling bin&quot; is actually needed usually ends up encoded as a user-facing business requirement that ends up having an actually well-defined, non-generic, and actually recoverable logic that has nothing to do with the generically applicable soft&#x2F;hard&#x2F;audit strategies.</div><br/></div></div></div></div></div></div></div></div></div></body></html>