<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1720688470030" as="style"/><link rel="stylesheet" href="styles.css?v=1720688470030"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://joshcannon.me/2024/07/05/package-names.html">An analysis of module names inside top PyPI packages</a> <span class="domain">(<a href="https://joshcannon.me">joshcannon.me</a>)</span></div><div class="subtext"><span>thejcannon</span> | <span>26 comments</span></div><br/><div><div id="40932572" class="c"><input type="checkbox" id="c-40932572" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#40933057">next</a><span>|</span><label class="collapse" for="c-40932572">[-]</label><label class="expand" for="c-40932572">[4 more]</label></div><br/><div class="children"><div class="content">This is a great writeup on a perennially misunderstood topic in Python packaging (and namespacing&#x2F;module semantics)! A lot of (bad) security tools begin with the assumption that a top-level module name can always be reliably mapped back to its PyPI package name, and this post&#x27;s data concretely dispels that assumption.<p>It&#x27;s a shame that there isn&#x27;t (currently) a reliable way to perform this backwards link: the closest current things are `{dist}.dist-info&#x2F;METADATA` (unreliable, entirely user controlled) and `direct_url.json` for URL-installed packages, which isn&#x27;t present for packages resolved from indices.<p>Edit: PEP 710[1] would accomplish the above, but it&#x27;s still in draft.<p>[1]: <a href="https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0710&#x2F;" rel="nofollow">https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0710&#x2F;</a></div><br/><div id="40932883" class="c"><input type="checkbox" id="c-40932883" checked=""/><div class="controls bullet"><span class="by">staticautomatic</span><span>|</span><a href="#40932572">parent</a><span>|</span><a href="#40933437">next</a><span>|</span><label class="collapse" for="c-40932883">[-]</label><label class="expand" for="c-40932883">[2 more]</label></div><br/><div class="children"><div class="content">It took me what seemed like ages to figure out how to auth into Google cloud because the name of the module in their example code isn’t the name of the package. You shouldn’t have to be a detective to figure out what to pip install from looking at an import.</div><br/><div id="40932988" class="c"><input type="checkbox" id="c-40932988" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#40932572">root</a><span>|</span><a href="#40932883">parent</a><span>|</span><a href="#40933437">next</a><span>|</span><label class="collapse" for="c-40932988">[-]</label><label class="expand" for="c-40932988">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t necessarily disagree, although note that this is true for just about every packaging ecosystem: Rust, Ruby, etc. are similar in making no guarantee that the index name is even remotely related to the importable&#x2F;module name.<p>Python gets the &quot;worst&quot; of it in the sense that it&#x27;s big and has a large diversity of packages, but it&#x27;s a general consequence of having a packaging ecosystem that&#x27;s distinct from a given language&#x27;s import machinery.</div><br/></div></div></div></div><div id="40933437" class="c"><input type="checkbox" id="c-40933437" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#40932572">parent</a><span>|</span><a href="#40932883">prev</a><span>|</span><a href="#40933057">next</a><span>|</span><label class="collapse" for="c-40933437">[-]</label><label class="expand" for="c-40933437">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>This is a great writeup on a perennially misunderstood topic in Python packaging (and namespacing&#x2F;module semantics)! A lot of (bad) security tools begin with the assumption that a top-level module name can always be reliably mapped back to its PyPI package name, and this post&#x27;s data concretely dispels that assumption.</i><p>The whole model of naming of apt install &lt;thing&gt; vs port install &lt;thing&gt; is a wargame all of it&#x27;s own.<p>Your general point is well made: how you get a distribution, and unpack and install it is quite distinct from how it names inside the language&#x2F;system namespace it installs into.<p>Even at the level of ssh vs sshd, there can be confusion. the daemon is configured from sshd_ files, but they live inside &#x2F;etc&#x2F;ssh alongside &#x2F;etc&#x2F;ssh&#x2F;ssh_ files configuring the client side.</div><br/></div></div></div></div><div id="40933057" class="c"><input type="checkbox" id="c-40933057" checked=""/><div class="controls bullet"><span class="by">nicwolff</span><span>|</span><a href="#40932572">prev</a><span>|</span><a href="#40932763">next</a><span>|</span><label class="collapse" for="c-40933057">[-]</label><label class="expand" for="c-40933057">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve got a fun issue right now – two packages with dashes in the package names but underscores in the module names:<p><a href="https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;xml-from-seq&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;xml-from-seq&#x2F;</a> → xml_from_seq<p><a href="https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;cast-from-env&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;cast-from-env&#x2F;</a> → cast_from_env<p>Simple normalization, right? But `pip` installs one with underscores and one with dashes:<p><pre><code>    &gt;&gt;&gt; from importlib.metadata import metadata
    &gt;&gt;&gt; metadata(&#x27;xml_from_seq&#x27;)[&#x27;Name&#x27;]
    &#x27;xml_from_seq&#x27;
    &gt;&gt;&gt; metadata(&#x27;cast_from_env&#x27;)[&#x27;Name&#x27;]
    &#x27;cast-from-env&#x27; 
</code></pre>
so that&#x27;s what ends up in `pip freeze`.<p>I _think_ it&#x27;s because there a bdist in PyPI for one, and not the other, so `pip` is using different &quot;backends&quot; that normalize the names into `METADATA` differently... ugh.</div><br/><div id="40933095" class="c"><input type="checkbox" id="c-40933095" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#40933057">parent</a><span>|</span><a href="#40932763">next</a><span>|</span><label class="collapse" for="c-40933095">[-]</label><label class="expand" for="c-40933095">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I _think_ it&#x27;s because there a bdist in PyPI for one, and not the other, so `pip` is using different &quot;backends&quot; that normalize the names into `METADATA` differently... ugh.<p>That isn&#x27;t why: it&#x27;s because `cast-from-env`&#x27;s sdist is from March 2023, while PEP 625 (which strongly stipulates package name normalization) was adopted in setuptools a year later[1].<p>But to take a step back: why does the difference in `pip freeze` affect you? It shouldn&#x27;t matter to `pip`, since PyPI will happily serve from both the normalized and unnormalized names.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;pypa&#x2F;setuptools&#x2F;issues&#x2F;3593">https:&#x2F;&#x2F;github.com&#x2F;pypa&#x2F;setuptools&#x2F;issues&#x2F;3593</a></div><br/></div></div></div></div><div id="40932763" class="c"><input type="checkbox" id="c-40932763" checked=""/><div class="controls bullet"><span class="by">doctorpangloss</span><span>|</span><a href="#40933057">prev</a><span>|</span><a href="#40934309">next</a><span>|</span><label class="collapse" for="c-40932763">[-]</label><label class="expand" for="c-40932763">[1 more]</label></div><br/><div class="children"><div class="content">On the one hand, you could say it&#x27;s a security issue, an installed Python package can make any module names importable, which would have surprising effects if say, it overwrote stuff like aiohttp or your postgres client or whatever.<p>On the other hand, you know, it&#x27;s already source code, it can do whatever it wants...</div><br/></div></div><div id="40934309" class="c"><input type="checkbox" id="c-40934309" checked=""/><div class="controls bullet"><span class="by">formerly_proven</span><span>|</span><a href="#40932763">prev</a><span>|</span><a href="#40932789">next</a><span>|</span><label class="collapse" for="c-40934309">[-]</label><label class="expand" for="c-40934309">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There are 210 packages which include a top-level test or tests directory<p>Now there&#x27;s a somewhat useful &quot;make a pull request to an open source project&quot; exercise.</div><br/></div></div><div id="40932789" class="c"><input type="checkbox" id="c-40932789" checked=""/><div class="controls bullet"><span class="by">dheera</span><span>|</span><a href="#40934309">prev</a><span>|</span><label class="collapse" for="c-40932789">[-]</label><label class="expand" for="c-40932789">[17 more]</label></div><br/><div class="children"><div class="content">I hate this shit.<p><pre><code>    yaml -&gt; pip install pyyaml
    cv2 -&gt; pip install opencv-contrib-python
    PIL -&gt; pip install pillow (wtf, this should be a misdemeanor punishable by being forced to used windows for a year)
</code></pre>
And can we please ban &quot;py&quot; and &quot;python&quot; from appearing inside the name of python packages?<p>Or else I&#x27;m going to start writing some python packages with &quot;.js&quot; in their name.</div><br/><div id="40934782" class="c"><input type="checkbox" id="c-40934782" checked=""/><div class="controls bullet"><span class="by">RockRobotRock</span><span>|</span><a href="#40932789">parent</a><span>|</span><a href="#40933194">next</a><span>|</span><label class="collapse" for="c-40934782">[-]</label><label class="expand" for="c-40934782">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s funny and sad how you remember the stupid aliases after a while.</div><br/></div></div><div id="40933194" class="c"><input type="checkbox" id="c-40933194" checked=""/><div class="controls bullet"><span class="by">ziml77</span><span>|</span><a href="#40932789">parent</a><span>|</span><a href="#40934782">prev</a><span>|</span><a href="#40933006">next</a><span>|</span><label class="collapse" for="c-40933194">[-]</label><label class="expand" for="c-40933194">[2 more]</label></div><br/><div class="children"><div class="content">I have to look up PIL every time I use it to remember if I install PIL and import pillow or install pillow and import PIL.<p>Imports can be aliased, so why allow this mismatch at all? PyPI should have enforced that each package contains one top-level module whose name is identical to the name used to install it.</div><br/><div id="40933392" class="c"><input type="checkbox" id="c-40933392" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#40932789">root</a><span>|</span><a href="#40933194">parent</a><span>|</span><a href="#40933006">next</a><span>|</span><label class="collapse" for="c-40933392">[-]</label><label class="expand" for="c-40933392">[1 more]</label></div><br/><div class="children"><div class="content">Imports can be aliased as <i>bindings</i>; they can&#x27;t be aliased at the import machinery layer, which makes the PIL&#x2F;pillow distinction necessary. The adjacent subthread has an example of this.</div><br/></div></div></div></div><div id="40933006" class="c"><input type="checkbox" id="c-40933006" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#40932789">parent</a><span>|</span><a href="#40933194">prev</a><span>|</span><a href="#40932872">next</a><span>|</span><label class="collapse" for="c-40933006">[-]</label><label class="expand" for="c-40933006">[5 more]</label></div><br/><div class="children"><div class="content">Banning &quot;py&quot; would catch &quot;mypy&quot; and &quot;pydantic&quot;, both of which you probably don&#x27;t intend to catch.<p>pillow is imported as `PIL` because it&#x27;s a fork of the original PIL[1]. There&#x27;s a <i>very</i> strong argument that Python&#x27;s ability to retain the same import name across package name changes like that is a valuable source of flexibility that has benefited the ecosystem as a whole.<p>[1]: <a href="https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;PIL&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;PIL&#x2F;</a></div><br/><div id="40933038" class="c"><input type="checkbox" id="c-40933038" checked=""/><div class="controls bullet"><span class="by">throw-the-towel</span><span>|</span><a href="#40932789">root</a><span>|</span><a href="#40933006">parent</a><span>|</span><a href="#40932872">next</a><span>|</span><label class="collapse" for="c-40933038">[-]</label><label class="expand" for="c-40933038">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Python&#x27;s ability to retain the same import name across package name changes...<p>As in, `import pillow as PIL`?</div><br/><div id="40933075" class="c"><input type="checkbox" id="c-40933075" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#40932789">root</a><span>|</span><a href="#40933038">parent</a><span>|</span><a href="#40932872">next</a><span>|</span><label class="collapse" for="c-40933075">[-]</label><label class="expand" for="c-40933075">[3 more]</label></div><br/><div class="children"><div class="content">&gt; As in, `import pillow as PIL`?<p>As in, not changing your imports at all, and just changing your dependency from PIL to pillow. This has two substantial advantages:<p>1. You only have to change one line (the dependency), not an indefinite number of source files. This is less of an issue now that the Python community has high-quality refactoring tools, but it&#x27;s still the past of least resistance.<p>2. More importantly: `import pillow as PIL` is not referentially transparent: the `PIL` binding that it introduces is a `module` object, but that object can&#x27;t be used in subsequent imports. In other words, blindly performing an `import X as Y` refactor would break code like this:<p><pre><code>    import PIL
    from PIL import whatever
</code></pre>
You can observe this for yourself locally:<p><pre><code>    &gt;&gt;&gt; import ssl as lol
    &gt;&gt;&gt; from lol import CERT_NONE
    ModuleNotFoundError: No module named &#x27;lol&#x27;
    &gt;&gt;&gt; from ssl import CERT_NONE
</code></pre>
This is arguably a defect in Python&#x27;s import and module machinery, but that&#x27;s how it currently is. Renaming the dependency and keeping the module name is <i>far</i> less fraught.</div><br/><div id="40933950" class="c"><input type="checkbox" id="c-40933950" checked=""/><div class="controls bullet"><span class="by">dheera</span><span>|</span><a href="#40932789">root</a><span>|</span><a href="#40933075">parent</a><span>|</span><a href="#40932872">next</a><span>|</span><label class="collapse" for="c-40933950">[-]</label><label class="expand" for="c-40933950">[2 more]</label></div><br/><div class="children"><div class="content">The related thing that bothers me deeply is that<p><pre><code>    import PIL
</code></pre>
does not make PIL.Image available. What the hell else do you expect me to do with PIL? Why isn&#x27;t PIL.Image included in importing PIL? You have to explicitly do either of these<p><pre><code>    import PIL.Image
    from PIL import Image</code></pre></div><br/><div id="40934011" class="c"><input type="checkbox" id="c-40934011" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#40932789">root</a><span>|</span><a href="#40933950">parent</a><span>|</span><a href="#40932872">next</a><span>|</span><label class="collapse" for="c-40934011">[-]</label><label class="expand" for="c-40934011">[1 more]</label></div><br/><div class="children"><div class="content">That’s because it’s a module within the PIL module, not an attribute of PIL. But that doesn’t really have anything to do with the original comment; that’s a different quirk of Python’s import machinery.<p>(Understanding the difference between packages, module hierarchies, and module attributes is table stakes for architecting a large Python package correctly. PIL almost certainly does this to prevent hard-to-debug circular imports elsewhere in their codebase.)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40932872" class="c"><input type="checkbox" id="c-40932872" checked=""/><div class="controls bullet"><span class="by">cozzyd</span><span>|</span><a href="#40932789">parent</a><span>|</span><a href="#40933006">prev</a><span>|</span><a href="#40932913">next</a><span>|</span><label class="collapse" for="c-40932872">[-]</label><label class="expand" for="c-40932872">[6 more]</label></div><br/><div class="children"><div class="content">Unless something is a binding, baking a package after the programming language is super weird. Like what if you change the implementation language later?</div><br/><div id="40933034" class="c"><input type="checkbox" id="c-40933034" checked=""/><div class="controls bullet"><span class="by">rty32</span><span>|</span><a href="#40932789">root</a><span>|</span><a href="#40932872">parent</a><span>|</span><a href="#40932913">next</a><span>|</span><label class="collapse" for="c-40933034">[-]</label><label class="expand" for="c-40933034">[5 more]</label></div><br/><div class="children"><div class="content">&gt; what if you change the implementation language later?<p>I don&#x27;t think that is a thing that happens in real life.<p>* Practically, one package is associated with exactly one github repository, sometimes a few. You would see implementation switching from JavaScript to TypeScript, but almost never from python to Go. Normally people start a brand new project for that kind of thing.
* The reality is that each language has its own library ecosystem, and people reinvent the wheel at least once for each language. I wish we live in a world where you could save the effort, instead implement everything only once and it runs efficiently and has idiomatic APIs everywhere. But that&#x27;s not how it works. If you create a package for a language, that&#x27;s it. You could reimplement the same thing like by line in another language, but that would be a different package for that language.</div><br/><div id="40933116" class="c"><input type="checkbox" id="c-40933116" checked=""/><div class="controls bullet"><span class="by">cozzyd</span><span>|</span><a href="#40932789">root</a><span>|</span><a href="#40933034">parent</a><span>|</span><a href="#40933869">next</a><span>|</span><label class="collapse" for="c-40933116">[-]</label><label class="expand" for="c-40933116">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s pretty common for e.g. old scientific software to get rewritten from Fortran to C++ with a version bump.</div><br/></div></div><div id="40933869" class="c"><input type="checkbox" id="c-40933869" checked=""/><div class="controls bullet"><span class="by">dheera</span><span>|</span><a href="#40932789">root</a><span>|</span><a href="#40933034">parent</a><span>|</span><a href="#40933116">prev</a><span>|</span><a href="#40932913">next</a><span>|</span><label class="collapse" for="c-40933869">[-]</label><label class="expand" for="c-40933869">[3 more]</label></div><br/><div class="children"><div class="content">Yeah but what <i>is</i> common in real life is writing multiple parallel libraries for {Python, NodeJS, ...} with a nearly identical API. In this case I would think that if the Python command is `pip install foo`, the NodeJS command should be `npm install foo`. It&#x27;s redundant to do `pip install foo-python` when pip is only for Python, and opens the door for stealthy attacks where someone else creates `pip install foo` on PyPI that is forked from your repo and mirrors your API exactly but steals data and credentials and sends it to malicious servers.</div><br/><div id="40934072" class="c"><input type="checkbox" id="c-40934072" checked=""/><div class="controls bullet"><span class="by">kortex</span><span>|</span><a href="#40932789">root</a><span>|</span><a href="#40933869">parent</a><span>|</span><a href="#40932913">next</a><span>|</span><label class="collapse" for="c-40934072">[-]</label><label class="expand" for="c-40934072">[2 more]</label></div><br/><div class="children"><div class="content">&gt; when pip is only for Python<p>That&#x27;s the neat part, it&#x27;s not! You can distribute basically any kind of data with pip, within reason. Iirc Cmake can be pip-installed.</div><br/><div id="40934335" class="c"><input type="checkbox" id="c-40934335" checked=""/><div class="controls bullet"><span class="by">rented_mule</span><span>|</span><a href="#40932789">root</a><span>|</span><a href="#40934072">parent</a><span>|</span><a href="#40932913">next</a><span>|</span><label class="collapse" for="c-40934335">[-]</label><label class="expand" for="c-40934335">[1 more]</label></div><br/><div class="children"><div class="content">`pip install nodejs-bin` gets you node, including npm, in your venv along with bindings for calling it all from Python.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40932913" class="c"><input type="checkbox" id="c-40932913" checked=""/><div class="controls bullet"><span class="by">nilamo</span><span>|</span><a href="#40932789">parent</a><span>|</span><a href="#40932872">prev</a><span>|</span><label class="collapse" for="c-40932913">[-]</label><label class="expand" for="c-40932913">[2 more]</label></div><br/><div class="children"><div class="content">Pillow is a special case, in that it was always meant as a drop in replacement for the PIL, and you only changed the requirements.txt</div><br/><div id="40933233" class="c"><input type="checkbox" id="c-40933233" checked=""/><div class="controls bullet"><span class="by">ziml77</span><span>|</span><a href="#40932789">root</a><span>|</span><a href="#40932913">parent</a><span>|</span><label class="collapse" for="c-40933233">[-]</label><label class="expand" for="c-40933233">[1 more]</label></div><br/><div class="children"><div class="content">Feels to me like that was a deficiency in the package management tools. Like if your requirements file could define a global alias, it would allow people who want that easy one-line change to install pillow as PIL. But everyone else who was starting fresh or who was okay with doing a few edits to their Python files could install pillow and use it as pillow.<p>I guess though that there could be an issue with some dependencies being written against PIL and others being written against pillow?</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>