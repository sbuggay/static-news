<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1694163660314" as="style"/><link rel="stylesheet" href="styles.css?v=1694163660314"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/JuliaDebug/Cthulhu.jl">Cthulhu.jl – show type-inferred Julia code</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>xgdgsc</span> | <span>33 comments</span></div><br/><div><div id="37425936" class="c"><input type="checkbox" id="c-37425936" checked=""/><div class="controls bullet"><span class="by">tmvphil</span><span>|</span><a href="#37425965">next</a><span>|</span><label class="collapse" for="c-37425936">[-]</label><label class="expand" for="c-37425936">[14 more]</label></div><br/><div class="children"><div class="content">These tools are a great improvement, but honestly I find working with this aspect of Julia to be super frustrating. External tools feels like a poor substitute for a type system where this kind of information was obvious from the code.</div><br/><div id="37426408" class="c"><input type="checkbox" id="c-37426408" checked=""/><div class="controls bullet"><span class="by">ssivark</span><span>|</span><a href="#37425936">parent</a><span>|</span><a href="#37426266">next</a><span>|</span><label class="collapse" for="c-37426408">[-]</label><label class="expand" for="c-37426408">[12 more]</label></div><br/><div class="children"><div class="content">Are you talking about static typing? If so, that sounds fundamentally incompatible with the basic worldview behind Julia — that you want to delay binding&#x2F;dispatch till runtime, and leverage multiple dispatch, for high composability &amp; code reuse.<p>I wonder how capable the ahead-of-time compiler would be, if you have not just the library, but can also provide the “inputs” in your “script” (that it can specialize on).</div><br/><div id="37429651" class="c"><input type="checkbox" id="c-37429651" checked=""/><div class="controls bullet"><span class="by">majoe</span><span>|</span><a href="#37425936">root</a><span>|</span><a href="#37426408">parent</a><span>|</span><a href="#37427205">next</a><span>|</span><label class="collapse" for="c-37429651">[-]</label><label class="expand" for="c-37429651">[1 more]</label></div><br/><div class="children"><div class="content">Playing <i>advocatus deii</i> for Julia, I guess you could write code, where all function signatures only contain concrete types. Then the ahead-of-time compiler would work the same as for a C++ program without templates and dynamic polymorphism through subtyping. That&#x27;s a totally valid programming model, that noone uses.
Of course you don&#x27;t have to go that far in practice and you still could have static types with less restrictions, as long as the types are inferable</div><br/></div></div><div id="37427205" class="c"><input type="checkbox" id="c-37427205" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#37425936">root</a><span>|</span><a href="#37426408">parent</a><span>|</span><a href="#37429651">prev</a><span>|</span><a href="#37426266">next</a><span>|</span><label class="collapse" for="c-37427205">[-]</label><label class="expand" for="c-37427205">[10 more]</label></div><br/><div class="children"><div class="content">The question I have is whether Julia-style multiple dispatch would be practical in a statically typed language?</div><br/><div id="37427599" class="c"><input type="checkbox" id="c-37427599" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#37425936">root</a><span>|</span><a href="#37427205">parent</a><span>|</span><a href="#37427555">next</a><span>|</span><label class="collapse" for="c-37427599">[-]</label><label class="expand" for="c-37427599">[6 more]</label></div><br/><div class="children"><div class="content">Multiple dispatch is a kind of <i>runtime</i> type resolution. Static&#x2F;compile-time function overloading based on types is a thing, but is fairly banal... common in C++, but mostly forbidden in Rust, but it doesn&#x27;t resolve on vtables, so doesn&#x27;t give you the same kind of polymorphism as what you&#x27;d get in Dylan&#x2F;Julia&#x2F;CLOS&#x2F;Cecil, etc.<p>This looks like a good series of blog posts on this topic: <a href="https:&#x2F;&#x2F;eli.thegreenplace.net&#x2F;tag&#x2F;multiple-dispatch" rel="nofollow noreferrer">https:&#x2F;&#x2F;eli.thegreenplace.net&#x2F;tag&#x2F;multiple-dispatch</a><p>Myself, I was excited to work in a language with multiple dispatch at first, but once I spent some time working full-time in Julia the sheen wore off. It could be Julia&#x27;s take on it, but I really don&#x27;t like the kind of ... semantic overloading ... and duck typing that can happen all over the place.<p>Programs can become very hard to reason about.</div><br/><div id="37428168" class="c"><input type="checkbox" id="c-37428168" checked=""/><div class="controls bullet"><span class="by">underdraft_fee</span><span>|</span><a href="#37425936">root</a><span>|</span><a href="#37427599">parent</a><span>|</span><a href="#37427555">next</a><span>|</span><label class="collapse" for="c-37428168">[-]</label><label class="expand" for="c-37428168">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve worked quite extensively for Julia as my primary language for quite some time at this point. I&#x27;ve gone from being absolutely in love with the language to extremely disillusioned over the last couple of years.<p>It is incredibly hard to reason about this language if every developer is not willing to commit to understanding and writing Julia code the right way (e.g. type stable, dispatch via the type system, actually defining interfaces). Given the target demographic of academics, the proportion of people interested in grokking Julia is vastly smaller than the number of academics who hear &quot;walks like Python runs like C&quot; and decide this is their new, free, hip MATLAB&#x2F;SciPy replacement.<p>And it&#x27;s extremely good for that! The SciML ecosystem is top of the class, I would never recommend someone solve a differential equation any other way. If you can build a system that is just a thin wrapper on top of SciML, absolutely go for it. I would recommend anyone wanting to build new systems from scratch to look elsewhere.<p>But, the tooling is subpar and overfit to the VS Code extension, and even there I found so many false positives with the linter that I just started ignoring all but the most basic of warnings. It&#x27;s not entirely the fault of the developers, Julia is dynamically typed and there&#x27;s only so much you can do. But if you have to type things rigidly enough that it&#x27;s inferrable while <i>developing</i> that Cthulhu.jl or JET.jl can infer the types, why not just work with a static type system where you get that for free?<p>I have also found the obsession with reducing time to first plot incredibly aggravating. It is finally down to a pretty good level, which is a nice quality of life improvement. However, it has done absolutely nothing for my ability to write code that doesn&#x27;t crash because someone passed in a type that doesn&#x27;t obey the implicit interface I expect.</div><br/><div id="37428801" class="c"><input type="checkbox" id="c-37428801" checked=""/><div class="controls bullet"><span class="by">minetest2048</span><span>|</span><a href="#37425936">root</a><span>|</span><a href="#37428168">parent</a><span>|</span><a href="#37428244">next</a><span>|</span><label class="collapse" for="c-37428801">[-]</label><label class="expand" for="c-37428801">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I have also found the obsession with reducing time to first plot incredibly aggravating. It is finally down to a pretty good level, which is a nice quality of life improvement<p>For the target users of Julia, which are academics that are currently using Matlab or Python, time to first plot is one of the primary reasons that they are not willing to switch to Julia. Especially if their current workflow is writing a script then pressing run button in Matlab or calling python my_script.py, then they do julia my_script.jl and they expect it to work the same way as Python or Matlab do. This is why in all the user &amp; developer survey TTFP is consistently ranked highest.<p>As a research software engineer, I&#x27;ve seen PhDs and postdocs that are downright scared of programming and any kind of low level technical work in general, even if their problem domain requires high performance languages. They just want their project or thesis to finish within their probably unrealistic deadlines. You throw them to a language with strict type checking or traits and interfaces and they will just give up. Unfortunately if the language users are filled with these kind of user then it results to this kind of problems, which you did mentioned in your second paragraph.<p>&gt; It is incredibly hard to reason about this language if every developer is not willing to commit to understanding and writing Julia code the right way (e.g. type stable, dispatch via the type system, actually defining interfaces). Given the target demographic of academics, the proportion of people interested in grokking Julia is vastly smaller than the number of academics who hear &quot;walks like Python runs like C&quot; and decide this is their new, free, hip MATLAB&#x2F;SciPy replacement.<p>Thinking about it, to solve this Julia problem we need to solve academics scared of programming problem. I don&#x27;t have a solution to this either, I&#x27;ve been trying to think about it after seeing several people keep asking me for help in programming</div><br/></div></div><div id="37428244" class="c"><input type="checkbox" id="c-37428244" checked=""/><div class="controls bullet"><span class="by">affinepplan</span><span>|</span><a href="#37425936">root</a><span>|</span><a href="#37428168">parent</a><span>|</span><a href="#37428801">prev</a><span>|</span><a href="#37428228">next</a><span>|</span><label class="collapse" for="c-37428244">[-]</label><label class="expand" for="c-37428244">[1 more]</label></div><br/><div class="children"><div class="content">I have not yet fallen out of love with the language, but I can absolutely sympathize with the desire for better ways to define and enforce interfaces. In my opinion it is the #2 issue for me right behind having a non-kludgy import&#x2F;module system</div><br/></div></div><div id="37428228" class="c"><input type="checkbox" id="c-37428228" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#37425936">root</a><span>|</span><a href="#37428168">parent</a><span>|</span><a href="#37428244">prev</a><span>|</span><a href="#37427555">next</a><span>|</span><label class="collapse" for="c-37428228">[-]</label><label class="expand" for="c-37428228">[2 more]</label></div><br/><div class="children"><div class="content">I was working in a non-numerics&#x2F;non-scientific code base and the quality of the code was good to very good. And I could see the value Julia was bringing to the table on some aspects of the higher levels of their stack. But it utterly fails at being any kind of &quot;systems language&quot;, and it was being coraled into that role in spots. Tossing some optional somewhat-static (but not really) type declarations and a JIT into the language doesn&#x27;t make it a performant language for areas where something like C++, Rust, etc. would be more suited.<p>And yes, like any late-bound language, it&#x27;s going to be prone to crashing at runtime in unexpected ways. Julia has some okayish tools for doing some static analysis, but it&#x27;s never going to be at the level of what you can get out of an actual modern static type system. I was fortunate to work with some very smart people who had written some very high quality code in Julia, and some aspects of the language I found very nice and expressive (and even sometimes miss), but I was happy to go back to writing Rust after I switched jobs.<p>And yeah, not being a VSCode user (JetBrains addict), I found tooling lacking as well. The emacs mode was okayish. Also found I kept having to use the Repl in ways I found non-intuitive.<p>I would reach for Julia as an alternative to Python, maybe, for certain types of things. It&#x27;s certainly prettier to look at.</div><br/><div id="37430012" class="c"><input type="checkbox" id="c-37430012" checked=""/><div class="controls bullet"><span class="by">npalli</span><span>|</span><a href="#37425936">root</a><span>|</span><a href="#37428228">parent</a><span>|</span><a href="#37427555">next</a><span>|</span><label class="collapse" for="c-37430012">[-]</label><label class="expand" for="c-37430012">[1 more]</label></div><br/><div class="children"><div class="content">Using Julia as non-numerics&#x2F;non-scientific systems language is not a good fit. So, not surprising you are not finding it as useful as Rust. JIT performance notwithstanding. As for Python, it is getting defaulted to any and every programming niche with predictably bad results.</div><br/></div></div></div></div></div></div></div></div><div id="37428078" class="c"><input type="checkbox" id="c-37428078" checked=""/><div class="controls bullet"><span class="by">kelipso</span><span>|</span><a href="#37425936">root</a><span>|</span><a href="#37427205">parent</a><span>|</span><a href="#37427555">prev</a><span>|</span><a href="#37426266">next</a><span>|</span><label class="collapse" for="c-37428078">[-]</label><label class="expand" for="c-37428078">[2 more]</label></div><br/><div class="children"><div class="content">Haskell&#x27;s type classes work fine, similar enough to multiple dispatch.</div><br/><div id="37430101" class="c"><input type="checkbox" id="c-37430101" checked=""/><div class="controls bullet"><span class="by">majoe</span><span>|</span><a href="#37425936">root</a><span>|</span><a href="#37428078">parent</a><span>|</span><a href="#37426266">next</a><span>|</span><label class="collapse" for="c-37430101">[-]</label><label class="expand" for="c-37430101">[1 more]</label></div><br/><div class="children"><div class="content">I think it would be great for Julia to have a mechanism to formalise&#x2F;enforce interfaces.<p>I thought a bit about it lately and came to the conclusion, that something like C++ concepts (minus the clunky syntax) would be a better fit for Julia than Haskell&#x27;s typeclasses or Rust traits. The main difference for me is, that typeclasses are a whitelist of allowed types, while concepts are a set of type constraints, that blacklist types, when the constraints are not fulfilled. Otherwise they are quite similar.<p>As a result, you don&#x27;t have to explicitly create a instance with concepts like you would need to do for type classes and packages can happily interoperate without knowing of each other.</div><br/></div></div></div></div></div></div></div></div><div id="37426266" class="c"><input type="checkbox" id="c-37426266" checked=""/><div class="controls bullet"><span class="by">vchuravy</span><span>|</span><a href="#37425936">parent</a><span>|</span><a href="#37426408">prev</a><span>|</span><a href="#37425965">next</a><span>|</span><label class="collapse" for="c-37426266">[-]</label><label class="expand" for="c-37426266">[1 more]</label></div><br/><div class="children"><div class="content">Yeah in the end this the difference between dynamical and static typing.<p>I enjoy 
<a href="https:&#x2F;&#x2F;tratt.net&#x2F;laurie&#x2F;research&#x2F;pubs&#x2F;html&#x2F;tratt__dynamically_typed_languages&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;tratt.net&#x2F;laurie&#x2F;research&#x2F;pubs&#x2F;html&#x2F;tratt__dynamical...</a> as a discussion of dynamic typing.</div><br/></div></div></div></div><div id="37425965" class="c"><input type="checkbox" id="c-37425965" checked=""/><div class="controls bullet"><span class="by">vchuravy</span><span>|</span><a href="#37425936">prev</a><span>|</span><a href="#37415506">next</a><span>|</span><label class="collapse" for="c-37425965">[-]</label><label class="expand" for="c-37425965">[6 more]</label></div><br/><div class="children"><div class="content">One of the authors here, happy to answer questions.</div><br/><div id="37426830" class="c"><input type="checkbox" id="c-37426830" checked=""/><div class="controls bullet"><span class="by">contravariant</span><span>|</span><a href="#37425965">parent</a><span>|</span><a href="#37415506">next</a><span>|</span><label class="collapse" for="c-37426830">[-]</label><label class="expand" for="c-37426830">[5 more]</label></div><br/><div class="children"><div class="content">You had a perfectly good opportunity to call a function madness and then descend into it, why didn&#x27;t you?</div><br/><div id="37426950" class="c"><input type="checkbox" id="c-37426950" checked=""/><div class="controls bullet"><span class="by">philipov</span><span>|</span><a href="#37425965">root</a><span>|</span><a href="#37426830">parent</a><span>|</span><a href="#37427036">next</a><span>|</span><label class="collapse" for="c-37426950">[-]</label><label class="expand" for="c-37426950">[1 more]</label></div><br/><div class="children"><div class="content">This could be a feature request.</div><br/></div></div><div id="37427036" class="c"><input type="checkbox" id="c-37427036" checked=""/><div class="controls bullet"><span class="by">vchuravy</span><span>|</span><a href="#37425965">root</a><span>|</span><a href="#37426830">parent</a><span>|</span><a href="#37426950">prev</a><span>|</span><a href="#37415506">next</a><span>|</span><label class="collapse" for="c-37427036">[-]</label><label class="expand" for="c-37427036">[3 more]</label></div><br/><div class="children"><div class="content">Ah but what defines madness? For me it&#x27;s innocuous functions that have surprising&#x2F;wild behavior due to type inference disagreeing with me.<p>Most of the time I am the one wrong.</div><br/><div id="37430678" class="c"><input type="checkbox" id="c-37430678" checked=""/><div class="controls bullet"><span class="by">sundarurfriend</span><span>|</span><a href="#37425965">root</a><span>|</span><a href="#37427036">parent</a><span>|</span><a href="#37415506">next</a><span>|</span><label class="collapse" for="c-37430678">[-]</label><label class="expand" for="c-37430678">[2 more]</label></div><br/><div class="children"><div class="content">Changing the `function foo()` in the &quot;Usage: descend&quot; section to `function madness()` sounds like a pretty good&#x2F;funny idea.<p><pre><code>    @descend madness()
</code></pre>
would be a pretty good reference to the original text!<p>Positive: it would also let people know at a glance that things like `rand() &gt; 0.5 ? Int64 : Float64` are indeed madness.<p>Potential negative: some people may not consider it super DEI-friendly? As a neurodivergent person, I&#x27;d just find it to be just a lovely reference though.</div><br/><div id="37431192" class="c"><input type="checkbox" id="c-37431192" checked=""/><div class="controls bullet"><span class="by">drt5b7j</span><span>|</span><a href="#37425965">root</a><span>|</span><a href="#37430678">parent</a><span>|</span><a href="#37415506">next</a><span>|</span><label class="collapse" for="c-37431192">[-]</label><label class="expand" for="c-37431192">[1 more]</label></div><br/><div class="children"><div class="content">What a vapid comment.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37415506" class="c"><input type="checkbox" id="c-37415506" checked=""/><div class="controls bullet"><span class="by">xgdgsc</span><span>|</span><a href="#37425965">prev</a><span>|</span><a href="#37426301">next</a><span>|</span><label class="collapse" for="c-37415506">[-]</label><label class="expand" for="c-37415506">[9 more]</label></div><br/><div class="children"><div class="content">Latest release adds integrate with VSCode that shows inferred types inline.</div><br/><div id="37426573" class="c"><input type="checkbox" id="c-37426573" checked=""/><div class="controls bullet"><span class="by">andyferris</span><span>|</span><a href="#37415506">parent</a><span>|</span><a href="#37425853">next</a><span>|</span><label class="collapse" for="c-37426573">[-]</label><label class="expand" for="c-37426573">[4 more]</label></div><br/><div class="children"><div class="content">This sounds great!<p>Is this built into the existing VSCode extension, or as another extension you need to install?</div><br/><div id="37426683" class="c"><input type="checkbox" id="c-37426683" checked=""/><div class="controls bullet"><span class="by">xgdgsc</span><span>|</span><a href="#37415506">root</a><span>|</span><a href="#37426573">parent</a><span>|</span><a href="#37425853">next</a><span>|</span><label class="collapse" for="c-37426683">[-]</label><label class="expand" for="c-37426683">[3 more]</label></div><br/><div class="children"><div class="content">Just update to latest julia extension and use Cthulhu inside the extension started REPL.</div><br/><div id="37426705" class="c"><input type="checkbox" id="c-37426705" checked=""/><div class="controls bullet"><span class="by">sdfghswe</span><span>|</span><a href="#37415506">root</a><span>|</span><a href="#37426683">parent</a><span>|</span><a href="#37425853">next</a><span>|</span><label class="collapse" for="c-37426705">[-]</label><label class="expand" for="c-37426705">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think I&#x27;ve ever updated the julia extension. Is that something that has to be done manually? I&#x27;m on v1.51.2<p>Update: I just saw that the last release is from 2023-08-31, so I guess it&#x27;s been updating automatically.</div><br/><div id="37426941" class="c"><input type="checkbox" id="c-37426941" checked=""/><div class="controls bullet"><span class="by">xgdgsc</span><span>|</span><a href="#37415506">root</a><span>|</span><a href="#37426705">parent</a><span>|</span><a href="#37425853">next</a><span>|</span><label class="collapse" for="c-37426941">[-]</label><label class="expand" for="c-37426941">[1 more]</label></div><br/><div class="children"><div class="content">Yes this version should work.</div><br/></div></div></div></div></div></div></div></div><div id="37425853" class="c"><input type="checkbox" id="c-37425853" checked=""/><div class="controls bullet"><span class="by">sdfghswe</span><span>|</span><a href="#37415506">parent</a><span>|</span><a href="#37426573">prev</a><span>|</span><a href="#37426301">next</a><span>|</span><label class="collapse" for="c-37425853">[-]</label><label class="expand" for="c-37425853">[4 more]</label></div><br/><div class="children"><div class="content">What does this show that @code_warntype doesn&#x27;t?</div><br/><div id="37427025" class="c"><input type="checkbox" id="c-37427025" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#37415506">root</a><span>|</span><a href="#37425853">parent</a><span>|</span><a href="#37426040">next</a><span>|</span><label class="collapse" for="c-37427025">[-]</label><label class="expand" for="c-37427025">[2 more]</label></div><br/><div class="children"><div class="content">A few things. For me the most important is that it lets you easily explore the whole compile time call graph. (i.e if `h(x)=x*x` and `f(x)=h(x)`, Cthulhu will let you easily switch from looking at `f` to looking at `h` (think of it like compile time debugging). Cthulhu also has the equivalent of @code_llvm and @code_native.</div><br/><div id="37427306" class="c"><input type="checkbox" id="c-37427306" checked=""/><div class="controls bullet"><span class="by">celrod</span><span>|</span><a href="#37415506">root</a><span>|</span><a href="#37427025">parent</a><span>|</span><a href="#37426040">next</a><span>|</span><label class="collapse" for="c-37427306">[-]</label><label class="expand" for="c-37427306">[1 more]</label></div><br/><div class="children"><div class="content">This is extremely helpful when hunting for type instabilities.<p>`@code_warntype` and `Cthulhu.@descend` can both show `SomePackage.foo` was inferred as `Any`.
But why? Cthulhu lets you immediately descend, and see that it&#x27;s because it calls `SomeOtherPackage.bar`, so you descend, and see...<p>Five or ten calls in, you finally see a problem you can fix that can motivate a PR.
This is fast to do with with `Cthulhu`. Descending is as easy as pressing `[enter]`, instead of requiring you to construct all the arguments and descend.<p>Exploring the call graph while doing this gives you some overview of what the code is doing, and you can always look for the initial cause of propagating instabilities, instead of wading through a ton of JET output (but JET is also great).</div><br/></div></div></div></div><div id="37426040" class="c"><input type="checkbox" id="c-37426040" checked=""/><div class="controls bullet"><span class="by">borodi</span><span>|</span><a href="#37415506">root</a><span>|</span><a href="#37425853">parent</a><span>|</span><a href="#37427025">prev</a><span>|</span><a href="#37426301">next</a><span>|</span><label class="collapse" for="c-37426040">[-]</label><label class="expand" for="c-37426040">[1 more]</label></div><br/><div class="children"><div class="content">It tries to show you the type information on the source itself, instead of on the IR.</div><br/></div></div></div></div></div></div><div id="37426301" class="c"><input type="checkbox" id="c-37426301" checked=""/><div class="controls bullet"><span class="by">ivirshup</span><span>|</span><a href="#37415506">prev</a><span>|</span><a href="#37427964">next</a><span>|</span><label class="collapse" for="c-37426301">[-]</label><label class="expand" for="c-37426301">[1 more]</label></div><br/><div class="children"><div class="content">Love this tool. Invaluable for figuring out what code actually got called after complicated dispatch.</div><br/></div></div><div id="37427964" class="c"><input type="checkbox" id="c-37427964" checked=""/><div class="controls bullet"><span class="by">zeckalpha</span><span>|</span><a href="#37426301">prev</a><span>|</span><a href="#37429001">next</a><span>|</span><label class="collapse" for="c-37427964">[-]</label><label class="expand" for="c-37427964">[1 more]</label></div><br/><div class="children"><div class="content">Hoping this doesn&#x27;t reopen &quot;Julia is dependent typed&quot; debate</div><br/></div></div></div></div></div></div></div></body></html>