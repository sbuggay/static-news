<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1732611672515" as="style"/><link rel="stylesheet" href="styles.css?v=1732611672515"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://cacm.acm.org/research-highlights/computing-with-time-microarchitectural-weird-machines/">Computing with Time: Microarchitectural Weird Machines</a> <span class="domain">(<a href="https://cacm.acm.org">cacm.acm.org</a>)</span></div><div class="subtext"><span>rbanffy</span> | <span>22 comments</span></div><br/><div><div id="42238037" class="c"><input type="checkbox" id="c-42238037" checked=""/><div class="controls bullet"><span class="by">rikthevik</span><span>|</span><a href="#42237400">next</a><span>|</span><label class="collapse" for="c-42238037">[-]</label><label class="expand" for="c-42238037">[1 more]</label></div><br/><div class="children"><div class="content">This is fantastic stuff, building these machines out of odd primitives.<p>They kind of remind me of blind SQL injection attacks. When you can inject SQL, but can&#x27;t view the output, so you use things like `pg_sleep()` to get a low-fidelity form of query output. Depending on how far you want to go, you can use different sleep lengths to slowly exfiltrate data.<p><a href="https:&#x2F;&#x2F;owasp.org&#x2F;www-community&#x2F;attacks&#x2F;Blind_SQL_Injection" rel="nofollow">https:&#x2F;&#x2F;owasp.org&#x2F;www-community&#x2F;attacks&#x2F;Blind_SQL_Injection</a></div><br/></div></div><div id="42237400" class="c"><input type="checkbox" id="c-42237400" checked=""/><div class="controls bullet"><span class="by">kaladin-jasnah</span><span>|</span><a href="#42238037">prev</a><span>|</span><a href="#42238412">next</a><span>|</span><label class="collapse" for="c-42237400">[-]</label><label class="expand" for="c-42237400">[2 more]</label></div><br/><div class="children"><div class="content">I read this for some work I did a few months ago. It&#x27;s a very interesting idea to try to uncover a computer within a computer. It reminds me of the Atari 2600 emulators in Minecraft [1], or things like using bitwise operators to compute and write arbitrary data to memory as is done in the Pegasus&#x2F;NSO exploit [2]. But I think the literature does not necessarily imply that these &quot;weird machines&quot; are Turing complete or capable of much; they are more general. From my understanding weird machines are some sort of FSM of unintended&#x2F;weird states in a program with various transitions to go from weird state to weird state. The use is to be able to construct a weird machine with enough states and transitions to get a program to a vulnerable state where it can be exploited. Getting something like this with micro-architectural weird machines, the Pegasus exploit, etc. is of course much harder, and more valuable. It will also be interesting to see if the theory behind weird machines becomes used for automated exploit generation in the future.<p>[1] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=mq7T5_xH24M" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=mq7T5_xH24M</a><p>[2] <a href="https:&#x2F;&#x2F;googleprojectzero.blogspot.com&#x2F;2021&#x2F;12&#x2F;a-deep-dive-into-nso-zero-click.html" rel="nofollow">https:&#x2F;&#x2F;googleprojectzero.blogspot.com&#x2F;2021&#x2F;12&#x2F;a-deep-dive-i...</a></div><br/><div id="42237548" class="c"><input type="checkbox" id="c-42237548" checked=""/><div class="controls bullet"><span class="by">EvanAnderson</span><span>|</span><a href="#42237400">parent</a><span>|</span><a href="#42238412">next</a><span>|</span><label class="collapse" for="c-42237548">[-]</label><label class="expand" for="c-42237548">[1 more]</label></div><br/><div class="children"><div class="content">As good a place as any to share: <a href="https:&#x2F;&#x2F;matt-rickard.com&#x2F;accidentally-turing-complete" rel="nofollow">https:&#x2F;&#x2F;matt-rickard.com&#x2F;accidentally-turing-complete</a></div><br/></div></div></div></div><div id="42238412" class="c"><input type="checkbox" id="c-42238412" checked=""/><div class="controls bullet"><span class="by">rep_lodsb</span><span>|</span><a href="#42237400">prev</a><span>|</span><a href="#42239004">next</a><span>|</span><label class="collapse" for="c-42238412">[-]</label><label class="expand" for="c-42238412">[1 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t seem to be useful for hiding the fact that <i>something</i> suspicious is going on. If I understand it correctly, a static analysis of the program would reveal that they are decrypting code with an AES key derived from CPU instruction timings, and then executing that code inside a TSX transaction.<p>Hardly normal behavior for non-malicious code. The only thing hidden is the actual key that will be used when it runs correctly, and hence what exactly the decrypted code does.<p>(Also, didn&#x27;t Intel obsolete TSX already in more recent CPU generations, because of its use for speculative execution side-channels?)</div><br/></div></div><div id="42239004" class="c"><input type="checkbox" id="c-42239004" checked=""/><div class="controls bullet"><span class="by">spaintech</span><span>|</span><a href="#42238412">prev</a><span>|</span><a href="#42242118">next</a><span>|</span><label class="collapse" for="c-42239004">[-]</label><label class="expand" for="c-42239004">[3 more]</label></div><br/><div class="children"><div class="content">When I read these articles, I always ask myself if this is more of a joint OS-ISA issue than just an ISA problem.<p>Wondering if a well defined OS system, with strict enforcement of memory boundaries at the OS level and at the application level, where the application sits in a well defined deterministic execution model would mitigate some of these unpredictable state transitions.<p>If one considers a minimalist OS, micro kernel for example, lowering the attack surface, would this not explicitly prevent access to certain microarchitectural states (e.g., by disallowing certain instructions like clflush or speculative paths)? This could be accomplished with a strict memory management jointly at the OS layer and the binary structure of the application… one where the binary has a well defined memory memory boundary. The OS just ensures it is kept with in these limits.</div><br/><div id="42239454" class="c"><input type="checkbox" id="c-42239454" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#42239004">parent</a><span>|</span><a href="#42242118">next</a><span>|</span><label class="collapse" for="c-42239454">[-]</label><label class="expand" for="c-42239454">[2 more]</label></div><br/><div class="children"><div class="content">&gt; well defined deterministic execution model would mitigate some of these unpredictable state transitions.<p>The problem here is that giving a program access to high-resolution (non-virtualized) timers violates deterministic execution. Even without a high-resolution timer, the non-determinism inherent in shared memory parallelism can be exploited to make high-resolution timers. In short, one can use a counter thread to make a very high precision timer.<p>With high-resolution timers, the timing domain becomes both a potential covert channel and a universal side-channel to spy on other concurrent computations.</div><br/><div id="42243054" class="c"><input type="checkbox" id="c-42243054" checked=""/><div class="controls bullet"><span class="by">spaintech</span><span>|</span><a href="#42239004">root</a><span>|</span><a href="#42239454">parent</a><span>|</span><a href="#42242118">next</a><span>|</span><label class="collapse" for="c-42243054">[-]</label><label class="expand" for="c-42243054">[1 more]</label></div><br/><div class="children"><div class="content">Good point, but still, you are leaving the user with too much leverage on the underlying architecture, again from the OS’ perspective.<p>They way I’m considering this is, one could provide virtual time sources, removing the high resolution timers, where the OS has more of a coarse-grained timer. Not sure the implications, but if needed, one could add jitter or randomness ( Noise ) to the virtual timer values…<p>This would further prevent thread from running out of sync with the resto of the threads.<p>Further, one could also add a stack based shared memory model, LIFO would provide a highly predictable behavior from an application perspective. If you make it per process, the shared stack would then be confined to the application. No sure if possible ( haven given deep thought ) but the stacks could be confined to specific cache lines, removing the timing differences caused by cache contention…</div><br/></div></div></div></div></div></div><div id="42242118" class="c"><input type="checkbox" id="c-42242118" checked=""/><div class="controls bullet"><span class="by">tomcam</span><span>|</span><a href="#42239004">prev</a><span>|</span><a href="#42237934">next</a><span>|</span><label class="collapse" for="c-42242118">[-]</label><label class="expand" for="c-42242118">[2 more]</label></div><br/><div class="children"><div class="content">My career started in the early 80s. For about 30 years, I felt pretty confident that I understood all the major trends in this business. I have to admit that I didn’t even know exploits like this were possible.</div><br/><div id="42242153" class="c"><input type="checkbox" id="c-42242153" checked=""/><div class="controls bullet"><span class="by">UltraSane</span><span>|</span><a href="#42242118">parent</a><span>|</span><a href="#42237934">next</a><span>|</span><label class="collapse" for="c-42242153">[-]</label><label class="expand" for="c-42242153">[1 more]</label></div><br/><div class="children"><div class="content">I know, right! This is some serious 200IQ stuff.</div><br/></div></div></div></div><div id="42237934" class="c"><input type="checkbox" id="c-42237934" checked=""/><div class="controls bullet"><span class="by">Carrentt</span><span>|</span><a href="#42242118">prev</a><span>|</span><a href="#42239340">next</a><span>|</span><label class="collapse" for="c-42237934">[-]</label><label class="expand" for="c-42237934">[1 more]</label></div><br/><div class="children"><div class="content">Microarchitectural weird machines: where your CPU&#x27;s quirks are both the hackers&#x27; playground and the defenders&#x27; nightmare. Who knew speculative execution could be this creative?</div><br/></div></div><div id="42236631" class="c"><input type="checkbox" id="c-42236631" checked=""/><div class="controls bullet"><span class="by">yvdriess</span><span>|</span><a href="#42239340">prev</a><span>|</span><a href="#42237310">next</a><span>|</span><label class="collapse" for="c-42236631">[-]</label><label class="expand" for="c-42236631">[3 more]</label></div><br/><div class="children"><div class="content">In short, timing-attack computed?</div><br/><div id="42237859" class="c"><input type="checkbox" id="c-42237859" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#42236631">parent</a><span>|</span><a href="#42237310">next</a><span>|</span><label class="collapse" for="c-42237859">[-]</label><label class="expand" for="c-42237859">[2 more]</label></div><br/><div class="children"><div class="content">It is more complicated, but I find it hilarious people are trying to find utility in metastability problems on modern architectures.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Metastability_(electronics)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Metastability_(electronics)</a><p>Arguably, the concept is the ultimate reduction of the absurd claim &#x27;It&#x27;s Not a Bug, It&#x27;s a Feature.&#x27;<p>Seems some crowds sell the facade of repeatable correctness, rather than acknowledge their design is fundamentally an unreliable Beta. =3</div><br/><div id="42240016" class="c"><input type="checkbox" id="c-42240016" checked=""/><div class="controls bullet"><span class="by">schoen</span><span>|</span><a href="#42236631">root</a><span>|</span><a href="#42237859">parent</a><span>|</span><a href="#42237310">next</a><span>|</span><label class="collapse" for="c-42240016">[-]</label><label class="expand" for="c-42240016">[1 more]</label></div><br/><div class="children"><div class="content">This research definitely views it as a threat to the interests of the computer owners, because attackers can use it to hide malicious behavior better. It&#x27;s just that it&#x27;s cool and interesting to explore how and why. It&#x27;s not like &quot;it&#x27;s so awesome and desirable to have this behavior here&quot;.</div><br/></div></div></div></div></div></div><div id="42237310" class="c"><input type="checkbox" id="c-42237310" checked=""/><div class="controls bullet"><span class="by">ashoeafoot</span><span>|</span><a href="#42236631">prev</a><span>|</span><a href="#42236875">next</a><span>|</span><label class="collapse" for="c-42237310">[-]</label><label class="expand" for="c-42237310">[1 more]</label></div><br/><div class="children"><div class="content">So if i have a dumb pattermatcher on ram it can prefetch by looking at requested instructions and data?</div><br/></div></div><div id="42236875" class="c"><input type="checkbox" id="c-42236875" checked=""/><div class="controls bullet"><span class="by">timealyzer</span><span>|</span><a href="#42237310">prev</a><span>|</span><label class="collapse" for="c-42236875">[-]</label><label class="expand" for="c-42236875">[6 more]</label></div><br/><div class="children"><div class="content">I browsed the article but didn&#x27;t see any reference to increased power use or efficiency. Would such a proposed scheme only be used for cryptography and the remainder of the program run conventionally?</div><br/><div id="42237155" class="c"><input type="checkbox" id="c-42237155" checked=""/><div class="controls bullet"><span class="by">drcwpl</span><span>|</span><a href="#42236875">parent</a><span>|</span><label class="collapse" for="c-42237155">[-]</label><label class="expand" for="c-42237155">[5 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right to be curious about the power implications of µWMs! Unfortunately, the article doesn&#x27;t go into power consumption or efficiency specifically.  Probably because the research is still in its early stages, primarily focused on proving the concept and exploring its potential.<p>As you suggested, a hybrid approach is the most likely scenario for practical applications of µWMs. This means conventional computing for general tasks, I guess. The majority of a program would likely execute using conventional instructions and pathways, minimizing power overhead.</div><br/><div id="42238474" class="c"><input type="checkbox" id="c-42238474" checked=""/><div class="controls bullet"><span class="by">rep_lodsb</span><span>|</span><a href="#42236875">root</a><span>|</span><a href="#42237155">parent</a><span>|</span><label class="collapse" for="c-42238474">[-]</label><label class="expand" for="c-42238474">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an obfuscation technique, not a way to improve efficiency.</div><br/><div id="42240230" class="c"><input type="checkbox" id="c-42240230" checked=""/><div class="controls bullet"><span class="by">rbanffy</span><span>|</span><a href="#42236875">root</a><span>|</span><a href="#42238474">parent</a><span>|</span><label class="collapse" for="c-42240230">[-]</label><label class="expand" for="c-42240230">[3 more]</label></div><br/><div class="children"><div class="content">Now you got me curious about using processor bugs and the once popular use of invalid instructions in the Z80 and 6502 days. Do modern OSs guard against exploiting architectural misfeatures?</div><br/><div id="42240644" class="c"><input type="checkbox" id="c-42240644" checked=""/><div class="controls bullet"><span class="by">rep_lodsb</span><span>|</span><a href="#42236875">root</a><span>|</span><a href="#42240230">parent</a><span>|</span><label class="collapse" for="c-42240644">[-]</label><label class="expand" for="c-42240644">[2 more]</label></div><br/><div class="children"><div class="content">Modern processors[1] cause an exception on invalid opcodes, instead of performing some undocumented function. They also have control bits to enable&#x2F;disable features like being able to read certain &quot;system&quot; registers from userspace.<p>User code generally can&#x27;t <i>directly</i> violate security (like writing to memory in the kernel or a more privileged process) by just running some instruction, however there are timing side channels that can be used to leak information. The terms to search for are &quot;Spectre&quot; and &quot;Meltdown&quot;.<p>The timestamp counter is one of the registers that an OS can prevent software from reading, but mainstream ones still don&#x27;t do this AFAIK. Perhaps it would be better to only enable it for processes that have a legitimate reason to need a high-resolution timer.<p>And of course, x86 has accumulated enough legacy features that you could use to confuse a person reading your code, my user name is one such instruction ;)<p>[1] pretty much everything newer than the original 8086</div><br/><div id="42240773" class="c"><input type="checkbox" id="c-42240773" checked=""/><div class="controls bullet"><span class="by">rbanffy</span><span>|</span><a href="#42236875">root</a><span>|</span><a href="#42240644">parent</a><span>|</span><label class="collapse" for="c-42240773">[-]</label><label class="expand" for="c-42240773">[1 more]</label></div><br/><div class="children"><div class="content">They no longer have stable undocumented instructions like the Z80 had (the 6502 lost it on the 65C02) but they still have sizable errata published explaining what legal instructions don&#x27;t work as expected in which conditions. Also, I remember this tool: <a href="https:&#x2F;&#x2F;github.com&#x2F;Battelle&#x2F;sandsifter">https:&#x2F;&#x2F;github.com&#x2F;Battelle&#x2F;sandsifter</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>