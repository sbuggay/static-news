<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1718614868161" as="style"/><link rel="stylesheet" href="styles.css?v=1718614868161"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://people.eecs.berkeley.edu/~bh/sicp.html">Why &quot;Structure and Interpretation of Computer Programs&quot; matters (2011)</a> <span class="domain">(<a href="https://people.eecs.berkeley.edu">people.eecs.berkeley.edu</a>)</span></div><div class="subtext"><span>AlexeyBrin</span> | <span>163 comments</span></div><br/><div><div id="40703235" class="c"><input type="checkbox" id="c-40703235" checked=""/><div class="controls bullet"><span class="by">bryanrasmussen</span><span>|</span><a href="#40702866">next</a><span>|</span><label class="collapse" for="c-40703235">[-]</label><label class="expand" for="c-40703235">[1 more]</label></div><br/><div class="children"><div class="content">I always found the first half of the book a light read, an exciting read, it was as wonderful to read for me as Lord Dunsany, I sped through it.<p>When it started to get to object orientation I started having problems following. It just didn&#x27;t make sense. Maybe I should try again, but it just always made me feel that for my particular mind functional thinking was better.</div><br/></div></div><div id="40702866" class="c"><input type="checkbox" id="c-40702866" checked=""/><div class="controls bullet"><span class="by">alkonaut</span><span>|</span><a href="#40703235">prev</a><span>|</span><a href="#40703433">next</a><span>|</span><label class="collapse" for="c-40702866">[-]</label><label class="expand" for="c-40702866">[1 more]</label></div><br/><div class="children"><div class="content">I have never gotten past the first few pages. Had it ever been a mandatory class in my education, I would be working with something else today.</div><br/></div></div><div id="40703433" class="c"><input type="checkbox" id="c-40703433" checked=""/><div class="controls bullet"><span class="by">runlaszlorun</span><span>|</span><a href="#40702866">prev</a><span>|</span><a href="#40699922">next</a><span>|</span><label class="collapse" for="c-40703433">[-]</label><label class="expand" for="c-40703433">[2 more]</label></div><br/><div class="children"><div class="content">In addition to the free book online, YouTube has original lectures from the early 80’s- complete with quirky humor, super early attempts at graphics, and late 70’s fashions all around.<p>Oh,and educational too!</div><br/><div id="40703451" class="c"><input type="checkbox" id="c-40703451" checked=""/><div class="controls bullet"><span class="by">wiz21c</span><span>|</span><a href="#40703433">parent</a><span>|</span><a href="#40699922">next</a><span>|</span><label class="collapse" for="c-40703451">[-]</label><label class="expand" for="c-40703451">[1 more]</label></div><br/><div class="children"><div class="content">And the best introductory lesson ever where they explain you <i>what</i> is programming.</div><br/></div></div></div></div><div id="40699922" class="c"><input type="checkbox" id="c-40699922" checked=""/><div class="controls bullet"><span class="by">zeroCalories</span><span>|</span><a href="#40703433">prev</a><span>|</span><a href="#40701071">next</a><span>|</span><label class="collapse" for="c-40699922">[-]</label><label class="expand" for="c-40699922">[47 more]</label></div><br/><div class="children"><div class="content">I always see people gush over this book, but is it still worth reading for someone that already has a ton of experience programming?</div><br/><div id="40703663" class="c"><input type="checkbox" id="c-40703663" checked=""/><div class="controls bullet"><span class="by">constantcrying</span><span>|</span><a href="#40699922">parent</a><span>|</span><a href="#40700554">next</a><span>|</span><label class="collapse" for="c-40703663">[-]</label><label class="expand" for="c-40703663">[1 more]</label></div><br/><div class="children"><div class="content">It definitely is a &quot;classic&quot; book for a good reason.<p>I think it really depends on your actual <i>formal</i> education, how valuable this book will be to you. If you have a CS degree basically everything in there should have been covered during your studies, you already know how to operate on trees, recursive algorithms and how to build an interpreter. The main value to you would have been seeing it all come together in one place.<p>If you don&#x27;t have that kind of education I believe it is extremely valuable to see programming from a theoretical perspective. The book is very good at laying out a cohesive narrative of how you go from very basic structures to complex programs and how these programs can be executed by a computer. The highlight definitely is the implementation of lisp in lisp.<p>There were also chapters, mostly towards the end, which I think aged quite poorly and seemed mostly irrelevant. I don&#x27;t think there is much lost by skipping them.</div><br/></div></div><div id="40700554" class="c"><input type="checkbox" id="c-40700554" checked=""/><div class="controls bullet"><span class="by">sakras</span><span>|</span><a href="#40699922">parent</a><span>|</span><a href="#40703663">prev</a><span>|</span><a href="#40700145">next</a><span>|</span><label class="collapse" for="c-40700554">[-]</label><label class="expand" for="c-40700554">[10 more]</label></div><br/><div class="children"><div class="content">I started reading it around a year ago with the personal goal of doing every exercise. I&#x27;m not done yet (almost done with chapter 4). It has definitely taken a lot of my time, but it really has changed my thinking about a lot of language constructs I find in other languages.<p>For instance, the part about tagging objects with their type reshaped my thinking about static type systems in general. Static typing, for example in C, is essentially just moving the location of the type tag from existing at runtime within the struct, to the &quot;analysis&quot; phase of the compiler. It&#x27;s a pretty simple idea, but it made the &quot;degree of dynamism&quot; tradeoff click in my head. All the information _has_ to exist somewhere, and the only question is where. And Scheme is just at an extreme where the _everything_ is stored dynamically.</div><br/><div id="40702550" class="c"><input type="checkbox" id="c-40702550" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#40699922">root</a><span>|</span><a href="#40700554">parent</a><span>|</span><a href="#40700145">next</a><span>|</span><label class="collapse" for="c-40702550">[-]</label><label class="expand" for="c-40702550">[9 more]</label></div><br/><div class="children"><div class="content">&gt; Static typing, for example in C, is essentially just moving the location of the type tag from existing at runtime within the struct, to the &quot;analysis&quot; phase of the compiler.<p>See also &quot;shift left&quot;<p>&gt; All the information _has_ to exist somewhere, and the only question is where.<p>Not entirely sure what you mean about this, but not all type information has to exist somewhere. Sometimes things get encoded into a type that might never be represented otherwise -- like whether an integer is a width or a height, or whether a string is a name or an address.</div><br/><div id="40703162" class="c"><input type="checkbox" id="c-40703162" checked=""/><div class="controls bullet"><span class="by">bryanrasmussen</span><span>|</span><a href="#40699922">root</a><span>|</span><a href="#40702550">parent</a><span>|</span><a href="#40702701">next</a><span>|</span><label class="collapse" for="c-40703162">[-]</label><label class="expand" for="c-40703162">[2 more]</label></div><br/><div class="children"><div class="content">whether something (a variable) is a width or a height is encoded somewhere in the code because if the variable is a width it makes its usage different than if it is a height.<p>Then the code is written to make sure you never make the mistake of sending a width to a height, because that would be silly.<p>The type (width or height) is represented as logic in the code.<p>theoretically - if you have a type system that allows you to know something is a width or height you can often reduce logic to keep track of these things but my experience is that level of granularity in your typing reduces dynamism too much. I would rather keep track of that in code (as it probably will have to deal with it anyway) than make my type system deal with it.</div><br/><div id="40703417" class="c"><input type="checkbox" id="c-40703417" checked=""/><div class="controls bullet"><span class="by">hibikir</span><span>|</span><a href="#40699922">root</a><span>|</span><a href="#40703162">parent</a><span>|</span><a href="#40702701">next</a><span>|</span><label class="collapse" for="c-40703417">[-]</label><label class="expand" for="c-40703417">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s some cool mechanisms in type-forward languages that lead to minimal dynamism loss along with safety: For instance, you can do scientific programming that carries units along. So you really can divide a length by a time with no problems: Your results just happens to be a velocity, and will come out in meters per second (or whichever your favorite units are). Adding meters to kilometers? Congrats, you might you have to say which physical representation you want in float-land. But then you are saved from adding seconds to milliliters, because then the types will tell you it&#x27;s complete nonsense.<p>But note that to make all of that work well you really need your language to provide a lot of syntactic sugar features which are missing in most older languages, so all the operations read seamlessly, instead of being full of ceremony. One could do all of this in, say, old Java 1.4 or something, but the amount of type annotation, along with the massive mounts of boilerplate to get all of the operationg working right, and checked at compile time would make it all Not-Worth-It(tm) But with enough language features, and a smart enough compiler, `val acc =  mySpeed &#x2F; someSeconds` will work, straight up, with the safety included.</div><br/></div></div></div></div><div id="40702701" class="c"><input type="checkbox" id="c-40702701" checked=""/><div class="controls bullet"><span class="by">dehrmann</span><span>|</span><a href="#40699922">root</a><span>|</span><a href="#40702550">parent</a><span>|</span><a href="#40703162">prev</a><span>|</span><a href="#40703078">next</a><span>|</span><label class="collapse" for="c-40702701">[-]</label><label class="expand" for="c-40702701">[5 more]</label></div><br/><div class="children"><div class="content">That just means it exists in your head.</div><br/><div id="40702795" class="c"><input type="checkbox" id="c-40702795" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#40699922">root</a><span>|</span><a href="#40702701">parent</a><span>|</span><a href="#40703078">next</a><span>|</span><label class="collapse" for="c-40702795">[-]</label><label class="expand" for="c-40702795">[4 more]</label></div><br/><div class="children"><div class="content">Not really. Whether an integer represents a width or a height won&#x27;t even exist in your head if you&#x27;re implementing a function like max(a, b).</div><br/><div id="40703139" class="c"><input type="checkbox" id="c-40703139" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#40699922">root</a><span>|</span><a href="#40702795">parent</a><span>|</span><a href="#40703144">next</a><span>|</span><label class="collapse" for="c-40703139">[-]</label><label class="expand" for="c-40703139">[1 more]</label></div><br/><div class="children"><div class="content">&gt; exist in your head if you&#x27;re implementing a function like max(a, b)<p>surely, you have an idea of what you&#x27;re using that function for, while you&#x27;re writing it.<p>The compiler is doing a check to see if the function makes some minimal logical sense (ala, a typecheck), but it cannot read your mind. But this implies the types are actually an actualization of the thoughts in your head, in a formal manner.</div><br/></div></div><div id="40703144" class="c"><input type="checkbox" id="c-40703144" checked=""/><div class="controls bullet"><span class="by">lomase</span><span>|</span><a href="#40699922">root</a><span>|</span><a href="#40702795">parent</a><span>|</span><a href="#40703139">prev</a><span>|</span><a href="#40703132">next</a><span>|</span><label class="collapse" for="c-40703144">[-]</label><label class="expand" for="c-40703144">[1 more]</label></div><br/><div class="children"><div class="content">The type is encoded in the name of the function.<p>Is a pretty bad system because you say &quot;won&#x27;t even exist in your head&quot; but I dont even know if I should pass it integers, floats a srtring. Or what it will return.</div><br/></div></div><div id="40703132" class="c"><input type="checkbox" id="c-40703132" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#40699922">root</a><span>|</span><a href="#40702795">parent</a><span>|</span><a href="#40703144">prev</a><span>|</span><a href="#40703078">next</a><span>|</span><label class="collapse" for="c-40703132">[-]</label><label class="expand" for="c-40703132">[1 more]</label></div><br/><div class="children"><div class="content">Because <i>inside</i> the abstraction max it doesn&#x27;t represent a width or height, they are just numbers (or just some &quot;comparable things&quot;). But outside the abstraction, at some level, you&#x27;ll definitely know what a and b are.</div><br/></div></div></div></div></div></div><div id="40703078" class="c"><input type="checkbox" id="c-40703078" checked=""/><div class="controls bullet"><span class="by">port19</span><span>|</span><a href="#40699922">root</a><span>|</span><a href="#40702550">parent</a><span>|</span><a href="#40702701">prev</a><span>|</span><a href="#40700145">next</a><span>|</span><label class="collapse" for="c-40703078">[-]</label><label class="expand" for="c-40703078">[1 more]</label></div><br/><div class="children"><div class="content">At the extreme end, and with no claims of scalability, you have shell: everything is a string.<p>I&#x27;m skeptical that sophisticated type systems <i>need</i> to exist.<p>Perhaps I should dust off my copy and start reading SICP</div><br/></div></div></div></div></div></div><div id="40700145" class="c"><input type="checkbox" id="c-40700145" checked=""/><div class="controls bullet"><span class="by">Maxatar</span><span>|</span><a href="#40699922">parent</a><span>|</span><a href="#40700554">prev</a><span>|</span><a href="#40703055">next</a><span>|</span><label class="collapse" for="c-40700145">[-]</label><label class="expand" for="c-40700145">[1 more]</label></div><br/><div class="children"><div class="content">Experience in software development isn&#x27;t linear so depending on which path your experience has taken it could be very insightful and useful, or it could be stuff you already know.<p>I&#x27;d say for the vast majority of developers, experienced or otherwise, it&#x27;s a good read.</div><br/></div></div><div id="40703055" class="c"><input type="checkbox" id="c-40703055" checked=""/><div class="controls bullet"><span class="by">zelphirkalt</span><span>|</span><a href="#40699922">parent</a><span>|</span><a href="#40700145">prev</a><span>|</span><a href="#40700747">next</a><span>|</span><label class="collapse" for="c-40703055">[-]</label><label class="expand" for="c-40703055">[2 more]</label></div><br/><div class="children"><div class="content">That depends entirely on what kind of a ton of experience you have. If you have written Java&#x2F;PHP&#x2F;Python&#x2F;JS for 20 years, SICP might teach you lots of new tricks. If you have worked a lot with functional languages, probably fewer, but still probably some in later parts of the book.</div><br/><div id="40703204" class="c"><input type="checkbox" id="c-40703204" checked=""/><div class="controls bullet"><span class="by">llm_trw</span><span>|</span><a href="#40699922">root</a><span>|</span><a href="#40703055">parent</a><span>|</span><a href="#40700747">next</a><span>|</span><label class="collapse" for="c-40703204">[-]</label><label class="expand" for="c-40703204">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d worked exclusively with functional languages and assignment operators implemented as lambdas blew my mind more so than all the monads in Haskell.</div><br/></div></div></div></div><div id="40700747" class="c"><input type="checkbox" id="c-40700747" checked=""/><div class="controls bullet"><span class="by">PheonixPharts</span><span>|</span><a href="#40699922">parent</a><span>|</span><a href="#40703055">prev</a><span>|</span><a href="#40702946">next</a><span>|</span><label class="collapse" for="c-40700747">[-]</label><label class="expand" for="c-40700747">[9 more]</label></div><br/><div class="children"><div class="content">&quot;Don&#x27;t cast your pearls before swine&quot;.<p>When I was younger I used to passionately defend those things I&#x27;ve seen as beautiful, but after years experience talking with people passionate about their fields and learning and those who never will be: If you lack the innate curiosity to explore those things others have declared marvelous, then this book will offer you no value.<p>Every time I crack this book open I get excited and I&#x27;ve read it multiple time and one most of the exercises. I can think of few other books that really expose the beauty and simultaneously strong engineering foundations of software.<p>You have &quot;tons of experience programming&quot; and sound like you&#x27;ve already decided you know what needs to be known (otherwise why even ask rather than just read it <i>free</i> online), I doubt this will offer you anything you haven&#x27;t already seen before.</div><br/><div id="40701225" class="c"><input type="checkbox" id="c-40701225" checked=""/><div class="controls bullet"><span class="by">shagie</span><span>|</span><a href="#40699922">root</a><span>|</span><a href="#40700747">parent</a><span>|</span><a href="#40702718">next</a><span>|</span><label class="collapse" for="c-40701225">[-]</label><label class="expand" for="c-40701225">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If you lack the innate curiosity to explore those things others have declared marvelous, then this book will offer you no value.<p>&gt; Every time I crack this book open I get excited and I&#x27;ve read it multiple time and one most of the exercises. I can think of few other books that really expose the beauty and simultaneously strong engineering foundations of software.<p>---<p><a href="https:&#x2F;&#x2F;www.stilldrinking.org&#x2F;programming-sucks" rel="nofollow">https:&#x2F;&#x2F;www.stilldrinking.org&#x2F;programming-sucks</a> ( <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=7667825">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=7667825</a> and others)<p>&gt; Every programmer occasionally, when nobody’s home, turns off the lights, pours a glass of scotch, puts on some light German electronica, and opens up a file on their computer. It’s a different file for every programmer. Sometimes they wrote it, sometimes they found it and knew they had to save it. They read over the lines, and weep at their beauty, then the tears turn bitter as they remember the rest of the files and the inevitable collapse of all that is good and true in the world.<p>I recommend (not ironically) Double Binded Sax by the group named Software.</div><br/><div id="40702798" class="c"><input type="checkbox" id="c-40702798" checked=""/><div class="controls bullet"><span class="by">ramenbytes</span><span>|</span><a href="#40699922">root</a><span>|</span><a href="#40701225">parent</a><span>|</span><a href="#40702718">next</a><span>|</span><label class="collapse" for="c-40702798">[-]</label><label class="expand" for="c-40702798">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I recommend (not ironically) Double Binded Sax by the group named Software.<p>After you finish that, I recommend queuing up Friedrich Nietzsche by Klaus Schulze.</div><br/></div></div></div></div><div id="40702718" class="c"><input type="checkbox" id="c-40702718" checked=""/><div class="controls bullet"><span class="by">dehrmann</span><span>|</span><a href="#40699922">root</a><span>|</span><a href="#40700747">parent</a><span>|</span><a href="#40701225">prev</a><span>|</span><a href="#40702709">next</a><span>|</span><label class="collapse" for="c-40702718">[-]</label><label class="expand" for="c-40702718">[3 more]</label></div><br/><div class="children"><div class="content">&gt; otherwise why even ask rather than just read it free online<p>Not GP, but my time is limited, so asking &quot;is this something an experienced programmer would find worthwhile and insightful&quot; is a fair question.</div><br/><div id="40703041" class="c"><input type="checkbox" id="c-40703041" checked=""/><div class="controls bullet"><span class="by">djtango</span><span>|</span><a href="#40699922">root</a><span>|</span><a href="#40702718">parent</a><span>|</span><a href="#40703109">next</a><span>|</span><label class="collapse" for="c-40703041">[-]</label><label class="expand" for="c-40703041">[1 more]</label></div><br/><div class="children"><div class="content">To be honest I&#x27;d recommend just taking a look. It&#x27;s been 10 years since I first encountered the book (and programming) and I&#x27;m sure the lessons can be found elsewhere.<p>But I find the book a marvel of pedagogy and rank it as maybe one of the greatest textbooks of all time across disciplines. The lessons are packed so densely yet so concisely that you&#x27;ll appreciate different things on successive reads.<p>If you&#x27;re experienced it will also read very easily and quickly so it then becomes quite an easy and enjoyable skim and then you don&#x27;t have to rely on other people&#x27;s accounts of whether it is or isn&#x27;t worth your time.</div><br/></div></div></div></div><div id="40702709" class="c"><input type="checkbox" id="c-40702709" checked=""/><div class="controls bullet"><span class="by">toonalfrink</span><span>|</span><a href="#40699922">root</a><span>|</span><a href="#40700747">parent</a><span>|</span><a href="#40702718">prev</a><span>|</span><a href="#40701124">next</a><span>|</span><label class="collapse" for="c-40702709">[-]</label><label class="expand" for="c-40702709">[2 more]</label></div><br/><div class="children"><div class="content">Might find it beautiful, but I&#x27;m also just f&#x27;in busy. Why do you think that if I enjoyed it I would&#x27;ve already done it? Enjoying things is great but it&#x27;s not my main desideratum for doing something</div><br/><div id="40703208" class="c"><input type="checkbox" id="c-40703208" checked=""/><div class="controls bullet"><span class="by">llm_trw</span><span>|</span><a href="#40699922">root</a><span>|</span><a href="#40702709">parent</a><span>|</span><a href="#40701124">next</a><span>|</span><label class="collapse" for="c-40703208">[-]</label><label class="expand" for="c-40703208">[1 more]</label></div><br/><div class="children"><div class="content">Then it&#x27;s not for you and you can do something else, like commenting about why you should read it.</div><br/></div></div></div></div><div id="40701124" class="c"><input type="checkbox" id="c-40701124" checked=""/><div class="controls bullet"><span class="by">daggerdrone</span><span>|</span><a href="#40699922">root</a><span>|</span><a href="#40700747">parent</a><span>|</span><a href="#40702709">prev</a><span>|</span><a href="#40702946">next</a><span>|</span><label class="collapse" for="c-40701124">[-]</label><label class="expand" for="c-40701124">[1 more]</label></div><br/><div class="children"><div class="content">| I can think of few other books
I’m interested to know which books …</div><br/></div></div></div></div><div id="40702946" class="c"><input type="checkbox" id="c-40702946" checked=""/><div class="controls bullet"><span class="by">bazoom42</span><span>|</span><a href="#40699922">parent</a><span>|</span><a href="#40700747">prev</a><span>|</span><a href="#40703406">next</a><span>|</span><label class="collapse" for="c-40702946">[-]</label><label class="expand" for="c-40702946">[1 more]</label></div><br/><div class="children"><div class="content">Depends on the kinds of experience. If you have experience writing compilers and interpreters - probably not a lot. If your experience is in application development you might learn a lot.<p>I worked through it after years of practical experience as a self-thought programmer, and I learnt a lot (and found it quite challenging, especially the mathy parts).</div><br/></div></div><div id="40703406" class="c"><input type="checkbox" id="c-40703406" checked=""/><div class="controls bullet"><span class="by">runlaszlorun</span><span>|</span><a href="#40699922">parent</a><span>|</span><a href="#40702946">prev</a><span>|</span><a href="#40700441">next</a><span>|</span><label class="collapse" for="c-40703406">[-]</label><label class="expand" for="c-40703406">[1 more]</label></div><br/><div class="children"><div class="content">I’d personally say especially so. I’m guessing those taking it as freshman are missing out on 75% of the good stuff.<p>It’s free online. And YouTube has lectures from the authors- presented in all their early 80’s glory.</div><br/></div></div><div id="40700441" class="c"><input type="checkbox" id="c-40700441" checked=""/><div class="controls bullet"><span class="by">omnicognate</span><span>|</span><a href="#40699922">parent</a><span>|</span><a href="#40703406">prev</a><span>|</span><a href="#40700254">next</a><span>|</span><label class="collapse" for="c-40700441">[-]</label><label class="expand" for="c-40700441">[1 more]</label></div><br/><div class="children"><div class="content">Whether it&#x27;s worth reading isn&#x27;t a question others can answer for you, but &quot;a ton of experience programming&quot; definitely doesn&#x27;t imply it <i>isn&#x27;t</i> worth reading as it&#x27;s perfectly possible to get through an entire programming career without encountering the ideas and ways of thinking that you&#x27;ll find in it.</div><br/></div></div><div id="40700254" class="c"><input type="checkbox" id="c-40700254" checked=""/><div class="controls bullet"><span class="by">CuriousSkeptic</span><span>|</span><a href="#40699922">parent</a><span>|</span><a href="#40700441">prev</a><span>|</span><a href="#40701737">next</a><span>|</span><label class="collapse" for="c-40700254">[-]</label><label class="expand" for="c-40700254">[1 more]</label></div><br/><div class="children"><div class="content">Haven&#x27;t actually done the book. Can vouch for the lectures[1] though. Very much worth it to get a different perspective on various language structures I had just taken for granted.<p>Watching 2-3 of these will probably answer your question.<p>[1] <a href="https:&#x2F;&#x2F;groups.csail.mit.edu&#x2F;mac&#x2F;classes&#x2F;6.001&#x2F;abelson-sussman-lectures&#x2F;" rel="nofollow">https:&#x2F;&#x2F;groups.csail.mit.edu&#x2F;mac&#x2F;classes&#x2F;6.001&#x2F;abelson-sussm...</a></div><br/></div></div><div id="40701737" class="c"><input type="checkbox" id="c-40701737" checked=""/><div class="controls bullet"><span class="by">egl2021</span><span>|</span><a href="#40699922">parent</a><span>|</span><a href="#40700254">prev</a><span>|</span><a href="#40700367">next</a><span>|</span><label class="collapse" for="c-40701737">[-]</label><label class="expand" for="c-40701737">[1 more]</label></div><br/><div class="children"><div class="content">Depends on what you learned during that &quot;ton of experience programming.&quot;  My only regret was that I had, but stupidly ignored, the MIT course notes that preceded publication of SICP. I didn&#x27;t realize what I had missed until many years later when I sat down to work my way through SICP. I coulda been a contender.</div><br/></div></div><div id="40700367" class="c"><input type="checkbox" id="c-40700367" checked=""/><div class="controls bullet"><span class="by">kikimora</span><span>|</span><a href="#40699922">parent</a><span>|</span><a href="#40701737">prev</a><span>|</span><a href="#40702245">next</a><span>|</span><label class="collapse" for="c-40700367">[-]</label><label class="expand" for="c-40700367">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I bet it will give you new perspective on a number of things.</div><br/></div></div><div id="40702245" class="c"><input type="checkbox" id="c-40702245" checked=""/><div class="controls bullet"><span class="by">barrell</span><span>|</span><a href="#40699922">parent</a><span>|</span><a href="#40700367">prev</a><span>|</span><a href="#40701226">next</a><span>|</span><label class="collapse" for="c-40702245">[-]</label><label class="expand" for="c-40702245">[1 more]</label></div><br/><div class="children"><div class="content">Only if you’re comfortable being converted to lisp</div><br/></div></div><div id="40701226" class="c"><input type="checkbox" id="c-40701226" checked=""/><div class="controls bullet"><span class="by">dswilkerson</span><span>|</span><a href="#40699922">parent</a><span>|</span><a href="#40702245">prev</a><span>|</span><a href="#40699959">next</a><span>|</span><label class="collapse" for="c-40701226">[-]</label><label class="expand" for="c-40701226">[1 more]</label></div><br/><div class="children"><div class="content">No.  If you want a deeper understanding of programming, write your own static analysis &#x2F; theorem prover.</div><br/></div></div><div id="40699959" class="c"><input type="checkbox" id="c-40699959" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#40699922">parent</a><span>|</span><a href="#40701226">prev</a><span>|</span><a href="#40700102">next</a><span>|</span><label class="collapse" for="c-40699959">[-]</label><label class="expand" for="c-40699959">[13 more]</label></div><br/><div class="children"><div class="content">Yes. But instead of taking my word for it why don’t you just start reading it and decide for yourself?</div><br/><div id="40700392" class="c"><input type="checkbox" id="c-40700392" checked=""/><div class="controls bullet"><span class="by">vsuperpower2020</span><span>|</span><a href="#40699922">root</a><span>|</span><a href="#40699959">parent</a><span>|</span><a href="#40700102">next</a><span>|</span><label class="collapse" for="c-40700392">[-]</label><label class="expand" for="c-40700392">[12 more]</label></div><br/><div class="children"><div class="content">Do you really need this explained? It&#x27;s a 600 page technical book and people have a limited amount of time to sort through everything that exists.</div><br/><div id="40703560" class="c"><input type="checkbox" id="c-40703560" checked=""/><div class="controls bullet"><span class="by">BodyCulture</span><span>|</span><a href="#40699922">root</a><span>|</span><a href="#40700392">parent</a><span>|</span><a href="#40700659">next</a><span>|</span><label class="collapse" for="c-40703560">[-]</label><label class="expand" for="c-40703560">[1 more]</label></div><br/><div class="children"><div class="content">Do not waste your time and energy relying on the opinion of others. Always check yourself.</div><br/></div></div><div id="40700659" class="c"><input type="checkbox" id="c-40700659" checked=""/><div class="controls bullet"><span class="by">lopatin</span><span>|</span><a href="#40699922">root</a><span>|</span><a href="#40700392">parent</a><span>|</span><a href="#40703560">prev</a><span>|</span><a href="#40700421">next</a><span>|</span><label class="collapse" for="c-40700659">[-]</label><label class="expand" for="c-40700659">[2 more]</label></div><br/><div class="children"><div class="content">Agree but you are replying to a user named &quot;lisper&quot;.</div><br/><div id="40700798" class="c"><input type="checkbox" id="c-40700798" checked=""/><div class="controls bullet"><span class="by">CoastalCoder</span><span>|</span><a href="#40699922">root</a><span>|</span><a href="#40700659">parent</a><span>|</span><a href="#40700421">next</a><span>|</span><label class="collapse" for="c-40700798">[-]</label><label class="expand" for="c-40700798">[1 more]</label></div><br/><div class="children"><div class="content">Maybe he struggles with a speech impediment, you insensitive clod!<p>&lt;&#x2F;Slashdot_nostalgia&gt;</div><br/></div></div></div></div><div id="40700421" class="c"><input type="checkbox" id="c-40700421" checked=""/><div class="controls bullet"><span class="by">exe34</span><span>|</span><a href="#40699922">root</a><span>|</span><a href="#40700392">parent</a><span>|</span><a href="#40700659">prev</a><span>|</span><a href="#40700763">next</a><span>|</span><label class="collapse" for="c-40700421">[-]</label><label class="expand" for="c-40700421">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s a 600 page technical book<p>&gt; why don’t you just start reading it and decide for yourself?<p>A journey of a thousand miles....</div><br/></div></div><div id="40700763" class="c"><input type="checkbox" id="c-40700763" checked=""/><div class="controls bullet"><span class="by">Turing_Machine</span><span>|</span><a href="#40699922">root</a><span>|</span><a href="#40700392">parent</a><span>|</span><a href="#40700421">prev</a><span>|</span><a href="#40700102">next</a><span>|</span><label class="collapse" for="c-40700763">[-]</label><label class="expand" for="c-40700763">[7 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s a 600 page technical book<p>You do understand that you don&#x27;t have to read an entire book before forming an opinion, right?<p>&gt;  sort through everything that exists<p>&quot;Book that has been considered a classic for forty years and was used as the intro text at MIT for decades&quot; is a long, long way from &quot;everything that exists&quot;.</div><br/><div id="40701018" class="c"><input type="checkbox" id="c-40701018" checked=""/><div class="controls bullet"><span class="by">zeroCalories</span><span>|</span><a href="#40699922">root</a><span>|</span><a href="#40700763">parent</a><span>|</span><a href="#40700956">next</a><span>|</span><label class="collapse" for="c-40701018">[-]</label><label class="expand" for="c-40701018">[5 more]</label></div><br/><div class="children"><div class="content">I did begin reading it a few years ago, and it seemed like a lisp flavored intro CS book. Why do I want to read an intro CS book? I&#x27;ve read those before. Yet people promise me that this one is different, while giving me nothing but condescending promises of enlightenment.</div><br/><div id="40702144" class="c"><input type="checkbox" id="c-40702144" checked=""/><div class="controls bullet"><span class="by">BoiledCabbage</span><span>|</span><a href="#40699922">root</a><span>|</span><a href="#40701018">parent</a><span>|</span><a href="#40702592">next</a><span>|</span><label class="collapse" for="c-40702144">[-]</label><label class="expand" for="c-40702144">[2 more]</label></div><br/><div class="children"><div class="content">I guess the honest question is &quot;what are you looking for in a response to your question?&quot;<p>You asked if you should read it, and almost everyone who bothered to reply has said yes. Each time this topic comes up and people ask if they should read it the majority of responses are &#x27;yes&#x27;. And I presume if you&#x27;ve been around software for that long, you&#x27;ve seen all of those threads and previous questions and answers like I have - meaning you likely knew what people would say when they responded.<p>So, in the end, it&#x27;s up to you to decide if you&#x27;ll read it or not.<p>I don&#x27;t know you personally, but from my life experience it sounds to me like something I&#x27;ve seen in other circumstances. You&#x27;ve more or less decided that you&#x27;re not going to read it, but feel like you&#x27;re missing out and you want someone who as read it to say &quot;it&#x27;s ok to not read it&quot;. So you can resolve both the feelings of the decision to not read it, and the uncomfortableness of feeling like you&#x27;re missing out.<p>It&#x27;s possible I&#x27;m way off the mark on the above, but I mean it to be helpful - as I can say I&#x27;ve seen what looks to be this same pattern many times in life.<p>or what you&#x27;re likely looking for: <i>In the end, there are only so many hours in the day. You gave it a fair shot and it wasn&#x27;t your vibe. It doesn&#x27;t say anything about your strength as an engineer, it just has a specific approach and it&#x27;s not a match for everyone. That doesn&#x27;t make it a bad thing, it just means you&#x27;d rather spend your time learning and exploring in other ways. And it probably would&#x27;ve had more impact earlier in your career than at the level of experience you have now.</i><p>But of course before wrapping up I do need to undo my comment: <i>I think you should give it another go. Maybe skim past the early part if it feels a bit to introductory and come back to it later. But it&#x27;s a book that continues to grows on you the more time it&#x27;s been since you read it. The concepts it presents are subtle but impactful in changing how you think about software. You don&#x27;t fully grasp it when you read it. It&#x27;s just that afterwards you just start seeing things through its lens often. I haven&#x27;t read any other book like it.</i></div><br/><div id="40702677" class="c"><input type="checkbox" id="c-40702677" checked=""/><div class="controls bullet"><span class="by">im3w1l</span><span>|</span><a href="#40699922">root</a><span>|</span><a href="#40702144">parent</a><span>|</span><a href="#40702592">next</a><span>|</span><label class="collapse" for="c-40702677">[-]</label><label class="expand" for="c-40702677">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s clear he wants <i>arguments</i> whose strength he can then evaluate, not just a yes&#x2F;no answer.</div><br/></div></div></div></div><div id="40702592" class="c"><input type="checkbox" id="c-40702592" checked=""/><div class="controls bullet"><span class="by">turndown</span><span>|</span><a href="#40699922">root</a><span>|</span><a href="#40701018">parent</a><span>|</span><a href="#40702144">prev</a><span>|</span><a href="#40701993">next</a><span>|</span><label class="collapse" for="c-40702592">[-]</label><label class="expand" for="c-40702592">[1 more]</label></div><br/><div class="children"><div class="content">If you are experienced then I’d say skim whatever sounds interesting from chapters 1-3, then do chapters 4&#x2F;5 as they contain most of the interesting stuff.</div><br/></div></div><div id="40701993" class="c"><input type="checkbox" id="c-40701993" checked=""/><div class="controls bullet"><span class="by">ozim</span><span>|</span><a href="#40699922">root</a><span>|</span><a href="#40701018">parent</a><span>|</span><a href="#40702592">prev</a><span>|</span><a href="#40700956">next</a><span>|</span><label class="collapse" for="c-40701993">[-]</label><label class="expand" for="c-40701993">[1 more]</label></div><br/><div class="children"><div class="content">Maybe not for you, but there is bunch of expert beginners out there that would benefit from reading up intro CS stuff.</div><br/></div></div></div></div><div id="40700956" class="c"><input type="checkbox" id="c-40700956" checked=""/><div class="controls bullet"><span class="by">vsuperpower2020</span><span>|</span><a href="#40699922">root</a><span>|</span><a href="#40700763">parent</a><span>|</span><a href="#40701018">prev</a><span>|</span><a href="#40700102">next</a><span>|</span><label class="collapse" for="c-40700956">[-]</label><label class="expand" for="c-40700956">[1 more]</label></div><br/><div class="children"><div class="content">Weasel words. Considered a classic by who? And why would being an &quot;intro text at MIT&quot; mean it&#x27;s good for someone who is already experienced? If anything, that should show it&#x27;s not worth his time.</div><br/></div></div></div></div></div></div></div></div><div id="40700102" class="c"><input type="checkbox" id="c-40700102" checked=""/><div class="controls bullet"><span class="by">bowsamic</span><span>|</span><a href="#40699922">parent</a><span>|</span><a href="#40699959">prev</a><span>|</span><a href="#40701071">next</a><span>|</span><label class="collapse" for="c-40700102">[-]</label><label class="expand" for="c-40700102">[2 more]</label></div><br/><div class="children"><div class="content">No</div><br/><div id="40700379" class="c"><input type="checkbox" id="c-40700379" checked=""/><div class="controls bullet"><span class="by">theshaper</span><span>|</span><a href="#40699922">root</a><span>|</span><a href="#40700102">parent</a><span>|</span><a href="#40701071">next</a><span>|</span><label class="collapse" for="c-40700379">[-]</label><label class="expand" for="c-40700379">[1 more]</label></div><br/><div class="children"><div class="content">Because...</div><br/></div></div></div></div></div></div><div id="40701071" class="c"><input type="checkbox" id="c-40701071" checked=""/><div class="controls bullet"><span class="by">Ozzie_osman</span><span>|</span><a href="#40699922">prev</a><span>|</span><a href="#40703302">next</a><span>|</span><label class="collapse" for="c-40701071">[-]</label><label class="expand" for="c-40701071">[2 more]</label></div><br/><div class="children"><div class="content">And here i thought the goal of SICP was to scare off folks who were getting into CS because it was trendy rather than because they enjoyed it...<p>Seriously, it was a really valuable foundational course. But 100% it scared some folks to other majors.</div><br/><div id="40701383" class="c"><input type="checkbox" id="c-40701383" checked=""/><div class="controls bullet"><span class="by">gsbcbdjfncnjd</span><span>|</span><a href="#40701071">parent</a><span>|</span><a href="#40703302">next</a><span>|</span><label class="collapse" for="c-40701383">[-]</label><label class="expand" for="c-40701383">[1 more]</label></div><br/><div class="children"><div class="content">With a 50% fail rate, I think the standard course load does a very good job of that anyway.</div><br/></div></div></div></div><div id="40703302" class="c"><input type="checkbox" id="c-40703302" checked=""/><div class="controls bullet"><span class="by">lycopodiopsida</span><span>|</span><a href="#40701071">prev</a><span>|</span><a href="#40700691">next</a><span>|</span><label class="collapse" for="c-40703302">[-]</label><label class="expand" for="c-40703302">[1 more]</label></div><br/><div class="children"><div class="content">Can someone compare it to PAIP?
I assume SICP handles functional programming ans CS basics and PAIP is more about programming practice in general?</div><br/></div></div><div id="40700691" class="c"><input type="checkbox" id="c-40700691" checked=""/><div class="controls bullet"><span class="by">dswilkerson</span><span>|</span><a href="#40703302">prev</a><span>|</span><a href="#40699913">next</a><span>|</span><label class="collapse" for="c-40700691">[-]</label><label class="expand" for="c-40700691">[10 more]</label></div><br/><div class="children"><div class="content">I used to be a teaching assistant for CS 61A (intro to programming) at Berkeley teaching from this book with Brian as the instructor.<p>One of Brian&#x27;s primary points is the following:<p>&gt; Scheme ... has a very simple, uniform notation for everything. Other languages have one notation for variable assignment, another notation for conditional execution, two or three more for looping, and yet another for function calls. Courses that teach those languages spend at least half their time just on learning the notation. In my SICP-based course at Berkeley, we spend the first hour on notation and that&#x27;s all we need; for the rest of the semester we&#x27;re learning ideas, not syntax.<p>Bullshit.  Again, I was a TA for this course.  You do not spend the rest of the semester on ideas, you spend the rest of the semester on the students being very confused.<p>This &quot;everything looks the same&quot; property of Scheme and of all LISP-like languages is a bug, not a feature.  When the semantics is different, humans need the syntax to be different.  In contrast, LISP&#x2F;Scheme make everything look the same.  It is quite hard to even tell a noun from a verb.  This makes learning it and teaching it hard, not easy.<p>Brian is selling a fantasy here.  If you think Scheme is so great, look at this nightmare of examples showing the various ways to implement the factorial function in Scheme: <a href="https:&#x2F;&#x2F;erkin.party&#x2F;blog&#x2F;200715&#x2F;evolution&#x2F;" rel="nofollow">https:&#x2F;&#x2F;erkin.party&#x2F;blog&#x2F;200715&#x2F;evolution&#x2F;</a><p>All of this &quot;abstractions first, reality second&quot; agenda is just a special case of what I call &quot;The Pathology of the Modern&quot;: the pathological worship of the abstract over the concrete.  Everything modernism touches turns into shit.  I am done with living in modernist shit and I hope you are too.</div><br/><div id="40702717" class="c"><input type="checkbox" id="c-40702717" checked=""/><div class="controls bullet"><span class="by">aag</span><span>|</span><a href="#40700691">parent</a><span>|</span><a href="#40701356">next</a><span>|</span><label class="collapse" for="c-40702717">[-]</label><label class="expand" for="c-40702717">[1 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t have spoken up except for this comment.  As a freshman, I took 6.001, the MIT course that Structure and Interpretation of Computer Programs was based on, and I loved it.  As a graduate student, I taught 6.001 three times, twice as head TA under Prof. Sussman and once under Prof. Abelson.  In addition to helping make up problem sets, quizzes, and exams, my responsibilities included teaching seven or eight one-hour, five-student tutorial sessions per week as well as teaching a forty-student recitation section once per semester.  I graded assignments as well.  My point is that I have a lot of experience with what students found challenging in the course.<p>Prof. Harvey&#x27;s claim rings completely true to me.  Students understood the syntax quickly, and spent little time on it.  It was not a point of frequent confusion.  There were plenty of difficult concepts in the course, but the details of the programming language were not, for most students, among them.<p>Students who already had programming experience when they started the course often had more trouble than inexperienced students, but mostly because they had to unlearn imperative habits since the imperative features of the language, except for I&#x2F;O, weren&#x27;t used until late in the course.<p>SICP covers a huge breadth of material, from basic computational ideas to algorithms and data structures to interpreters and compilers to query languages to concurrency, and does it in an entertaining and challenging way.  Even decades later, I find myself pulling ideas from it in my daily programming work.<p>I worked at Google for almost twelve years, and I can&#x27;t count the times I found myself muttering, when reading a design document, &quot;I wish this person had read SICP.&quot;<p>I&#x27;m certainly biased, but I would encourage anyone who would like to become a better software engineer to read SICP and study it carefully.  Take your time with it, but do read it.</div><br/></div></div><div id="40701356" class="c"><input type="checkbox" id="c-40701356" checked=""/><div class="controls bullet"><span class="by">bonyen</span><span>|</span><a href="#40700691">parent</a><span>|</span><a href="#40702717">prev</a><span>|</span><a href="#40702045">next</a><span>|</span><label class="collapse" for="c-40701356">[-]</label><label class="expand" for="c-40701356">[1 more]</label></div><br/><div class="children"><div class="content">Upvoted for an interesting take, even though I disagree with some of it.<p>I took 61A from bh. Personally, I agree with bh&#x27;s statement that you quoted. Where I encountered difficulty was applying the ideas in a different context (e.g. C or Java). Brian spent time addressing this precise difficulty (in the last lecture or so), but it still wasn&#x27;t enough for me.<p>I do heartily agree with you calling out &quot;the pathological worship of the abstract over the concrete&quot;. Knuth&#x27;s Concrete Mathematics was also bucking this trend (e.g. <a href="https:&#x2F;&#x2F;youtu.be&#x2F;GmpxxC5tBck?si=tRHQmuA4a-Hapogq&amp;t=78" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;GmpxxC5tBck?si=tRHQmuA4a-Hapogq&amp;t=78</a>). I&#x27;m curious, once you came to this opinion&#x2F;realization, how did your teaching&#x2F;learning change?</div><br/></div></div><div id="40702045" class="c"><input type="checkbox" id="c-40702045" checked=""/><div class="controls bullet"><span class="by">ksd482</span><span>|</span><a href="#40700691">parent</a><span>|</span><a href="#40701356">prev</a><span>|</span><a href="#40702131">next</a><span>|</span><label class="collapse" for="c-40702045">[-]</label><label class="expand" for="c-40702045">[1 more]</label></div><br/><div class="children"><div class="content">Just an anecdote.<p>I took CS61A by Brian Harvey in 2009. I loved the course and I actually spent very little time learning the syntax and most of the time learning the concepts.<p>So I fully agree with Prof. Brian Harvey here.</div><br/></div></div><div id="40702131" class="c"><input type="checkbox" id="c-40702131" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#40700691">parent</a><span>|</span><a href="#40702045">prev</a><span>|</span><a href="#40702015">next</a><span>|</span><label class="collapse" for="c-40702131">[-]</label><label class="expand" for="c-40702131">[1 more]</label></div><br/><div class="children"><div class="content">Does it beat OO Java classes with students crying ? or months spent on warning kids not to mutate an iterator or else you&#x27;re gonna cry again ?<p>Mostly kidding but different paradigms bear different pain points it seems.<p>Oh and lastly, the let-us-care-not-about-syntax is also an argument at Brown edu (krishnamurti and his team IIRC)<p>That said, I&#x27;d be curious to hear what your students had to say about scheme confusing traits.</div><br/></div></div><div id="40702015" class="c"><input type="checkbox" id="c-40702015" checked=""/><div class="controls bullet"><span class="by">cageface</span><span>|</span><a href="#40700691">parent</a><span>|</span><a href="#40702131">prev</a><span>|</span><a href="#40700783">next</a><span>|</span><label class="collapse" for="c-40702015">[-]</label><label class="expand" for="c-40702015">[1 more]</label></div><br/><div class="children"><div class="content">You could also portray this as yet another case of theory trumping practice, which is also symptomatic of modernism.<p>The idea that a language based on a small, elegant set of composable primitives is inherently better for programming in the large as well has not been borne out in practice.</div><br/></div></div><div id="40700783" class="c"><input type="checkbox" id="c-40700783" checked=""/><div class="controls bullet"><span class="by">Turing_Machine</span><span>|</span><a href="#40700691">parent</a><span>|</span><a href="#40702015">prev</a><span>|</span><a href="#40699913">next</a><span>|</span><label class="collapse" for="c-40700783">[-]</label><label class="expand" for="c-40700783">[4 more]</label></div><br/><div class="children"><div class="content">&gt; It is quite hard to even tell a noun from a verb<p>What?<p>Unless the list is quoted or something, the first item after the opening paren is always the &quot;verb&quot;, yes?</div><br/><div id="40701042" class="c"><input type="checkbox" id="c-40701042" checked=""/><div class="controls bullet"><span class="by">troad</span><span>|</span><a href="#40700691">root</a><span>|</span><a href="#40700783">parent</a><span>|</span><a href="#40699913">next</a><span>|</span><label class="collapse" for="c-40701042">[-]</label><label class="expand" for="c-40701042">[3 more]</label></div><br/><div class="children"><div class="content">There&#x27;s nothing stopping any other item from being a verb, no? (Not <i>the</i> verb, but <i>a</i> verb.) Anything involving higher order functions?</div><br/><div id="40702253" class="c"><input type="checkbox" id="c-40702253" checked=""/><div class="controls bullet"><span class="by">skydhash</span><span>|</span><a href="#40700691">root</a><span>|</span><a href="#40701042">parent</a><span>|</span><a href="#40699913">next</a><span>|</span><label class="collapse" for="c-40702253">[-]</label><label class="expand" for="c-40702253">[2 more]</label></div><br/><div class="children"><div class="content">In the context of <i>the</i> verb, everything else is a noun. When you understand what <i>the</i> verb does, then you can care about the difference between <i>a</i> verb and <i>a</i> noun.</div><br/><div id="40702331" class="c"><input type="checkbox" id="c-40702331" checked=""/><div class="controls bullet"><span class="by">troad</span><span>|</span><a href="#40700691">root</a><span>|</span><a href="#40702253">parent</a><span>|</span><a href="#40699913">next</a><span>|</span><label class="collapse" for="c-40702331">[-]</label><label class="expand" for="c-40702331">[1 more]</label></div><br/><div class="children"><div class="content">Certainly, but the original quote was &quot;It is quite hard to even tell <i>a</i> noun from <i>a</i> verb&quot; (emph. added), and this is correct, you can&#x27;t tell whether an identifier refers to a function or variable in Scheme by sight alone. This seems desirable if one wants first-class functions, and is very much an intentional choice for Scheme, but it can admittedly be more difficult to build up a mental model of new code if you have no idea what&#x27;s a variable and what&#x27;s a function (esp. amidst an already-difficult-to-grok sea of parentheses).<p>Notably, this isn&#x27;t intrinsic to Lisps - Common Lisp uses a different syntax and namespace for function names and variables. My understanding is that Scheme et al&#x27;s decision to merge the namespaces&#x2F;syntax was not without controversy in the Lisp community (the Lisp-1 v Lisp-2 debate).[0]<p>[0] <a href="http:&#x2F;&#x2F;www.nhplace.com&#x2F;kent&#x2F;Papers&#x2F;Technical-Issues.html" rel="nofollow">http:&#x2F;&#x2F;www.nhplace.com&#x2F;kent&#x2F;Papers&#x2F;Technical-Issues.html</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="40699913" class="c"><input type="checkbox" id="c-40699913" checked=""/><div class="controls bullet"><span class="by">patrickmay</span><span>|</span><a href="#40700691">prev</a><span>|</span><a href="#40700733">next</a><span>|</span><label class="collapse" for="c-40699913">[-]</label><label class="expand" for="c-40699913">[83 more]</label></div><br/><div class="children"><div class="content">Every time I read about SICP, I get frustrated all over again about Javascript.  It could have been Scheme and all web development would have benefited.</div><br/><div id="40700433" class="c"><input type="checkbox" id="c-40700433" checked=""/><div class="controls bullet"><span class="by">ralphc</span><span>|</span><a href="#40699913">parent</a><span>|</span><a href="#40700341">next</a><span>|</span><label class="collapse" for="c-40700433">[-]</label><label class="expand" for="c-40700433">[76 more]</label></div><br/><div class="children"><div class="content">The only way it would have &quot;benefited&quot; would be that the web would only be developed by lisp programmers.<p>To the vast majority of programmers, syntax matters. C-style with brackets, or python whitespace, or Ruby do&#x2F;end, these fit better the brains of the majority of programmers. Perhaps not the majority of HN readers but the majority of corporate devs.<p>Another example of this is Erlang and Elixir. Elixir adds a couple of features over Erlang, macros and protocols, but Erlang does everything else. What made Elixir take off where Erlang didn&#x27;t, after decades, is that Elixir has a syntax that people are comfortable with. Erlang has a syntax that will summon Cthulu.</div><br/><div id="40700964" class="c"><input type="checkbox" id="c-40700964" checked=""/><div class="controls bullet"><span class="by">manusachi</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700433">parent</a><span>|</span><a href="#40700504">next</a><span>|</span><label class="collapse" for="c-40700964">[-]</label><label class="expand" for="c-40700964">[1 more]</label></div><br/><div class="children"><div class="content">To be fair, what made Elixir take off, other than syntax there is also the developer experience overall, including documentation, package manager, unit testing framework out of the box, web-framework initially inspired by Rails etc.<p>Though, slightly off topic, but worth mentioning, that both Erlang and Elixir communities support each other very well. For example, now not only elixir is built on top of Erlang, but also Erlang adopts some things from elixir, such as monadic expression `with` from elixir inspired `maybe` in Erlang, or starting OTP27 Erlang is using ExDoc introduced by Elixir to generate documentations.</div><br/></div></div><div id="40700504" class="c"><input type="checkbox" id="c-40700504" checked=""/><div class="controls bullet"><span class="by">sakras</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700433">parent</a><span>|</span><a href="#40700964">prev</a><span>|</span><a href="#40700685">next</a><span>|</span><label class="collapse" for="c-40700504">[-]</label><label class="expand" for="c-40700504">[57 more]</label></div><br/><div class="children"><div class="content">Is it an innate property of humans that the curly-brace style is more natural? I wonder if in an alternate universe where Lisp took off as the browser language people would find it more natural instead. It seems like somewhat of a chicken-egg problem.</div><br/><div id="40700608" class="c"><input type="checkbox" id="c-40700608" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700504">parent</a><span>|</span><a href="#40702910">next</a><span>|</span><label class="collapse" for="c-40700608">[-]</label><label class="expand" for="c-40700608">[3 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s innate that having differentiated syntax for different types of grouping is natural. Look at mathematical papers where people will introduce new brackets with new meanings. (Indeed look at the entirety of QM for a clear, simple case)</div><br/><div id="40702678" class="c"><input type="checkbox" id="c-40702678" checked=""/><div class="controls bullet"><span class="by">nequo</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700608">parent</a><span>|</span><a href="#40702934">next</a><span>|</span><label class="collapse" for="c-40702678">[-]</label><label class="expand" for="c-40702678">[1 more]</label></div><br/><div class="children"><div class="content">Some Scheme and Lisp dialects have that. For example, Racket often uses square brackets instead of parentheses for things like clauses of a cond expression, and Clojure uses square brackets for vector literals and curlies for hash map literals.</div><br/></div></div><div id="40702934" class="c"><input type="checkbox" id="c-40702934" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700608">parent</a><span>|</span><a href="#40702678">prev</a><span>|</span><a href="#40702910">next</a><span>|</span><label class="collapse" for="c-40702934">[-]</label><label class="expand" for="c-40702934">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;Look at mathematical papers where people will introduce new brackets with new meanings&quot;<p>Common Lisp has left brackets like {} and [] to the user (aka developer). It supports &quot;reader macros&quot;, where the user can extend&#x2F;supersede the syntax of s-expressions.<p>So, specialized tools&#x2F;libraries&#x2F;applications can introduce these brackets for their own use. Examples are embedded SQL expressions, notations for Frames (special objects, in kind of a mix of OOP and Logics), grammar terms, etc.<p>Thus it explicitly supports the idea of &quot;people will introduce new brackets with new meanings&quot;.</div><br/></div></div></div></div><div id="40702910" class="c"><input type="checkbox" id="c-40702910" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700504">parent</a><span>|</span><a href="#40700608">prev</a><span>|</span><a href="#40700612">next</a><span>|</span><label class="collapse" for="c-40702910">[-]</label><label class="expand" for="c-40702910">[1 more]</label></div><br/><div class="children"><div class="content">Because lisp is trivial to parse, it’s easy to make an extension for vs code that shows &#x2F; edits Common Lisp &#x2F; scheme looking completely different; you can make it unrecognisable. If the () are the only thing bothering people, then this is very simple to resolve. Can hardly be the only thing though. It’s also easy to build operators similar to the ones you have in Python etc like filter, map etc so you don’t have to apply recursion. These are there already but you can build them yourself in a few hours.<p>So it’s probably just what people learn first + lack of ‘marketing’ or negative PR (there are no libraries or ecosystem! The thing that <i>least</i> bothered me about CL but people with npm leftpad experience seem bothered by it).<p>It’s interesting as I worked I almost everything in production; c&#x2F;c++ (including the MS 90s flavour), Delphi, VB, Perl, PHP, Java, C#, Haskell, F#, Common Lisp, Erlang, TS&#x2F;JS, Python, Ruby, asm (z80, arm, x86) and I simply have not had a better overal experience than CL. The others are better at <i>some</i> things but a an overal experience, CL just is a pleasure.</div><br/></div></div><div id="40700612" class="c"><input type="checkbox" id="c-40700612" checked=""/><div class="controls bullet"><span class="by">lopatin</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700504">parent</a><span>|</span><a href="#40702910">prev</a><span>|</span><a href="#40701148">next</a><span>|</span><label class="collapse" for="c-40700612">[-]</label><label class="expand" for="c-40700612">[26 more]</label></div><br/><div class="children"><div class="content">Does decades of empirical evidence not prove that people are more comfortable with imperative, curly brace programming over s-expressions? It&#x27;s not a chicken and egg problem. The egg has hatched and nested parentheses lost.</div><br/><div id="40701054" class="c"><input type="checkbox" id="c-40701054" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700612">parent</a><span>|</span><a href="#40700834">next</a><span>|</span><label class="collapse" for="c-40701054">[-]</label><label class="expand" for="c-40701054">[7 more]</label></div><br/><div class="children"><div class="content">You may be right, idk, but I want to point out that you’re conflating two orthogonal concepts: S-expressions and imperative vs. functional programming.<p>There are lisp dialects that are very imperative, for example elisp, but they still use S-expressions. Historically they might have been considered “functional” because they have first-class functions and higher-order functions like mapcar, but nowadays practically every modern programming language (except go!) has these.<p>The thing all lisp dialects have in common is not where they land on the imperative vs. functional spectrum, but rather the fact that the syntax is trivial and so it’s easy to write powerful macros.</div><br/><div id="40701139" class="c"><input type="checkbox" id="c-40701139" checked=""/><div class="controls bullet"><span class="by">jltsiren</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40701054">parent</a><span>|</span><a href="#40700834">next</a><span>|</span><label class="collapse" for="c-40701139">[-]</label><label class="expand" for="c-40701139">[6 more]</label></div><br/><div class="children"><div class="content">I think the simple uniform syntax is the main reason why Lisp never became popular.<p>Code is communication, and communication needs redundancy for error correction. You can see it in natural languages, and it makes sense to have it in programming languages as well. Using different kinds of syntax for expressing different ideas is an easy way to increase redundancy without making the code more verbose.</div><br/><div id="40702414" class="c"><input type="checkbox" id="c-40702414" checked=""/><div class="controls bullet"><span class="by">jimbokun</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40701139">parent</a><span>|</span><a href="#40701395">next</a><span>|</span><label class="collapse" for="c-40702414">[-]</label><label class="expand" for="c-40702414">[2 more]</label></div><br/><div class="children"><div class="content">Lisp did become popular.<p>Then the AI Winter killed it and people avoided it like the plague.</div><br/><div id="40703341" class="c"><input type="checkbox" id="c-40703341" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40702414">parent</a><span>|</span><a href="#40701395">next</a><span>|</span><label class="collapse" for="c-40703341">[-]</label><label class="expand" for="c-40703341">[1 more]</label></div><br/><div class="children"><div class="content">The Lisp machine companies killed Lisp. They were the ones who blew Lisp sky high, but they also created expensive, monstrous workstations running Lisp images requiring tens of megabytes of RAM. Developers used them for prototyping and then had to cob something together to ship to the users, who had hardware like IBM PC machines with less than a meg of RAM.<p>Today&#x27;s cruft like you  ... Python, JS, whatever ... would not stand a chance in the world of the 1980s on that hardware.<p>It&#x27;s amazing how far they were able to bloat up Lisp while continuing to peddle it commercially.<p>Leaner Lisps running on small systems existed all along, but they would rescue Lisp from the associations brought about by big Lisp.</div><br/></div></div></div></div><div id="40701395" class="c"><input type="checkbox" id="c-40701395" checked=""/><div class="controls bullet"><span class="by">gsbcbdjfncnjd</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40701139">parent</a><span>|</span><a href="#40702414">prev</a><span>|</span><a href="#40702478">next</a><span>|</span><label class="collapse" for="c-40701395">[-]</label><label class="expand" for="c-40701395">[1 more]</label></div><br/><div class="children"><div class="content">Clojure has all those other braces also. They’re just used for data structure literals rather than blocks of code.</div><br/></div></div><div id="40702478" class="c"><input type="checkbox" id="c-40702478" checked=""/><div class="controls bullet"><span class="by">xwolfi</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40701139">parent</a><span>|</span><a href="#40701395">prev</a><span>|</span><a href="#40700834">next</a><span>|</span><label class="collapse" for="c-40702478">[-]</label><label class="expand" for="c-40702478">[2 more]</label></div><br/><div class="children"><div class="content">Or as I tell my colleagues who try to push for more abstract syntax: do you want your brain to do compilation each time your read something, or just have verbose text giving hints at each line ?<p>It s weird people prefer reading implicit text.</div><br/><div id="40702713" class="c"><input type="checkbox" id="c-40702713" checked=""/><div class="controls bullet"><span class="by">nequo</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40702478">parent</a><span>|</span><a href="#40700834">next</a><span>|</span><label class="collapse" for="c-40702713">[-]</label><label class="expand" for="c-40702713">[1 more]</label></div><br/><div class="children"><div class="content">Isn’t this a big reason we have syntax highlighting? You can use color and styling to give you those hints that are otherwise implicit in text.</div><br/></div></div></div></div></div></div></div></div><div id="40700834" class="c"><input type="checkbox" id="c-40700834" checked=""/><div class="controls bullet"><span class="by">shakow</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700612">parent</a><span>|</span><a href="#40701054">prev</a><span>|</span><a href="#40701039">next</a><span>|</span><label class="collapse" for="c-40700834">[-]</label><label class="expand" for="c-40700834">[3 more]</label></div><br/><div class="children"><div class="content">Decades of empirical evidence prove that people are more comfortable with functional, reactive, beging&#x2F;end delimited programming, i.e. Excel.</div><br/><div id="40701035" class="c"><input type="checkbox" id="c-40701035" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700834">parent</a><span>|</span><a href="#40701039">next</a><span>|</span><label class="collapse" for="c-40701035">[-]</label><label class="expand" for="c-40701035">[2 more]</label></div><br/><div class="children"><div class="content">millenia of empirical evidence and through to today, shows that most people are more comfortable not coding at all.</div><br/><div id="40701475" class="c"><input type="checkbox" id="c-40701475" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40701035">parent</a><span>|</span><a href="#40701039">next</a><span>|</span><label class="collapse" for="c-40701475">[-]</label><label class="expand" for="c-40701475">[1 more]</label></div><br/><div class="children"><div class="content">True, the majority of humans never even <i>saw</i>  a computer.</div><br/></div></div></div></div></div></div><div id="40701039" class="c"><input type="checkbox" id="c-40701039" checked=""/><div class="controls bullet"><span class="by">addicted</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700612">parent</a><span>|</span><a href="#40700834">prev</a><span>|</span><a href="#40701652">next</a><span>|</span><label class="collapse" for="c-40701039">[-]</label><label class="expand" for="c-40701039">[2 more]</label></div><br/><div class="children"><div class="content">No, it doesn’t.<p>What has happened in reality is that C became really popular and then all the people designing languages they wanted to be popular, rather than to be experimental, or to push boundaries, etc obviously chose a syntax which was familiar with most programmers, ie a syntax like C’s.<p>Further, one can disprove that the syntax is particularly important by simply pointing to Python which became immensely popular despite a lack of curly braces and even worse with significant white space simply because colleges and bootcamps decided it would be a good language to teach programming to beginners.</div><br/><div id="40702336" class="c"><input type="checkbox" id="c-40702336" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40701039">parent</a><span>|</span><a href="#40701652">next</a><span>|</span><label class="collapse" for="c-40702336">[-]</label><label class="expand" for="c-40702336">[1 more]</label></div><br/><div class="children"><div class="content">Arguably python and c are much more similar than any of them compared to a lisp.<p>I would argue the important part are the <i>blocks</i> in the former two,  which sort of gets lost in the homogeny of lisps. Whether a block is marked with curly braces or indents doesn’t matter much - they being dissimilar to a regular expression does. Of course well-formatted lisp code tries to indent as well, but still there is a lot of visual noise there making it harder to visually inspect the code, I would guess.<p>Of course familiarity with a given way is significantly more important. We pretty much learnt the non-intuitive writing of math, to Chinese people their writing system is the intuitive one, etc.</div><br/></div></div></div></div><div id="40701652" class="c"><input type="checkbox" id="c-40701652" checked=""/><div class="controls bullet"><span class="by">eichin</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700612">parent</a><span>|</span><a href="#40701039">prev</a><span>|</span><a href="#40702002">next</a><span>|</span><label class="collapse" for="c-40701652">[-]</label><label class="expand" for="c-40701652">[1 more]</label></div><br/><div class="children"><div class="content">Hmm, can&#x27;t find the paper (mostly clutter from language bootcamp results) but around a decade or so back there was an education research project that concluded that teaching SQL first, rather than any imperative language (regardless of punctuation), was better for getting students to develop reasonable mental models for computing.  (Unfortunately without the reference I can&#x27;t address what the criteria for &quot;better&quot; were - but &quot;what people get paid to do&quot; isn&#x27;t really proof of <i>comfort</i> at any level...)</div><br/></div></div><div id="40702002" class="c"><input type="checkbox" id="c-40702002" checked=""/><div class="controls bullet"><span class="by">cageface</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700612">parent</a><span>|</span><a href="#40701652">prev</a><span>|</span><a href="#40700989">next</a><span>|</span><label class="collapse" for="c-40702002">[-]</label><label class="expand" for="c-40702002">[6 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s quite telling that almost all of the innovations in lisp (garbage collection, first class functions, repl etc) have been absorbed into more popular languages <i>except</i> for s-expression syntax, which remains a small niche despite many great implementations of s-expression based languages.</div><br/><div id="40702206" class="c"><input type="checkbox" id="c-40702206" checked=""/><div class="controls bullet"><span class="by">skydhash</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40702002">parent</a><span>|</span><a href="#40700989">next</a><span>|</span><label class="collapse" for="c-40702206">[-]</label><label class="expand" for="c-40702206">[5 more]</label></div><br/><div class="children"><div class="content">Because as soon as you adopt the s-expressions, what you got is no longer &lt;language&gt;, but lisp itself. Something like this:<p><pre><code>  static char _getch() {
    char buf;

    if (read(0, &amp;buf, 1)) return buf;

    return &#x27;\0&#x27;;
  }
</code></pre>
would become:<p><pre><code>  (define _getchar ()
    (declare static)
    (return-type &#x27;char)
    (let ((buf (char)))
      (if (read 0 (&amp; buf) 1)
        buf
        &quot;\0&quot;)))</code></pre></div><br/><div id="40702605" class="c"><input type="checkbox" id="c-40702605" checked=""/><div class="controls bullet"><span class="by">cageface</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40702206">parent</a><span>|</span><a href="#40702354">next</a><span>|</span><label class="collapse" for="c-40702605">[-]</label><label class="expand" for="c-40702605">[1 more]</label></div><br/><div class="children"><div class="content">Right. From which we can infer people like many things about lisp except for the syntax.</div><br/></div></div><div id="40702354" class="c"><input type="checkbox" id="c-40702354" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40702206">parent</a><span>|</span><a href="#40702605">prev</a><span>|</span><a href="#40700989">next</a><span>|</span><label class="collapse" for="c-40702354">[-]</label><label class="expand" for="c-40702354">[3 more]</label></div><br/><div class="children"><div class="content">No. There is a good github gist rant I can’t find anymore, but if we call every AST in the form of s-expressions lisp, then is anything lisp? A programming language has to have an associated evaluation strategy, otherwise it’s just data. What you wrote only makes sense to execute as C code, which sure you can write a compiler for in your given lisp as well (so can you write a C compiler taking C AST in any other language, so it’s not special at all).</div><br/><div id="40702719" class="c"><input type="checkbox" id="c-40702719" checked=""/><div class="controls bullet"><span class="by">hayley-patton</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40702354">parent</a><span>|</span><a href="#40700989">next</a><span>|</span><label class="collapse" for="c-40702719">[-]</label><label class="expand" for="c-40702719">[2 more]</label></div><br/><div class="children"><div class="content">This one? <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;no-defun-allowed&#x2F;4f0a06e17b3ce74c6aeac514281f350f" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;no-defun-allowed&#x2F;4f0a06e17b3ce74c6ae...</a><p>It also responds to a few parents up &quot;almost all of the innovations in lisp [...] have been absorbed into more popular languages&quot; - pervasive interactivity hasn&#x27;t even been taken up by some &quot;Lisps&quot;, let alone has it been absorbed outside Lisp.</div><br/><div id="40702997" class="c"><input type="checkbox" id="c-40702997" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40702719">parent</a><span>|</span><a href="#40700989">next</a><span>|</span><label class="collapse" for="c-40702997">[-]</label><label class="expand" for="c-40702997">[1 more]</label></div><br/><div class="children"><div class="content">Yes! Thanks for digging it up for me! I can’t find anything on google for the life of me since they switched to vector search, even though I used to be able to find some obscure blog post..</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40700989" class="c"><input type="checkbox" id="c-40700989" checked=""/><div class="controls bullet"><span class="by">wholinator2</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700612">parent</a><span>|</span><a href="#40702002">prev</a><span>|</span><a href="#40702407">next</a><span>|</span><label class="collapse" for="c-40700989">[-]</label><label class="expand" for="c-40700989">[3 more]</label></div><br/><div class="children"><div class="content">Has there ever been research on this? Perhaps this situation has come about because the schools people must go to to get the programming jobs only teach the Javascript way? It seems circular logic to say that the current paradigm must be superior for the fact that it is the current paradigm. Is it possible that there are other reasons it reached that status?</div><br/><div id="40701113" class="c"><input type="checkbox" id="c-40701113" checked=""/><div class="controls bullet"><span class="by">pas</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700989">parent</a><span>|</span><a href="#40702407">next</a><span>|</span><label class="collapse" for="c-40701113">[-]</label><label class="expand" for="c-40701113">[2 more]</label></div><br/><div class="children"><div class="content">does n=1 count? :)<p>some time ago I tried Racket, and just no. recently I tried Scala ZIO HTTP, and yes.<p>Maybe it&#x27;s the types? Maybe it&#x27;s the parens. But probably both. I cannot really recall my experience, just that manipulating code was ridiculously clunky. My assumption was that the IDE will manage the parens for me and when I&#x27;m moving something somewhere it&#x27;ll figure out if I messed up the parens.. and ... no, nothing. I had to balance them with hand.</div><br/><div id="40702016" class="c"><input type="checkbox" id="c-40702016" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40701113">parent</a><span>|</span><a href="#40702407">next</a><span>|</span><label class="collapse" for="c-40702016">[-]</label><label class="expand" for="c-40702016">[1 more]</label></div><br/><div class="children"><div class="content">One reason emacs is popular for lisp programming is that the paredit package (or its newer competitor smartparens) do basically exactly what you describe: structural editing of sexp-based languages.</div><br/></div></div></div></div></div></div><div id="40702407" class="c"><input type="checkbox" id="c-40702407" checked=""/><div class="controls bullet"><span class="by">jimbokun</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700612">parent</a><span>|</span><a href="#40700989">prev</a><span>|</span><a href="#40701963">next</a><span>|</span><label class="collapse" for="c-40702407">[-]</label><label class="expand" for="c-40702407">[1 more]</label></div><br/><div class="children"><div class="content">It only proves that those languages are the most learned because they are the most popular in industry.<p>It says nothing about what makes a language easy to learn.</div><br/></div></div><div id="40701963" class="c"><input type="checkbox" id="c-40701963" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700612">parent</a><span>|</span><a href="#40702407">prev</a><span>|</span><a href="#40700855">next</a><span>|</span><label class="collapse" for="c-40701963">[-]</label><label class="expand" for="c-40701963">[1 more]</label></div><br/><div class="children"><div class="content">No, because people who start in programming do not go to a syntax comfort clinic, where they are tested, and then assigned to a programming language.</div><br/></div></div><div id="40700855" class="c"><input type="checkbox" id="c-40700855" checked=""/><div class="controls bullet"><span class="by">Ologn</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700612">parent</a><span>|</span><a href="#40701963">prev</a><span>|</span><a href="#40701148">next</a><span>|</span><label class="collapse" for="c-40700855">[-]</label><label class="expand" for="c-40700855">[1 more]</label></div><br/><div class="children"><div class="content">Does over a century of empirical evidence not prove that people are more comfortable with keyboards whose top row is laid out &quot;QWERTYUIOP&quot;?</div><br/></div></div></div></div><div id="40701148" class="c"><input type="checkbox" id="c-40701148" checked=""/><div class="controls bullet"><span class="by">troad</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700504">parent</a><span>|</span><a href="#40700612">prev</a><span>|</span><a href="#40701733">next</a><span>|</span><label class="collapse" for="c-40701148">[-]</label><label class="expand" for="c-40701148">[17 more]</label></div><br/><div class="children"><div class="content">I would argue that imperative programming is most natural - it&#x27;s what everyone gravitates to in the beginning. Then, at a sufficient level of complexity, a programmer gravitates to solutions like OOP or FP, but there&#x27;s an obvious trade off in readability there. 99 Bottles of Beer implemented with a loop is intrinsically going to be easier to read than an implementation with tail recursion, even though the latter is generally better. Lisp&#x27;s inside-out parentheses style adds yet more cognitive load on top of that.<p>Many things are socially constructed, but not <i>everything</i>.</div><br/><div id="40701468" class="c"><input type="checkbox" id="c-40701468" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40701148">parent</a><span>|</span><a href="#40701360">next</a><span>|</span><label class="collapse" for="c-40701468">[-]</label><label class="expand" for="c-40701468">[5 more]</label></div><br/><div class="children"><div class="content">&gt; I would argue that imperative programming is most natural - it&#x27;s what everyone gravitates to in the beginning.<p>When 6.001 (the introductory class for which SICP was written) was launched, most of the students who took it had never used a computer before.  Yes, MIT students.  This was around ~1980.  And in the first hour of their first class they were already doing symbolic differentiation in scheme.<p>I think your view of what’s “natural” is a just so story.</div><br/><div id="40701629" class="c"><input type="checkbox" id="c-40701629" checked=""/><div class="controls bullet"><span class="by">troad</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40701468">parent</a><span>|</span><a href="#40701573">next</a><span>|</span><label class="collapse" for="c-40701629">[-]</label><label class="expand" for="c-40701629">[3 more]</label></div><br/><div class="children"><div class="content">&gt; And in the first hour of their first class they were already doing symbolic differentiation in scheme.<p>People heavily trained in maths can take quickly to languages designed to make programming look like maths, that&#x27;s hardly a surprise.<p>I wouldn&#x27;t base my assumptions about what most people find natural on the experience of MIT students taking 6.001 in 1980.<p>(Not to mention, &#x27;doing&#x27; is doing a lot of heavy lifting in that sentence. I could show you a intricate sentence in French in the first hour of your first French class, but unless you came up with it yourself, are you demonstrating much learning just yet?)</div><br/><div id="40702392" class="c"><input type="checkbox" id="c-40702392" checked=""/><div class="controls bullet"><span class="by">jimbokun</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40701629">parent</a><span>|</span><a href="#40701573">next</a><span>|</span><label class="collapse" for="c-40702392">[-]</label><label class="expand" for="c-40702392">[2 more]</label></div><br/><div class="children"><div class="content">But you are basing your assumptions on absolutely nothing.</div><br/><div id="40702496" class="c"><input type="checkbox" id="c-40702496" checked=""/><div class="controls bullet"><span class="by">troad</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40702392">parent</a><span>|</span><a href="#40701573">next</a><span>|</span><label class="collapse" for="c-40702496">[-]</label><label class="expand" for="c-40702496">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m basing my assumptions my own experience, both learning to code and teaching others to code, which isn&#x27;t nothing to me, but may well be nothing to you. (No shade intended, that&#x27;s totally valid.)<p>I would certainly be interested in the results of a study that put a simpler interpreter &#x2F; compiler and a language reference in front of motivated non-programmers, but I strongly suspect that the amount of elegant tail recursion we&#x27;ll see will be limited (and I&#x27;d very much expect there to be a correlation between that and a training in mathematics).<p>Imho, data comes from experiments, but experiments come from hypotheses, and hypotheses come from experience.</div><br/></div></div></div></div></div></div><div id="40701573" class="c"><input type="checkbox" id="c-40701573" checked=""/><div class="controls bullet"><span class="by">eichin</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40701468">parent</a><span>|</span><a href="#40701629">prev</a><span>|</span><a href="#40701360">next</a><span>|</span><label class="collapse" for="c-40701573">[-]</label><label class="expand" for="c-40701573">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, mid-1980s the thing incoming students had to unlearn was <i>BASIC</i>, not anything with curly braces.  (Source: I was a 6.001 Lab TA at the time.)  Of course, the next class on the rotation used Clu, where you had to unlearn &quot;recursion is free&quot;.</div><br/></div></div></div></div><div id="40701360" class="c"><input type="checkbox" id="c-40701360" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40701148">parent</a><span>|</span><a href="#40701468">prev</a><span>|</span><a href="#40702825">next</a><span>|</span><label class="collapse" for="c-40701360">[-]</label><label class="expand" for="c-40701360">[3 more]</label></div><br/><div class="children"><div class="content">Imperative programming is probably the most intuitive, but I&#x27;m doubtful curly braces and C-like syntax are anything more than coincidence. The first programming language was Fortran, and it didn&#x27;t look anything like C. This is a really old Fortran program copied from a book:<p><pre><code>     WRITE(6,28)
     READ(5,31) LIMIT
     ALIM = LIMIT
   5 SUM=0.0
     DO 35 ICNT=1,LIMIT
     READ(5,32) X
  35 SUM = SUM + X
     AMEAN = SUM&#x2F;ALIM
     WRITE(6,33) AMEAN
     GO TO 5
  28 FORMAT(1H1)
  31 FORMAT(I3)
  32 FORMAT(F5.2)
  33 FORMAT(8H MEAN = .F8.2)
     END
</code></pre>
Most modern programming languages seem to take inspiration from C, which took inspiration from BCPL, and that from Algol. Others took inspiration from Algol directly, like Ada, or Lua. And Python has indentation-based block structure, rather than having blocks of statements delimited by braces or or an &quot;end&quot; keyword.</div><br/><div id="40701517" class="c"><input type="checkbox" id="c-40701517" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40701360">parent</a><span>|</span><a href="#40702049">next</a><span>|</span><label class="collapse" for="c-40701517">[-]</label><label class="expand" for="c-40701517">[1 more]</label></div><br/><div class="children"><div class="content">I always liked Pascal&#x27;s BEGIN and END statements instead of curly braces. There is also Basic where the blocks built into control flow statements, like FOR I=1 TO 5 [code here] NEXT I<p>I&#x27;d argue a lot of programming language evolution is influenced by the capabilities of our IDEs. When you code in a text editor, the terse syntax of C is great and brings advantages over the verbosity of Pascal, Basic or god forbid Cobol. Once your editor does auto-indentation the braces seem redundant and you get Python. Smart completions from IntelliSense are essential to efficiently writing C#, and now that LSP has brought that to every IDE or smart text editor we have the explosion of popularity of more explicit and more powerful type systems (Typescript, typed Python, Rust). Programming languages are shaped by their environment, but the successful ones far outlive the environment that shaped them.</div><br/></div></div><div id="40702049" class="c"><input type="checkbox" id="c-40702049" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40701360">parent</a><span>|</span><a href="#40701517">prev</a><span>|</span><a href="#40702825">next</a><span>|</span><label class="collapse" for="c-40702049">[-]</label><label class="expand" for="c-40702049">[1 more]</label></div><br/><div class="children"><div class="content">It really depends on your mindset. I grew up with math (composable operators, no side effects) and a lot of immutable + virtual operations software (maya, samplitude, shake, combustion) ... so to me imperative programming, with all the control flow, subtly changing state and time dependencies, coupling of concerns was almost instantaneously an fatal issue..<p>Backus also shifted away from imperative inspired languages to design FP&#x2F;FL language (I thought they were contemporaries of BCPL but came 10 years later, later than APL), even though he contributed to FORTRAN directly.</div><br/></div></div></div></div><div id="40702825" class="c"><input type="checkbox" id="c-40702825" checked=""/><div class="controls bullet"><span class="by">antonvs</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40701148">parent</a><span>|</span><a href="#40701360">prev</a><span>|</span><a href="#40702405">next</a><span>|</span><label class="collapse" for="c-40702825">[-]</label><label class="expand" for="c-40702825">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I would argue that imperative programming is most natural - it&#x27;s what everyone gravitates to in the beginning.<p>Why do you believe this is anything more than an historical accident?<p>For example, it wasn&#x27;t what Alonzo Church gravitated to when he invented the lambda calculus in the 1930s, before any programming languages or indeed general-purpose computers existed.<p>&gt; 99 Bottles of Beer implemented with a loop is intrinsically going to be easier to read than an implementation with tail recursion<p>First, you don&#x27;t need to use explicit tail recursion. See e.g. <a href="https:&#x2F;&#x2F;99-bottles-of-beer.net&#x2F;language-haskell-1070.html" rel="nofollow">https:&#x2F;&#x2F;99-bottles-of-beer.net&#x2F;language-haskell-1070.html</a><p>Second, this sounds like unfamiliarity, not anything inherent. Why is it &quot;intrinsically easier to read&quot;? For a tail recursive version, the main tail recursive function would look like this in Haskell:<p><pre><code>    _99bottles 0 = printVerse 0
    _99bottles n = do
        printVerse n
        _99bottles (n - 1)
</code></pre>
In fact, with a bit of experience you might write this as:<p><pre><code>    _99bottles 0 = printVerse 0
    _99bottles n = printVerse n &gt;&gt; _99bottles (n - 1)
</code></pre>
It&#x27;s only less easy to read if you&#x27;re completely unfamiliar with the concepts of pattern matching and recursion. But the same is true of any programming language.<p>Given the above, what&#x27;s a &quot;for loop&quot; and why would you need one? Sounds complicated and unnatural.</div><br/></div></div><div id="40702405" class="c"><input type="checkbox" id="c-40702405" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40701148">parent</a><span>|</span><a href="#40702825">prev</a><span>|</span><a href="#40702991">next</a><span>|</span><label class="collapse" for="c-40702405">[-]</label><label class="expand" for="c-40702405">[1 more]</label></div><br/><div class="children"><div class="content">OOP is imperative programming. It&#x27;s just function calls where the first parameter is to the left of the function name, after all.<p>A better name for &quot;non-OOP&quot; programming is procedural programming, where you organize code in long blocks that go straight down, code duplication is accepted vs jumping all over the place, etc. Honestly underrated. It can be quite easy to understand.<p>Strictly-evaluated FP is also imperative. The only really different languages are the ones with different evaluation systems or that can do things besides evaluate - people like to say Haskell is the best here but I think it&#x27;s actually unification languages like Mercury. Maybe even SQL with transactions.</div><br/></div></div><div id="40702991" class="c"><input type="checkbox" id="c-40702991" checked=""/><div class="controls bullet"><span class="by">kovac</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40701148">parent</a><span>|</span><a href="#40702405">prev</a><span>|</span><a href="#40701448">next</a><span>|</span><label class="collapse" for="c-40702991">[-]</label><label class="expand" for="c-40702991">[2 more]</label></div><br/><div class="children"><div class="content">&gt; even though the latter is generally better<p>Why is tail recursion  better generally? I&#x27;m not familiar with FP very much, but it feels like loops more closely resemble the way computers execute them than tail recursion.</div><br/><div id="40703210" class="c"><input type="checkbox" id="c-40703210" checked=""/><div class="controls bullet"><span class="by">vmladenov</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40702991">parent</a><span>|</span><a href="#40701448">next</a><span>|</span><label class="collapse" for="c-40703210">[-]</label><label class="expand" for="c-40703210">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s more concise and illustrates the common subproblem. Loops make you model a state machine in your head, which I&#x27;d rather leave to the computer.</div><br/></div></div></div></div><div id="40701448" class="c"><input type="checkbox" id="c-40701448" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40701148">parent</a><span>|</span><a href="#40702991">prev</a><span>|</span><a href="#40702751">next</a><span>|</span><label class="collapse" for="c-40701448">[-]</label><label class="expand" for="c-40701448">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;d argue a FP implemenation with map (something like `[99..1].map(|n| f&#x27;{n} bottles of beer ... {n-1} bottles of beer on the wall&#x27;).join(&#x27;\n\n&#x27;)`) is inherently as readable as the for loop, and not really more complex.<p>There are lots of great parts in FP, and for the last ~10-15 years imperative programming languages have made a lot of effort to add them to their syntax. You just need to leave out the more dogmatic parts that make FP popular in academia.</div><br/><div id="40701734" class="c"><input type="checkbox" id="c-40701734" checked=""/><div class="controls bullet"><span class="by">troad</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40701448">parent</a><span>|</span><a href="#40702751">next</a><span>|</span><label class="collapse" for="c-40701734">[-]</label><label class="expand" for="c-40701734">[1 more]</label></div><br/><div class="children"><div class="content">Hehe, it&#x27;s easy if you ignore half the song, the singular for n=1 and the whole n=0 case! (Not that we&#x27;re talking about rocket science if you don&#x27;t, but c&#x27;mon, oranges to oranges!)<p>I agree with you otherwise though.</div><br/></div></div></div></div><div id="40702751" class="c"><input type="checkbox" id="c-40702751" checked=""/><div class="controls bullet"><span class="by">dehrmann</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40701148">parent</a><span>|</span><a href="#40701448">prev</a><span>|</span><a href="#40702384">next</a><span>|</span><label class="collapse" for="c-40702751">[-]</label><label class="expand" for="c-40702751">[1 more]</label></div><br/><div class="children"><div class="content">Assembly is imperative, so there&#x27;s a lot to be said for a language that mimics how the computer actually works. Lisps always leave me saying, &quot;oh, that&#x27;s clever.&quot;</div><br/></div></div><div id="40702384" class="c"><input type="checkbox" id="c-40702384" checked=""/><div class="controls bullet"><span class="by">jimbokun</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40701148">parent</a><span>|</span><a href="#40702751">prev</a><span>|</span><a href="#40701733">next</a><span>|</span><label class="collapse" for="c-40702384">[-]</label><label class="expand" for="c-40702384">[1 more]</label></div><br/><div class="children"><div class="content">This is completely socially constructed.<p>Lisp was once a very popular introductory programming language and students learned it just as easily or easier than any other language.</div><br/></div></div></div></div><div id="40701733" class="c"><input type="checkbox" id="c-40701733" checked=""/><div class="controls bullet"><span class="by">mcswell</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700504">parent</a><span>|</span><a href="#40701148">prev</a><span>|</span><a href="#40700640">next</a><span>|</span><label class="collapse" for="c-40701733">[-]</label><label class="expand" for="c-40701733">[1 more]</label></div><br/><div class="children"><div class="content">Then why does this web page use indentation to clarify who&#x27;s replying to whom, instead of {}s?</div><br/></div></div><div id="40700640" class="c"><input type="checkbox" id="c-40700640" checked=""/><div class="controls bullet"><span class="by">ralphc</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700504">parent</a><span>|</span><a href="#40701733">prev</a><span>|</span><a href="#40701917">next</a><span>|</span><label class="collapse" for="c-40700640">[-]</label><label class="expand" for="c-40700640">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know if it&#x27;s innate but it&#x27;s what we have. Lisp has been around about as long as programming, it&#x27;s had plenty of time to catch on, it hasn&#x27;t.<p>Maybe innate, maybe it&#x27;s an offshoot of teaching math in an infix style, 1 + 2 vs. + 1 2.</div><br/><div id="40701056" class="c"><input type="checkbox" id="c-40701056" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700640">parent</a><span>|</span><a href="#40702440">next</a><span>|</span><label class="collapse" for="c-40701056">[-]</label><label class="expand" for="c-40701056">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think it&#x27;s been tested at all. for people who took and finished a course in Lisp as their first programming language, how many &quot;hate parens&quot;?<p>I have no trouble with lisp&#x27;s parens, i like them. What I never liked though, is that the first item in the list was an operator, a verb lets say, and the rest were the nouns; whereas, you could also have nested lists say of numbers where there were no operators. Never felt right (not that I can think of a better way, not worth adding more parens)</div><br/></div></div><div id="40702440" class="c"><input type="checkbox" id="c-40702440" checked=""/><div class="controls bullet"><span class="by">jimbokun</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700640">parent</a><span>|</span><a href="#40701056">prev</a><span>|</span><a href="#40701411">next</a><span>|</span><label class="collapse" for="c-40702440">[-]</label><label class="expand" for="c-40702440">[1 more]</label></div><br/><div class="children"><div class="content">Lisp became very popular, then died off rapidly due to association with the AI Winter.</div><br/></div></div><div id="40701411" class="c"><input type="checkbox" id="c-40701411" checked=""/><div class="controls bullet"><span class="by">gsbcbdjfncnjd</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700640">parent</a><span>|</span><a href="#40702440">prev</a><span>|</span><a href="#40701917">next</a><span>|</span><label class="collapse" for="c-40701411">[-]</label><label class="expand" for="c-40701411">[1 more]</label></div><br/><div class="children"><div class="content">But good college math departments teach reverse Polish notation; i.e., Hewlett-Packard over Texas Instruments. It’s demonstrably more advanced &#x2F; efficient.</div><br/></div></div></div></div><div id="40701917" class="c"><input type="checkbox" id="c-40701917" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700504">parent</a><span>|</span><a href="#40700640">prev</a><span>|</span><a href="#40702373">next</a><span>|</span><label class="collapse" for="c-40701917">[-]</label><label class="expand" for="c-40701917">[2 more]</label></div><br/><div class="children"><div class="content">C-like syntax is brutally hostile to programming beginners. There is not a shred of anything natural about it.</div><br/><div id="40702168" class="c"><input type="checkbox" id="c-40702168" checked=""/><div class="controls bullet"><span class="by">skydhash</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40701917">parent</a><span>|</span><a href="#40702373">next</a><span>|</span><label class="collapse" for="c-40702168">[-]</label><label class="expand" for="c-40702168">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s nothing natural about programming, because no ones like to be that formalized in their thinking process, especially with things that should be common sense (although ambiguity is still an issue). It&#x27;s the recursive definition that get people. Especially when pointing that the things that the computer can do form a very small set. It&#x27;s just that they can do it very fast.<p>You can see that when observing novices programming (without stack overflow or similar help). They often assumes that it will get done (magically) as soon as they call that function. And their code organization reflects the ad hoc thinking instead of a planned endeavor.</div><br/></div></div></div></div><div id="40702373" class="c"><input type="checkbox" id="c-40702373" checked=""/><div class="controls bullet"><span class="by">jimbokun</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700504">parent</a><span>|</span><a href="#40701917">prev</a><span>|</span><a href="#40701237">next</a><span>|</span><label class="collapse" for="c-40702373">[-]</label><label class="expand" for="c-40702373">[1 more]</label></div><br/><div class="children"><div class="content">That alternative universe was the early 1980s where Lisp was very popular to learn due to bring consider the best language for AI.</div><br/></div></div><div id="40701237" class="c"><input type="checkbox" id="c-40701237" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700504">parent</a><span>|</span><a href="#40702373">prev</a><span>|</span><a href="#40700685">next</a><span>|</span><label class="collapse" for="c-40701237">[-]</label><label class="expand" for="c-40701237">[1 more]</label></div><br/><div class="children"><div class="content">The curly braces themselves are 100% irrelevant, as evidenced by the many, many successful and well-liked languages which don&#x27;t use them, including Python, which is in the running for the most-used language these days.  They&#x27;re an implementation detail.<p>What&#x27;s closer to innate is the Algorithmic Language, Algol for short, the common ancestor of the vast majority of languages in common use (but not, notably, Lisps).<p>Algol was designed based on observational data of how programmers, who had to somehow turn their ideas into the assembler to run on machines, would write out those ideas.  Before it was code, it was pseudocode, and the origins predate electronic computers: pseudocode was used to express algorithms to computers, when that was a profession rather than an object.<p>That pseudocode could have been anything, because it was just a way of working out what you then had to persuade the machine to do.  But it gravitated toward a common vocabulary of control structures, assignment expressions, arithmetic as expressed in PEBCAK style, subroutine calls written like functions, indexing with squared brackets on both sides of an assignment, and so on.  I revert to pseudocode frequently when I&#x27;m stuck on something, and get a lot of benefit from the practice.<p>So I do think that what&#x27;s common in imperative languages captures something which is somewhat innate to the way programmers think about programs.  Lisp was also a notation! And it fits the way some people think very well. But not the majority. I have some thoughts about why, which you can deduce an accurate sketch of from what I chose to highlight in the previous paragraph.</div><br/></div></div></div></div><div id="40700685" class="c"><input type="checkbox" id="c-40700685" checked=""/><div class="controls bullet"><span class="by">tejtm</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700433">parent</a><span>|</span><a href="#40700504">prev</a><span>|</span><a href="#40701398">next</a><span>|</span><label class="collapse" for="c-40700685">[-]</label><label class="expand" for="c-40700685">[1 more]</label></div><br/><div class="children"><div class="content">&quot;The only way it would have &quot;benefited&quot; would be that the web would only be developed by lisp programmers.&quot;<p>Considering the state of the web I do not think this is making the argument you intend.</div><br/></div></div><div id="40701398" class="c"><input type="checkbox" id="c-40701398" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700433">parent</a><span>|</span><a href="#40700685">prev</a><span>|</span><a href="#40702367">next</a><span>|</span><label class="collapse" for="c-40701398">[-]</label><label class="expand" for="c-40701398">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>To the vast majority of programmers, syntax matters. C-style with brackets, or python whitespace, or Ruby do&#x2F;end, these fit better the brains of the majority of programmers.</i><p>You have no idea whether this is actually true, or whether people have just fit their brains to what is out there.<p>The idea that programming language syntax fits people&#x27;s brains rings untrue for anyone who has watched beginners struggle with it, or remembers being one.</div><br/><div id="40702943" class="c"><input type="checkbox" id="c-40702943" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40701398">parent</a><span>|</span><a href="#40702367">next</a><span>|</span><label class="collapse" for="c-40702943">[-]</label><label class="expand" for="c-40702943">[1 more]</label></div><br/><div class="children"><div class="content">Plus, add a heaping tablespoon of survivorship bias.<p>1. Many people try programming.<p>2. The vast majority of the people who try programming are subject to external forces that guide them to whatever they learn and use.<p>3. Out of these, a certain fractions stick with it and are found programming in the long run, even working in it.<p>We could easily conclude (probably quite wrongly) that the popular languages turn people away from programming, except for a few weirdos for whom they click.</div><br/></div></div></div></div><div id="40702367" class="c"><input type="checkbox" id="c-40702367" checked=""/><div class="controls bullet"><span class="by">jimbokun</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700433">parent</a><span>|</span><a href="#40701398">prev</a><span>|</span><a href="#40701656">next</a><span>|</span><label class="collapse" for="c-40702367">[-]</label><label class="expand" for="c-40702367">[1 more]</label></div><br/><div class="children"><div class="content">When Lisp was popular, developers learned it as easily or easier than any other language.</div><br/></div></div><div id="40701656" class="c"><input type="checkbox" id="c-40701656" checked=""/><div class="controls bullet"><span class="by">pragmatic</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700433">parent</a><span>|</span><a href="#40702367">prev</a><span>|</span><a href="#40701094">next</a><span>|</span><label class="collapse" for="c-40701656">[-]</label><label class="expand" for="c-40701656">[2 more]</label></div><br/><div class="children"><div class="content">Significant white space would have been a disaster on the web.<p>As much as everyone poops on js it is a very forgiving language for embedding.</div><br/><div id="40702234" class="c"><input type="checkbox" id="c-40702234" checked=""/><div class="controls bullet"><span class="by">skydhash</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40701656">parent</a><span>|</span><a href="#40701094">next</a><span>|</span><label class="collapse" for="c-40702234">[-]</label><label class="expand" for="c-40702234">[1 more]</label></div><br/><div class="children"><div class="content">JS is fine for scripting, sprinkling a bit of interactivity on a page. The issue is when you want to create whole software out of it, and the last thing you want is forgiveness. You want the compiler and linter complaining loudly.</div><br/></div></div></div></div><div id="40701094" class="c"><input type="checkbox" id="c-40701094" checked=""/><div class="controls bullet"><span class="by">troad</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700433">parent</a><span>|</span><a href="#40701656">prev</a><span>|</span><a href="#40700513">next</a><span>|</span><label class="collapse" for="c-40701094">[-]</label><label class="expand" for="c-40701094">[6 more]</label></div><br/><div class="children"><div class="content">Very much a personal anecdote, but I spent about a month earlier this year seriously learning various Lisps (CL, Racket Scheme, Clojure). I stopped when it clicked for me - Lisps are a mess. Everything I wanted from Lisp I found in Haskell.<p>I&#x27;m reasonably confident that all the anecdotes you hear about 10x improvements from switching to Lisp are just programmers learning about functional programming and good design patterns for the first time. But those aren&#x27;t contingent on using a Lisp, and I&#x27;d argue using Lisp brings an enormous amount of cruft and baggage that makes FP seem far more alien and difficult than it needs to be.</div><br/><div id="40701348" class="c"><input type="checkbox" id="c-40701348" checked=""/><div class="controls bullet"><span class="by">7thaccount</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40701094">parent</a><span>|</span><a href="#40702215">next</a><span>|</span><label class="collapse" for="c-40701348">[-]</label><label class="expand" for="c-40701348">[4 more]</label></div><br/><div class="children"><div class="content">The 10x seems to mostly have been from programmers switching from extremely low level languages like C++ to something far higher level. Paul Graham also talks about macros in his well known essay, but I honestly think a lot of the value one gets from Lisp can be found with Python. There are a lot of things you don&#x27;t have to worry about like manual memory management and so on. Python isn&#x27;t as fast as lisp or as beautiful (opinion), but the ecosystem is very impressive and the community isn&#x27;t as fractured as the lisp community (for example see the bipolar lisp programmer essay).<p>I don&#x27;t think FP by itself is that massive of a win despite what some dubious studies or zealots say, but it&#x27;s certainly better than enterprise Java. I&#x27;ve read my fair share of horror stories of Haskell in production too.</div><br/><div id="40701524" class="c"><input type="checkbox" id="c-40701524" checked=""/><div class="controls bullet"><span class="by">troad</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40701348">parent</a><span>|</span><a href="#40702449">next</a><span>|</span><label class="collapse" for="c-40701524">[-]</label><label class="expand" for="c-40701524">[2 more]</label></div><br/><div class="children"><div class="content">Ultimately, programming languages are tools, and different tools are appropriate for different jobs.<p>There&#x27;s nothing stopping you from writing a massively-scaling e-commerce site in Verilog and running it on an FPGA, but it - uh - probably isn&#x27;t the soundest course of action.</div><br/><div id="40701646" class="c"><input type="checkbox" id="c-40701646" checked=""/><div class="controls bullet"><span class="by">7thaccount</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40701524">parent</a><span>|</span><a href="#40702449">next</a><span>|</span><label class="collapse" for="c-40701646">[-]</label><label class="expand" for="c-40701646">[1 more]</label></div><br/><div class="children"><div class="content">Yep. I&#x27;d agree with that statement. Although there&#x27;s a lot of tools I&#x27;d struggle to use practically anywhere.</div><br/></div></div></div></div><div id="40702449" class="c"><input type="checkbox" id="c-40702449" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40701348">parent</a><span>|</span><a href="#40701524">prev</a><span>|</span><a href="#40702215">next</a><span>|</span><label class="collapse" for="c-40702449">[-]</label><label class="expand" for="c-40702449">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Paul Graham also talks about macros in his well known essay<p>With all due respect, he is ironically probably the biggest blub programmer.</div><br/></div></div></div></div><div id="40702215" class="c"><input type="checkbox" id="c-40702215" checked=""/><div class="controls bullet"><span class="by">mikebenfield</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40701094">parent</a><span>|</span><a href="#40701348">prev</a><span>|</span><a href="#40700513">next</a><span>|</span><label class="collapse" for="c-40702215">[-]</label><label class="expand" for="c-40702215">[1 more]</label></div><br/><div class="children"><div class="content">I think the idea that Lisp was so much more productive than other languages originates from a much earlier time. But now the most important features of Lisp - like garbage collection - are commonly available in most languages.</div><br/></div></div></div></div><div id="40700513" class="c"><input type="checkbox" id="c-40700513" checked=""/><div class="controls bullet"><span class="by">zarathustreal</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700433">parent</a><span>|</span><a href="#40701094">prev</a><span>|</span><a href="#40701843">next</a><span>|</span><label class="collapse" for="c-40700513">[-]</label><label class="expand" for="c-40700513">[2 more]</label></div><br/><div class="children"><div class="content">I agree with most of what you said here but I want to emphasize that this is not necessarily a good outcome. Fitting the brains of corporate devs is not a metric to measure if your goal is to make the best tool for the job - the majority of corporate devs are extremely mediocre at their job even with a language that they’re not scared of.<p>All that to say, I completely emphatically agree with the original comment. The world would have been so much better off with Scheme as the language of the web.</div><br/><div id="40700616" class="c"><input type="checkbox" id="c-40700616" checked=""/><div class="controls bullet"><span class="by">ralphc</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700513">parent</a><span>|</span><a href="#40701843">next</a><span>|</span><label class="collapse" for="c-40700616">[-]</label><label class="expand" for="c-40700616">[1 more]</label></div><br/><div class="children"><div class="content">If the &quot;job&quot; is to make lots and lots of software, even if most of it is mediocre, then the best tool is what will enable millions of mediocre developers to develop, not just thousands of elite developers.</div><br/></div></div></div></div><div id="40701843" class="c"><input type="checkbox" id="c-40701843" checked=""/><div class="controls bullet"><span class="by">binary132</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700433">parent</a><span>|</span><a href="#40700513">prev</a><span>|</span><a href="#40703170">next</a><span>|</span><label class="collapse" for="c-40701843">[-]</label><label class="expand" for="c-40701843">[1 more]</label></div><br/><div class="children"><div class="content">There is so much begging the question in this thread that it’s absolutely mind-boggling.</div><br/></div></div><div id="40703170" class="c"><input type="checkbox" id="c-40703170" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700433">parent</a><span>|</span><a href="#40701843">prev</a><span>|</span><a href="#40701634">next</a><span>|</span><label class="collapse" for="c-40703170">[-]</label><label class="expand" for="c-40703170">[1 more]</label></div><br/><div class="children"><div class="content">People aren&#x27;t born familiar with C style syntax. Quite the opposite: many people struggle with it for a long time! Back in the day it super common to get frustrated because you missed off a semicolon or something. Nowadays IDEs probably help, but what&#x27;s the point of syntax that the computer could write for you?</div><br/></div></div><div id="40701634" class="c"><input type="checkbox" id="c-40701634" checked=""/><div class="controls bullet"><span class="by">swagmoney1606</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700433">parent</a><span>|</span><a href="#40703170">prev</a><span>|</span><a href="#40700341">next</a><span>|</span><label class="collapse" for="c-40701634">[-]</label><label class="expand" for="c-40701634">[1 more]</label></div><br/><div class="children"><div class="content">&gt;The only way it would have &quot;benefited&quot; would be that the web would only be developed by lisp programmers.<p>Millions have learned javascript because it is the technology of the web. Are they better off?<p>So many people have been introduced to programming, computer science, and programs through the abstractions provided by javascript, and that sucks</div><br/></div></div></div></div><div id="40700341" class="c"><input type="checkbox" id="c-40700341" checked=""/><div class="controls bullet"><span class="by">snek_case</span><span>|</span><a href="#40699913">parent</a><span>|</span><a href="#40700433">prev</a><span>|</span><a href="#40700443">next</a><span>|</span><label class="collapse" for="c-40700341">[-]</label><label class="expand" for="c-40700341">[2 more]</label></div><br/><div class="children"><div class="content">JavaScript was originally developed in two weeks due to time constraints from Brendan Eich&#x27;s employer. It would probably have just as many design mistakes if he had stuck with a scheme-like syntax instead. It&#x27;s just hard to create a well-designed language in such a short amount of time.</div><br/><div id="40701279" class="c"><input type="checkbox" id="c-40701279" checked=""/><div class="controls bullet"><span class="by">prisenco</span><span>|</span><a href="#40699913">root</a><span>|</span><a href="#40700341">parent</a><span>|</span><a href="#40700443">next</a><span>|</span><label class="collapse" for="c-40701279">[-]</label><label class="expand" for="c-40701279">[1 more]</label></div><br/><div class="children"><div class="content">Yes, Javascript is one of the seminal &quot;sales already signed the contract&quot; situations in tech.<p>Given the circumstances, it&#x27;s amazing javascript isn&#x27;t way worse.</div><br/></div></div></div></div><div id="40700443" class="c"><input type="checkbox" id="c-40700443" checked=""/><div class="controls bullet"><span class="by">odyssey7</span><span>|</span><a href="#40699913">parent</a><span>|</span><a href="#40700341">prev</a><span>|</span><a href="#40699951">next</a><span>|</span><label class="collapse" for="c-40700443">[-]</label><label class="expand" for="c-40700443">[1 more]</label></div><br/><div class="children"><div class="content">ECMAScript 2015: proper tail calls are now in the spec<p>Chromium: we’re not doing proper tail calls</div><br/></div></div><div id="40699951" class="c"><input type="checkbox" id="c-40699951" checked=""/><div class="controls bullet"><span class="by">fire_lake</span><span>|</span><a href="#40699913">parent</a><span>|</span><a href="#40700443">prev</a><span>|</span><a href="#40701865">next</a><span>|</span><label class="collapse" for="c-40699951">[-]</label><label class="expand" for="c-40699951">[1 more]</label></div><br/><div class="children"><div class="content">Hey, at least there’s Clojurescript.</div><br/></div></div><div id="40701865" class="c"><input type="checkbox" id="c-40701865" checked=""/><div class="controls bullet"><span class="by">ipnon</span><span>|</span><a href="#40699913">parent</a><span>|</span><a href="#40699951">prev</a><span>|</span><a href="#40700867">next</a><span>|</span><label class="collapse" for="c-40701865">[-]</label><label class="expand" for="c-40701865">[1 more]</label></div><br/><div class="children"><div class="content">I should write a Lisp browser.</div><br/></div></div><div id="40700867" class="c"><input type="checkbox" id="c-40700867" checked=""/><div class="controls bullet"><span class="by">potsandpans</span><span>|</span><a href="#40699913">parent</a><span>|</span><a href="#40701865">prev</a><span>|</span><a href="#40700733">next</a><span>|</span><label class="collapse" for="c-40700867">[-]</label><label class="expand" for="c-40700867">[1 more]</label></div><br/><div class="children"><div class="content">having call&#x2F;cc would make my life better</div><br/></div></div></div></div><div id="40700733" class="c"><input type="checkbox" id="c-40700733" checked=""/><div class="controls bullet"><span class="by">rscho</span><span>|</span><a href="#40699913">prev</a><span>|</span><a href="#40699891">next</a><span>|</span><label class="collapse" for="c-40700733">[-]</label><label class="expand" for="c-40700733">[10 more]</label></div><br/><div class="children"><div class="content">People who complain about parentheses have never tried structural editing. Change my mind!</div><br/><div id="40701160" class="c"><input type="checkbox" id="c-40701160" checked=""/><div class="controls bullet"><span class="by">pas</span><span>|</span><a href="#40700733">parent</a><span>|</span><a href="#40701390">prev</a><span>|</span><a href="#40699891">next</a><span>|</span><label class="collapse" for="c-40701160">[-]</label><label class="expand" for="c-40701160">[8 more]</label></div><br/><div class="children"><div class="content">I tried Racked with the recommended IDE setup (VScode), does that have structural editing?<p>Here are my notes from 2023-07:<p><a href="https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;more&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;more&#x2F;index.html</a><p><pre><code>    * okay, seriously. functional programming is nice, but these fucking parenthesis are ridiculous. the VSCode extension is okay, but doesn&#x27;t help at all with formatting, etc.
    * &quot;car&quot; and &quot;cons&quot;, yeey, but &quot;first&quot; would have been so hard?
    * the whole &quot;define x &#x27;x&quot; is also meh.
    * no return, so sometimes something just takes the last one and returns.
    * there&#x27;s string-&gt;url ... why not string-&gt;parse-url .. no, would have been too verbose. MAYBE YOU COULD HAVE SAVED SPACE BY OMITTING THE FUCKING PARENTHESES
    *
</code></pre>
&#x2F; end notes<p>ehehe ... well ... I think I will keep trying it again every few years. is there a pythonish version, where indentation matters and no need for wrapping parens?</div><br/><div id="40701210" class="c"><input type="checkbox" id="c-40701210" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#40700733">root</a><span>|</span><a href="#40701160">parent</a><span>|</span><a href="#40703230">next</a><span>|</span><label class="collapse" for="c-40701210">[-]</label><label class="expand" for="c-40701210">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    * there&#x27;s string-&gt;url ... why not string-&gt;parse-url .. no, would have been too verbose. MAYBE YOU COULD HAVE SAVED SPACE BY OMITTING THE FUCKING PARENTHESES

</code></pre>
<i>string-&gt;url</i> is consistent with the way they do things in Racket. Note in that same document you linked the use of <i>number-&gt;string</i> and <i>string-&gt;number</i>, the -&gt; indicates a type conversion. Along with <i>string-&gt;url</i> there is also the reverse, <i>url-&gt;string</i>, and some other conversion functions. That consistency is actually pretty nice, it means you can guess and check (&quot;I have a string and want a url, will this work?&quot; Oh, great it does!) or guess and search the docs before checking with the REPL or whatever.<p><a href="https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;net&#x2F;url.html" rel="nofollow">https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;net&#x2F;url.html</a><p><pre><code>    * &quot;car&quot; and &quot;cons&quot;, yeey, but &quot;first&quot; would have been so hard?
</code></pre>
<i>car</i> shows up once, <i>cons</i> not at all, but he does use <i>cdr</i>. <i>first</i>, <i>second</i>, and <i>rest</i> are available, I don&#x27;t know why he didn&#x27;t use it in this demonstration. If you want to use <i>first</i>, go for it.</div><br/></div></div><div id="40703230" class="c"><input type="checkbox" id="c-40703230" checked=""/><div class="controls bullet"><span class="by">rscho</span><span>|</span><a href="#40700733">root</a><span>|</span><a href="#40701160">parent</a><span>|</span><a href="#40701210">prev</a><span>|</span><a href="#40702008">next</a><span>|</span><label class="collapse" for="c-40703230">[-]</label><label class="expand" for="c-40703230">[1 more]</label></div><br/><div class="children"><div class="content">Your notes indeed suggest that you&#x27;ve not been using structural editing.<p>Aside from that, you could have tried to use `first` instead of `car`. It would&#x27;ve worked.<p>And yes, there happens to be a pythonic version named `Rhombus`, which is the flagship language of the racket system.</div><br/></div></div><div id="40702008" class="c"><input type="checkbox" id="c-40702008" checked=""/><div class="controls bullet"><span class="by">skydhash</span><span>|</span><a href="#40700733">root</a><span>|</span><a href="#40701160">parent</a><span>|</span><a href="#40703230">prev</a><span>|</span><a href="#40701796">next</a><span>|</span><label class="collapse" for="c-40702008">[-]</label><label class="expand" for="c-40702008">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>these fucking parenthesis are ridiculous</i><p>They&#x27;re just different. And once you&#x27;ve come familiar with the language, you miss s-expressions everyday, because they&#x27;re just that easy to work with, especially with something like paredit. Why? because the grammar is easy to parse and reason about. The whole code is a tree. And evaluation is mostly working from the leaves to the root.<p>&gt; <i>&quot;car&quot; and &quot;cons&quot;, yeey, but &quot;first&quot; would have been so hard?</i><p>It comes from the nature of the language. &quot;cons&quot; is to construct a pair of values, and &quot;car&quot; to get the first one, while &quot;cdr&quot; returns the second one. But lists are composed of cons cells (check how it works), and in that case you could argue for &quot;head&quot; and &quot;tail&quot; for the function names. But &quot;car&quot; and &quot;cdr&quot; were first and you could alias them easily.<p>&gt; <i>no return, so sometimes something just takes the last one and returns</i><p>The computing paradigm is expression evaluations, not sequence of instructions (although sequencing is there). An s-expression is always equivalent to something, and that something is what you&#x27;re computing. Something like (first &#x27;(&quot;name&quot; &quot;email&quot;)) is the same as &quot;name&quot;. Or (if (&gt; x 0) :pos :neg) with x = 5 is the same as (if t :pos :neg) and the same as :pos. [0]<p>No return is needed. It&#x27;s tricky when doing iteration, but whenever you&#x27;re doing sequencing (they mention that in the docs for CL), the last value is equivalent to the whole thing.<p>[0]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Lambda_calculus#Reduction" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Lambda_calculus#Reduction</a></div><br/></div></div><div id="40701796" class="c"><input type="checkbox" id="c-40701796" checked=""/><div class="controls bullet"><span class="by">crooked-v</span><span>|</span><a href="#40700733">root</a><span>|</span><a href="#40701160">parent</a><span>|</span><a href="#40702008">prev</a><span>|</span><a href="#40701651">next</a><span>|</span><label class="collapse" for="c-40701796">[-]</label><label class="expand" for="c-40701796">[3 more]</label></div><br/><div class="children"><div class="content">&gt; but these fucking parenthesis are ridiculous<p>I thoroughly agree. I am deeply into functional programming, but syntax built entirely around endless nested parentheses has never felt like anything but a nightmare to me. Doubly so because even in &#x27;clean&#x27; code it&#x27;s reusing the same syntax with what are for most coders three clearly different logical concerns (defining functions, listing statements to execute in order, and invoking functions).</div><br/><div id="40702121" class="c"><input type="checkbox" id="c-40702121" checked=""/><div class="controls bullet"><span class="by">skydhash</span><span>|</span><a href="#40700733">root</a><span>|</span><a href="#40701796">parent</a><span>|</span><a href="#40701651">next</a><span>|</span><label class="collapse" for="c-40702121">[-]</label><label class="expand" for="c-40702121">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>what are for most coders three clearly different logical concerns</i><p>That&#x27;s the imperative model which foundations is the Turing machine. Lisp comes from lambda calculus and you&#x27;re not doing the above really. At it&#x27;s core there&#x27;s the value (or the symbol that&#x27;s represent it), then the <i>abstraction</i>, which defines how to get the value, and the <i>application</i>, which let you know with what to replace unknowns (variables) in your abstraction so you can get the value. And it&#x27;s recursive.<p>A program can be a value (not that useful), an abstraction (kinda like a nice theorem), or an application (the useful choice). Defining a function is creating a named abstraction, which is just a special value. Invoking a function is applying the parameters to that abstraction, which means replacing variables to get a more simplified version with the goal to finally have a value. If you can&#x27;t get a value, that means the result is still an abstraction and then you still have to do more applications.<p>You either have a symbol or atom (which is a value) or you have a list which is an application (except the empty list, which is the same thing as nil). An abstraction is created by special forms like (defun foo (bar) ...) in CL. but the result of the latter is still a symbol. An atom is equivalent to itself, and a list is equivalent to having applied the abstraction represented by the first element to the rest. Anything else is either special forms, macros, or syntactic sugar.<p>So unless you&#x27;re applying imperative thinking to the lambda calculus model, there&#x27;s no confusion possible.</div><br/><div id="40702794" class="c"><input type="checkbox" id="c-40702794" checked=""/><div class="controls bullet"><span class="by">crooked-v</span><span>|</span><a href="#40700733">root</a><span>|</span><a href="#40702121">parent</a><span>|</span><a href="#40701651">next</a><span>|</span><label class="collapse" for="c-40702794">[-]</label><label class="expand" for="c-40702794">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t have to be <i>confused</i> by it to dislike how it ends up working out in actual code, even &quot;clean&quot; code, in terms of ease of understanding and maintainability.</div><br/></div></div></div></div></div></div><div id="40701651" class="c"><input type="checkbox" id="c-40701651" checked=""/><div class="controls bullet"><span class="by">ashton314</span><span>|</span><a href="#40700733">root</a><span>|</span><a href="#40701160">parent</a><span>|</span><a href="#40701796">prev</a><span>|</span><a href="#40699891">next</a><span>|</span><label class="collapse" for="c-40701651">[-]</label><label class="expand" for="c-40701651">[1 more]</label></div><br/><div class="children"><div class="content">DrRacket probably would have served you better. That or Emacs.<p>You might be interested in Rhombus: Racket with ML-inspired syntax. <a href="https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;rhombus&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;rhombus&#x2F;index.html</a></div><br/></div></div></div></div></div></div><div id="40699891" class="c"><input type="checkbox" id="c-40699891" checked=""/><div class="controls bullet"><span class="by">MeteorMarc</span><span>|</span><a href="#40700733">prev</a><span>|</span><a href="#40700400">next</a><span>|</span><label class="collapse" for="c-40699891">[-]</label><label class="expand" for="c-40699891">[1 more]</label></div><br/><div class="children"><div class="content">I miss the structure in the layout of this read.</div><br/></div></div><div id="40700400" class="c"><input type="checkbox" id="c-40700400" checked=""/><div class="controls bullet"><span class="by">iungret</span><span>|</span><a href="#40699891">prev</a><span>|</span><a href="#40702393">next</a><span>|</span><label class="collapse" for="c-40700400">[-]</label><label class="expand" for="c-40700400">[3 more]</label></div><br/><div class="children"><div class="content">I want a searchable resource where I give my inputs and desired output and brief description of the algorithm and it gives me the algorithm and code.<p>Same with AOCP, but I greatly prefer scheme to MIX.<p>Otherwise these works just seem like a doomsday rebuilding references rather than knowledge with any practical presentation.</div><br/><div id="40700487" class="c"><input type="checkbox" id="c-40700487" checked=""/><div class="controls bullet"><span class="by">omnicognate</span><span>|</span><a href="#40700400">parent</a><span>|</span><a href="#40701010">next</a><span>|</span><label class="collapse" for="c-40700487">[-]</label><label class="expand" for="c-40700487">[1 more]</label></div><br/><div class="children"><div class="content">SICP isn&#x27;t an algorithms book or a reference. It&#x27;s very unlike The Art of Computer Programming.</div><br/></div></div><div id="40701010" class="c"><input type="checkbox" id="c-40701010" checked=""/><div class="controls bullet"><span class="by">MrVandemar</span><span>|</span><a href="#40700400">parent</a><span>|</span><a href="#40700487">prev</a><span>|</span><a href="#40702393">next</a><span>|</span><label class="collapse" for="c-40701010">[-]</label><label class="expand" for="c-40701010">[1 more]</label></div><br/><div class="children"><div class="content">&gt;I want a searchable resource where I give my inputs and desired output and brief description of the algorithm and it gives me the algorithm and code.<p>It sounds like you&#x27;d like to outsource your problem solving and thinking. Some things require work, and from that you learn and grow, which is the greatest reward.</div><br/></div></div></div></div><div id="40702393" class="c"><input type="checkbox" id="c-40702393" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#40700400">prev</a><span>|</span><label class="collapse" for="c-40702393">[-]</label><label class="expand" for="c-40702393">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an interesting text for sure, and even became a bit of a meme, but I think SICP has only contributed to the trend of overabstraction and increasing inefficiency in software.</div><br/></div></div></div></div></div></div></div></body></html>