<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1727254868408" as="style"/><link rel="stylesheet" href="styles.css?v=1727254868408"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://catskull.net/thoughts-on-debugging.html">Thoughts on Debugging</a> <span class="domain">(<a href="https://catskull.net">catskull.net</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>15 comments</span></div><br/><div><div id="41644596" class="c"><input type="checkbox" id="c-41644596" checked=""/><div class="controls bullet"><span class="by">vardump</span><span>|</span><a href="#41644153">next</a><span>|</span><label class="collapse" for="c-41644596">[-]</label><label class="expand" for="c-41644596">[2 more]</label></div><br/><div class="children"><div class="content">From the article:<p><pre><code>  Here’s my one simple rule for debugging:
  
  Reproduce the issue.
</code></pre>
<i>Unless</i> it&#x27;s one of those cursed things installed at the customer thousands of miles away that never happens back in the lab.<p>Some things can be incredibly hard to debug and can depend on the craziest of things you&#x27;d never even consider possible. Like a thunderstorm causing voltage spikes that very subtly damage the equipment causing subtle failures a few months later. Sometimes that &quot;software bug&quot; turns out to be hardware in weird ways. Or issues like <a href="https:&#x2F;&#x2F;web.mit.edu&#x2F;jemorris&#x2F;humor&#x2F;500-miles" rel="nofollow">https:&#x2F;&#x2F;web.mit.edu&#x2F;jemorris&#x2F;humor&#x2F;500-miles</a> – every person who&#x27;s debugging weird issues should read that.<p>Once you can actually reproduce the issue, you&#x27;ve often done 80-99+% of the work already.</div><br/><div id="41644999" class="c"><input type="checkbox" id="c-41644999" checked=""/><div class="controls bullet"><span class="by">virgilp</span><span>|</span><a href="#41644596">parent</a><span>|</span><a href="#41644153">next</a><span>|</span><label class="collapse" for="c-41644999">[-]</label><label class="expand" for="c-41644999">[1 more]</label></div><br/><div class="children"><div class="content">It is true that for many (especially concurrency&#x2F;distributed-systems-related) bugs, reproducing the issue might be the hardest part... but that&#x27;s not always true.<p>Long time ago, I was working on a C++ compiler for an embedded processor. Customer complains that when they turn on optimization, code fails. 100% reproducible, just put &quot;-O3&quot; and it fails, with &quot;-O0&quot; it works. Now, we&#x27;re used to these bug reports, it&#x27;s often a bug in the original software (like relying on undefined behaviour), but we manage to get the code, it looks good &#x2F; we don&#x27;t find anything strange. Can&#x27;t run it, it only works on the customer board (which is their custom proprietary hardware, using  our microprocessor). We look through the assembly, can&#x27;t find any obvious optimization error that the compiler made. After much (remote) debugging, it turns out that it was a fault in their memory system.</div><br/></div></div></div></div><div id="41644153" class="c"><input type="checkbox" id="c-41644153" checked=""/><div class="controls bullet"><span class="by">avidiax</span><span>|</span><a href="#41644596">prev</a><span>|</span><a href="#41644630">next</a><span>|</span><label class="collapse" for="c-41644153">[-]</label><label class="expand" for="c-41644153">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Here’s my one simple rule for debugging:<p>&gt; Reproduce the issue.<p>&gt; . . .<p>&gt; I’m not sure that I’ve ever worked on a hard problem . . .<p>I agree, the author has probably not worked on hard problems.<p>There are many situations where either a) reproducing the problem is extremely elusive, or b) reproduction is easy, but the cause is especially elusive, or c) organizational issues prevent access to the system, to source code, or to people willing to investigate and&#x2F;or solve the issue.<p>Some examples:<p>For A, the elusive reproduction, I saw an issue where we had an executive escalation that their laptop would always blue screen shortly after boot up. Nobody could reproduce this issue. Telemetry showed nobody else had this issue. Changing hardware didn&#x27;t fix it. Only this executive had the anti-Midas touch to cause the issue. Turned out the executive lived on a large parcel, and had exactly one WiFi network visible. Some code parsing that list of WiFi APs had an off-by-one error which caused a BSOD. A large portion of wireless technology (Bluetooth&#x2F;Thread&#x2F;WiFi&#x2F;cellular) bugs fall into this category.<p>For B, the easy to repro but still difficult, I&#x27;ve seen numerous bugs that cause stack corruption, random memory corruption, or trigger a hardware flaw that freezes or resets the system. These types of issues are terrible to debug, because either the logs aren&#x27;t available (system comes down before the final moments), or because the culprit doesn&#x27;t log anything and never harms themselves, only an innocent victim. Time-travel tracing is often the best solution, but is also often unavailable. Bisecting the code changes is sometimes little help in a busy codebase, since the culprit is often far away from their victims.<p>Category C is also pretty common if you are integrating systems. Vendors will have closed source and be unable or unwilling to admit even the possibility of fault, help with an investigation, or commit to a fix. Partners will have ship blocking bugs in hardware that they just can&#x27;t show you or share with you, but it must nonetheless get fixed. You will often end up shipping workarounds for errors in code you don&#x27;t control, or carefully instrumenting code to uncover the partner&#x27;s issues.</div><br/><div id="41644282" class="c"><input type="checkbox" id="c-41644282" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#41644153">parent</a><span>|</span><a href="#41644630">next</a><span>|</span><label class="collapse" for="c-41644282">[-]</label><label class="expand" for="c-41644282">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I agree, the author has probably not worked on hard problems.<p>Conversely, if you focus on creating a repro you <i>make</i> problems easy.<p>I’m a little surprised the OP doesn’t mention debuggers. For whatever reason many modern Linux programmers seem to have never and used a debugger and rely almost entirely on printf. Which is utterly bonkers to me! If you can repro and issue and trap it in a debugger then you’ve done 90% of the work.</div><br/><div id="41644628" class="c"><input type="checkbox" id="c-41644628" checked=""/><div class="controls bullet"><span class="by">vardump</span><span>|</span><a href="#41644153">root</a><span>|</span><a href="#41644282">parent</a><span>|</span><a href="#41644477">next</a><span>|</span><label class="collapse" for="c-41644628">[-]</label><label class="expand" for="c-41644628">[1 more]</label></div><br/><div class="children"><div class="content">Debuggers are not great when you have a bug that occurs between multiple CPU cores, hardware device timing, etc.<p>In those cases, a debugger just can&#x27;t stop the world, so back to printf it is.</div><br/></div></div><div id="41644477" class="c"><input type="checkbox" id="c-41644477" checked=""/><div class="controls bullet"><span class="by">glandium</span><span>|</span><a href="#41644153">root</a><span>|</span><a href="#41644282">parent</a><span>|</span><a href="#41644628">prev</a><span>|</span><a href="#41644630">next</a><span>|</span><label class="collapse" for="c-41644477">[-]</label><label class="expand" for="c-41644477">[1 more]</label></div><br/><div class="children"><div class="content">And if you can repro in rr, you&#x27;ve done 99% of the work most of the time.</div><br/></div></div></div></div></div></div><div id="41644630" class="c"><input type="checkbox" id="c-41644630" checked=""/><div class="controls bullet"><span class="by">lordnacho</span><span>|</span><a href="#41644153">prev</a><span>|</span><a href="#41645198">next</a><span>|</span><label class="collapse" for="c-41644630">[-]</label><label class="expand" for="c-41644630">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Reproduce the issue.<p>Once you have done this, you are already over the hump. It&#x27;s like being the first rider over the last mountain on the Tour de France stage, you&#x27;ve more or less won by doing that.<p>I&#x27;m not sure I even consider it a challenge if the issue is easily reproduced. You will simply grind out the solution once you have the reproduction done.<p>The real bugs are the ones that you cannot replicate. The kind of thing that breaks once a week on 10 continuously running machines. You can&#x27;t scale that system to 1000 or more with the bug around, you&#x27;ll be swamped with reports. But you also can&#x27;t fix it because the conditions to reproduce it are so elusive that your logs aren&#x27;t useful. You don&#x27;t know if all the errors have the same root cause.<p>Typically the kind of thing that creates a lot of paths to check is &quot;manual multithreading&quot;. The kind of thing where you have a bunch of threads, each locking and unlocking (or forgetting either) access to shared data in a particular way. The number of ways where &quot;this read and then that writes&quot; explodes quite fast with such code, and it also explodes in a way that isn&#x27;t obvious from the code. Sprinkling log outputs over such code can change the frequency of the errors.</div><br/></div></div><div id="41645198" class="c"><input type="checkbox" id="c-41645198" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#41644630">prev</a><span>|</span><a href="#41644437">next</a><span>|</span><label class="collapse" for="c-41645198">[-]</label><label class="expand" for="c-41645198">[1 more]</label></div><br/><div class="children"><div class="content">My rule for debugging is to park your assumptions and scientifically invalidate each thing you think might be the issue. It&#x27;s usually something simple and your initial assumptions are probably wrong. Which is why trying to invalidate those is a productive course of action.<p>If you catch yourself thinking, it&#x27;s probably X. Then you should try to prove yourself wrong. Because if your are, you are looking in the wrong place. And if you are struggling to understand why a thing is happening you can safely assume that something you assume to be true is in fact not true. Invalidating that assumption would be how you figure out why.<p>Assumptions can range from &quot;there&#x27;s a bug in a library we are using&quot;, &quot;the problem must have been introduced recently&quot;, &quot;the problem only happens when we do X&quot;, etc. Most of these things are fairly simple to test.<p>The other day I was debugging someone else&#x27;s code that I inherited. I started looking at the obvious place in the code, adding some logging and I was getting nowhere. Then I decided to try to reproduce the problem in a place where that code was definitely not used to challenge the assumption I was making that the problem even was in that part of the code. I instantly managed to reproduce the issue. I wasted two hours staring at that code and trying to understand it.<p>In the end, the issue was with a weird bug that only showed up when using our software in the US (or as it turns out, the western hemisphere). The problem wasn&#x27;t the functionality I was testing but everything that used negative coordinates.<p>Once I narrowed it down to a simple math problem with negative longitudes and I realized the problem was a missing call to abs where we subtracting values (subtracting a negative value means you are adding it). That function was used in four different places; each of those was broken. Easy fix and the problem went away. Being in Europe (only positive longitudes), we just never properly tested that part of our software in the US. The bug had lurked there for over a year. Kind of embarrassing really.<p>Which is why randomizing your inputs in unit tests is important. We were testing with just one hard coded coordinate. The fix included me adding proper unit tests for the algorithm.</div><br/></div></div><div id="41644437" class="c"><input type="checkbox" id="c-41644437" checked=""/><div class="controls bullet"><span class="by">fch42</span><span>|</span><a href="#41645198">prev</a><span>|</span><a href="#41644184">next</a><span>|</span><label class="collapse" for="c-41644437">[-]</label><label class="expand" for="c-41644437">[1 more]</label></div><br/><div class="children"><div class="content">I follow, yet I disagree that &quot;first priority&quot; must always be a reproducer. There are a lot of conditions that can be rootcaused clearly from diagnostics; say, Linux kernel code deadlocks can exhibit as two different (in their stacks) repeatedly shown &quot;task stuck for more than ... seconds&quot; messages; the remainder follows from the code (to see the abba-lock-ordering violation).
There&#x27;s a certain fetishisation of reproducers not unlike the fetishisation of build-time testing - to denigrate a bug because &quot;you can&#x27;t reproduce it&quot; or &quot;if it doesn&#x27;t show in the tests it needn&#x27;t be changed&quot;. Personally, that mindset irks me.
Fortunately, most developers are happy to learn more about their code any which way. And debugging, tracing, monitoring is cool in itself.</div><br/></div></div><div id="41644184" class="c"><input type="checkbox" id="c-41644184" checked=""/><div class="controls bullet"><span class="by">dave333</span><span>|</span><a href="#41644437">prev</a><span>|</span><a href="#41644279">next</a><span>|</span><label class="collapse" for="c-41644184">[-]</label><label class="expand" for="c-41644184">[2 more]</label></div><br/><div class="children"><div class="content">Reproducing the problem not only allows in depth debugging but the conditions needed to reproduce can give clues as to the cause. The most significant&#x2F;interesting bug of my career was a problem in 1978 with a Linotron 606 phototypesetter at the Auckland Star newspaper in NZ that occasionally would have a small patch of mangled text at a random place in the job. Reprint the text again and the problem would disappear. The problem had been outstanding for several months as it wasn&#x27;t a showstopper. The hardware engineer and I figured it might be related to how the fonts were pulled off disk and put in the typesetting memory buffer so we set up some artificial disk transfer errors where every 50th transfer would fail and sure enough this made the problem happen 100% of the time. From there simply inspecting the code that transferred the fonts we found the problem which was that an extra blank character used for filling the background in reverse video (white text on black background) which was put at the top of the buffer was omitted when things were redone after a disk transfer error. So all the character addresses in the buffer were incorrect resulting in mangled characters.</div><br/><div id="41644509" class="c"><input type="checkbox" id="c-41644509" checked=""/><div class="controls bullet"><span class="by">spc476</span><span>|</span><a href="#41644184">parent</a><span>|</span><a href="#41644279">next</a><span>|</span><label class="collapse" for="c-41644509">[-]</label><label class="expand" for="c-41644509">[1 more]</label></div><br/><div class="children"><div class="content">But you had a theory you could test.  The hardest bug I had to debug (over a month of constant work) was very difficult to reproduce on demand.  The program (a single threaded server) would crash after running a few hours in production.  I was able to get it to crash on the development server only if I let it run handling requests for a few days.  The core dumps (and yes, there were plenty of core dumps to look at) were inconsistent---each crash was in a different location.
There was no reason I could find that caused the crashes, so no theory I could really test.<p>I was able to locate the root cause, which was calling a non-async-signal safe function from a signal handler, but that came only after staring at the code and thinking hard for a long time.</div><br/></div></div></div></div><div id="41644279" class="c"><input type="checkbox" id="c-41644279" checked=""/><div class="controls bullet"><span class="by">pdpi</span><span>|</span><a href="#41644184">prev</a><span>|</span><a href="#41644823">next</a><span>|</span><label class="collapse" for="c-41644279">[-]</label><label class="expand" for="c-41644279">[1 more]</label></div><br/><div class="children"><div class="content">In a narrower sense of the word, one technique I developed early on in my career that I don’t see mentioned very often is exploratory debugging. At its most basic, you run the program, look at the output and find the output string in the source code. Then you set a breakpoint there, and go again. You’re now in a place where you can start understanding the program by working backwards from the output.<p>One thing that makes me sad about the pervasive use of async&#x2F;await-style programming is that it usually breaks the stack in a way that makes this technique a bit useless.</div><br/></div></div><div id="41644823" class="c"><input type="checkbox" id="c-41644823" checked=""/><div class="controls bullet"><span class="by">toolslive</span><span>|</span><a href="#41644279">prev</a><span>|</span><a href="#41644088">next</a><span>|</span><label class="collapse" for="c-41644823">[-]</label><label class="expand" for="c-41644823">[1 more]</label></div><br/><div class="children"><div class="content">He has a point about reproducing the issue. However, tracing is better than logging, and for god&#x27;s sake, put a f*cking breakpoint.</div><br/></div></div><div id="41644088" class="c"><input type="checkbox" id="c-41644088" checked=""/><div class="controls bullet"><span class="by">z33k</span><span>|</span><a href="#41644823">prev</a><span>|</span><label class="collapse" for="c-41644088">[-]</label><label class="expand" for="c-41644088">[1 more]</label></div><br/><div class="children"><div class="content">”If you don’t love your logging system, proactively fix that problem.”<p>Really, you have a ”one-system” where you can see _ALL_ the logs? I don’t believe that. This whole software thing is abstractions everywhere, and we are probably using some abstraction somewhere that isn’t compatible with this fabled ”one-system”.<p>Often the most debugging takes place on the least observable systems.</div><br/></div></div></div></div></div></div></div></body></html>