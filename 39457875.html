<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1708592470782" as="style"/><link rel="stylesheet" href="styles.css?v=1708592470782"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://two-wrongs.com/useful-uses-of-cat">Useful Uses of cat</a> <span class="domain">(<a href="https://two-wrongs.com">two-wrongs.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>133 comments</span></div><br/><div><div id="39464768" class="c"><input type="checkbox" id="c-39464768" checked=""/><div class="controls bullet"><span class="by">unhammer</span><span>|</span><a href="#39458657">next</a><span>|</span><label class="collapse" for="c-39464768">[-]</label><label class="expand" for="c-39464768">[1 more]</label></div><br/><div class="children"><div class="content">I have an old note named the same as this blog post:<p><pre><code>    cat &#x2F;dev&#x2F;sdb &gt; backup.img # make a disk image

    cat &#x2F;dev&#x2F;sdb &gt; &#x2F;dev&#x2F;sdc   # clone disk

    cat ~&#x2F;Downloads&#x2F;*         # play Russian roulette with your terminal

    cat &gt; file                # minimalistic text editor

    grep -r bongo . | cat     # shorter than typing --color=never

    cat -v file               # cause 20 points of damage to wizards of bell labs

    cat file &gt; file           # empty a file without removing the file

    cat meow meow &gt; meows     # duplicate file contents</code></pre></div><br/></div></div><div id="39458657" class="c"><input type="checkbox" id="c-39458657" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#39464768">prev</a><span>|</span><a href="#39459941">next</a><span>|</span><label class="collapse" for="c-39458657">[-]</label><label class="expand" for="c-39458657">[34 more]</label></div><br/><div class="children"><div class="content">The reason these sequences of commands always start with cat, for me at least, is that I just cat’d the file only to find it was too long or noisy.<p><pre><code>    cat filename.txt 

    Up | grep “thing I want”
</code></pre>
Is fewer keystrokes than<p><pre><code>    cat filename.txt

    grep “thing I want” filename.txt
</code></pre>
Or more likely<p><pre><code>    cat filename.txt

    grep filename.txt “thing I want” 

    grep “thing I want” filename.txt</code></pre></div><br/><div id="39458899" class="c"><input type="checkbox" id="c-39458899" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#39458657">parent</a><span>|</span><a href="#39459495">next</a><span>|</span><label class="collapse" for="c-39458899">[-]</label><label class="expand" for="c-39458899">[12 more]</label></div><br/><div class="children"><div class="content">You can also do:<p><pre><code>    grep “thing I want” !$
</code></pre>
Bash (and similar) will replace !$ with the last parameter of the previous command.<p>This is a trick I’ve used lots when wanting to perform a non-piping operation on a command I’ve ‘cat’ed (eg ‘rm -v !$’)<p>I’d never criticise anyone for “useless” use of ‘cat’ though. If the fork() overhead was really that critical then it wouldn’t be a shell command to begin with.</div><br/><div id="39459195" class="c"><input type="checkbox" id="c-39459195" checked=""/><div class="controls bullet"><span class="by">mmh0000</span><span>|</span><a href="#39458657">root</a><span>|</span><a href="#39458899">parent</a><span>|</span><a href="#39459230">next</a><span>|</span><label class="collapse" for="c-39459195">[-]</label><label class="expand" for="c-39459195">[6 more]</label></div><br/><div class="children"><div class="content">Even easier, press alt+. (fewer keystrokes too! cli golf is fun), it&#x27;ll copy-and-paste the last parameter from the previous command. If you press . multiple times it&#x27;ll go further back into your history.</div><br/><div id="39463917" class="c"><input type="checkbox" id="c-39463917" checked=""/><div class="controls bullet"><span class="by">smackeyacky</span><span>|</span><a href="#39458657">root</a><span>|</span><a href="#39459195">parent</a><span>|</span><a href="#39463155">next</a><span>|</span><label class="collapse" for="c-39463917">[-]</label><label class="expand" for="c-39463917">[2 more]</label></div><br/><div class="children"><div class="content">Not sure that would work everywhere but !$ definitely does for retrieving the last arg of the last command.  40 years of muscle memory right there</div><br/><div id="39464226" class="c"><input type="checkbox" id="c-39464226" checked=""/><div class="controls bullet"><span class="by">penguin_booze</span><span>|</span><a href="#39458657">root</a><span>|</span><a href="#39463917">parent</a><span>|</span><a href="#39463155">next</a><span>|</span><label class="collapse" for="c-39464226">[-]</label><label class="expand" for="c-39464226">[1 more]</label></div><br/><div class="children"><div class="content">Alt + . is a readline binding, so that&#x27;s available wherever GNU readline is used. Immediate examples that come to mind are Python PDB shell and GDB.</div><br/></div></div></div></div><div id="39463155" class="c"><input type="checkbox" id="c-39463155" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#39458657">root</a><span>|</span><a href="#39459195">parent</a><span>|</span><a href="#39463917">prev</a><span>|</span><a href="#39459230">next</a><span>|</span><label class="collapse" for="c-39463155">[-]</label><label class="expand" for="c-39463155">[3 more]</label></div><br/><div class="children"><div class="content">Often the shortcuts that people point out in these threads are too niche for me to remember, but that seems like a pretty great one, I’ll try to remember it.</div><br/><div id="39463957" class="c"><input type="checkbox" id="c-39463957" checked=""/><div class="controls bullet"><span class="by">imp0cat</span><span>|</span><a href="#39458657">root</a><span>|</span><a href="#39463155">parent</a><span>|</span><a href="#39459230">next</a><span>|</span><label class="collapse" for="c-39463957">[-]</label><label class="expand" for="c-39463957">[2 more]</label></div><br/><div class="children"><div class="content">alt + . is easy to remember, but did you know you there is a way to recall any argument from the previous command in bash?<p>Press Escape, then the number of the argument from the previous command, confirm with Ctrl+Alt+Y.<p>Example:<p><pre><code>  &gt; command arg1 arg2 arg3
</code></pre>
Escape, 1, Ctrl+Alt+Y gives you arg1.</div><br/><div id="39464241" class="c"><input type="checkbox" id="c-39464241" checked=""/><div class="controls bullet"><span class="by">penguin_booze</span><span>|</span><a href="#39458657">root</a><span>|</span><a href="#39463957">parent</a><span>|</span><a href="#39459230">next</a><span>|</span><label class="collapse" for="c-39464241">[-]</label><label class="expand" for="c-39464241">[1 more]</label></div><br/><div class="children"><div class="content">alt + &lt;number&gt; + alt + . should do the same thing. No need for ctrl+alt+y, is there?</div><br/></div></div></div></div></div></div></div></div><div id="39459230" class="c"><input type="checkbox" id="c-39459230" checked=""/><div class="controls bullet"><span class="by">bumblebeast</span><span>|</span><a href="#39458657">root</a><span>|</span><a href="#39458899">parent</a><span>|</span><a href="#39459195">prev</a><span>|</span><a href="#39463144">next</a><span>|</span><label class="collapse" for="c-39459230">[-]</label><label class="expand" for="c-39459230">[2 more]</label></div><br/><div class="children"><div class="content">I just use &lt;esc&gt;. On the command line to bring back the last argument.<p>Then I can look at it before hitting return</div><br/><div id="39460382" class="c"><input type="checkbox" id="c-39460382" checked=""/><div class="controls bullet"><span class="by">harrisi</span><span>|</span><a href="#39458657">root</a><span>|</span><a href="#39459230">parent</a><span>|</span><a href="#39463144">next</a><span>|</span><label class="collapse" for="c-39460382">[-]</label><label class="expand" for="c-39460382">[1 more]</label></div><br/><div class="children"><div class="content">shopt -s histverify</div><br/></div></div></div></div><div id="39463144" class="c"><input type="checkbox" id="c-39463144" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#39458657">root</a><span>|</span><a href="#39458899">parent</a><span>|</span><a href="#39459230">prev</a><span>|</span><a href="#39464091">next</a><span>|</span><label class="collapse" for="c-39463144">[-]</label><label class="expand" for="c-39463144">[1 more]</label></div><br/><div class="children"><div class="content">I’m sure there are cases where the fork overhead matters. But, alas, I don’t type or read that fast.</div><br/></div></div><div id="39464091" class="c"><input type="checkbox" id="c-39464091" checked=""/><div class="controls bullet"><span class="by">77pt77</span><span>|</span><a href="#39458657">root</a><span>|</span><a href="#39458899">parent</a><span>|</span><a href="#39463144">prev</a><span>|</span><a href="#39462386">next</a><span>|</span><label class="collapse" for="c-39464091">[-]</label><label class="expand" for="c-39464091">[1 more]</label></div><br/><div class="children"><div class="content">!! is the previous command line BTW<p>useful shorthand<p>&gt; sudo !!<p>for example.<p>Again, bash specific.</div><br/></div></div><div id="39462386" class="c"><input type="checkbox" id="c-39462386" checked=""/><div class="controls bullet"><span class="by">dllthomas</span><span>|</span><a href="#39458657">root</a><span>|</span><a href="#39458899">parent</a><span>|</span><a href="#39464091">prev</a><span>|</span><a href="#39459495">next</a><span>|</span><label class="collapse" for="c-39462386">[-]</label><label class="expand" for="c-39462386">[1 more]</label></div><br/><div class="children"><div class="content">&lt;!$ grep ... or &lt;$_ grep ... work, too.</div><br/></div></div></div></div><div id="39459495" class="c"><input type="checkbox" id="c-39459495" checked=""/><div class="controls bullet"><span class="by">neuromanser</span><span>|</span><a href="#39458657">parent</a><span>|</span><a href="#39458899">prev</a><span>|</span><a href="#39459170">next</a><span>|</span><label class="collapse" for="c-39459495">[-]</label><label class="expand" for="c-39459495">[1 more]</label></div><br/><div class="children"><div class="content">Press alt and dot (full stop) to insert last word from the previous command line:<p><pre><code>    $ cat file
    $ grep stuff alt-.
</code></pre>
Alternatively, make use off the READNULLCMD mechanism in Zsh:<p><pre><code>    $ &lt; file
</code></pre>
translates to<p><pre><code>    $ ${READNULLCMD:-more} &lt; file
</code></pre>
Thus you can<p><pre><code>    $ &lt; file
</code></pre>
then UP (or ctrl-p which I find more ergonomic) and continue with &quot;grep stuff&quot;:<p><pre><code>    $ &lt; file grep stuff
</code></pre>
(Redirections can be anywhere in the command.)<p><a href="https:&#x2F;&#x2F;zsh.sourceforge.io&#x2F;Doc&#x2F;Release&#x2F;Redirection.html#Redirections-with-no-command" rel="nofollow">https:&#x2F;&#x2F;zsh.sourceforge.io&#x2F;Doc&#x2F;Release&#x2F;Redirection.html#Redi...</a></div><br/></div></div><div id="39459170" class="c"><input type="checkbox" id="c-39459170" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#39458657">parent</a><span>|</span><a href="#39459495">prev</a><span>|</span><a href="#39462837">next</a><span>|</span><label class="collapse" for="c-39459170">[-]</label><label class="expand" for="c-39459170">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always though UUoC while working <i>interactively</i> are fine. One shouldn&#x27;t interrupt their flow to fix minutia in a one time command.<p>UUoC criticism, to me, belongs when one sits down to script.</div><br/><div id="39460152" class="c"><input type="checkbox" id="c-39460152" checked=""/><div class="controls bullet"><span class="by">0cf8612b2e1e</span><span>|</span><a href="#39458657">root</a><span>|</span><a href="#39459170">parent</a><span>|</span><a href="#39462837">next</a><span>|</span><label class="collapse" for="c-39460152">[-]</label><label class="expand" for="c-39460152">[1 more]</label></div><br/><div class="children"><div class="content">Eventually I will want to debug&#x2F;change the script where we get right back to the situation where I want cat at the front of the line.</div><br/></div></div></div></div><div id="39462837" class="c"><input type="checkbox" id="c-39462837" checked=""/><div class="controls bullet"><span class="by">skipkey</span><span>|</span><a href="#39458657">parent</a><span>|</span><a href="#39459170">prev</a><span>|</span><a href="#39458939">next</a><span>|</span><label class="collapse" for="c-39462837">[-]</label><label class="expand" for="c-39462837">[1 more]</label></div><br/><div class="children"><div class="content">Or what I find myself doing often:<p>cat “filename.txt”<p>Up | grep “thing”<p>Up | grep -v “not thing”<p>Up | grep -v “other thing”<p>Etc.  it’s just easier to build this way even if the initial cat is unnecessary.</div><br/></div></div><div id="39458939" class="c"><input type="checkbox" id="c-39458939" checked=""/><div class="controls bullet"><span class="by">sophacles</span><span>|</span><a href="#39458657">parent</a><span>|</span><a href="#39462837">prev</a><span>|</span><a href="#39463975">next</a><span>|</span><label class="collapse" for="c-39458939">[-]</label><label class="expand" for="c-39458939">[12 more]</label></div><br/><div class="children"><div class="content">I look through a lot of logs, so I&#x27;ve aliased `not` to `grep -vE` and using the method you describe over several iterations i end up with a history that has a lot of<p><pre><code>    cat log | not spam1 | not spam2 | not &#x27;spam(3|4)&#x27; | .... | less</code></pre></div><br/><div id="39459294" class="c"><input type="checkbox" id="c-39459294" checked=""/><div class="controls bullet"><span class="by">lambdaba</span><span>|</span><a href="#39458657">root</a><span>|</span><a href="#39458939">parent</a><span>|</span><a href="#39459216">next</a><span>|</span><label class="collapse" for="c-39459294">[-]</label><label class="expand" for="c-39459294">[9 more]</label></div><br/><div class="children"><div class="content">Zsh global aliases can be nice for commands commonly used in pipelines:<p><pre><code>  alias -g V=&#x27;| grep -vE&#x27;
  alias -g L=&quot;| $PAGER&quot;
</code></pre>
Then you can do<p><pre><code>  cat log V spam1 V spam2 L
</code></pre>
I also like<p><pre><code>  alias -g G=&#x27;| grep&#x27;
  alias -g X=&#x27;| xargs&#x27;
</code></pre>
The possibilities are endless...</div><br/><div id="39459543" class="c"><input type="checkbox" id="c-39459543" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#39458657">root</a><span>|</span><a href="#39459294">parent</a><span>|</span><a href="#39459216">next</a><span>|</span><label class="collapse" for="c-39459543">[-]</label><label class="expand" for="c-39459543">[8 more]</label></div><br/><div class="children"><div class="content">So are the injection possibilities. That makes me very nervous.</div><br/><div id="39462130" class="c"><input type="checkbox" id="c-39462130" checked=""/><div class="controls bullet"><span class="by">OJFord</span><span>|</span><a href="#39458657">root</a><span>|</span><a href="#39459543">parent</a><span>|</span><a href="#39459598">next</a><span>|</span><label class="collapse" for="c-39462130">[-]</label><label class="expand" for="c-39462130">[1 more]</label></div><br/><div class="children"><div class="content">If you already have injection to my command line or environment I don&#x27;t see how not setting an alias is going to save me?</div><br/></div></div><div id="39459598" class="c"><input type="checkbox" id="c-39459598" checked=""/><div class="controls bullet"><span class="by">lambdaba</span><span>|</span><a href="#39458657">root</a><span>|</span><a href="#39459543">parent</a><span>|</span><a href="#39462130">prev</a><span>|</span><a href="#39459216">next</a><span>|</span><label class="collapse" for="c-39459598">[-]</label><label class="expand" for="c-39459598">[6 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the scenario?</div><br/><div id="39459787" class="c"><input type="checkbox" id="c-39459787" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#39458657">root</a><span>|</span><a href="#39459598">parent</a><span>|</span><a href="#39459216">next</a><span>|</span><label class="collapse" for="c-39459787">[-]</label><label class="expand" for="c-39459787">[5 more]</label></div><br/><div class="children"><div class="content">Something sets $PAGER to “rm -rf &#x2F;“ or something along those lines.<p>Really I’d be more worried about <i>accidental</i> invocations. Aliases are not scoped, so if you’re dealing with one of those programs with non standards option handling and uppercase single character switches…</div><br/><div id="39461854" class="c"><input type="checkbox" id="c-39461854" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#39458657">root</a><span>|</span><a href="#39459787">parent</a><span>|</span><a href="#39459926">next</a><span>|</span><label class="collapse" for="c-39461854">[-]</label><label class="expand" for="c-39461854">[1 more]</label></div><br/><div class="children"><div class="content">Tons of things use environment variables like EDITOR or PAGER, and tons of things can &quot;inject&quot; &quot;rm -rf ~&quot; or whatnot. But if they can inject that, they can probably also go all sorts of other nefarious things. There is nothing special about a global alias here.<p>And an accidental typo is not really a big deal, certainly not an &quot;injection possibility&quot;.</div><br/></div></div><div id="39459926" class="c"><input type="checkbox" id="c-39459926" checked=""/><div class="controls bullet"><span class="by">lambdaba</span><span>|</span><a href="#39458657">root</a><span>|</span><a href="#39459787">parent</a><span>|</span><a href="#39461854">prev</a><span>|</span><a href="#39459216">next</a><span>|</span><label class="collapse" for="c-39459926">[-]</label><label class="expand" for="c-39459926">[3 more]</label></div><br/><div class="children"><div class="content">I actually use `alias -g L=&#x27;| nvimpager&#x27;`,<p>As for accidental invocations, yeah I agree it feels dangerous, but in a few hundred thousand lines of shell history since I set them, never had a problem.</div><br/><div id="39460250" class="c"><input type="checkbox" id="c-39460250" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#39458657">root</a><span>|</span><a href="#39459926">parent</a><span>|</span><a href="#39459216">next</a><span>|</span><label class="collapse" for="c-39460250">[-]</label><label class="expand" for="c-39460250">[2 more]</label></div><br/><div class="children"><div class="content">Haven’t had a problem, or haven’t noticed you’ve had a problem? I kid - but only partially.<p>What I really wish for is some sort of tool that would let me pipeline like that, but also easily examine each step in the chain for sanity. Sort of a workbook for shell.</div><br/><div id="39460327" class="c"><input type="checkbox" id="c-39460327" checked=""/><div class="controls bullet"><span class="by">lambdaba</span><span>|</span><a href="#39458657">root</a><span>|</span><a href="#39460250">parent</a><span>|</span><a href="#39459216">next</a><span>|</span><label class="collapse" for="c-39460327">[-]</label><label class="expand" for="c-39460327">[1 more]</label></div><br/><div class="children"><div class="content">Auto-expanding aliases seems like it would help:<p><pre><code>  function expand-alias() {
      zle _expand_alias
      zle self-insert
  }
  zle -N expand-alias
  bindkey -M main &#x27; &#x27; expand-alias</code></pre></div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="39459216" class="c"><input type="checkbox" id="c-39459216" checked=""/><div class="controls bullet"><span class="by">mmh0000</span><span>|</span><a href="#39458657">root</a><span>|</span><a href="#39458939">parent</a><span>|</span><a href="#39459294">prev</a><span>|</span><a href="#39459010">next</a><span>|</span><label class="collapse" for="c-39459216">[-]</label><label class="expand" for="c-39459216">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using Linux for a very long time and never thought of that as an alias. I love it! Thank you for sharing.</div><br/></div></div><div id="39459010" class="c"><input type="checkbox" id="c-39459010" checked=""/><div class="controls bullet"><span class="by">kqr</span><span>|</span><a href="#39458657">root</a><span>|</span><a href="#39458939">parent</a><span>|</span><a href="#39459216">prev</a><span>|</span><a href="#39463975">next</a><span>|</span><label class="collapse" for="c-39459010">[-]</label><label class="expand" for="c-39459010">[1 more]</label></div><br/><div class="children"><div class="content">I really like that alias. Thanks!</div><br/></div></div></div></div><div id="39463975" class="c"><input type="checkbox" id="c-39463975" checked=""/><div class="controls bullet"><span class="by">mdekkers</span><span>|</span><a href="#39458657">parent</a><span>|</span><a href="#39458939">prev</a><span>|</span><a href="#39460709">next</a><span>|</span><label class="collapse" for="c-39463975">[-]</label><label class="expand" for="c-39463975">[1 more]</label></div><br/><div class="children"><div class="content">&gt; grep filename.txt “thing I want”<p>&gt; grep “thing I want” filename.txt.<p>…every time</div><br/></div></div><div id="39460709" class="c"><input type="checkbox" id="c-39460709" checked=""/><div class="controls bullet"><span class="by">hawski</span><span>|</span><a href="#39458657">parent</a><span>|</span><a href="#39463975">prev</a><span>|</span><a href="#39458820">next</a><span>|</span><label class="collapse" for="c-39460709">[-]</label><label class="expand" for="c-39460709">[3 more]</label></div><br/><div class="children"><div class="content">Try:<p><pre><code>  &lt; file.txt grep pattern
</code></pre>
Less keystrokes.</div><br/><div id="39461996" class="c"><input type="checkbox" id="c-39461996" checked=""/><div class="controls bullet"><span class="by">FreeFull</span><span>|</span><a href="#39458657">root</a><span>|</span><a href="#39460709">parent</a><span>|</span><a href="#39458820">next</a><span>|</span><label class="collapse" for="c-39461996">[-]</label><label class="expand" for="c-39461996">[2 more]</label></div><br/><div class="children"><div class="content">That doesn&#x27;t work for the first step though, where you want to print the file to stdout without processing it in any way</div><br/><div id="39464123" class="c"><input type="checkbox" id="c-39464123" checked=""/><div class="controls bullet"><span class="by">hawski</span><span>|</span><a href="#39458657">root</a><span>|</span><a href="#39461996">parent</a><span>|</span><a href="#39458820">next</a><span>|</span><label class="collapse" for="c-39464123">[-]</label><label class="expand" for="c-39464123">[1 more]</label></div><br/><div class="children"><div class="content">Fair. One could get used to the following for the first step:<p><pre><code>  &lt; file.txt cat
</code></pre>
But then one has to ctrl-w cat. It is a pity that this is not an alternative to cat for a single file:<p><pre><code>  &lt; file.txt</code></pre></div><br/></div></div></div></div></div></div></div></div><div id="39459941" class="c"><input type="checkbox" id="c-39459941" checked=""/><div class="controls bullet"><span class="by">TacticalCoder</span><span>|</span><a href="#39458657">prev</a><span>|</span><a href="#39460792">next</a><span>|</span><label class="collapse" for="c-39459941">[-]</label><label class="expand" for="c-39459941">[5 more]</label></div><br/><div class="children"><div class="content">What&#x27;s really useless are all the &quot;useless use of cat&quot; comments (and shellcheck warnings although I take it for a shell script there could be cases where one less process may be justified [although really if you&#x27;re at that point you&#x27;ve got other things to worry than cat, sadly]).<p>I use &quot;cat ... | ... | ... &quot; like in TFA and just like many in this thread because it simply makes sense. It&#x27;s more intuitive. It&#x27;s easier to read. It requires less  braincycles to remember how this or that command wants its parameter passed, etc.<p>I think the &quot;useless use of cat&quot; movement made its time: it failed. Many of us are never going to give up our use(less|ful) of cat (you decide). So stop wasting your time complaining about it.</div><br/><div id="39461826" class="c"><input type="checkbox" id="c-39461826" checked=""/><div class="controls bullet"><span class="by">thaumaturgy</span><span>|</span><a href="#39459941">parent</a><span>|</span><a href="#39460792">next</a><span>|</span><label class="collapse" for="c-39461826">[-]</label><label class="expand" for="c-39461826">[4 more]</label></div><br/><div class="children"><div class="content">I use shellcheck a lot, and I&#x27;ve found so far that its complaints fall neatly into one of two buckets: &quot;oh, whoops, nice catch&quot; and &quot;shut up, shellcheck&quot;.<p>&quot;useless use of cat&quot; goes into the latter bucket. Complaining at me about it does not actually improve the code; it&#x27;s just a nag about a bad habit that, arguably, isn&#x27;t even a bad habit.</div><br/><div id="39463601" class="c"><input type="checkbox" id="c-39463601" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39459941">root</a><span>|</span><a href="#39461826">parent</a><span>|</span><a href="#39460792">next</a><span>|</span><label class="collapse" for="c-39463601">[-]</label><label class="expand" for="c-39463601">[3 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;re mistaken here, and confusing two different usages of cat.<p>&quot;Useless&quot; uses of cat aren&#x27;t bad habits during <i>interactive</i> usage, for all the reasons people mention here which I won&#x27;t rehash.<p>For <i>scripts</i>, however, the story is different than for one-off commands. For one thing, it&#x27;s slower due to the extra forks and copying of data across pipes, so there&#x27;s at least that. For another, it prevents the command from inspecting the other end of its pipe, which can negatively impact usage in some case. (For example, if the program knows its input is from a terminal, it may flush its output on every newline it sees.) Moreover, a bunch of the arguments for the interaction case (like &quot;it&#x27;s fewer keystrokes&quot; or whatever) don&#x27;t even apply to the script case in the first place...<p>The end result here is that you definitely shouldn&#x27;t assume some habit is just fine with scripting merely because it&#x27;s fine when you&#x27;re typing on the terminal, or vice-versa.</div><br/><div id="39464142" class="c"><input type="checkbox" id="c-39464142" checked=""/><div class="controls bullet"><span class="by">thaumaturgy</span><span>|</span><a href="#39459941">root</a><span>|</span><a href="#39463601">parent</a><span>|</span><a href="#39460792">next</a><span>|</span><label class="collapse" for="c-39464142">[-]</label><label class="expand" for="c-39464142">[2 more]</label></div><br/><div class="children"><div class="content">Those are all reasonable points, but:<p>For shell scripts, I would argue quite vehemently that the most important goals should be <i>correctness</i> and <i>readability</i>, with performance being a very distant third concern. I&#x27;d even be tempted to argue that performance shouldn&#x27;t be a consideration at all, except of course that argument would be misinterpreted to support some absurd edge case until I&#x27;d have to admit that of course performance is a little bit of a concern. But in any case, I can&#x27;t recall a single example of a cat pipe being the root cause of an unacceptable performance problem in a shell script.<p>On the readability point, the example that probably irritates me most often is a cat pipe into some commands into a while loop. I <i>much</i> prefer this:<p><pre><code>    cat file.conf | sed -e &#x27;s&#x2F;pattern&#x2F;replacement&#x2F;g&#x27; -e &#x27;s&#x2F;reallybigolhonkinpattern&#x2F;other-replacement&#x2F;g&#x27; | tr... | while read line; do...
</code></pre>
to this:<p><pre><code>    sed -e &#x27;s&#x2F;pattern&#x2F;replacement&#x2F;g&#x27; -e &#x27;s&#x2F;reallybigolhonkinpattern&#x2F;other-replacement&#x2F;g&#x27; wrongfile.conf | tr... | while read line; do...
</code></pre>
or this:<p><pre><code>    sed -e &#x27;s&#x2F;pattern&#x2F;replacement&#x2F;g&#x27; -e &#x27;s&#x2F;reallybigolhonkinpattern&#x2F;other-replacement&#x2F;g&#x27; | tr... | while read line; do
        stuff...
    done &lt; file.conf
</code></pre>
...and that&#x27;s a pretty common pattern where the edge case of reading input from a terminal doesn&#x27;t apply.<p>So this is the kind of thing that makes me go &quot;shut up shellcheck&quot; instead of &quot;thanks shellcheck!&quot;</div><br/><div id="39464250" class="c"><input type="checkbox" id="c-39464250" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39459941">root</a><span>|</span><a href="#39464142">parent</a><span>|</span><a href="#39460792">next</a><span>|</span><label class="collapse" for="c-39464250">[-]</label><label class="expand" for="c-39464250">[1 more]</label></div><br/><div class="children"><div class="content">Fork performance is a <i>much</i> more severe problem on Windows (WSL1, MSYS2, etc.) than Linux, so I&#x27;m not claiming <i>you&#x27;ll</i> personally run into it per se, but it can affect users of some scripts.<p>But: performance was just one of the problems I cited. I gave you more than that -- one was a correctness reason (which you do care about) and had nothing to do with performance. And, again, incorrect buffering (which can make the script literally unusable in some cases) was just one example. I&#x27;ve seen needless redirection interfere with Ctrl+C handling too, though I don&#x27;t recall the exact example. Oh, and there&#x27;s terminal coloring and ANSI escape processing too, which programs detect differently. Point is, being unable to see the end of the pipe can definitely cause an unnecessary mess in some cases.<p>As for readability - honestly, part of the reason you find it less readable is that you&#x27;re missing something else. Namely, this:<p><pre><code>  sed -e &#x27;s&#x2F;pattern&#x2F;replacement&#x2F;g&#x27; -e &#x27;s&#x2F;reallybigolhonkinpattern&#x2F;other-replacement&#x2F;g&#x27; wrongfile.conf | tr... | while read line; do...
</code></pre>
should really have been:<p><pre><code>  sed -e &#x27;s&#x2F;pattern&#x2F;replacement&#x2F;g&#x27; -e &#x27;s&#x2F;reallybigolhonkinpattern&#x2F;other-replacement&#x2F;g&#x27; -- wrongfile.conf | tr... | while read line; do...
</code></pre>
which is in fact both more correct (at least when the file name isn&#x27;t hard-coded, which is the common case in shell scripts) <i>and</i> more readable than your example; you can immediately spot where the file name is. The difference between that and cat &quot;$blah&quot; | sed ... is very minor at that point (and in fact you should be doing cat -- &quot;$blah&quot; as well...); anybody reading a command like sed without a pipe input knows to look for an input argument. The important point regarding readability here is, it&#x27;s not like the code gets overly tricky if you write it one way vs. another way. It&#x27;s just a matter of spending 1-2 extra seconds glancing over. So it&#x27;s very much a minor thing to be prioritizing above everything else. (If the logic became harder to reason about, that&#x27;d be a different story, and it&#x27;d put more weight on the readability aspect.)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39460792" class="c"><input type="checkbox" id="c-39460792" checked=""/><div class="controls bullet"><span class="by">VSpike</span><span>|</span><a href="#39459941">prev</a><span>|</span><a href="#39464683">next</a><span>|</span><label class="collapse" for="c-39460792">[-]</label><label class="expand" for="c-39460792">[6 more]</label></div><br/><div class="children"><div class="content">I definitely think if you want to use `cat` then just go ahead, it&#x27;s fine. Sometimes these things are a power play, a way to distinguish between people who know the social codes and those who don&#x27;t. In this case, it probably had a reasonable origin even if it&#x27;s now more of a way to beat on newcomers. On old systems, memory was limited, disk was slow and forking was expensive. Saving a process in a script or one liner was a noticeable improvement performance-wise.<p>I learned some bash from an old-timer who would write an infinite-loop like this:<p><pre><code>  while :; do 
    # loop body here
  done
</code></pre>
This works because the `:` is a way to set a label, and it implicitly returns 0. It&#x27;s just a weird wrinkle of the language. So, why not do `while true`? On old systems, `true` was not a builtin and would call `&#x2F;usr&#x2F;bin&#x2F;true`. Writing the loop this way saves a process fork on each iteration.<p>On a modern system, you&#x27;d be hard pushed to measure the difference, so it really doesn&#x27;t matter which style you prefer.</div><br/><div id="39464541" class="c"><input type="checkbox" id="c-39464541" checked=""/><div class="controls bullet"><span class="by">PennRobotics</span><span>|</span><a href="#39460792">parent</a><span>|</span><a href="#39462161">next</a><span>|</span><label class="collapse" for="c-39464541">[-]</label><label class="expand" for="c-39464541">[1 more]</label></div><br/><div class="children"><div class="content">infinite loop in C:<p><pre><code>  for(;;){
      &#x2F;&#x2F; loop body here
  }</code></pre></div><br/></div></div><div id="39462161" class="c"><input type="checkbox" id="c-39462161" checked=""/><div class="controls bullet"><span class="by">OJFord</span><span>|</span><a href="#39460792">parent</a><span>|</span><a href="#39464541">prev</a><span>|</span><a href="#39464683">next</a><span>|</span><label class="collapse" for="c-39462161">[-]</label><label class="expand" for="c-39462161">[4 more]</label></div><br/><div class="children"><div class="content">&gt; This works because the `:` is a way to set a label, and it implicitly returns 0. It&#x27;s just a weird wrinkle of the language.<p>Do you have a source for that? I thought it was just POSIX built-in for true. Like `.` vs. `source`. What&#x27;s a label in this context anyway?</div><br/><div id="39464473" class="c"><input type="checkbox" id="c-39464473" checked=""/><div class="controls bullet"><span class="by">VSpike</span><span>|</span><a href="#39460792">root</a><span>|</span><a href="#39462161">parent</a><span>|</span><a href="#39464300">next</a><span>|</span><label class="collapse" for="c-39464473">[-]</label><label class="expand" for="c-39464473">[1 more]</label></div><br/><div class="children"><div class="content">Hah, yeah I was completely wrong on that! Should have fact checked myself. That&#x27;s a falsehood I absorbed at some point and didn&#x27;t question.</div><br/></div></div><div id="39464300" class="c"><input type="checkbox" id="c-39464300" checked=""/><div class="controls bullet"><span class="by">penguin_booze</span><span>|</span><a href="#39460792">root</a><span>|</span><a href="#39462161">parent</a><span>|</span><a href="#39464473">prev</a><span>|</span><a href="#39462322">next</a><span>|</span><label class="collapse" for="c-39464300">[-]</label><label class="expand" for="c-39464300">[1 more]</label></div><br/><div class="children"><div class="content">Equally surprised. I know &#x27;:&#x27; is a label in sed, but labels in (ba)sh, I&#x27;m not aware. If it&#x27;s indeed a label, is there a goto?</div><br/></div></div><div id="39462322" class="c"><input type="checkbox" id="c-39462322" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#39460792">root</a><span>|</span><a href="#39462161">parent</a><span>|</span><a href="#39464300">prev</a><span>|</span><a href="#39464683">next</a><span>|</span><label class="collapse" for="c-39462322">[-]</label><label class="expand" for="c-39462322">[1 more]</label></div><br/><div class="children"><div class="content">No need to ask for a source.  The word &quot;label&quot; in the POSIX shell documentation only occurs in the description of `case`, and it doesn&#x27;t happen in the manual page for bash, dash, zsh, etc.</div><br/></div></div></div></div></div></div><div id="39464683" class="c"><input type="checkbox" id="c-39464683" checked=""/><div class="controls bullet"><span class="by">halayli</span><span>|</span><a href="#39460792">prev</a><span>|</span><a href="#39458021">next</a><span>|</span><label class="collapse" for="c-39464683">[-]</label><label class="expand" for="c-39464683">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not more modular to use cat instead of head&#x27;s filename argument. OP invented their own definition of modularity to fit their narative and bias. What are you going to use if you need to tail? cat a 1GB file through the kernel to reach tail&#x27;s stdin? You&#x27;re not just spawning an extra process you&#x27;re copying the data from one process to another via read&#x2F;write system calls for no good reason.</div><br/></div></div><div id="39458021" class="c"><input type="checkbox" id="c-39458021" checked=""/><div class="controls bullet"><span class="by">gruturo</span><span>|</span><a href="#39464683">prev</a><span>|</span><a href="#39458441">next</a><span>|</span><label class="collapse" for="c-39458021">[-]</label><label class="expand" for="c-39458021">[14 more]</label></div><br/><div class="children"><div class="content">The concept presented is something I can agree with in principle, but &quot;transforming a filename into the content of the file&quot; is a really thin justification for a responsibility.<p>By all means don&#x27;t build something where you have cascading effect and need to retest an entire pipeline, but this is _not_ it.<p>P.S.<p>And if you really really want to keep it separate, just do &quot;&lt; access.log head -500 etc etc etc&quot; (no I didn&#x27;t forget a pipe. And yes the &quot;&lt; inputfile&quot; works even if it&#x27;s in front of what you&#x27;re calling).</div><br/><div id="39458103" class="c"><input type="checkbox" id="c-39458103" checked=""/><div class="controls bullet"><span class="by">hk__2</span><span>|</span><a href="#39458021">parent</a><span>|</span><a href="#39458436">next</a><span>|</span><label class="collapse" for="c-39458103">[-]</label><label class="expand" for="c-39458103">[10 more]</label></div><br/><div class="children"><div class="content">&gt; And if you really really want to keep it separate, just do &quot;&lt; access.log head -500 etc etc etc&quot; (no I didn&#x27;t forget a pipe. And yes the &quot;&lt; inputfile&quot; works even if it&#x27;s in front of what you&#x27;re calling).<p>Or just use `cat` and let the pipe separate the different steps. &quot;&lt; access.log head&quot; is nice but it breaks this representation where each step is piped into the next one. Sure, once you’re done fiddling you can rewrite the thing to remove the &quot;cat&quot;, but when you are constructing the thing I find it clearer to use cat.</div><br/><div id="39458310" class="c"><input type="checkbox" id="c-39458310" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#39458021">root</a><span>|</span><a href="#39458103">parent</a><span>|</span><a href="#39458392">next</a><span>|</span><label class="collapse" for="c-39458310">[-]</label><label class="expand" for="c-39458310">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Sure, once you’re done fiddling you can rewrite the thing to remove the &quot;cat&quot;<p>Or just… don’t?</div><br/><div id="39458379" class="c"><input type="checkbox" id="c-39458379" checked=""/><div class="controls bullet"><span class="by">margalabargala</span><span>|</span><a href="#39458021">root</a><span>|</span><a href="#39458310">parent</a><span>|</span><a href="#39458392">next</a><span>|</span><label class="collapse" for="c-39458379">[-]</label><label class="expand" for="c-39458379">[1 more]</label></div><br/><div class="children"><div class="content">Sure. Don&#x27;t. Or do. Whatever you prefer.</div><br/></div></div></div></div><div id="39458392" class="c"><input type="checkbox" id="c-39458392" checked=""/><div class="controls bullet"><span class="by">kristjansson</span><span>|</span><a href="#39458021">root</a><span>|</span><a href="#39458103">parent</a><span>|</span><a href="#39458310">prev</a><span>|</span><a href="#39458436">next</a><span>|</span><label class="collapse" for="c-39458392">[-]</label><label class="expand" for="c-39458392">[7 more]</label></div><br/><div class="children"><div class="content">&gt; it breaks this representation where each step is piped into the next one<p>No it doesn&#x27;t?<p><pre><code>  &lt; access.log head -n 500 | grep mail | perl -e …
</code></pre>
is completely valid, and reads right-to-left as well as the cat version.  IMO using stdin is preferable to either solution in TFA.</div><br/><div id="39459470" class="c"><input type="checkbox" id="c-39459470" checked=""/><div class="controls bullet"><span class="by">n_plus_1_acc</span><span>|</span><a href="#39458021">root</a><span>|</span><a href="#39458392">parent</a><span>|</span><a href="#39458494">next</a><span>|</span><label class="collapse" for="c-39459470">[-]</label><label class="expand" for="c-39459470">[2 more]</label></div><br/><div class="children"><div class="content">I agree that it&#x27;s more elegant, but it requires you to remember the operator precendence of &lt; vs |</div><br/><div id="39459622" class="c"><input type="checkbox" id="c-39459622" checked=""/><div class="controls bullet"><span class="by">kristjansson</span><span>|</span><a href="#39458021">root</a><span>|</span><a href="#39459470">parent</a><span>|</span><a href="#39458494">next</a><span>|</span><label class="collapse" for="c-39459622">[-]</label><label class="expand" for="c-39459622">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not really a precedence relation as much as it&#x27;s part of shell syntax. There are separators[0], and anything sequence of tokens between a separator is a command[1].  A command decomposes further, of course, but the only thing the programmer needs to know here is that separators are a different kind of thing than commands.<p>[0]: newline, ‘||’, ‘&amp;&amp;’, ‘&amp;’, ‘;’, ‘;;’, ‘;&amp;’, ‘;;&amp;’, ‘|’, ‘|&amp;’, ‘(’, or ‘)’.<p>[1]: <a href="https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;bash&#x2F;manual&#x2F;bash.html#Simple-Commands" rel="nofollow">https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;bash&#x2F;manual&#x2F;bash.html#Simple-Co...</a></div><br/></div></div></div></div><div id="39458494" class="c"><input type="checkbox" id="c-39458494" checked=""/><div class="controls bullet"><span class="by">ufo</span><span>|</span><a href="#39458021">root</a><span>|</span><a href="#39458392">parent</a><span>|</span><a href="#39459470">prev</a><span>|</span><a href="#39458436">next</a><span>|</span><label class="collapse" for="c-39458494">[-]</label><label class="expand" for="c-39458494">[4 more]</label></div><br/><div class="children"><div class="content">This works but it&#x27;s so ugly :(</div><br/><div id="39459484" class="c"><input type="checkbox" id="c-39459484" checked=""/><div class="controls bullet"><span class="by">kristjansson</span><span>|</span><a href="#39458021">root</a><span>|</span><a href="#39458494">parent</a><span>|</span><a href="#39458436">next</a><span>|</span><label class="collapse" for="c-39459484">[-]</label><label class="expand" for="c-39459484">[3 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s beautiful?  Reads left-to-right, has nice symmetry if you pipe to an output file like:<p><pre><code>    &lt; infile some_cmd &gt; outfile
</code></pre>
and real clarifies what&#x27;s a shell command, what&#x27;s a redirection, etc.</div><br/><div id="39462476" class="c"><input type="checkbox" id="c-39462476" checked=""/><div class="controls bullet"><span class="by">jltsiren</span><span>|</span><a href="#39458021">root</a><span>|</span><a href="#39459484">parent</a><span>|</span><a href="#39458436">next</a><span>|</span><label class="collapse" for="c-39462476">[-]</label><label class="expand" for="c-39462476">[2 more]</label></div><br/><div class="children"><div class="content">It would make more sense like:<p><pre><code>    infile &gt; some_cmd &gt; outfile
</code></pre>
Then the arrow would be pointing in the right direction. But then it would be unclear whether &quot;infile&quot; is a file or a command. Which is why people use:<p><pre><code>    cat infile | some_cmd &gt; outfile
</code></pre>
You can now interpret &quot;cat&quot; as a keyword that specifies that &quot;infile&quot; is a file.</div><br/><div id="39463324" class="c"><input type="checkbox" id="c-39463324" checked=""/><div class="controls bullet"><span class="by">MatmaRex</span><span>|</span><a href="#39458021">root</a><span>|</span><a href="#39462476">parent</a><span>|</span><a href="#39458436">next</a><span>|</span><label class="collapse" for="c-39463324">[-]</label><label class="expand" for="c-39463324">[1 more]</label></div><br/><div class="children"><div class="content">It is more pleasant to the eye if you remove the spaces:<p><pre><code>    &lt;infile some_cmd &gt;outfile
</code></pre>
Just like you wouldn&#x27;t add spaces in the middle of &#x27;2&gt;&amp;1&#x27; when redirecting stderr to stdout:<p><pre><code>    &lt;infile some_cmd &gt;outfile 2&gt;&amp;1</code></pre></div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39458436" class="c"><input type="checkbox" id="c-39458436" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#39458021">parent</a><span>|</span><a href="#39458103">prev</a><span>|</span><a href="#39458159">next</a><span>|</span><label class="collapse" for="c-39458436">[-]</label><label class="expand" for="c-39458436">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;transforming a filename into the content of the file&quot; is a really thin justification for a responsibility.<p>Uh... I dunno, but my lizard brain thinks that the whole idea of mediating filesystem operations on storage and IPC mechanisms like pipes is a lot <i>more</i> complicated, magic, and deserving of a single command than merely filtering the data on stdin.<p>I agree with the article and the logic, and think this historic meme was basically wrong originally.  You string up your chain of pipelines with the first element being &quot;where does it come from?&quot; and not merely whatever the first operation happens to be just because that operation allows for some kind of file input or redirection syntactically.</div><br/></div></div><div id="39458159" class="c"><input type="checkbox" id="c-39458159" checked=""/><div class="controls bullet"><span class="by">TOGoS</span><span>|</span><a href="#39458021">parent</a><span>|</span><a href="#39458436">prev</a><span>|</span><a href="#39458703">next</a><span>|</span><label class="collapse" for="c-39458159">[-]</label><label class="expand" for="c-39458159">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>transforming a filename into the content of the file&quot; is a really thin justification for a responsibility</i><p>This is one of those things where I think it is until it isn&#x27;t.<p>I sometimes second-guess myself when I think I might be over-single-responsibilifying.  &quot;Well in practice these two things are so trivial that this feels a little silly.&quot;<p>It often turns out to have been a good call in hindsight, especially when working with other people who aren&#x27;t necessarily thinking about these things at all.  If the responsibilities have been sufficiently split up, they&#x27;re more likely to change only the part that needed to be changed, and less likely to complectify the two things together that really shouldn&#x27;t&#x27;ve been.  Or when I go &quot;oh wow that thing that I thought I overly-abstracted sure composes well with this unexpected new thing!&quot;<p>Hardcore separation of concerns is just another method of defensive programming.<p>&gt; <i>&lt; access.log head -500 etc etc etc</i><p>It&#x27;s too bad that the syntax is so different.  Why does the first stage not end with &quot;|&quot;?  There&#x27;s space for shell syntax improvements, here.  Maybe a &#x27;cat&#x27;-like builtin that translates `cat foo | bar` into `bar &lt;foo` so you can have the nice syntax but don&#x27;t needlessly create processes would leave everyone happy.</div><br/></div></div><div id="39458703" class="c"><input type="checkbox" id="c-39458703" checked=""/><div class="controls bullet"><span class="by">jiveturkey</span><span>|</span><a href="#39458021">parent</a><span>|</span><a href="#39458159">prev</a><span>|</span><a href="#39458441">next</a><span>|</span><label class="collapse" for="c-39458703">[-]</label><label class="expand" for="c-39458703">[1 more]</label></div><br/><div class="children"><div class="content">in the example given in the website, it could all be done in the perl! no need for the pipeline at all.</div><br/></div></div></div></div><div id="39458441" class="c"><input type="checkbox" id="c-39458441" checked=""/><div class="controls bullet"><span class="by">jxy</span><span>|</span><a href="#39458021">prev</a><span>|</span><a href="#39458344">next</a><span>|</span><label class="collapse" for="c-39458441">[-]</label><label class="expand" for="c-39458441">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m in the camp of using<p><pre><code>    &lt;input X|Y|Z &gt;output
</code></pre>
The point of this syntax is that I can readily replace it with<p><pre><code>    F() { X|Y|Z }
    &lt;input F &gt;output</code></pre></div><br/><div id="39458629" class="c"><input type="checkbox" id="c-39458629" checked=""/><div class="controls bullet"><span class="by">iforgotpassword</span><span>|</span><a href="#39458441">parent</a><span>|</span><a href="#39463257">next</a><span>|</span><label class="collapse" for="c-39458629">[-]</label><label class="expand" for="c-39458629">[1 more]</label></div><br/><div class="children"><div class="content">Since I like spaces around stuff I started putting two spaces after the infile at some point.<p><pre><code>  &lt; infile  x | y | z &gt; outfile
</code></pre>
I just didn&#x27;t like how the filename was so close to the command name ;)</div><br/></div></div><div id="39463257" class="c"><input type="checkbox" id="c-39463257" checked=""/><div class="controls bullet"><span class="by">adityaathalye</span><span>|</span><a href="#39458441">parent</a><span>|</span><a href="#39458629">prev</a><span>|</span><a href="#39459146">next</a><span>|</span><label class="collapse" for="c-39463257">[-]</label><label class="expand" for="c-39463257">[1 more]</label></div><br/><div class="children"><div class="content">Oh `F()`. I should use redirection more with my Bash functions, and add it to my list (pun intended) of functional tricks [1].<p>[1] <a href="https:&#x2F;&#x2F;evalapply.org&#x2F;posts&#x2F;shell-aint-a-bad-place-to-fp-part-2-functions-as-unix-tools&#x2F;" rel="nofollow">https:&#x2F;&#x2F;evalapply.org&#x2F;posts&#x2F;shell-aint-a-bad-place-to-fp-par...</a></div><br/></div></div><div id="39459146" class="c"><input type="checkbox" id="c-39459146" checked=""/><div class="controls bullet"><span class="by">CBLT</span><span>|</span><a href="#39458441">parent</a><span>|</span><a href="#39463257">prev</a><span>|</span><a href="#39461006">next</a><span>|</span><label class="collapse" for="c-39459146">[-]</label><label class="expand" for="c-39459146">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m in this camp as well, starting with input file redirection just makes so much sense to me.<p><pre><code>    &lt;&#x2F;proc&#x2F;0&#x2F;environ xargs -0
</code></pre>
I also don&#x27;t tend to want enormous volumes of text in my terminal scrollback so I generally view files or pipe verbose commands to `less`, then when I find what I want to send to the terminal I use the `|` less command to pipe it to `cat`.<p>Or to grab just a few lines for my later reference:<p><pre><code>    kubectl get po&#x2F;my-pod -o yaml | less
    &#x2F;* find the lines I&#x27;m interest in *&#x2F;
    -N
    |^sed -n 34,35p</code></pre></div><br/></div></div><div id="39461006" class="c"><input type="checkbox" id="c-39461006" checked=""/><div class="controls bullet"><span class="by">bloopernova</span><span>|</span><a href="#39458441">parent</a><span>|</span><a href="#39459146">prev</a><span>|</span><a href="#39458344">next</a><span>|</span><label class="collapse" for="c-39461006">[-]</label><label class="expand" for="c-39461006">[1 more]</label></div><br/><div class="children"><div class="content">This is by far the best explanation I&#x27;ve read for using that method. Thank you!</div><br/></div></div></div></div><div id="39458344" class="c"><input type="checkbox" id="c-39458344" checked=""/><div class="controls bullet"><span class="by">hiAndrewQuinn</span><span>|</span><a href="#39458441">prev</a><span>|</span><a href="#39461206">next</a><span>|</span><label class="collapse" for="c-39458344">[-]</label><label class="expand" for="c-39458344">[12 more]</label></div><br/><div class="children"><div class="content">`cat x | Y | Z` is Subject-Verb-Object.<p>`Y x | Z` is Verb-Subject-Object.<p>That&#x27;s why I prefer using cat &quot;uselessly&quot;.</div><br/><div id="39458535" class="c"><input type="checkbox" id="c-39458535" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39458344">parent</a><span>|</span><a href="#39459559">next</a><span>|</span><label class="collapse" for="c-39458535">[-]</label><label class="expand" for="c-39458535">[8 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>   &lt; x Y | Z &gt; w
</code></pre>
Y takes input redirected from x, piped into Z, which outputs into w.</div><br/><div id="39460919" class="c"><input type="checkbox" id="c-39460919" checked=""/><div class="controls bullet"><span class="by">ulucs</span><span>|</span><a href="#39458344">root</a><span>|</span><a href="#39458535">parent</a><span>|</span><a href="#39463493">next</a><span>|</span><label class="collapse" for="c-39460919">[-]</label><label class="expand" for="c-39460919">[1 more]</label></div><br/><div class="children"><div class="content">No, that&#x27;s obviously taking the inner product of the &lt;x| bra and |Z&gt; ket while applying the Y operator, and multiplying by a scalar w</div><br/></div></div><div id="39463493" class="c"><input type="checkbox" id="c-39463493" checked=""/><div class="controls bullet"><span class="by">hiAndrewQuinn</span><span>|</span><a href="#39458344">root</a><span>|</span><a href="#39458535">parent</a><span>|</span><a href="#39460919">prev</a><span>|</span><a href="#39458716">next</a><span>|</span><label class="collapse" for="c-39463493">[-]</label><label class="expand" for="c-39463493">[1 more]</label></div><br/><div class="children"><div class="content">The shell &lt; has never intuitive to me, for some reason, but this has helped me see it in a new light. Thanks!</div><br/></div></div><div id="39458716" class="c"><input type="checkbox" id="c-39458716" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#39458344">root</a><span>|</span><a href="#39458535">parent</a><span>|</span><a href="#39463493">prev</a><span>|</span><a href="#39459559">next</a><span>|</span><label class="collapse" for="c-39458716">[-]</label><label class="expand" for="c-39458716">[5 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Y takes input redirected from x, piped into Z, which outputs into w.</i><p>I.e.<p><pre><code>  x | Z | tee w | Y
</code></pre>
? that&#x27;s... something else entirely.</div><br/><div id="39458985" class="c"><input type="checkbox" id="c-39458985" checked=""/><div class="controls bullet"><span class="by">_kst_</span><span>|</span><a href="#39458344">root</a><span>|</span><a href="#39458716">parent</a><span>|</span><a href="#39459559">next</a><span>|</span><label class="collapse" for="c-39458985">[-]</label><label class="expand" for="c-39458985">[4 more]</label></div><br/><div class="children"><div class="content">No, the command is<p><pre><code>    &lt; x Y | Z &gt; w
</code></pre>
where x and w are files, not commands.<p>Something that &quot;cat file | ...&quot; advocates might be overlooking is that a redirection (&quot;&lt;inputfile&quot;, &quot;&gt;outputfile&quot;, &quot;2&gt;errorfile&quot;) can appear anywhere within a simple command, so these:<p><pre><code>    command -option &lt; file
    &lt; file command -option
    command &lt; file -option
</code></pre>
are all exactly the same -- and of course very similar to<p><pre><code>    cat file | command -option
</code></pre>
If the purpose of typing &quot;cat file | command&quot; is to put the input file at the beginning (which does make logical sense), you can achieve the same thing with &quot;&lt; file command&quot;. Admittedly, it does look at bit strange if you&#x27;re not accustomed to it. (It even works with csh and tcsh.)</div><br/><div id="39461760" class="c"><input type="checkbox" id="c-39461760" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#39458344">root</a><span>|</span><a href="#39458985">parent</a><span>|</span><a href="#39459559">next</a><span>|</span><label class="collapse" for="c-39461760">[-]</label><label class="expand" for="c-39461760">[3 more]</label></div><br/><div class="children"><div class="content">So I take it you&#x27;re also an advocate for this?<p><pre><code>  &lt; &lt;(curl http:&#x2F;&#x2F;...) command -option
</code></pre>
Because that&#x27;s what you get if you address the actual argument and still insist on input redirection.<p>Input redirection is inconsistent with every other command to retrieve data.  Not only does it not have the same syntax, it&#x27;s combining two actions into one step of the pipeline.</div><br/><div id="39462395" class="c"><input type="checkbox" id="c-39462395" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39458344">root</a><span>|</span><a href="#39461760">parent</a><span>|</span><a href="#39459559">next</a><span>|</span><label class="collapse" for="c-39462395">[-]</label><label class="expand" for="c-39462395">[2 more]</label></div><br/><div class="children"><div class="content">Redirection isn&#x27;t a step in the pipeline; it&#x27;s syntax which indicates to the shell that it should perform certain file descriptor manipulations when it arranges the pipeline.<p>I would say that &lt; &lt;(command arg) is a useless use of process substitution (UUoPS). You just want command arg |.<p>The redirection variant doesn&#x27;t eliminate <i>command</i>  and does not move <i>arg</i> out of <i>command</i>&#x27;s argument position; it&#x27;s just superfluous syntax.<p>Just because we want &quot;&lt; file&quot; instead of &quot;cat file |&quot; doesn&#x27;t imply that we want &quot;&lt; &lt;(command arg)&quot;
instead of &quot;command arg |&quot;.  It&#x27;s not even the same rewrite pattern at all.<p>However, if someone wrote:<p><pre><code>  cat &lt;(curl https:&#x2F;&#x2F;example.com&#x2F;file) | next
</code></pre>
then that now the UUoC pattern &quot;cat file |&quot;. We can apply the transformation to eliminate cat:<p><pre><code>  &lt; &lt;(curl https:&#x2F;&#x2F;example.com&#x2F;file) next
</code></pre>
Now in so doing, we have moved the process substitution such that there is an obvious match for the UUoPS pattern. We apply that rewrite rule as well:<p><pre><code>  curl https:&#x2F;&#x2F;example.com&#x2F;file | next</code></pre></div><br/><div id="39463276" class="c"><input type="checkbox" id="c-39463276" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#39458344">root</a><span>|</span><a href="#39462395">parent</a><span>|</span><a href="#39459559">next</a><span>|</span><label class="collapse" for="c-39463276">[-]</label><label class="expand" for="c-39463276">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Redirection isn&#x27;t a step in the pipeline<p>&quot;Get data&quot; is the pipeline step we&#x27;re talking about.  Using &quot;&lt; file&quot; combines it with the first transformation step, instead of keeping it as its own separate step as all other such data sources require.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39459559" class="c"><input type="checkbox" id="c-39459559" checked=""/><div class="controls bullet"><span class="by">neuromanser</span><span>|</span><a href="#39458344">parent</a><span>|</span><a href="#39458535">prev</a><span>|</span><a href="#39460227">next</a><span>|</span><label class="collapse" for="c-39459559">[-]</label><label class="expand" for="c-39459559">[2 more]</label></div><br/><div class="children"><div class="content">cat is a verb though</div><br/><div id="39464466" class="c"><input type="checkbox" id="c-39464466" checked=""/><div class="controls bullet"><span class="by">bowsamic</span><span>|</span><a href="#39458344">root</a><span>|</span><a href="#39459559">parent</a><span>|</span><a href="#39460227">next</a><span>|</span><label class="collapse" for="c-39464466">[-]</label><label class="expand" for="c-39464466">[1 more]</label></div><br/><div class="children"><div class="content">cat x is a subject</div><br/></div></div></div></div><div id="39460227" class="c"><input type="checkbox" id="c-39460227" checked=""/><div class="controls bullet"><span class="by">pwdisswordfishc</span><span>|</span><a href="#39458344">parent</a><span>|</span><a href="#39459559">prev</a><span>|</span><a href="#39461206">next</a><span>|</span><label class="collapse" for="c-39460227">[-]</label><label class="expand" for="c-39460227">[1 more]</label></div><br/><div class="children"><div class="content">&quot;x&quot; is not a subject.</div><br/></div></div></div></div><div id="39461206" class="c"><input type="checkbox" id="c-39461206" checked=""/><div class="controls bullet"><span class="by">GuB-42</span><span>|</span><a href="#39458344">prev</a><span>|</span><a href="#39459015">next</a><span>|</span><label class="collapse" for="c-39461206">[-]</label><label class="expand" for="c-39461206">[2 more]</label></div><br/><div class="children"><div class="content">There is another reason: to make sure the program doesn&#x27;t do anything funny with the file, like modifying it. I know it won&#x27;t happen with &quot;head&quot; but for commands I am not familiar with, it is a way to be sure. And example of a command that does &quot;something funny&quot; is gunzip. With just a file as an argument, it will decompress the .gz file and erase the original instead of reading it and dumping its content to stdout.<p>I usually prefer to do &quot;&lt; file command&quot; though. &quot;cat&quot; adds an extra layer of indirection, forcing stream processing and hiding the original file, but that&#x27;s usually unnecessary. If you really don&#x27;t trust the program, it is not an adequate solution anyways.</div><br/><div id="39462158" class="c"><input type="checkbox" id="c-39462158" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#39461206">parent</a><span>|</span><a href="#39459015">next</a><span>|</span><label class="collapse" for="c-39462158">[-]</label><label class="expand" for="c-39462158">[1 more]</label></div><br/><div class="children"><div class="content">If you want to hide the file&#x27;s device and inode number from the program that will be consuming the file&#x27;s contents, then, yes, using cat makes sense.  I&#x27;ve never had to do that.  Just redirecting stdin is enough.</div><br/></div></div></div></div><div id="39459015" class="c"><input type="checkbox" id="c-39459015" checked=""/><div class="controls bullet"><span class="by">nonethewiser</span><span>|</span><a href="#39461206">prev</a><span>|</span><a href="#39460736">next</a><span>|</span><label class="collapse" for="c-39459015">[-]</label><label class="expand" for="c-39459015">[3 more]</label></div><br/><div class="children"><div class="content">I like this sort of blog post - simple, clear example in a short format. Of course we can nitpick the implementation but I think the principle is solid: don&#x27;t be afraid to sacrifice some brevity for modularity or composability.<p>I do think he could have woven in the Parnas source a bit better. The first quote seems to rely a lot on the surrounding context of the essay and its never contextualized. This bit:<p>&gt; The problem is that these subsets and extensions are not the programs that we would have designed if we had set out to design just that product.<p>Just feels a bit disjointed in the article. I get the high-level message but thought it could be woven into the blog authors narrative better. Anyways, it sounds like a good article though.</div><br/><div id="39459388" class="c"><input type="checkbox" id="c-39459388" checked=""/><div class="controls bullet"><span class="by">kqr</span><span>|</span><a href="#39459015">parent</a><span>|</span><a href="#39460736">next</a><span>|</span><label class="collapse" for="c-39459388">[-]</label><label class="expand" for="c-39459388">[2 more]</label></div><br/><div class="children"><div class="content">Author here. You&#x27;re right. Originally I had a much longer excerpt but it got a bit rambly. I overcorrected and cut out too much; I&#x27;ll see what I can do to fix it. Thanks!</div><br/><div id="39462676" class="c"><input type="checkbox" id="c-39462676" checked=""/><div class="controls bullet"><span class="by">nonethewiser</span><span>|</span><a href="#39459015">root</a><span>|</span><a href="#39459388">parent</a><span>|</span><a href="#39460736">next</a><span>|</span><label class="collapse" for="c-39462676">[-]</label><label class="expand" for="c-39462676">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a nitpick BTW. Of course a bit more context would help I think, but I probably appreciate your edits to keep it brief too. As I mentioned, I really appreciate how concise and to the point it was. Thanks for writing.<p>I actually noticed your reply because I came back to this comment to save your blog. Not just for the content but the page style. The eggshile white (or similar) color, font, foot(side)notes. It&#x27;s nice.</div><br/></div></div></div></div></div></div><div id="39460736" class="c"><input type="checkbox" id="c-39460736" checked=""/><div class="controls bullet"><span class="by">yesiamyourdad</span><span>|</span><a href="#39459015">prev</a><span>|</span><a href="#39458759">next</a><span>|</span><label class="collapse" for="c-39460736">[-]</label><label class="expand" for="c-39460736">[3 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t be the only one who clicked on this hoping for an explanation of why they owned a cat.</div><br/><div id="39463104" class="c"><input type="checkbox" id="c-39463104" checked=""/><div class="controls bullet"><span class="by">slyall</span><span>|</span><a href="#39460736">parent</a><span>|</span><a href="#39462992">next</a><span>|</span><label class="collapse" for="c-39463104">[-]</label><label class="expand" for="c-39463104">[1 more]</label></div><br/><div class="children"><div class="content">I thought it might reference the book &quot; 101 Uses for a Dead Cat &quot;<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;101_Uses_for_a_Dead_Cat" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;101_Uses_for_a_Dead_Cat</a><p>&quot;It consisted of cartoons depicting the bodies of dead cats being used for various purposes, including anchoring boats, sharpening pencils and holding bottles of wine.&quot;<p>&quot;By December 7, 1981, it had spent 27 weeks on the New York Times Best Seller list.&quot;</div><br/></div></div><div id="39462992" class="c"><input type="checkbox" id="c-39462992" checked=""/><div class="controls bullet"><span class="by">chilling</span><span>|</span><a href="#39460736">parent</a><span>|</span><a href="#39463104">prev</a><span>|</span><a href="#39458759">next</a><span>|</span><label class="collapse" for="c-39462992">[-]</label><label class="expand" for="c-39462992">[1 more]</label></div><br/><div class="children"><div class="content">Yeah... sadly no cat was found ):</div><br/></div></div></div></div><div id="39458759" class="c"><input type="checkbox" id="c-39458759" checked=""/><div class="controls bullet"><span class="by">matvore</span><span>|</span><a href="#39460736">prev</a><span>|</span><a href="#39459214">next</a><span>|</span><label class="collapse" for="c-39458759">[-]</label><label class="expand" for="c-39458759">[5 more]</label></div><br/><div class="children"><div class="content">If we&#x27;re going to talk about unnecessary extra processes like useless cat, we should merge the head and grep commands into a sed, and possibly just merge everything into perl:<p><pre><code>    &lt;access.log sed -n &#x27;&#x2F;mail&#x2F;p; 500q&#x27; | perl -e ...
</code></pre>
If perl is processing the file line-by-line then filtering lines by regex and stopping at line X is trivial, and you don&#x27;t even need sed.</div><br/><div id="39458771" class="c"><input type="checkbox" id="c-39458771" checked=""/><div class="controls bullet"><span class="by">jkingsman</span><span>|</span><a href="#39458759">parent</a><span>|</span><a href="#39459247">next</a><span>|</span><label class="collapse" for="c-39458771">[-]</label><label class="expand" for="c-39458771">[2 more]</label></div><br/><div class="children"><div class="content">I think your point is valid and I don&#x27;t dispute it, but if I had a nickel for every time I said &quot;just do it all in perl&quot; and regretted it, I&#x27;d be... well, perhaps not a rich man, but I&#x27;d have lunch covered for a few weeks.</div><br/><div id="39458914" class="c"><input type="checkbox" id="c-39458914" checked=""/><div class="controls bullet"><span class="by">matvore</span><span>|</span><a href="#39458759">root</a><span>|</span><a href="#39458771">parent</a><span>|</span><a href="#39459247">next</a><span>|</span><label class="collapse" for="c-39458914">[-]</label><label class="expand" for="c-39458914">[1 more]</label></div><br/><div class="children"><div class="content">Perl has the advantage of only having one implementation, unlike sed and grep (e.g. BSD or GNU) and &#x2F;bin&#x2F;sh (can be one of many POSIX shells), so upgrading this pipeline to 100% perl is safer in some respects. The example in the article is light on details so it&#x27;s hard to comment very deeply.<p>I have heard snarky Perl putdowns ad nauseam at work and on HN and may have regretted using it a handful of times but I can say worse or similar for other popular tools, languages...</div><br/></div></div></div></div><div id="39459247" class="c"><input type="checkbox" id="c-39459247" checked=""/><div class="controls bullet"><span class="by">b5n</span><span>|</span><a href="#39458759">parent</a><span>|</span><a href="#39458771">prev</a><span>|</span><a href="#39459214">next</a><span>|</span><label class="collapse" for="c-39459247">[-]</label><label class="expand" for="c-39459247">[2 more]</label></div><br/><div class="children"><div class="content">I usually do it all in awk:<p><pre><code>    awk &#x27;&#x2F;mail&#x2F; &amp;&amp; NR &lt;= 500 {...}&#x27; access.log
</code></pre>
If you want N matched lines:<p><pre><code>    awk &#x27;&#x2F;mail&#x2F; &amp;&amp; i &lt; 500 {i++; ...}&#x27; access.log</code></pre></div><br/><div id="39460745" class="c"><input type="checkbox" id="c-39460745" checked=""/><div class="controls bullet"><span class="by">matvore</span><span>|</span><a href="#39458759">root</a><span>|</span><a href="#39459247">parent</a><span>|</span><a href="#39459214">next</a><span>|</span><label class="collapse" for="c-39460745">[-]</label><label class="expand" for="c-39460745">[1 more]</label></div><br/><div class="children"><div class="content">I wish I knew awk as well as I know perl, since then I wouldn&#x27;t need to hear recommendations for CPAN modules and spurious style prescriptions.</div><br/></div></div></div></div></div></div><div id="39459214" class="c"><input type="checkbox" id="c-39459214" checked=""/><div class="controls bullet"><span class="by">cljacoby</span><span>|</span><a href="#39458759">prev</a><span>|</span><a href="#39458474">next</a><span>|</span><label class="collapse" for="c-39459214">[-]</label><label class="expand" for="c-39459214">[4 more]</label></div><br/><div class="children"><div class="content">I also use cat this way, and for me the biggest reason is it just allows for a more intuitive left-to-right reading of any pipeline.<p>Things like this:<p>head -n 500 access.log | grep ...<p>head -n 500 &lt;access.log | grep ...<p>Feel like you start with the filename, then go leftwards to the first operation, then start reading rightward again through the pipe. At least in my brain, it feels slightly more awkward.</div><br/><div id="39460130" class="c"><input type="checkbox" id="c-39460130" checked=""/><div class="controls bullet"><span class="by">didntcheck</span><span>|</span><a href="#39459214">parent</a><span>|</span><a href="#39459238">next</a><span>|</span><label class="collapse" for="c-39460130">[-]</label><label class="expand" for="c-39460130">[1 more]</label></div><br/><div class="children"><div class="content">I wish math notation and computer programming had just settled on postfix over prefix early on, it&#x27;s so much more natural to read. Of course, we kind of get it with object oriented programming, some languages have UFCS [1], F# has that pipe operator etc.<p>It&#x27;s funny, when learning programming, I think Haskell was the language that introduced me to the pattern of having a chain of operators processing a stream to build up a result (and I&#x27;d later cover it again in SICP), and I loved how clean it looked compared to imperative code. But I now find it one of the harder to read languages due to it all being prefix, whereas Java&#x2F;Kotlin&#x2F;C#&#x2F;Javascript now all have stream constructs that use method calls, so read left-to-right, source-to-sink<p>And I&#x27;m reminded that I need to give Forth a proper go sometime<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Uniform_Function_Call_Syntax" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Uniform_Function_Call_Syntax</a></div><br/></div></div><div id="39459238" class="c"><input type="checkbox" id="c-39459238" checked=""/><div class="controls bullet"><span class="by">lubutu</span><span>|</span><a href="#39459214">parent</a><span>|</span><a href="#39460130">prev</a><span>|</span><a href="#39458474">next</a><span>|</span><label class="collapse" for="c-39459238">[-]</label><label class="expand" for="c-39459238">[2 more]</label></div><br/><div class="children"><div class="content">You can do...<p><pre><code>  &lt;access.log head -n 500 | grep ...
</code></pre>
... though that&#x27;s less familiar to many, I&#x27;m sure.</div><br/><div id="39459287" class="c"><input type="checkbox" id="c-39459287" checked=""/><div class="controls bullet"><span class="by">cljacoby</span><span>|</span><a href="#39459214">root</a><span>|</span><a href="#39459238">parent</a><span>|</span><a href="#39458474">next</a><span>|</span><label class="collapse" for="c-39459287">[-]</label><label class="expand" for="c-39459287">[1 more]</label></div><br/><div class="children"><div class="content">Neat, I didn&#x27;t realize you could order it like that.<p>I&#x27;m realizing now another (and potentially stronger influence) is just years of muscle memory starting pipelines with cat.</div><br/></div></div></div></div></div></div><div id="39458474" class="c"><input type="checkbox" id="c-39458474" checked=""/><div class="controls bullet"><span class="by">NelsonMinar</span><span>|</span><a href="#39459214">prev</a><span>|</span><a href="#39463101">next</a><span>|</span><label class="collapse" for="c-39458474">[-]</label><label class="expand" for="c-39458474">[3 more]</label></div><br/><div class="children"><div class="content">Another reason to do `cat | foo` is because you can then quickly change it to `zcat | foo` or some other source for the data by editing the very beginning of the command.</div><br/><div id="39463980" class="c"><input type="checkbox" id="c-39463980" checked=""/><div class="controls bullet"><span class="by">imp0cat</span><span>|</span><a href="#39458474">parent</a><span>|</span><a href="#39458639">next</a><span>|</span><label class="collapse" for="c-39463980">[-]</label><label class="expand" for="c-39463980">[1 more]</label></div><br/><div class="children"><div class="content">Right, but when using grep, one can use zgrep directly to go through archived files.</div><br/></div></div><div id="39458639" class="c"><input type="checkbox" id="c-39458639" checked=""/><div class="controls bullet"><span class="by">pimlottc</span><span>|</span><a href="#39458474">parent</a><span>|</span><a href="#39463980">prev</a><span>|</span><a href="#39463101">next</a><span>|</span><label class="collapse" for="c-39458639">[-]</label><label class="expand" for="c-39458639">[1 more]</label></div><br/><div class="children"><div class="content">less is useful for this if you have the lesspipe [0] preprocessor installed<p>0: <a href="https:&#x2F;&#x2F;github.com&#x2F;wofr06&#x2F;lesspipe">https:&#x2F;&#x2F;github.com&#x2F;wofr06&#x2F;lesspipe</a></div><br/></div></div></div></div><div id="39463101" class="c"><input type="checkbox" id="c-39463101" checked=""/><div class="controls bullet"><span class="by">Lvl999Noob</span><span>|</span><a href="#39458474">prev</a><span>|</span><a href="#39463224">next</a><span>|</span><label class="collapse" for="c-39463101">[-]</label><label class="expand" for="c-39463101">[1 more]</label></div><br/><div class="children"><div class="content">The only time I made serious use of big pipelines was when I was trying to diagnose some bug in the production system using the log files. At that time, I would make a pipeline with lots of `head`, `tail`, `grep`, etc. I would reorder the filters, change the file it is running on, sometimes run it on multiple files. Using `cat` to feed the initial input was way better than trying to avoid UUoC. Concatenating files became possible, reordering became simple. It was just overall a much better experience with `cat`. In my daily life if I am writing shell pipelines, I still use cat because it just flows better in my brain. Step 1, take the input; step 2, apply filter; step 3, apply other filters; step 4, print it out. When I don&#x27;t even know which filter I am going to be using, it is easier to write the cat and glob the files while my brain catches up on whether I want grep or sed or something else.</div><br/></div></div><div id="39463224" class="c"><input type="checkbox" id="c-39463224" checked=""/><div class="controls bullet"><span class="by">adityaathalye</span><span>|</span><a href="#39463101">prev</a><span>|</span><a href="#39463415">next</a><span>|</span><label class="collapse" for="c-39463224">[-]</label><label class="expand" for="c-39463224">[1 more]</label></div><br/><div class="children"><div class="content">Another rather useful use of `cat` is to make the input stream appear in a specific location withing another stream. e.g. My website [1] maker [2] uses `cat -` to inject content into templates.<p><pre><code>  shite_template_common_default_page() {
      cat &lt;&lt;EOF |
    $(shite_template_common_header)
    &lt;main id=&quot;main&quot;&gt;
      $(cat -)
    &lt;&#x2F;main&gt;
  EOF
      shite_template_standard_page_wrapper
  }
</code></pre>
[1] <a href="https:&#x2F;&#x2F;evalapply.org" rel="nofollow">https:&#x2F;&#x2F;evalapply.org</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;adityaathalye&#x2F;shite?tab=readme-ov-file#templating-system">https:&#x2F;&#x2F;github.com&#x2F;adityaathalye&#x2F;shite?tab=readme-ov-file#te...</a></div><br/></div></div><div id="39463415" class="c"><input type="checkbox" id="c-39463415" checked=""/><div class="controls bullet"><span class="by">wodenokoto</span><span>|</span><a href="#39463224">prev</a><span>|</span><a href="#39458504">next</a><span>|</span><label class="collapse" for="c-39463415">[-]</label><label class="expand" for="c-39463415">[1 more]</label></div><br/><div class="children"><div class="content">Related, I find bash and other shells the only language where I can stream data through processes.<p>Like, R can pipe, and pandas can .pipe() but they both complete the function on the entire data before it pushes a copy of the output to the next step.<p>Why isn’t this flow of data a primitive outside of shell?</div><br/></div></div><div id="39458504" class="c"><input type="checkbox" id="c-39458504" checked=""/><div class="controls bullet"><span class="by">avgcorrection</span><span>|</span><a href="#39463415">prev</a><span>|</span><a href="#39458857">next</a><span>|</span><label class="collapse" for="c-39458504">[-]</label><label class="expand" for="c-39458504">[2 more]</label></div><br/><div class="children"><div class="content">Most immediate use: I have to google less shell syntax.</div><br/><div id="39463251" class="c"><input type="checkbox" id="c-39463251" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#39458504">parent</a><span>|</span><a href="#39458857">next</a><span>|</span><label class="collapse" for="c-39463251">[-]</label><label class="expand" for="c-39463251">[1 more]</label></div><br/><div class="children"><div class="content">Stream of consciousness troubleshooting dies on the search page. Especially with ads.</div><br/></div></div></div></div><div id="39458857" class="c"><input type="checkbox" id="c-39458857" checked=""/><div class="controls bullet"><span class="by">txutxu</span><span>|</span><a href="#39458504">prev</a><span>|</span><a href="#39458456">next</a><span>|</span><label class="collapse" for="c-39458857">[-]</label><label class="expand" for="c-39458857">[2 more]</label></div><br/><div class="children"><div class="content">After read the article... all the reasoning... I think I could go with this for such reasons exposed:<p><pre><code>    perl -ne &#x27;last if $. &gt; 500; &#x2F;mail&#x2F; &amp;&amp; print&#x27; access.log
</code></pre>
When you&#x27;re done with the part after the &amp;&amp;, remove the &#x27;last if $. &gt; 500&#x27;<p>For me, the most useful  use of (gnu) cat, is cat -A weird.file<p>It saves my day or solves weird issues (X-files) with files generated by (not so) junior sysadmins, copy&#x2F;pastes, end of lines, invisible diffs, etc... many times each year.</div><br/><div id="39461429" class="c"><input type="checkbox" id="c-39461429" checked=""/><div class="controls bullet"><span class="by">0xbadcafebee</span><span>|</span><a href="#39458857">parent</a><span>|</span><a href="#39458456">next</a><span>|</span><label class="collapse" for="c-39461429">[-]</label><label class="expand" for="c-39461429">[1 more]</label></div><br/><div class="children"><div class="content">But then it&#x27;s not modular! I need this one-liner to be more complicated because I read a classic paper recently.</div><br/></div></div></div></div><div id="39458456" class="c"><input type="checkbox" id="c-39458456" checked=""/><div class="controls bullet"><span class="by">TehShrike</span><span>|</span><a href="#39458857">prev</a><span>|</span><a href="#39458096">next</a><span>|</span><label class="collapse" for="c-39458456">[-]</label><label class="expand" for="c-39458456">[1 more]</label></div><br/><div class="children"><div class="content">Typo in the title – should be &quot;cat&quot; not &quot;Cat&quot; (same as the h1 in the linked article)</div><br/></div></div><div id="39458096" class="c"><input type="checkbox" id="c-39458096" checked=""/><div class="controls bullet"><span class="by">svilen_dobrev</span><span>|</span><a href="#39458456">prev</a><span>|</span><a href="#39462427">next</a><span>|</span><label class="collapse" for="c-39458096">[-]</label><label class="expand" for="c-39458096">[3 more]</label></div><br/><div class="children"><div class="content">well, whole thing can be written in the perl -ne ...<p>but that absolutely kills modularity &#x2F; composability<p>so yes, &quot;cat xyz&quot; plays a source - and can be replaced with another source - without touching all other stuff.</div><br/><div id="39458131" class="c"><input type="checkbox" id="c-39458131" checked=""/><div class="controls bullet"><span class="by">hk__2</span><span>|</span><a href="#39458096">parent</a><span>|</span><a href="#39462427">next</a><span>|</span><label class="collapse" for="c-39458131">[-]</label><label class="expand" for="c-39458131">[2 more]</label></div><br/><div class="children"><div class="content">&gt; so yes, &quot;cat xyz&quot; plays a source - and can be replaced with another source - without touching all other stuff.<p>This. I often have to read logs and being able to apply the same oneliner on older logs just by adding a &quot;z&quot; in front of &quot;cat&quot; to read .log.gz instead of .log files is extremely useful.</div><br/><div id="39458463" class="c"><input type="checkbox" id="c-39458463" checked=""/><div class="controls bullet"><span class="by">kqr</span><span>|</span><a href="#39458096">root</a><span>|</span><a href="#39458131">parent</a><span>|</span><a href="#39462427">next</a><span>|</span><label class="collapse" for="c-39458463">[-]</label><label class="expand" for="c-39458463">[1 more]</label></div><br/><div class="children"><div class="content">Good point! I often experiment with cat response.json and then replace cat with curl once I&#x27;m happy.</div><br/></div></div></div></div></div></div><div id="39462427" class="c"><input type="checkbox" id="c-39462427" checked=""/><div class="controls bullet"><span class="by">karmakaze</span><span>|</span><a href="#39458096">prev</a><span>|</span><a href="#39459450">next</a><span>|</span><label class="collapse" for="c-39462427">[-]</label><label class="expand" for="c-39462427">[2 more]</label></div><br/><div class="children"><div class="content">If the example used tail rather than head, I would expect passing the file (rather than piping contents) should be noticeably faster for a large file.</div><br/><div id="39464655" class="c"><input type="checkbox" id="c-39464655" checked=""/><div class="controls bullet"><span class="by">PennRobotics</span><span>|</span><a href="#39462427">parent</a><span>|</span><a href="#39459450">next</a><span>|</span><label class="collapse" for="c-39464655">[-]</label><label class="expand" for="c-39464655">[1 more]</label></div><br/><div class="children"><div class="content">I wanted to test this and found a surprising result, although with shuf instead of tail...<p><pre><code>  ( head -n40000 filelist_h.txt | grep &#x27;v\|$&#x27; &gt;&gt; &#x2F;dev&#x2F;null; )       0.00s user 0.02s system  43% cpu  0.045 total
  ( tail -n40000 filelist_h.txt | grep &#x27;v\|$&#x27; &gt;&gt; &#x2F;dev&#x2F;null; )       0.00s user 0.01s system  22% cpu  0.066 total
  ( shuf -n40000 filelist_h.txt | grep &#x27;v\|$&#x27; &gt;&gt; &#x2F;dev&#x2F;null; )       0.71s user 1.37s system  12% cpu 16.874 total
  ( cat filelist_h.txt | head -n40000 | grep &#x27;v\|$&#x27; &gt;&gt; &#x2F;dev&#x2F;null;   0.00s user 0.01s system 101% cpu  0.017 total
  ( cat filelist_h.txt | tail -n40000 | grep &#x27;v\|$&#x27; &gt;&gt; &#x2F;dev&#x2F;null;   0.05s user 0.45s system  54% cpu  0.930 total
  ( cat filelist_h.txt | shuf -n40000 | grep &#x27;v\|$&#x27; &gt;&gt; &#x2F;dev&#x2F;null;   0.60s user 0.91s system  96% cpu  1.565 total
</code></pre>
The results are fairly repeatable:<p>- as expected, head and tail alone are equally quick alone<p>- shuf is ridiculously slow due to overhead compared to cat | shuf<p>- cat | shuf is just a bit slower than cat | tail.<p>- cat | tail is slower than tail.<p>- cat | head is faster than head (but only because of overhead)<p>Caveats are that this is WSL2 and the file is 480 MB (5 million lines) in a mounted Windows directory, although that helps magnify that slow I&#x2F;O can influence how you pipe commands.</div><br/></div></div></div></div><div id="39459450" class="c"><input type="checkbox" id="c-39459450" checked=""/><div class="controls bullet"><span class="by">az09mugen</span><span>|</span><a href="#39462427">prev</a><span>|</span><a href="#39458369">next</a><span>|</span><label class="collapse" for="c-39459450">[-]</label><label class="expand" for="c-39459450">[2 more]</label></div><br/><div class="children"><div class="content">Among the uses of cat, I saw no one mention you can write or append text to a file, like this :<p><pre><code>    cat &gt; file.txt  # after this command, just type your text
</code></pre>
Or to append :<p><pre><code>    cat &gt;&gt; file.txt
</code></pre>
Can also work with Here Doc syntax :<p><pre><code>    cat &gt; file.txt &lt;&lt; EOF
    This is the text to write down
    EOF</code></pre></div><br/><div id="39463234" class="c"><input type="checkbox" id="c-39463234" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#39459450">parent</a><span>|</span><a href="#39458369">next</a><span>|</span><label class="collapse" for="c-39463234">[-]</label><label class="expand" for="c-39463234">[1 more]</label></div><br/><div class="children"><div class="content">Somewhere along the way it had been so long since I used cat to concatenate files that I had to relearn to do so. That felt either very silly or, “I’ve forgotten more about X than you’ll ever know”<p>But probably the former.</div><br/></div></div></div></div><div id="39458369" class="c"><input type="checkbox" id="c-39458369" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39459450">prev</a><span>|</span><a href="#39458904">next</a><span>|</span><label class="collapse" for="c-39458369">[-]</label><label class="expand" for="c-39458369">[4 more]</label></div><br/><div class="children"><div class="content">This blogger does not seem to know that in the POSIX shell syntax, redirections can be specified anywhere in the command:<p><pre><code>   &lt; access.log head -n 500 | grep mail | perl -e
</code></pre>
Now you can delete &quot;head -n 500 |&quot;.<p>&gt; <i>If we then delete only the head processing step we’re left without a step that transforms the string access.log into the contents of the access log.</i><p>By introducing &quot;cat access.log&quot; we have the same problem: if we delete only the cat processing step, we&#x27;re left without a step that transforms the string access.log into the contents. For the useless cat to have the nice property that you can cleanly delete it from the command line, you need:<p><pre><code>   &lt; access.log | cat | head -n 500 ...
</code></pre>
:)</div><br/><div id="39461845" class="c"><input type="checkbox" id="c-39461845" checked=""/><div class="controls bullet"><span class="by">Bost</span><span>|</span><a href="#39458369">parent</a><span>|</span><a href="#39461496">next</a><span>|</span><label class="collapse" for="c-39461845">[-]</label><label class="expand" for="c-39461845">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sorry, that doesn&#x27;t work:<p><pre><code>  $ echo &quot;foo&quot; &gt; access.log     # create the access.log with some content
  $ &lt; access.log | cat | head -n 5
  # no output
</code></pre>
This works:<p><pre><code>  $ cat access.log | head -n 5
  foo
  $ &lt; access.log cat | head -n 5
  foo
  $ &lt; access.log cat | cat | head -n 5
  foo
  $ &lt; access.log head -n 5
  foo</code></pre></div><br/></div></div><div id="39461496" class="c"><input type="checkbox" id="c-39461496" checked=""/><div class="controls bullet"><span class="by">jameshart</span><span>|</span><a href="#39458369">parent</a><span>|</span><a href="#39461845">prev</a><span>|</span><a href="#39458904">next</a><span>|</span><label class="collapse" for="c-39461496">[-]</label><label class="expand" for="c-39461496">[2 more]</label></div><br/><div class="children"><div class="content">The useless cat plays the role of ‘a process that produces a stream’, which gives you higher confidence that you can substitute it with a different ‘process that produces a stream’ - like the curl command mentioned in the article, or perhaps a server whose stdout output you want to analyse.<p>It should be the same as giving your pipeline a file input handle via &lt; access.log… but why take the risk?</div><br/><div id="39463364" class="c"><input type="checkbox" id="c-39463364" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39458369">root</a><span>|</span><a href="#39461496">parent</a><span>|</span><a href="#39458904">next</a><span>|</span><label class="collapse" for="c-39463364">[-]</label><label class="expand" for="c-39463364">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the whole mistake. Streams are not sourced by processes, but by kernel objects. You don&#x27;t need a process to read bytes from a serial port, for instance. You don&#x27;t need &quot;cat &#x2F;dev&#x2F;ttywhatever | program&quot;.   Interrupt handlers in the drivers already drive the activity of bytes being received.</div><br/></div></div></div></div></div></div><div id="39458904" class="c"><input type="checkbox" id="c-39458904" checked=""/><div class="controls bullet"><span class="by">cgs1019</span><span>|</span><a href="#39458369">prev</a><span>|</span><a href="#39462665">next</a><span>|</span><label class="collapse" for="c-39458904">[-]</label><label class="expand" for="c-39458904">[2 more]</label></div><br/><div class="children"><div class="content">`cat -n` prints with line numbers, which is occasionally handy.</div><br/><div id="39460359" class="c"><input type="checkbox" id="c-39460359" checked=""/><div class="controls bullet"><span class="by">JTbane</span><span>|</span><a href="#39458904">parent</a><span>|</span><a href="#39462665">next</a><span>|</span><label class="collapse" for="c-39460359">[-]</label><label class="expand" for="c-39460359">[1 more]</label></div><br/><div class="children"><div class="content">nl?</div><br/></div></div></div></div><div id="39462665" class="c"><input type="checkbox" id="c-39462665" checked=""/><div class="controls bullet"><span class="by">hyperthesis</span><span>|</span><a href="#39458904">prev</a><span>|</span><a href="#39460341">next</a><span>|</span><label class="collapse" for="c-39462665">[-]</label><label class="expand" for="c-39462665">[1 more]</label></div><br/><div class="children"><div class="content">Similar to TFA&#x27;s footnote 4 (switching from `cat` to `curl`), it&#x27;s easier to edit the filename with `cat`, because it&#x27;s nearer the start.</div><br/></div></div><div id="39460341" class="c"><input type="checkbox" id="c-39460341" checked=""/><div class="controls bullet"><span class="by">psim1</span><span>|</span><a href="#39462665">prev</a><span>|</span><a href="#39458472">next</a><span>|</span><label class="collapse" for="c-39460341">[-]</label><label class="expand" for="c-39460341">[4 more]</label></div><br/><div class="children"><div class="content">$ killall cat | cat | cat | cat | cat | cat<p>Terminated: 15<p>Which cat died first?</div><br/><div id="39460949" class="c"><input type="checkbox" id="c-39460949" checked=""/><div class="controls bullet"><span class="by">urbandw311er</span><span>|</span><a href="#39460341">parent</a><span>|</span><a href="#39461014">next</a><span>|</span><label class="collapse" for="c-39460949">[-]</label><label class="expand" for="c-39460949">[2 more]</label></div><br/><div class="children"><div class="content">I’m guessing none, since if I assume the commands are executed sequentially then, at the time of execution of killall, the cat commands are not yet running.<p>Fascinated to know the actual answer though.</div><br/><div id="39461029" class="c"><input type="checkbox" id="c-39461029" checked=""/><div class="controls bullet"><span class="by">GrumpySloth</span><span>|</span><a href="#39460341">root</a><span>|</span><a href="#39460949">parent</a><span>|</span><a href="#39461014">next</a><span>|</span><label class="collapse" for="c-39461029">[-]</label><label class="expand" for="c-39461029">[1 more]</label></div><br/><div class="children"><div class="content">Pipelines are executed in parallel.</div><br/></div></div></div></div><div id="39461014" class="c"><input type="checkbox" id="c-39461014" checked=""/><div class="controls bullet"><span class="by">GrumpySloth</span><span>|</span><a href="#39460341">parent</a><span>|</span><a href="#39460949">prev</a><span>|</span><a href="#39458472">next</a><span>|</span><label class="collapse" for="c-39461014">[-]</label><label class="expand" for="c-39461014">[1 more]</label></div><br/><div class="children"><div class="content">The Schrödinger’s cat.</div><br/></div></div></div></div><div id="39458472" class="c"><input type="checkbox" id="c-39458472" checked=""/><div class="controls bullet"><span class="by">ufo</span><span>|</span><a href="#39460341">prev</a><span>|</span><a href="#39459517">next</a><span>|</span><label class="collapse" for="c-39458472">[-]</label><label class="expand" for="c-39458472">[4 more]</label></div><br/><div class="children"><div class="content">If the shell were to treat cat as a builtin, could it implement cat| as a stdin redirect?<p>I wish I could write &quot;useless cat&quot; without people pestering me about it.</div><br/><div id="39458599" class="c"><input type="checkbox" id="c-39458599" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39458472">parent</a><span>|</span><a href="#39459517">next</a><span>|</span><label class="collapse" for="c-39458599">[-]</label><label class="expand" for="c-39458599">[3 more]</label></div><br/><div class="children"><div class="content">Bash allows the $(&lt; file) syntax instead of $(cat file), and I think the latter might be converted to the former.</div><br/><div id="39459706" class="c"><input type="checkbox" id="c-39459706" checked=""/><div class="controls bullet"><span class="by">neuromanser</span><span>|</span><a href="#39458472">root</a><span>|</span><a href="#39458599">parent</a><span>|</span><a href="#39459517">next</a><span>|</span><label class="collapse" for="c-39459706">[-]</label><label class="expand" for="c-39459706">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s built-in in Zsh: The substitution ‘$(cat foo)’ may be replaced by the faster ‘$(&lt;foo)’.<p><a href="https:&#x2F;&#x2F;zsh.sourceforge.io&#x2F;Doc&#x2F;Release&#x2F;Expansion.html#Command-Substitution" rel="nofollow">https:&#x2F;&#x2F;zsh.sourceforge.io&#x2F;Doc&#x2F;Release&#x2F;Expansion.html#Comman...</a></div><br/><div id="39460925" class="c"><input type="checkbox" id="c-39460925" checked=""/><div class="controls bullet"><span class="by">ufo</span><span>|</span><a href="#39458472">root</a><span>|</span><a href="#39459706">parent</a><span>|</span><a href="#39459517">next</a><span>|</span><label class="collapse" for="c-39460925">[-]</label><label class="expand" for="c-39460925">[1 more]</label></div><br/><div class="children"><div class="content">Is that only for command substitution?</div><br/></div></div></div></div></div></div></div></div><div id="39459517" class="c"><input type="checkbox" id="c-39459517" checked=""/><div class="controls bullet"><span class="by">jl6</span><span>|</span><a href="#39458472">prev</a><span>|</span><a href="#39458299">next</a><span>|</span><label class="collapse" for="c-39459517">[-]</label><label class="expand" for="c-39459517">[1 more]</label></div><br/><div class="children"><div class="content">If only output redirection syntax was w&gt; instead of &gt;w. Then you could write pipelines with compelling HTML-esque symmetry:<p>&lt;x Y | Z w&gt;</div><br/></div></div><div id="39458299" class="c"><input type="checkbox" id="c-39458299" checked=""/><div class="controls bullet"><span class="by">gregfjohnson</span><span>|</span><a href="#39459517">prev</a><span>|</span><label class="collapse" for="c-39458299">[-]</label><label class="expand" for="c-39458299">[3 more]</label></div><br/><div class="children"><div class="content">Thoughtful article - thanks.  Humorous aside:  I recently came across a hilariously named, occasionally useful, related utility:  &quot;tac&quot;.</div><br/><div id="39458426" class="c"><input type="checkbox" id="c-39458426" checked=""/><div class="controls bullet"><span class="by">ryukoposting</span><span>|</span><a href="#39458299">parent</a><span>|</span><label class="collapse" for="c-39458426">[-]</label><label class="expand" for="c-39458426">[2 more]</label></div><br/><div class="children"><div class="content">It ships with coreutils! `rev` is another one in a similar vein, though that&#x27;s not coreutils.</div><br/><div id="39460946" class="c"><input type="checkbox" id="c-39460946" checked=""/><div class="controls bullet"><span class="by">mprovost</span><span>|</span><a href="#39458299">root</a><span>|</span><a href="#39458426">parent</a><span>|</span><label class="collapse" for="c-39460946">[-]</label><label class="expand" for="c-39460946">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a bit surprised `rev` isn&#x27;t in coreutils, it&#x27;s ancient. Originally written because `cut` doesn&#x27;t allow selecting fields from the end of a line. So to get the last field in each line, you reverse each line (right to left) with `rev`, select the first field with `cut`, and then reverse it again with `rev`.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>