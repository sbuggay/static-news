<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1716368468768" as="style"/><link rel="stylesheet" href="styles.css?v=1716368468768"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://stevelosh.com/blog/2018/08/a-road-to-common-lisp/">A Road to Common Lisp (2018)</a> <span class="domain">(<a href="https://stevelosh.com">stevelosh.com</a>)</span></div><div class="subtext"><span>fuzztester</span> | <span>52 comments</span></div><br/><div><div id="40436926" class="c"><input type="checkbox" id="c-40436926" checked=""/><div class="controls bullet"><span class="by">b3lm0nt</span><span>|</span><a href="#40436840">next</a><span>|</span><label class="collapse" for="c-40436926">[-]</label><label class="expand" for="c-40436926">[16 more]</label></div><br/><div class="children"><div class="content">I wanted to love Common Lisp, but as a Vim user every day was a struggle. One typically uses plugins (Slimv, Vlime) that contort buffers in bizarre ways in order to simulate the SLIME EMacs REPL — if not, they will lose out on the interactive development experience that is so central to CL.<p>Being tied to either EMacs or  an enterprise solution like LispWorks to get the full language experience was ultimately a non-starter. I’d love for someone to build an alternative CL development experience that could work in a wider range of text editors and IDEs.<p>There is a lot to learn from CL, but I think it can be hard to access for most developers.</div><br/><div id="40436941" class="c"><input type="checkbox" id="c-40436941" checked=""/><div class="controls bullet"><span class="by">nomilk</span><span>|</span><a href="#40436926">parent</a><span>|</span><a href="#40437254">next</a><span>|</span><label class="collapse" for="c-40436941">[-]</label><label class="expand" for="c-40436941">[6 more]</label></div><br/><div class="children"><div class="content">A flavour of emacs called &#x27;doom emacs&#x27; is basically emacs for vim users (same keybindings and many similar features): <a href="https:&#x2F;&#x2F;github.com&#x2F;doomemacs&#x2F;doomemacs?tab=readme-ov-file#doom-emacs">https:&#x2F;&#x2F;github.com&#x2F;doomemacs&#x2F;doomemacs?tab=readme-ov-file#do...</a><p>Great set of instructions for how to set it up here: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=xyXDE5gP2QI" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=xyXDE5gP2QI</a><p>(and if you&#x27;re on macOS, this video is flawless for installation specifics: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=A6SxH9lUWV0" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=A6SxH9lUWV0</a>)</div><br/><div id="40437227" class="c"><input type="checkbox" id="c-40437227" checked=""/><div class="controls bullet"><span class="by">kaeland</span><span>|</span><a href="#40436926">root</a><span>|</span><a href="#40436941">parent</a><span>|</span><a href="#40438008">next</a><span>|</span><label class="collapse" for="c-40437227">[-]</label><label class="expand" for="c-40437227">[3 more]</label></div><br/><div class="children"><div class="content">As a vim user, I’ve been using doom emacs for the past 3.5 years and haven’t looked back yet. I really enjoy the Common Lisp experience while using doom as well.</div><br/><div id="40437422" class="c"><input type="checkbox" id="c-40437422" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#40436926">root</a><span>|</span><a href="#40437227">parent</a><span>|</span><a href="#40438008">next</a><span>|</span><label class="collapse" for="c-40437422">[-]</label><label class="expand" for="c-40437422">[2 more]</label></div><br/><div class="children"><div class="content">I appreciate the message you&#x27;re conveying (I also switched from using vim for years to emacs for years, probably for good) but man, we have to stop attaching tools to our identities.<p>You&#x27;re not only more than a vim user, you don&#x27;t even use vim!</div><br/><div id="40437479" class="c"><input type="checkbox" id="c-40437479" checked=""/><div class="controls bullet"><span class="by">bmacho</span><span>|</span><a href="#40436926">root</a><span>|</span><a href="#40437422">parent</a><span>|</span><a href="#40438008">next</a><span>|</span><label class="collapse" for="c-40437479">[-]</label><label class="expand" for="c-40437479">[1 more]</label></div><br/><div class="children"><div class="content">Stop being vim-purist! There are so many ways that one can be a vim user, and yes, using vim is not necessary</div><br/></div></div></div></div></div></div><div id="40438008" class="c"><input type="checkbox" id="c-40438008" checked=""/><div class="controls bullet"><span class="by">medo-bear</span><span>|</span><a href="#40436926">root</a><span>|</span><a href="#40436941">parent</a><span>|</span><a href="#40437227">prev</a><span>|</span><a href="#40437254">next</a><span>|</span><label class="collapse" for="c-40438008">[-]</label><label class="expand" for="c-40438008">[2 more]</label></div><br/><div class="children"><div class="content">Common Lisp in Doom uses Sly. If you want to stick to Slime and prefer vim ergonomics to those of Emacs there is also Spacemacs, which I just learned even has its own Wikipedia page: <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Spacemacs" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Spacemacs</a></div><br/><div id="40438853" class="c"><input type="checkbox" id="c-40438853" checked=""/><div class="controls bullet"><span class="by">sandbach</span><span>|</span><a href="#40436926">root</a><span>|</span><a href="#40438008">parent</a><span>|</span><a href="#40437254">next</a><span>|</span><label class="collapse" for="c-40438853">[-]</label><label class="expand" for="c-40438853">[1 more]</label></div><br/><div class="children"><div class="content">That sort of thing is all configurable. It&#x27;s easy to tell Doom Emacs to use Slime instead.</div><br/></div></div></div></div></div></div><div id="40437254" class="c"><input type="checkbox" id="c-40437254" checked=""/><div class="controls bullet"><span class="by">reikonomusha</span><span>|</span><a href="#40436926">parent</a><span>|</span><a href="#40436941">prev</a><span>|</span><a href="#40437104">next</a><span>|</span><label class="collapse" for="c-40437254">[-]</label><label class="expand" for="c-40437254">[3 more]</label></div><br/><div class="children"><div class="content">&quot;Lem is the editor&#x2F;IDE well-tuned for Common Lisp. [...] If you come from Emacs or Vim, you will feel right at home.&quot;<p><a href="https:&#x2F;&#x2F;lem-project.github.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lem-project.github.io&#x2F;</a></div><br/><div id="40438023" class="c"><input type="checkbox" id="c-40438023" checked=""/><div class="controls bullet"><span class="by">medo-bear</span><span>|</span><a href="#40436926">root</a><span>|</span><a href="#40437254">parent</a><span>|</span><a href="#40437104">next</a><span>|</span><label class="collapse" for="c-40438023">[-]</label><label class="expand" for="c-40438023">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious, how does Lem compare to Emacs as a common lisp ide?</div><br/><div id="40438268" class="c"><input type="checkbox" id="c-40438268" checked=""/><div class="controls bullet"><span class="by">alt0_</span><span>|</span><a href="#40436926">root</a><span>|</span><a href="#40438023">parent</a><span>|</span><a href="#40437104">next</a><span>|</span><label class="collapse" for="c-40438268">[-]</label><label class="expand" for="c-40438268">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s pretty raw and buggy still, but if you&#x27;re already a cl hacker, you&#x27;ll certainly enjoy it.<p>It is missing most useful Emacs features but also seems to have some of it&#x27;s own, particularly for CL.</div><br/></div></div></div></div></div></div><div id="40437104" class="c"><input type="checkbox" id="c-40437104" checked=""/><div class="controls bullet"><span class="by">orthecreedence</span><span>|</span><a href="#40436926">parent</a><span>|</span><a href="#40437254">prev</a><span>|</span><a href="#40437006">next</a><span>|</span><label class="collapse" for="c-40437104">[-]</label><label class="expand" for="c-40437104">[1 more]</label></div><br/><div class="children"><div class="content">Back in my CL days I <i>loved</i> Slimv. It had its warts, but was miles beyond having a shell with a REPL open. I imagine it has only gotten better since (I haven&#x27;t touched lisp in almost 10 years now). That said, I never gave Emacs a serious shake so I was probably missing out quite a lot on what a good interactive experience could be.</div><br/></div></div><div id="40437006" class="c"><input type="checkbox" id="c-40437006" checked=""/><div class="controls bullet"><span class="by">jimbokun</span><span>|</span><a href="#40436926">parent</a><span>|</span><a href="#40437104">prev</a><span>|</span><a href="#40437291">next</a><span>|</span><label class="collapse" for="c-40437006">[-]</label><label class="expand" for="c-40437006">[3 more]</label></div><br/><div class="children"><div class="content">Understandable, but it also seems like there is a disconnect between the philosophy of vi and the philosophy of Lisp.  Vi is designed to be purely a text editor, and not an environment for building text based applications.  Common Lisp being so inherently interactive, seems to require a dynamic, interactive text editing environment.  Like Emacs.</div><br/><div id="40437577" class="c"><input type="checkbox" id="c-40437577" checked=""/><div class="controls bullet"><span class="by">ngcc_hk</span><span>|</span><a href="#40436926">root</a><span>|</span><a href="#40437006">parent</a><span>|</span><a href="#40437291">next</a><span>|</span><label class="collapse" for="c-40437577">[-]</label><label class="expand" for="c-40437577">[2 more]</label></div><br/><div class="children"><div class="content">But that is old.  Vim can easily interact with lisp real time.  It would and probably never will be the same as emacs which is a lisp env.  Still it is good enough.</div><br/><div id="40437888" class="c"><input type="checkbox" id="c-40437888" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#40436926">root</a><span>|</span><a href="#40437577">parent</a><span>|</span><a href="#40437291">next</a><span>|</span><label class="collapse" for="c-40437888">[-]</label><label class="expand" for="c-40437888">[1 more]</label></div><br/><div class="children"><div class="content">GNU Emacs nor XEmacs also can not behave like ZMACS on lisp machines - there&#x27;s just as much disconnect as between (n)ViM and lisp image. It&#x27;s always a remote, RPC-like relation.<p>In fact, I&#x27;d say that a certain ancient Erlang mode for Emacs resulted in closer relationship between Emacs and Erlang, as it made Emacs into a process in OTP cluster.</div><br/></div></div></div></div></div></div><div id="40437291" class="c"><input type="checkbox" id="c-40437291" checked=""/><div class="controls bullet"><span class="by">sitzkrieg</span><span>|</span><a href="#40436926">parent</a><span>|</span><a href="#40437006">prev</a><span>|</span><a href="#40436840">next</a><span>|</span><label class="collapse" for="c-40437291">[-]</label><label class="expand" for="c-40437291">[2 more]</label></div><br/><div class="children"><div class="content">i agree and went through the same struggles before totally giving up, i discovered racket along way tho so it was a net win</div><br/><div id="40438032" class="c"><input type="checkbox" id="c-40438032" checked=""/><div class="controls bullet"><span class="by">medo-bear</span><span>|</span><a href="#40436926">root</a><span>|</span><a href="#40437291">parent</a><span>|</span><a href="#40436840">next</a><span>|</span><label class="collapse" for="c-40438032">[-]</label><label class="expand" for="c-40438032">[1 more]</label></div><br/><div class="children"><div class="content">You should give common lisp another chance and see what you have been missing in racket.</div><br/></div></div></div></div></div></div><div id="40436840" class="c"><input type="checkbox" id="c-40436840" checked=""/><div class="controls bullet"><span class="by">nomilk</span><span>|</span><a href="#40436926">prev</a><span>|</span><a href="#40436807">next</a><span>|</span><label class="collapse" for="c-40436840">[-]</label><label class="expand" for="c-40436840">[21 more]</label></div><br/><div class="children"><div class="content">Great read. Highly fond of long single-pagers.<p>Curious why lisp&#x27;s REPL is frequently touted as an incredible language feature e.g.:<p>&gt; Support for this style of interactive development doesn&#x27;t just come from some fancy editor plugins — it&#x27;s baked into the bones of the language.<p>&gt; So how do you actually get this wonderful interactive experience?<p>I&#x27;ve only ever programmed in interpreted languages (R, ruby), so I can&#x27;t really understand how or why a REPL is so great since to me a (console|REPL|interpreter) is a standard feature (nothing extraordinary). Perhaps because I haven&#x27;t had to work in a language without the convenient and immediate ability to execute arbitrary user inputs (as a REPL or interpreter can), for example a compiled language.</div><br/><div id="40436999" class="c"><input type="checkbox" id="c-40436999" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#40436840">parent</a><span>|</span><a href="#40437133">next</a><span>|</span><label class="collapse" for="c-40436999">[-]</label><label class="expand" for="c-40436999">[1 more]</label></div><br/><div class="children"><div class="content">Had you worked in Fortran, Pascal or Algol or C, and been forced to think linearly to a deck of cards, and a job queue, and do all the marshalling of the IO into that job queue through some horrendous syntax of JCL of some kind, then the experience of being in a REPL might be more momentus. Instead you&#x27;re a fish swimming in clear water not understanding why water is so unbelievably amazing if you haven&#x27;t been in it before.<p>Of course LISPians want to make their REPL very meta, compared to any REPL, and it is: its degree of self-introspection, and the potential to modify the REPL is a REPL on steroids experience. But just being a REPL, is pretty damn amazing if you had to uplift from write-compile-assemble-marshall-coordinate-queue-run-cleanup &quot;before&quot;<p>(I did learn on punched cards in the 70s. Bugs hurt at a 20 min production-to-run cycle, some people were a drive away from the batch queue, and a 1 day turnaround was good.)</div><br/></div></div><div id="40437133" class="c"><input type="checkbox" id="c-40437133" checked=""/><div class="controls bullet"><span class="by">nanomonkey</span><span>|</span><a href="#40436840">parent</a><span>|</span><a href="#40436999">prev</a><span>|</span><a href="#40437889">next</a><span>|</span><label class="collapse" for="c-40437133">[-]</label><label class="expand" for="c-40437133">[1 more]</label></div><br/><div class="children"><div class="content">The REPL can be much more than a prompt where you execute code.  In fact with many editors you can evaluate blocks of lisp code directly.  Networked REPL&#x27;s are amazing, specially when you&#x27;re fixing code on machines that are difficult to physically access, like in space. The ability to query the current value of a symbol (function, macro, variable, record) and replace it at runtime without clobbering the runtime state is a great boon to the development process.<p>Also Common Lisp and a few Schemes allow you to interpret <i>and</i> compile a symbol&#x27;s value (to speed up execution).</div><br/></div></div><div id="40437889" class="c"><input type="checkbox" id="c-40437889" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#40436840">parent</a><span>|</span><a href="#40437133">prev</a><span>|</span><a href="#40436913">next</a><span>|</span><label class="collapse" for="c-40437889">[-]</label><label class="expand" for="c-40437889">[1 more]</label></div><br/><div class="children"><div class="content">&gt; compiled language<p>more like &quot;batch compiled language&quot;. In many Lisps one would incrementally compile code. Common Lisp has already three functions built-in: LOAD, COMPILE and COMPILE-FILE. How they work is depending on the implementation, but LOAD typically can load source and compiled files, COMPILE compiles a single function in memory, and COMPILE-FILE compiles a source file to a compiled file (native machine code or some byte-code). SBCL for example compiles with these functions every thing to machine code, which it does anyway, by default.<p>One of the things which make this useable for incremental work is the symbol table, which holds all symbols and its values&amp;functions. One can change the function of a symbol at runtime and global function calls go through this symbol table (-&gt; late binding). So an update to a function has effect on its next call.</div><br/></div></div><div id="40436913" class="c"><input type="checkbox" id="c-40436913" checked=""/><div class="controls bullet"><span class="by">troad</span><span>|</span><a href="#40436840">parent</a><span>|</span><a href="#40437889">prev</a><span>|</span><a href="#40436860">next</a><span>|</span><label class="collapse" for="c-40436913">[-]</label><label class="expand" for="c-40436913">[3 more]</label></div><br/><div class="children"><div class="content">The difference, as I understand it, is that the REPL <i>is</i> the running Lisp, and all of its code. You can inspect or redefine any function inside of Lisp itself, live, no matter how integral, in the same way you input any of your own code.<p>The interactive mode of interpreted languages is more of a sandbox, from that perspective.</div><br/><div id="40437911" class="c"><input type="checkbox" id="c-40437911" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#40436840">root</a><span>|</span><a href="#40436913">parent</a><span>|</span><a href="#40437296">next</a><span>|</span><label class="collapse" for="c-40437911">[-]</label><label class="expand" for="c-40437911">[1 more]</label></div><br/><div class="children"><div class="content">The REPL often is also the default debugger. On error one gets a debug REPL at the point of the error (no unwinding), one debug level deeper. The debug REPL is basically a normal REPL, but with some debug features (stack movement, ...) and the ability to call predefined restarts in the code.</div><br/></div></div><div id="40437296" class="c"><input type="checkbox" id="c-40437296" checked=""/><div class="controls bullet"><span class="by">reikonomusha</span><span>|</span><a href="#40436840">root</a><span>|</span><a href="#40436913">parent</a><span>|</span><a href="#40437911">prev</a><span>|</span><a href="#40436860">next</a><span>|</span><label class="collapse" for="c-40437296">[-]</label><label class="expand" for="c-40437296">[1 more]</label></div><br/><div class="children"><div class="content">This is a pretty reasonable approximation. The REPL is also the library-fetcher, program loader, compiler, debugger, disassembler, and profiler.</div><br/></div></div></div></div><div id="40436860" class="c"><input type="checkbox" id="c-40436860" checked=""/><div class="controls bullet"><span class="by">ColonelPhantom</span><span>|</span><a href="#40436840">parent</a><span>|</span><a href="#40436913">prev</a><span>|</span><a href="#40437424">next</a><span>|</span><label class="collapse" for="c-40436860">[-]</label><label class="expand" for="c-40436860">[4 more]</label></div><br/><div class="children"><div class="content">When using Python, the REPL does not feel remotely integral to the experience. For example, my Django project, when an exception occurs in debug mode, has a nice page with a backtrace et cetera. However, I cannot resume, or poke around using a REPL, or even view details of local variables. I feel like if Django was implemented in Common Lisp this would not be a problem at all, if not for technical reasons then for cultural reasons.</div><br/><div id="40437039" class="c"><input type="checkbox" id="c-40437039" checked=""/><div class="controls bullet"><span class="by">matthewn</span><span>|</span><a href="#40436840">root</a><span>|</span><a href="#40436860">parent</a><span>|</span><a href="#40436902">next</a><span>|</span><label class="collapse" for="c-40437039">[-]</label><label class="expand" for="c-40437039">[2 more]</label></div><br/><div class="children"><div class="content">If you install the django-extensions package and use runserver_plus instead of runserver, when you hit an exception you get a live REPL in your browser where you can poke around and inspect at will. It&#x27;s not CL-level power, but it&#x27;s mighty useful.</div><br/><div id="40438478" class="c"><input type="checkbox" id="c-40438478" checked=""/><div class="controls bullet"><span class="by">struanr</span><span>|</span><a href="#40436840">root</a><span>|</span><a href="#40437039">parent</a><span>|</span><a href="#40436902">next</a><span>|</span><label class="collapse" for="c-40438478">[-]</label><label class="expand" for="c-40438478">[1 more]</label></div><br/><div class="children"><div class="content">For non Django code, the IPython REPL with the %pdb magic enabled drops you in a ipdb debugger on an exception. Doesn&#x27;t allow resuming but still very useful.</div><br/></div></div></div></div><div id="40436902" class="c"><input type="checkbox" id="c-40436902" checked=""/><div class="controls bullet"><span class="by">wrs</span><span>|</span><a href="#40436840">root</a><span>|</span><a href="#40436860">parent</a><span>|</span><a href="#40437039">prev</a><span>|</span><a href="#40437424">next</a><span>|</span><label class="collapse" for="c-40436902">[-]</label><label class="expand" for="c-40436902">[1 more]</label></div><br/><div class="children"><div class="content">Over on the Ruby side, there is a library [0] that gives your web application error pages with a live REPL in them.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;BetterErrors&#x2F;better_errors">https:&#x2F;&#x2F;github.com&#x2F;BetterErrors&#x2F;better_errors</a></div><br/></div></div></div></div><div id="40437424" class="c"><input type="checkbox" id="c-40437424" checked=""/><div class="controls bullet"><span class="by">spit2wind</span><span>|</span><a href="#40436840">parent</a><span>|</span><a href="#40436860">prev</a><span>|</span><a href="#40437514">next</a><span>|</span><label class="collapse" for="c-40437424">[-]</label><label class="expand" for="c-40437424">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s a great demo of the REPL: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=_B_4vhsmRRI" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=_B_4vhsmRRI</a></div><br/></div></div><div id="40437514" class="c"><input type="checkbox" id="c-40437514" checked=""/><div class="controls bullet"><span class="by">skydhash</span><span>|</span><a href="#40436840">parent</a><span>|</span><a href="#40437424">prev</a><span>|</span><a href="#40437359">next</a><span>|</span><label class="collapse" for="c-40437514">[-]</label><label class="expand" for="c-40437514">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Curious why lisp&#x27;s REPL is frequently touted as an incredible language feature e.g.</i><p>Another language that’s great in that regard is Smalltalk&#x2F;Pharo. It’s the Minecraft of programming languages. Your program start as an IDE and you morph it to what you want. Feels like building a car while it’s running.</div><br/></div></div><div id="40437359" class="c"><input type="checkbox" id="c-40437359" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#40436840">parent</a><span>|</span><a href="#40437514">prev</a><span>|</span><a href="#40437013">next</a><span>|</span><label class="collapse" for="c-40437359">[-]</label><label class="expand" for="c-40437359">[1 more]</label></div><br/><div class="children"><div class="content">An important thing to remember is that both R and Ruby have directly, wholly, imported the REPL approach (not just having an interpreter you can type at, like Python) from Lisp&#x2F;Common Lisp - with R arguably fitting as Lisp-family language if with different syntax (Ruby&#x27;s other inspirations were Smalltalk obviously, and less known was being Perl replacement)</div><br/></div></div><div id="40437013" class="c"><input type="checkbox" id="c-40437013" checked=""/><div class="controls bullet"><span class="by">killerstorm</span><span>|</span><a href="#40436840">parent</a><span>|</span><a href="#40437359">prev</a><span>|</span><a href="#40437552">next</a><span>|</span><label class="collapse" for="c-40437013">[-]</label><label class="expand" for="c-40437013">[6 more]</label></div><br/><div class="children"><div class="content">Jupiter works good as long as all your code is in one file. You can&#x27;t really modify code outside of cells you made.<p>In Common Lisp you can develop a project with multiple files interactively, you can even modify library code, maybe even the runtime</div><br/><div id="40437058" class="c"><input type="checkbox" id="c-40437058" checked=""/><div class="controls bullet"><span class="by">nomilk</span><span>|</span><a href="#40436840">root</a><span>|</span><a href="#40437013">parent</a><span>|</span><a href="#40437552">next</a><span>|</span><label class="collapse" for="c-40437058">[-]</label><label class="expand" for="c-40437058">[5 more]</label></div><br/><div class="children"><div class="content">&gt; you can even modify library code, maybe even the runtime<p>this would be difficult (and not recommended) but not strictly impossible in languages other than lisp (e.g. read library files, edit them, re-write them, re-load the library).<p>But to play devil&#x27;s advocate, isn&#x27;t the language feature that makes this easy in lisp its homoiconicity, as opposed to its REPL?</div><br/><div id="40437874" class="c"><input type="checkbox" id="c-40437874" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#40436840">root</a><span>|</span><a href="#40437058">parent</a><span>|</span><a href="#40437936">next</a><span>|</span><label class="collapse" for="c-40437874">[-]</label><label class="expand" for="c-40437874">[2 more]</label></div><br/><div class="children"><div class="content">Another feature of CL, specifically CLOS, is that it actually has a formal protocol for changing classes.<p>A formal protocol you can tap into. While hardly omniscient, I don’t know of another language that does offer this. I don’t even think Smalltalk has this. (Smalltalk has a fundamental primitive related to this called “become:”, which can be used for this purpose, but that’s less formal than what CLOS provides.)<p>What does this mean? It means that you can change the structure of classes, AND their instances, in a live, running system. Not just their structure, but how the system transmutes from the old structure to the new structure. How the conversion is done.<p>What does this have to do with the REPL? It’s part and parcel of the kind of environment and functionality of the system that is exposed by the REPL.<p>The REPL is not just a console that you can type into, and use backspace, and what not. It’s the door to the very rich world underlying the system.<p>And this is the key point. In CL, the REPL is not an afterthought. It’s not an add-on. It’s a core competency. Much of this no doubt came from the Lisp Machine experience, where all you had was a running image that, like a surgeon, you had your arms elbow deep into. A system where you could not trivially just stop and restart for every little change. A system where you had to have the ability to change the tires on a running vehicle.<p>The vast majority of modern REPL environments don’t have that burden, so when things get tough, they can punt. “Eh, just restart and do over.”<p>It’s absolutely fair to consider whether that quality is actually still germane in the modern era. Hard to imagine a scenario where you might do something like a change like this on a running server, especially in our age of “cattle, not pets”.<p>But the legacy is still there from that past time. A time when not only were they pets, they were coddled and spoiled. So the folks back then had to think this stuff through.</div><br/><div id="40437942" class="c"><input type="checkbox" id="c-40437942" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#40436840">root</a><span>|</span><a href="#40437874">parent</a><span>|</span><a href="#40437936">next</a><span>|</span><label class="collapse" for="c-40437942">[-]</label><label class="expand" for="c-40437942">[1 more]</label></div><br/><div class="children"><div class="content">If AWS had an R&amp;D Labs division with zero expectation of profit I think you could sell them an idea of Elastic Lisp Machine where a deployment is not a restart but whatever you need to do in the lisp world. (Patch an image…? No idea but sounds cool!)</div><br/></div></div></div></div><div id="40437936" class="c"><input type="checkbox" id="c-40437936" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#40436840">root</a><span>|</span><a href="#40437058">parent</a><span>|</span><a href="#40437874">prev</a><span>|</span><a href="#40437315">next</a><span>|</span><label class="collapse" for="c-40437936">[-]</label><label class="expand" for="c-40437936">[1 more]</label></div><br/><div class="children"><div class="content">The language features that make this possible are a) late-binding and b) resident development tools (compiler, debugger, interpreter, inspector, trace, ... are all included in the runtime).</div><br/></div></div><div id="40437315" class="c"><input type="checkbox" id="c-40437315" checked=""/><div class="controls bullet"><span class="by">skydhash</span><span>|</span><a href="#40436840">root</a><span>|</span><a href="#40437058">parent</a><span>|</span><a href="#40437936">prev</a><span>|</span><a href="#40437552">next</a><span>|</span><label class="collapse" for="c-40437315">[-]</label><label class="expand" for="c-40437315">[1 more]</label></div><br/><div class="children"><div class="content">Not really. The runtime, plus your code is a virtual machine. It’s similar to docker container in that regard. The REPL is your shell. And you can poke around everything. Another language that has that is Smalltalk&#x2F;pharo. In comparison, the Python REPL feel like the os part was burned on ROM.</div><br/></div></div></div></div></div></div><div id="40437552" class="c"><input type="checkbox" id="c-40437552" checked=""/><div class="controls bullet"><span class="by">hayley-patton</span><span>|</span><a href="#40436840">parent</a><span>|</span><a href="#40437013">prev</a><span>|</span><a href="#40436807">next</a><span>|</span><label class="collapse" for="c-40437552">[-]</label><label class="expand" for="c-40437552">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a lot of language semantics which make the REPL convenient to write interesting amounts of code in, Gilad Bracha details some in &lt;<a href="https:&#x2F;&#x2F;blog.bracha.org&#x2F;primordialsoup.html?snapshot=AmpleforthViewer.vfuel&amp;docName=ReplacingREPLs" rel="nofollow">https:&#x2F;&#x2F;blog.bracha.org&#x2F;primordialsoup.html?snapshot=Amplefo...</a>&gt; (with the message reflected in the medium, embedding the Newspeak IDE in the document for examples). It&#x27;s unrelated to compiling or interpreting; many Common Lisp implementations will compile code from the REPL too.</div><br/></div></div></div></div><div id="40436807" class="c"><input type="checkbox" id="c-40436807" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#40436840">prev</a><span>|</span><a href="#40438655">next</a><span>|</span><label class="collapse" for="c-40436807">[-]</label><label class="expand" for="c-40436807">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>A Road to Common Lisp (2018)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31645558">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31645558</a> - June 2022 (48 comments)<p><i>A Road to Common Lisp</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=17852194">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=17852194</a> - Aug 2018 (92 comments)</div><br/></div></div><div id="40438655" class="c"><input type="checkbox" id="c-40438655" checked=""/><div class="controls bullet"><span class="by">anentropic</span><span>|</span><a href="#40436807">prev</a><span>|</span><a href="#40437567">next</a><span>|</span><label class="collapse" for="c-40438655">[-]</label><label class="expand" for="c-40438655">[3 more]</label></div><br/><div class="children"><div class="content">&gt; JSON support in Common Lisp is a god damn mess<p>Is the JSON situation any better now in 2024?</div><br/><div id="40438786" class="c"><input type="checkbox" id="c-40438786" checked=""/><div class="controls bullet"><span class="by">varjag</span><span>|</span><a href="#40438655">parent</a><span>|</span><a href="#40438729">next</a><span>|</span><label class="collapse" for="c-40438786">[-]</label><label class="expand" for="c-40438786">[1 more]</label></div><br/><div class="children"><div class="content">This piece is enthusiastic but a bit subjective. I personally had zero troubles with JSON in CL, just chose one library and use it. Would also disagree with some his recommendations, e.g. Drakma has a lacking interface for error handling and Dexador is nicer for use in prod.</div><br/></div></div><div id="40438729" class="c"><input type="checkbox" id="c-40438729" checked=""/><div class="controls bullet"><span class="by">cess11</span><span>|</span><a href="#40438655">parent</a><span>|</span><a href="#40438786">prev</a><span>|</span><a href="#40437567">next</a><span>|</span><label class="collapse" for="c-40438729">[-]</label><label class="expand" for="c-40438729">[1 more]</label></div><br/><div class="children"><div class="content">JSON is a messy format, you&#x27;ll always have to know your requirements well to be able to pick a fitting parser for it.<p>Are you going to parse a simple, small key-value-structure? Pretty much any library will solve it for you or you could invent your own simple parser.<p>If you need to stream gigabytes of complicated JSON and do sophisticated transformations back into JSON or something like that, then you&#x27;ll have to evaluate several libraries and have a look at how they translate into CL datatypes. Some might reduce a combination of false, null, the empty list to NIL, which could lead to information loss and surprises.</div><br/></div></div></div></div><div id="40437567" class="c"><input type="checkbox" id="c-40437567" checked=""/><div class="controls bullet"><span class="by">ngcc_hk</span><span>|</span><a href="#40438655">prev</a><span>|</span><a href="#40436254">next</a><span>|</span><label class="collapse" for="c-40437567">[-]</label><label class="expand" for="c-40437567">[1 more]</label></div><br/><div class="children"><div class="content">This totally changed me and enjoy lisp so much more using vim.  No more emacs.<p><a href="https:&#x2F;&#x2F;susam.net&#x2F;lisp-in-vim.html" rel="nofollow">https:&#x2F;&#x2F;susam.net&#x2F;lisp-in-vim.html</a></div><br/></div></div><div id="40436254" class="c"><input type="checkbox" id="c-40436254" checked=""/><div class="controls bullet"><span class="by">e12e</span><span>|</span><a href="#40437567">prev</a><span>|</span><a href="#40436513">next</a><span>|</span><label class="collapse" for="c-40436254">[-]</label><label class="expand" for="c-40436254">[1 more]</label></div><br/><div class="children"><div class="content">(2018)</div><br/></div></div><div id="40436464" class="c"><input type="checkbox" id="c-40436464" checked=""/><div class="controls bullet"><span class="by">sapling-ginger</span><span>|</span><a href="#40436513">prev</a><span>|</span><label class="collapse" for="c-40436464">[-]</label><label class="expand" for="c-40436464">[7 more]</label></div><br/><div class="children"><div class="content">The author first says that CL people usually avoid dependency hell:<p>&gt;When programming applications in Common Lisp people will often depend on a small(ish) number of stable libraries, and library writers often try to minimize dependencies by utilizing as much of the core language as possible.<p>But then try to expound on CL&#x27;s extensibility using libraries:<p>&gt; No one has been clamoring for a new version of the specification that adds features because Common Lisp&#x27;s extensibility allows users to add new features to the language as plain old libraries<p>Very contradictory, and these two paragraphs are in two adjacent sections.</div><br/><div id="40436648" class="c"><input type="checkbox" id="c-40436648" checked=""/><div class="controls bullet"><span class="by">iLemming</span><span>|</span><a href="#40436464">parent</a><span>|</span><a href="#40436955">next</a><span>|</span><label class="collapse" for="c-40436648">[-]</label><label class="expand" for="c-40436648">[2 more]</label></div><br/><div class="children"><div class="content">As other pointed out, there&#x27;s no contradiction. I would like to add that CL often avoids dependency hell with:<p>- Standardized Specification: Common Lisp has a stable and comprehensive standard that reduces the need for external libraries.<p>- Load Time Flexibility: Its dynamic nature allows loading and reloading of code at runtime, facilitating easier management of dependencies.<p>- Isolation through Packages: The Lisp package system provides a way to encapsulate code and manage namespaces effectively, reducing conflicts.<p>- Backward Compatibility: Common Lisp places a strong emphasis on backward compatibility, which helps in maintaining stability across versions.<p>- Mature Ecosystem: Many Common Lisp projects are long-lived and stable, leading to a mature ecosystem with less frequent breaking changes.<p>I can&#x27;t claim to be a very experienced CL coder, but I wrote enough Clojure, and similarly, rarely ever see dependency problems, even though Clojure heavily relies on the JVM ecosystem, inheriting both its strengths and complexities. Clojure emphasizes interoperability with Java and uses many Java libraries, which can introduce complex dependency trees and conflicts common in the Java ecosystem, yet at the same time, Clojure emphasizes small, composable libraries (often referred to as the &quot;small libraries&quot; philosophy), reducing the likelihood of large, monolithic dependencies causing issues. The community prioritizes modularity and ease of composition, leading to the prevalence of smaller, more focused libraries. Common Lisp in contrast tends to favor more extensive libraries or systems that provide a broad set of features within a single package.</div><br/><div id="40437463" class="c"><input type="checkbox" id="c-40437463" checked=""/><div class="controls bullet"><span class="by">skydhash</span><span>|</span><a href="#40436464">root</a><span>|</span><a href="#40436648">parent</a><span>|</span><a href="#40436955">next</a><span>|</span><label class="collapse" for="c-40437463">[-]</label><label class="expand" for="c-40437463">[1 more]</label></div><br/><div class="children"><div class="content">The thing is that’s once you’ve casted most external inputs to lisp data structures, you don’t really need anything else other than utility algorithms (crypto,…). And with metaprogramming, it’s easier to do stuff without special classes and decorator. You can visualize the code as data being transformed, as a chain of transformers, or when you do metaprogramming as data generating code and code generating data. It’s all organic and you can do a lot without external code, because very soon you’re coding with a language adapted to your problem domain.<p>To GP: Think about how simple the HTTP protocol is (the core), so if you want a web framework, you want something that will map the headers and the body to cl data structures and then you can go to solve smaller problems like routing, auth, response generation,… Then you notice boilerplate and you macro them out. Same for most client libraries. It really easy to add an ad-hoc library that solve your problems. So you do that instead of reaching to others’ code.</div><br/></div></div></div></div><div id="40436955" class="c"><input type="checkbox" id="c-40436955" checked=""/><div class="controls bullet"><span class="by">kloop</span><span>|</span><a href="#40436464">parent</a><span>|</span><a href="#40436648">prev</a><span>|</span><a href="#40436479">next</a><span>|</span><label class="collapse" for="c-40436955">[-]</label><label class="expand" for="c-40436955">[1 more]</label></div><br/><div class="children"><div class="content">The lisp world has a rather different idea of extensibility via library than you are used to.<p>For example, the Common Lisp Object System (CLOS, object oriented programming in lisp) originated as a library. Lisp&#x27;s main looping mechanism (loop) also originated as a macro (although long before CL standardization).<p>You just don&#x27;t do js levels of dependencies when they&#x27;re adding big features like that. You don&#x27;t need 100,000 programming paradigms in your code base.</div><br/></div></div><div id="40436479" class="c"><input type="checkbox" id="c-40436479" checked=""/><div class="controls bullet"><span class="by">mepian</span><span>|</span><a href="#40436464">parent</a><span>|</span><a href="#40436955">prev</a><span>|</span><a href="#40436486">next</a><span>|</span><label class="collapse" for="c-40436479">[-]</label><label class="expand" for="c-40436479">[1 more]</label></div><br/><div class="children"><div class="content">How is this contradictory? The point is that you can extend the language when you really need it.</div><br/></div></div><div id="40436486" class="c"><input type="checkbox" id="c-40436486" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#40436464">parent</a><span>|</span><a href="#40436479">prev</a><span>|</span><a href="#40436516">next</a><span>|</span><label class="collapse" for="c-40436486">[-]</label><label class="expand" for="c-40436486">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see any contradiction in those two points. Both of them can simultaneously be true.</div><br/></div></div></div></div></div></div></div></div></div></body></html>