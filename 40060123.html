<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1713344471025" as="style"/><link rel="stylesheet" href="styles.css?v=1713344471025"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://rmarcus.info/blog/2024/04/12/pg-over-time.html">Ten years of improvements in PostgreSQL&#x27;s optimizer</a> <span class="domain">(<a href="https://rmarcus.info">rmarcus.info</a>)</span></div><div class="subtext"><span>samaysharma</span> | <span>19 comments</span></div><br/><div><div id="40061666" class="c"><input type="checkbox" id="c-40061666" checked=""/><div class="controls bullet"><span class="by">DoubleFree</span><span>|</span><a href="#40060946">next</a><span>|</span><label class="collapse" for="c-40061666">[-]</label><label class="expand" for="c-40061666">[1 more]</label></div><br/><div class="children"><div class="content">The postgres query optimizer will try to minimize the number of pages read from disk (and the number of intermediate pages written to disk). Benchmarking the query optimizer by making the shared buffers large enough to hold all the data therefore seems wrong, as you&#x27;re then measuring the speed of the query optimizer and the join processor, instead of the quality of the generated query plans. It would not surprise me if the generated plans for these versions are actually all the same and this is only measuring execution speed.</div><br/></div></div><div id="40060946" class="c"><input type="checkbox" id="c-40060946" checked=""/><div class="controls bullet"><span class="by">BitPirate</span><span>|</span><a href="#40061666">prev</a><span>|</span><a href="#40060415">next</a><span>|</span><label class="collapse" for="c-40060946">[-]</label><label class="expand" for="c-40060946">[2 more]</label></div><br/><div class="children"><div class="content">The author mentions PostgreSQL&#x27;s JIT compiler. Up to this day, I&#x27;ve only seen it degrade the performance of queries. Disabling it is on my install checklist.</div><br/><div id="40061567" class="c"><input type="checkbox" id="c-40061567" checked=""/><div class="controls bullet"><span class="by">LunaSea</span><span>|</span><a href="#40060946">parent</a><span>|</span><a href="#40060415">next</a><span>|</span><label class="collapse" for="c-40061567">[-]</label><label class="expand" for="c-40061567">[1 more]</label></div><br/><div class="children"><div class="content">The JIT compiler is great for analytical queries.<p>You can configure thresholds for the JIT activation in PostgreSQL as well if you want to elevate the bar from which the JIT is enabled.</div><br/></div></div></div></div><div id="40060415" class="c"><input type="checkbox" id="c-40060415" checked=""/><div class="controls bullet"><span class="by">uhoh-itsmaciek</span><span>|</span><a href="#40060946">prev</a><span>|</span><a href="#40060414">next</a><span>|</span><label class="collapse" for="c-40060415">[-]</label><label class="expand" for="c-40060415">[2 more]</label></div><br/><div class="children"><div class="content">Neat, but Postgres version numbering changed with v10. 9.6, 9.5, 9.4, 9.3, 9.2, 9.1, 9.0, 8.4, 8.3, 8.2, 8.1, and 8.0 are effectively all distinct major versions. It&#x27;d be interesting to see how perf changed with those.</div><br/><div id="40061549" class="c"><input type="checkbox" id="c-40061549" checked=""/><div class="controls bullet"><span class="by">guiriduro</span><span>|</span><a href="#40060415">parent</a><span>|</span><a href="#40060414">next</a><span>|</span><label class="collapse" for="c-40061549">[-]</label><label class="expand" for="c-40061549">[1 more]</label></div><br/><div class="children"><div class="content">But at least they maintained the courtesy of major version filesystem compatibility allowing faster in-place upgrades during an extended period (from v9.0 - 9.6), by simply changing the binaries. Possibly that held them back, but yearly updates that require more downtime&#x2F;reindexing isn&#x27;t so much fun, and possibly the reason why many sites skip upgrades until previous versions drop out of support (esp AWS RDS users). While the alternative of a logical replication upgrade (from v10 onward) has availability benefits, its a major project with unavoidable costs and significant risks unless schemas are relatively simple.</div><br/></div></div></div></div><div id="40060414" class="c"><input type="checkbox" id="c-40060414" checked=""/><div class="controls bullet"><span class="by">nsilvestri</span><span>|</span><a href="#40060415">prev</a><span>|</span><a href="#40060428">next</a><span>|</span><label class="collapse" for="c-40060414">[-]</label><label class="expand" for="c-40060414">[6 more]</label></div><br/><div class="children"><div class="content">Proebsting&#x27;s Law comes to mind: <a href="https:&#x2F;&#x2F;proebsting.cs.arizona.edu&#x2F;law.html" rel="nofollow">https:&#x2F;&#x2F;proebsting.cs.arizona.edu&#x2F;law.html</a></div><br/><div id="40061896" class="c"><input type="checkbox" id="c-40061896" checked=""/><div class="controls bullet"><span class="by">fear91</span><span>|</span><a href="#40060414">parent</a><span>|</span><a href="#40060887">next</a><span>|</span><label class="collapse" for="c-40061896">[-]</label><label class="expand" for="c-40061896">[1 more]</label></div><br/><div class="children"><div class="content">The nice thing about compiler optimizations is that you can improve performance of existing CPU&#x27;s without physically touching them. Year by year. You squeeze more of the machine someone designed. It adds up.<p>Imagine what environmental impact you would have if you optimized Python&#x27;s performance by 1%? How much CO2 are you removing from the atmosphere? It&#x27;s likely to overshadow the environmental footprint of you, your family and all your friends combined. Hell, maybe it&#x27;s the entire city you live in. All because someone spent time implementing a few bitwise tricks.</div><br/></div></div><div id="40060887" class="c"><input type="checkbox" id="c-40060887" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#40060414">parent</a><span>|</span><a href="#40061896">prev</a><span>|</span><a href="#40060585">next</a><span>|</span><label class="collapse" for="c-40060887">[-]</label><label class="expand" for="c-40060887">[1 more]</label></div><br/><div class="children"><div class="content">Why? The at law seems to talk about how performance software improvements isn’t relevant while this article talks about how there improvements to Postgres has been significant.<p>Is it because you view the 15% to be a low number? Because it really, really, isn’t in the context. It’s certainly smaller than the 60% from your linked law especially if you do the whole 15&#x2F;10 thing, but you really shouldn’t compare Postgres’s performance to hardware increases because they aren’t the same. You would need absolutely massive amounts of hardware improvements to compare to even 1% performance on what is being measured here.<p>I don’t think the law is as silly as other posters here, but it’s talking about programming language compile times. I wouldn’t compare something as unimportant as that to what is arguably one of the most important things in computer science… considering how much data storage and consumption means to our world.</div><br/></div></div><div id="40060585" class="c"><input type="checkbox" id="c-40060585" checked=""/><div class="controls bullet"><span class="by">cpeterso</span><span>|</span><a href="#40060414">parent</a><span>|</span><a href="#40060887">prev</a><span>|</span><a href="#40060832">next</a><span>|</span><label class="collapse" for="c-40060585">[-]</label><label class="expand" for="c-40060585">[1 more]</label></div><br/><div class="children"><div class="content">In this case, the researcher built each PostgreSQL version using the same GCC version (13.2) and tested on the same OS.</div><br/></div></div><div id="40060832" class="c"><input type="checkbox" id="c-40060832" checked=""/><div class="controls bullet"><span class="by">waterproof</span><span>|</span><a href="#40060414">parent</a><span>|</span><a href="#40060585">prev</a><span>|</span><a href="#40060583">next</a><span>|</span><label class="collapse" for="c-40060832">[-]</label><label class="expand" for="c-40060832">[1 more]</label></div><br/><div class="children"><div class="content">That seems like a very weak “law”. Is it meant as a joke? The supporting evidence is just numbers pulled apparently from nowhere (“let’s assume…”) and the conclusion is wildly off base. They seem to imply that if optimization improves the performance of much of the world’s software, by 4% each year, then it’s a waste of time.<p>Murphy’s law is the only comparison given. I wonder what the comparative expense is to develop faster and faster hardware, vs. to keep improving compilers. Depending on how the ROIs compare, (in dollars-per-percent gain, let’s say) maybe this “law” is worth some weight.<p>OTOH, the Postgres article in question seems to show diminishing returns from optimization, which belies the whole premise of the “law” which assumes the gain is consistent from year to year. And might prove Prorbstig’s implied point about optimization being a bad investment over the long term!</div><br/></div></div></div></div><div id="40060428" class="c"><input type="checkbox" id="c-40060428" checked=""/><div class="controls bullet"><span class="by">uhoh-itsmaciek</span><span>|</span><a href="#40060414">prev</a><span>|</span><a href="#40060904">next</a><span>|</span><label class="collapse" for="c-40060428">[-]</label><label class="expand" for="c-40060428">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Of course, not all of these improvements are attributable to the query optimizer.<p>It would be interesting to see plan changes, if any, across versions.</div><br/></div></div><div id="40060904" class="c"><input type="checkbox" id="c-40060904" checked=""/><div class="controls bullet"><span class="by">morepork</span><span>|</span><a href="#40060428">prev</a><span>|</span><a href="#40060677">next</a><span>|</span><label class="collapse" for="c-40060904">[-]</label><label class="expand" for="c-40060904">[1 more]</label></div><br/><div class="children"><div class="content">Site seems to be down, you can try this instead:
<a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20240417050840&#x2F;https:&#x2F;&#x2F;rmarcus.info&#x2F;blog&#x2F;2024&#x2F;04&#x2F;12&#x2F;pg-over-time.html" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20240417050840&#x2F;https:&#x2F;&#x2F;rmarcus.i...</a></div><br/></div></div><div id="40060677" class="c"><input type="checkbox" id="c-40060677" checked=""/><div class="controls bullet"><span class="by">edweis</span><span>|</span><a href="#40060904">prev</a><span>|</span><a href="#40060440">next</a><span>|</span><label class="collapse" for="c-40060677">[-]</label><label class="expand" for="c-40060677">[4 more]</label></div><br/><div class="children"><div class="content">How query optimisation looks like? Does it optimize on the SQL or algorithm level?</div><br/><div id="40061274" class="c"><input type="checkbox" id="c-40061274" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#40060677">parent</a><span>|</span><a href="#40061118">next</a><span>|</span><label class="collapse" for="c-40061274">[-]</label><label class="expand" for="c-40061274">[1 more]</label></div><br/><div class="children"><div class="content">For the databases I&#x27;ve used, which excludes PostgreSQL, most optimization happens on algorithmic level, that is, selecting the best algorithms to use for a given query and in what order to execute them.<p>From what I gather this is mostly because various different SQL queries might get transformed into the same &quot;instructions&quot;, or execution plan, but also because SQL semantics doesn&#x27;t leave much room for language-level optimizations.<p>As a sibling comment noted, an important decision is if you can replace a full table scan with an index lookup or index scan instead.<p>For example, if you need to do a full table scan, and do significant computation per row to determine if a row should be included in the result set, the optimizer might change the full table scan with a parallel table scan then merge the results from each parallel task.<p>When writing performant code for a compiler, you&#x27;ll want to know how your compilers optimizer transforms the source code to machine instructions, so you prefer writing code the optimizer handles well and avoid writing code the optimizer outputs slower machine instructions for. After all the optimizer is programmed to detect certain patterns and transform them.<p>Same thing with a query optimizer and its execution plan. You&#x27;ll have to learn which patterns the query optimizer in the database you&#x27;re using can handle and generate efficient execution plans for.</div><br/></div></div><div id="40061118" class="c"><input type="checkbox" id="c-40061118" checked=""/><div class="controls bullet"><span class="by">BenoitP</span><span>|</span><a href="#40060677">parent</a><span>|</span><a href="#40061274">prev</a><span>|</span><a href="#40061495">next</a><span>|</span><label class="collapse" for="c-40061118">[-]</label><label class="expand" for="c-40061118">[1 more]</label></div><br/><div class="children"><div class="content">It describes all the way the SQL could be executed, then choses the faster plan. For example: if you&#x27;re looking for the user row with user_id xx, do you read the full table then filter it (you have to look at all the rows)? Or do you use the dedicated data structure to do so (an index will enable to do it in the logarithm of the number of rows)?<p>A lot more can be done: choosing the join order, choosing the join strategies, pushing the filter predicates at the source, etc. That&#x27;s the vast topic of SQL optimization.</div><br/></div></div><div id="40061495" class="c"><input type="checkbox" id="c-40061495" checked=""/><div class="controls bullet"><span class="by">mdavidn</span><span>|</span><a href="#40060677">parent</a><span>|</span><a href="#40061118">prev</a><span>|</span><a href="#40060440">next</a><span>|</span><label class="collapse" for="c-40061495">[-]</label><label class="expand" for="c-40061495">[1 more]</label></div><br/><div class="children"><div class="content">At a very high level, the query planner&#x27;s goal is to minimize the cost of reading data from disk. It gathers pre-computed column statistics, like counts of rows and distinct values, to estimate the number of rows a query is likely to match. It uses this information to order joins and choose indexes, among other things. Joins can be accomplished with several different algorithms, like hashing or looping or merging. The cheapest option depends on factors like whether one side fits in working memory or whether both sides are already sorted, e.g. thanks to index scans.</div><br/></div></div></div></div><div id="40060440" class="c"><input type="checkbox" id="c-40060440" checked=""/><div class="controls bullet"><span class="by">throwaway984393</span><span>|</span><a href="#40060677">prev</a><span>|</span><label class="collapse" for="c-40060440">[-]</label><label class="expand" for="c-40060440">[1 more]</label></div><br/><div class="children"><div class="content">It would arguably be more accurate to compare the actual systems running Postgres and their precompiled binaries. Nearly everything else in a given system running a given version of an application may have an impact on its performance in subtle ways. Its development occurred in conjunction with these other system components, thus it was optimized for them. In addition, distributions tend to ship their binaries with patches not found upstream which can also affect performance. Everything from the kernel and scheduler to glibc and more may affect performance. Newer isn&#x27;t always faster. Even the containerization you now use might add a subtle penalty that an older non-containered version may not experience.<p>Basically, it&#x27;s theoretically possible that some old ass system running version 8 runs it faster than your current system runs version 8 (excluding hardware).<p>Add to that all the other usual caveats about benchmarks etc (like the fact that IO wasn&#x27;t tested here but is pretty dang relevant to real world performance)</div><br/></div></div></div></div></div></div></div></body></html>