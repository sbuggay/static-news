<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1695286863102" as="style"/><link rel="stylesheet" href="styles.css?v=1695286863102"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/goldsborough/clang-expand">Clang-expand: Expand function invocations into current scope</a>Â <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>6keZbCECT2uB</span> | <span>11 comments</span></div><br/><div><div id="37594839" class="c"><input type="checkbox" id="c-37594839" checked=""/><div class="controls bullet"><span class="by">CrendKing</span><span>|</span><a href="#37588209">next</a><span>|</span><label class="collapse" for="c-37594839">[-]</label><label class="expand" for="c-37594839">[1 more]</label></div><br/><div class="children"><div class="content">I sincerely don&#x27;t understand when is this useful. It basically removes all the existing abstractions in the code, and replaces with inline code. Those abstractions were created by someone for some reasons. Blindly destroying them in the name of &quot;refactoring&quot; is just wrong. Refactoring should be process that involves intellectual creativity, involves deeply understanding the intricacy of dependencies and references, not mechanically expanding functions and call it done.<p>Of course, just like rust-analyzer&#x27;s &quot;Expand macro recursively&quot; command, this could be used as an analysis utility, even better if it works not only on functions but also C&#x2F;C++ macros.</div><br/></div></div><div id="37588209" class="c"><input type="checkbox" id="c-37588209" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#37594839">prev</a><span>|</span><a href="#37589156">next</a><span>|</span><label class="collapse" for="c-37588209">[-]</label><label class="expand" for="c-37588209">[2 more]</label></div><br/><div class="children"><div class="content">Very very nice. But it should really be an action in clangd instead of its own tool, for simple integration with LSP.<p>Also instead of always replacing the text, it could also be an overlay, where the function call is temporarily expanded in your IDE while in some special mode.</div><br/><div id="37588664" class="c"><input type="checkbox" id="c-37588664" checked=""/><div class="controls bullet"><span class="by">6keZbCECT2uB</span><span>|</span><a href="#37588209">parent</a><span>|</span><a href="#37589156">next</a><span>|</span><label class="collapse" for="c-37588664">[-]</label><label class="expand" for="c-37588664">[1 more]</label></div><br/><div class="children"><div class="content">The choice between replacing and making it an overlay is up to your editor. I think it would be pretty to handle either choice as a plugin in your editor given the returned json.<p>I was surprised it wasn&#x27;t combined with clangd.</div><br/></div></div></div></div><div id="37589156" class="c"><input type="checkbox" id="c-37589156" checked=""/><div class="controls bullet"><span class="by">kevincox</span><span>|</span><a href="#37588209">prev</a><span>|</span><a href="#37591589">next</a><span>|</span><label class="collapse" for="c-37589156">[-]</label><label class="expand" for="c-37589156">[1 more]</label></div><br/><div class="children"><div class="content">rust-analyzer has this as well. I&#x27;ve never actually used it though. In most cases where I would have found it useful the function was so simple that I just did it manually without thinking. This also seems to do a better job cleaning up the resulting code than rust-analyzer does for example.<p><pre><code>    let cell = self.cell_mut(pos);
</code></pre>
Becomes:<p><pre><code>    let cell = {
      let ref mut this = self;
      &amp;mut this.board[usize::from(pos)]
    };
</code></pre>
Instead of:<p><pre><code>    let cell = &amp;mut self.board[usize::from(pos)];
</code></pre>
It did manage to simplify the argument (maybe because it was the same name?) but had to rename `self`.</div><br/></div></div><div id="37591589" class="c"><input type="checkbox" id="c-37591589" checked=""/><div class="controls bullet"><span class="by">MauranKilom</span><span>|</span><a href="#37589156">prev</a><span>|</span><a href="#37591455">next</a><span>|</span><label class="collapse" for="c-37591589">[-]</label><label class="expand" for="c-37591589">[5 more]</label></div><br/><div class="children"><div class="content">Maybe I&#x27;m the only one, but... why?<p>What about by-hand-inlining `std::find` makes the code better?</div><br/><div id="37594665" class="c"><input type="checkbox" id="c-37594665" checked=""/><div class="controls bullet"><span class="by">the-smug-one</span><span>|</span><a href="#37591589">parent</a><span>|</span><a href="#37593167">next</a><span>|</span><label class="collapse" for="c-37594665">[-]</label><label class="expand" for="c-37594665">[1 more]</label></div><br/><div class="children"><div class="content">I just want to know what code is actually called. This is often a pain in C++. I assume this code handles SFINAE etc.</div><br/></div></div><div id="37593167" class="c"><input type="checkbox" id="c-37593167" checked=""/><div class="controls bullet"><span class="by">sweetjuly</span><span>|</span><a href="#37591589">parent</a><span>|</span><a href="#37594665">prev</a><span>|</span><a href="#37591666">next</a><span>|</span><label class="collapse" for="c-37593167">[-]</label><label class="expand" for="c-37593167">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s great for doing security reviews! Often times with crazy template and macro ridden code, it&#x27;s a challenge to even find the implementation for something. Sometimes it&#x27;s easier to compile the binary, throw it into Ghidra, and look at the disassembly and decompilation to grok what the code is actually doing than try to bounce your way through a dozen templates and types.</div><br/></div></div><div id="37591666" class="c"><input type="checkbox" id="c-37591666" checked=""/><div class="controls bullet"><span class="by">Conscat</span><span>|</span><a href="#37591589">parent</a><span>|</span><a href="#37593167">prev</a><span>|</span><a href="#37594705">next</a><span>|</span><label class="collapse" for="c-37591666">[-]</label><label class="expand" for="c-37591666">[1 more]</label></div><br/><div class="children"><div class="content">Clang has a statement attribute `[[clang::always_inline]]` that automates this at a call site, but GCC only has a function attribute for it. You could wrap the function in a `[[gnu::flatten]]` function that takes the callable as a non-type template parameter in C++20 to do this, though, but that could be more aggressive than what you want. It also won&#x27;t work for operators as easily as this.<p>You can already expand macros at call site in any major C++ editor, so why <i>not</i> functions as well?<p>I would like this mainly just for making source exploration easier. Visual Studio and Clion have a &quot;peek&quot; feature that does something similar, but as a purely UI element, but Emacs&#x27; implementation of peek from LSP works much worse.</div><br/></div></div><div id="37594705" class="c"><input type="checkbox" id="c-37594705" checked=""/><div class="controls bullet"><span class="by">choppaface</span><span>|</span><a href="#37591589">parent</a><span>|</span><a href="#37591666">prev</a><span>|</span><a href="#37591455">next</a><span>|</span><label class="collapse" for="c-37594705">[-]</label><label class="expand" for="c-37594705">[1 more]</label></div><br/><div class="children"><div class="content">Copy-pasta is typically a no-no, but this tool sure helps experiment especially when templates &#x2F; types are complex.<p>Moreover things like SFINAE, variadic functions, and macros can make some libraries really opaque.  Stuff like loggers, pub-subs, SERDES code... there will be a lot of template complexity and other indirection where this tool would help dramatically in peeling back the layers and could be used in place of breakpoints or a traditional debugger.  (And it can often be hard to set up a debug session for large systems).<p>Can also be useful when you want to take an existing function and customize it for the call site versus write a new helper.  For example maybe you want std::find_if() but instead of writing a lambda predicate you want some other code embedded into the body of the loop.</div><br/></div></div></div></div><div id="37591455" class="c"><input type="checkbox" id="c-37591455" checked=""/><div class="controls bullet"><span class="by">smasher164</span><span>|</span><a href="#37591589">prev</a><span>|</span><label class="collapse" for="c-37591455">[-]</label><label class="expand" for="c-37591455">[1 more]</label></div><br/><div class="children"><div class="content">This is so cool! I want this for every language now.</div><br/></div></div></div></div></div></div></div></body></html>