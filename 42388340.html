<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1733994055633" as="style"/><link rel="stylesheet" href="styles.css?v=1733994055633"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://andyatkinson.com/django-python-postgres-busy-rails-developer">Django and Postgres for the Busy Rails Developer</a> <span class="domain">(<a href="https://andyatkinson.com">andyatkinson.com</a>)</span></div><div class="subtext"><span>plaur782</span> | <span>93 comments</span></div><br/><div><div id="42390386" class="c"><input type="checkbox" id="c-42390386" checked=""/><div class="controls bullet"><span class="by">pmontra</span><span>|</span><a href="#42390331">next</a><span>|</span><label class="collapse" for="c-42390386">[-]</label><label class="expand" for="c-42390386">[60 more]</label></div><br/><div class="children"><div class="content">I&#x27;m working on a Rails and on a Django project for two different customers and I&#x27;ve been doing that for years now. I&#x27;d pick Rails over Django any time for every single feature.<p>The absolute worst Django feature is the templating language. It seems to be designed to slow down developers to the like of old time Java web apps, almost mandatory templatetags et all.<p>The query language is moderately bad, quite verbose (Model.objects every time) for no good reason.<p>The lack of common project structure means that every project is different.<p>There is no Capistrano to deploy. I wrote something like that myself and we have been using it for maybe 7 years.<p>I&#x27;m sure I could go on for a while if I keep thinking about it, but you got the gist of it.<p>On the Rails side, sometimes I&#x27;d like to have a talk with some of the previous developers of the Rails app, which hid some important functionality in a before save callback in a different module for no particular reason, but one can be too clever with Python too. However the language (Python) is quite dull, which can be a good or a bad thing. It&#x27;s very subjective. It&#x27;s a Ruby gone bad at design time to me.</div><br/><div id="42394664" class="c"><input type="checkbox" id="c-42394664" checked=""/><div class="controls bullet"><span class="by">brokegrammer</span><span>|</span><a href="#42390386">parent</a><span>|</span><a href="#42394684">next</a><span>|</span><label class="collapse" for="c-42394664">[-]</label><label class="expand" for="c-42394664">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The absolute worst Django feature is the templating language. It seems to be designed to slow down developers to the like of old time Java web apps, almost mandatory templatetags et all.<p>They wanted to provide safe and clean templating, so they decided to force developers to write tags instead of putting logic inside templates.<p>I agree it&#x27;s quite overkill because I still want to run code like I would with ERB or PHP sometimes instead of being forced to write a tag. But this can lead to difficult to debug templates and security problems.<p>&gt; The query language is moderately bad, quite verbose (Model.objects every time) for no good reason.<p>The idea was to make the separation between Model and QuerySet objects obvious. When you access the <i>objects</i> property on the model object, you&#x27;re actually accessing the QuerySet.<p>It seems weird because in Rails, everything is encapsulated in the model&#x27;s class. But Python devs tend to prefer explicit code. In Django we also have the Manager class as an additional layer used to build QuerySets. I&#x27;d say it&#x27;s just a different architecture instead of a shortcoming.<p>&gt; The lack of common project structure means that every project is different.<p>This is a real problem but I reckon that big Rails projects aren&#x27;t as easy to navigate either because most don&#x27;t stick to the Rails way as soon as custom business logic is needed.<p>I would say that Django isn&#x27;t worse than Rails. They just decided to be more strict in some places, which isn&#x27;t necessarily a bad thing. In the end, you just need to work with whatever you prefer.</div><br/><div id="42397173" class="c"><input type="checkbox" id="c-42397173" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42394664">parent</a><span>|</span><a href="#42397092">next</a><span>|</span><label class="collapse" for="c-42397173">[-]</label><label class="expand" for="c-42397173">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &gt; The query language is moderately bad, quite verbose (Model.objects every time) for no good reason.<p>&gt; The idea was to make the separation between Model and QuerySet objects obvious. When you access the objects property on the model object, you&#x27;re actually accessing the QuerySet.<p>&gt; It seems weird because in Rails, everything is encapsulated in the model&#x27;s class. But Python devs tend to prefer explicit code. In Django we also have the Manager class as an additional layer used to build QuerySets. I&#x27;d say it&#x27;s just a different architecture instead of a shortcoming.<p>Also, you&#x27;re supposed to enhance the models with additional functionality independent of views.  Not just in the form of just adding new class or instance methods, but you can also redefine or add alternate QuerySet Managers. For example &quot;Model.objects&quot; could be replaced with a pre-filtered one that includes &quot;deleted=False&quot; and you can add &quot;Model.deleted&quot; for &quot;deleted=True&quot; and &quot;Model.all&quot; for the original get-everything QuerySet.<p><a href="https:&#x2F;&#x2F;docs.djangoproject.com&#x2F;en&#x2F;5.1&#x2F;topics&#x2F;db&#x2F;managers&#x2F;#custom-managers" rel="nofollow">https:&#x2F;&#x2F;docs.djangoproject.com&#x2F;en&#x2F;5.1&#x2F;topics&#x2F;db&#x2F;managers&#x2F;#cu...</a></div><br/></div></div><div id="42397092" class="c"><input type="checkbox" id="c-42397092" checked=""/><div class="controls bullet"><span class="by">brokegrammer</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42394664">parent</a><span>|</span><a href="#42397173">prev</a><span>|</span><a href="#42394684">next</a><span>|</span><label class="collapse" for="c-42397092">[-]</label><label class="expand" for="c-42397092">[1 more]</label></div><br/><div class="children"><div class="content">&gt; When you access the objects property on the model object, you&#x27;re actually accessing the QuerySet<p>Made a mistake there. I wanted to say: The objects property contains a Manager instance that allows you to work with QuerySets.<p>I can see how having three layers to work with your database can cause confusion.</div><br/></div></div></div></div><div id="42394684" class="c"><input type="checkbox" id="c-42394684" checked=""/><div class="controls bullet"><span class="by">ropable</span><span>|</span><a href="#42390386">parent</a><span>|</span><a href="#42394664">prev</a><span>|</span><a href="#42391065">next</a><span>|</span><label class="collapse" for="c-42394684">[-]</label><label class="expand" for="c-42394684">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used them both in production enough to feel qualified to counter these, but we&#x27;d all just be arguing for our opinions. Both are excellent frameworks, with no clear standout IMO.<p>I will say one thing in response: we&#x27;ve found it approximately 10x easier to find devs having years of experience with Python than with Ruby. That&#x27;s a non-trivial argument in Django&#x27;s favour in our organisation.</div><br/><div id="42395770" class="c"><input type="checkbox" id="c-42395770" checked=""/><div class="controls bullet"><span class="by">theappsecguy</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42394684">parent</a><span>|</span><a href="#42391065">next</a><span>|</span><label class="collapse" for="c-42395770">[-]</label><label class="expand" for="c-42395770">[2 more]</label></div><br/><div class="children"><div class="content">Perhaps, but ruby is trivial to learn.</div><br/><div id="42396155" class="c"><input type="checkbox" id="c-42396155" checked=""/><div class="controls bullet"><span class="by">block_dagger</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42395770">parent</a><span>|</span><a href="#42391065">next</a><span>|</span><label class="collapse" for="c-42396155">[-]</label><label class="expand" for="c-42396155">[1 more]</label></div><br/><div class="children"><div class="content">The basics are trivial to learn but the object model and lambda style programming as well as metaprogramming (method_missing, etc) can be overwhelming for some folks to pick up quickly. I absolutely love Ruby though.</div><br/></div></div></div></div></div></div><div id="42391065" class="c"><input type="checkbox" id="c-42391065" checked=""/><div class="controls bullet"><span class="by">ic_fly2</span><span>|</span><a href="#42390386">parent</a><span>|</span><a href="#42394684">prev</a><span>|</span><a href="#42391149">next</a><span>|</span><label class="collapse" for="c-42391065">[-]</label><label class="expand" for="c-42391065">[12 more]</label></div><br/><div class="children"><div class="content">The whole appeal of Django is that you can just swap in a different templating engine &#x2F; syntax if you prefer.<p>And you can add a DB and let there be managed by some other system.<p>Same goes for extending manage.py<p>I’ve worked on Django projects big and small and generally the speed are which we could deliver even on strange edge cases impressed.</div><br/><div id="42391258" class="c"><input type="checkbox" id="c-42391258" checked=""/><div class="controls bullet"><span class="by">mostlysimilar</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42391065">parent</a><span>|</span><a href="#42391149">next</a><span>|</span><label class="collapse" for="c-42391258">[-]</label><label class="expand" for="c-42391258">[11 more]</label></div><br/><div class="children"><div class="content">You can do that with Rails too. The difference is that Rails defaults are very good.</div><br/><div id="42391704" class="c"><input type="checkbox" id="c-42391704" checked=""/><div class="controls bullet"><span class="by">aerhardt</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42391258">parent</a><span>|</span><a href="#42391149">next</a><span>|</span><label class="collapse" for="c-42391704">[-]</label><label class="expand" for="c-42391704">[10 more]</label></div><br/><div class="children"><div class="content">The Rails dev says that Rails defaults are very good and so says the Django dev about the Django defaults.<p>The Django ORM is loved by tens, maybe hundreds of thousands of Python devs globally, and while I could raise concerns about it (for example, the async experimental capabilities fucking suck, and the core dev team is extremely slow to innovate on them on the basis that that&#x27;s not &quot;the Django way&quot;), I&#x27;ve never heard anyone but a Rails dev complain that it&#x27;s &quot;too verbose&quot;.<p>People love it so much that they&#x27;ll do atrocities like import it into Jupyter notebooks or simple scripts that should otherwise have no business in bringing in those type of dependencies. I should know because when I&#x27;ve felt creative and a bit naughty about doing those types of things I&#x27;ve found out - to my unmeasurable disappointment - that there were many other trailblazers before me to write gists, Medium articles, and almost everything every type of format short of an entire O&#x27;Reilly book on how to do it.</div><br/><div id="42396948" class="c"><input type="checkbox" id="c-42396948" checked=""/><div class="controls bullet"><span class="by">melodyogonna</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42391704">parent</a><span>|</span><a href="#42393040">next</a><span>|</span><label class="collapse" for="c-42396948">[-]</label><label class="expand" for="c-42396948">[1 more]</label></div><br/><div class="children"><div class="content">Can confirm. Django&#x27;s ORM is the main reasons I use Django. A work of art in software design.</div><br/></div></div><div id="42393040" class="c"><input type="checkbox" id="c-42393040" checked=""/><div class="controls bullet"><span class="by">deaddodo</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42391704">parent</a><span>|</span><a href="#42396948">prev</a><span>|</span><a href="#42393721">next</a><span>|</span><label class="collapse" for="c-42393040">[-]</label><label class="expand" for="c-42393040">[6 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve never heard anyone but a Rails dev complain that it&#x27;s &quot;too verbose&quot;.<p>Maybe not too verbose, but there&#x27;s a large population of python devs that find SQLAlchemy (+ Alembic) the much better option.</div><br/><div id="42393123" class="c"><input type="checkbox" id="c-42393123" checked=""/><div class="controls bullet"><span class="by">kshahkshah</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42393040">parent</a><span>|</span><a href="#42394209">next</a><span>|</span><label class="collapse" for="c-42393123">[-]</label><label class="expand" for="c-42393123">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s curious to me honestly. I really prefer the ergonomics of Django&#x27;s ORM compared to when I&#x27;ve had to use SQLAlchemy+Alembic in the past. I find alembic incredibly confusing and poorly documented. Not that documentation matters as much nowadays with AI</div><br/><div id="42395327" class="c"><input type="checkbox" id="c-42395327" checked=""/><div class="controls bullet"><span class="by">gmassman</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42393123">parent</a><span>|</span><a href="#42394146">next</a><span>|</span><label class="collapse" for="c-42395327">[-]</label><label class="expand" for="c-42395327">[1 more]</label></div><br/><div class="children"><div class="content">Alembic is certainly a bit of a challenge to grasp at first, especially if you want to do anything more complicated than create or alter tables. However, it does provide a great amount of flexibility if you want to implement more complex migration functionality. It allows library developers to add powerful features that would be very difficult to do with Rails&#x2F;ActiveRecord or Django ORM.
 FWIW I maintain the flask-audit-logger package. It allows users to maintain audit logs of specific tables using postgres triggers. Being able to create custom migration operations is really an amazing feat. The alembic docs are quite dense, but the code is well organized and very readable.</div><br/></div></div><div id="42394146" class="c"><input type="checkbox" id="c-42394146" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42393123">parent</a><span>|</span><a href="#42395327">prev</a><span>|</span><a href="#42394209">next</a><span>|</span><label class="collapse" for="c-42394146">[-]</label><label class="expand" for="c-42394146">[1 more]</label></div><br/><div class="children"><div class="content">yeah, alembic feels especially &quot;small&quot; and obscure compared to the hyper exhaustive nature of SQLA for everything else. felt like a side project at first</div><br/></div></div></div></div><div id="42394209" class="c"><input type="checkbox" id="c-42394209" checked=""/><div class="controls bullet"><span class="by">irjustin</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42393040">parent</a><span>|</span><a href="#42393123">prev</a><span>|</span><a href="#42393721">next</a><span>|</span><label class="collapse" for="c-42394209">[-]</label><label class="expand" for="c-42394209">[2 more]</label></div><br/><div class="children"><div class="content">Yeah SQL Alchemy is 1000x better.<p>Django&#x27;s ORM is miserable.<p>User.objects.filter(company__product__product_variation__var_type__in=[&#x27;var1&#x27;, &#x27;var2&#x27;])<p>vs<p>User.where(company: { product: { product_variation: { var_type: [&#x27;var1&#x27;, &#x27;var2&#x27;] }}})<p>Little things like that make it so much harder to read.</div><br/><div id="42397285" class="c"><input type="checkbox" id="c-42397285" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42394209">parent</a><span>|</span><a href="#42393721">next</a><span>|</span><label class="collapse" for="c-42397285">[-]</label><label class="expand" for="c-42397285">[1 more]</label></div><br/><div class="children"><div class="content">Not to mention SQLAlchemy supports the unit of work pattern meaning you can update many objects at once. It tracks and figures out how to apply the updates all in one go. Django supports one object at a time.<p>With SQLAlchemy it&#x27;s easy to build mappers to real domain objects that are independent of the database. Most Django people treat the Django models as entities or, worse, do business logic in views etc. It&#x27;s possible to implement unit of work on top of Django, but that&#x27;s then another layer you have to maintain yourself (which SQLAlchemy does for you).<p>But SQLAlchemy is harder. It&#x27;s better but it&#x27;s harder. Django is easier to get going with. But it bites you later (unless your app is just CRUD, in which case Django is all you need, well that and a better way to generate HTML).</div><br/></div></div></div></div></div></div><div id="42393721" class="c"><input type="checkbox" id="c-42393721" checked=""/><div class="controls bullet"><span class="by">adammarples</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42391704">parent</a><span>|</span><a href="#42393040">prev</a><span>|</span><a href="#42391149">next</a><span>|</span><label class="collapse" for="c-42393721">[-]</label><label class="expand" for="c-42393721">[2 more]</label></div><br/><div class="children"><div class="content">Actually the dango dev is saying that the whole appeal of dango is that you can swap the defaults out easily, kind of the opposite</div><br/><div id="42397307" class="c"><input type="checkbox" id="c-42397307" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42393721">parent</a><span>|</span><a href="#42391149">next</a><span>|</span><label class="collapse" for="c-42397307">[-]</label><label class="expand" for="c-42397307">[1 more]</label></div><br/><div class="children"><div class="content">The problem with Django is not swapping out defaults. The problem is it doesn&#x27;t like to sit at the edge of an application where it belongs. Django should be equivalent of any other MVC-style framework (like Qt etc), sitting right out in the &quot;interface&quot; layer of your software. But it just doesn&#x27;t work well out there, mostly due to how tightly coupled it is with its ORM.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42391149" class="c"><input type="checkbox" id="c-42391149" checked=""/><div class="controls bullet"><span class="by">techscruggs</span><span>|</span><a href="#42390386">parent</a><span>|</span><a href="#42391065">prev</a><span>|</span><a href="#42396687">next</a><span>|</span><label class="collapse" for="c-42391149">[-]</label><label class="expand" for="c-42391149">[4 more]</label></div><br/><div class="children"><div class="content">A bit off topic, but whenever Rails and templating get brought up, I have to plug my absolute favorite project out there:  Phlex <a href="https:&#x2F;&#x2F;beta.phlex.fun&#x2F;" rel="nofollow">https:&#x2F;&#x2F;beta.phlex.fun&#x2F;</a>.  It&#x27;s like ViewComponents, but swap out the ERB for pure Ruby.  It has been a joy to develop with.<p>With the addition of Phlex::Kit, it has made building out a component library pretty easy too.  
 RubyUI <a href="https:&#x2F;&#x2F;github.com&#x2F;ruby-ui&#x2F;ruby_ui" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;ruby-ui&#x2F;ruby_ui</a> does a great job of showing off how to do this.</div><br/><div id="42392651" class="c"><input type="checkbox" id="c-42392651" checked=""/><div class="controls bullet"><span class="by">pmontra</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42391149">parent</a><span>|</span><a href="#42391795">next</a><span>|</span><label class="collapse" for="c-42392651">[-]</label><label class="expand" for="c-42392651">[2 more]</label></div><br/><div class="children"><div class="content">Those kind of things used to be a lose lose proposition back at the time of haml (?) and all the yaml like templating languages. That was more than 10 years ago. The reason was that any designer that could actually do html was able to write an erb page, maybe except loops and logic, but they could understand them if a developer added them into the page later. On the other side with one of those languages, and more with phlex, only a developer could write the views so we were back to the 90s with photoshop layouts.<p>Furthermore your can&#x27;t copy and paste examples. Think about Bootstrap components. You have to really write everything from scratch.</div><br/><div id="42395790" class="c"><input type="checkbox" id="c-42395790" checked=""/><div class="controls bullet"><span class="by">techscruggs</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42392651">parent</a><span>|</span><a href="#42391795">next</a><span>|</span><label class="collapse" for="c-42395790">[-]</label><label class="expand" for="c-42395790">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.phlexing.fun&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.phlexing.fun&#x2F;</a> 
We have this for that. :)</div><br/></div></div></div></div><div id="42391795" class="c"><input type="checkbox" id="c-42391795" checked=""/><div class="controls bullet"><span class="by">petepete</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42391149">parent</a><span>|</span><a href="#42392651">prev</a><span>|</span><a href="#42396687">next</a><span>|</span><label class="collapse" for="c-42391795">[-]</label><label class="expand" for="c-42391795">[1 more]</label></div><br/><div class="children"><div class="content">Funnily enough I write most of my view components without a template these days, unless there&#x27;s a load of markup.<p>I keep meaning to take a look at Phlex.</div><br/></div></div></div></div><div id="42396687" class="c"><input type="checkbox" id="c-42396687" checked=""/><div class="controls bullet"><span class="by">cplat</span><span>|</span><a href="#42390386">parent</a><span>|</span><a href="#42391149">prev</a><span>|</span><a href="#42392570">next</a><span>|</span><label class="collapse" for="c-42396687">[-]</label><label class="expand" for="c-42396687">[3 more]</label></div><br/><div class="children"><div class="content">I agree with you. I&#x27;ve wrote very big web applications in Rails, Django, and Java&#x2F;Spring.<p>I understand the argument for things being &quot;explicit&quot; in Python, but then I just prefer Java if I&#x27;m going to be very verbose about what I want (I&#x27;m only talking about backend APIs here). It&#x27;s just my opinion that whether explicit is good or not depends on the level of abstraction we&#x27;re interested in, and I don&#x27;t believe that explicit is always good. (I like the concept of meta-algorithms, for example)<p>But if there&#x27;s a one-person project that needs to be scaled quickly, I prefer Rails. (The article mentions how Django makes model fields explicit in the models file, but doesn&#x27;t talk about schema.rb in Rails which doesn&#x27;t require you to view each migration to know how the database looks.)<p>Yes, big projects in any language can get messy, but that&#x27;s a software engineering problem, not a framework problem.<p>I recently wrote a FastAPI project that was db-driven, with all the necessary test cases, etc. The amount of lines it took to express the controller, the schemas and models separately, the dependencies for auth and stuff, and especially elaborate test cases was pretty substantial. Yeah, the code was all explicit, but it was not enjoyable.</div><br/><div id="42396987" class="c"><input type="checkbox" id="c-42396987" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42396687">parent</a><span>|</span><a href="#42392570">next</a><span>|</span><label class="collapse" for="c-42396987">[-]</label><label class="expand" for="c-42396987">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Yes, big projects in any language can get messy, but that&#x27;s a software engineering problem, not a framework problem.<p>Strongly disagree. IME the biggest factor determining how big your project can get before it turns into a mess is your choice of language&#x2F;framework.</div><br/><div id="42397405" class="c"><input type="checkbox" id="c-42397405" checked=""/><div class="controls bullet"><span class="by">cplat</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42396987">parent</a><span>|</span><a href="#42392570">next</a><span>|</span><label class="collapse" for="c-42397405">[-]</label><label class="expand" for="c-42397405">[1 more]</label></div><br/><div class="children"><div class="content">Good for you.</div><br/></div></div></div></div></div></div><div id="42392570" class="c"><input type="checkbox" id="c-42392570" checked=""/><div class="controls bullet"><span class="by">mrsilencedogood</span><span>|</span><a href="#42390386">parent</a><span>|</span><a href="#42396687">prev</a><span>|</span><a href="#42391429">next</a><span>|</span><label class="collapse" for="c-42392570">[-]</label><label class="expand" for="c-42392570">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used rails for years, and have used old versions of django at one company, and used python extensively for non-web purposes.<p>I think my take is that there&#x27;s no middle-ground between Rails and some of the newer Java-based frameworks.<p>Either I&#x27;m doing a side project or startup, and I need to go as FAST as possible, type systems and similar be damned, or I&#x27;m OK with not going as fast as possible and we&#x27;re going to go slower but deliver something very solid.<p>Python&#x2F;django still had me spending a bunch of time on stuff that rails will either generate, scaffold, or hide from you completely. While still not being nearly as safe or performant as anything in the Java world. Note I&#x27;m mostly thinking about more modern frameworks like Javalin, not necessarily Spring&#x27;s entire ecosystem&#x2F;way-of-life.</div><br/><div id="42393501" class="c"><input type="checkbox" id="c-42393501" checked=""/><div class="controls bullet"><span class="by">theflyinghorse</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42392570">parent</a><span>|</span><a href="#42391429">next</a><span>|</span><label class="collapse" for="c-42393501">[-]</label><label class="expand" for="c-42393501">[1 more]</label></div><br/><div class="children"><div class="content">I was not aware of Javeline being used in the same way that RoR&#x2F;django&#x2F;Laravel would be used. Javeline provides primitives to build a backend&#x2F;API layer only no?</div><br/></div></div></div></div><div id="42391429" class="c"><input type="checkbox" id="c-42391429" checked=""/><div class="controls bullet"><span class="by">pmontra</span><span>|</span><a href="#42390386">parent</a><span>|</span><a href="#42392570">prev</a><span>|</span><a href="#42392348">next</a><span>|</span><label class="collapse" for="c-42391429">[-]</label><label class="expand" for="c-42391429">[2 more]</label></div><br/><div class="children"><div class="content">I add one item to my own list: Django admin, being backed by default into the framework is a good thing. Rails has ActiveAdmin but it&#x27;s a separate gem and it requires more work to integrate. Furthermore, being extra work is something that some customers don&#x27;t want to pay for. With Django, it&#x27;s always there.</div><br/><div id="42397326" class="c"><input type="checkbox" id="c-42397326" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42391429">parent</a><span>|</span><a href="#42392348">next</a><span>|</span><label class="collapse" for="c-42397326">[-]</label><label class="expand" for="c-42397326">[1 more]</label></div><br/><div class="children"><div class="content">Django admin is great but it&#x27;s just CRUD. If you plan to do anything more than CRUD you need to switch off admin at some point. But as a &quot;better than a spreadsheet&quot; database, it&#x27;s great.</div><br/></div></div></div></div><div id="42392348" class="c"><input type="checkbox" id="c-42392348" checked=""/><div class="controls bullet"><span class="by">dethos</span><span>|</span><a href="#42390386">parent</a><span>|</span><a href="#42391429">prev</a><span>|</span><a href="#42394470">next</a><span>|</span><label class="collapse" for="c-42392348">[-]</label><label class="expand" for="c-42392348">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve worked for many years with both frameworks. I have the opposite view, since I prefer the Django ecosystem and Python.<p>Rails has nice things, but overall, I prefer Django&#x27;s approach and the language it uses.</div><br/></div></div><div id="42394470" class="c"><input type="checkbox" id="c-42394470" checked=""/><div class="controls bullet"><span class="by">silviogutierrez</span><span>|</span><a href="#42390386">parent</a><span>|</span><a href="#42392348">prev</a><span>|</span><a href="#42390925">next</a><span>|</span><label class="collapse" for="c-42394470">[-]</label><label class="expand" for="c-42394470">[3 more]</label></div><br/><div class="children"><div class="content">Shameless plug for <a href="https:&#x2F;&#x2F;www.reactivated.io" rel="nofollow">https:&#x2F;&#x2F;www.reactivated.io</a><p>It swaps the templating engine for React. But still server side and using all the Django features you know and love. No SPA needed.</div><br/><div id="42395995" class="c"><input type="checkbox" id="c-42395995" checked=""/><div class="controls bullet"><span class="by">raihansaputra</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42394470">parent</a><span>|</span><a href="#42390925">next</a><span>|</span><label class="collapse" for="c-42395995">[-]</label><label class="expand" for="c-42395995">[2 more]</label></div><br/><div class="children"><div class="content">thanks for sharing! The server side story is definitely a consideration why I&#x27;m not hyped on Inertia.js for now, this seems to solve it. My current nitpick is my personal preference for Svelte&#x2F;SvelteKit. I hope you don&#x27;t mind me taking a look at the repo and try to have Svelte as an option.</div><br/><div id="42396554" class="c"><input type="checkbox" id="c-42396554" checked=""/><div class="controls bullet"><span class="by">silviogutierrez</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42395995">parent</a><span>|</span><a href="#42390925">next</a><span>|</span><label class="collapse" for="c-42396554">[-]</label><label class="expand" for="c-42396554">[1 more]</label></div><br/><div class="children"><div class="content">Sure thing. The magic is in vite.mts, render.mts and renderer.py<p>In theory, you could swap in Svelte in there.</div><br/></div></div></div></div></div></div><div id="42390925" class="c"><input type="checkbox" id="c-42390925" checked=""/><div class="controls bullet"><span class="by">giancarlostoro</span><span>|</span><a href="#42390386">parent</a><span>|</span><a href="#42394470">prev</a><span>|</span><a href="#42390484">next</a><span>|</span><label class="collapse" for="c-42390925">[-]</label><label class="expand" for="c-42390925">[4 more]</label></div><br/><div class="children"><div class="content">Funny you mention templating, its one key thing I&#x27;d change about Django, that... and maybe scaffolding, I&#x27;d crank it up drastically more.<p>My ideal enhancement to Django would be something like how Microsoft made Razor into Blazor... A template engine that can run purely on the back-end or purely on the front-end, replacing any need to ever use JavaScript, you stick to your native programming tongue if you will.</div><br/><div id="42394553" class="c"><input type="checkbox" id="c-42394553" checked=""/><div class="controls bullet"><span class="by">silviogutierrez</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42390925">parent</a><span>|</span><a href="#42392000">next</a><span>|</span><label class="collapse" for="c-42394553">[-]</label><label class="expand" for="c-42394553">[1 more]</label></div><br/><div class="children"><div class="content">Nothing on the python side for templating will ever come close to React or things like that. I built <a href="https:&#x2F;&#x2F;www.reactivated.io" rel="nofollow">https:&#x2F;&#x2F;www.reactivated.io</a> specifically to let python do what it does best (business logic &#x2F; backend) and render using React. But all still server side without the downsides of a SPA.</div><br/></div></div><div id="42392000" class="c"><input type="checkbox" id="c-42392000" checked=""/><div class="controls bullet"><span class="by">davepeck</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42390925">parent</a><span>|</span><a href="#42394553">prev</a><span>|</span><a href="#42390484">next</a><span>|</span><label class="collapse" for="c-42392000">[-]</label><label class="expand" for="c-42392000">[2 more]</label></div><br/><div class="children"><div class="content">I think of Django&#x27;s templating system as a great tool for a previous era. I&#x27;m hopeful that PEP 750 [1] gets accepted and a modern ecosystem of template engines emerges in Python-land. For the moment, I tend to use in-python builders like htpy [2] when I want back-end Python code to generate some HTML.<p>[1] <a href="https:&#x2F;&#x2F;pep-previews--4124.org.readthedocs.build&#x2F;pep-0750&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pep-previews--4124.org.readthedocs.build&#x2F;pep-0750&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;htpy.dev" rel="nofollow">https:&#x2F;&#x2F;htpy.dev</a></div><br/><div id="42394350" class="c"><input type="checkbox" id="c-42394350" checked=""/><div class="controls bullet"><span class="by">va1a</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42392000">parent</a><span>|</span><a href="#42390484">next</a><span>|</span><label class="collapse" for="c-42394350">[-]</label><label class="expand" for="c-42394350">[1 more]</label></div><br/><div class="children"><div class="content">Didn&#x27;t know about pep 750, that&#x27;s really cool that there&#x27;s a push for native templating. I just hope we see a gradual stepping away of &quot;everything clientside&quot; and the JS framework hell that exists today. I&#x27;ve tried and I&#x27;ve tried but I just can&#x27;t take javascript seriously. It&#x27;s so ugly and overbuilt. It should never have been brought to the server, Node was a horrible mistake. In my ideal future, the web returns to servers doing their jobs, and JS being used for minor interactivity features when necessary.</div><br/></div></div></div></div></div></div><div id="42390484" class="c"><input type="checkbox" id="c-42390484" checked=""/><div class="controls bullet"><span class="by">kamikazeturtles</span><span>|</span><a href="#42390386">parent</a><span>|</span><a href="#42390925">prev</a><span>|</span><a href="#42390901">next</a><span>|</span><label class="collapse" for="c-42390484">[-]</label><label class="expand" for="c-42390484">[12 more]</label></div><br/><div class="children"><div class="content">Python is used for much more than just web dev and Django, whereas Ruby seams to only be synonymous with Ruby on Rails.<p>Do you think Rails is still worth using when investing in learning Python and Django has a much higher roi?</div><br/><div id="42391489" class="c"><input type="checkbox" id="c-42391489" checked=""/><div class="controls bullet"><span class="by">criddell</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42390484">parent</a><span>|</span><a href="#42392446">next</a><span>|</span><label class="collapse" for="c-42391489">[-]</label><label class="expand" for="c-42391489">[1 more]</label></div><br/><div class="children"><div class="content">It sounds like you&#x27;ve already made your choice and it&#x27;s a good one. Go with Python and make great stuff.<p>Rails has been around two decades, Ruby three. Both will still be there down the road when you decide to try it out. A lot of what you learn in your Python work will translate in some way to Ruby &amp; Rails.</div><br/></div></div><div id="42392446" class="c"><input type="checkbox" id="c-42392446" checked=""/><div class="controls bullet"><span class="by">RangerScience</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42390484">parent</a><span>|</span><a href="#42391489">prev</a><span>|</span><a href="#42390701">next</a><span>|</span><label class="collapse" for="c-42392446">[-]</label><label class="expand" for="c-42392446">[1 more]</label></div><br/><div class="children"><div class="content">Yes. You learn unique, transferable things from every language and framework; usually, techniques and perspectives, but also confidence and theory.<p>I’d also contest your statement that learning Python and Django have a “much higher ROI” - but, I don’t actually want to get into it.</div><br/></div></div><div id="42390701" class="c"><input type="checkbox" id="c-42390701" checked=""/><div class="controls bullet"><span class="by">karolist</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42390484">parent</a><span>|</span><a href="#42392446">prev</a><span>|</span><a href="#42395833">next</a><span>|</span><label class="collapse" for="c-42390701">[-]</label><label class="expand" for="c-42390701">[7 more]</label></div><br/><div class="children"><div class="content">Majority of learning surface will come from framework and not the language, if you need Python elsewhere just learn that as well, but this shouldn&#x27;t move framework choice much.</div><br/><div id="42391728" class="c"><input type="checkbox" id="c-42391728" checked=""/><div class="controls bullet"><span class="by">infamia</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42390701">parent</a><span>|</span><a href="#42391482">next</a><span>|</span><label class="collapse" for="c-42391728">[-]</label><label class="expand" for="c-42391728">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Majority of learning surface will come from framework and not the language<p>Once you get past the beginner level in Django, you&#x27;re going to pick up a ton of Python knowledge (standard dunder methods, MRO, standard lib, data type&#x27;s im&#x2F;mutability, package ecosystem, etc.) and muscle memory along the way. Django (for the most part) is just plain old Python data structures, classes, and functions that a decent Django dev will apart, reuse, override, repurpose, and add on to as they do more interesting things. Python is boring (in a good way), however it has <i>a lot</i> of surface area (std lib is massive) and intricacies that a Django dev will pick up along the way to becoming an intermediate&#x2F;advanced dev. It would take someone coming in fresh to Python quite a while to catch up. Naturally, if the same person knew several languages, the ramp up would be quite a bit quicker.</div><br/></div></div><div id="42391482" class="c"><input type="checkbox" id="c-42391482" checked=""/><div class="controls bullet"><span class="by">Tronno</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42390701">parent</a><span>|</span><a href="#42391728">prev</a><span>|</span><a href="#42395833">next</a><span>|</span><label class="collapse" for="c-42391482">[-]</label><label class="expand" for="c-42391482">[5 more]</label></div><br/><div class="children"><div class="content">Ruby, and Rails in particular, has a lackluster dev experience with any editor that isn&#x27;t RubyMine. That&#x27;s been a huge obstacle for me personally.</div><br/><div id="42393886" class="c"><input type="checkbox" id="c-42393886" checked=""/><div class="controls bullet"><span class="by">weaksauce</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42391482">parent</a><span>|</span><a href="#42393099">next</a><span>|</span><label class="collapse" for="c-42393886">[-]</label><label class="expand" for="c-42393886">[1 more]</label></div><br/><div class="children"><div class="content">ruby-lsp and rails-lsp from shopify is pretty good right now and getting better by the day. the vscode extension handles it well too.</div><br/></div></div><div id="42393099" class="c"><input type="checkbox" id="c-42393099" checked=""/><div class="controls bullet"><span class="by">Lio</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42391482">parent</a><span>|</span><a href="#42393886">prev</a><span>|</span><a href="#42392757">next</a><span>|</span><label class="collapse" for="c-42393099">[-]</label><label class="expand" for="c-42393099">[2 more]</label></div><br/><div class="children"><div class="content">Each to their own I guess.<p>Personally I like the ruby-lsp and TPope’s Rails plugin in NeoVim.<p>I dislike heavy weight IDEs, I never find the juice is worth the squeeze.</div><br/><div id="42395844" class="c"><input type="checkbox" id="c-42395844" checked=""/><div class="controls bullet"><span class="by">theappsecguy</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42393099">parent</a><span>|</span><a href="#42392757">next</a><span>|</span><label class="collapse" for="c-42395844">[-]</label><label class="expand" for="c-42395844">[1 more]</label></div><br/><div class="children"><div class="content">I want to like ruby lsp but it takes about 8 seconds to get method references in a large monorepo. It’s simply not good enough, and forces anyone looking for a good devex into rubymine</div><br/></div></div></div></div><div id="42392757" class="c"><input type="checkbox" id="c-42392757" checked=""/><div class="controls bullet"><span class="by">Joe_Cool</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42391482">parent</a><span>|</span><a href="#42393099">prev</a><span>|</span><a href="#42395833">next</a><span>|</span><label class="collapse" for="c-42392757">[-]</label><label class="expand" for="c-42392757">[1 more]</label></div><br/><div class="children"><div class="content">Although a bit annoying to install I am still using the rails plugin for NetBeans.<p>I just never switched to Aptana or Rubymine and now I don&#x27;t wanna.</div><br/></div></div></div></div></div></div><div id="42395833" class="c"><input type="checkbox" id="c-42395833" checked=""/><div class="controls bullet"><span class="by">dismalaf</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42390484">parent</a><span>|</span><a href="#42390701">prev</a><span>|</span><a href="#42394888">next</a><span>|</span><label class="collapse" for="c-42395833">[-]</label><label class="expand" for="c-42395833">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Ruby seams to only be synonymous with Ruby on Rails.<p>Seems to be...  But it can be used for anything Python is.  There&#x27;s ML libraries, bindings to stuff like Torch, all the math-y stuff like Python, all sorts of stuff.  Also it&#x27;s a great language to just roll your own scripts, programs, etc...  Then there&#x27;s also mruby, which can be embedded like Lua...</div><br/></div></div><div id="42394888" class="c"><input type="checkbox" id="c-42394888" checked=""/><div class="controls bullet"><span class="by">x0x0</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42390484">parent</a><span>|</span><a href="#42395833">prev</a><span>|</span><a href="#42390901">next</a><span>|</span><label class="collapse" for="c-42394888">[-]</label><label class="expand" for="c-42394888">[1 more]</label></div><br/><div class="children"><div class="content">If you spend a bunch of time in Ruby (or Python), I don&#x27;t think you&#x27;ll have a huge lift switching to the other if you ever want to?<p>&gt; Rails is still worth using<p>Yes.  Hotwire + Hotwire Native are great tech.  The whole suite is integrated in a way that Django isn&#x27;t ime.  I prefer the strong default approach for most things.</div><br/></div></div></div></div><div id="42392531" class="c"><input type="checkbox" id="c-42392531" checked=""/><div class="controls bullet"><span class="by">mlboss</span><span>|</span><a href="#42390386">parent</a><span>|</span><a href="#42390901">prev</a><span>|</span><a href="#42394490">next</a><span>|</span><label class="collapse" for="c-42392531">[-]</label><label class="expand" for="c-42392531">[1 more]</label></div><br/><div class="children"><div class="content">For an alternative django templating, I would recommend htpy. <a href="https:&#x2F;&#x2F;htpy.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;htpy.dev&#x2F;</a></div><br/></div></div><div id="42394490" class="c"><input type="checkbox" id="c-42394490" checked=""/><div class="controls bullet"><span class="by">knowsuchagency</span><span>|</span><a href="#42390386">parent</a><span>|</span><a href="#42392531">prev</a><span>|</span><a href="#42390971">next</a><span>|</span><label class="collapse" for="c-42394490">[-]</label><label class="expand" for="c-42394490">[1 more]</label></div><br/><div class="children"><div class="content">I saw someone mention reactived but there&#x27;s also <a href="https:&#x2F;&#x2F;github.com&#x2F;wrabit&#x2F;django-cotton" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;wrabit&#x2F;django-cotton</a></div><br/></div></div><div id="42394460" class="c"><input type="checkbox" id="c-42394460" checked=""/><div class="controls bullet"><span class="by">innocentoldguy</span><span>|</span><a href="#42390386">parent</a><span>|</span><a href="#42390971">prev</a><span>|</span><a href="#42392652">next</a><span>|</span><label class="collapse" for="c-42394460">[-]</label><label class="expand" for="c-42394460">[3 more]</label></div><br/><div class="children"><div class="content">One of the biggest things I dislike about Django is its lack of a standard project structure. I haven&#x27;t used it in years, so things may be different now, but back in the day, even the core team recommended against using the default project layout, which always made me wonder why they generated new apps that way.<p>Switching between Django projects while doing contract work was always a &quot;what the hell?&quot; experience. Rails&#x27; opinionated nature makes it easy to dive into new projects you know virtually nothing about.<p>Nowadays, I focus exclusively on Elixir&#x2F;Phoenix apps. Elixir eliminates the OOP requirement (I&#x27;ve never liked OOP because I don&#x27;t feel it remotely lives up to the hype) while maintaining all the other great things I love about Rails, like consistent project layouts. It also makes writing multi-threaded, distributed apps easy.</div><br/><div id="42394641" class="c"><input type="checkbox" id="c-42394641" checked=""/><div class="controls bullet"><span class="by">0cf8612b2e1e</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42394460">parent</a><span>|</span><a href="#42392652">next</a><span>|</span><label class="collapse" for="c-42394641">[-]</label><label class="expand" for="c-42394641">[2 more]</label></div><br/><div class="children"><div class="content">This is a bit of a head scratcher for me. I feel Django very much has a way in which projects are supposed to be structured. Maybe you do not like it, but if you ask me where the settings&#x2F;templates&#x2F;tests are stored, I could tell you immediately. In a bigger app, where you might want to break things apart, you have options, but it always struck me as you would maintain the existing structure (maybe debate a views&#x2F; with multiple modules in there vs views_x.py, views_y.py in the app root)<p>Unless, you are more angling at the project vs app distinction? Which does seem a bit of cruft. I only ever create a “core” app and put everything in there. Avoids any potential headache.<p>My only really basis of comparison would be Flask, which has basically zero standard. You can organize your app however you want. Given the barebones nature and need for third party dependencies, no two Flask apps will look alike.</div><br/><div id="42395625" class="c"><input type="checkbox" id="c-42395625" checked=""/><div class="controls bullet"><span class="by">thunky</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42394641">parent</a><span>|</span><a href="#42392652">next</a><span>|</span><label class="collapse" for="c-42395625">[-]</label><label class="expand" for="c-42395625">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I only ever create a “core” app and put everything in there. Avoids any potential headache.<p>I agree with this, but the Django tutorial would lead someone to believe that you need a bunch of apps. So I&#x27;ve seen newbies create way too many apps without understanding why they&#x27;ve done it.</div><br/></div></div></div></div></div></div><div id="42392652" class="c"><input type="checkbox" id="c-42392652" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#42390386">parent</a><span>|</span><a href="#42394460">prev</a><span>|</span><a href="#42391157">next</a><span>|</span><label class="collapse" for="c-42392652">[-]</label><label class="expand" for="c-42392652">[2 more]</label></div><br/><div class="children"><div class="content">Rails is so good it succeeded despite Ruby.<p>Django&#x27;s main benefits are<p>1. Admin interface
2. Python</div><br/><div id="42393150" class="c"><input type="checkbox" id="c-42393150" checked=""/><div class="controls bullet"><span class="by">kshahkshah</span><span>|</span><a href="#42390386">root</a><span>|</span><a href="#42392652">parent</a><span>|</span><a href="#42391157">next</a><span>|</span><label class="collapse" for="c-42393150">[-]</label><label class="expand" for="c-42393150">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately for Rubyists (myself included) those are huge benefits though nowadays. It&#x27;s much easier to find Python developers.<p>Having an out-of-the-box admin interface means business people can operationalize and workaround short comings of the software today, not tomorrow. I think functional admin interfaces can often be the difference between a successful company and one which is constantly operating off of spreadsheets in the background and never fully commits to their software.</div><br/></div></div></div></div><div id="42391157" class="c"><input type="checkbox" id="c-42391157" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#42390386">parent</a><span>|</span><a href="#42392652">prev</a><span>|</span><a href="#42390331">next</a><span>|</span><label class="collapse" for="c-42391157">[-]</label><label class="expand" for="c-42391157">[1 more]</label></div><br/><div class="children"><div class="content">Rails is 10x better than Django in every way and it isn&#x27;t even close.</div><br/></div></div></div></div><div id="42390331" class="c"><input type="checkbox" id="c-42390331" checked=""/><div class="controls bullet"><span class="by">Supernaut</span><span>|</span><a href="#42390386">prev</a><span>|</span><a href="#42395996">next</a><span>|</span><label class="collapse" for="c-42390331">[-]</label><label class="expand" for="c-42390331">[7 more]</label></div><br/><div class="children"><div class="content">As a longtime Rails developer who has experimented with Python but knew little about Django, I read this article with interest. Something that jumped out at me was the author&#x27;s description of the &quot;models.py file, which contains all the application models (multiple models in a single file)&quot;. I did some quick research and I gather that this approach isn&#x27;t maintained as you move beyond the scale of a toy application. I kind of think he&#x27;s doing Django a disservice with his current wording there, as my immediate reaction was that it sounded nightmarish!</div><br/><div id="42390785" class="c"><input type="checkbox" id="c-42390785" checked=""/><div class="controls bullet"><span class="by">9dev</span><span>|</span><a href="#42390331">parent</a><span>|</span><a href="#42390425">next</a><span>|</span><label class="collapse" for="c-42390785">[-]</label><label class="expand" for="c-42390785">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not originally a Python guy, but when I’m forced to work with Django, what I do for models and settings and such is just creating a barrel module, that is—instead of models.py, have models&#x2F;__init__.py that imports (and thus re-exports) everything from every file in the models folder. Then I can have a single model per file, as it should be.<p>I’ll never understand the conventions of Python land, but at least the language is flexible enough to do it properly.</div><br/><div id="42392751" class="c"><input type="checkbox" id="c-42392751" checked=""/><div class="controls bullet"><span class="by">adithyareddy</span><span>|</span><a href="#42390331">root</a><span>|</span><a href="#42390785">parent</a><span>|</span><a href="#42391413">next</a><span>|</span><label class="collapse" for="c-42392751">[-]</label><label class="expand" for="c-42392751">[2 more]</label></div><br/><div class="children"><div class="content">Zulip does this: <a href="https:&#x2F;&#x2F;github.com&#x2F;zulip&#x2F;zulip&#x2F;blob&#x2F;main&#x2F;zerver&#x2F;models&#x2F;__init__.py" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;zulip&#x2F;zulip&#x2F;blob&#x2F;main&#x2F;zerver&#x2F;models&#x2F;__ini...</a><p>Zulip in general is a great example of a large open source Django app that&#x27;s been maintained and actively developed for a long time. I use it as a reference quite a lot.</div><br/><div id="42394804" class="c"><input type="checkbox" id="c-42394804" checked=""/><div class="controls bullet"><span class="by">curiousgal</span><span>|</span><a href="#42390331">root</a><span>|</span><a href="#42392751">parent</a><span>|</span><a href="#42391413">next</a><span>|</span><label class="collapse" for="c-42394804">[-]</label><label class="expand" for="c-42394804">[1 more]</label></div><br/><div class="children"><div class="content">Why are they using the as?</div><br/></div></div></div></div><div id="42391413" class="c"><input type="checkbox" id="c-42391413" checked=""/><div class="controls bullet"><span class="by">bena</span><span>|</span><a href="#42390331">root</a><span>|</span><a href="#42390785">parent</a><span>|</span><a href="#42392751">prev</a><span>|</span><a href="#42390425">next</a><span>|</span><label class="collapse" for="c-42391413">[-]</label><label class="expand" for="c-42391413">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that&#x27;s the way to do it.<p>Python is fairly accepting with modules being either directories or files.<p>Going the dir&#x2F;__init__.py route also allows you to do a bit of encapsulation as you can not export things.<p>Of course, someone could import from your file directly still. But, yeah, there is no reason to keep <i>all</i> of your models in a single file.</div><br/></div></div></div></div><div id="42390425" class="c"><input type="checkbox" id="c-42390425" checked=""/><div class="controls bullet"><span class="by">pmontra</span><span>|</span><a href="#42390331">parent</a><span>|</span><a href="#42390785">prev</a><span>|</span><a href="#42393398">next</a><span>|</span><label class="collapse" for="c-42390425">[-]</label><label class="expand" for="c-42390425">[1 more]</label></div><br/><div class="children"><div class="content">We have a models file that imports models from other files, to keep them in the same directory tree. Anyway one could import models from any location of the project. Every app the Django project is made from can have its own urls, models, migrations.</div><br/></div></div><div id="42393398" class="c"><input type="checkbox" id="c-42393398" checked=""/><div class="controls bullet"><span class="by">dsego</span><span>|</span><a href="#42390331">parent</a><span>|</span><a href="#42390425">prev</a><span>|</span><a href="#42395996">next</a><span>|</span><label class="collapse" for="c-42393398">[-]</label><label class="expand" for="c-42393398">[1 more]</label></div><br/><div class="children"><div class="content">You have dozens of apps (modules) each having its own models.py with a handful of models.</div><br/></div></div></div></div><div id="42395996" class="c"><input type="checkbox" id="c-42395996" checked=""/><div class="controls bullet"><span class="by">sroerick</span><span>|</span><a href="#42390331">prev</a><span>|</span><a href="#42394198">next</a><span>|</span><label class="collapse" for="c-42395996">[-]</label><label class="expand" for="c-42395996">[2 more]</label></div><br/><div class="children"><div class="content">I’ve spent a lot of time with Django, and not a lot of time with rails.<p>For me, if I was doing minimalist CRUD and wanted to ship to mobile or a lot of users, I’d reach for Rails. Hotwire and Turbo seem great, and the ecosystem just seems better and more developed for customer facing stuff.<p>Most of my work has been internal tooling with an emphasis on data analytics or geospatial. Having python libs run natively is a big win for data analysis, and as another commenter posted, geodjango is very tough to beat for usability for geospatial work. For this I still maintain Django is pretty unbeatable.<p>I am happy to be corrected in both domains though, again, not much rails experience here beyond a couple toy projects.</div><br/><div id="42397291" class="c"><input type="checkbox" id="c-42397291" checked=""/><div class="controls bullet"><span class="by">smatija</span><span>|</span><a href="#42395996">parent</a><span>|</span><a href="#42394198">next</a><span>|</span><label class="collapse" for="c-42397291">[-]</label><label class="expand" for="c-42397291">[1 more]</label></div><br/><div class="children"><div class="content">You can use Hotwire libs with Django - integrating stimulus into my django project wasn&#x27;t any more complicated than integrating tailwindcss for example.</div><br/></div></div></div></div><div id="42394198" class="c"><input type="checkbox" id="c-42394198" checked=""/><div class="controls bullet"><span class="by">davidkwast</span><span>|</span><a href="#42395996">prev</a><span>|</span><a href="#42391583">next</a><span>|</span><label class="collapse" for="c-42394198">[-]</label><label class="expand" for="c-42394198">[2 more]</label></div><br/><div class="children"><div class="content">Well. I use GeoDjango with PostGIS. Django supports it natively. And django-rest-framework takes it to another level.<p>Python has the best machine learning and AI support too. It is very easy to mix geographic libs with data science tools.<p>To build a simple CRUD software with vanilla SQL you really don&#x27;t need Django and Python. But I challenge any one to try a GIS full stack without Django and Python.<p>Just look for GDAL, pyproj, shapelly, fiona and MapLibre&#x2F;Mapbox.<p>And it really powerful to combine with HTMX or Vuejs for reactive SPAs</div><br/><div id="42395972" class="c"><input type="checkbox" id="c-42395972" checked=""/><div class="controls bullet"><span class="by">sroerick</span><span>|</span><a href="#42394198">parent</a><span>|</span><a href="#42391583">next</a><span>|</span><label class="collapse" for="c-42395972">[-]</label><label class="expand" for="c-42395972">[1 more]</label></div><br/><div class="children"><div class="content">I second this 100%</div><br/></div></div></div></div><div id="42391583" class="c"><input type="checkbox" id="c-42391583" checked=""/><div class="controls bullet"><span class="by">czhu12</span><span>|</span><a href="#42394198">prev</a><span>|</span><a href="#42392352">next</a><span>|</span><label class="collapse" for="c-42391583">[-]</label><label class="expand" for="c-42391583">[2 more]</label></div><br/><div class="children"><div class="content">I worked significantly in both Django and Rails, and I found the most magical part of rails is its ORM (ActiveRecord). I find both SQLAlchemy and DjangoORM both more awkward and less natural to use, both for the query side and the relationship definition side.<p>Once the data is loaded into memory, everything else is just syntax.<p>At this point, I only reach for python as a web application if I need to build something that has AI &#x2F; ML features. Rails apps I&#x27;ve built in the past that needed to call a local model resulted in having to create a python inference microservice, which kinda sucks.</div><br/><div id="42392547" class="c"><input type="checkbox" id="c-42392547" checked=""/><div class="controls bullet"><span class="by">RangerScience</span><span>|</span><a href="#42391583">parent</a><span>|</span><a href="#42392352">next</a><span>|</span><label class="collapse" for="c-42392547">[-]</label><label class="expand" for="c-42392547">[1 more]</label></div><br/><div class="children"><div class="content">FYI, there’s a few projects out there for interoperability between Ruby and Python - stuff like putting one language in another.<p>Also, Jupyter and Zeppelin notebooks allow for interoperability, although I don’t know how.<p>(Oh, lastly, if there’s a JVM implementation of Python you could probably use alongside JRuby)</div><br/></div></div></div></div><div id="42392352" class="c"><input type="checkbox" id="c-42392352" checked=""/><div class="controls bullet"><span class="by">kitsune_</span><span>|</span><a href="#42391583">prev</a><span>|</span><a href="#42396138">next</a><span>|</span><label class="collapse" for="c-42392352">[-]</label><label class="expand" for="c-42392352">[7 more]</label></div><br/><div class="children"><div class="content">I have yet to see a software project where ActiveRecordish ORMs did not end up making the modelling of business processes and translation of use cases into code overly messy and complicated, Rails or Django.</div><br/><div id="42392489" class="c"><input type="checkbox" id="c-42392489" checked=""/><div class="controls bullet"><span class="by">RangerScience</span><span>|</span><a href="#42392352">parent</a><span>|</span><a href="#42392496">next</a><span>|</span><label class="collapse" for="c-42392489">[-]</label><label class="expand" for="c-42392489">[3 more]</label></div><br/><div class="children"><div class="content">The Rails apps I’ve worked with where there was an ORM mess (which yeah… is all of them) it’s extremely clear that the mess is the normal “too fast” software development mess. Sure, it’s worse because it’s the ORM (and&#x2F;or sharp knives), but it’s also always been the case that I can clean it up with <i>better</i> use of Actuve Record.<p>Also, I’ve worked with some pretty gnarly pure-SQL systems that had essentially the same kinds of problems.<p>It’s all just variations on “saving hours of planning with months of work” kind of things.</div><br/><div id="42392712" class="c"><input type="checkbox" id="c-42392712" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#42392352">root</a><span>|</span><a href="#42392489">parent</a><span>|</span><a href="#42392496">next</a><span>|</span><label class="collapse" for="c-42392712">[-]</label><label class="expand" for="c-42392712">[2 more]</label></div><br/><div class="children"><div class="content">Rails and especially DHH particularly encourage not having any sort of separation between your domain objects and your persistence (and even your views), which is why N+1 queries are so goddamn common and why people are going to put confirmation mail logic in model callbacks etc.</div><br/><div id="42397442" class="c"><input type="checkbox" id="c-42397442" checked=""/><div class="controls bullet"><span class="by">RangerScience</span><span>|</span><a href="#42392352">root</a><span>|</span><a href="#42392712">parent</a><span>|</span><a href="#42392496">next</a><span>|</span><label class="collapse" for="c-42397442">[-]</label><label class="expand" for="c-42397442">[1 more]</label></div><br/><div class="children"><div class="content">&gt; your domain objects and your persistence<p>Hmm. Thinking over my career...<p>Maybe I don&#x27;t know what you mean by &quot;domain objects&quot;, &quot;separation&quot;, and &quot;persistence&quot;, but when I think over the stuff I&#x27;ve worked on in my career, and the problems I&#x27;ve seen in codebases...<p>Yeah, I think I&#x27;m with them on this - your domain objects and your persistence should pretty much be the same thing. There&#x27;s gonna be a few exceptions (and, ofc, you can do a shit job building the models), but I expect those to be short-lived and small.<p>Otherwise, you shouldn&#x27;t have domain _objects_ doing all that, you should have functions operating on data, and the data is pretty much always going to be either (1) some incoming hash or (2) some database record; then you group the functions into handy modules for humans. And then they&#x27;re not domain _objects_.<p>Do you have a good example of a &quot;domain object&quot; that you think really _should_ be heavily separated from persistence?<p>PS - The one time that comes to mind that might fit, the data I wanted to persist was essentially logging data on the operation that was performed on other data.<p>PPS - N+1 queries are kinda trivial to resolve in most cases in Rails? There&#x27;s core ORM functionality for it.<p>PPPS - Yeah, don&#x27;t put your confirmation mail logic in the model callback, that&#x27;s a bad plan.<p>Fake edit: Like, you either have data you want to persist, or you have data you&#x27;re transforming. If you&#x27;re transforming it, it&#x27;s temporary, and either I don&#x27;t understand what a &quot;domain object&quot; is, or I think you&#x27;d make a mistake to make your temporary data into a domain object.</div><br/></div></div></div></div></div></div><div id="42392496" class="c"><input type="checkbox" id="c-42392496" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#42392352">parent</a><span>|</span><a href="#42392489">prev</a><span>|</span><a href="#42396138">next</a><span>|</span><label class="collapse" for="c-42392496">[-]</label><label class="expand" for="c-42392496">[3 more]</label></div><br/><div class="children"><div class="content">I can’t speak for rails’s ActiveRecord but I don’t think DjangoORM is worse than any other ORM in that regard. It’s probably one of my favorite ORMs. I don’t think I’ll ever really use it again but that includes every other ORM.</div><br/><div id="42392691" class="c"><input type="checkbox" id="c-42392691" checked=""/><div class="controls bullet"><span class="by">kitsune_</span><span>|</span><a href="#42392352">root</a><span>|</span><a href="#42392496">parent</a><span>|</span><a href="#42396138">next</a><span>|</span><label class="collapse" for="c-42392691">[-]</label><label class="expand" for="c-42392691">[2 more]</label></div><br/><div class="children"><div class="content">I mean there is a clear difference  in how ORMs that use the data mapper pattern like Hibernate or Entity Framework etc. ultimately allow for a cleaner overall application architecture vis-a-vis ActiveRecord (the pattern) which usually ends up leaking throughout the entire application.</div><br/><div id="42393577" class="c"><input type="checkbox" id="c-42393577" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#42392352">root</a><span>|</span><a href="#42392691">parent</a><span>|</span><a href="#42396138">next</a><span>|</span><label class="collapse" for="c-42393577">[-]</label><label class="expand" for="c-42393577">[1 more]</label></div><br/><div class="children"><div class="content">I think we agree. I don’t think there is that much difference between ORM patterns (and I’m sorry I misunderstood you) because they all eventually become more trouble than they are worth in larger and more serious projects. I agree that you can probably go further with data mapper pattern ORMs, like EF, but I’m not sure I think the same is true for something like DjangoORM vs SQLAlchemy. On the flip-side a lot of projects will do fine with any ORM and never run into issues over their lifecycles.<p>Though in a world of SQLC (and similar) I’m not sure what ORMs are really solving for anyone anymore.</div><br/></div></div></div></div></div></div></div></div><div id="42396138" class="c"><input type="checkbox" id="c-42396138" checked=""/><div class="controls bullet"><span class="by">block_dagger</span><span>|</span><a href="#42392352">prev</a><span>|</span><a href="#42391048">next</a><span>|</span><label class="collapse" for="c-42396138">[-]</label><label class="expand" for="c-42396138">[1 more]</label></div><br/><div class="children"><div class="content">I think Rails would be better off with TOML vs YML but otherwise I think Rails is better. Disclaimer: I’ve built dozens of Rails apps but never a full Django app. I dislike significant whitespace.</div><br/></div></div><div id="42391048" class="c"><input type="checkbox" id="c-42391048" checked=""/><div class="controls bullet"><span class="by">wfleming</span><span>|</span><a href="#42396138">prev</a><span>|</span><a href="#42393406">next</a><span>|</span><label class="collapse" for="c-42391048">[-]</label><label class="expand" for="c-42391048">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Migrations in Django
&gt; 
&gt; The Django approach has noteworthy differences and a slightly different workflow<p>My explanation of Django&#x27;s approach to migrations would involve a lot more expletives. It is by far my least favorite thing about the framework.<p>- Fields are not-null by default, the opposite of SQL itself<p>- Field declarations use argument names that <i>sound</i> like the SQL equivalents (default, on delete cascade&#x2F;restrict), but they&#x27;re fully enforced in python and don&#x27;t make it into the SQL schema at all by default. I get that not every DB supports these features, and there are sometimes good reasons for doing something like a delete cascade in process (if you need to implement custom on-delete logic or something), but the DSL shouldn&#x27;t read like SQL if it&#x27;s not going to change the SQL schema. The default value thing combined with not-null by default is particularly easy to get bitten by adding a new field with default if you deploy migrations separately from deploying code (which you must do to avoid downtime): if you add a new field with a default value believing it&#x27;s safe, you will probably get crashes in the interval between applying the migration &amp; the new code deploying because you&#x27;ve got not-null column without a default value in the schema. They did finally add db_default recently, thankfully, but it took years!<p>- Django migrations cannot be understood in isolation, the sql a generated migration containing something like an AlterField operation will run depends on what <i>earlier</i> migrations say. You have to check with the sqlmigrate command and&#x2F;or actually read earlier migrations to be sure you understand what the migration will do. Compared to Rails, where each migration can be read and understood in isolation (though you may still need to understand how a Rails migration DSL will translate to actual SQL of course). This also has a performance impact making Django migrations slower because Django has an in-memory model of what the schema should be at each migration point, so running a migration is not just &quot;load the file and run the commands&quot;, it&#x27;s &quot;determine the schema that should exist after running this migration, diff that with the schema we think exists before this point, magically generate SQL for that diff, then run that&quot;.<p>- The makemigrations command to auto-generate pending migrations is very aggressive and will detect things as &quot;changed&quot; that don&#x27;t impact the schema. If you changed some help text on a field, or a localization string, or the aforementioned only-in-python default value, makemigrations will see that as requiring a migration that does nothing. Leads to lots of cruft.<p>- Related to both of the above points, AlterField&#x27;s auto-generated SQL can be dangerous and bad. Particularly, I&#x27;ve seen cases where very minor changes to a ForeignKey (like changing from nullable to not-nullable, or even not-schema-impacting changes like above) would, by default, have dropped the foreign key constraint &amp; index, and then re-created them. Completely unnecessary and potentially dangerous since it could be locking a large table. I&#x27;m not positive, but in some cases I think these have been generated purely because of a django upgrade leading to it deciding the names of the indexes&#x2F;constraints need to be changed for some reason.<p>- AlterField will <i>also</i> tend to stomp all over any tweaks you manually made to the schema to work around all these issues. If you manually wrote a SQL statement in an earlier migration to add a default value to a column, and then that column&#x27;s definition gets tweaked months or years later the generated AlterField is gonna remove your default value. At a technical level this isn&#x27;t surprising when you understand how Django is modeling the schema internally &amp; generating the SQL changes, but it&#x27;s definitely a bad user experience downstream of a lot of these design decisions.<p>Generally the field declaration&#x2F;migrations system in Django feels to me designed to lead people down a garden path towards bad and dangerous behavior. If I had my druthers I&#x27;d enforce a policy in our Django app of &quot;never run makemigrations, all migrations must be manually written SQL&quot;.</div><br/><div id="42397274" class="c"><input type="checkbox" id="c-42397274" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#42391048">parent</a><span>|</span><a href="#42392336">next</a><span>|</span><label class="collapse" for="c-42397274">[-]</label><label class="expand" for="c-42397274">[1 more]</label></div><br/><div class="children"><div class="content">&gt; - The makemigrations command to auto-generate pending migrations is very aggressive and will detect things as &quot;changed&quot; that don&#x27;t impact the schema. If you changed some help text on a field, or a localization string, or the aforementioned only-in-python default value, makemigrations will see that as requiring a migration that does nothing. Leads to lots of cruft.<p><pre><code>    # Attributes that don&#x27;t affect a column definition.
    # These attributes are ignored when altering the field.
    non_db_attrs = (
        &quot;blank&quot;,
        &quot;choices&quot;,
        &quot;db_column&quot;,
        &quot;editable&quot;,
        &quot;error_messages&quot;,
        &quot;help_text&quot;,
        &quot;limit_choices_to&quot;,
        # Database-level options are not supported, see #21961.
        &quot;on_delete&quot;,
        &quot;related_name&quot;,
        &quot;related_query_name&quot;,
        &quot;validators&quot;,
        &quot;verbose_name&quot;,
    )
</code></pre>
Don&#x27;t know when this was added, I just quickly checked django 4.2</div><br/></div></div><div id="42392336" class="c"><input type="checkbox" id="c-42392336" checked=""/><div class="controls bullet"><span class="by">infamia</span><span>|</span><a href="#42391048">parent</a><span>|</span><a href="#42397274">prev</a><span>|</span><a href="#42393023">next</a><span>|</span><label class="collapse" for="c-42392336">[-]</label><label class="expand" for="c-42392336">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The default value thing combined with not-null by default<p>It is interesting... I strongly feel the opposite after debugging far too many SQL queries where someone checked for an empty string but forgot to check for NULL. NULL by default is a SQL footgun IMO.</div><br/><div id="42392892" class="c"><input type="checkbox" id="c-42392892" checked=""/><div class="controls bullet"><span class="by">wfleming</span><span>|</span><a href="#42391048">root</a><span>|</span><a href="#42392336">parent</a><span>|</span><a href="#42393023">next</a><span>|</span><label class="collapse" for="c-42392892">[-]</label><label class="expand" for="c-42392892">[1 more]</label></div><br/><div class="children"><div class="content">I prefer null as a clear “no value” marker to handle rather than special-casing handling of an empty string vs other strings, and if “empty string” isn’t considered valid that should be validation logic and that should never get stored in the database. But it’s certainly a matter of opinion and either can work as long as you’re consistent.<p>The point about Django’s choices about default and not-null though is that it can easily lead to crashes while you’re adding fields. If you add a string field with default=“” and don’t specify null=False, the generated schema will be a non-null field without a default value in SQL, but Django will backfill “” into all existing rows. To avoid downtime, you need to deploy migrations &amp; apply them, then deploy the models.py&#x2F;other code changes. But if anyone tries to write a new row before the new code finishes deploying after applying the migration, it will crash.</div><br/></div></div></div></div><div id="42393023" class="c"><input type="checkbox" id="c-42393023" checked=""/><div class="controls bullet"><span class="by">alephxyz</span><span>|</span><a href="#42391048">parent</a><span>|</span><a href="#42392336">prev</a><span>|</span><a href="#42393406">next</a><span>|</span><label class="collapse" for="c-42393023">[-]</label><label class="expand" for="c-42393023">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Generally the field declaration&#x2F;migrations system in Django feels to me designed to lead people down a garden path towards bad and dangerous behavior. If I had my druthers I&#x27;d enforce a policy in our Django app of &quot;never run makemigrations, all migrations must be manually written SQL&quot;.<p>`makemigrations --dry-run` is helpful to see if your manual migrations are complete but besides that I agree</div><br/><div id="42396231" class="c"><input type="checkbox" id="c-42396231" checked=""/><div class="controls bullet"><span class="by">wfleming</span><span>|</span><a href="#42391048">root</a><span>|</span><a href="#42393023">parent</a><span>|</span><a href="#42393406">next</a><span>|</span><label class="collapse" for="c-42396231">[-]</label><label class="expand" for="c-42396231">[1 more]</label></div><br/><div class="children"><div class="content">I believe `makemigrations` builds up its conception of &quot;what the schema is&quot; from the `CreateModel`, `AddField`, `AlterField`, etc. ops in the migrations files. But it doesn&#x27;t incorporate `RunSQL` ops into building that model of the schema. If my migrations were just a bunch of `RunSQL` ops, I think `makemigrations --dry-run` would basically just see <i>everything</i> from models.py as always needing to be added.<p>This behavior is why `SeparateDatabaseAndState` is a necessary hack in Django: sometimes you need to do an `AlterField` where the SQL Django would generate is really bad, so you need to write your own `RunSQL` to do the right thing, but you also need Django to see the `AlterField` as applied or you&#x27;ll have problems with future migrations.<p>I suppose I could modify my preference to &quot;run makemigrations and then wrap every single op in SeparateDatabaseAndState&quot;, but that does not sound fun :).</div><br/></div></div></div></div></div></div><div id="42393406" class="c"><input type="checkbox" id="c-42393406" checked=""/><div class="controls bullet"><span class="by">brap</span><span>|</span><a href="#42391048">prev</a><span>|</span><a href="#42390083">next</a><span>|</span><label class="collapse" for="c-42393406">[-]</label><label class="expand" for="c-42393406">[3 more]</label></div><br/><div class="children"><div class="content">With all of this praise Rails is getting, even still in 2024, it’s mind boggling how there was never a successful Rails alternative in one of today’s popular web programming languages. Nothing ever caught on.</div><br/><div id="42393431" class="c"><input type="checkbox" id="c-42393431" checked=""/><div class="controls bullet"><span class="by">joshlemer</span><span>|</span><a href="#42393406">parent</a><span>|</span><a href="#42390083">next</a><span>|</span><label class="collapse" for="c-42393431">[-]</label><label class="expand" for="c-42393431">[2 more]</label></div><br/><div class="children"><div class="content">Laravel and Django don&#x27;t count?</div><br/><div id="42396639" class="c"><input type="checkbox" id="c-42396639" checked=""/><div class="controls bullet"><span class="by">Kerrick</span><span>|</span><a href="#42393406">root</a><span>|</span><a href="#42393431">parent</a><span>|</span><a href="#42390083">next</a><span>|</span><label class="collapse" for="c-42396639">[-]</label><label class="expand" for="c-42396639">[1 more]</label></div><br/><div class="children"><div class="content">Those are definitely successful by popularity metrics. Adonis (node), Loco (rust), and Phoenix (elixir) are successful by productivity metrics, too.</div><br/></div></div></div></div></div></div><div id="42395465" class="c"><input type="checkbox" id="c-42395465" checked=""/><div class="controls bullet"><span class="by">ltbarcly3</span><span>|</span><a href="#42390083">prev</a><span>|</span><label class="collapse" for="c-42395465">[-]</label><label class="expand" for="c-42395465">[1 more]</label></div><br/><div class="children"><div class="content">Django is a framework made of several components:<p><pre><code>  - ORM: bizarre and can&#x27;t generate lots of common SQL you will want to generate.  Weird joins via counting underscores.  Horrible errors that don&#x27;t make sense.  Lots of builtin functions have never worked and they won&#x27;t fix them.  (ROUND has never worked!)
  - Template language:  Slow and borderline unusable.  are 50 pages of recursive nonsense tracebacks that doesn&#x27;t tell you anything usable.
  - Web app (controller) framework: Terrible and inflexible
</code></pre>
Each of these components is a piece of shit.  Don&#x27;t use Django.<p>I suggest:<p><pre><code>  - ORM: Sqlalchemy: probably one of the best ORMs in any language, good performance and very flexible.  It won&#x27;t get in your way much. 
  - Templates: jinja2: basically identical to django templates but faster and usable tracebacks are perfect
  - Web app: Flask or werkzeug, but there are lots of good options here.  Django is the worst.</code></pre></div><br/></div></div></div></div></div></div></div></body></html>