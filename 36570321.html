<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1688547651855" as="style"/><link rel="stylesheet" href="styles.css?v=1688547651855"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://cliffle.com/blog/async-inversion/">How to think about `async`/`await` in Rust</a> <span class="domain">(<a href="http://cliffle.com">cliffle.com</a>)</span></div><div class="subtext"><span>mpweiher</span> | <span>50 comments</span></div><br/><div><div id="36596531" class="c"><input type="checkbox" id="c-36596531" checked=""/><div class="controls bullet"><span class="by">usrbinbash</span><span>|</span><a href="#36596732">next</a><span>|</span><label class="collapse" for="c-36596531">[-]</label><label class="expand" for="c-36596531">[34 more]</label></div><br/><div class="children"><div class="content">Not specific to rust, but I think asynchronous programming in general is a hype.<p>It didn&#x27;t start because it is so awesome, it started because JS can&#x27;t do parallel any other way. That&#x27;s the long and short of it. People wanted to use JS in the backend for some reason. The backend requires concurrency. JS cannot do concurrency. Enter the event loop. Then enter some syntactic sugar for the event loop. And since JS is popular, async became popular.<p>Code written using threads is, at least to me, much more readable and easier to reason about. Each section in itself is just synchronous code. The runtime&#x2F;kernel take care of concurrency. The overhead is negligible in a day when we have greenlet implementations. It works for both i&#x2F;o bound concurrency and cpu bound parallel computing. It doesn&#x27;t require entire libraries rewritten to support it. There is no callback hell. It scales both horizontically and vertically. Modern languages support it out of the box (Hello `go` keyword).<p>I realise that this is going to get a lot of downvotes. I don&#x27;t really care. To me, async is just &quot;cooperative multitasking&quot; with a quick paintjob. We left behind that paradigm in Operating Systems decades ago, and with good reason.</div><br/><div id="36596664" class="c"><input type="checkbox" id="c-36596664" checked=""/><div class="controls bullet"><span class="by">3np</span><span>|</span><a href="#36596531">parent</a><span>|</span><a href="#36596947">next</a><span>|</span><label class="collapse" for="c-36596664">[-]</label><label class="expand" for="c-36596664">[3 more]</label></div><br/><div class="children"><div class="content">Your comment seems to be conflating concurrency with parallelism.<p>JS doesn&#x27;t have any language-level abstractions for parallelism (async or not) but you do have Web Workers[0] and process forking (depending on runtime) to get actual parallel programming. JS async deals with concurrency, not parallelism.<p>Threads are the opposite: They are interfaces for parallel programming and their use is orthogonal to how your application handles the resulting concurrency.<p>You say &quot;the runtime&#x2F;kernel take care of concurrency&quot; - are you telling me you never write a mutex or implement locking logic? Because that&#x27;s what &quot;taking care of concurrency&quot; is. I&#x27;d choose refactoring callback-&#x2F;Promise-hell over debugging a complex deadlock any day (unless intra-process parallelism is actually a requirement, which may tip the scale in the other direction).<p>In the context of doing concurrency and parallelism in Rust, I&#x27;d 100% agree that the JS&#x2F;C#-style async&#x2F;await approach isn&#x27;t necessarily always the best approach and it&#x27;s good to consider alternative idioms if your requirements call for it. For anyone writing &quot;apps&quot; or glue-libraries, though, I&#x27;m  thankful that they stay away from spawning threads all over my system by default and that they need more tools than &quot;learn Rust async in 15 minutes&quot; gives them to become dangerous.<p>Messing up your single-threaded event-loop concurrency can hog roughly a single CPU core and cause OoM. Messing up thread-based concurrency can have larger implications on the hosting system.<p>[0]: <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Web_Workers_API" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Web_Workers...</a></div><br/><div id="36597629" class="c"><input type="checkbox" id="c-36597629" checked=""/><div class="controls bullet"><span class="by">ngrilly</span><span>|</span><a href="#36596531">root</a><span>|</span><a href="#36596664">parent</a><span>|</span><a href="#36597168">next</a><span>|</span><label class="collapse" for="c-36597629">[-]</label><label class="expand" for="c-36597629">[1 more]</label></div><br/><div class="children"><div class="content">async&#x2F;await doesn&#x27;t entirely remove the need for mutexes and locks. We still need them if we have multiple coroutines using a shared resource across multiple yield points.</div><br/></div></div></div></div><div id="36596947" class="c"><input type="checkbox" id="c-36596947" checked=""/><div class="controls bullet"><span class="by">justin_</span><span>|</span><a href="#36596531">parent</a><span>|</span><a href="#36596664">prev</a><span>|</span><a href="#36596830">next</a><span>|</span><label class="collapse" for="c-36596947">[-]</label><label class="expand" for="c-36596947">[2 more]</label></div><br/><div class="children"><div class="content">Asynchronous programming is a great fit for IO-driven programs, because modern IO is inherently asynchronous. This is clearly true for networking, but even for disk IO, generally commands are sent to the disks and results come back later. Another thing that’s asynchronous is user input, and that’s why JS has it.<p>As for threading vs. explicit yielding (e.g. coroutines), I’d say it’s a matter of taste. I generally prefer to see where code is going to yield. Something like gevent can make control flow confusing, since it’s unclear what will yield, and you need to implement explicit yielding for CPU-bound tasks anyway. Its green threads are based on greenlet, which are cooperative coroutines.<p>Cooperative multitasking was a big problem in operating systems, where you can’t tell whether other processes are looking for CPU time or not. But within your own code, you can control it however you want!</div><br/><div id="36597650" class="c"><input type="checkbox" id="c-36597650" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#36596531">root</a><span>|</span><a href="#36596947">parent</a><span>|</span><a href="#36596830">next</a><span>|</span><label class="collapse" for="c-36597650">[-]</label><label class="expand" for="c-36597650">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not how an operating system models disk access though. You synchronously write to the kernel cache, and the kernel eventually gets those written to disk.<p>Wanting to do asynchronous I&#x2F;O to disk is only useful if you&#x27;re aiming to bypass the cache. In practice it is very hard to reach higher performance when doing that though.</div><br/></div></div></div></div><div id="36596830" class="c"><input type="checkbox" id="c-36596830" checked=""/><div class="controls bullet"><span class="by">fvncc</span><span>|</span><a href="#36596531">parent</a><span>|</span><a href="#36596947">prev</a><span>|</span><a href="#36597503">next</a><span>|</span><label class="collapse" for="c-36596830">[-]</label><label class="expand" for="c-36596830">[2 more]</label></div><br/><div class="children"><div class="content">One advantage of async&#x2F;await is that its easier to cancel things. For example, this leads to the design pattern where you have multiple futures and you want to select the one that finishes first and cancel the rest.<p>In regular threaded programming, cancellation is a bit more painful as you need to have some type of cancellation token used each time the thread waits for something. This a) is more verbose and b) can lead to bugs where you forget to implement the cancellation logic.</div><br/><div id="36597671" class="c"><input type="checkbox" id="c-36597671" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#36596531">root</a><span>|</span><a href="#36596830">parent</a><span>|</span><a href="#36597503">next</a><span>|</span><label class="collapse" for="c-36597671">[-]</label><label class="expand" for="c-36597671">[1 more]</label></div><br/><div class="children"><div class="content">&gt;In regular threaded programming, cancellation is a bit more painful<p>No, it isn&#x27;t. Nothing is stopping your threading library from implementing the same thing. It just turns out it is a bad idea to kill threads at random points in time because they may own things like locks.</div><br/></div></div></div></div><div id="36597503" class="c"><input type="checkbox" id="c-36597503" checked=""/><div class="controls bullet"><span class="by">dumdumchan</span><span>|</span><a href="#36596531">parent</a><span>|</span><a href="#36596830">prev</a><span>|</span><a href="#36597333">next</a><span>|</span><label class="collapse" for="c-36597503">[-]</label><label class="expand" for="c-36597503">[6 more]</label></div><br/><div class="children"><div class="content">Look at this program:<p><pre><code>    val another_path = await readFile(path);
    val data = await readFile(another_path);
    console.log(data.length);
</code></pre>
How would you do that using threads?</div><br/><div id="36597604" class="c"><input type="checkbox" id="c-36597604" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#36596531">root</a><span>|</span><a href="#36597503">parent</a><span>|</span><a href="#36597546">next</a><span>|</span><label class="collapse" for="c-36597604">[-]</label><label class="expand" for="c-36597604">[1 more]</label></div><br/><div class="children"><div class="content">For this specific case, just use traditional blocking functions:<p><pre><code>    val another_path = readFileSync(path);
    val data = readFileSync(another_path);
    console.log(data.length);
</code></pre>
The &quot;runtime&quot; (for instance the OS, or a task system) will take care of scheduling other things that are ready to to run while the the blocking functions are &quot;stuck&quot;. That&#x27;s exactly what processes and threads had been invented for.</div><br/></div></div><div id="36597546" class="c"><input type="checkbox" id="c-36597546" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#36596531">root</a><span>|</span><a href="#36597503">parent</a><span>|</span><a href="#36597604">prev</a><span>|</span><a href="#36597572">next</a><span>|</span><label class="collapse" for="c-36597546">[-]</label><label class="expand" for="c-36597546">[3 more]</label></div><br/><div class="children"><div class="content">This program has no concurrency so you could do it without threads.</div><br/><div id="36597575" class="c"><input type="checkbox" id="c-36597575" checked=""/><div class="controls bullet"><span class="by">csomar</span><span>|</span><a href="#36596531">root</a><span>|</span><a href="#36597546">parent</a><span>|</span><a href="#36597572">next</a><span>|</span><label class="collapse" for="c-36597575">[-]</label><label class="expand" for="c-36597575">[2 more]</label></div><br/><div class="children"><div class="content">Not in Rust if you use something like Tokio.</div><br/><div id="36597593" class="c"><input type="checkbox" id="c-36597593" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#36596531">root</a><span>|</span><a href="#36597575">parent</a><span>|</span><a href="#36597572">next</a><span>|</span><label class="collapse" for="c-36597593">[-]</label><label class="expand" for="c-36597593">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty sure this program has no concurrency even if you port it to Rust and use Tokio.</div><br/></div></div></div></div></div></div><div id="36597572" class="c"><input type="checkbox" id="c-36597572" checked=""/><div class="controls bullet"><span class="by">yuvadam</span><span>|</span><a href="#36596531">root</a><span>|</span><a href="#36597503">parent</a><span>|</span><a href="#36597546">prev</a><span>|</span><a href="#36597333">next</a><span>|</span><label class="collapse" for="c-36597572">[-]</label><label class="expand" for="c-36597572">[1 more]</label></div><br/><div class="children"><div class="content">uh, open a thread that does that and `join` on it waiting for it to complete, but why would you need that in your example?</div><br/></div></div></div></div><div id="36597333" class="c"><input type="checkbox" id="c-36597333" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#36596531">parent</a><span>|</span><a href="#36597503">prev</a><span>|</span><a href="#36596848">next</a><span>|</span><label class="collapse" for="c-36597333">[-]</label><label class="expand" for="c-36597333">[1 more]</label></div><br/><div class="children"><div class="content">The alternative with threads on an IO-bound server eventually cycles back to async&#x2F;await but with extra steps. You write synchronous request handlers until you notice IO-waits wasting all your thread time, add more threads to the pool, start hitting overhead from that, then implement greenthreads.<p>NodeJS did it right, and it&#x27;s hard to call a 14-year-old technology a fad.</div><br/></div></div><div id="36596848" class="c"><input type="checkbox" id="c-36596848" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#36596531">parent</a><span>|</span><a href="#36597333">prev</a><span>|</span><a href="#36596976">next</a><span>|</span><label class="collapse" for="c-36596848">[-]</label><label class="expand" for="c-36596848">[2 more]</label></div><br/><div class="children"><div class="content"><i>To me, async is just &quot;cooperative multitasking&quot; with a quick paintjob</i><p>It is, and not only to you. It is a way to save a call stack until a runloop calls it back.<p>But what I can’t agree with is parallels with OS. Coop MT is only problematic in OS MT. When it’s your code there’s no unknown bad actor, and having multiple cooperative (mostly waiting) processes without scheduling them on a thread pool is a useful concept regardless of threads availability.<p>E.g. when you have to wait on multiple sources, the options you have are:<p>- serialize<p>- perform few non-blocking calls and wait for any&#x2F;all of them to complete<p>- schedule them as tasks on a thread pool and wait for their completion<p>Async can do all three, it’s orthogonal. I’d say that just awaiting on PMT task completion is much more convenient that setting up locking primitives. Same for NB polling. Promise is just an abstraction and all it does is waiting for an event to fire on a current thread’s runloop while retaining the comfort of a lexical scope, all with a couple of keywords.</div><br/><div id="36597636" class="c"><input type="checkbox" id="c-36597636" checked=""/><div class="controls bullet"><span class="by">hayley-patton</span><span>|</span><a href="#36596531">root</a><span>|</span><a href="#36596848">parent</a><span>|</span><a href="#36596976">next</a><span>|</span><label class="collapse" for="c-36597636">[-]</label><label class="expand" for="c-36597636">[1 more]</label></div><br/><div class="children"><div class="content">But I&#x27;m my own worst enemy, and blocking the event loop is unpleasant even when I do it myself. Once I had to pass compute-intensive tasks (hashing some data, which took long enough to matter) to a thread pool, to not hurt latency for other tasks in the event loop.<p>&gt; I’d say that just awaiting on PMT task completion is much more convenient that setting up locking primitives.<p>Don&#x27;t use the primitives then - write e.g. a parbegin&#x2F;parallel-map atop thread primitives, and use that.</div><br/></div></div></div></div><div id="36596976" class="c"><input type="checkbox" id="c-36596976" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#36596531">parent</a><span>|</span><a href="#36596848">prev</a><span>|</span><a href="#36597603">next</a><span>|</span><label class="collapse" for="c-36596976">[-]</label><label class="expand" for="c-36596976">[1 more]</label></div><br/><div class="children"><div class="content">async&#x2F;await allows to do concurrency without the need for explicit synchronization to shared data structures.<p>E.g. I can do:<p><pre><code>    loop {
      select! {
         _ = src_channel.readable() =&gt; src_channel.read(&amp;mut buffer),
         _ = dst_channel.writable() =&gt; dst_channel.write(&amp;mut buffer),
      }
    }
</code></pre>
without any mutex guarding the buffer, even though the reads and writes happen concurrently and share the same mutable buffer. This is possible because with async&#x2F;await the concurrency is cooperative, the code precisely controls where context switches can happen (in this case this is the select! waiting for event), and the compiler can see that even though the code as a whole is concurrent, the branches of select do not run <i>at the same time</i> in parallel.<p>This is not possible to achieve with threads directly. If using blocking I&#x2F;O + threads model, then you&#x27;d need to dedicate one thread for reading and one for writing and then synchronize access to the shared data structure (where using a queue&#x2F;channel also counts as synchronization). Which obviously would be much harder to get right.</div><br/></div></div><div id="36597603" class="c"><input type="checkbox" id="c-36597603" checked=""/><div class="controls bullet"><span class="by">secretsatan</span><span>|</span><a href="#36596531">parent</a><span>|</span><a href="#36596976">prev</a><span>|</span><a href="#36596777">next</a><span>|</span><label class="collapse" for="c-36597603">[-]</label><label class="expand" for="c-36597603">[1 more]</label></div><br/><div class="children"><div class="content">Really weird to throw in JS as the culprit, this is a long standing issue, the asynchronous nature of web work probably highlights it but dealing with asynchronous tasks is part and parcel of writing complex performant applications. Much may be hidden by modern dev environments, but you won&#x27;t get far beyond the most simple apps before you need to start thinking about how to deal with it.</div><br/></div></div><div id="36596777" class="c"><input type="checkbox" id="c-36596777" checked=""/><div class="controls bullet"><span class="by">pantulis</span><span>|</span><a href="#36596531">parent</a><span>|</span><a href="#36597603">prev</a><span>|</span><a href="#36597398">next</a><span>|</span><label class="collapse" for="c-36596777">[-]</label><label class="expand" for="c-36596777">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it started because JS can&#x27;t do parallel any other way<p>I remember doing async in C++ with CORBA and ACE&#x27;s Reactor pattern about 25 years ago, it was not beautiful nor easy.<p>But if memory serves, most interpreted server side languages used for web programming in the late 2000&#x27;s didn&#x27;t have mature multithreading or async capabilities and most of the deployments consisted on exec&#x2F;forked full application servers.  I would also bet that this is exactly what made Node.js popular.<p>To each its own, async is just another tool in the proverbial belt.</div><br/></div></div><div id="36597398" class="c"><input type="checkbox" id="c-36597398" checked=""/><div class="controls bullet"><span class="by">diarrhea</span><span>|</span><a href="#36596531">parent</a><span>|</span><a href="#36596777">prev</a><span>|</span><a href="#36597222">next</a><span>|</span><label class="collapse" for="c-36597398">[-]</label><label class="expand" for="c-36597398">[1 more]</label></div><br/><div class="children"><div class="content">&gt; We left behind that paradigm in Operating Systems decades ago, and with good reason.<p>I&#x27;m curious, what reason?<p>I grew up on Python and C#, and only know async&#x2F;await, never done real threading (C# async is threading and coroutines under the hood, Python is just coroutines, single-threaded). I find that way of writing code very elegant, as one can encode points of blocking&#x2F;switching explicitly. A bit like encoding logic into the type system (cliffle has an article on the type state pattern, a good read!): the underlying async implementation can change without code adjustments.</div><br/></div></div><div id="36597222" class="c"><input type="checkbox" id="c-36597222" checked=""/><div class="controls bullet"><span class="by">3np</span><span>|</span><a href="#36596531">parent</a><span>|</span><a href="#36597398">prev</a><span>|</span><a href="#36596889">next</a><span>|</span><label class="collapse" for="c-36597222">[-]</label><label class="expand" for="c-36597222">[1 more]</label></div><br/><div class="children"><div class="content">Your rant reminded me of this classic post, which I believe shares your views but from different reasoning. From the discussion, you may be interested in looking at zig[0].<p><a href="https:&#x2F;&#x2F;journal.stuffwithstuff.com&#x2F;2015&#x2F;02&#x2F;01&#x2F;what-color-is-your-function&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;journal.stuffwithstuff.com&#x2F;2015&#x2F;02&#x2F;01&#x2F;what-color-is-...</a><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36597229">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36597229</a> (fresh repost)<p>Discussed previously:<p><pre><code>  https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8984648 (8ya)
  https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=16732948 (5ya)
  https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23218782 (3ya)
  https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28657358 (2ya)

</code></pre>
[0]: <a href="https:&#x2F;&#x2F;kristoff.it&#x2F;blog&#x2F;zig-colorblind-async-await&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;kristoff.it&#x2F;blog&#x2F;zig-colorblind-async-await&#x2F;</a></div><br/></div></div><div id="36596889" class="c"><input type="checkbox" id="c-36596889" checked=""/><div class="controls bullet"><span class="by">tbillington</span><span>|</span><a href="#36596531">parent</a><span>|</span><a href="#36597222">prev</a><span>|</span><a href="#36596783">next</a><span>|</span><label class="collapse" for="c-36596889">[-]</label><label class="expand" for="c-36596889">[1 more]</label></div><br/><div class="children"><div class="content">Fundamentally, async&#x2F;await and threads are different tools. Async&#x2F;await is &quot;in vogue&quot; at the moment, but there are still real advantages in certain scenarios.<p>For example, the blog authors project is an OS running on minimal resources that would not be appropriate for any threading model I&#x27;m aware of.<p><pre><code>  This is a wee operating system written to support the async style of programming in Rust on microcontrollers. It fits in about 2 kiB of Flash and uses about 20 bytes of RAM (before your tasks are added). In that space, you get a full async runtime with multiple tasks, support for complex concurrency via join and select, and a lot of convenient but simple APIs.
</code></pre>
Rust actually used to have green threads before 1.0. You can read about the proposal and reasoning for it&#x27;s removal here <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;blob&#x2F;master&#x2F;text&#x2F;0230-remove-runtime.md">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;blob&#x2F;master&#x2F;text&#x2F;0230-remo...</a>.<p>If you&#x27;d like more info on the story around the adoption of async&#x2F;await in rust you can see this excellent talk by Steve K. <a href="https:&#x2F;&#x2F;www.infoq.com&#x2F;presentations&#x2F;rust-2019&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.infoq.com&#x2F;presentations&#x2F;rust-2019&#x2F;</a>.</div><br/></div></div><div id="36596783" class="c"><input type="checkbox" id="c-36596783" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#36596531">parent</a><span>|</span><a href="#36596889">prev</a><span>|</span><a href="#36597031">next</a><span>|</span><label class="collapse" for="c-36596783">[-]</label><label class="expand" for="c-36596783">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a role for async, and it&#x27;s when you&#x27;re very I&#x2F;O bound, you have one thread, and async means you don&#x27;t need locking. This is simple to think about. That&#x27;s the classic JavaScript model.<p>If you have compute-bound components, things get more complicated. If you have threads, locks, and async, all in one program, things get much more complicated. I&#x27;m not sure that&#x27;s a win. At some point, it&#x27;s easier to use something like Go&#x27;s green-thread &quot;goroutines&quot;, which try not to block, but can block if they have to.</div><br/></div></div><div id="36597031" class="c"><input type="checkbox" id="c-36597031" checked=""/><div class="controls bullet"><span class="by">motbus3</span><span>|</span><a href="#36596531">parent</a><span>|</span><a href="#36596783">prev</a><span>|</span><a href="#36597626">next</a><span>|</span><label class="collapse" for="c-36597031">[-]</label><label class="expand" for="c-36597031">[1 more]</label></div><br/><div class="children"><div class="content">Others have already answered to you, but maybe a bit more affirmation may help.<p>Concurrency and parallelism are different concepts.
Many many years ago it was easy to confuse them both because there were no parallelism. You had a single big core and CPU pipelines were much simpler.<p>I won&#x27;t delve into details, although I found them fascinating, but concurrency and parallelism are different tools.
I confess I found the name &quot;concurrency&quot; not useful.<p>Concurrency allows you to transfer control from one piece of text (I mean executable code) to another while it waits for the return.<p>Parallel means instructions are being executed, well, in parallel.<p>The OS scheduler does not inspect the code, nor know that the next instruction will be a noop sleep.
Some languages with runtime environments provide basically functionality pra intercepting calls and nudging the OS.<p>Attempts in the past of requiring each application to be clear about sharing control but it failed. One single bad application could hang and compromise the entire system.
As a matter of fact, some RTOS uses this premise of development.<p>Async has been implemented by providing a runtime library which saves the context and swap tasks. The control is only hidden from the programmer.<p>I do not know about Golang, but I suppose coroutines are implemented in a different way, as it seems to me, that the compiler handles this. But I don&#x27;t know.</div><br/></div></div><div id="36597626" class="c"><input type="checkbox" id="c-36597626" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#36596531">parent</a><span>|</span><a href="#36597031">prev</a><span>|</span><a href="#36597521">next</a><span>|</span><label class="collapse" for="c-36597626">[-]</label><label class="expand" for="c-36597626">[3 more]</label></div><br/><div class="children"><div class="content">My opinion is the opposite, to the point I would argue that anyone advocating for multithreading for reasons other than executing things in parallel on different cores is extremely dangerous and shouldn&#x27;t be allowed anywhere near a serious codebase.</div><br/><div id="36597663" class="c"><input type="checkbox" id="c-36597663" checked=""/><div class="controls bullet"><span class="by">pltzxy</span><span>|</span><a href="#36596531">root</a><span>|</span><a href="#36597626">parent</a><span>|</span><a href="#36597657">next</a><span>|</span><label class="collapse" for="c-36597663">[-]</label><label class="expand" for="c-36597663">[1 more]</label></div><br/><div class="children"><div class="content">Are you talking about Rust (which I don&#x27;t know)? In Python the async people don&#x27;t care much about correctness.</div><br/></div></div><div id="36597657" class="c"><input type="checkbox" id="c-36597657" checked=""/><div class="controls bullet"><span class="by">psychphysic</span><span>|</span><a href="#36596531">root</a><span>|</span><a href="#36597626">parent</a><span>|</span><a href="#36597663">prev</a><span>|</span><a href="#36597521">next</a><span>|</span><label class="collapse" for="c-36597657">[-]</label><label class="expand" for="c-36597657">[1 more]</label></div><br/><div class="children"><div class="content">Erlang&#x2F;OTP has entered the chat.</div><br/></div></div></div></div><div id="36597521" class="c"><input type="checkbox" id="c-36597521" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#36596531">parent</a><span>|</span><a href="#36597626">prev</a><span>|</span><a href="#36596982">next</a><span>|</span><label class="collapse" for="c-36597521">[-]</label><label class="expand" for="c-36597521">[1 more]</label></div><br/><div class="children"><div class="content">Most languages don&#x27;t have preemptively scheduled green threads like golang.<p>In Lua and Zig we have &quot;cooperative multitasking&quot; but we get to use the same library for both kinds of applications :)</div><br/></div></div><div id="36596982" class="c"><input type="checkbox" id="c-36596982" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#36596531">parent</a><span>|</span><a href="#36597521">prev</a><span>|</span><a href="#36597343">next</a><span>|</span><label class="collapse" for="c-36596982">[-]</label><label class="expand" for="c-36596982">[1 more]</label></div><br/><div class="children"><div class="content">Coroutines, async, parallelism and concurrency is my main hobby.<p>Business logic programmers shouldn&#x27;t be dealing with machine level parallelism and async unless heavily abstracted, such as in a job queue or evented message queue.<p>JMP or RET is how the machine transfers control flow at the machine level. So coroutines are a natural solution to switching between code at the machine layer.<p>If you&#x27;re working in Javascript, then you shouldn&#x27;t have to worry about this stuff.<p>Cooperative multitasking is elegant, within a process for scheduling but not as the main approach for the operating system to switch between processes, it&#x27;s a subtle difference.<p>If the operating system depends on cooperative multitasking, some buggy processes can keep control flow to themselves. But using cooperative multitasking inside a process for code elegance, is a good way of scheduling and decoupling concerns.<p>I have a lightweight thread runtime similar to Go and I find event loops really interesting, I want to make the pain of async and parallelism go away.</div><br/></div></div><div id="36597343" class="c"><input type="checkbox" id="c-36597343" checked=""/><div class="controls bullet"><span class="by">vmfunction</span><span>|</span><a href="#36596531">parent</a><span>|</span><a href="#36596982">prev</a><span>|</span><a href="#36597036">next</a><span>|</span><label class="collapse" for="c-36597343">[-]</label><label class="expand" for="c-36597343">[2 more]</label></div><br/><div class="children"><div class="content">&gt;Not specific to rust, but I think asynchronous programming in general is a hype.<p>Hmm, wasn&#x27;t the whole point of doing things in event loop because it way out perform thread-based architecture? Like  when Nginx way out performs Apache? On a single core CPU of course.<p>Edit: It is not that event-loop is better than thread-based, just in a web server scenario it just perform much better.</div><br/><div id="36597470" class="c"><input type="checkbox" id="c-36597470" checked=""/><div class="controls bullet"><span class="by">arijun</span><span>|</span><a href="#36596531">root</a><span>|</span><a href="#36597343">parent</a><span>|</span><a href="#36597036">next</a><span>|</span><label class="collapse" for="c-36597470">[-]</label><label class="expand" for="c-36597470">[1 more]</label></div><br/><div class="children"><div class="content">The parent comment mentions green threads. While there is some performance hit to using them, I don’t think it is way less performant. I mean, go was built for being a web backend, and is based on green threads.<p>For rust specifically, though, green threads&#x2F;coroutines were discarded because they are not zero-cost.</div><br/></div></div></div></div><div id="36597036" class="c"><input type="checkbox" id="c-36597036" checked=""/><div class="controls bullet"><span class="by">mjan22640</span><span>|</span><a href="#36596531">parent</a><span>|</span><a href="#36597343">prev</a><span>|</span><a href="#36597070">next</a><span>|</span><label class="collapse" for="c-36597036">[-]</label><label class="expand" for="c-36597036">[1 more]</label></div><br/><div class="children"><div class="content">This is an occurence of co-Blub paradox <a href="https:&#x2F;&#x2F;reasonablypolymorphic.com&#x2F;blog&#x2F;coblub&#x2F;index.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;reasonablypolymorphic.com&#x2F;blog&#x2F;coblub&#x2F;index.html</a></div><br/></div></div><div id="36597070" class="c"><input type="checkbox" id="c-36597070" checked=""/><div class="controls bullet"><span class="by">qwertox</span><span>|</span><a href="#36596531">parent</a><span>|</span><a href="#36597036">prev</a><span>|</span><a href="#36596732">next</a><span>|</span><label class="collapse" for="c-36597070">[-]</label><label class="expand" for="c-36597070">[1 more]</label></div><br/><div class="children"><div class="content">For me async&#x2F;await was a godsend. I&#x27;ve had so bad experiences with multithreading in C++, where I ended up in a Semaphore&#x2F;Mutex hell in a big project, that async&#x2F;await is a really welcome compromise between using idle CPU resources and just not doing multiple things at once.<p>Then there&#x27;s `#[tokio::main(flavor = &quot;multi_thread&quot;, worker_threads = 2)]` which actually lets you use multithreading with async&#x2F;await which is just a nice feature to have, given that Python can&#x27;t do this due to the GIL. But asyncio in Python is also so great.</div><br/></div></div></div></div><div id="36596732" class="c"><input type="checkbox" id="c-36596732" checked=""/><div class="controls bullet"><span class="by">leoedin</span><span>|</span><a href="#36596531">prev</a><span>|</span><a href="#36597157">next</a><span>|</span><label class="collapse" for="c-36596732">[-]</label><label class="expand" for="c-36596732">[1 more]</label></div><br/><div class="children"><div class="content">The article shows a great example of how to implement a state machine with internal delays (do something, wait for a defined time, do something else), which is very useful in a driver or embedded context where you often just have to wait for an external device to be ready.<p>However, it doesn&#x27;t really address how you&#x27;d construct a state machine with an external tick. It&#x27;s pretty common to have a state machine called at a fixed frequency. I guess to implement that (using the pending!() Macro between state actions) you&#x27;d need to implement a custom executor?</div><br/></div></div><div id="36597157" class="c"><input type="checkbox" id="c-36597157" checked=""/><div class="controls bullet"><span class="by">ngrilly</span><span>|</span><a href="#36596732">prev</a><span>|</span><a href="#36596817">next</a><span>|</span><label class="collapse" for="c-36597157">[-]</label><label class="expand" for="c-36597157">[1 more]</label></div><br/><div class="children"><div class="content">Archive, as the original link seems to be unresponsive: <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20230702221952&#x2F;http:&#x2F;&#x2F;cliffle.com&#x2F;blog&#x2F;async-inversion&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20230702221952&#x2F;http:&#x2F;&#x2F;cliffle.co...</a></div><br/></div></div><div id="36596817" class="c"><input type="checkbox" id="c-36596817" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#36597157">prev</a><span>|</span><a href="#36596951">next</a><span>|</span><label class="collapse" for="c-36596817">[-]</label><label class="expand" for="c-36596817">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for this article.<p>I feel the goal of a tool should be to make common patterns easy to represent: so &quot;sprinkling async everywhere&quot; only doesn&#x27;t work because of some common desirable pattern not being easily representable in modern languages and gotchas of the languages.<p>I have a lightweight thread scheduler written in C and I communicate between threads with a lockless ringbuffer. IO threads do IO. I like the idea of event loops and libuv but I want parallelism.<p>I wanted to understand how to compile async&#x2F;await so I wrote a multithreaded unrolled state machine in Java. Each async keyword sends to another thread. I haven&#x27;t got it to send to a different thread each time to load balance, I need to spend more time on it.<p><pre><code>  task1:
    handle1 = async task2();
    handle2 = async task3();
    handle3 = async task4();
    &#x2F;&#x2F; at this point, I want task2, task3, task4 to be going on in parallel ON DIFFERENT threads
    await handle1;
    await handle2;
    await handle3;
</code></pre>
I am designing a notation for concurrency and asynchronocity that is a directly a state machine. I need to write a specification and I&#x27;m working on a Java runtime. It looks like this. It&#x27;s inspired by BNF and Prolog facts.<p><pre><code>  thread(s) = state1(yes) | send(message) | receive(message2);
  thread(r) = state1(yes) | receive(message) | send(message2);
</code></pre>
I am inspired by Pony lang, Go and Erlang but I think there&#x27;s still lots of potential innovation in this space that could be had.</div><br/></div></div><div id="36596951" class="c"><input type="checkbox" id="c-36596951" checked=""/><div class="controls bullet"><span class="by">eis</span><span>|</span><a href="#36596817">prev</a><span>|</span><a href="#36597361">next</a><span>|</span><label class="collapse" for="c-36596951">[-]</label><label class="expand" for="c-36596951">[11 more]</label></div><br/><div class="children"><div class="content">I think Go got it right by inverting the logic around async&#x2F;await. In Go you have to explicitly state that a function is to run in the background via &quot;go fn(...)&quot;. This makes it much clearer that this code will execute concurrently. In the async&#x2F;await world you can&#x27;t tell by looking at a function call if it will block until it&#x27;s done. Forgot an await? No compile error but your program might behave in weird ways. This has bitten me in JS too many times. Haven&#x27;t done too much async Rust yet but I don&#x27;t think it solved this issue from what I&#x27;ve seen. Why can&#x27;t &quot;await&quot; be the default when calling an async function and if you don&#x27;t need the result right away then call it with &quot;async func(...)&quot;?</div><br/><div id="36597462" class="c"><input type="checkbox" id="c-36597462" checked=""/><div class="controls bullet"><span class="by">CryZe</span><span>|</span><a href="#36596951">parent</a><span>|</span><a href="#36597151">next</a><span>|</span><label class="collapse" for="c-36597462">[-]</label><label class="expand" for="c-36597462">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Haven&#x27;t done too much async Rust yet but I don&#x27;t think it solved this issue from what I&#x27;ve seen.<p>In Rust an async function is really just a const fn that synchronously only constructs and returns a state machine struct that implements the Future trait.<p>So<p>async fn foo(x: i32) { }<p>essentially desugars to<p>const fn foo(x: i32) -&gt; FooFuture {
    FooFuture { x }
}<p>struct FooFuture {
    x: i32
} &#x2F;&#x2F; technically it&#x27;s an enum modelling the state machine<p>impl Future for FooFuture { ... }<p>You have to explicitly spawn that onto a runtime or await it (i.e. combine it into the state machine that your code is already in). So that&#x27;s actually really cool about how Rust handles async; that an async fn really isn&#x27;t doing any magic, it just constructs a state machine and never interacts (or spawns) with a runtime at all, so it never starts running in the background, you are always in full control. And by throwing the future away, you are essentially cancelling it, there&#x27;s no need to interact with any runtime either.</div><br/></div></div><div id="36597151" class="c"><input type="checkbox" id="c-36597151" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#36596951">parent</a><span>|</span><a href="#36597462">prev</a><span>|</span><a href="#36597122">next</a><span>|</span><label class="collapse" for="c-36597151">[-]</label><label class="expand" for="c-36597151">[3 more]</label></div><br/><div class="children"><div class="content">You&#x27;re talking about particular JS implementation problems, not general async&#x2F;await problems.<p>&gt;  In Go you have to explicitly state that a function is to run in the background via &quot;go fn(...)&quot;.<p>In Rust you have to explicitly `spawn` a task to detach it from the current coroutine and make it run in background. Typically this is much more costly than not spawning and executing async function concurrently as part of the same coroutine&#x27;s state machine (and Go actually doesn&#x27;t give you that option at all).<p>&gt;  In the async&#x2F;await world you can&#x27;t tell by looking at a function call if it will block until its done.<p><pre><code>   foo().await();  &lt;-- blocks
   foo();          &lt;-- doesn&#x27;t block
</code></pre>
&gt; Forgot an await? No compile error<p><pre><code>   warning: unused implementer of `futures::Future` that must be used
</code></pre>
&gt; Why can&#x27;t &quot;await&quot; be the default when calling an async function<p>For similar reasons you don&#x27;t want `clone()` to be implicit or rethrowing errors to be implicit (like exceptions in Java).<p>Awaiting implicitly would hide a potentially long and important operation. Await typically means the control is yielded back to the executor and it can switch to another task. You don&#x27;t want it in a language that wants to give as much control about performance as possible to the developer. Being able to see that &quot;this fragment of code will never be preempted&quot; is a great thing for predictability. Rust is not Go&#x2F;Java - nobody is going to celebrate achieving sub 1 ms latency here.<p>Additionally there are certain things you are not allowed to keep across await points, e.g. mutex guards or other stuff that&#x27;s not safe to switch between threads. E.g. using a thread-local data structure across await points might break, because you could be on a different thread after await. If await was hidden, you&#x27;d likely be much more surprised when the compiler would reject some code due to &quot;invisible&quot; await.</div><br/><div id="36597278" class="c"><input type="checkbox" id="c-36597278" checked=""/><div class="controls bullet"><span class="by">eis</span><span>|</span><a href="#36596951">root</a><span>|</span><a href="#36597151">parent</a><span>|</span><a href="#36597122">next</a><span>|</span><label class="collapse" for="c-36597278">[-]</label><label class="expand" for="c-36597278">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    &gt; foo();          &lt;-- doesn&#x27;t block
</code></pre>
Only if you know that foo is an async function. You can&#x27;t tell by the function call itelf.<p><pre><code>    &gt; warning: unused implementer of `futures::Future` that must be used
</code></pre>
Interesting, I haven&#x27;t seen this warning in the Rust codebase I worked a little with. I&#x27;ll have to check the compiler settings. Anyways wouldn&#x27;t it make sense to actually throw an error instead of just a warning?<p><pre><code>    &gt; Additionally there are certain things you are not allowed to keep across await points, e.g. mutex guards or other stuff that&#x27;s not safe to switch between threads. E.g. using a thread-local data structure across await points might break, because you could be on a different thread after await. If await was hidden, you&#x27;d likely be much more surprised when the compiler would reject some code due to &quot;invisible&quot; await. 
</code></pre>
Why couldn&#x27;t the compiler clearly state the reason for the error though?</div><br/><div id="36597348" class="c"><input type="checkbox" id="c-36597348" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#36596951">root</a><span>|</span><a href="#36597278">parent</a><span>|</span><a href="#36597122">next</a><span>|</span><label class="collapse" for="c-36597348">[-]</label><label class="expand" for="c-36597348">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Only if you know that foo is an async function. You can&#x27;t tell by the function call itelf.<p>That&#x27;s fair point, but traditionally you don&#x27;t use blocking functions in async contexts at all. It is fairly easy to lint for by prohibiting some inherently blocking calls eg.g std::io, although they might sneak in through some third-party dependency.<p>This doesn&#x27;t have an easy solution because Rust is a general purpose language that allows different styles of concurrency adapted best to the situation, instead of one-size-fits-all like Golang.<p>Rust has means to annotate functions so maybe there will be some automation to deal with that in the future, similar to how `#[must_use]` works now. E.g. `#[blocking]` or whatever.<p>&gt; I&#x27;ll have to check the compiler settings.<p>This is with default compiler settings.<p>&gt;  Why couldn&#x27;t the compiler clearly state the reason for the error though?<p>Stating the reason is probably solvable problem, but there is another problem: what if 5 layers down the call chain something suddenly introduces a potentially blocking (awaiting) operation? This would mean that some code that previously compiled now has to stop compiling even though it <i>hasn&#x27;t changed</i> and even though none of the <i>signatures</i> it uses changed. I guess it would break things like separate compilation.<p>And again, it would be less readable than it is now. Now it is fairly simple - you don&#x27;t have to look down the call chain to know that something can do await.</div><br/></div></div></div></div></div></div><div id="36597122" class="c"><input type="checkbox" id="c-36597122" checked=""/><div class="controls bullet"><span class="by">sirwhinesalot</span><span>|</span><a href="#36596951">parent</a><span>|</span><a href="#36597151">prev</a><span>|</span><a href="#36597089">next</a><span>|</span><label class="collapse" for="c-36597122">[-]</label><label class="expand" for="c-36597122">[2 more]</label></div><br/><div class="children"><div class="content">It wouldn&#x27;t work. In Go, it doesn&#x27;t matter how deeply nested a call to a blocking function is, when you do &quot;go f()&quot; the runtime takes care of things.<p>With async however, if &quot;await&quot; is the default, then as soon as an async function calls another async function, it would block, completely defeating the point of async in the first place.<p>I guess you could flip the rules and say that within an async function async is the default and within a regular function await is the default, but actually in most languages a regular function can&#x27;t call an async function directly because async needs to propagate all the way to the event loop. So you&#x27;d just have async as the default again.<p>My explanation sucks but if you want to go into this rabbit hole look up &quot;stackful vs stackless coroutines&quot;.</div><br/><div id="36597214" class="c"><input type="checkbox" id="c-36597214" checked=""/><div class="controls bullet"><span class="by">eis</span><span>|</span><a href="#36596951">root</a><span>|</span><a href="#36597122">parent</a><span>|</span><a href="#36597089">next</a><span>|</span><label class="collapse" for="c-36597214">[-]</label><label class="expand" for="c-36597214">[1 more]</label></div><br/><div class="children"><div class="content">It would just make things more explicit. Whenever you want to obtain a future you&#x27;d have to add &quot;async&quot;. The execution of async stuff would work the same just instead of having to explicitly &quot;await&quot; things you&#x27;d have to explicitly &quot;async&quot; things. Of course you can&#x27;t change the way Rust does async&#x2F;await now without having to rewrite all the async code so not going to happen.</div><br/></div></div></div></div><div id="36597089" class="c"><input type="checkbox" id="c-36597089" checked=""/><div class="controls bullet"><span class="by">tcfhgj</span><span>|</span><a href="#36596951">parent</a><span>|</span><a href="#36597122">prev</a><span>|</span><a href="#36597104">next</a><span>|</span><label class="collapse" for="c-36597089">[-]</label><label class="expand" for="c-36597089">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Haven&#x27;t done too much async Rust yet but I don&#x27;t think it solved this issue from what I&#x27;ve seen.<p>If you don&#x27;t await your variable contains a future - how are you using that like e.g. an int, without a compiler error?</div><br/><div id="36597150" class="c"><input type="checkbox" id="c-36597150" checked=""/><div class="controls bullet"><span class="by">eis</span><span>|</span><a href="#36596951">root</a><span>|</span><a href="#36597089">parent</a><span>|</span><a href="#36597104">next</a><span>|</span><label class="collapse" for="c-36597150">[-]</label><label class="expand" for="c-36597150">[2 more]</label></div><br/><div class="children"><div class="content">The issue arises if you don&#x27;t use the returned value. Lets say there&#x27;s a function &quot;async fn saveToDisk()&quot;. You call this function before you exit the program. Now if you forget to use await on it, your program will exit without having saved the data to disk.</div><br/><div id="36597583" class="c"><input type="checkbox" id="c-36597583" checked=""/><div class="controls bullet"><span class="by">phicoh</span><span>|</span><a href="#36596951">root</a><span>|</span><a href="#36597150">parent</a><span>|</span><a href="#36597104">next</a><span>|</span><label class="collapse" for="c-36597583">[-]</label><label class="expand" for="c-36597583">[1 more]</label></div><br/><div class="children"><div class="content">In any sensible API, saveToDisk would return an error status (a Result type in Rust). If you don&#x27;t check for errors, then probably you didn&#x27;t care of the data was actually saved or not.</div><br/></div></div></div></div></div></div><div id="36597104" class="c"><input type="checkbox" id="c-36597104" checked=""/><div class="controls bullet"><span class="by">conradludgate</span><span>|</span><a href="#36596951">parent</a><span>|</span><a href="#36597089">prev</a><span>|</span><a href="#36597361">next</a><span>|</span><label class="collapse" for="c-36597104">[-]</label><label class="expand" for="c-36597104">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s actually very likely you&#x27;ll have a compile error. Async functions return a Future (like a Promise in JS)  and this isn&#x27;t a value you can typically use inplace of others. There are also an on-by-default warning if you don&#x27;t use the Future value at all</div><br/></div></div></div></div></div></div></div></div></div></body></html>