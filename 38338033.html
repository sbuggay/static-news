<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1700470865350" as="style"/><link rel="stylesheet" href="styles.css?v=1700470865350"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://htmx.org/essays/why-tend-not-to-use-content-negotiation/">Why I tend not to use content negotiation</a> <span class="domain">(<a href="https://htmx.org">htmx.org</a>)</span></div><div class="subtext"><span>TheBigRoomXXL</span> | <span>100 comments</span></div><br/><div><div id="38338963" class="c"><input type="checkbox" id="c-38338963" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#38340987">next</a><span>|</span><label class="collapse" for="c-38338963">[-]</label><label class="expand" for="c-38338963">[55 more]</label></div><br/><div class="children"><div class="content">Cloudflare doesn&#x27;t obey the Accept header on anything other than image content types.<p>This means if you have an endpoint that returns HTML or JSON depending on the requested content type and you try to serve it from behind Cloudflare you risk serving cached JSON to HTML user agents or vice-versa.<p>I dropped the idea of supporting content negotiation from my Datasette project because of this.<p>(And because I personally don&#x27;t like that kind of endpoint - I want to be able to know if a specific URL is going to return JSON or HTML).</div><br/><div id="38341006" class="c"><input type="checkbox" id="c-38341006" checked=""/><div class="controls bullet"><span class="by">LeonB</span><span>|</span><a href="#38338963">parent</a><span>|</span><a href="#38344913">next</a><span>|</span><label class="collapse" for="c-38341006">[-]</label><label class="expand" for="c-38341006">[28 more]</label></div><br/><div class="children"><div class="content">A wisened old web developer named Rik told me that in a wiki he wrote long ago he performed his own cache-busting form of content negotiation by having urls ends with a file type —<p>E.g.<p><pre><code>    &#x2F;fred.html - returns html 
    &#x2F;fred.md   - returns markdown
    &#x2F;fred.json - returns json
</code></pre>
(I’m guessing that also —<p><pre><code>    &#x2F;fred  - defaults to html
</code></pre>
)<p>Though he was a strict fundamentalist restafarian in other ways he held that this had the benefits of<p>1. Working<p>2. Being readily understood<p>I’ve seen worse ideas. Only downside is that the urls look a bit ugly.</div><br/><div id="38342083" class="c"><input type="checkbox" id="c-38342083" checked=""/><div class="controls bullet"><span class="by">MenhirMike</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38341006">parent</a><span>|</span><a href="#38343755">next</a><span>|</span><label class="collapse" for="c-38342083">[-]</label><label class="expand" for="c-38342083">[8 more]</label></div><br/><div class="children"><div class="content">&gt; Only downside is that the urls look a bit ugly.<p>If &#x2F;fred returns HTML, then the URL is perfectly fine, since the only real consumer of fred.md or fred.json are automated systems&#x2F;API clients, and they couldn&#x27;t care less what the URL looks like, only that it&#x27;s predictable.</div><br/><div id="38342120" class="c"><input type="checkbox" id="c-38342120" checked=""/><div class="controls bullet"><span class="by">manwe150</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38342083">parent</a><span>|</span><a href="#38343755">next</a><span>|</span><label class="collapse" for="c-38342120">[-]</label><label class="expand" for="c-38342120">[7 more]</label></div><br/><div class="children"><div class="content">It is a good trick with GitHub though that you can add .patch or .diff to the url to fetch the content without styling</div><br/><div id="38344939" class="c"><input type="checkbox" id="c-38344939" checked=""/><div class="controls bullet"><span class="by">moondev</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38342120">parent</a><span>|</span><a href="#38343434">next</a><span>|</span><label class="collapse" for="c-38344939">[-]</label><label class="expand" for="c-38344939">[1 more]</label></div><br/><div class="children"><div class="content">Adding .pibb to a gist url is another nice trick</div><br/></div></div><div id="38343434" class="c"><input type="checkbox" id="c-38343434" checked=""/><div class="controls bullet"><span class="by">going_north</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38342120">parent</a><span>|</span><a href="#38344939">prev</a><span>|</span><a href="#38343124">next</a><span>|</span><label class="collapse" for="c-38343434">[-]</label><label class="expand" for="c-38343434">[4 more]</label></div><br/><div class="children"><div class="content">Another good one for GitHub is that you can do<p><pre><code>    github.com&#x2F;[username].png
</code></pre>
to get that username&#x27;s profile picture.</div><br/><div id="38344185" class="c"><input type="checkbox" id="c-38344185" checked=""/><div class="controls bullet"><span class="by">theblazehen</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38343434">parent</a><span>|</span><a href="#38343124">next</a><span>|</span><label class="collapse" for="c-38344185">[-]</label><label class="expand" for="c-38344185">[3 more]</label></div><br/><div class="children"><div class="content">And<p><pre><code>        github.com&#x2F;[username].keys
</code></pre>
to get their ssh keys</div><br/><div id="38344250" class="c"><input type="checkbox" id="c-38344250" checked=""/><div class="controls bullet"><span class="by">barosl</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38344185">parent</a><span>|</span><a href="#38343124">next</a><span>|</span><label class="collapse" for="c-38344250">[-]</label><label class="expand" for="c-38344250">[2 more]</label></div><br/><div class="children"><div class="content">We have<p><pre><code>  github.com&#x2F;[username].gpg
</code></pre>
to get their OpenPGP keys, too!</div><br/><div id="38345074" class="c"><input type="checkbox" id="c-38345074" checked=""/><div class="controls bullet"><span class="by">rapnie</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38344250">parent</a><span>|</span><a href="#38343124">next</a><span>|</span><label class="collapse" for="c-38345074">[-]</label><label class="expand" for="c-38345074">[1 more]</label></div><br/><div class="children"><div class="content">Just go for .secrets to get it all in one request.</div><br/></div></div></div></div></div></div></div></div><div id="38343124" class="c"><input type="checkbox" id="c-38343124" checked=""/><div class="controls bullet"><span class="by">amake</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38342120">parent</a><span>|</span><a href="#38343434">prev</a><span>|</span><a href="#38343755">next</a><span>|</span><label class="collapse" for="c-38343124">[-]</label><label class="expand" for="c-38343124">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not just styling. The content is actually a `git format-patch` patch for the former a unified-format diff for the latter.</div><br/></div></div></div></div></div></div><div id="38343755" class="c"><input type="checkbox" id="c-38343755" checked=""/><div class="controls bullet"><span class="by">euroderf</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38341006">parent</a><span>|</span><a href="#38342083">prev</a><span>|</span><a href="#38341368">next</a><span>|</span><label class="collapse" for="c-38343755">[-]</label><label class="expand" for="c-38343755">[1 more]</label></div><br/><div class="children"><div class="content">But doesn&#x27;t &lt;&lt; &#x2F;fred.md &gt;&gt; beat the heck out of something like &lt;&lt; &#x2F;fred?format=md &gt;&gt;?</div><br/></div></div><div id="38341368" class="c"><input type="checkbox" id="c-38341368" checked=""/><div class="controls bullet"><span class="by">giancarlostoro</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38341006">parent</a><span>|</span><a href="#38343755">prev</a><span>|</span><a href="#38342543">next</a><span>|</span><label class="collapse" for="c-38341368">[-]</label><label class="expand" for="c-38341368">[1 more]</label></div><br/><div class="children"><div class="content">I think if this is the URL behind any sort of &quot;api&quot; prefix in the URL (subdomain, or subdirectory) I don&#x27;t see why not? It&#x27;s always worked out pretty darned fantastic.</div><br/></div></div><div id="38342543" class="c"><input type="checkbox" id="c-38342543" checked=""/><div class="controls bullet"><span class="by">trevor-e</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38341006">parent</a><span>|</span><a href="#38341368">prev</a><span>|</span><a href="#38344069">next</a><span>|</span><label class="collapse" for="c-38342543">[-]</label><label class="expand" for="c-38342543">[3 more]</label></div><br/><div class="children"><div class="content">Reddit does this too. You can add a &quot;.json&quot; suffix to any post and get the JSON response.</div><br/><div id="38344082" class="c"><input type="checkbox" id="c-38344082" checked=""/><div class="controls bullet"><span class="by">navanchauhan</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38342543">parent</a><span>|</span><a href="#38344069">next</a><span>|</span><label class="collapse" for="c-38344082">[-]</label><label class="expand" for="c-38344082">[2 more]</label></div><br/><div class="children"><div class="content">also &quot;.rss&quot; to get a RSS feed</div><br/><div id="38344167" class="c"><input type="checkbox" id="c-38344167" checked=""/><div class="controls bullet"><span class="by">kagevf</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38344082">parent</a><span>|</span><a href="#38344069">next</a><span>|</span><label class="collapse" for="c-38344167">[-]</label><label class="expand" for="c-38344167">[1 more]</label></div><br/><div class="children"><div class="content">I use that with a custom feed; works well.</div><br/></div></div></div></div></div></div><div id="38344069" class="c"><input type="checkbox" id="c-38344069" checked=""/><div class="controls bullet"><span class="by">the_gipsy</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38341006">parent</a><span>|</span><a href="#38342543">prev</a><span>|</span><a href="#38341511">next</a><span>|</span><label class="collapse" for="c-38344069">[-]</label><label class="expand" for="c-38344069">[1 more]</label></div><br/><div class="children"><div class="content">The URLs are different, suffix instead of the typical prefix, that&#x27;s not really content negotiation.</div><br/></div></div><div id="38341511" class="c"><input type="checkbox" id="c-38341511" checked=""/><div class="controls bullet"><span class="by">djbusby</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38341006">parent</a><span>|</span><a href="#38344069">prev</a><span>|</span><a href="#38342999">next</a><span>|</span><label class="collapse" for="c-38341511">[-]</label><label class="expand" for="c-38341511">[11 more]</label></div><br/><div class="children"><div class="content">Who cares if urls are ugly?</div><br/><div id="38342318" class="c"><input type="checkbox" id="c-38342318" checked=""/><div class="controls bullet"><span class="by">DANmode</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38341511">parent</a><span>|</span><a href="#38342033">next</a><span>|</span><label class="collapse" for="c-38342318">[-]</label><label class="expand" for="c-38342318">[1 more]</label></div><br/><div class="children"><div class="content">Those navigating with a keyboard.</div><br/></div></div><div id="38342033" class="c"><input type="checkbox" id="c-38342033" checked=""/><div class="controls bullet"><span class="by">teeray</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38341511">parent</a><span>|</span><a href="#38342318">prev</a><span>|</span><a href="#38342005">next</a><span>|</span><label class="collapse" for="c-38342033">[-]</label><label class="expand" for="c-38342033">[2 more]</label></div><br/><div class="children"><div class="content">Marketing</div><br/><div id="38342299" class="c"><input type="checkbox" id="c-38342299" checked=""/><div class="controls bullet"><span class="by">bobbylarrybobby</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38342033">parent</a><span>|</span><a href="#38342005">next</a><span>|</span><label class="collapse" for="c-38342299">[-]</label><label class="expand" for="c-38342299">[1 more]</label></div><br/><div class="children"><div class="content">These are the same people who make every link in the emails they send 1kB of tracking parameters?</div><br/></div></div></div></div><div id="38342005" class="c"><input type="checkbox" id="c-38342005" checked=""/><div class="controls bullet"><span class="by">dasmith91</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38341511">parent</a><span>|</span><a href="#38342033">prev</a><span>|</span><a href="#38342999">next</a><span>|</span><label class="collapse" for="c-38342005">[-]</label><label class="expand" for="c-38342005">[7 more]</label></div><br/><div class="children"><div class="content">Front-End Developers</div><br/><div id="38342320" class="c"><input type="checkbox" id="c-38342320" checked=""/><div class="controls bullet"><span class="by">quectophoton</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38342005">parent</a><span>|</span><a href="#38342999">next</a><span>|</span><label class="collapse" for="c-38342320">[-]</label><label class="expand" for="c-38342320">[6 more]</label></div><br/><div class="children"><div class="content">Also that&#x27;s why single page applications are no longer technically single page.<p><pre><code>    https:&#x2F;&#x2F;example.com&#x2F;#!&#x2F;
    https:&#x2F;&#x2F;example.com&#x2F;#!&#x2F;about&#x2F;
    https:&#x2F;&#x2F;example.com&#x2F;#!&#x2F;users&#x2F;
</code></pre>
Are all the same page as far as the browser concerns, and if you move from `&#x2F;#!&#x2F;` to `&#x2F;#!&#x2F;users&#x2F;`, and reload the page, you still load the same page (i.e. `&#x2F;`).<p>But that was too ugly for URLs, so modern websites now use browser history APIs just so they can remove 3 characters from the URL and do stuff like:<p><pre><code>    https:&#x2F;&#x2F;example.com&#x2F;
    https:&#x2F;&#x2F;example.com&#x2F;about&#x2F;
    https:&#x2F;&#x2F;example.com&#x2F;users&#x2F;
</code></pre>
Sure, if you load `&#x2F;` and move to `&#x2F;about&#x2F;` you don&#x27;t load a new page because of browser history APIs; but if you then refresh, now you load a different, uncached page (`&#x2F;about&#x2F;`, instead of `&#x2F;`) even if the HTML in the response is exactly the same as in `&#x2F;`.<p>Sure, the difference is not much, but to me it still seems like a waste when the response could have been cached already like in the first example.</div><br/><div id="38342792" class="c"><input type="checkbox" id="c-38342792" checked=""/><div class="controls bullet"><span class="by">alex_smart</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38342320">parent</a><span>|</span><a href="#38344680">next</a><span>|</span><label class="collapse" for="c-38342792">[-]</label><label class="expand" for="c-38342792">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But that was too ugly for URLs, so modern websites now use browser history APIs just so they can remove 3 characters from the URL and do stuff like<p>Would back&#x2F;forward buttons continue to work if we decided not use browser history APIs?</div><br/><div id="38343248" class="c"><input type="checkbox" id="c-38343248" checked=""/><div class="controls bullet"><span class="by">quectophoton</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38342792">parent</a><span>|</span><a href="#38344680">next</a><span>|</span><label class="collapse" for="c-38343248">[-]</label><label class="expand" for="c-38343248">[1 more]</label></div><br/><div class="children"><div class="content">Yes, and a quick test with Mithril.js confirms it.<p>I could try with something like React, but that&#x27;s too much for a quick test.</div><br/></div></div></div></div><div id="38344680" class="c"><input type="checkbox" id="c-38344680" checked=""/><div class="controls bullet"><span class="by">cylemons</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38342320">parent</a><span>|</span><a href="#38342792">prev</a><span>|</span><a href="#38343672">next</a><span>|</span><label class="collapse" for="c-38344680">[-]</label><label class="expand" for="c-38344680">[2 more]</label></div><br/><div class="children"><div class="content">What does the ! symbol do in url fragments?</div><br/></div></div><div id="38343672" class="c"><input type="checkbox" id="c-38343672" checked=""/><div class="controls bullet"><span class="by">prewk</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38342320">parent</a><span>|</span><a href="#38344680">prev</a><span>|</span><a href="#38342999">next</a><span>|</span><label class="collapse" for="c-38343672">[-]</label><label class="expand" for="c-38343672">[1 more]</label></div><br/><div class="children"><div class="content">The first one always requests &#x2F; from the server when landed on&#x2F;refreshed. The other one does not. This fact can be acted upon.</div><br/></div></div></div></div></div></div></div></div><div id="38342999" class="c"><input type="checkbox" id="c-38342999" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38341006">parent</a><span>|</span><a href="#38341511">prev</a><span>|</span><a href="#38344913">next</a><span>|</span><label class="collapse" for="c-38342999">[-]</label><label class="expand" for="c-38342999">[2 more]</label></div><br/><div class="children"><div class="content">Shopify does that.<p>Well, at least the appending .json to everything.</div><br/><div id="38343262" class="c"><input type="checkbox" id="c-38343262" checked=""/><div class="controls bullet"><span class="by">arrowsmith</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38342999">parent</a><span>|</span><a href="#38344913">next</a><span>|</span><label class="collapse" for="c-38343262">[-]</label><label class="expand" for="c-38343262">[1 more]</label></div><br/><div class="children"><div class="content">Shopify is written in Rails, no? That&#x27;s how Rails does it.</div><br/></div></div></div></div></div></div><div id="38344913" class="c"><input type="checkbox" id="c-38344913" checked=""/><div class="controls bullet"><span class="by">mariusor</span><span>|</span><a href="#38338963">parent</a><span>|</span><a href="#38341006">prev</a><span>|</span><a href="#38341961">next</a><span>|</span><label class="collapse" for="c-38344913">[-]</label><label class="expand" for="c-38344913">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Cloudflare doesn&#x27;t obey the Accept header<p>That&#x27;s not true. They do, but you have to add it to the Vary header: <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;HTTP&#x2F;Headers&#x2F;Vary" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;HTTP&#x2F;Headers&#x2F;Va...</a><p>This way user-agents know that the Accept header is involved in the final form of the response. (As another example, Firefox also doesn&#x27;t take Accept into consideration when caching locally by default, and it does with Varry: Accept)</div><br/></div></div><div id="38341961" class="c"><input type="checkbox" id="c-38341961" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#38338963">parent</a><span>|</span><a href="#38344913">prev</a><span>|</span><a href="#38344177">next</a><span>|</span><label class="collapse" for="c-38341961">[-]</label><label class="expand" for="c-38341961">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s where Cloudflare document this: <a href="https:&#x2F;&#x2F;developers.cloudflare.com&#x2F;cache&#x2F;concepts&#x2F;cache-control&#x2F;#other" rel="nofollow noreferrer">https:&#x2F;&#x2F;developers.cloudflare.com&#x2F;cache&#x2F;concepts&#x2F;cache-contr...</a><p>&gt; vary — Cloudflare does not consider vary values in caching decisions. Nevertheless, vary values are respected when Vary for images is configured and when the vary header is vary: accept-encoding.</div><br/></div></div><div id="38344177" class="c"><input type="checkbox" id="c-38344177" checked=""/><div class="controls bullet"><span class="by">laurencerowe</span><span>|</span><a href="#38338963">parent</a><span>|</span><a href="#38341961">prev</a><span>|</span><a href="#38339022">next</a><span>|</span><label class="collapse" for="c-38344177">[-]</label><label class="expand" for="c-38344177">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m undecided about whether the Semantic Web is generally useful for not, but in certain domains it does seem to have some worth.<p>When building a public scientific database I really want the URL identifying the item in the database to return the page for that item when I enter it in a browser but to return the appropriately structured data for that item when requested with &quot;Accept: application&#x2F;ld+json&quot; or &quot;application&#x2F;rdf+xml&quot; by a linked data library.<p>So it&#x27;s unfortunate that there&#x27;s no good way to support this with common CDNs.<p>Of course I always make it so that appending &quot;?type=json&quot; or &quot;?type=xml&quot; gets you the appropriate document.</div><br/></div></div><div id="38339022" class="c"><input type="checkbox" id="c-38339022" checked=""/><div class="controls bullet"><span class="by">ForkMeOnTinder</span><span>|</span><a href="#38338963">parent</a><span>|</span><a href="#38344177">prev</a><span>|</span><a href="#38339346">next</a><span>|</span><label class="collapse" for="c-38339022">[-]</label><label class="expand" for="c-38339022">[10 more]</label></div><br/><div class="children"><div class="content">That&#x27;s even with the proper Vary header, right? Seems like a cloudflare bug if that&#x27;s true. Maybe even a security bug if you find a service that supports text&#x2F;plain.</div><br/><div id="38339818" class="c"><input type="checkbox" id="c-38339818" checked=""/><div class="controls bullet"><span class="by">zoogeny</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38339022">parent</a><span>|</span><a href="#38339346">next</a><span>|</span><label class="collapse" for="c-38339818">[-]</label><label class="expand" for="c-38339818">[9 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t dealt with Cloudflare specifically, but I did deal with a number of big CDNs for large amounts of traffic. They were pretty adamant about NOT supporting arbitrary Vary header values. It broke some logic on a few of our systems and we eventually just decided to work around it instead of pushing our case.<p>Interestingly, one of the big CDN providers did have controls in their UI for explicitly allowing&#x2F;disallowing Vary header entries but they disabled it for us at some point (e.g. it was still in the UI but greyed out). I assumed once we hit a certain level of traffic it was too computationally expensive? Ever since, I&#x27;ve avoided any kind of fancy header&#x2F;response variance in APIs just in case I end up in the same situation. It is rarely a necessity. IIRC, the only thing they continued to support variance wise was gzip (e.g. content-encoding).<p>It&#x27;s also worth noting they were <i>extremely</i> conservative with query parameters too. Also to reiterate, this was very high traffic and high volume with expectations of low latency, so probably not applicable to most people using CDNs for static website assets.</div><br/><div id="38340101" class="c"><input type="checkbox" id="c-38340101" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38339818">parent</a><span>|</span><a href="#38342149">next</a><span>|</span><label class="collapse" for="c-38340101">[-]</label><label class="expand" for="c-38340101">[7 more]</label></div><br/><div class="children"><div class="content">&gt; I assumed once we hit a certain level of traffic it was too computationally expensive?<p>Seems strange; AFAIK in e.g. Varnish, Vary just means you get more &quot;stuff&quot; tacked onto the buffer that gets built from the request and then hashed to create the cache key.<p>And actually, come to think of it, if memory for N concurrent in-flight requests is the concern, then you don&#x27;t even need an actual (dynamically allocated) buffer, either; presuming you&#x27;re using a streaming hash, you can feed each constituent field directly into the hasher, with only the hasher&#x27;s (probably stack-allocated) internal static buffer for blockwise hashing required. (Which you&#x27;re gonna need regardless of whether you&#x27;re doing any Vary-ing.)<p>So it&#x27;s really just a question of how many CPU cycles are being spent hashing. And it&#x27;s likely just going to be a difference between hashing 300 bytes (base request — hostname, path, headers that are always implicitly Varied upon) and 350 bytes (those things, plus whatever you explicitly Varied) per request. Doesn&#x27;t <i>seem</i> like too much of a win... (especially when hardware-accelerated hashing ops operate on blocks anyway, such that you only get stepwise cost increases for every e.g. 128 bytes.) I wonder why they bothered?</div><br/><div id="38341419" class="c"><input type="checkbox" id="c-38341419" checked=""/><div class="controls bullet"><span class="by">johncolanduoni</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38340101">parent</a><span>|</span><a href="#38340258">next</a><span>|</span><label class="collapse" for="c-38341419">[-]</label><label class="expand" for="c-38341419">[2 more]</label></div><br/><div class="children"><div class="content">Respecting vary headers is not this simple. Given a request, how do you calculate a cache key that includes only the Vary headers? You only get that list in actual responses from the server, so you need to actually look at some information derived from previous responses to determine what to hash on each request. This is called &quot;partial match retrieval&quot;, and is much more complicated (and computationally intensive) than cases where you can calculate a hash key as a pure function of the request.</div><br/><div id="38341759" class="c"><input type="checkbox" id="c-38341759" checked=""/><div class="controls bullet"><span class="by">zoogeny</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38341419">parent</a><span>|</span><a href="#38340258">next</a><span>|</span><label class="collapse" for="c-38341759">[-]</label><label class="expand" for="c-38341759">[1 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t something I considered but it totally makes sense. Given that the Vary header is a per-resource value you would have to propagate that through the network. For millions of resources that might become an issue. And since in a worse-case scenario the server could be changing the Vary header for a single resource across multiple requests you have the additional problem of trying to keep it consistent across datacenters.<p>I think that is probably why some CDNs have a single configuration for any HTTP headers you want to vary on (e.g. Cloudfront allows you to specify a global configuration for a distribution that takes into account specific headers). This avoids the problem of both per-resource and inter-datacenter consistency that relying on the Vary header might cause.</div><br/></div></div></div></div><div id="38340258" class="c"><input type="checkbox" id="c-38340258" checked=""/><div class="controls bullet"><span class="by">zoogeny</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38340101">parent</a><span>|</span><a href="#38341419">prev</a><span>|</span><a href="#38341041">next</a><span>|</span><label class="collapse" for="c-38340258">[-]</label><label class="expand" for="c-38340258">[1 more]</label></div><br/><div class="children"><div class="content">To be clear, I&#x27;m not trying to make their argument for them since we spent probably 1 day working around it. I&#x27;m just passing along an anecdote. One day, Vary header stopped working on one CDN and we had to fix it. When I spoke to our account rep (I literally had a weekly call with them due to our usage) he said they were phasing it out for performance reasons. Not long after we got notice from another CDN asking for similar consideration. I have no inside knowledge as to their infrastructure or systems that made this a requirement. I very much doubt it was the cost to <i>hash</i>, maybe more likely something to do with their network topology and how requests were routed from origin to regional tiers to PoPs? I&#x27;m totally speculating here.<p>If this had been a <i>necessity</i> then I would have probably dug into the request more deeply. It was a &quot;pick your battles&quot; kind of thing. Extremely low cost on our side to change, no reason to bother if they claimed it would decrease problems on their side.</div><br/></div></div><div id="38341041" class="c"><input type="checkbox" id="c-38341041" checked=""/><div class="controls bullet"><span class="by">phanimahesh</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38340101">parent</a><span>|</span><a href="#38340258">prev</a><span>|</span><a href="#38340343">next</a><span>|</span><label class="collapse" for="c-38341041">[-]</label><label class="expand" for="c-38341041">[2 more]</label></div><br/><div class="children"><div class="content">The cost of vary headers is usually not in hashing the keys but storing multiple entries per url in an arbitrarily large combination of headers. I can imagine cdns not wanting the hassle, though I don&#x27;t live the outcome.</div><br/><div id="38341832" class="c"><input type="checkbox" id="c-38341832" checked=""/><div class="controls bullet"><span class="by">zoogeny</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38341041">parent</a><span>|</span><a href="#38340343">next</a><span>|</span><label class="collapse" for="c-38341832">[-]</label><label class="expand" for="c-38341832">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s worth noting that the cost of storage wasn&#x27;t the issue in this case. They already had a system that allowed you to determine which headers in the Vary list would be respected and so you could calculate a worst-case storage load. I mean, it definitely was an issue <i>in general</i> and we were careful about avoiding the same content being stored multiple times but it wasn&#x27;t the reasoning they communicated behind the change in the anecdote I related.<p>I think the best suggestion was in another thread by @johncolanduoni where he pointed out the difficulty of storing, distributing and retrieving the metadata per-resource that would be necessary for each PoP to correctly determine the Vary requirements at request time.</div><br/></div></div></div></div></div></div><div id="38342149" class="c"><input type="checkbox" id="c-38342149" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38339818">parent</a><span>|</span><a href="#38340101">prev</a><span>|</span><a href="#38339346">next</a><span>|</span><label class="collapse" for="c-38342149">[-]</label><label class="expand" for="c-38342149">[1 more]</label></div><br/><div class="children"><div class="content">The problem with Vary is that it massively expands footprints and reduces cache efficiency when overused. In a CDN this can create noisy neighbor like issues.</div><br/></div></div></div></div></div></div><div id="38339346" class="c"><input type="checkbox" id="c-38339346" checked=""/><div class="controls bullet"><span class="by">judge2020</span><span>|</span><a href="#38338963">parent</a><span>|</span><a href="#38339022">prev</a><span>|</span><a href="#38341553">next</a><span>|</span><label class="collapse" for="c-38339346">[-]</label><label class="expand" for="c-38339346">[2 more]</label></div><br/><div class="children"><div class="content">I think you mean for CDN-cached content, right?<p>The accept header is passed along, so your server can respond however it wants for dynamic content&#x2F;not cached by CDN.</div><br/><div id="38340743" class="c"><input type="checkbox" id="c-38340743" checked=""/><div class="controls bullet"><span class="by">acdha</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38339346">parent</a><span>|</span><a href="#38341553">next</a><span>|</span><label class="collapse" for="c-38340743">[-]</label><label class="expand" for="c-38340743">[1 more]</label></div><br/><div class="children"><div class="content">Yes - this can be a big problem if it means that users get a cached response which isn’t compatible with their browser. It can also mean that you lose cache efficiency if you don’t get a ton of traffic - one site I worked on would’ve gotten much slower if they used WebP because it would have increased your odds of not getting a CDN-cached response, and the ~10-15% byte size savings just wasn’t worth that.</div><br/></div></div></div></div><div id="38341553" class="c"><input type="checkbox" id="c-38341553" checked=""/><div class="controls bullet"><span class="by">4death4</span><span>|</span><a href="#38338963">parent</a><span>|</span><a href="#38339346">prev</a><span>|</span><a href="#38341027">next</a><span>|</span><label class="collapse" for="c-38341553">[-]</label><label class="expand" for="c-38341553">[2 more]</label></div><br/><div class="children"><div class="content">This sounds like a misconfiguration. I haven&#x27;t used Cloudflare, but I&#x27;ve used other CDNs, and they need to generate a cache key with as few header values as possible to maximize the cache hit rate. The headers used in generating the cache key is configurable, so if you want to use the accept header in your application, then you&#x27;re free to do so, but you need to tell Cloudflare that&#x27;s an important part of your application.</div><br/><div id="38341939" class="c"><input type="checkbox" id="c-38341939" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38341553">parent</a><span>|</span><a href="#38341027">next</a><span>|</span><label class="collapse" for="c-38341939">[-]</label><label class="expand" for="c-38341939">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the problem: they don&#x27;t respect the Vary header for HTML or JSON documents, just for images.<p>It&#x27;s a documented decision that they&#x27;ve made: <a href="https:&#x2F;&#x2F;developers.cloudflare.com&#x2F;cache&#x2F;concepts&#x2F;cache-control&#x2F;#other" rel="nofollow noreferrer">https:&#x2F;&#x2F;developers.cloudflare.com&#x2F;cache&#x2F;concepts&#x2F;cache-contr...</a></div><br/></div></div></div></div><div id="38341027" class="c"><input type="checkbox" id="c-38341027" checked=""/><div class="controls bullet"><span class="by">VWWHFSfQ</span><span>|</span><a href="#38338963">parent</a><span>|</span><a href="#38341553">prev</a><span>|</span><a href="#38339191">next</a><span>|</span><label class="collapse" for="c-38341027">[-]</label><label class="expand" for="c-38341027">[2 more]</label></div><br/><div class="children"><div class="content">Are you certain that it is actually not supported?  I suspect the CDN cache was not configured to vary cached responses via the Vary header.  That header will usually at minimum look like:<p>Vary: Cookie, Authorization, Accept, Accept-Language</div><br/><div id="38342525" class="c"><input type="checkbox" id="c-38342525" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38341027">parent</a><span>|</span><a href="#38339191">next</a><span>|</span><label class="collapse" for="c-38342525">[-]</label><label class="expand" for="c-38342525">[1 more]</label></div><br/><div class="children"><div class="content">I mistyped: it&#x27;s that Vary header that Cloudflare doesn&#x27;t support (for non-image resources) - see <a href="https:&#x2F;&#x2F;developers.cloudflare.com&#x2F;cache&#x2F;concepts&#x2F;cache-control&#x2F;#other" rel="nofollow noreferrer">https:&#x2F;&#x2F;developers.cloudflare.com&#x2F;cache&#x2F;concepts&#x2F;cache-contr...</a></div><br/></div></div></div></div><div id="38339191" class="c"><input type="checkbox" id="c-38339191" checked=""/><div class="controls bullet"><span class="by">shawn-butler</span><span>|</span><a href="#38338963">parent</a><span>|</span><a href="#38341027">prev</a><span>|</span><a href="#38340987">next</a><span>|</span><label class="collapse" for="c-38339191">[-]</label><label class="expand" for="c-38339191">[7 more]</label></div><br/><div class="children"><div class="content">Serious problem if true</div><br/><div id="38340278" class="c"><input type="checkbox" id="c-38340278" checked=""/><div class="controls bullet"><span class="by">Gigachad</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38339191">parent</a><span>|</span><a href="#38340987">next</a><span>|</span><label class="collapse" for="c-38340278">[-]</label><label class="expand" for="c-38340278">[6 more]</label></div><br/><div class="children"><div class="content">Meh. Too many ways to solve the same problem results in bugs and security issues. There is no case where you need to use the Accepts header, you can just put that info in the URL instead.<p>Some effort to clean up the useless and duplicate features would be good.</div><br/><div id="38340974" class="c"><input type="checkbox" id="c-38340974" checked=""/><div class="controls bullet"><span class="by">stephenr</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38340278">parent</a><span>|</span><a href="#38340987">next</a><span>|</span><label class="collapse" for="c-38340974">[-]</label><label class="expand" for="c-38340974">[5 more]</label></div><br/><div class="children"><div class="content">How exactly do you specify weighted preferences for several possible types, in the url, in a way that is standardised?</div><br/><div id="38344338" class="c"><input type="checkbox" id="c-38344338" checked=""/><div class="controls bullet"><span class="by">Gigachad</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38340974">parent</a><span>|</span><a href="#38341877">next</a><span>|</span><label class="collapse" for="c-38344338">[-]</label><label class="expand" for="c-38344338">[1 more]</label></div><br/><div class="children"><div class="content">The only time you&#x27;d ever want to do this is for image and video formats. And HTML has built in support for this in the picture and video tags. Otherwise this sounds nonsensical.<p>What kind of situation would you ever have a request like &quot;Uh I want json the most but XML could work&quot;. Either the backend serves it in a format or not, just directly request what you want.</div><br/></div></div><div id="38341877" class="c"><input type="checkbox" id="c-38341877" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38340974">parent</a><span>|</span><a href="#38344338">prev</a><span>|</span><a href="#38340987">next</a><span>|</span><label class="collapse" for="c-38341877">[-]</label><label class="expand" for="c-38341877">[3 more]</label></div><br/><div class="children"><div class="content">Other than for images and video, when in practice do you <i>want</i> to do that?<p>If you&#x27;re talking to an API, you should know what that API can produce.<p>And if you&#x27;re talking to a webpage, this isn&#x27;t an issue.</div><br/><div id="38342777" class="c"><input type="checkbox" id="c-38342777" checked=""/><div class="controls bullet"><span class="by">stephenr</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38341877">parent</a><span>|</span><a href="#38340987">next</a><span>|</span><label class="collapse" for="c-38342777">[-]</label><label class="expand" for="c-38342777">[2 more]</label></div><br/><div class="children"><div class="content">&gt; when in practice do you want to do that?<p>Well as you&#x27;re quite interested in APIs: the accept header is a fantastic way to <i>version</i> a REST API, and even has a built in way to handle clients that can talk to multiple versions of the same API.<p>Your app <i>could</i> request just &#x27;application&#x2F;vnd.foo.v1+json&#x27; from an API and if it&#x27;s a centralised service that may be fine.<p>If the API your app talks to is something that&#x27;s deployed to customers, or rolls out to regions incrementally or whatever, and thus can be at different versions, you need a way to handle that: the Accept header has you covered.</div><br/><div id="38344368" class="c"><input type="checkbox" id="c-38344368" checked=""/><div class="controls bullet"><span class="by">Gigachad</span><span>|</span><a href="#38338963">root</a><span>|</span><a href="#38342777">parent</a><span>|</span><a href="#38340987">next</a><span>|</span><label class="collapse" for="c-38344368">[-]</label><label class="expand" for="c-38344368">[1 more]</label></div><br/><div class="children"><div class="content">Everyone does this by putting &#x2F;v1&#x2F; in the api url. It&#x27;s massively more visible, gets logged properly, and isn&#x27;t annoying to request from tools like curl.<p>The Accept header does nothing that URLs can not.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="38340987" class="c"><input type="checkbox" id="c-38340987" checked=""/><div class="controls bullet"><span class="by">briHass</span><span>|</span><a href="#38338963">prev</a><span>|</span><a href="#38344925">next</a><span>|</span><label class="collapse" for="c-38340987">[-]</label><label class="expand" for="c-38340987">[2 more]</label></div><br/><div class="children"><div class="content">I agree with the underlying point being made here: a separate API (REST&#x2F;JSON) that serves data should be kept separate from the endpoints that serve an application, in this case, HTML-based.<p>It seems like building your application around a single API that is also used to provide data externally saves you time, but you end up polluting that API with presentation concerns needed to drive the application&#x27;s reports&#x2F;grids&#x2F;views. It&#x27;s not worth the mental energy to consider how changes you need to make for presentation might affect the &#x27;purity&#x27; of your public API. Returning hypermedia from the &#x27;internal&#x27; API just forces that separation: there&#x27;s no expectation that this &#x27;data&#x27; is being returned for consumption by anything except the app that uses it.</div><br/><div id="38343530" class="c"><input type="checkbox" id="c-38343530" checked=""/><div class="controls bullet"><span class="by">twelfthnight</span><span>|</span><a href="#38340987">parent</a><span>|</span><a href="#38344925">next</a><span>|</span><label class="collapse" for="c-38343530">[-]</label><label class="expand" for="c-38343530">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a really good point. It&#x27;s natural, but if an API is primarily used to serve a front end, all other internal consumers (analyst, data science, etc) take a back seat.  I think it also leads to situations where most of the engineers on the team don&#x27;t really understand the &quot;natural&quot; data domains, but always think about it in a front end lens (e.g. pagination, merging of different concepts because they are on the same UI element, very quick endpoints only, JSON instead of less web friendly serializations, etc)</div><br/></div></div></div></div><div id="38344925" class="c"><input type="checkbox" id="c-38344925" checked=""/><div class="controls bullet"><span class="by">liampulles</span><span>|</span><a href="#38340987">prev</a><span>|</span><a href="#38338898">next</a><span>|</span><label class="collapse" for="c-38344925">[-]</label><label class="expand" for="c-38344925">[1 more]</label></div><br/><div class="children"><div class="content">At a very basic level, isn&#x27;t it just confusing to have the same URL and method return two different completely different formats?<p>I feel like a good API is limited in what it accepts, and this alone is enough to say one should not do content negotiation unless forced to.</div><br/></div></div><div id="38338898" class="c"><input type="checkbox" id="c-38338898" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#38344925">prev</a><span>|</span><a href="#38338731">next</a><span>|</span><label class="collapse" for="c-38338898">[-]</label><label class="expand" for="c-38338898">[6 more]</label></div><br/><div class="children"><div class="content">I think content negotiation is great when your usecase supports it, like asking for XML or JSON. Also the mappings of content types should be well defined for all to see and edit. Rails is kinda a labyrinth in that regard.<p>I do tend to prefer actual file extensions though. Friendlier for humans (curl <a href="https:&#x2F;&#x2F;endpoint&#x2F;item.json" rel="nofollow noreferrer">https:&#x2F;&#x2F;endpoint&#x2F;item.json</a> vs curl -H &quot;accept: application&#x2F;json&quot; <a href="https:&#x2F;&#x2F;endpoint&#x2F;item" rel="nofollow noreferrer">https:&#x2F;&#x2F;endpoint&#x2F;item</a>), and it is visible in logging infrastructure, sharable, etc.</div><br/><div id="38344954" class="c"><input type="checkbox" id="c-38344954" checked=""/><div class="controls bullet"><span class="by">IanCal</span><span>|</span><a href="#38338898">parent</a><span>|</span><a href="#38339021">next</a><span>|</span><label class="collapse" for="c-38344954">[-]</label><label class="expand" for="c-38344954">[1 more]</label></div><br/><div class="children"><div class="content">Something nice about accept headers is you can have your own formats, and include versioning information. That means I can have a consumer specify it can process V2 and V3 formats of the API, and when the API is upgraded or downgraded around a release everything works smoothly. Your API <i>can</i> serve both but it doesn&#x27;t have to - it can be easier to have clients support two versions than support long running parallel API versions.<p>I sometimes prefer file extensions, but then consuming code can often get filled with appending or removing or changing formats.<p>Broadly, I like content negotiation as a concept because it describes what you actually want and is much more typed (as far as it can be). Adding file extensions feels very stringly typed processing.<p>Both have problems, you pick your poison and look wistfully at the greener grass on the other side.</div><br/></div></div><div id="38339021" class="c"><input type="checkbox" id="c-38339021" checked=""/><div class="controls bullet"><span class="by">qwertox</span><span>|</span><a href="#38338898">parent</a><span>|</span><a href="#38344954">prev</a><span>|</span><a href="#38340542">next</a><span>|</span><label class="collapse" for="c-38339021">[-]</label><label class="expand" for="c-38339021">[2 more]</label></div><br/><div class="children"><div class="content">For me it has always been a part of the query parameter<p><a href="http:&#x2F;&#x2F;endpoint&#x2F;item?format=json" rel="nofollow noreferrer">http:&#x2F;&#x2F;endpoint&#x2F;item?format=json</a> or ?type=json<p>I never ever had a problem with that. The only reason to use a file extension would be if the request would take no query parameters.<p>It would never occur to me to use header information for this.</div><br/><div id="38343996" class="c"><input type="checkbox" id="c-38343996" checked=""/><div class="controls bullet"><span class="by">dgb23</span><span>|</span><a href="#38338898">root</a><span>|</span><a href="#38339021">parent</a><span>|</span><a href="#38340542">next</a><span>|</span><label class="collapse" for="c-38343996">[-]</label><label class="expand" for="c-38343996">[1 more]</label></div><br/><div class="children"><div class="content">Both file extensions and query parameters are functionally very similar.<p>What I don’t necessarily like about query params for this, is that their usage implies filtering. It’s a cultural assumption but it’s there.<p>Another point: you might actually have a literal file at a similar path that you serve, typically when you cache responses (managed cache or straight from your app server). Using file extensions gives you a bit more natural affordances. It’s just overal less clunky.</div><br/></div></div></div></div><div id="38340542" class="c"><input type="checkbox" id="c-38340542" checked=""/><div class="controls bullet"><span class="by">FullstakBlogger</span><span>|</span><a href="#38338898">parent</a><span>|</span><a href="#38339021">prev</a><span>|</span><a href="#38338731">next</a><span>|</span><label class="collapse" for="c-38340542">[-]</label><label class="expand" for="c-38340542">[2 more]</label></div><br/><div class="children"><div class="content">Content negotiation is &quot;friendlier to humans&quot; in the sense that you can serve the right content to different clients using the same URL, transparent to the user. If the URL itself is never meant to be shared by the user, then I don&#x27;t see the point.<p>Say, an RSS feed being served as a formatted and styled page to a browser, or a client that accepts the usual XML.</div><br/><div id="38340737" class="c"><input type="checkbox" id="c-38340737" checked=""/><div class="controls bullet"><span class="by">None4U</span><span>|</span><a href="#38338898">root</a><span>|</span><a href="#38340542">parent</a><span>|</span><a href="#38338731">next</a><span>|</span><label class="collapse" for="c-38340737">[-]</label><label class="expand" for="c-38340737">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what XSLT is for though, the display layer should be your browser</div><br/></div></div></div></div></div></div><div id="38338731" class="c"><input type="checkbox" id="c-38338731" checked=""/><div class="controls bullet"><span class="by">esjeon</span><span>|</span><a href="#38338898">prev</a><span>|</span><a href="#38338408">next</a><span>|</span><label class="collapse" for="c-38338731">[-]</label><label class="expand" for="c-38338731">[1 more]</label></div><br/><div class="children"><div class="content">So, this is actually about: Why I Tend Not To Use Content Negotiation (to serve both HTML and JSON data from the same endpoints).<p>The author also suggests:<p>&gt; The alternative is to ... splitting your APIs. This means providing different paths (or sub-domains, or whatever) for your JSON API and your hypermedia (HTML) API.<p>I believe the alternative has been the norm actually. For example, many front-end frameworks encode UI states in URL, and it&#x27;s not so sustainable to keep the alignment b&#x2F;w UI states and data APIs in the long term.</div><br/></div></div><div id="38338408" class="c"><input type="checkbox" id="c-38338408" checked=""/><div class="controls bullet"><span class="by">xyzzy_plugh</span><span>|</span><a href="#38338731">prev</a><span>|</span><a href="#38343872">next</a><span>|</span><label class="collapse" for="c-38338408">[-]</label><label class="expand" for="c-38338408">[1 more]</label></div><br/><div class="children"><div class="content">Content negotiation is surely a fire composed of tires but there are sadly many scenarios where it is necessary. Deciding whether to redirect for example is often context sensitive.<p>In other words content negotiation is useful to be able to respond intelligibly. If a client asks you for json but not html, it might not make sense to return html.</div><br/></div></div><div id="38343872" class="c"><input type="checkbox" id="c-38343872" checked=""/><div class="controls bullet"><span class="by">HdS84</span><span>|</span><a href="#38338408">prev</a><span>|</span><a href="#38342213">next</a><span>|</span><label class="collapse" for="c-38343872">[-]</label><label class="expand" for="c-38343872">[1 more]</label></div><br/><div class="children"><div class="content">Content negotiation is useful when there are multiple feasible return formats. But when is that the case?<p>For data, Json is the absolute king. For content, html is king. There is very little to negotiate.<p>The only case where I needed that feature was when data scientists wanted to download data from my API and needed a bunch of formats (parquet, CSV, TSV). But then they did not really grok content negotiation and asked for a query param. So finally I think this is like a lot of html features: half baked and from a different time. Html would do well to drop it.</div><br/></div></div><div id="38342213" class="c"><input type="checkbox" id="c-38342213" checked=""/><div class="controls bullet"><span class="by">agentultra</span><span>|</span><a href="#38343872">prev</a><span>|</span><a href="#38341609">next</a><span>|</span><label class="collapse" for="c-38342213">[-]</label><label class="expand" for="c-38342213">[1 more]</label></div><br/><div class="children"><div class="content">Split it out but keep using the same models. Wouldn’t want your entities and semantics to drift apart between your UI and API.<p>Personally I prefer sticking to the standards. At least that way when you move between projects you know what you’re getting into.<p>But everyone has their own conventions these days. It’s all fragmenting.</div><br/></div></div><div id="38341609" class="c"><input type="checkbox" id="c-38341609" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#38342213">prev</a><span>|</span><a href="#38338618">next</a><span>|</span><label class="collapse" for="c-38341609">[-]</label><label class="expand" for="c-38341609">[2 more]</label></div><br/><div class="children"><div class="content">I get this on one level but wow can you tell the difference between when a team uses the API they offer users and when they don’t, and the “single API” approach gets you there so well.<p>I have basically never seen a nice user-facing API when it’s been split out. Sometimes that’s fine, but at least for enterprise use cases having a “real” API just feels like table stakes in so many domains for getting bigger clients onboard.</div><br/><div id="38343509" class="c"><input type="checkbox" id="c-38343509" checked=""/><div class="controls bullet"><span class="by">8n4vidtmkvmk</span><span>|</span><a href="#38341609">parent</a><span>|</span><a href="#38338618">next</a><span>|</span><label class="collapse" for="c-38343509">[-]</label><label class="expand" for="c-38343509">[1 more]</label></div><br/><div class="children"><div class="content">I thought I knew what the author meant until I got to the end. I could be that they&#x27;re referring to HTML as one API, and JSON-RPC as the other API.<p>Originally I thought they meant 2 JSON APIs. One that&#x27;s tightly coupled with the HTML to handle all the &quot;ajax&quot; requests, and the other for 3rd parties to fetch arbitrary bits of data.<p>Otherwise, I know what you mean. My company has our internal RPCs and then our customer-facing API and the customer one hasn&#x27;t been updated in ages and it&#x27;s just a thin layer over some old internal RPCs we used to have and now we have to maintain backwards compatibility but keep breaking it anyway.</div><br/></div></div></div></div><div id="38338618" class="c"><input type="checkbox" id="c-38338618" checked=""/><div class="controls bullet"><span class="by">afandian</span><span>|</span><a href="#38341609">prev</a><span>|</span><a href="#38344143">next</a><span>|</span><label class="collapse" for="c-38338618">[-]</label><label class="expand" for="c-38338618">[4 more]</label></div><br/><div class="children"><div class="content">Tangential, but the lack of a &quot;these types are available&quot; as the counterpart to &quot;Accept&quot; has always been so obviously missing. What&#x27;s the point of Accept if you don&#x27;t know what to ask for?<p>Maybe in the trivial case saying &quot;I&#x27;d prefer a JPG to a PNG&quot; can be an assymetrical choice. But in all the interesting use cases I can think of, e.g. where there are competing representation formats, you&#x27;d want the server to be able to respond to a HEAD with the choices.<p>That&#x27;s the kind of thing you can put in Swagger, but that might lead to hoisting the client&#x27;s choice into the API, away from Content Negotiation.</div><br/><div id="38339114" class="c"><input type="checkbox" id="c-38339114" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#38338618">parent</a><span>|</span><a href="#38340869">next</a><span>|</span><label class="collapse" for="c-38339114">[-]</label><label class="expand" for="c-38339114">[1 more]</label></div><br/><div class="children"><div class="content">The OPTIONS response already describes which methods are available for an endpoint in the Allow header. Including a list of available types in a new header would be a pretty natural extension. (Content-Type isn&#x27;t available because it&#x27;s defined to only contain a single media type.)</div><br/></div></div><div id="38340869" class="c"><input type="checkbox" id="c-38340869" checked=""/><div class="controls bullet"><span class="by">stephenr</span><span>|</span><a href="#38338618">parent</a><span>|</span><a href="#38339114">prev</a><span>|</span><a href="#38338658">next</a><span>|</span><label class="collapse" for="c-38340869">[-]</label><label class="expand" for="c-38340869">[1 more]</label></div><br/><div class="children"><div class="content">Why?<p>The whole point of content negotiation is the client tells the server which type<i>s</i> it wants the content in, with weights to determine preference;<p>The server then works out the best match for what&#x27;s requested.<p>Why do you need to ask about what&#x27;s available? Just ask for it if you support it, and then handle the response based on its type.</div><br/></div></div></div></div><div id="38344143" class="c"><input type="checkbox" id="c-38344143" checked=""/><div class="controls bullet"><span class="by">3cats-in-a-coat</span><span>|</span><a href="#38338618">prev</a><span>|</span><a href="#38338661">next</a><span>|</span><label class="collapse" for="c-38344143">[-]</label><label class="expand" for="c-38344143">[2 more]</label></div><br/><div class="children"><div class="content">Carson Gross&#x27; main thesis is this: &quot;I am advocating tightly coupling your web application to your hypermedia API&quot;. In other words &quot;have an API that returns HTML snippets tightly coupled to your website.&quot;<p>It&#x27;s ironic he wrote an article about how the industry uses the term &quot;REST API&quot; incorrectly, because he himself keeps using the term &quot;API&quot; incorrectly. If an &quot;API&quot; is tightly coupled to a single application, it&#x27;s not an &quot;Application Programming Interface&quot;... it&#x27;s just a part of your application.<p>An API is supposed to be an interface on top of which <i>multiple</i> applications may rest. Particularly without a specific frontend in mind - so web, desktop app, mobile app, as a component of other services and so on. Obviously if it serves site-specific HTML snippets, that&#x27;s not the case. The only reason he advocates this whole thing is because without it HTMX won&#x27;t work, and in this way I find it quite myopic as a position. But if I was pushing HTMX I&#x27;d also be compelled to figure out reasons to make it sound good.<p>So from that PoV, talking about &quot;Content Negotiation in HTML APIs&quot; loses meaning, as what he has is not an API in the first place, it&#x27;s just his HTML website, but with some partial requests in the mix. And <i>of course</i> you wouldn&#x27;t mix your API and your site. But this <i>does not</i> imply you can&#x27;t and shouldn&#x27;t use Content Negotiation either on your site, or in your API. You simply shouldn&#x27;t use them to mix two things that never made sense to mix.<p>A lot of his blog posts would become completely unnecessary if he just says &quot;don&#x27;t mix your website and your API, and the HTMX partial requests are part of your website, not your API&quot;. Alas he&#x27;s stuck on this odd formulation of &quot;hypermedia API&quot; and constantly having to clarify himself and making things as clear as mud.</div><br/><div id="38344875" class="c"><input type="checkbox" id="c-38344875" checked=""/><div class="controls bullet"><span class="by">dgb23</span><span>|</span><a href="#38344143">parent</a><span>|</span><a href="#38338661">next</a><span>|</span><label class="collapse" for="c-38344875">[-]</label><label class="expand" for="c-38344875">[1 more]</label></div><br/><div class="children"><div class="content">I think your definition of API is very useful, but API is the wrong term. It’s much more general than that and is used in contexts where these constraints don’t even make sense.<p>Specifically a hypermedia API is something browsers (and the implicit backbone of the internet) understand very well. In fact you have to go out of your way to serve an application that your browser doesn’t inherently understand.<p>The clarity that seems to be lacking here is not necessarily a fault of the author. We re-purposed some of these terms (REST, API etc.) to serve specific needs. But then kind of lost the understanding of what we had before.<p>I think that’s not our fault though. Standardization didn’t move fast enough and the quality we needed in the mobile context wasn’t there.</div><br/></div></div></div></div><div id="38338644" class="c"><input type="checkbox" id="c-38338644" checked=""/><div class="controls bullet"><span class="by">mberning</span><span>|</span><a href="#38338661">prev</a><span>|</span><a href="#38339966">next</a><span>|</span><label class="collapse" for="c-38338644">[-]</label><label class="expand" for="c-38338644">[15 more]</label></div><br/><div class="children"><div class="content">A technology like htmx seems to demand a “hypermedia” API. Whereas things like angular and react can consume a data API in many cases. However once an application becomes sufficiently complex people end up building data APIs just to suit their frontend framework. And in that case doing htmx and returning html seems nicer.</div><br/><div id="38338687" class="c"><input type="checkbox" id="c-38338687" checked=""/><div class="controls bullet"><span class="by">simonbarker87</span><span>|</span><a href="#38338644">parent</a><span>|</span><a href="#38338709">next</a><span>|</span><label class="collapse" for="c-38338687">[-]</label><label class="expand" for="c-38338687">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been building an app with HTMX over the past 6 months and this is the reason I am loving it. I don&#x27;t even feel the backend&#x2F;frontend interface, so rather than feeling like I am making the app twice (once in backend and again in the frontend to consume it) I am just making it once, there is no frontend, it&#x27;s just all my app.</div><br/><div id="38340988" class="c"><input type="checkbox" id="c-38340988" checked=""/><div class="controls bullet"><span class="by">joshmanders</span><span>|</span><a href="#38338644">root</a><span>|</span><a href="#38338687">parent</a><span>|</span><a href="#38338709">next</a><span>|</span><label class="collapse" for="c-38340988">[-]</label><label class="expand" for="c-38340988">[1 more]</label></div><br/><div class="children"><div class="content">Yep, same here. Now I think my actual API is better and less cumbersome because I&#x27;m not trying to fit my own UI needs into a general purpose JSON API meant to be consumed by 3rd party clients who want to do things on my app.</div><br/></div></div></div></div><div id="38338709" class="c"><input type="checkbox" id="c-38338709" checked=""/><div class="controls bullet"><span class="by">candiddevmike</span><span>|</span><a href="#38338644">parent</a><span>|</span><a href="#38338687">prev</a><span>|</span><a href="#38339966">next</a><span>|</span><label class="collapse" for="c-38338709">[-]</label><label class="expand" for="c-38338709">[12 more]</label></div><br/><div class="children"><div class="content">Seems like a ton of added complexity to avoid using JavaScript&#x2F;a fat client</div><br/><div id="38339034" class="c"><input type="checkbox" id="c-38339034" checked=""/><div class="controls bullet"><span class="by">Arch-TK</span><span>|</span><a href="#38338644">root</a><span>|</span><a href="#38338709">parent</a><span>|</span><a href="#38339964">next</a><span>|</span><label class="collapse" for="c-38339034">[-]</label><label class="expand" for="c-38339034">[4 more]</label></div><br/><div class="children"><div class="content">Doing htmx is just as simple as doing server side rendering. Yes you still have a javascript dependency but that&#x27;s a lot simpler than a client side javascript framework for pulling data out of a data API and rendering it client side.<p>I don&#x27;t think anyone&#x27;s complaint about server side rendering has ever been that it was too complex.</div><br/><div id="38341683" class="c"><input type="checkbox" id="c-38341683" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#38338644">root</a><span>|</span><a href="#38339034">parent</a><span>|</span><a href="#38339964">next</a><span>|</span><label class="collapse" for="c-38341683">[-]</label><label class="expand" for="c-38341683">[3 more]</label></div><br/><div class="children"><div class="content">The core thing is a lot of nice UX patterns are harder with server side rendering. Multi-page forms? Now you’re juggling around state. “Form has N rows”? Now that’s a thing. “Form has N heterogenous rows” is another thing.<p>Then you get into things like how no server side rendering strategy has the equivalent to React “just write an inline helper function for this page”, so you need to create partials in files all over. And what if you’d like to statically verify that your templates have all the content in place? Proper typing? Who hasn’t had a page fall over because there was some missing context variable 3 layers deep.<p>The thing with the API based flow and client side rendering (with React at least) when you have it set up nicely is “add a list view with pagination and search with a modal to create a resource if needed, and some inline editing” can be done by opening a single file and getting there with 2 dozen lines. Server side rendering strategies in practice tend to buckle a bit if you try to be modular enough, and in many cases you need to open one file per checklist on your project. Code locality issues are real IMO<p>Disclaimer: I’ve done both, messing around with HTMX on a project and think it’s pretty cool. But it’s mainly because I don’t have all of the nice patterns from work projects that I’m tying this. If startup costs weren’t a thing I’d go with a client side system most days of the week.</div><br/><div id="38342501" class="c"><input type="checkbox" id="c-38342501" checked=""/><div class="controls bullet"><span class="by">halfcat</span><span>|</span><a href="#38338644">root</a><span>|</span><a href="#38341683">parent</a><span>|</span><a href="#38339964">next</a><span>|</span><label class="collapse" for="c-38342501">[-]</label><label class="expand" for="c-38342501">[2 more]</label></div><br/><div class="children"><div class="content">I wouldn’t say we’ve hit the center of the bullseye quite yet, still experimenting with the exact patterns of organizing and structuring a project using this approach.<p>But so far we’ve landed on using the django-components library [1] to build something akin to Vue’s single file components. HTML, CSS, JavaScript, and Python “business logic”, all in one file.<p>That component is then used in the Django templates, or in other component’s HTML, and it all seems to work very React-like in terms of an organized structure of composable components. Combined with HTMX the traditional SSR challenges you mention seem fairly straightforward to handle.<p>&gt; what if you’d like to statically verify that your templates have all the content in place? Proper typing?<p>Can you say more about this? Would this be using TypeScript in React to verify types, or something more involved? I’m trying to understand this and what the equivalent might be in this “dynamic SSR” scenario.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;EmilStenstrom&#x2F;django-components">https:&#x2F;&#x2F;github.com&#x2F;EmilStenstrom&#x2F;django-components</a></div><br/><div id="38343138" class="c"><input type="checkbox" id="c-38343138" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#38338644">root</a><span>|</span><a href="#38342501">parent</a><span>|</span><a href="#38339964">next</a><span>|</span><label class="collapse" for="c-38343138">[-]</label><label class="expand" for="c-38343138">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I&#x27;m talking mainly about React + Typescript as a combo. With more gnarly Django templates sometimes it&#x27;s hard to even know what we are looking at in a template, whereas inside a React component I&#x27;m going to be a &quot;jump to definition&quot; away, not just for components (or template tags in the case of Django, I know PyCharm offers good jump to def there, including for stuff like Angluar!), but for variables and the like as well.<p>I think django-components only has part of the story there, because even if that helps writing out your page, you&#x27;re still looking at going to the other side of the frontend&#x2F;backend wall to add, at the very least, an endpoint using that template. And if you&#x27;re following this whole &quot;hypertext API and data API as separate things&quot;, you&#x27;ll need to also code handling of submitting any data, and routing involved.<p>I&#x27;m not against this stuff entirely, because I think there&#x27;s a bit of a Go-like niceness to how it&#x27;s &quot;at worst&quot; boilerplate (that you can abstract over on a per-project basis). But if you have a comfortable, well designed API all that work spread over you templates and controllers might actually all just be in one place.</div><br/></div></div></div></div></div></div></div></div><div id="38339964" class="c"><input type="checkbox" id="c-38339964" checked=""/><div class="controls bullet"><span class="by">hipadev23</span><span>|</span><a href="#38338644">root</a><span>|</span><a href="#38338709">parent</a><span>|</span><a href="#38339034">prev</a><span>|</span><a href="#38341343">next</a><span>|</span><label class="collapse" for="c-38339964">[-]</label><label class="expand" for="c-38339964">[1 more]</label></div><br/><div class="children"><div class="content">I’d argue javascript frameworks are a ton of added complexity. I send html, browser renders.</div><br/></div></div><div id="38341343" class="c"><input type="checkbox" id="c-38341343" checked=""/><div class="controls bullet"><span class="by">SrslyJosh</span><span>|</span><a href="#38338644">root</a><span>|</span><a href="#38338709">parent</a><span>|</span><a href="#38339964">prev</a><span>|</span><a href="#38342047">next</a><span>|</span><label class="collapse" for="c-38341343">[-]</label><label class="expand" for="c-38341343">[1 more]</label></div><br/><div class="children"><div class="content">Not having to write your app a second time in javascript seems like less complexity to me. ¯\_(ツ)_&#x2F;¯</div><br/></div></div><div id="38342047" class="c"><input type="checkbox" id="c-38342047" checked=""/><div class="controls bullet"><span class="by">rchaud</span><span>|</span><a href="#38338644">root</a><span>|</span><a href="#38338709">parent</a><span>|</span><a href="#38341343">prev</a><span>|</span><a href="#38339108">next</a><span>|</span><label class="collapse" for="c-38342047">[-]</label><label class="expand" for="c-38342047">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d say this is a very useful library to have that provides a lot of React-like features without the overhead of a build step or frankly, needing to learn React on top of building the backend in some other language and framework. Compare the simplicity of &#x27;hx-get&#x27; to the verbiage needed for a simple XHR request in vanilla JS, and the benefits become clear.<p>IMO, it&#x27;s a great option for rapid prototyping and for projects that can be done with whatever backend stack you already have.</div><br/></div></div><div id="38339108" class="c"><input type="checkbox" id="c-38339108" checked=""/><div class="controls bullet"><span class="by">folsom</span><span>|</span><a href="#38338644">root</a><span>|</span><a href="#38338709">parent</a><span>|</span><a href="#38342047">prev</a><span>|</span><a href="#38338795">next</a><span>|</span><label class="collapse" for="c-38339108">[-]</label><label class="expand" for="c-38339108">[1 more]</label></div><br/><div class="children"><div class="content">I think the idea is that your hypermedia api and data api are not the same thing and the general shape of your data api should not be based on the needs of your front end.</div><br/></div></div><div id="38338795" class="c"><input type="checkbox" id="c-38338795" checked=""/><div class="controls bullet"><span class="by">infecto</span><span>|</span><a href="#38338644">root</a><span>|</span><a href="#38338709">parent</a><span>|</span><a href="#38339108">prev</a><span>|</span><a href="#38340632">next</a><span>|</span><label class="collapse" for="c-38338795">[-]</label><label class="expand" for="c-38338795">[1 more]</label></div><br/><div class="children"><div class="content">Depends what you are trying to build. If you are building a complicated app that requires lots of states and you want it in the form of a SPA. Sure might be a bad fit.<p>Lots of use cases could benefit from a hypermedia flow.</div><br/></div></div><div id="38340632" class="c"><input type="checkbox" id="c-38340632" checked=""/><div class="controls bullet"><span class="by">halfcat</span><span>|</span><a href="#38338644">root</a><span>|</span><a href="#38338709">parent</a><span>|</span><a href="#38338795">prev</a><span>|</span><a href="#38340954">next</a><span>|</span><label class="collapse" for="c-38340632">[-]</label><label class="expand" for="c-38340632">[1 more]</label></div><br/><div class="children"><div class="content">We have a team of Python devs who push data around and do analytics, reporting, etc<p>They added real-time search results to our Django SSR site in 2 lines of HTMX.<p>It’s the opposite of added complexity.</div><br/></div></div></div></div></div></div><div id="38339966" class="c"><input type="checkbox" id="c-38339966" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#38338644">prev</a><span>|</span><a href="#38339637">next</a><span>|</span><label class="collapse" for="c-38339966">[-]</label><label class="expand" for="c-38339966">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Your JSON API should remain stable. You can’t be adding and removing end-points willy-nilly. Yes, you can have some end-points respond with either JSON or HTML and others only respond with HTML, but it gets messy. What if you accidentally copy-and-paste in the wrong code somewhere, for example.<p>Can&#x27;t we handle this situation by regarding each version of the JSON output as a separate content type (which is arguably the semantically correct thing anyway) and then letting the server pick the more recent output version that the client supports?</div><br/></div></div><div id="38339637" class="c"><input type="checkbox" id="c-38339637" checked=""/><div class="controls bullet"><span class="by">foul</span><span>|</span><a href="#38339966">prev</a><span>|</span><a href="#38338451">next</a><span>|</span><label class="collapse" for="c-38339637">[-]</label><label class="expand" for="c-38339637">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Not being content with alienating only the general purpose JSON API enthusiasts, let me now proceed to also alienate my erstwhile hypermedia enthusiast allies<p>Nah I think he&#x27;s right and it&#x27;s coherent to avoid HTTP subtleties in that web architecture.</div><br/></div></div><div id="38338451" class="c"><input type="checkbox" id="c-38338451" checked=""/><div class="controls bullet"><span class="by">mschuster91</span><span>|</span><a href="#38339637">prev</a><span>|</span><label class="collapse" for="c-38338451">[-]</label><label class="expand" for="c-38338451">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Data APIs should be rate limited<p>Hypermedia APIs should be rate limited as well, because otherwise people will just go and screen scrape (like many HN apps do, because HN doesn&#x27;t offer an API). All a &quot;data&quot; API does is make the scraper&#x27;s job easier.<p>&gt; Data APIs typically use some sort of token-based authentication &#x2F; Hypermedia APIs typically use some sort of session-cookie based authentication<p>So what. Any web framework worth its salt can support multiple authentication &#x2F; credential mechanisms - the only &quot;benefit&quot; I can see from limiting cookie authentication is to make life for bad actors with cookie-stealer malware harder (like GitLab does, IIRC).</div><br/><div id="38344894" class="c"><input type="checkbox" id="c-38344894" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38338451">parent</a><span>|</span><a href="#38339083">next</a><span>|</span><label class="collapse" for="c-38344894">[-]</label><label class="expand" for="c-38344894">[1 more]</label></div><br/><div class="children"><div class="content">People usually screen scrape because of limitations in the Hacker News API, not because it&#x27;s nonexistent.</div><br/></div></div><div id="38339083" class="c"><input type="checkbox" id="c-38339083" checked=""/><div class="controls bullet"><span class="by">serial_dev</span><span>|</span><a href="#38338451">parent</a><span>|</span><a href="#38344894">prev</a><span>|</span><a href="#38338720">next</a><span>|</span><label class="collapse" for="c-38339083">[-]</label><label class="expand" for="c-38339083">[1 more]</label></div><br/><div class="children"><div class="content">Hacker News has an API for a while now (I used it years ago around 2018), based on this post since 2014.<p>Announcement <a href="https:&#x2F;&#x2F;www.ycombinator.com&#x2F;blog&#x2F;hacker-news-api">https:&#x2F;&#x2F;www.ycombinator.com&#x2F;blog&#x2F;hacker-news-api</a><p>API <a href="https:&#x2F;&#x2F;github.com&#x2F;HackerNews&#x2F;API">https:&#x2F;&#x2F;github.com&#x2F;HackerNews&#x2F;API</a></div><br/></div></div><div id="38338720" class="c"><input type="checkbox" id="c-38338720" checked=""/><div class="controls bullet"><span class="by">benmanns</span><span>|</span><a href="#38338451">parent</a><span>|</span><a href="#38339083">prev</a><span>|</span><a href="#38338841">next</a><span>|</span><label class="collapse" for="c-38338720">[-]</label><label class="expand" for="c-38338720">[1 more]</label></div><br/><div class="children"><div class="content">Not anymore! <a href="https:&#x2F;&#x2F;github.com&#x2F;HackerNews&#x2F;API">https:&#x2F;&#x2F;github.com&#x2F;HackerNews&#x2F;API</a></div><br/></div></div><div id="38338841" class="c"><input type="checkbox" id="c-38338841" checked=""/><div class="controls bullet"><span class="by">ronsor</span><span>|</span><a href="#38338451">parent</a><span>|</span><a href="#38338720">prev</a><span>|</span><label class="collapse" for="c-38338841">[-]</label><label class="expand" for="c-38338841">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Hypermedia APIs should be rate limited as well, because otherwise people will just go and screen scrape<p>Then proxies or other IPs will be used anyway.</div><br/></div></div></div></div></div></div></div></div></div></body></html>