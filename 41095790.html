<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1722243658788" as="style"/><link rel="stylesheet" href="styles.css?v=1722243658788"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://dotat.at/@/2024-07-28-tolower-avx512.html">tolower() with AVX-512</a> <span class="domain">(<a href="https://dotat.at">dotat.at</a>)</span></div><div class="subtext"><span>fanf2</span> | <span>74 comments</span></div><br/><div><div id="41097850" class="c"><input type="checkbox" id="c-41097850" checked=""/><div class="controls bullet"><span class="by">anderskaseorg</span><span>|</span><a href="#41098895">next</a><span>|</span><label class="collapse" for="c-41097850">[-]</label><label class="expand" for="c-41097850">[6 more]</label></div><br/><div class="children"><div class="content">Note that the “unsafe read beyond of death” trick is considered undefined behavior in the Rust and LLVM memory model, even if it’s allowed by the underlying hardware. Like any undefined behavior, compilers are allowed to assume it doesn’t happen for the purpose of optimization, leading to results you don’t expect. The only way around this is to use inline assembly.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ogxd&#x2F;gxhash&#x2F;issues&#x2F;82">https:&#x2F;&#x2F;github.com&#x2F;ogxd&#x2F;gxhash&#x2F;issues&#x2F;82</a></div><br/><div id="41097966" class="c"><input type="checkbox" id="c-41097966" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#41097850">parent</a><span>|</span><a href="#41098415">next</a><span>|</span><label class="collapse" for="c-41097966">[-]</label><label class="expand" for="c-41097966">[3 more]</label></div><br/><div class="children"><div class="content">It would be neat to have non-assembly options for things like this. A &quot;load with unspecified elements for any values past the end of the allocation, UB only if the hardware doesn&#x27;t like it&quot; thing shouldn&#x27;t be hard to support, even if just as an alias for the respective assembly invocations.<p>Additional neatness would be being able to request a guarantee that all allocations - malloc, stack, constants - have at least, say, 64 bytes of non-faulting addresses after them, though that is significantly more complex, requiring cooperation between a bunch of parts.<p>Annoying thing is that this is trivial with a custom allocator (as long as the compiler isn&#x27;t told to consider the custom sub-allocations as separate), but then you&#x27;re stuck not being able to use your SIMD stuff on anything outside your custom heap due to the very tiny chance of segfaulting.<p>Sanitizers&#x2F;valgrind don&#x27;t necessarily become pointless with this even - the past-the-end values are still undefined, can be tracked as such, and error on use.</div><br/><div id="41098721" class="c"><input type="checkbox" id="c-41098721" checked=""/><div class="controls bullet"><span class="by">tomsmeding</span><span>|</span><a href="#41097850">root</a><span>|</span><a href="#41097966">parent</a><span>|</span><a href="#41098737">next</a><span>|</span><label class="collapse" for="c-41098721">[-]</label><label class="expand" for="c-41098721">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A &quot;load with unspecified elements for any values past the end of the allocation, UB only if the hardware doesn&#x27;t like it&quot; thing shouldn&#x27;t be hard to support<p>Not an expert, but to me this sounds like you want an alternative where behaviour for a read beyond the end of an allocation is merely <i>implementation-defined</i>, not undefined. That means the implementation (e.g. LLVM) has to document what they do — which may be platform-dependent — and the choice of whether it becomes <i>undefined</i> is up to the implementation.<p>The natural thing to do here for the implementation is of course to say &quot;I&#x27;m just going to emit the load instruction, it may crash your program, better be prepared&quot;.</div><br/></div></div><div id="41098737" class="c"><input type="checkbox" id="c-41098737" checked=""/><div class="controls bullet"><span class="by">the8472</span><span>|</span><a href="#41097850">root</a><span>|</span><a href="#41097966">parent</a><span>|</span><a href="#41098721">prev</a><span>|</span><a href="#41098415">next</a><span>|</span><label class="collapse" for="c-41098737">[-]</label><label class="expand" for="c-41098737">[1 more]</label></div><br/><div class="children"><div class="content">The sanctioned way to this would be masked aligned load intrinsics, alignment avoids page faults, masking avoids reading undef bits, being an intrinsic conveys the intent to the compiler so it&#x27;ll know that this is not an OOB read.<p>The other option that I&#x27;ve seen discussed is a freezing load to LLVM that turns the undef bits into some unspecified but valid bit patterns.</div><br/></div></div></div></div><div id="41098415" class="c"><input type="checkbox" id="c-41098415" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41097850">parent</a><span>|</span><a href="#41097966">prev</a><span>|</span><a href="#41098895">next</a><span>|</span><label class="collapse" for="c-41098415">[-]</label><label class="expand" for="c-41098415">[2 more]</label></div><br/><div class="children"><div class="content">Is that even true at a hardware level? What if you read into an unmapped page or into protected memory? (I haven&#x27;t read the code, maybe it has alignment guarantees that avoid this?)</div><br/><div id="41098558" class="c"><input type="checkbox" id="c-41098558" checked=""/><div class="controls bullet"><span class="by">b3orn</span><span>|</span><a href="#41097850">root</a><span>|</span><a href="#41098415">parent</a><span>|</span><a href="#41098895">next</a><span>|</span><label class="collapse" for="c-41098558">[-]</label><label class="expand" for="c-41098558">[1 more]</label></div><br/><div class="children"><div class="content">The code uses unaligned load and store instructions, so it should be possible to trigger memory access to unmapped addresses.</div><br/></div></div></div></div></div></div><div id="41098895" class="c"><input type="checkbox" id="c-41098895" checked=""/><div class="controls bullet"><span class="by">dolmen</span><span>|</span><a href="#41097850">prev</a><span>|</span><a href="#41098380">next</a><span>|</span><label class="collapse" for="c-41098895">[-]</label><label class="expand" for="c-41098895">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately those SWAR optimizations are only useful for strings that are aligned on 8 bytes address.<p>If your SWAR algorithm is applied on a non-aligned string, it is often slower than the original algorithm.<p>And splitting the algorith in 3 parts (handling the beginning up to an aligned address, then the aligned part, and then the less-than-8-bytes tail) takes even more instructions.<p>Here is a similar case on a false claim of a faster utf8.IsValid in Go, with benchmarks: <a href="https:&#x2F;&#x2F;github.com&#x2F;sugawarayuuta&#x2F;charcoal&#x2F;pull&#x2F;1">https:&#x2F;&#x2F;github.com&#x2F;sugawarayuuta&#x2F;charcoal&#x2F;pull&#x2F;1</a></div><br/></div></div><div id="41098380" class="c"><input type="checkbox" id="c-41098380" checked=""/><div class="controls bullet"><span class="by">Remnant44</span><span>|</span><a href="#41098895">prev</a><span>|</span><a href="#41095822">next</a><span>|</span><label class="collapse" for="c-41098380">[-]</label><label class="expand" for="c-41098380">[5 more]</label></div><br/><div class="children"><div class="content">Neat and performant code like the article makes me very curious how the competition will shake out between AMD&#x27;s AVX512 implementation and Intel&#x27;s upcoming AVX10. The entire point of AVX10 seems to be to resolve Intel&#x27;s P vs E core situation, while AMD seems to have taken a better approach of using either full width (Zen5) or double-pumped 256bit (Zen4, Zen5 mobile) as appropriate to the situation, while making the API seamless.<p>The big gains delivered in the article are all on a double-pumped Zen4 core! AVX512 brings a lot to the table so its quite frustrating that Intel market-segmented support for it so heavily as to completely inhibit its adoption in broad-based client code.</div><br/><div id="41098427" class="c"><input type="checkbox" id="c-41098427" checked=""/><div class="controls bullet"><span class="by">Tuna-Fish</span><span>|</span><a href="#41098380">parent</a><span>|</span><a href="#41095822">next</a><span>|</span><label class="collapse" for="c-41098427">[-]</label><label class="expand" for="c-41098427">[4 more]</label></div><br/><div class="children"><div class="content">If Intel actually implements AVX10&#x2F;256 on every CPU they ship going forwards, it will eventually win simply by availability. The market has repeatedly and thoroughly rejected dispatching to different code paths based on CPU, so the only SIMD implementation that actually matters is the lowest common denominator. And since AVX10.1&#x2F;256 and AVX512VL have a shared subset, that will be what people will eventually target once enough time has passed and nearly everyone has a CPU that can support it.<p>AVX512 will continue to give AMD some easy wins on the few benchmarking apps that were actually updated to support it, but if Intel sticks with the AVX10 plan I expect that AMD will eventually just use the double-pumped SIMD pipes for everything, just because they are the more efficient way to support AVX10&#x2F;256 while retaining AVX512 compatibility.<p>Intel did a lot of bad choices in the past decade, but segmenting the market based on instruction set has to be one of the worst. They just chose to kill all the momentum and interest in their newest and best innovations. Hopefully they actually add AVX10&#x2F;256 support to the whole lineup, because the width is the least interesting part about AVX512, the masked operations especially are a lot more important.</div><br/><div id="41098914" class="c"><input type="checkbox" id="c-41098914" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#41098380">root</a><span>|</span><a href="#41098427">parent</a><span>|</span><a href="#41098884">next</a><span>|</span><label class="collapse" for="c-41098914">[-]</label><label class="expand" for="c-41098914">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The market has repeatedly and thoroughly rejected dispatching to different code paths based on CPU<p>What do you mean? At least numpy and pytorch (the only numeric libraries I&#x27;m familiar with) both use runtime dispatching.</div><br/></div></div><div id="41098884" class="c"><input type="checkbox" id="c-41098884" checked=""/><div class="controls bullet"><span class="by">janwas</span><span>|</span><a href="#41098380">root</a><span>|</span><a href="#41098427">parent</a><span>|</span><a href="#41098914">prev</a><span>|</span><a href="#41098525">next</a><span>|</span><label class="collapse" for="c-41098884">[-]</label><label class="expand" for="c-41098884">[1 more]</label></div><br/><div class="children"><div class="content">Dispatching is actually heavily used. Image&#x2F;video codecs, cryptography, and ML libraries routinely use it, because the lowest common denominator is very low indeed.</div><br/></div></div><div id="41098525" class="c"><input type="checkbox" id="c-41098525" checked=""/><div class="controls bullet"><span class="by">Remnant44</span><span>|</span><a href="#41098380">root</a><span>|</span><a href="#41098427">parent</a><span>|</span><a href="#41098884">prev</a><span>|</span><a href="#41095822">next</a><span>|</span><label class="collapse" for="c-41098525">[-]</label><label class="expand" for="c-41098525">[1 more]</label></div><br/><div class="children"><div class="content">I agree. I still hesitate to ship code that requires even AVX1, even though it was first introduced in 2011(!).<p>AVX512 really improves the instruction set. Not just from masking but from some really big holes filled in terms of instructions available that AVX2 doesn&#x27;t have a good solution for.<p>At the same time I also DO have plenty of code that could definitely use the compute throughput improvement of 512 bit vectors. But it&#x27;s definitely a more niche usage. You have to at least nominally satisfy that you: 1) Benefit from 2x the ALU throughput 2) Live mostly in the cache 3) Are not worth running on the GPU instead.</div><br/></div></div></div></div></div></div><div id="41095822" class="c"><input type="checkbox" id="c-41095822" checked=""/><div class="controls bullet"><span class="by">h2odragon</span><span>|</span><a href="#41098380">prev</a><span>|</span><a href="#41096934">next</a><span>|</span><label class="collapse" for="c-41095822">[-]</label><label class="expand" for="c-41095822">[26 more]</label></div><br/><div class="children"><div class="content">just for giggles: <a href="http:&#x2F;&#x2F;www.unicode.org&#x2F;Public&#x2F;3.1-Update1&#x2F;CaseFolding-4.txt" rel="nofollow">http:&#x2F;&#x2F;www.unicode.org&#x2F;Public&#x2F;3.1-Update1&#x2F;CaseFolding-4.txt</a></div><br/><div id="41097159" class="c"><input type="checkbox" id="c-41097159" checked=""/><div class="controls bullet"><span class="by">pdpi</span><span>|</span><a href="#41095822">parent</a><span>|</span><a href="#41096348">next</a><span>|</span><label class="collapse" for="c-41097159">[-]</label><label class="expand" for="c-41097159">[18 more]</label></div><br/><div class="children"><div class="content">While we&#x27;re having fun with that:<p><pre><code>    # Capitalising an eszett changes the string length.
    &gt;&gt;&gt; &quot;straße&quot;.upper()
    &#x27;STRASSE&#x27;
    
    # If you don&#x27;t specify the locale, round-trip upper&#x2F;lower case
    # messes up the dotless i used in turkic languages.
    &gt;&gt;&gt; &#x27;ı&#x27;.upper().lower()
    &#x27;i&#x27;</code></pre></div><br/><div id="41097860" class="c"><input type="checkbox" id="c-41097860" checked=""/><div class="controls bullet"><span class="by">kleiba</span><span>|</span><a href="#41095822">root</a><span>|</span><a href="#41097159">parent</a><span>|</span><a href="#41098333">next</a><span>|</span><label class="collapse" for="c-41097860">[-]</label><label class="expand" for="c-41097860">[15 more]</label></div><br/><div class="children"><div class="content">Up until a few years ago, the first conversion would have been the official way to write a German word that contains the ligature ß (a lower-case letter) in all caps, because there was no corresponding upper-case letter. However, in 2017, an upper-case variant [1] was introduced into the official German orthography, so the conversion cited here should no longer be necessary.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Capital_%E1%BA%9E" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Capital_%E1%BA%9E</a></div><br/><div id="41097925" class="c"><input type="checkbox" id="c-41097925" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41095822">root</a><span>|</span><a href="#41097860">parent</a><span>|</span><a href="#41097920">next</a><span>|</span><label class="collapse" for="c-41097925">[-]</label><label class="expand" for="c-41097925">[4 more]</label></div><br/><div class="children"><div class="content">The upper-case ẞ remains very unconventional, and the Unicode casing algorithm continues to specify upper-case conversion to SS.</div><br/><div id="41098026" class="c"><input type="checkbox" id="c-41098026" checked=""/><div class="controls bullet"><span class="by">kleiba</span><span>|</span><a href="#41095822">root</a><span>|</span><a href="#41097925">parent</a><span>|</span><a href="#41097920">next</a><span>|</span><label class="collapse" for="c-41098026">[-]</label><label class="expand" for="c-41098026">[3 more]</label></div><br/><div class="children"><div class="content">Correct. This raises the question what should be the basis of the Unicode casing algorithm: what is commonly practiced by users of a specific language (<i>how to measure this reliably in less clear cases than this one?</i>) or what an official &quot;specification&quot; of the language defines (<i>if such a thing exists, and is widely accepted, especially when the language is spoken in more than one country</i>)?</div><br/><div id="41098423" class="c"><input type="checkbox" id="c-41098423" checked=""/><div class="controls bullet"><span class="by">stefs</span><span>|</span><a href="#41095822">root</a><span>|</span><a href="#41098026">parent</a><span>|</span><a href="#41097920">next</a><span>|</span><label class="collapse" for="c-41098423">[-]</label><label class="expand" for="c-41098423">[2 more]</label></div><br/><div class="children"><div class="content">IMO: the official specification. If it doesn&#x27;t match common usage after some time, the spec should be revised.<p>Pretty sure the actual question would be: what if there are multiple conflicting official specs?</div><br/><div id="41098582" class="c"><input type="checkbox" id="c-41098582" checked=""/><div class="controls bullet"><span class="by">mschuster91</span><span>|</span><a href="#41095822">root</a><span>|</span><a href="#41098423">parent</a><span>|</span><a href="#41097920">next</a><span>|</span><label class="collapse" for="c-41098582">[-]</label><label class="expand" for="c-41098582">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If it doesn&#x27;t match common usage after some time, the spec should be revised<p>Well, the problem with <i>any</i> kind of language spec change is that it can take <i>decades</i> until it gets accepted widely.<p>Young people are the first adopters as they get it force-fed by schools, but getting the age bracket 40+ to adopt is a real challenge. Germany&#x27;s 1996 project led to years-long battles and partial reversals in 2004&#x2F;06, and really old people to this day haven&#x27;t accepted it.</div><br/></div></div></div></div></div></div></div></div><div id="41097920" class="c"><input type="checkbox" id="c-41097920" checked=""/><div class="controls bullet"><span class="by">Tomte</span><span>|</span><a href="#41095822">root</a><span>|</span><a href="#41097860">parent</a><span>|</span><a href="#41097925">prev</a><span>|</span><a href="#41098333">next</a><span>|</span><label class="collapse" for="c-41097920">[-]</label><label class="expand" for="c-41097920">[10 more]</label></div><br/><div class="children"><div class="content">It is extremely unusual, and the addition to Unicode was very controversial.<p>Basically, some type designers liked to play with capital ß and thought it cool to have it included into Unicode. There was a whole campaign for inclusion, and it was a big mistake.<p>Because even though existing use must be shown to merit inclusion, they only managed to find a single book (a dictionary) printed in more than a few copies. From East Germany. And that book only used the capital ß for a single edition (out of dozens of editions) and reverted straight back to double s. Somehow, that still was enough for Unicode.<p>Capital ß is a shit show, and it only confuses native speakers, because close to none of them have ever seen that glyph before.<p>It has no real historic lineage (like the long s, for example, that pretty much nobody under 80 knows, either), it is a faux-retro modern design, an idle plaything.</div><br/><div id="41097935" class="c"><input type="checkbox" id="c-41097935" checked=""/><div class="controls bullet"><span class="by">kleiba</span><span>|</span><a href="#41095822">root</a><span>|</span><a href="#41097920">parent</a><span>|</span><a href="#41098382">prev</a><span>|</span><a href="#41098292">next</a><span>|</span><label class="collapse" for="c-41097935">[-]</label><label class="expand" for="c-41097935">[4 more]</label></div><br/><div class="children"><div class="content">Well, what can you do... amtlich is amtlich.<p>And the behavior of a function that converts ß to double upper-case S can certainly be discussed too, if only for the fact that a round-trip toUpper().toLower() will not give you back the original word.</div><br/><div id="41098303" class="c"><input type="checkbox" id="c-41098303" checked=""/><div class="controls bullet"><span class="by">josefx</span><span>|</span><a href="#41095822">root</a><span>|</span><a href="#41097935">parent</a><span>|</span><a href="#41098125">next</a><span>|</span><label class="collapse" for="c-41098303">[-]</label><label class="expand" for="c-41098303">[2 more]</label></div><br/><div class="children"><div class="content">&gt; if only for the fact that a round-trip toUpper().toLower() will not give you back the original word.<p>It is an inherently destructive round trip, especially in a language that makes excessive use of upper case when comapred to english. When you have the word &quot;wagen&quot; did it originally refer to a &quot;car&quot; or did it refer to someone &quot;trying&quot;?</div><br/><div id="41098547" class="c"><input type="checkbox" id="c-41098547" checked=""/><div class="controls bullet"><span class="by">vlabakje90</span><span>|</span><a href="#41095822">root</a><span>|</span><a href="#41098303">parent</a><span>|</span><a href="#41098125">next</a><span>|</span><label class="collapse" for="c-41098547">[-]</label><label class="expand" for="c-41098547">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not a German speaker but this is definitely not exclusive to German nor is it caused by &#x27;excessive&#x27; capitalization. The use of capital letters to denote nouns only helps to disambiguate it in German. While in English, this distinction is never clear just from the spelling of the isolated word alone. E.g. &#x27;contract&#x27; can either mean &#x27;an agreement&#x27; as a noun or  &#x27;to decrease in size&#x27; as a verb. There are plenty of other examples.<p>I agree though that this makes the round-trip inherently destructive.</div><br/></div></div></div></div><div id="41098125" class="c"><input type="checkbox" id="c-41098125" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41095822">root</a><span>|</span><a href="#41097935">parent</a><span>|</span><a href="#41098303">prev</a><span>|</span><a href="#41098292">next</a><span>|</span><label class="collapse" for="c-41098125">[-]</label><label class="expand" for="c-41098125">[1 more]</label></div><br/><div class="children"><div class="content">Note that the addition to Unicode came first, and the addition to the official German orthography only came nine years later (and might not have happened at all without the Unicode inclusion). In addition, it remains only a variant in the latter, alongside the existing SS.</div><br/></div></div></div></div><div id="41098292" class="c"><input type="checkbox" id="c-41098292" checked=""/><div class="controls bullet"><span class="by">nuancebydefault</span><span>|</span><a href="#41095822">root</a><span>|</span><a href="#41097920">parent</a><span>|</span><a href="#41097935">prev</a><span>|</span><a href="#41098409">next</a><span>|</span><label class="collapse" for="c-41098292">[-]</label><label class="expand" for="c-41098292">[1 more]</label></div><br/><div class="children"><div class="content">As a non native German speaker I really don&#x27;t understand all the fuß around the capitalneSS of ß</div><br/></div></div><div id="41098409" class="c"><input type="checkbox" id="c-41098409" checked=""/><div class="controls bullet"><span class="by">jabiko</span><span>|</span><a href="#41095822">root</a><span>|</span><a href="#41097920">parent</a><span>|</span><a href="#41098292">prev</a><span>|</span><a href="#41098333">next</a><span>|</span><label class="collapse" for="c-41098409">[-]</label><label class="expand" for="c-41098409">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Capital ß is a shit show, and it only confuses native speakers, because close to none of them have ever seen that glyph before.<p>I don&#x27;t think it&#x27;s particularly confusing, but it is a great addition. As of 2017 the rules allow both &quot;SS&quot; and &quot;ẞ&quot;.<p>Moreover, the current version of DIN 5008 (Rules for Writing and Design in Text and Information Processing) actually recommends preferring &quot;ẞ&quot; over &quot;SS&quot;.</div><br/><div id="41098524" class="c"><input type="checkbox" id="c-41098524" checked=""/><div class="controls bullet"><span class="by">gwervc</span><span>|</span><a href="#41095822">root</a><span>|</span><a href="#41098409">parent</a><span>|</span><a href="#41098333">next</a><span>|</span><label class="collapse" for="c-41098524">[-]</label><label class="expand" for="c-41098524">[2 more]</label></div><br/><div class="children"><div class="content">What&#x27;s confusing for me is that the German government seems to change its mind radically around the question every few years. If I counted properly, there was already two orthographic changes since I was schooled (German as a second language).</div><br/><div id="41098825" class="c"><input type="checkbox" id="c-41098825" checked=""/><div class="controls bullet"><span class="by">jabiko</span><span>|</span><a href="#41095822">root</a><span>|</span><a href="#41098524">parent</a><span>|</span><a href="#41098333">next</a><span>|</span><label class="collapse" for="c-41098825">[-]</label><label class="expand" for="c-41098825">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure what radical changes you are referring to. There was a orthography reform in 1996 (with a transitional period until 2005). But other than that only minor changes occurred.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41096348" class="c"><input type="checkbox" id="c-41096348" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#41095822">parent</a><span>|</span><a href="#41097159">prev</a><span>|</span><a href="#41096614">next</a><span>|</span><label class="collapse" for="c-41096348">[-]</label><label class="expand" for="c-41096348">[2 more]</label></div><br/><div class="children"><div class="content">Heh, thank goodness I don’t have to deal with all that! This code is ascii-only because it arose from working on the DNS. There are other protocols that are ascii-case-insensitive so it turns up a lot in the hot path of many servers.</div><br/><div id="41097182" class="c"><input type="checkbox" id="c-41097182" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41095822">root</a><span>|</span><a href="#41096348">parent</a><span>|</span><a href="#41096614">next</a><span>|</span><label class="collapse" for="c-41097182">[-]</label><label class="expand" for="c-41097182">[1 more]</label></div><br/><div class="children"><div class="content">This is presumably Rust&#x27;s u8::to_ascii_lowercase rather than C&#x27;s tolower since tolower is locale sensitive (which you don&#x27;t care about) and has Undefined Behaviour (because of course it does it&#x27;s a C function and who cares about correctness)<p>Or possibly u8::make_ascii_lowercase which is the same function but with in-place mutation.</div><br/></div></div></div></div><div id="41096614" class="c"><input type="checkbox" id="c-41096614" checked=""/><div class="controls bullet"><span class="by">Asooka</span><span>|</span><a href="#41095822">parent</a><span>|</span><a href="#41096348">prev</a><span>|</span><a href="#41097153">next</a><span>|</span><label class="collapse" for="c-41096614">[-]</label><label class="expand" for="c-41096614">[4 more]</label></div><br/><div class="children"><div class="content">There is a difference between strings used internally, usually as IDs, and text entered by a human. For the former you&#x27;d always use straight ASCII in 8-bit encoding, for the latter ... things get difficult. A straightforward example are DNS addresses - they can technically contain almost any Unicode, but that is always converted to a very limited subset of ASCII for actual DNS resolution, which in turn is case-insensitive.<p>There are of course things like programming languages with case-insensitive identifiers that support all human writing systems in Unicode. If that&#x27;s what you&#x27;re dealing with, you have my condolences.</div><br/><div id="41097238" class="c"><input type="checkbox" id="c-41097238" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41095822">root</a><span>|</span><a href="#41096614">parent</a><span>|</span><a href="#41097649">next</a><span>|</span><label class="collapse" for="c-41097238">[-]</label><label class="expand" for="c-41097238">[1 more]</label></div><br/><div class="children"><div class="content">On the wire DNS questions and answers are case <i>preserving</i> but not case <i>sensitive</i> which is important for correctness. DNS was designed a long time ago and doesn&#x27;t have enough places to hide randomness (~30 bits at most are available) to protect it against a realistic attacker, so, for most names we do a terrible trick in the real world - we randomize the case during querying. This is called DNS-0x20 for obvious reasons.<p>Suppose a web browser wants to know news.ycombinator.com AAAA? but bad guys know it&#x27;s about to ask this (e.g. they use JS to force that lookup when they wanted), they can shove a billion bogus answers (one for every possible random value) onto the wire and have a great chance to trick the browser into accepting one of these answers which seemingly is to the question it just asked. But, if we instead pick random cases we&#x27;re asking about, say, NeWS.yCOmbinAtOR.cOM and we can ignore answers for nEWS.yCOMBINATOR.cOM or news.ycombinator.com or NEWS.YCOMBINATOR.COM or any other spelling. Bad guys now need to do many orders of magnitude more expensive work for the same results.</div><br/></div></div><div id="41097122" class="c"><input type="checkbox" id="c-41097122" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#41095822">root</a><span>|</span><a href="#41096614">parent</a><span>|</span><a href="#41097649">prev</a><span>|</span><a href="#41097153">next</a><span>|</span><label class="collapse" for="c-41097122">[-]</label><label class="expand" for="c-41097122">[1 more]</label></div><br/><div class="children"><div class="content">For what it’s worth, with IDNs you’re still going to do a kind of case folding using stringprep before doing the query, and that isn’t really better than the table GP linked. ASCII-only case-insensitive matching is indeed a thing, but it’s usually mutually exclusive with (non-programmer) user-entered data.</div><br/></div></div></div></div><div id="41097153" class="c"><input type="checkbox" id="c-41097153" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#41095822">parent</a><span>|</span><a href="#41096614">prev</a><span>|</span><a href="#41096934">next</a><span>|</span><label class="collapse" for="c-41097153">[-]</label><label class="expand" for="c-41097153">[1 more]</label></div><br/><div class="children"><div class="content">Note for the first example which transforms the German maße to MASSE that the German language has an uppercase Eszett as well: ẞ<p>This is as of now not widely deployed and few fonts support it, but in theory it is there now.</div><br/></div></div></div></div><div id="41096934" class="c"><input type="checkbox" id="c-41096934" checked=""/><div class="controls bullet"><span class="by">LelouBil</span><span>|</span><a href="#41095822">prev</a><span>|</span><a href="#41096834">next</a><span>|</span><label class="collapse" for="c-41096934">[-]</label><label class="expand" for="c-41096934">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Finally, we do a masked add. We pass c twice: bytes from the first c are copied to the result when is_uppper is false, and when is_upper is true the result is c + to_upper.<p>Is that an error in the post ? Shouldnt it do the addition when is_upper is false and copy the same when it is true ?</div><br/><div id="41097009" class="c"><input type="checkbox" id="c-41097009" checked=""/><div class="controls bullet"><span class="by">jmalicki</span><span>|</span><a href="#41096934">parent</a><span>|</span><a href="#41096834">next</a><span>|</span><label class="collapse" for="c-41097009">[-]</label><label class="expand" for="c-41097009">[1 more]</label></div><br/><div class="children"><div class="content">The operation is `tolower`<p>Capital a is 0x40, lowercase is 0x60.<p>The addition of 0x20 needs to happen when is_upper is true.</div><br/></div></div></div></div><div id="41096834" class="c"><input type="checkbox" id="c-41096834" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#41096934">prev</a><span>|</span><a href="#41097399">next</a><span>|</span><label class="collapse" for="c-41096834">[-]</label><label class="expand" for="c-41096834">[8 more]</label></div><br/><div class="children"><div class="content">Mask add looks neat! I wish there was a way to directly manipulate AVX512&#x27;s mask registers in .NET intrinsics but for now we have to live with &quot;recognized idioms&quot;.<p>For anyone interested, the author&#x27;s core loop in ASM is as compiled by GCC<p><pre><code>    .L3:
        vmovdqu8        zmm0, ZMMWORD PTR [rcx+rax]
        vmovdqa64       zmm1, zmm0
        vpcmpb  k1, zmm0, zmm4, 5
        vpcmpb  k0, zmm0, zmm3, 2
        kandq   k1, k1, k0
        vpaddb  zmm1{k1}, zmm0, zmm2
        vmovdqu8        ZMMWORD PTR [rdi+rax], zmm1
        add     rax, 64
        cmp     rax, r8
        jne     .L3
</code></pre>
uiCA (CQA&#x2F;MAQAO) (<a href="https:&#x2F;&#x2F;uica.uops.info&#x2F;" rel="nofollow">https:&#x2F;&#x2F;uica.uops.info&#x2F;</a>, make sure to pick CQA + Ice Lake) says it achieves nice 32B&#x2F;cycle on Ice Lake. If you multiply by say 3 to match 3 GHz, this gives us almost 96 GiB&#x2F;s assuming memory access is not a bottleneck (it always is in such algorithms).<p>But this seems not as close to optimal utilization as it could be. Using Clang instead yields much better, nicely unrolled result with better instruction selection.<p><pre><code>    .LBB0_9:
        vmovdqu64       zmm3, zmmword ptr [rsi]
        vmovdqu64       zmm5, zmmword ptr [rsi + 64]
        vmovdqu64       zmm6, zmmword ptr [rsi + 128]
        add     rdx, -512
        vpaddb  zmm4, zmm3, zmm0
        vpcmpltub       k1, zmm4, zmm1
        vpaddb  zmm4, zmm5, zmm0
        vpaddb  zmm3 {k1}, zmm3, zmm2
        vpcmpltub       k1, zmm4, zmm1
        vpaddb  zmm4, zmm6, zmm0
        vpaddb  zmm5 {k1}, zmm5, zmm2
        vmovdqu64       zmmword ptr [rcx], zmm3
        vpcmpltub       k1, zmm4, zmm1
        vmovdqu64       zmmword ptr [rcx + 64], zmm5
        vmovdqu64       zmm5, zmmword ptr [rsi + 192]
        vpaddb  zmm6 {k1}, zmm6, zmm2
        vmovdqu64       zmmword ptr [rcx + 128], zmm6
        vmovdqu64       zmm6, zmmword ptr [rsi + 256]
        vpaddb  zmm4, zmm5, zmm0
        vpcmpltub       k1, zmm4, zmm1
        vpaddb  zmm4, zmm6, zmm0
        vpaddb  zmm5 {k1}, zmm5, zmm2
        vpcmpltub       k1, zmm4, zmm1
        vmovdqu64       zmmword ptr [rcx + 192], zmm5
        vmovdqu64       zmm5, zmmword ptr [rsi + 320]
        vpaddb  zmm6 {k1}, zmm6, zmm2
        vmovdqu64       zmmword ptr [rcx + 256], zmm6
        vmovdqu64       zmm6, zmmword ptr [rsi + 384]
        vpaddb  zmm4, zmm5, zmm0
        vpcmpltub       k1, zmm4, zmm1
        vpaddb  zmm4, zmm6, zmm0
        vpaddb  zmm5 {k1}, zmm5, zmm2
        vpcmpltub       k1, zmm4, zmm1
        vmovdqu64       zmmword ptr [rcx + 320], zmm5
        vmovdqu64       zmm5, zmmword ptr [rsi + 448]
        vpaddb  zmm6 {k1}, zmm6, zmm2
        add     rsi, 512
        vmovdqu64       zmmword ptr [rcx + 384], zmm6
        vpaddb  zmm4, zmm5, zmm0
        vpcmpltub       k1, zmm4, zmm1
        vpaddb  zmm5 {k1}, zmm5, zmm2
        vmovdqu64       zmmword ptr [rcx + 448], zmm5
        add     rcx, 512
        cmp     rdx, 63
        ja      .LBB0_9
</code></pre>
This extracts more impressive 42.67B&#x2F;c, I don&#x27;t think even L2 cache can sustain such a throughput, but it&#x27;s nice to know that medium length strings get up&#x2F;downcased in about the same time it takes light from your screen to reach your cornea.<p>The core for short lengths there is one instruction less:<p><pre><code>    .LBB0_5:
        vmovdqu64       zmm3, zmmword ptr [rsi + rcx]
        vpaddb  zmm4, zmm3, zmm0
        vpcmpltub       k1, zmm4, zmm1
        vpaddb  zmm3 {k1}, zmm3, zmm2
        vmovdqu64       zmmword ptr [rax + rcx], zmm3
        add     rcx, 64
        cmp     r8, rcx
        jne     .LBB0_5
</code></pre>
Some months ago I wrote a similar ASCII in UTF-8 upcase&#x2F;downcase implementation in C#: <a href="https:&#x2F;&#x2F;github.com&#x2F;U8String&#x2F;U8String&#x2F;blob&#x2F;main&#x2F;Sources&#x2F;U8String&#x2F;CaseConverters&#x2F;U8AsciiCaseConverter.cs#L158-L171">https:&#x2F;&#x2F;github.com&#x2F;U8String&#x2F;U8String&#x2F;blob&#x2F;main&#x2F;Sources&#x2F;U8Str...</a><p>(the unrolled conversion for below vectorization lengths is required as short strings dominate most codebases so handling it fast is important - the switch compiles to jump table and then branchless fall-through to return)<p>For now it goes as wide as 256b as it already saturates e.g. Zen 3 or 4 which have only 256x4 SIMD units (even though Zen 4 can do fancy 512b shuffles natively and has very good 512b implementation). The core loop compiles to compact<p><pre><code>       G_M48884_IG05:
              vmovups  ymm3, ymmword ptr [rdi+rax]
              vpaddb   ymm4, ymm3, ymm1
              vpcmpgtb ymm4, ymm2, ymm4
              vpand    ymm4, ymm4, ymm0
              vpor     ymm3, ymm4, ymm3
              vmovups  ymmword ptr [rsi+rax], ymm3
              add      rax, 32
              cmp      rax, rdx
              jbe      SHORT G_M48884_IG05
</code></pre>
Side by side with C ones: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;eTGYhTPan" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;eTGYhTPan</a><p>I believe you can also achieve similar with 3-instruction conversion with AVX512 with vpternlogd, as when I had access to AVX512 hardware, this is what .NET optimized it to for 256b width + AVX512VL, but strangely enough I can&#x27;t make it do so for 512b width right now.<p>You may notice failed SWAR attempt for switch dispatch case and I was wondering what kind of license your posts are distributed under? (gave up on it back then because per-element fall-through was already fast enough, but if yours passes the test suite, I&#x27;d love to use it haha)</div><br/><div id="41097181" class="c"><input type="checkbox" id="c-41097181" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#41096834">parent</a><span>|</span><a href="#41098783">next</a><span>|</span><label class="collapse" for="c-41097181">[-]</label><label class="expand" for="c-41097181">[4 more]</label></div><br/><div class="children"><div class="content">Clang and GCC have a differing approach to Intrinsics, and Clang is more likely than GCC to deviate from the Intel guide&#x27;s specified opcodes &amp; algorithms, and this is particularly noticeable with AVX-512 instructions. It&#x27;s understandable given their respective architectures. Sometimes the result is an improvement, sometimes it is a detriment.<p>A couple of years ago I worked on a heavily vectorized project that was intended to compile with either, and wound up maintaining inline asm and .S in the repository for specific targets alongside the C reference version. That made for some ugly Makefile shenanigans, and also meant including benchmarking as part of the test suite. It adds up to considerable maintenance burden, so the takeaway for me was that using Intrinsics as a low-level means to improve on the autovectorizer should be only very sparingly considered.<p><i>Edit to add</i>: quick example, from my notes during that project, <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;T4Pjhrz5d" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;T4Pjhrz5d</a> ; the GCC output is what was expected, the Clang output was a surprise, and noticeably slower in practice, even when inlined. When looped (or similarly if unrolled), uiCA clocks it at 7 cycles to GCC&#x27;s 4, and this was borne out by their benchmark performance in application code, in which this function was performed a few billion times in the course of a brute-forcing algorithm (which is to say, it mattered).  I recall finding other issues where a dive into the LLVM codebase suggested that Clang 16 might be entirely unable to issue some masked AVX-512 instructions due to internal refactorings.</div><br/><div id="41097746" class="c"><input type="checkbox" id="c-41097746" checked=""/><div class="controls bullet"><span class="by">Remnant44</span><span>|</span><a href="#41096834">root</a><span>|</span><a href="#41097181">parent</a><span>|</span><a href="#41097777">next</a><span>|</span><label class="collapse" for="c-41097746">[-]</label><label class="expand" for="c-41097746">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve run into the same behavior with clang and intrinsics. Well, I appreciate the fact that they&#x27;re trying to optimize the intrinsics usage, there really does need to be a flag or pragma you can pass that says more along the lines of &quot;no really, give me what I asked for.&quot; In some cases I have found that the code it produces is a significant pessimization from what I had selected.</div><br/></div></div><div id="41097777" class="c"><input type="checkbox" id="c-41097777" checked=""/><div class="controls bullet"><span class="by">glandium</span><span>|</span><a href="#41096834">root</a><span>|</span><a href="#41097181">parent</a><span>|</span><a href="#41097746">prev</a><span>|</span><a href="#41098783">next</a><span>|</span><label class="collapse" for="c-41097777">[-]</label><label class="expand" for="c-41097777">[2 more]</label></div><br/><div class="children"><div class="content">Did you file bugs with testcases?</div><br/><div id="41098653" class="c"><input type="checkbox" id="c-41098653" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#41096834">root</a><span>|</span><a href="#41097777">parent</a><span>|</span><a href="#41098783">next</a><span>|</span><label class="collapse" for="c-41098653">[-]</label><label class="expand" for="c-41098653">[1 more]</label></div><br/><div class="children"><div class="content">Sadly didn’t have time (this was not a funded project and I am far from sufficiently up to speed on LLVM internals). I still hope to get around to writing something up during the next break.</div><br/></div></div></div></div></div></div><div id="41098783" class="c"><input type="checkbox" id="c-41098783" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#41096834">parent</a><span>|</span><a href="#41097181">prev</a><span>|</span><a href="#41097092">next</a><span>|</span><label class="collapse" for="c-41098783">[-]</label><label class="expand" for="c-41098783">[1 more]</label></div><br/><div class="children"><div class="content">One thing that&#x27;s not all that obvious from this large chunk of assembly is that Clang manages to rewrite<p><pre><code>  (x &gt;= &#x27;a&#x27; &amp;&amp; x &lt;= &#x27;z&#x27;)
</code></pre>
into<p><pre><code>  (x - &#x27;a&#x27;) &lt; &lt;some constant&gt;
</code></pre>
which saves one instruction (and sometimes, a register load due to weird opcode encoding thingies).</div><br/></div></div><div id="41097092" class="c"><input type="checkbox" id="c-41097092" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#41096834">parent</a><span>|</span><a href="#41098783">prev</a><span>|</span><a href="#41097399">next</a><span>|</span><label class="collapse" for="c-41097092">[-]</label><label class="expand" for="c-41097092">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for that analysis, very informative!<p>I have not tried to get the best possible performance: at first I wanted to see if it would work at all, and the fact that my first attempt performed really well was a bonus! My main point of interest is strings less than the size of a vector register, and getting rid of the troughs in the throughput chart.<p>You can click through the link to the code at the end of the blog post, which has all the licence details. It is 0BSD or MIT-0 except for the parts written originally for BIND which are MPL-2.0.</div><br/><div id="41097166" class="c"><input type="checkbox" id="c-41097166" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#41096834">root</a><span>|</span><a href="#41097092">parent</a><span>|</span><a href="#41097399">next</a><span>|</span><label class="collapse" for="c-41097166">[-]</label><label class="expand" for="c-41097166">[1 more]</label></div><br/><div class="children"><div class="content">Just to clarify - this was about SWAR version as my interest, similar to what you mentioned in a sibling comment, is in mainly below-vector-width strings, because these are most frequently passed to these kinds of functions by developers. I was going to try to see if it can further &quot;amortize&quot; the jump table with fallthrough for variable lengths below 16 in my C# UTF-8 string implementation that is going to use it.<p>In any case, thanks for writing the article, for some reason there is quite a bit of negativity among users and developers towards AVX512 - it is seen as &quot;AVX2 but twice as wide&quot;, which it of course isn&#x27;t, but most do not know that.<p>Also, you may want to simply do the overlapping conversion for the tail instead of masking out the elements, which is usually faster on the benchmarks (at least give it a try), and also align the source and destination for the loop to avoid split loads&#x2F;stores.</div><br/></div></div></div></div></div></div><div id="41097399" class="c"><input type="checkbox" id="c-41097399" checked=""/><div class="controls bullet"><span class="by">bonyt</span><span>|</span><a href="#41096834">prev</a><span>|</span><a href="#41096864">next</a><span>|</span><label class="collapse" for="c-41097399">[-]</label><label class="expand" for="c-41097399">[1 more]</label></div><br/><div class="children"><div class="content">See also, <a href="https:&#x2F;&#x2F;github.com&#x2F;Daniel-Liu-c0deb0t&#x2F;uwu">https:&#x2F;&#x2F;github.com&#x2F;Daniel-Liu-c0deb0t&#x2F;uwu</a><p>Using SIMD for making text into … uwu.</div><br/></div></div><div id="41096864" class="c"><input type="checkbox" id="c-41096864" checked=""/><div class="controls bullet"><span class="by">ipunchghosts</span><span>|</span><a href="#41097399">prev</a><span>|</span><a href="#41097023">next</a><span>|</span><label class="collapse" for="c-41096864">[-]</label><label class="expand" for="c-41096864">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m lost,  what is swar?</div><br/><div id="41096950" class="c"><input type="checkbox" id="c-41096950" checked=""/><div class="controls bullet"><span class="by">singron</span><span>|</span><a href="#41096864">parent</a><span>|</span><a href="#41096876">next</a><span>|</span><label class="collapse" for="c-41096950">[-]</label><label class="expand" for="c-41096950">[1 more]</label></div><br/><div class="children"><div class="content">&quot;SIMD Within A Register&quot;<p>I think the implication is that you can pack multiple items into an ordinary register and effectively get SIMD even if you aren&#x27;t using explicit SIMD instructions. E.g. if you pack a 31 and 32 bit number into a 64 bit register (you need 1 spare for a carry bit), you can do 2 adds with a single 64-bit add.<p>Games have used these tricks for graphics to pack RGB(A) values into 32 bit integers. E.g. this code from scummvm interpolates 2 16-bit RGB pixels (6 total components) packed into a 32-bit value. <a href="https:&#x2F;&#x2F;github.com&#x2F;scummvm&#x2F;scummvm&#x2F;blob&#x2F;master&#x2F;graphics&#x2F;scaler&#x2F;intern.h">https:&#x2F;&#x2F;github.com&#x2F;scummvm&#x2F;scummvm&#x2F;blob&#x2F;master&#x2F;graphics&#x2F;scal...</a></div><br/></div></div><div id="41096876" class="c"><input type="checkbox" id="c-41096876" checked=""/><div class="controls bullet"><span class="by">paulryanrogers</span><span>|</span><a href="#41096864">parent</a><span>|</span><a href="#41096950">prev</a><span>|</span><a href="#41096885">next</a><span>|</span><label class="collapse" for="c-41096876">[-]</label><label class="expand" for="c-41096876">[1 more]</label></div><br/><div class="children"><div class="content">SIMD within a register</div><br/></div></div></div></div><div id="41097023" class="c"><input type="checkbox" id="c-41097023" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#41096864">prev</a><span>|</span><a href="#41097260">next</a><span>|</span><label class="collapse" for="c-41097023">[-]</label><label class="expand" for="c-41097023">[7 more]</label></div><br/><div class="children"><div class="content">...you know, while I personally think that the RISC approach was an honest mistake, stuff like this makes me see why some people wanted to got rid of complex instructions.<p>Well, supposedly RISC-V implementations will have none of this malarkey while still rivaling x64&#x2F;ARM64 in processing speed at comparable technology&#x2F;clock rates&#x2F;prices, just with plain old loads-and-xors-and-stores?</div><br/><div id="41098478" class="c"><input type="checkbox" id="c-41098478" checked=""/><div class="controls bullet"><span class="by">Tuna-Fish</span><span>|</span><a href="#41097023">parent</a><span>|</span><a href="#41097060">next</a><span>|</span><label class="collapse" for="c-41098478">[-]</label><label class="expand" for="c-41098478">[1 more]</label></div><br/><div class="children"><div class="content">Complicated vector instructions like these are not really antithetical to RISC.<p>The core of modern RISC thought is basically: &quot;The laws of physics mean that no matter how much hardware you throw at it, only some kinds of instructions can be implemented in a performant way. We should only include these kinds of instructions in the instruction set.&quot; Then you build more complex operations out of these simple building blocks, but the fact that every instruction provided can be reasonably implemented to run really fast, the CPU itself can be fast.<p>Masked vector adds belong in the set of instructions that can be implemented to be fast, and that&#x27;s why they are included in the RVV RISC-V extension. An example of an instruction that cannot be implemented to be fast would be the humble x86 load+add, where you first look up a value in memory, and then add it to a register. The only reasonable way to implement this to be fast is to just split it into two separate operations which are also dispatched separately, and that is precisely what modern x86 does.</div><br/></div></div><div id="41097060" class="c"><input type="checkbox" id="c-41097060" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#41097023">parent</a><span>|</span><a href="#41098478">prev</a><span>|</span><a href="#41097082">next</a><span>|</span><label class="collapse" for="c-41097060">[-]</label><label class="expand" for="c-41097060">[1 more]</label></div><br/><div class="children"><div class="content">RISC-V does have RVV, which similarly can do SIMD, has masking, but also has a vector length separate from masks: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;rrEW85snh" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;rrEW85snh</a>. Complete with its own set of ~40000 C intrinsics (<a href="https:&#x2F;&#x2F;dzaima.github.io&#x2F;intrinsics-viewer" rel="nofollow">https:&#x2F;&#x2F;dzaima.github.io&#x2F;intrinsics-viewer</a>).<p>Though, granted, RVV is significantly more uniform than AVX-512 (albeit at the cost of not having some useful goodies).</div><br/></div></div><div id="41097082" class="c"><input type="checkbox" id="c-41097082" checked=""/><div class="controls bullet"><span class="by">pca006132</span><span>|</span><a href="#41097023">parent</a><span>|</span><a href="#41097060">prev</a><span>|</span><a href="#41097150">next</a><span>|</span><label class="collapse" for="c-41097082">[-]</label><label class="expand" for="c-41097082">[1 more]</label></div><br/><div class="children"><div class="content">RISC-V has SIMD extension as well. Even when there is no SIMD, prefetching or instruction selection&#x2F;scheduling will have a big impact on the performance, so it is unlikely one can easily write a few lines of assembly and get to a similar level of performance.</div><br/></div></div><div id="41097150" class="c"><input type="checkbox" id="c-41097150" checked=""/><div class="controls bullet"><span class="by">dralley</span><span>|</span><a href="#41097023">parent</a><span>|</span><a href="#41097082">prev</a><span>|</span><a href="#41097260">next</a><span>|</span><label class="collapse" for="c-41097150">[-]</label><label class="expand" for="c-41097150">[3 more]</label></div><br/><div class="children"><div class="content">Do the RISC-V vector instructions cover the whole gamut that x86 does?  (or at least the modern AVX-512 &#x2F; AVX-10 coding style)</div><br/><div id="41097187" class="c"><input type="checkbox" id="c-41097187" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#41097023">root</a><span>|</span><a href="#41097150">parent</a><span>|</span><a href="#41097260">next</a><span>|</span><label class="collapse" for="c-41097187">[-]</label><label class="expand" for="c-41097187">[2 more]</label></div><br/><div class="children"><div class="content">RVV has: masking for everything (though for things like loop tail handling (or even main body) using VL is better and much nicer); all the usual int &amp; FP widths; indexed (gather &amp; scatter) &amp; strided &amp; segmented loads &amp; stores (all potentially masked); all operations support all types where at all possible - including integer division of all widths, and three sign variations for the high half of the 128-bit result of a 64-bit int multiply; And (of course) has 8-bit shifts, which AVX-512 somehow doesn&#x27;t have.<p>All while being scalable, i.e. minimum vector register width (VLEN) is 128-bit for the &#x27;v&#x27; extension, but hardware can implement up to 65536-bit vectors (and software can choose to either pretend they&#x27;re 128-bit, or can be written such that it portably scales automatically); and if you want more than 128 bits portably there&#x27;s LMUL, allowing grouping registers up to 8 in a group, giving up to at-least-1024-bit registers.<p>For shuffles it has vrgather, which supports all element width lookups and can move any element to any other element (yes, including at LMUL=8, though as you can imagine it can be expected to slow down quadratically with LMUL; and could even become a problem at LMUL=1 for hardware with large VLEN, whenever that becomes a thing).</div><br/><div id="41097226" class="c"><input type="checkbox" id="c-41097226" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#41097023">root</a><span>|</span><a href="#41097187">parent</a><span>|</span><a href="#41097260">next</a><span>|</span><label class="collapse" for="c-41097226">[-]</label><label class="expand" for="c-41097226">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for those details, it sounds like it should be very nice for short strings, and more like SVE than AVX</div><br/></div></div></div></div></div></div></div></div><div id="41097260" class="c"><input type="checkbox" id="c-41097260" checked=""/><div class="controls bullet"><span class="by">xyst</span><span>|</span><a href="#41097023">prev</a><span>|</span><a href="#41096726">next</a><span>|</span><label class="collapse" for="c-41097260">[-]</label><label class="expand" for="c-41097260">[5 more]</label></div><br/><div class="children"><div class="content">Now account for Unicode characters (ie, Â -&gt; â) and I’ll be impressed.<p>Shame most programmers only care about ASCII. There is a whole world that exists outside of the standard [a-z,A-Z,0-9] character set</div><br/><div id="41098104" class="c"><input type="checkbox" id="c-41098104" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#41097260">parent</a><span>|</span><a href="#41096726">next</a><span>|</span><label class="collapse" for="c-41098104">[-]</label><label class="expand" for="c-41098104">[4 more]</label></div><br/><div class="children"><div class="content">He wrote about tolower(), not towlower()&#x2F;wcslwr().</div><br/><div id="41098284" class="c"><input type="checkbox" id="c-41098284" checked=""/><div class="controls bullet"><span class="by">Brananarchy</span><span>|</span><a href="#41097260">root</a><span>|</span><a href="#41098104">parent</a><span>|</span><a href="#41098179">prev</a><span>|</span><a href="#41096726">next</a><span>|</span><label class="collapse" for="c-41098284">[-]</label><label class="expand" for="c-41098284">[2 more]</label></div><br/><div class="children"><div class="content">C tolower() is locale aware and handles utf-8 as well as many other encodings</div><br/><div id="41098635" class="c"><input type="checkbox" id="c-41098635" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#41097260">root</a><span>|</span><a href="#41098284">parent</a><span>|</span><a href="#41096726">next</a><span>|</span><label class="collapse" for="c-41098635">[-]</label><label class="expand" for="c-41098635">[1 more]</label></div><br/><div class="children"><div class="content">It can only handle single-byte character sets, not UTF-8</div><br/></div></div></div></div></div></div></div></div><div id="41096726" class="c"><input type="checkbox" id="c-41096726" checked=""/><div class="controls bullet"><span class="by">kolbe</span><span>|</span><a href="#41097260">prev</a><span>|</span><label class="collapse" for="c-41096726">[-]</label><label class="expand" for="c-41096726">[8 more]</label></div><br/><div class="children"><div class="content">Did you try something like this? The autovectorizer looks pretty clean to me.<p><a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;1c5joKK5n" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;1c5joKK5n</a></div><br/><div id="41096790" class="c"><input type="checkbox" id="c-41096790" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#41096726">parent</a><span>|</span><label class="collapse" for="c-41096790">[-]</label><label class="expand" for="c-41096790">[7 more]</label></div><br/><div class="children"><div class="content">That’s basically the same as `tolower1` - see the bullet points below the graph</div><br/><div id="41096914" class="c"><input type="checkbox" id="c-41096914" checked=""/><div class="controls bullet"><span class="by">kolbe</span><span>|</span><a href="#41096726">root</a><span>|</span><a href="#41096790">parent</a><span>|</span><label class="collapse" for="c-41096914">[-]</label><label class="expand" for="c-41096914">[6 more]</label></div><br/><div class="children"><div class="content">Well, the conundrum sits with the fact that this is the disassembly of the main loop:<p><pre><code>        vmovdqu64       zmm3, zmmword ptr [rdi + rcx]
        vmovdqu64       zmm4, zmmword ptr [rdi + rcx + 64]
        vmovdqu64       zmm5, zmmword ptr [rdi + rcx + 128]
        vmovdqu64       zmm6, zmmword ptr [rdi + rcx + 192]
        vpaddb  zmm7, zmm3, zmm0
        vpaddb  zmm8, zmm4, zmm0
        vpaddb  zmm9, zmm5, zmm0
        vpaddb  zmm10, zmm6, zmm0
        vpcmpltub       k1, zmm7, zmm1
        vpcmpltub       k2, zmm8, zmm1
        vpcmpltub       k3, zmm9, zmm1
        vpcmpltub       k4, zmm10, zmm1
        vpaddb  zmm3 {k1}, zmm3, zmm2
        vpaddb  zmm4 {k2}, zmm4, zmm2
        vpaddb  zmm5 {k3}, zmm5, zmm2
        vpaddb  zmm6 {k4}, zmm6, zmm2
        vmovdqu64       zmmword ptr [rdi + rcx], zmm3
        vmovdqu64       zmmword ptr [rdi + rcx + 64], zmm4
        vmovdqu64       zmmword ptr [rdi + rcx + 128], zmm5
        vmovdqu64       zmmword ptr [rdi + rcx + 192], zmm6
</code></pre>
...which is, upon first glance, is similar to yet better than the intrinsics version you wrote. Additionally it has cleaner tail handling.</div><br/><div id="41097044" class="c"><input type="checkbox" id="c-41097044" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#41096726">root</a><span>|</span><a href="#41096914">parent</a><span>|</span><a href="#41097183">next</a><span>|</span><label class="collapse" for="c-41097044">[-]</label><label class="expand" for="c-41097044">[4 more]</label></div><br/><div class="children"><div class="content">The tail handling is the main point of the post. The tolower1 line on the chart is very spiky because the autovectorizer doesn’t use masked loads and stores for tails, and instead does something slower that tanks performance. The tolower64 line is smoother and rises faster because masked loads and stores make it easier to handle strings shorter than the vector size.</div><br/><div id="41097671" class="c"><input type="checkbox" id="c-41097671" checked=""/><div class="controls bullet"><span class="by">kolbe</span><span>|</span><a href="#41096726">root</a><span>|</span><a href="#41097044">parent</a><span>|</span><a href="#41097183">next</a><span>|</span><label class="collapse" for="c-41097671">[-]</label><label class="expand" for="c-41097671">[3 more]</label></div><br/><div class="children"><div class="content">There is something to be said for using masking load&#x2F;stores instead of downgrading the SIMD register types. But to my eye, something is clearly wrong with your code in such a way that the &quot;naive&quot; autovectorized version should be blowing yours out of the water at 256B. Your code leaves a sparse instruction pipeline, and thus needs to run through the loop 4 times for every one of the autovectorized version. So, something is wrong here, as far as I know. I was just trying to make sure you&#x27;d covered the basics, like ensuring you were targeting the right architecture with your build and whatnot.<p>This is yours. Basically the same instructions, but taking up way more space:<p><pre><code>        vmovdqu64       zmm3, zmmword ptr [rsi]
        vpaddb  zmm4, zmm3, zmm0
        vpcmpltub       k1, zmm4, zmm1
        vpaddb  zmm3 {k1}, zmm3, zmm2
        vmovdqu64       zmmword ptr [rdi], zmm3</code></pre></div><br/><div id="41097737" class="c"><input type="checkbox" id="c-41097737" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#41096726">root</a><span>|</span><a href="#41097671">parent</a><span>|</span><a href="#41097183">next</a><span>|</span><label class="collapse" for="c-41097737">[-]</label><label class="expand" for="c-41097737">[2 more]</label></div><br/><div class="children"><div class="content">Unrolling on AVX-512, especially on Zen 4 with its double-pumped almost-everything, isn&#x27;t particularly significant; the 512-bit store alone has a reciprocal throughput of 2 cycles&#x2F;zmm, which gives a pretty comfortable best possible target of 2 cycles&#x2F;iteration. With Zen 4 being 6-wide out of the op cache, that&#x27;s fine for up to 12 instructions in the loop (and with separate ports for scalar &amp; SIMD, the per-iteration scalar op overhead is irrelevant).<p>Interestingly enough, clang 16 doesn&#x27;t unroll the intrinsics version, but trunk does, which&#x27;d make the entire point moot.<p>The benchmark in question, as per the article, tests over 1MB in blocks, so it&#x27;ll be at L2 or L3 speeds anyway.<p>Clang downgrades to ymm, which&#x27;ll handle a 32-byte tail, but after that it does a plain scalar loop, up to a massive 31 iterations. Whereas masking appears to be approximately free on Zen 4, so I&#x27;d be surprised if the scalar tail would be better at even, like, 4 bytes (perhaps there could be some minor throughput gained by splitting up into optional unmasked ymm and then a masked ymm, but even that&#x27;s probably questionable just from the extra logic&#x2F;decode overhead).<p>Also worth considering that in real-world usage the masking version could be significantly better just from being branchless for up to 64-byte inputs.</div><br/><div id="41098484" class="c"><input type="checkbox" id="c-41098484" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#41096726">root</a><span>|</span><a href="#41097737">parent</a><span>|</span><a href="#41097183">next</a><span>|</span><label class="collapse" for="c-41098484">[-]</label><label class="expand" for="c-41098484">[1 more]</label></div><br/><div class="children"><div class="content">Yeah the spikes in the “tolower1” line illustrate the 32 byte tail pretty nicely.<p>I should maybe draw a version of the chart covering just small strings, but it’s an SVG so you can zoom right in. The “tolower1” line shows relatively poor performance compared to “tolower64”, tho it is hard to see for strings less than 8 bytes.</div><br/></div></div></div></div></div></div></div></div><div id="41097183" class="c"><input type="checkbox" id="c-41097183" checked=""/><div class="controls bullet"><span class="by">harry8</span><span>|</span><a href="#41096726">root</a><span>|</span><a href="#41096914">parent</a><span>|</span><a href="#41097044">prev</a><span>|</span><label class="collapse" for="c-41097183">[-]</label><label class="expand" for="c-41097183">[1 more]</label></div><br/><div class="children"><div class="content">The autovectorizer can, at times, when you check it produce reasonable simd code with a given compiler based on simple, clear C code. Is gcc as good in this case? Are previous versions of clang (that may be employed by users) going to work out as well. How do you check in your build that the compiler did the right thing? If you touch the C code in any way will it silently do something you don&#x27;t want?<p>Autovectorization <i>is</i> great and improving.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>