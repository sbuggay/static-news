<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1722697058039" as="style"/><link rel="stylesheet" href="styles.css?v=1722697058039"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.redox-os.org/news/kernel-11/">Towards userspaceification of POSIX – part I: signal handling and IO</a> <span class="domain">(<a href="https://www.redox-os.org">www.redox-os.org</a>)</span></div><div class="subtext"><span>akyuu</span> | <span>37 comments</span></div><br/><div><div id="41143396" class="c"><input type="checkbox" id="c-41143396" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#41143115">next</a><span>|</span><label class="collapse" for="c-41143396">[-]</label><label class="expand" for="c-41143396">[26 more]</label></div><br/><div class="children"><div class="content">&gt; POSIX allows file descriptors to be shared by an arbitrary number of processes, after e.g. forks or SCM_RIGHTS transfers (even though this use case is most likely very rare, so it’s not entirely impossible for this state to be moved to userspace).<p>Normally it’s rare, except shell functionality crucially depends on it[1].<p>The way to think about this, IMO, is that while a disk file is more or less random-access, when you open it unavoidably turns into strange hybrid of a random-access byte array and a (seekable) byte stream (classically, the “file description”), and <i>that</i> is what the resulting fd and any of its copies point at. Seekable streams made some sense in the age of tape drives, but nowadays it seems to me that random-access files and non-seekable streams have enough of a gulf between them that forcing both to appear like the same kind of object is more confusing than helpful.<p>(I don’t know what my ideal world would look like, given I still like to direct streams from&#x2F;to files. I still dislike the “file description” business rather strongly.)<p>[1] <a href="https:&#x2F;&#x2F;utcc.utoronto.ca&#x2F;~cks&#x2F;space&#x2F;blog&#x2F;unix&#x2F;DupSharedOffsetNecessary" rel="nofollow">https:&#x2F;&#x2F;utcc.utoronto.ca&#x2F;~cks&#x2F;space&#x2F;blog&#x2F;unix&#x2F;DupSharedOffse...</a></div><br/><div id="41145616" class="c"><input type="checkbox" id="c-41145616" checked=""/><div class="controls bullet"><span class="by">4lDO2</span><span>|</span><a href="#41143396">parent</a><span>|</span><a href="#41143741">next</a><span>|</span><label class="collapse" for="c-41145616">[-]</label><label class="expand" for="c-41145616">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m aware of this example, this was discussed earlier on HN [1]. I think it would be reasonable to (try to) enforce O_APPEND in such scenarios, in which case libc might internally open a pipe (configured to passively or actively be flushed to the underlying file, non-concurrently). A pipe would also be more reliable (and secure, though programs in shell pipelines are usually trusted), since it&#x27;s no longer possible for isolated programs to change the global cursor, which could overwrite other processes&#x27; written data.<p>[1] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38009458">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38009458</a><p>Also, I feel like you are misquoting me, by not including the whole sentence (judging from the subcomments). I implied shared fds <i>with shared cursors</i> are probably a rare use cases, not shared fds in general (as you explained later on). Shared fds, and especially the ability to send fds, are obviously very fundamental for Unix-like systems, and for moving towards capability-oriented security.</div><br/><div id="41146569" class="c"><input type="checkbox" id="c-41146569" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#41143396">root</a><span>|</span><a href="#41145616">parent</a><span>|</span><a href="#41143741">next</a><span>|</span><label class="collapse" for="c-41146569">[-]</label><label class="expand" for="c-41146569">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, cutting the sentence that way evidently did not work out, sorry. For posterity:<p>&gt; This cursor unfortunately cannot be stored in userspace without complex coordination, since POSIX allows file descriptors to be shared by an arbitrary number of processes, after e.g. forks or SCM_RIGHTS transfers (even though this use case is most likely very rare, so it’s not entirely impossible for this state to be moved to userspace).</div><br/></div></div></div></div><div id="41143741" class="c"><input type="checkbox" id="c-41143741" checked=""/><div class="controls bullet"><span class="by">seeknotfind</span><span>|</span><a href="#41143396">parent</a><span>|</span><a href="#41145616">prev</a><span>|</span><a href="#41144404">next</a><span>|</span><label class="collapse" for="c-41143741">[-]</label><label class="expand" for="c-41143741">[12 more]</label></div><br/><div class="children"><div class="content">Ah! Well as a systems programmer, it&#x27;s not so rare. FDs are really not a friendly interface, and I&#x27;d love a better interface (FDs have their quirks), but as an application programmer, it&#x27;s really sad we don&#x27;t take advantage of FD passing to build more modular programs. For instance on desktop operating systems, you pass paths, not capabilities to use files, and the norm is giving programs access to read large swaths of user data. This is not secure, and it&#x27;s one of the issues well-passed FDs could help solve. In general, despite the challenges in making them secure, I&#x27;d strongly advocate for more modular and integrated applications.<p>As for the seeking abstraction, it fits well with other buffered device driver information streams. Yes, it&#x27;s a complicated and confusing interface, but the key thing is it allows you to share an OS&#x2F;system&#x2F;hardware level resource between multiple programs. We want to take advantage of that. It&#x27;s the abstraction we&#x27;ve got sure, but it&#x27;s what we do with it that counts!</div><br/><div id="41146051" class="c"><input type="checkbox" id="c-41146051" checked=""/><div class="controls bullet"><span class="by">the8472</span><span>|</span><a href="#41143396">root</a><span>|</span><a href="#41143741">parent</a><span>|</span><a href="#41144801">next</a><span>|</span><label class="collapse" for="c-41146051">[-]</label><label class="expand" for="c-41146051">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but as an application programmer, it&#x27;s really sad we don&#x27;t take advantage of FD passing to build more modular programs.<p>For that programming languages need better unix socket (with SCM_RIGHTS) and directory-handle (openat &amp; co) support. And of course windows does things differently so getting a portable abstraction would be difficult.</div><br/></div></div><div id="41144801" class="c"><input type="checkbox" id="c-41144801" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#41143396">root</a><span>|</span><a href="#41143741">parent</a><span>|</span><a href="#41146051">prev</a><span>|</span><a href="#41143841">next</a><span>|</span><label class="collapse" for="c-41144801">[-]</label><label class="expand" for="c-41144801">[3 more]</label></div><br/><div class="children"><div class="content">&gt; As for the seeking abstraction, it fits well with other buffered device driver information streams. Yes, it&#x27;s a complicated and confusing interface, but the key thing is it allows you to share an OS&#x2F;system&#x2F;hardware level resource between multiple programs.<p>As someone who has only dabbled in OS-level programming but recently had a use case that the seek interface seemed to work well for (parsing a file format that heavily used offsets to reference other parts of the data), I&#x27;m super curious about what you think the &quot;complicated and confusing&quot; parts of the interface are. (To be clear, I&#x27;m not doubting you; I&#x27;m asking because I suspect that my understanding might be more surface-level than I thought and there are probably some pitfalls that I might not be aware of!) Offhand, the only parts that seemed potentially confusing to me are the mix of signed and unsigned integers depending on the offset type (not sure if this was specific to the Rust implementation, but it used signed integers for relative offsets and unsigned for absolute offsets, which makes sense but maybe isn&#x27;t something people would expect) and the fact that it&#x27;s valid to seek past the end of a file (which I didn&#x27;t need for my use case), but are there other subtleties that I didn&#x27;t think of?</div><br/><div id="41145905" class="c"><input type="checkbox" id="c-41145905" checked=""/><div class="controls bullet"><span class="by">thinkharderdev</span><span>|</span><a href="#41143396">root</a><span>|</span><a href="#41144801">parent</a><span>|</span><a href="#41143841">next</a><span>|</span><label class="collapse" for="c-41145905">[-]</label><label class="expand" for="c-41145905">[2 more]</label></div><br/><div class="children"><div class="content">Not the OP but the complicated part to me is just that the fd has a global cursor which makes concurrent access require synchronization. The rust std::fs::File API at least makes this clear through mutability requirements but I imagine in other languages this either can cause a lot of bugs or requires a more complicated API to surface the functionality safely.</div><br/><div id="41146485" class="c"><input type="checkbox" id="c-41146485" checked=""/><div class="controls bullet"><span class="by">4lDO2</span><span>|</span><a href="#41143396">root</a><span>|</span><a href="#41145905">parent</a><span>|</span><a href="#41143841">next</a><span>|</span><label class="collapse" for="c-41146485">[-]</label><label class="expand" for="c-41146485">[1 more]</label></div><br/><div class="children"><div class="content">Rust does however implement the IO traits for `&amp;File` as well (shared), and IIRC also implements `try_clone` which is the dup equivalent.</div><br/></div></div></div></div></div></div><div id="41143841" class="c"><input type="checkbox" id="c-41143841" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#41143396">root</a><span>|</span><a href="#41143741">parent</a><span>|</span><a href="#41144801">prev</a><span>|</span><a href="#41144016">next</a><span>|</span><label class="collapse" for="c-41143841">[-]</label><label class="expand" for="c-41143841">[2 more]</label></div><br/><div class="children"><div class="content">I have nothing against FD passing, and indeed agree it’s unfortunate we don’t do more of it. An (almost-)everything-is-a-string (shell) language with object-capability powers is still something I’d like to figure out someday. The Lisp-2-ish way Tcl object systems approach this feels interesting, but still a bit off from a real solution.<p>My reading of TFA was that it’s rare for it to be important that descriptors sharing a description thus also share a file position. And shell-like redirection use cases really are the only case I can think of where that’s important.<p>&gt; As for the seeking abstraction, it fits well with other buffered device driver information streams.<p>I don’t think I understand what you’re getting at here. My point was that having some objects (fds, whatever) support {fstat, read&#x2F;write} only and others {fstat, pread&#x2F;pwrite, mmap} only would get rid of the confusing user-visible notion of “file description”. Obviously I don’t expect this to happen, but it’s still nice to dream.</div><br/><div id="41144660" class="c"><input type="checkbox" id="c-41144660" checked=""/><div class="controls bullet"><span class="by">tbrownaw</span><span>|</span><a href="#41143396">root</a><span>|</span><a href="#41143841">parent</a><span>|</span><a href="#41144016">next</a><span>|</span><label class="collapse" for="c-41144660">[-]</label><label class="expand" for="c-41144660">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>My reading of TFA was that it’s rare for it to be important that descriptors sharing a description thus also share a file position.</i><p>It reads like this was an assumption rather than an observation.<p>&gt; <i>And shell-like redirection use cases really are the only case I can think of where that’s important.</i><p>.xsession-errors , or really anything of that nature where a process tree shares an error log file on stderr.</div><br/></div></div></div></div><div id="41144016" class="c"><input type="checkbox" id="c-41144016" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#41143396">root</a><span>|</span><a href="#41143741">parent</a><span>|</span><a href="#41143841">prev</a><span>|</span><a href="#41144404">next</a><span>|</span><label class="collapse" for="c-41144016">[-]</label><label class="expand" for="c-41144016">[5 more]</label></div><br/><div class="children"><div class="content">On desktop Unix, D-Bus provides a friendlier interface to send file descriptors than sendmsg.</div><br/><div id="41145080" class="c"><input type="checkbox" id="c-41145080" checked=""/><div class="controls bullet"><span class="by">astrobe_</span><span>|</span><a href="#41143396">root</a><span>|</span><a href="#41144016">parent</a><span>|</span><a href="#41144279">next</a><span>|</span><label class="collapse" for="c-41145080">[-]</label><label class="expand" for="c-41145080">[2 more]</label></div><br/><div class="children"><div class="content">APIs are&#x2F;were designed for completeness more than friendliness. Speaking of <i>sendmsg</i>, the whole BSD socket API is plain horrible; it only takes a couple of uses to realize that you never want to use it directly again; you either make your own library on top of it, or a class, or whatever form of code reuse the language deems appropriate.</div><br/><div id="41146635" class="c"><input type="checkbox" id="c-41146635" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#41143396">root</a><span>|</span><a href="#41145080">parent</a><span>|</span><a href="#41144279">next</a><span>|</span><label class="collapse" for="c-41146635">[-]</label><label class="expand" for="c-41146635">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the whole BSD socket API is plain horrible; it only takes a couple of uses to realize that you never want to use it directly again<p>That was my initial impression as well, but recently I’ve had to use it again and surprisingly did not find as bad as I remembered. Except, indeed, for the fd-passing experience, for which see my wrapper elsewhere in the thread (also other sideband stuff, but how often do you really need SCM_CREDENTIALS?).<p>The syscall&#x2F;kernel-ABI people seem to love it as well—I remember reading an article that praised it for remaining so stable over its lifetime. I think these are actually two sides of the same coin: BSD sockets essentially layer a second ABI on top of C function invocations. It’s a tad more specific than generic ioctl-ish (selector, payload), but not that much, and the farther away you are from the happy path of send()&#x2F;recv(), the closer it is to that (and the more extension capability the kernel programmer wants, and the more misery the userland programmer feels).<p>The Unix approach of exposing syscalls from libc essentially directly was a nice thought, but the sockets API feels like a reductio ad absurdum of it.</div><br/></div></div></div></div><div id="41144279" class="c"><input type="checkbox" id="c-41144279" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#41143396">root</a><span>|</span><a href="#41144016">parent</a><span>|</span><a href="#41145080">prev</a><span>|</span><a href="#41145778">next</a><span>|</span><label class="collapse" for="c-41144279">[-]</label><label class="expand" for="c-41144279">[1 more]</label></div><br/><div class="children"><div class="content">Going straight to D-Bus feels excessive. Here&#x27;s an 85-line file I had lying around that should cover most cases of FD passing: <a href="https:&#x2F;&#x2F;paste.rs&#x2F;6FBFS.c" rel="nofollow">https:&#x2F;&#x2F;paste.rs&#x2F;6FBFS.c</a>.</div><br/></div></div><div id="41145778" class="c"><input type="checkbox" id="c-41145778" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#41143396">root</a><span>|</span><a href="#41144016">parent</a><span>|</span><a href="#41144279">prev</a><span>|</span><a href="#41144404">next</a><span>|</span><label class="collapse" for="c-41145778">[-]</label><label class="expand" for="c-41145778">[1 more]</label></div><br/><div class="children"><div class="content">Only because it wraps sendmsg in a nicer API at the language level - something you could also do with raw sendmsg.</div><br/></div></div></div></div></div></div><div id="41144404" class="c"><input type="checkbox" id="c-41144404" checked=""/><div class="controls bullet"><span class="by">Cloudef</span><span>|</span><a href="#41143396">parent</a><span>|</span><a href="#41143741">prev</a><span>|</span><a href="#41143541">next</a><span>|</span><label class="collapse" for="c-41144404">[-]</label><label class="expand" for="c-41144404">[1 more]</label></div><br/><div class="children"><div class="content">Linux has had plan9 namespaces for long time which you can use from userspace as well. With this you can give a process isolated view of the filesystem, network etc ..<p>Unfortunately not enabled on AWS lambda runner &lt;<a href="https:&#x2F;&#x2F;github.com&#x2F;aws&#x2F;aws-lambda-base-images&#x2F;issues&#x2F;143">https:&#x2F;&#x2F;github.com&#x2F;aws&#x2F;aws-lambda-base-images&#x2F;issues&#x2F;143</a>&gt;</div><br/></div></div><div id="41143541" class="c"><input type="checkbox" id="c-41143541" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#41143396">parent</a><span>|</span><a href="#41144404">prev</a><span>|</span><a href="#41143625">next</a><span>|</span><label class="collapse" for="c-41143541">[-]</label><label class="expand" for="c-41143541">[5 more]</label></div><br/><div class="children"><div class="content">absolutely right re. shells, there&#x27;s a lot in core old unix that depends on dup and a lot from the 90s&#x2F;00s that depends on dup2 as well, with all the pain in the butt that it comes with (for multi-threaded and userspace implementors).<p>readat and friends are certainly becoming more popular in various domains, particularly as they&#x27;re cheaper in highly parallel programs avoiding the locking on seeks, and avoiding the stalls on mappings (unless you can afford gigantic &#x2F; up-front &amp; static mappings). At this point what we really need is thread independent mapping solutions, a solution to request a mapping be bound to a thread, and the ability to also pass that around. Mapping will never be free, but if we can avoid whole process stalls and giant mapping pressure both of which are painfully common today that&#x27;s a big step forward.</div><br/><div id="41144477" class="c"><input type="checkbox" id="c-41144477" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#41143396">root</a><span>|</span><a href="#41143541">parent</a><span>|</span><a href="#41143625">next</a><span>|</span><label class="collapse" for="c-41144477">[-]</label><label class="expand" for="c-41144477">[4 more]</label></div><br/><div class="children"><div class="content">How would that work in practice? Each thread has their own memory map, but with one shared branch where all the normal process-global virtual memory is mapped, and a non-shared branch for per-thread virtual memory?<p>Seems like there&#x27;s the potential for surprise, accidental overlapping of non-shared VM mappings. But I guess this is purely a performance thing; caveat emptor, etc....<p>How easy would that be to hack into Linux&#x27;s existing page table structures?</div><br/><div id="41144941" class="c"><input type="checkbox" id="c-41144941" checked=""/><div class="controls bullet"><span class="by">Veserv</span><span>|</span><a href="#41143396">root</a><span>|</span><a href="#41144477">parent</a><span>|</span><a href="#41143625">next</a><span>|</span><label class="collapse" for="c-41144941">[-]</label><label class="expand" for="c-41144941">[3 more]</label></div><br/><div class="children"><div class="content">That is not how MMUs work, so it would go very poorly.<p>MMUs expect a tree. You can not give them “Tree A, except at Node N substitute a different sub-tree”. To have a different sub-tree, you must have a different root. However, you can share sub-trees amongst different trees.<p>To do what you are expecting, you would actually want multiple <i>processes</i> with their own mappings&#x2F;tree and you would share a substantial common&#x2F;shared mapping&#x2F;sub-tree. The difficulty there is making sure all the processes are aware of the common sub-tree and properly share and synchronize with it.</div><br/><div id="41145449" class="c"><input type="checkbox" id="c-41145449" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#41143396">root</a><span>|</span><a href="#41144941">parent</a><span>|</span><a href="#41143625">next</a><span>|</span><label class="collapse" for="c-41145449">[-]</label><label class="expand" for="c-41145449">[2 more]</label></div><br/><div class="children"><div class="content">Yeah per thread virtual memory is called a process. Within a process the memory manager has to maintain a single virtual address space. You could do it with a red black tree and a global lock. Or you could use potentially cleverer algorithms. Skip lists are friendly to scalable concurrency. You could also do a radix tree of page tables, similar to what x86-64 processors do internally, then have each item be its own atomic long, and use some kind of optimistic transactional locking strategy when allocating mappings that span multiple pages. Personally, I think the rbtree is easiest, since it&#x27;s better to leave memory scalability to malloc(). The way I like to make malloc() scale is having an arena for each CPU and then indexing them using sched_getcpu().</div><br/><div id="41145781" class="c"><input type="checkbox" id="c-41145781" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#41143396">root</a><span>|</span><a href="#41145449">parent</a><span>|</span><a href="#41143625">next</a><span>|</span><label class="collapse" for="c-41145781">[-]</label><label class="expand" for="c-41145781">[1 more]</label></div><br/><div class="children"><div class="content">The Linux kernel actually doesn&#x27;t know the difference between a thread and a process. The clone syscall (which starts a new thread) takes a bitmask specifying what should be shared between the parent and child (e.g. address space, open files, thread group ID (what most people call a process ID))</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41144537" class="c"><input type="checkbox" id="c-41144537" checked=""/><div class="controls bullet"><span class="by">XorNot</span><span>|</span><a href="#41143396">parent</a><span>|</span><a href="#41143625">prev</a><span>|</span><a href="#41143733">next</a><span>|</span><label class="collapse" for="c-41144537">[-]</label><label class="expand" for="c-41144537">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know that I see the practical difference here: a seekable stream and a random access byte array are one very thin abstraction away from each other, with the important caveat that a stream can represent a byte array which is being appended to while you&#x27;re using it.</div><br/><div id="41146533" class="c"><input type="checkbox" id="c-41146533" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#41143396">root</a><span>|</span><a href="#41144537">parent</a><span>|</span><a href="#41145149">next</a><span>|</span><label class="collapse" for="c-41146533">[-]</label><label class="expand" for="c-41146533">[1 more]</label></div><br/><div class="children"><div class="content">As long as only one thread of execution is using it, yes, there’s essentially no difference.<p>When it’s shared between several, though, seekable streams become annoying (and difficult to impossible to use correctly). When the sharing spans process boundaries, we get the well-known bane of microkernel Unices that TFA describes—you need every file position for every Unix process to be (at least potentially) tracked by a single systemwide “Unix server”. That’s a lot of pain for not a lot of win.<p>My point was that I can’t think of any non-niche thing that’s naturally a <i>seekable</i> stream—they’re usually either nonseekable or outright random-access. Tape was the natural example when the API was invented, but it is niche now.</div><br/></div></div><div id="41145149" class="c"><input type="checkbox" id="c-41145149" checked=""/><div class="controls bullet"><span class="by">layla5alive</span><span>|</span><a href="#41143396">root</a><span>|</span><a href="#41144537">parent</a><span>|</span><a href="#41146533">prev</a><span>|</span><a href="#41143733">next</a><span>|</span><label class="collapse" for="c-41145149">[-]</label><label class="expand" for="c-41145149">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s true in serial computations, but not true in concurrent ones - the abstraction now includes mutual exclusion in the stream case, and does not require it in the array case.</div><br/></div></div></div></div><div id="41143733" class="c"><input type="checkbox" id="c-41143733" checked=""/><div class="controls bullet"><span class="by">nolist_policy</span><span>|</span><a href="#41143396">parent</a><span>|</span><a href="#41144537">prev</a><span>|</span><a href="#41143115">next</a><span>|</span><label class="collapse" for="c-41143733">[-]</label><label class="expand" for="c-41143733">[1 more]</label></div><br/><div class="children"><div class="content">Passing around fd&#x27;s via unix sockets is important for sandboxing in e.g. Chrome and Firefox.</div><br/></div></div></div></div><div id="41143115" class="c"><input type="checkbox" id="c-41143115" checked=""/><div class="controls bullet"><span class="by">tom_</span><span>|</span><a href="#41143396">prev</a><span>|</span><a href="#41144914">next</a><span>|</span><label class="collapse" for="c-41143115">[-]</label><label class="expand" for="c-41143115">[3 more]</label></div><br/><div class="children"><div class="content">Those who understand Unix are condemned to reproduce it exactly.</div><br/><div id="41145601" class="c"><input type="checkbox" id="c-41145601" checked=""/><div class="controls bullet"><span class="by">Aerbil313</span><span>|</span><a href="#41143115">parent</a><span>|</span><a href="#41144914">next</a><span>|</span><label class="collapse" for="c-41145601">[-]</label><label class="expand" for="c-41145601">[2 more]</label></div><br/><div class="children"><div class="content">Which is why the next OS might be written by younglings who know little to nothing about &quot;modern&quot; OSes and just design from first principles, instead of being beholden to a gigantic historical architecture debt.<p>We&#x27;re still running on kernels written in 1990. Time for an upgrade?</div><br/><div id="41145692" class="c"><input type="checkbox" id="c-41145692" checked=""/><div class="controls bullet"><span class="by">blueflow</span><span>|</span><a href="#41143115">root</a><span>|</span><a href="#41145601">parent</a><span>|</span><a href="#41144914">next</a><span>|</span><label class="collapse" for="c-41145692">[-]</label><label class="expand" for="c-41145692">[1 more]</label></div><br/><div class="children"><div class="content">Communicating using a protocol from the 90ies, using a network stack from the 80ies, running an CPU architecture from the 70ies.<p>Being old and being unsuitable for its purpose are orthogonal.</div><br/></div></div></div></div></div></div><div id="41144914" class="c"><input type="checkbox" id="c-41144914" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41143115">prev</a><span>|</span><a href="#41144724">next</a><span>|</span><label class="collapse" for="c-41144914">[-]</label><label class="expand" for="c-41144914">[2 more]</label></div><br/><div class="children"><div class="content">Why emulate POSIX signal semantics? Those are a holdover from the single-thread UNIX era. Events should be delivered by threads or async calls. Signals should be reserved for exceptions, things you don&#x27;t return to, like segfaults.</div><br/><div id="41145658" class="c"><input type="checkbox" id="c-41145658" checked=""/><div class="controls bullet"><span class="by">4lDO2</span><span>|</span><a href="#41144914">parent</a><span>|</span><a href="#41144724">next</a><span>|</span><label class="collapse" for="c-41145658">[-]</label><label class="expand" for="c-41145658">[1 more]</label></div><br/><div class="children"><div class="content">The rationale was discussed in-depth earlier on LWN (<a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;982186&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;982186&#x2F;</a>).<p>Signals are useful as a software analogue to hardware interrupts, even though they are probably too low-level for most application use cases. They are for example used by the Golang runtime to preempt threads AFAIU, which wouldn&#x27;t otherwise be possible non-cooperatively. Intel even included an ISA extension called user-IPIs, which is similar to signals.</div><br/></div></div></div></div><div id="41144724" class="c"><input type="checkbox" id="c-41144724" checked=""/><div class="controls bullet"><span class="by">tbrownaw</span><span>|</span><a href="#41144914">prev</a><span>|</span><a href="#41145021">next</a><span>|</span><label class="collapse" for="c-41144724">[-]</label><label class="expand" for="c-41144724">[2 more]</label></div><br/><div class="children"><div class="content">Would shared pipes not have approximately the same issue wrt file positions being shared state? A process group (cron job, systemd service) sharing a pipe for error output is probably a bit more common than directly having an on-disk file.</div><br/><div id="41145424" class="c"><input type="checkbox" id="c-41145424" checked=""/><div class="controls bullet"><span class="by">4lDO2</span><span>|</span><a href="#41144724">parent</a><span>|</span><a href="#41145021">next</a><span>|</span><label class="collapse" for="c-41145424">[-]</label><label class="expand" for="c-41145424">[1 more]</label></div><br/><div class="children"><div class="content">Pipes lack a file cursor, but they still need to store the fcntl file description flags, so yes. This is emulated by the Redox kernel for old schemes, by inserting fcntl calls between the legacy read&#x2F;write calls that don&#x27;t allow passing the offset and flags. However, I&#x27;d argue that the fcntl flags are even more client-oriented than the cursor, say, O_NONBLOCK. Should it really be possible for isolated processes to set each others&#x27; nonblock flag (unless using preadv2&#x2F;pwritev2 which is non-POSIX)?</div><br/></div></div></div></div><div id="41145021" class="c"><input type="checkbox" id="c-41145021" checked=""/><div class="controls bullet"><span class="by">up2isomorphism</span><span>|</span><a href="#41144724">prev</a><span>|</span><a href="#41144707">next</a><span>|</span><label class="collapse" for="c-41145021">[-]</label><label class="expand" for="c-41145021">[2 more]</label></div><br/><div class="children"><div class="content">This is very typical rust project. Trying to change the old world while tightly following the old world in a very unimaginative way.<p>Maybe too much memory safety is bad for creativity?</div><br/></div></div></div></div></div></div></div></body></html>