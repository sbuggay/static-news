<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1717664465038" as="style"/><link rel="stylesheet" href="styles.css?v=1717664465038"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://laurent.le-brun.eu/blog/an-overview-of-starlark">An Overview of the Starlark Language</a> <span class="domain">(<a href="https://laurent.le-brun.eu">laurent.le-brun.eu</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>31 comments</span></div><br/><div><div id="40592926" class="c"><input type="checkbox" id="c-40592926" checked=""/><div class="controls bullet"><span class="by">jez</span><span>|</span><a href="#40593651">next</a><span>|</span><label class="collapse" for="c-40592926">[-]</label><label class="expand" for="c-40592926">[12 more]</label></div><br/><div class="children"><div class="content">The biggest feature I want out of Starlark the language (not Bazel the build system) is to allow optional type annotations. They don’t have to do anything, they don’t have to specified, it just needs to be syntactically valid to put type annotations somewhere. If there were syntax for type annotations that tools like Bazel ignored, it would be possible for some enterprising soul who’s forced to use Bazel at work to throw up an initial prototype of a type checker and a language server for Starlark in Bazel. The language is not that complicated that a type checker couldn’t be written by a hobbiest.<p>My biggest frustration when using Bazel is not even Bazel—it’s the fact that when I’m looking at code like this[1], everything comes from a single, unannotated `rctx` variable that has no type annotation. So when I’m trying to read the code, it’s a matter of constantly grepping the repo, grepping the bazel docs, and grepping the bazel source code to get any new code written.<p>Why can’t I just hover and see the docs? Why can’t I press `rctx.` and see all the attributes available?<p>I frequently hear “why do you need types? the language is Turing complete just run it and see if it fails” but that misses the point that I have want to use types to guide what code to write in the first place.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;bazel-contrib&#x2F;toolchains_llvm&#x2F;blob&#x2F;master&#x2F;toolchain&#x2F;internal&#x2F;configure.bzl#L59">https:&#x2F;&#x2F;github.com&#x2F;bazel-contrib&#x2F;toolchains_llvm&#x2F;blob&#x2F;master...</a></div><br/><div id="40595084" class="c"><input type="checkbox" id="c-40595084" checked=""/><div class="controls bullet"><span class="by">laurentlb</span><span>|</span><a href="#40592926">parent</a><span>|</span><a href="#40593781">next</a><span>|</span><label class="collapse" for="c-40595084">[-]</label><label class="expand" for="c-40595084">[1 more]</label></div><br/><div class="children"><div class="content">This is something that came up multiple times. I think type information is especially valuable in combination with other IDE features (code completion).<p>My idea was to do type checking in a separate tool (e.g. built on top of Buildifier) and let the interpreter ignore the types. So it could be completely optional. The type system could be gradual, like in Typescript.<p>I don&#x27;t know when&#x2F;if it will happen (I&#x27;m no longer working at Google, so it&#x27;s harder to make large contributions like this).</div><br/></div></div><div id="40593781" class="c"><input type="checkbox" id="c-40593781" checked=""/><div class="controls bullet"><span class="by">smeenai</span><span>|</span><a href="#40592926">parent</a><span>|</span><a href="#40595084">prev</a><span>|</span><a href="#40593076">next</a><span>|</span><label class="collapse" for="c-40593781">[-]</label><label class="expand" for="c-40593781">[1 more]</label></div><br/><div class="children"><div class="content">starlark-rust (used by Buck2) supports this! They&#x27;re immensely useful for grokking complex build code, as you said. <a href="https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;starlark-rust&#x2F;blob&#x2F;main&#x2F;docs&#x2F;types.md">https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;starlark-rust&#x2F;blob&#x2F;main&#x2F;docs&#x2F;typ...</a></div><br/></div></div><div id="40593076" class="c"><input type="checkbox" id="c-40593076" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#40592926">parent</a><span>|</span><a href="#40593781">prev</a><span>|</span><a href="#40594531">next</a><span>|</span><label class="collapse" for="c-40593076">[-]</label><label class="expand" for="c-40593076">[7 more]</label></div><br/><div class="children"><div class="content">A type system is a very good thing, but it directly contradicts one of the goals for this language, simplicity. As someone who has written type inference code for plain Hindley-Milner type systems and those with subtyping, I can tell you this is very much an open research problem.<p>Inferred types, understandable type errors, expressive language: choose two out of three. If you sacrifice good type inference and require users to specify type annotations themselves they will not like it especially considering users&#x27; mental model of this language comes from Python; if you sacrifice understandable type errors, users will reject the whole system as soon as they encounter a type error; if you sacrifice expressiveness you are taking away features users want like subtyping.<p>If you want something that&#x27;s ignored by Bazel and only used by some other tools you already have it: docstrings. You can enforce docstrings to be of a certain format and contain type annotations. Be the solution you want to see: be that hobbyist that writes a type checker and language server.</div><br/><div id="40594089" class="c"><input type="checkbox" id="c-40594089" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40592926">root</a><span>|</span><a href="#40593076">parent</a><span>|</span><a href="#40594423">next</a><span>|</span><label class="collapse" for="c-40594089">[-]</label><label class="expand" for="c-40594089">[5 more]</label></div><br/><div class="children"><div class="content">I don’t get this argument as it seems at odds with the existence proof of Python itself having optional typing, type inference, understandable type errors and an expressive language. What am I missing?</div><br/><div id="40594205" class="c"><input type="checkbox" id="c-40594205" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#40592926">root</a><span>|</span><a href="#40594089">parent</a><span>|</span><a href="#40594423">next</a><span>|</span><label class="collapse" for="c-40594205">[-]</label><label class="expand" for="c-40594205">[4 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s an elementary litmus test that anyone slightly experienced with type systems will know.<p>How do you type the omega combinator in Python?<p><pre><code>    lambda x: x(x)
</code></pre>
What about the application of the omega combinator to itself?<p><pre><code>    (lambda x: x(x))(lambda x: x(x))
</code></pre>
How do you type the Y combinator in Python?<p><pre><code>    lambda f: (lambda x: f(x(x)))(lambda x: f(x(x)))
</code></pre>
Depending on the choice of the type system you can either answer: this cannot be assigned a type in which case your type system is too weak to express many real-world programs, or it does have a type but then your type system is so sophisticated that people using this language (just for writing BUILD rules) won&#x27;t be able to understand type errors in this type system. I have yet to find a middle ground.<p>In case you claim this is impractical functional programming, bear in mind you can write the same thing using classes in object-oriented programming.<p>---<p>Okay let&#x27;s not even talk about these weird-looking &quot;combinators&quot; even though they have a rich history. Consider this function:<p><pre><code>    lambda x: {&#x27;this&#x27;: x, &#x27;next&#x27;: x + 1}
</code></pre>
What is its type? Again the answer depends on plenty of choices that need to be made by the type system designer. Do you force dictionaries to have a single type for values? If so, many users used to Python will reject your system for being too inflexible. If not, will you now introduce row polymorphism in your type system? Will you now introduce depth subtyping and width subtyping in your type system? (For example if a function only needs field &#x27;x&#x27; in a dictionary but the caller passes a dictionary with both fields &#x27;x&#x27; and &#x27;y&#x27; should not result in an error; that&#x27;s why you need subtyping.) Now let&#x27;s consider the lowly plus operator. In real Python the plus operator can work on integers, floats, strings, sets, etc. Let&#x27;s say your type inference algorithm uses the RHS to find that x must be an integer. But that&#x27;s wrong; it could still be a float. Can you now write a type for that expression? Hint: it involves record types, intersection types, type variables and other things that would not be comprehensible.</div><br/><div id="40594315" class="c"><input type="checkbox" id="c-40594315" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40592926">root</a><span>|</span><a href="#40594205">parent</a><span>|</span><a href="#40594423">next</a><span>|</span><label class="collapse" for="c-40594315">[-]</label><label class="expand" for="c-40594315">[3 more]</label></div><br/><div class="children"><div class="content">This seems like a very weird technical explanation that doesn’t actually address my question. Python typing works well in practice and doesn’t suffer from any of the problems you listed.<p>Also, from a brief investigation, according to [1] Haskell also isn’t able to express the omega combinator in its type system (&amp; indeed the answer says very few type systems are able to do so). This suggests this is a very bad litmus test if almost no languages can actually pass it even though a) languages exist with explainable type errors b) the languages are general purpose and fairly expressive c) they support type inference. An obvious example of this is Rust.<p>[1] <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;33546004&#x2F;is-it-possible-to-define-omega-combinator-%CE%BBx-xx-in-modern-haskell" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;33546004&#x2F;is-it-possible-...</a></div><br/><div id="40594338" class="c"><input type="checkbox" id="c-40594338" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#40592926">root</a><span>|</span><a href="#40594315">parent</a><span>|</span><a href="#40594423">next</a><span>|</span><label class="collapse" for="c-40594338">[-]</label><label class="expand" for="c-40594338">[2 more]</label></div><br/><div class="children"><div class="content">You have a different definition of &quot;works well&quot; and also a different definition of &quot;type inference&quot; here. Rust doesn&#x27;t have global type inference. C++&#x27;s `auto` doesn&#x27;t count. Go&#x27;s `:=` syntax doesn&#x27;t count.<p>Why not? Because you are adding typing retroactively to a dynamically typed language like Python. If a language was built with typing, you can do this because your initial choice of a type system already constrains the set of valid programs. But a Python-like language where users are already used to having no restrictions on runtime types? Absolutely not. Especially not in a language that encourages duck typing. Let&#x27;s go back to the omega combinator example. The Stack Overflow link is correct: Haskell cannot assign a type to it. That means the type system is purposefully designed weak enough that the omega combinator cannot be written in the first place! No valid Haskell program has it! Therefore you can totally disregard it. Python is different. You can already write the omega combinator in it. I wrote it three times in this thread. So a bolt-on type system needs to assign a type to it. And you can&#x27;t.<p>Python does not have a type system that &quot;works well&quot; and will never have one.</div><br/><div id="40594933" class="c"><input type="checkbox" id="c-40594933" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40592926">root</a><span>|</span><a href="#40594338">parent</a><span>|</span><a href="#40594423">next</a><span>|</span><label class="collapse" for="c-40594933">[-]</label><label class="expand" for="c-40594933">[1 more]</label></div><br/><div class="children"><div class="content">I think the disagreement is about what “works well” means. You are approaching it from some kind of theoretical purity whereas most people approach it from the perspective of “works for every program I am likely to encounter”. Omega combinators aren’t an example of something typically written in Python. I think you’re making a similar decision about global type inference as the only “true” definition of type inference when clearly more limited type inference already adds a significant amount of utility &amp; there’s not typically that much lost in an inability to avoid typing functions - it’s a bit inconvenient in some places, but overall acts as a way to define the explicit contract between the method body and the rest of the code which makes errors faster to spot and the language compile more quickly.<p>You are correct that the holy grail you’re trying to reach is impossible, but relaxing some constraints still yields a heck of a lot of practical benefit.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40594531" class="c"><input type="checkbox" id="c-40594531" checked=""/><div class="controls bullet"><span class="by">Turskarama</span><span>|</span><a href="#40592926">parent</a><span>|</span><a href="#40593076">prev</a><span>|</span><a href="#40594223">next</a><span>|</span><label class="collapse" for="c-40594531">[-]</label><label class="expand" for="c-40594531">[1 more]</label></div><br/><div class="children"><div class="content">A type system that doesn&#x27;t do anything? It has that, it&#x27;s called comments.
Before you try to tell me that it&#x27;s somehow different, consider that the main thing a type system has to be for consistency is accurate.  If they types aren&#x27;t checked by a compiler or interpreter, then someone can change the way the variable is assigned or what the function will work with, and the annotation will just be wrong.</div><br/></div></div><div id="40594223" class="c"><input type="checkbox" id="c-40594223" checked=""/><div class="controls bullet"><span class="by">fire_lake</span><span>|</span><a href="#40592926">parent</a><span>|</span><a href="#40594531">prev</a><span>|</span><a href="#40593651">next</a><span>|</span><label class="collapse" for="c-40594223">[-]</label><label class="expand" for="c-40594223">[1 more]</label></div><br/><div class="children"><div class="content">Given that “types” are passed around like values in Bazel this may prove complicated to support.</div><br/></div></div></div></div><div id="40593651" class="c"><input type="checkbox" id="c-40593651" checked=""/><div class="controls bullet"><span class="by">ajayvk</span><span>|</span><a href="#40592926">prev</a><span>|</span><a href="#40593787">next</a><span>|</span><label class="collapse" for="c-40593651">[-]</label><label class="expand" for="c-40593651">[1 more]</label></div><br/><div class="children"><div class="content">I used go-starlark[1] to build a configurable reverse proxy and container manager for web app deployment [2]. Starlark is used to configure the proxy and it can be used to actually implement the backend apis.<p>One challenge with Starlark was not having exceptions, which by itself is a good thing. But not having go-style multi-value returns in Starlark makes error handling verbose. Since the errors originate in plugin calls to go code, the solution I implemented was a thread-local to store the last error and handle that on the next plugin call if the error was not explicitly handled in the code [3]. Worked out pretty well in my test apps. For example, this app [4] implements a bookmark manager, with minimal error handling required in the code.<p>Starlark is great for adding dynamic behavior for go applications. I was worried about performance when I started but perf has not been a concern in the context of a web app server.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;starlark-go">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;starlark-go</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;claceio&#x2F;clace">https:&#x2F;&#x2F;github.com&#x2F;claceio&#x2F;clace</a><p>[3] <a href="https:&#x2F;&#x2F;clace.io&#x2F;docs&#x2F;plugins&#x2F;overview&#x2F;#automatic-error-handling" rel="nofollow">https:&#x2F;&#x2F;clace.io&#x2F;docs&#x2F;plugins&#x2F;overview&#x2F;#automatic-error-hand...</a><p>[4] <a href="https:&#x2F;&#x2F;github.com&#x2F;claceio&#x2F;apps&#x2F;blob&#x2F;main&#x2F;utils&#x2F;bookmarks&#x2F;app.star">https:&#x2F;&#x2F;github.com&#x2F;claceio&#x2F;apps&#x2F;blob&#x2F;main&#x2F;utils&#x2F;bookmarks&#x2F;ap...</a></div><br/></div></div><div id="40593787" class="c"><input type="checkbox" id="c-40593787" checked=""/><div class="controls bullet"><span class="by">abpavel</span><span>|</span><a href="#40593651">prev</a><span>|</span><a href="#40592562">next</a><span>|</span><label class="collapse" for="c-40593787">[-]</label><label class="expand" for="c-40593787">[1 more]</label></div><br/><div class="children"><div class="content">This is a powerful and flexible configuration language that blends Pythonic syntax with sandboxed execution, making it ideal for large-scale build systems like Bazel. Its deterministic and reproducible nature is a boon for developers seeking reliability and consistency in their builds.</div><br/></div></div><div id="40592562" class="c"><input type="checkbox" id="c-40592562" checked=""/><div class="controls bullet"><span class="by">i_am_a_peasant</span><span>|</span><a href="#40593787">prev</a><span>|</span><a href="#40593895">next</a><span>|</span><label class="collapse" for="c-40592562">[-]</label><label class="expand" for="c-40592562">[5 more]</label></div><br/><div class="children"><div class="content">I never felt before that I am wasting brain cells as much as when I have to do something in bazel. The hermecicity thing it does relatively well but god does the documentation suck, at some point you can only get farther if you just read the java code implementing it...</div><br/><div id="40592707" class="c"><input type="checkbox" id="c-40592707" checked=""/><div class="controls bullet"><span class="by">danpalmer</span><span>|</span><a href="#40592562">parent</a><span>|</span><a href="#40592910">next</a><span>|</span><label class="collapse" for="c-40592707">[-]</label><label class="expand" for="c-40592707">[1 more]</label></div><br/><div class="children"><div class="content">I think bazel is only worthwhile when you are big enough to have a team that builds and maintains the bazel setup in a company&#x2F;team. At Google it works fantastically, but I&#x27;ve also tried putting it into a project from scratch and it was too much.</div><br/></div></div><div id="40592910" class="c"><input type="checkbox" id="c-40592910" checked=""/><div class="controls bullet"><span class="by">dilyevsky</span><span>|</span><a href="#40592562">parent</a><span>|</span><a href="#40592707">prev</a><span>|</span><a href="#40592589">next</a><span>|</span><label class="collapse" for="c-40592910">[-]</label><label class="expand" for="c-40592910">[2 more]</label></div><br/><div class="children"><div class="content">It’s been many years since last time i had to do anything in bazel’s java code. Most warts have been massively improved and only require occasional starlark hack or the right incantation of flags. The docs are honestly not too bad but the system is so massive and deals with so much inherent complexity that it always going to be missing <i>something</i></div><br/><div id="40593276" class="c"><input type="checkbox" id="c-40593276" checked=""/><div class="controls bullet"><span class="by">kajecounterhack</span><span>|</span><a href="#40592562">root</a><span>|</span><a href="#40592910">parent</a><span>|</span><a href="#40592589">next</a><span>|</span><label class="collapse" for="c-40593276">[-]</label><label class="expand" for="c-40593276">[1 more]</label></div><br/><div class="children"><div class="content">This is my experience too. Just waiting for bzlmod to finally be supported by all the commonly used libraries. Looking at you, gRPC.</div><br/></div></div></div></div><div id="40592589" class="c"><input type="checkbox" id="c-40592589" checked=""/><div class="controls bullet"><span class="by">benreesman</span><span>|</span><a href="#40592562">parent</a><span>|</span><a href="#40592910">prev</a><span>|</span><a href="#40593895">next</a><span>|</span><label class="collapse" for="c-40592589">[-]</label><label class="expand" for="c-40592589">[1 more]</label></div><br/><div class="children"><div class="content">Cheat codes breaking Bazel 7’s sandbox: ‘cd -P’.<p>sudo give me my files.</div><br/></div></div></div></div><div id="40593895" class="c"><input type="checkbox" id="c-40593895" checked=""/><div class="controls bullet"><span class="by">yegle</span><span>|</span><a href="#40592562">prev</a><span>|</span><a href="#40594380">next</a><span>|</span><label class="collapse" for="c-40593895">[-]</label><label class="expand" for="c-40593895">[1 more]</label></div><br/><div class="children"><div class="content">I have a hobby project that forwards qBittorent&#x27;s logs to Telegram in Go, and uses Starlark to configure the filtering rules without hard coding the expression in Go. Pretty trivial to implement using the Go implementation of Starlark.</div><br/></div></div><div id="40594380" class="c"><input type="checkbox" id="c-40594380" checked=""/><div class="controls bullet"><span class="by">tripdout</span><span>|</span><a href="#40593895">prev</a><span>|</span><a href="#40593356">next</a><span>|</span><label class="collapse" for="c-40594380">[-]</label><label class="expand" for="c-40594380">[3 more]</label></div><br/><div class="children"><div class="content">How do they guarantee both deterministic results and parallelism?</div><br/><div id="40595125" class="c"><input type="checkbox" id="c-40595125" checked=""/><div class="controls bullet"><span class="by">laurentlb</span><span>|</span><a href="#40594380">parent</a><span>|</span><a href="#40594783">next</a><span>|</span><label class="collapse" for="c-40595125">[-]</label><label class="expand" for="c-40595125">[1 more]</label></div><br/><div class="children"><div class="content">The evaluation of a file happens in a single thread.<p>At the end of the file evaluation, Starlark exports the values and functions defined in the file. All values are frozen, meaning they won&#x27;t ever be mutated.<p>Since no shared object can be modified, you can have any number of threads reading the object. So you can safely evaluate many files in parallel.<p>Caveat: this assumes the interpreter doesn&#x27;t expose functions like reading&#x2F;writing on a disk, etc.</div><br/></div></div><div id="40594783" class="c"><input type="checkbox" id="c-40594783" checked=""/><div class="controls bullet"><span class="by">rockwotj</span><span>|</span><a href="#40594380">parent</a><span>|</span><a href="#40595125">prev</a><span>|</span><a href="#40593356">next</a><span>|</span><label class="collapse" for="c-40594783">[-]</label><label class="expand" for="c-40594783">[1 more]</label></div><br/><div class="children"><div class="content">Determinism: via sandboxing builds, it’s a little leaky by default (but getting better). See <a href="https:&#x2F;&#x2F;bazel.build&#x2F;basics&#x2F;hermeticity" rel="nofollow">https:&#x2F;&#x2F;bazel.build&#x2F;basics&#x2F;hermeticity</a><p>Parallelism: Easier with sandboxing, but the build declares all inputs&#x2F;outputs so it builds a merkle tree and strictly inforces a DAG. This way you can parallelize independent subgraphs and cache at a fine grained level.</div><br/></div></div></div></div><div id="40593356" class="c"><input type="checkbox" id="c-40593356" checked=""/><div class="controls bullet"><span class="by">travisgriggs</span><span>|</span><a href="#40594380">prev</a><span>|</span><a href="#40592482">next</a><span>|</span><label class="collapse" for="c-40593356">[-]</label><label class="expand" for="c-40593356">[1 more]</label></div><br/><div class="children"><div class="content">I rtfa excited to learn about another uPython in the “embedded” space. Alas, they meant embedded in a different way. Wish we had better terms for different variants of embedded.</div><br/></div></div><div id="40592482" class="c"><input type="checkbox" id="c-40592482" checked=""/><div class="controls bullet"><span class="by">jacknews</span><span>|</span><a href="#40593356">prev</a><span>|</span><label class="collapse" for="c-40592482">[-]</label><label class="expand" for="c-40592482">[6 more]</label></div><br/><div class="children"><div class="content">&quot;Some people might say it’s a bit like Lua with Python syntax&quot;<p>ye gods</div><br/><div id="40592583" class="c"><input type="checkbox" id="c-40592583" checked=""/><div class="controls bullet"><span class="by">benreesman</span><span>|</span><a href="#40592482">parent</a><span>|</span><label class="collapse" for="c-40592583">[-]</label><label class="expand" for="c-40592583">[5 more]</label></div><br/><div class="children"><div class="content">I can appreciate that it might not sound that appetizing but it’s really pretty good.<p>I worked on the original Buck and kind of caught the “principled and performant polyglot build system” bug and I’ve been diving down that rabbit hole since.<p>There are still usability and adoption challenges, but it’s the future and between buck2 and bazel7&#x2F;bzlmod the gap to slow, non-deterministic alternatives is closing fast.<p>I wouldn’t write it off.</div><br/><div id="40592882" class="c"><input type="checkbox" id="c-40592882" checked=""/><div class="controls bullet"><span class="by">__float</span><span>|</span><a href="#40592482">root</a><span>|</span><a href="#40592583">parent</a><span>|</span><a href="#40593912">next</a><span>|</span><label class="collapse" for="c-40592882">[-]</label><label class="expand" for="c-40592882">[3 more]</label></div><br/><div class="children"><div class="content">Why do you call out bzlmod? I haven&#x27;t heard great things about it.</div><br/><div id="40593937" class="c"><input type="checkbox" id="c-40593937" checked=""/><div class="controls bullet"><span class="by">benreesman</span><span>|</span><a href="#40592482">root</a><span>|</span><a href="#40592882">parent</a><span>|</span><a href="#40593903">next</a><span>|</span><label class="collapse" for="c-40593937">[-]</label><label class="expand" for="c-40593937">[1 more]</label></div><br/><div class="children"><div class="content">To the extent there’s a real issue with ‘MODULE.bazel’ (aka bzlmod), it’s that Bazel has such a rich ecosystem even on the old, janky ‘WORKSPACE’-style that the slick new thing that always works is impossible to migrate in one go.<p>The Bazel team flags things off by default for years, and then things on for years, because they’re engineers and try hard not to break people’s shit.<p>Are feature flags and migration paths and interim solutions more work? Yeah, no doubt.<p>But for all their recent fumbles in AI and steadily downward trajectory on search and all the things that happens when a big company is run by people who were never all that technical?<p>Google still has a hard core of the baddest hackers you don’t want to mess with.</div><br/></div></div><div id="40593903" class="c"><input type="checkbox" id="c-40593903" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#40592482">root</a><span>|</span><a href="#40592882">parent</a><span>|</span><a href="#40593937">prev</a><span>|</span><a href="#40593912">next</a><span>|</span><label class="collapse" for="c-40593903">[-]</label><label class="expand" for="c-40593903">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m happy with bzlmod.<p>What I hate about it is that not every bazel ruleset I use has yet been ported to it. But it&#x27;s getting there.<p>For example in my monorepo I&#x27;m only missing rule_distroless and I migrated all my deps to bzlmod.<p>The modules lock file situation has been greatly improved since 7.2.0-rc1. The lock file contains much less digests in it and its less likely to cause spurious merge conflicts<p>With bazelisk and .bazelversion we managed to have everybody use the same version of bazel and thus we could cheaply try out the rc1 and so far is working fine.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>