<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1708592470782" as="style"/><link rel="stylesheet" href="styles.css?v=1708592470782"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.chosenplaintext.ca/articles/beginners-guide-constant-time-cryptography.html">A beginner&#x27;s guide to constant-time cryptography (2017)</a> <span class="domain">(<a href="https://www.chosenplaintext.ca">www.chosenplaintext.ca</a>)</span></div><div class="subtext"><span>histories</span> | <span>14 comments</span></div><br/><div><div id="39464730" class="c"><input type="checkbox" id="c-39464730" checked=""/><div class="controls bullet"><span class="by">mratsim</span><span>|</span><a href="#39464417">next</a><span>|</span><label class="collapse" for="c-39464730">[-]</label><label class="expand" for="c-39464730">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve written and given a lot of references to attacks, countermeasures, fighting the compilers and even non-cryptographic side-channel attacks to uncover someone&#x27;s Twitter identity:<p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;mratsim&#x2F;constantine&#x2F;wiki&#x2F;Constant-time-arithmetics">https:&#x2F;&#x2F;github.com&#x2F;mratsim&#x2F;constantine&#x2F;wiki&#x2F;Constant-time-ar...</a></div><br/></div></div><div id="39464417" class="c"><input type="checkbox" id="c-39464417" checked=""/><div class="controls bullet"><span class="by">bananaflag</span><span>|</span><a href="#39464730">prev</a><span>|</span><a href="#39464702">next</a><span>|</span><label class="collapse" for="c-39464417">[-]</label><label class="expand" for="c-39464417">[11 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t you just hash the keys before comparing them?</div><br/><div id="39464548" class="c"><input type="checkbox" id="c-39464548" checked=""/><div class="controls bullet"><span class="by">histories</span><span>|</span><a href="#39464417">parent</a><span>|</span><a href="#39464754">prev</a><span>|</span><a href="#39464702">next</a><span>|</span><label class="collapse" for="c-39464548">[-]</label><label class="expand" for="c-39464548">[9 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the difference between a plaintext key and a hash in this context?<p>&gt;The attacker can crack the first byte of the key by trying all 256 possibilities, and observing which one caused the comparison to take longer.<p>It means that at the end you get the hash and not the key, but it is still a vulnerability</div><br/><div id="39464595" class="c"><input type="checkbox" id="c-39464595" checked=""/><div class="controls bullet"><span class="by">Epa095</span><span>|</span><a href="#39464417">root</a><span>|</span><a href="#39464548">parent</a><span>|</span><a href="#39464635">next</a><span>|</span><label class="collapse" for="c-39464595">[-]</label><label class="expand" for="c-39464595">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I (but I am not not OP) agree that hashing is not absolutely perfect, but it&#x27;s still much much better than leaking the actual password, and it would be cool to at least compare it as a feasible solution.<p>Getting the first character of the hash is trivial, but as you get further and further out you need to do more and more computational work locally to guess a string which will hash to the prefix you already know (given that your hash is secure against Preimage attack). And then at the end you end up with the complete hash, which itself is extremely hard to get anything useful out of. (all of this is given that you use a hash that is resistant to Preimage attack, and preferably salting as well).</div><br/></div></div><div id="39464635" class="c"><input type="checkbox" id="c-39464635" checked=""/><div class="controls bullet"><span class="by">jackjeff</span><span>|</span><a href="#39464417">root</a><span>|</span><a href="#39464548">parent</a><span>|</span><a href="#39464595">prev</a><span>|</span><a href="#39464570">next</a><span>|</span><label class="collapse" for="c-39464635">[-]</label><label class="expand" for="c-39464635">[1 more]</label></div><br/><div class="children"><div class="content">Basically you can figure out the hash using the aforementioned timing attack.<p>You can now perform an offline attack against the password that produced the hash.<p>It’s like you hacked into the database and got the password hashes.<p>Then, you fall back to something like hashcat.<p>If with a bit of luck you just hashed your password with a single round of SHA and did not use something cool like Argon2id then you’re toast. If your password is simple you’re toast too.<p>On the other hand, if you hashed a totally random key, the safety will rely on whether the hashing algorithm itself is constant time or not. You just moved the needle.</div><br/></div></div><div id="39464570" class="c"><input type="checkbox" id="c-39464570" checked=""/><div class="controls bullet"><span class="by">yellow_lead</span><span>|</span><a href="#39464417">root</a><span>|</span><a href="#39464548">parent</a><span>|</span><a href="#39464635">prev</a><span>|</span><a href="#39464702">next</a><span>|</span><label class="collapse" for="c-39464570">[-]</label><label class="expand" for="c-39464570">[6 more]</label></div><br/><div class="children"><div class="content">If you check hash(a) == hash(b), the attacker cannot produce a valid hash, because cryptographic hash functions are one way. This assumes you use a secure hash function, like not md5.<p>Even if they discover hash(b), they can&#x27;t produce b.</div><br/><div id="39464698" class="c"><input type="checkbox" id="c-39464698" checked=""/><div class="controls bullet"><span class="by">jackjeff</span><span>|</span><a href="#39464417">root</a><span>|</span><a href="#39464570">parent</a><span>|</span><a href="#39464605">next</a><span>|</span><label class="collapse" for="c-39464698">[-]</label><label class="expand" for="c-39464698">[1 more]</label></div><br/><div class="children"><div class="content">What people always forget when they make statements about hashing being one way is that these algorithms are designed to be incredibly fast.<p>So if what you’re hashing has low entropy&#x2F;randomness (say a password) then you can totally brute force it.<p>In fact if there’s not a salt you can look it up in a rainbow table, saving yourself some compute. Googling a hash also works sometimes. If you want to brute force look at hashcat.<p>Something like SHA256 protects about 128 bits of entropy. If you go much lower than that, you’ll be brute forced. You can look at hashcat benchmarks online to estimate the time and money necessary to perform the attack. Anyone can crack an average simple password using a single round of SHA256 in no time.</div><br/></div></div><div id="39464605" class="c"><input type="checkbox" id="c-39464605" checked=""/><div class="controls bullet"><span class="by">histories</span><span>|</span><a href="#39464417">root</a><span>|</span><a href="#39464570">parent</a><span>|</span><a href="#39464698">prev</a><span>|</span><a href="#39464702">next</a><span>|</span><label class="collapse" for="c-39464605">[-]</label><label class="expand" for="c-39464605">[4 more]</label></div><br/><div class="children"><div class="content">If the check is not done in constant time, the attacker can discover hash(b), by trying one byte at a time (without knowing b).<p>Of course it&#x27;s way less impactful than discovering b, but it&#x27;s nonetheless a vulnerability.</div><br/><div id="39464667" class="c"><input type="checkbox" id="c-39464667" checked=""/><div class="controls bullet"><span class="by">ramchip</span><span>|</span><a href="#39464417">root</a><span>|</span><a href="#39464605">parent</a><span>|</span><a href="#39464702">next</a><span>|</span><label class="collapse" for="c-39464667">[-]</label><label class="expand" for="c-39464667">[3 more]</label></div><br/><div class="children"><div class="content">H is a cryptographic hash. You observe via timing that H(&quot;123&quot;) starts with the same byte as H(key). How do you then guess the next byte?<p>Consider what happens to the first byte of the hash if you add a new byte to the input, e.g. &quot;1230&quot;...</div><br/><div id="39464755" class="c"><input type="checkbox" id="c-39464755" checked=""/><div class="controls bullet"><span class="by">histories</span><span>|</span><a href="#39464417">root</a><span>|</span><a href="#39464667">parent</a><span>|</span><a href="#39464702">next</a><span>|</span><label class="collapse" for="c-39464755">[-]</label><label class="expand" for="c-39464755">[2 more]</label></div><br/><div class="children"><div class="content">I just guess the HASH&#x27;s bytes, not the KEY&#x27;s.<p>To be practical: my first guesses are:<p>0000...0000<p>1000...0000<p>2000...0000<p>...<p>f000...0000<p>I discover that c000...0000 takes slightly longer. Then, my next guesses are:<p>c000...0000<p>c100...0000<p>c200...0000<p>...<p>cf00...0000<p>Now I discovered that c700...0000 takes slightly longer...<p>And so on.<p>At the end I have the full hash.<p>Getting the plaintext key from that hash is a different problem.</div><br/><div id="39464773" class="c"><input type="checkbox" id="c-39464773" checked=""/><div class="controls bullet"><span class="by">ramchip</span><span>|</span><a href="#39464417">root</a><span>|</span><a href="#39464755">parent</a><span>|</span><a href="#39464702">next</a><span>|</span><label class="collapse" for="c-39464773">[-]</label><label class="expand" for="c-39464773">[1 more]</label></div><br/><div class="children"><div class="content">[delayed]</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="39464702" class="c"><input type="checkbox" id="c-39464702" checked=""/><div class="controls bullet"><span class="by">Anotheroneagain</span><span>|</span><a href="#39464417">prev</a><span>|</span><label class="collapse" for="c-39464702">[-]</label><label class="expand" for="c-39464702">[1 more]</label></div><br/><div class="children"><div class="content">Why not lock the account for 30 minutes after 6 failed attempts?</div><br/></div></div></div></div></div></div></div></body></html>