<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719824481844" as="style"/><link rel="stylesheet" href="styles.css?v=1719824481844"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://grugq.substack.com/p/userland-rootkits-are-lame">Userland rootkits are lame (2022)</a> <span class="domain">(<a href="https://grugq.substack.com">grugq.substack.com</a>)</span></div><div class="subtext"><span>qweqwe14</span> | <span>41 comments</span></div><br/><div><div id="40843346" class="c"><input type="checkbox" id="c-40843346" checked=""/><div class="controls bullet"><span class="by">grugq</span><span>|</span><a href="#40842311">next</a><span>|</span><label class="collapse" for="c-40843346">[-]</label><label class="expand" for="c-40843346">[2 more]</label></div><br/><div class="children"><div class="content">Author here.<p>The context of this post is somewhat important. It is a direct response to a post titled: <i>Symbiote Deep-Dive: Analysis of a New, Nearly-Impossible-to-Detect Linux Threat</i><p>Userland rootkits are not “<i>nearly-impossible-to-detect</i>.” They are not novel, they are not impossible to detect, and they are not the pinnacle of hacker techniques.<p>I felt that it was worth pointing out that the history of userland rootkits goes back a ways and that they were very easy to detect because they rely on proxying all access to the system. If you bypass the hook they use to enter their proxy, they you evade them entirely.<p>Forensic and incident response guides used to advise using static linked binaries for exactly this reason. There are guides from the 1990s telling people to do this because userland rootkits were an issue (before kernel rootkits everyone used userland rootkits.)<p>Here is an example from 2013 which points out that you can’t trust any binaries&#x2F;libraries on the potentially compromised machine and should use statically linked tools. [0]<p>LD_PRELOAD rootkits are not new and they are not nearly-impossible-to-detect to detect. My post listed a number of ways to detect them, all of which have been known for decades.<p>[0] <a href="https:&#x2F;&#x2F;www.forensicfocus.com&#x2F;forums&#x2F;general&#x2F;trusted-static-linked-binaries-for-linux-live-forensic&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.forensicfocus.com&#x2F;forums&#x2F;general&#x2F;trusted-static-...</a></div><br/><div id="40843828" class="c"><input type="checkbox" id="c-40843828" checked=""/><div class="controls bullet"><span class="by">fullspectrumdev</span><span>|</span><a href="#40843346">parent</a><span>|</span><a href="#40842311">next</a><span>|</span><label class="collapse" for="c-40843828">[-]</label><label class="expand" for="c-40843828">[1 more]</label></div><br/><div class="children"><div class="content">&gt; they rely on proxying all access to the system<p>It’s worth noting that this has a measurable and enormous impact on system performance, because they usually are adding a bunch of strcmp or similar to every incantation of a bunch of different libc calls.</div><br/></div></div></div></div><div id="40842311" class="c"><input type="checkbox" id="c-40842311" checked=""/><div class="controls bullet"><span class="by">mike_d</span><span>|</span><a href="#40843346">prev</a><span>|</span><a href="#40843238">next</a><span>|</span><label class="collapse" for="c-40842311">[-]</label><label class="expand" for="c-40842311">[4 more]</label></div><br/><div class="children"><div class="content">Adversaries live by the saying &quot;if it works it isn&#x27;t stupid.&quot;</div><br/><div id="40843036" class="c"><input type="checkbox" id="c-40843036" checked=""/><div class="controls bullet"><span class="by">lotharcable</span><span>|</span><a href="#40842311">parent</a><span>|</span><a href="#40843238">next</a><span>|</span><label class="collapse" for="c-40843036">[-]</label><label class="expand" for="c-40843036">[3 more]</label></div><br/><div class="children"><div class="content">What they actually did was to implement kernel-level rootkits.<p>This is why things &#x27;secure boot&#x27; and requirement for signed drivers are a thing.</div><br/><div id="40843177" class="c"><input type="checkbox" id="c-40843177" checked=""/><div class="controls bullet"><span class="by">qweqwe14</span><span>|</span><a href="#40842311">root</a><span>|</span><a href="#40843036">parent</a><span>|</span><a href="#40843238">next</a><span>|</span><label class="collapse" for="c-40843177">[-]</label><label class="expand" for="c-40843177">[2 more]</label></div><br/><div class="children"><div class="content">The downside with kernel-level rootkits is you essentially have to compile it for many different kernel versions if you want it to work everywhere. I think I&#x27;ve read about some malware that literally contacted a server, sent the kernel version, and the server would compile the rootkit on demand.</div><br/><div id="40843189" class="c"><input type="checkbox" id="c-40843189" checked=""/><div class="controls bullet"><span class="by">abofh</span><span>|</span><a href="#40842311">root</a><span>|</span><a href="#40843177">parent</a><span>|</span><a href="#40843238">next</a><span>|</span><label class="collapse" for="c-40843189">[-]</label><label class="expand" for="c-40843189">[1 more]</label></div><br/><div class="children"><div class="content">And that&#x27;s service right there - they tried to distribute the most compatible malicious kernel exploits for you, but sometimes you need a bespoke compilation for your system -- and these guys step up and make sure you get one!<p>That&#x27;s customer service, I think a lot of (all of) our trillion dollar overlords could do a thing or to and learn about providing reliable service.</div><br/></div></div></div></div></div></div></div></div><div id="40843238" class="c"><input type="checkbox" id="c-40843238" checked=""/><div class="controls bullet"><span class="by">notepad0x90</span><span>|</span><a href="#40842311">prev</a><span>|</span><a href="#40843197">next</a><span>|</span><label class="collapse" for="c-40843238">[-]</label><label class="expand" for="c-40843238">[3 more]</label></div><br/><div class="children"><div class="content">ld_preload is the lazy way of doing userland rootkits. there are other ways.<p>For example, you can patch libc, and by patch I mean there are different ways of patching. a simply binary patch is unreliable because it&#x27;d be pinned to a specific version but you can parse the elf symbols dynamically and patch them, even when libc is updated (assuming certain critical symbols are unlikely to ever change) so it becomes reliable. a lot of &quot;static&quot; programs still dynamically load libc.<p>There is also a more aggressive but easily detectable approach, just patch every elf file on the system so that that the _start&#x2F;entry  always does <i>something</i> to prevent discovery of the malware like messing with the plt so that all function calls are proxied through rootkit code, where the rootkit filters for parameters and return values it doesn&#x27;t like.<p>Kernel rookits are great but secure boot is also a thing, if implemented correctly it would be very difficult to beat. you don&#x27;t even have to go full on rootkit, just a stealthy implant running as root via a hijacked dynamic library (doesn&#x27;t have to be libc) will do. this isn&#x27;t windows, it&#x27;s not like there is a reliable&#x2F;common way of making sure system libraries are legit (like authenticode&#x2F;pe signing). The package managers make sure the correct binaries are being installed but they don&#x27;t have something like sfc on windows (system file checker) that refuses to let the system boot if files are corrupt and&#x2F;or restore tampered system executables.</div><br/><div id="40843294" class="c"><input type="checkbox" id="c-40843294" checked=""/><div class="controls bullet"><span class="by">grugq</span><span>|</span><a href="#40843238">parent</a><span>|</span><a href="#40843197">next</a><span>|</span><label class="collapse" for="c-40843294">[-]</label><label class="expand" for="c-40843294">[2 more]</label></div><br/><div class="children"><div class="content">Bringing your own static linked busybox will still evade that rootkit.<p>If the attacker has modified the environment to present a specific view of system state, bringing your own environment defeats it.<p>There are tricks which are better than modifying things to hide. For example, there is a race condition between opendir() and readdir() which you can win by using inotify(). Then you can unlink() whatever, wait a while, then link() it back in. During that time it will be deleted and thus invisible to any detection. (I saw a demo of this 12 years ago, so I might be misremembering a bit. I know it used inotify() and unlink())</div><br/><div id="40843595" class="c"><input type="checkbox" id="c-40843595" checked=""/><div class="controls bullet"><span class="by">worthless-trash</span><span>|</span><a href="#40843238">root</a><span>|</span><a href="#40843294">parent</a><span>|</span><a href="#40843197">next</a><span>|</span><label class="collapse" for="c-40843595">[-]</label><label class="expand" for="c-40843595">[1 more]</label></div><br/><div class="children"><div class="content">Not if your running processes infect running userspace processes.</div><br/></div></div></div></div></div></div><div id="40843197" class="c"><input type="checkbox" id="c-40843197" checked=""/><div class="controls bullet"><span class="by">alkonaut</span><span>|</span><a href="#40843238">prev</a><span>|</span><a href="#40842562">next</a><span>|</span><label class="collapse" for="c-40843197">[-]</label><label class="expand" for="c-40843197">[1 more]</label></div><br/><div class="children"><div class="content">If it’s weak, I’d expect a standard distribution to detect it by itself and inform the user.<p>Only revealing itself to a defender who looks for it sounds like it’ll be working as intended in almost all cases.</div><br/></div></div><div id="40842562" class="c"><input type="checkbox" id="c-40842562" checked=""/><div class="controls bullet"><span class="by">rascul</span><span>|</span><a href="#40843197">prev</a><span>|</span><a href="#40842643">next</a><span>|</span><label class="collapse" for="c-40842562">[-]</label><label class="expand" for="c-40842562">[9 more]</label></div><br/><div class="children"><div class="content">Is it really practical to just statically compile everything so you don&#x27;t get a rootkit? Is that really the solution?</div><br/><div id="40842574" class="c"><input type="checkbox" id="c-40842574" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#40842562">parent</a><span>|</span><a href="#40843134">next</a><span>|</span><label class="collapse" for="c-40842574">[-]</label><label class="expand" for="c-40842574">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think that&#x27;s what the article is suggesting. It&#x27;s saying if you suspect a system to be infected you can install some statically-linked tools to diagnose it.</div><br/></div></div><div id="40843134" class="c"><input type="checkbox" id="c-40843134" checked=""/><div class="controls bullet"><span class="by">qweqwe14</span><span>|</span><a href="#40842562">parent</a><span>|</span><a href="#40842574">prev</a><span>|</span><a href="#40842600">next</a><span>|</span><label class="collapse" for="c-40843134">[-]</label><label class="expand" for="c-40843134">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m of the opinion that all systems should at least have a static busybox, it&#x27;s useful for more than just rootkit hunting, for example if you somehow break your installation because of glibc shenanigans (rare but happens)</div><br/></div></div><div id="40842600" class="c"><input type="checkbox" id="c-40842600" checked=""/><div class="controls bullet"><span class="by">worthless-trash</span><span>|</span><a href="#40842562">parent</a><span>|</span><a href="#40843134">prev</a><span>|</span><a href="#40842682">next</a><span>|</span><label class="collapse" for="c-40842600">[-]</label><label class="expand" for="c-40842600">[5 more]</label></div><br/><div class="children"><div class="content">Some of the rootkits i&#x27;ve written attack statically compiled executables, so <i>shrug</i>.</div><br/><div id="40843033" class="c"><input type="checkbox" id="c-40843033" checked=""/><div class="controls bullet"><span class="by">nvy</span><span>|</span><a href="#40842562">root</a><span>|</span><a href="#40842600">parent</a><span>|</span><a href="#40842682">next</a><span>|</span><label class="collapse" for="c-40843033">[-]</label><label class="expand" for="c-40843033">[4 more]</label></div><br/><div class="children"><div class="content">Have you written about this?  I&#x27;m fascinated by exploit dev.</div><br/><div id="40843160" class="c"><input type="checkbox" id="c-40843160" checked=""/><div class="controls bullet"><span class="by">qweqwe14</span><span>|</span><a href="#40842562">root</a><span>|</span><a href="#40843033">parent</a><span>|</span><a href="#40842682">next</a><span>|</span><label class="collapse" for="c-40843160">[-]</label><label class="expand" for="c-40843160">[3 more]</label></div><br/><div class="children"><div class="content">In case you&#x27;re interested, it&#x27;s usually done via ptrace by attaching to every process and modifiying the syscall arguments every time it makes one. There are performance issues associated with that (ptracing is rather expensive) and IMO it&#x27;s more complex than LD_PRELOAD. Furthermore, ptrace may be disabled altogether on some installations, even for root. See yama_ptrace_scope<p>I wouldn&#x27;t say it&#x27;s a practical approach. Works for a cool demo, sure, but as an adversary I would be hesitant to use this widely.</div><br/><div id="40843405" class="c"><input type="checkbox" id="c-40843405" checked=""/><div class="controls bullet"><span class="by">grugq</span><span>|</span><a href="#40842562">root</a><span>|</span><a href="#40843160">parent</a><span>|</span><a href="#40842682">next</a><span>|</span><label class="collapse" for="c-40843405">[-]</label><label class="expand" for="c-40843405">[2 more]</label></div><br/><div class="children"><div class="content">And you can detect when you are being ptrace()d because a process cannot be ptrace()d twice. Unless they changed Linux again.<p>There are also timing issues that show up, and you can do any number of anti-debugging tricks which would reveal that the environment is being manipulated. Which is an instant red flag.<p>In general if the attacker is running at the same privilege level, you can probably evade it or at least detect it. I’m somewhat surprised there isn’t a basic forensics tool that automates all of these tests already.<p>“sus: [-h] [-v] [-V] [-o file] [-O format]<p>Sus tests for common indicators of compromise using on generic tests for common methods of implementing userland rootkits. It will check for LD_PRELOAD, ptrace(), inotify() and verify the system binaries match the upstream distribution hashsums. It can be used to dump the file system directly (warning, slow!) for comparison against the output of `find`. See EXAMPLES for more.”<p>Implementation is left as an exercise for the reader.</div><br/><div id="40843673" class="c"><input type="checkbox" id="c-40843673" checked=""/><div class="controls bullet"><span class="by">worthless-trash</span><span>|</span><a href="#40842562">root</a><span>|</span><a href="#40843405">parent</a><span>|</span><a href="#40842682">next</a><span>|</span><label class="collapse" for="c-40843673">[-]</label><label class="expand" for="c-40843673">[1 more]</label></div><br/><div class="children"><div class="content">I almost got nerd sniped by this comment.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40842682" class="c"><input type="checkbox" id="c-40842682" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40842562">parent</a><span>|</span><a href="#40842600">prev</a><span>|</span><a href="#40842643">next</a><span>|</span><label class="collapse" for="c-40842682">[-]</label><label class="expand" for="c-40842682">[1 more]</label></div><br/><div class="children"><div class="content">Static linking does get used as a hardening measure in fact, but mostly at the level of individual applications from what I’ve seen.</div><br/></div></div></div></div><div id="40842643" class="c"><input type="checkbox" id="c-40842643" checked=""/><div class="controls bullet"><span class="by">benob</span><span>|</span><a href="#40842562">prev</a><span>|</span><a href="#40842227">next</a><span>|</span><label class="collapse" for="c-40842643">[-]</label><label class="expand" for="c-40842643">[9 more]</label></div><br/><div class="children"><div class="content">What are uses of LD_PRELOAD that make us keep it?</div><br/><div id="40842668" class="c"><input type="checkbox" id="c-40842668" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#40842643">parent</a><span>|</span><a href="#40842697">next</a><span>|</span><label class="collapse" for="c-40842668">[-]</label><label class="expand" for="c-40842668">[1 more]</label></div><br/><div class="children"><div class="content">Replacing allocators <a href="https:&#x2F;&#x2F;github.com&#x2F;jemalloc&#x2F;jemalloc&#x2F;wiki&#x2F;Getting-Started">https:&#x2F;&#x2F;github.com&#x2F;jemalloc&#x2F;jemalloc&#x2F;wiki&#x2F;Getting-Started</a><p>Pretending you&#x27;re running on a remote system <a href="https:&#x2F;&#x2F;github.com&#x2F;viraptor&#x2F;libremotec">https:&#x2F;&#x2F;github.com&#x2F;viraptor&#x2F;libremotec</a><p>Cheat in games <a href="https:&#x2F;&#x2F;github.com&#x2F;ProfessionallyEvil&#x2F;LD_PRELOAD-rand-Hijack-Example">https:&#x2F;&#x2F;github.com&#x2F;ProfessionallyEvil&#x2F;LD_PRELOAD-rand-Hijack...</a><p>Fixing bugs where the upstream can&#x27;t do it.</div><br/></div></div><div id="40842697" class="c"><input type="checkbox" id="c-40842697" checked=""/><div class="controls bullet"><span class="by">LukeShu</span><span>|</span><a href="#40842643">parent</a><span>|</span><a href="#40842668">prev</a><span>|</span><a href="#40842983">next</a><span>|</span><label class="collapse" for="c-40842697">[-]</label><label class="expand" for="c-40842697">[1 more]</label></div><br/><div class="children"><div class="content">Some uses of LD_PRELOAD off the top of my head:<p>- GNU stdbuf (BSDs use an env-var instead of hijacking libc)<p>- fakeroot<p>- gprofng&#x27;s data collector<p>- For a long time it was necessary to use LD_PRELOADto hack around a bug in flashplayer because flashplayer used memcpy when it should have used memmove.</div><br/></div></div><div id="40842983" class="c"><input type="checkbox" id="c-40842983" checked=""/><div class="controls bullet"><span class="by">mappu</span><span>|</span><a href="#40842643">parent</a><span>|</span><a href="#40842697">prev</a><span>|</span><a href="#40843287">next</a><span>|</span><label class="collapse" for="c-40842983">[-]</label><label class="expand" for="c-40842983">[1 more]</label></div><br/><div class="children"><div class="content">Do you mean the functionality itself (inherent in the capabilities of a dynamic ELF loader) or specifically that it uses an environment variable? Maybe moving it to static configuration in ld.so.conf would cut down on abuse.</div><br/></div></div><div id="40843287" class="c"><input type="checkbox" id="c-40843287" checked=""/><div class="controls bullet"><span class="by">xioxox</span><span>|</span><a href="#40842643">parent</a><span>|</span><a href="#40842983">prev</a><span>|</span><a href="#40842665">next</a><span>|</span><label class="collapse" for="c-40843287">[-]</label><label class="expand" for="c-40843287">[1 more]</label></div><br/><div class="children"><div class="content">tsocks is quite useful for proxying a program&#x27;s network access over ssh using SOCKS. I use it for accessing geo-blocked servers using command line tools without a full VPN.</div><br/></div></div><div id="40842664" class="c"><input type="checkbox" id="c-40842664" checked=""/><div class="controls bullet"><span class="by">worthless-trash</span><span>|</span><a href="#40842643">parent</a><span>|</span><a href="#40842665">prev</a><span>|</span><a href="#40842227">next</a><span>|</span><label class="collapse" for="c-40842664">[-]</label><label class="expand" for="c-40842664">[3 more]</label></div><br/><div class="children"><div class="content">Fixing bugs in a function in a library.  Overriding libraries.</div><br/><div id="40842944" class="c"><input type="checkbox" id="c-40842944" checked=""/><div class="controls bullet"><span class="by">freeone3000</span><span>|</span><a href="#40842643">root</a><span>|</span><a href="#40842664">parent</a><span>|</span><a href="#40842227">next</a><span>|</span><label class="collapse" for="c-40842944">[-]</label><label class="expand" for="c-40842944">[2 more]</label></div><br/><div class="children"><div class="content">Patching the binary seems like a better way to do this.</div><br/><div id="40843610" class="c"><input type="checkbox" id="c-40843610" checked=""/><div class="controls bullet"><span class="by">worthless-trash</span><span>|</span><a href="#40842643">root</a><span>|</span><a href="#40842944">parent</a><span>|</span><a href="#40842227">next</a><span>|</span><label class="collapse" for="c-40843610">[-]</label><label class="expand" for="c-40843610">[1 more]</label></div><br/><div class="children"><div class="content">Better long term,but also much harder.  Some anti cheat software will be tripped if you do this as they checksum the binaries on disk, that of course can be worked around so its just a matter of understanding your adversary.</div><br/></div></div></div></div></div></div></div></div><div id="40842227" class="c"><input type="checkbox" id="c-40842227" checked=""/><div class="controls bullet"><span class="by">from-nibly</span><span>|</span><a href="#40842643">prev</a><span>|</span><a href="#40842427">next</a><span>|</span><label class="collapse" for="c-40842227">[-]</label><label class="expand" for="c-40842227">[11 more]</label></div><br/><div class="children"><div class="content">This sounds like a food youtuber trying to explain how easy cooking a Turkey is. Yeah sure in a vaccum maybe, but I don&#x27;t spend all day cooking food. Ive got other stuff to do.<p>Maybe its easy to find rootkits if you know what you are doing and use a statically compiled tcpdump. Do you know how many times I&#x27;ve done a TCP dump on my computer to check for root kits statically compiled or not? 0. I don&#x27;t spend my time doing that. All it has to do is use less CPU and RAM than my corporate anti virus already does ( which is a lot ) and I&#x27;m never going to find it, cause im never gonna look.</div><br/><div id="40842640" class="c"><input type="checkbox" id="c-40842640" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#40842227">parent</a><span>|</span><a href="#40842535">next</a><span>|</span><label class="collapse" for="c-40842640">[-]</label><label class="expand" for="c-40842640">[1 more]</label></div><br/><div class="children"><div class="content">The target here is not a random YouTube watcher though. If you&#x27;re doing actual rootkit hunting, you&#x27;re in a larger org with lots of other indicators in place. You&#x27;ll have DNS and traffic logs (hopefully), some local agents, maybe managed devices.<p>You&#x27;re not going to find rootkits randomly by deciding to check with tcpdump. You&#x27;re looking for them in the first place, because they tripped some other detector. That&#x27;s a big prerequisite.</div><br/></div></div><div id="40842535" class="c"><input type="checkbox" id="c-40842535" checked=""/><div class="controls bullet"><span class="by">varenc</span><span>|</span><a href="#40842227">parent</a><span>|</span><a href="#40842640">prev</a><span>|</span><a href="#40842255">next</a><span>|</span><label class="collapse" for="c-40842535">[-]</label><label class="expand" for="c-40842535">[2 more]</label></div><br/><div class="children"><div class="content">Agreed that it still seems decently hard to find if you aren&#x27;t looking for it. Though the tone of the blog post made a lot more sense to me when I saw the over-top-top title of the article[0] it&#x27;s responding to: &#x27;Analysis of a New, Nearly-Impossible-to-Detect Linux Threat&#x27;:<p>[0] <a href="https:&#x2F;&#x2F;intezer.com&#x2F;blog&#x2F;research&#x2F;new-linux-threat-symbiote&#x2F;" rel="nofollow">https:&#x2F;&#x2F;intezer.com&#x2F;blog&#x2F;research&#x2F;new-linux-threat-symbiote&#x2F;</a></div><br/><div id="40843419" class="c"><input type="checkbox" id="c-40843419" checked=""/><div class="controls bullet"><span class="by">grugq</span><span>|</span><a href="#40842227">root</a><span>|</span><a href="#40842535">parent</a><span>|</span><a href="#40842255">next</a><span>|</span><label class="collapse" for="c-40843419">[-]</label><label class="expand" for="c-40843419">[1 more]</label></div><br/><div class="children"><div class="content">In retrospect I really should have included the title with the link.</div><br/></div></div></div></div><div id="40842255" class="c"><input type="checkbox" id="c-40842255" checked=""/><div class="controls bullet"><span class="by">AdeptusAquinas</span><span>|</span><a href="#40842227">parent</a><span>|</span><a href="#40842535">prev</a><span>|</span><a href="#40842659">next</a><span>|</span><label class="collapse" for="c-40842255">[-]</label><label class="expand" for="c-40842255">[4 more]</label></div><br/><div class="children"><div class="content">Yeah but this is more from the perspective of a blue teamer, someone actively looking for&#x2F;protecting against malware or performing forensics. If you&#x27;re not in that position, just have some good AV and don&#x27;t do anything that might make you a target.</div><br/><div id="40842352" class="c"><input type="checkbox" id="c-40842352" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#40842227">root</a><span>|</span><a href="#40842255">parent</a><span>|</span><a href="#40842659">next</a><span>|</span><label class="collapse" for="c-40842352">[-]</label><label class="expand" for="c-40842352">[3 more]</label></div><br/><div class="children"><div class="content">&gt; don&#x27;t do anything that might make you a target.<p>Like &quot;don&#x27;t get connected to the Internet&quot;? That&#x27;s a tall order.</div><br/><div id="40842454" class="c"><input type="checkbox" id="c-40842454" checked=""/><div class="controls bullet"><span class="by">denkmoon</span><span>|</span><a href="#40842227">root</a><span>|</span><a href="#40842352">parent</a><span>|</span><a href="#40842471">next</a><span>|</span><label class="collapse" for="c-40842454">[-]</label><label class="expand" for="c-40842454">[1 more]</label></div><br/><div class="children"><div class="content">You may not have noticed, everyone is on the internet. From the penthouses in new york to small villages in the savannah. Just being connected to the internet isn&#x27;t noteworthy or targeted.<p>Being targeted by an adversary is not the same as being hit by random drive-by attacks hitting every IP in the relatively limited IPv4 address space.</div><br/></div></div><div id="40842471" class="c"><input type="checkbox" id="c-40842471" checked=""/><div class="controls bullet"><span class="by">gizmo686</span><span>|</span><a href="#40842227">root</a><span>|</span><a href="#40842352">parent</a><span>|</span><a href="#40842454">prev</a><span>|</span><a href="#40842659">next</a><span>|</span><label class="collapse" for="c-40842471">[-]</label><label class="expand" for="c-40842471">[1 more]</label></div><br/><div class="children"><div class="content">That is what the antivirus is for. If you are not a high value target, then your risk is virus that are being widely distributed; and those will quickly find their way into an AV database.<p>If you are a high value target, AV is useless, since the attackers you care about will target you with bespoke mallare, that will not be in an AV database.</div><br/></div></div></div></div></div></div><div id="40842659" class="c"><input type="checkbox" id="c-40842659" checked=""/><div class="controls bullet"><span class="by">riwsky</span><span>|</span><a href="#40842227">parent</a><span>|</span><a href="#40842255">prev</a><span>|</span><a href="#40842303">next</a><span>|</span><label class="collapse" for="c-40842659">[-]</label><label class="expand" for="c-40842659">[2 more]</label></div><br/><div class="children"><div class="content">Cooking turkey in a vacuum… sous vide is your idea of easy? Props, dude!</div><br/><div id="40843211" class="c"><input type="checkbox" id="c-40843211" checked=""/><div class="controls bullet"><span class="by">abofh</span><span>|</span><a href="#40842227">root</a><span>|</span><a href="#40842659">parent</a><span>|</span><a href="#40842303">next</a><span>|</span><label class="collapse" for="c-40843211">[-]</label><label class="expand" for="c-40843211">[1 more]</label></div><br/><div class="children"><div class="content">Put meat in bag, put bag in water, receive protein?<p>A turkey might be hard by size, but sous vide is basically the easy-bake of cooking, takes no effort or creativity during the cook and you can only really impact it before and after.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>