<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1735376451365" as="style"/><link rel="stylesheet" href="styles.css?v=1735376451365"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://nytpu.com/gemlog/2024-12-27">Ada&#x27;s dependent types, and its types as a whole</a> <span class="domain">(<a href="https://nytpu.com">nytpu.com</a>)</span></div><div class="subtext"><span>nytpu</span> | <span>28 comments</span></div><br/><div><div id="42529097" class="c"><input type="checkbox" id="c-42529097" checked=""/><div class="controls bullet"><span class="by">seabird</span><span>|</span><a href="#42529353">next</a><span>|</span><label class="collapse" for="c-42529097">[-]</label><label class="expand" for="c-42529097">[7 more]</label></div><br/><div class="children"><div class="content">Ada is a criminally underrated tool that is unfortunately probably doomed to perpetually take the backseat to Rust despite Rust not solving all the problems Ada does. It&#x27;s really sad that so many people&#x27;s idea of safe programming is pretty strictly limited to memory safety, and that because Ada&#x27;s baseline memory safety (SPARK is a different story) isn&#x27;t as robust as Rust&#x27;s borrow checker (in the sense that it doesn&#x27;t have a borrow checker in favor of just avoiding dynamic allocations whenever possible), that it&#x27;s a relic of the past.<p>Ada&#x27;s type system, SPARK, general clarity on behavior, etc. allows you to structure programs in a manner that makes it hard to Hold It Wrong, especially when dealing with embedded firmware that has all sorts of hardware gotchas. I haven&#x27;t gotten the chance to use the Tasking primitives in anger yet, but I have a strong suspicion that they&#x27;re going to bail my ass out of a lot of problems just like the rest of the language has.<p>My team started at a new employer and made the jump from C to Ada for MCU firmware. We control things that spin real fast and our previous experiences with C definitely resulted in some screwups that left you weak in the knees for a bit. There was some initial hesitation but nobody has any interest in going back now. Rust was floated but we&#x27;re all glad we didn&#x27;t opt for it -- memory safety on a system that never allocates memory doesn&#x27;t hold a candle to Ada&#x27;s bitfield mapping&#x2F;representation clauses, ranged types, decimal types, reference manual, formal verification options, concern from the powers that be about providing a stable and trustworthy environment for doing shit that you really don&#x27;t want to get wrong, etc.</div><br/><div id="42529168" class="c"><input type="checkbox" id="c-42529168" checked=""/><div class="controls bullet"><span class="by">docandrew</span><span>|</span><a href="#42529097">parent</a><span>|</span><a href="#42529160">next</a><span>|</span><label class="collapse" for="c-42529168">[-]</label><label class="expand" for="c-42529168">[1 more]</label></div><br/><div class="children"><div class="content">Steve Klabnik (of Rust fame) wrote a (very generous IMO) article about Ada, interesting comparison: <a href="https:&#x2F;&#x2F;steveklabnik.com&#x2F;writing&#x2F;learning-ada&#x2F;" rel="nofollow">https:&#x2F;&#x2F;steveklabnik.com&#x2F;writing&#x2F;learning-ada&#x2F;</a></div><br/></div></div><div id="42529160" class="c"><input type="checkbox" id="c-42529160" checked=""/><div class="controls bullet"><span class="by">LiamPowell</span><span>|</span><a href="#42529097">parent</a><span>|</span><a href="#42529168">prev</a><span>|</span><a href="#42529353">next</a><span>|</span><label class="collapse" for="c-42529160">[-]</label><label class="expand" for="c-42529160">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a bit disappointed that we&#x27;ve ended up with Rust in the kernel but not Ada. The kernel relies on GCC and there&#x27;s already an Ada compiler in GCC, so it wouldn&#x27;t require adding another compiler as a build requirement like Rust does.<p>There&#x27;s a couple of major advantages that Ada could have in the Linux over Rust for safe drivers:<p>1. Having the option to use SPARK for fully verified code provides a superset of the correctness guarantees provided by Rust. As mentioned in the parent comment, Rust focuses purely on memory safety whereas SPARK can provide partial or complete verification of functional correctness. Even without writing any contracts, just preventing things like arithmetic overflows is incredibly useful.<p>2. Representation clauses almost entirely eliminate the need for the error-prone manual (de-)serialisation that&#x27;s littered all over Linux driver code: <a href="https:&#x2F;&#x2F;www.adaic.org&#x2F;resources&#x2F;add_content&#x2F;standards&#x2F;22rm&#x2F;html&#x2F;RM-13-5-1.html" rel="nofollow">https:&#x2F;&#x2F;www.adaic.org&#x2F;resources&#x2F;add_content&#x2F;standards&#x2F;22rm&#x2F;h...</a></div><br/><div id="42529492" class="c"><input type="checkbox" id="c-42529492" checked=""/><div class="controls bullet"><span class="by">quietbritishjim</span><span>|</span><a href="#42529097">root</a><span>|</span><a href="#42529160">parent</a><span>|</span><a href="#42529393">next</a><span>|</span><label class="collapse" for="c-42529492">[-]</label><label class="expand" for="c-42529492">[2 more]</label></div><br/><div class="children"><div class="content">&gt; 2. Representation clauses almost entirely eliminate the need for the error-prone manual (de-)serialisation that&#x27;s littered all over Linux driver code:<p>Do representation clauses let you specify endianess? From a quick glance at that link it didn&#x27;t appear so. I would imagine that invalidates most use cases for them.</div><br/><div id="42529543" class="c"><input type="checkbox" id="c-42529543" checked=""/><div class="controls bullet"><span class="by">LiamPowell</span><span>|</span><a href="#42529097">root</a><span>|</span><a href="#42529492">parent</a><span>|</span><a href="#42529393">next</a><span>|</span><label class="collapse" for="c-42529543">[-]</label><label class="expand" for="c-42529543">[1 more]</label></div><br/><div class="children"><div class="content">You can specify endianness, but only over the entire record, not an individual field. The way it works is a little complicated: <a href="https:&#x2F;&#x2F;www.adacore.com&#x2F;gems&#x2F;gem-140-bridging-the-endianness-gap" rel="nofollow">https:&#x2F;&#x2F;www.adacore.com&#x2F;gems&#x2F;gem-140-bridging-the-endianness...</a></div><br/></div></div></div></div><div id="42529393" class="c"><input type="checkbox" id="c-42529393" checked=""/><div class="controls bullet"><span class="by">LtWorf</span><span>|</span><a href="#42529097">root</a><span>|</span><a href="#42529160">parent</a><span>|</span><a href="#42529492">prev</a><span>|</span><a href="#42529448">next</a><span>|</span><label class="collapse" for="c-42529393">[-]</label><label class="expand" for="c-42529393">[1 more]</label></div><br/><div class="children"><div class="content">rust is in the kernel to attract the young developers, which ada does not.</div><br/></div></div><div id="42529448" class="c"><input type="checkbox" id="c-42529448" checked=""/><div class="controls bullet"><span class="by">Ygg2</span><span>|</span><a href="#42529097">root</a><span>|</span><a href="#42529160">parent</a><span>|</span><a href="#42529393">prev</a><span>|</span><a href="#42529353">next</a><span>|</span><label class="collapse" for="c-42529448">[-]</label><label class="expand" for="c-42529448">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m a bit disappointed that we&#x27;ve ended up with Rust in the kernel but not Ada.<p>Why? Do you program in Ada or Coq?<p>People can&#x27;t be bothered to track lifetimes, what makes you think they are ready to track pre&#x2F;post-conditions, invariants and do it efficiently and thoroughly.</div><br/></div></div></div></div></div></div><div id="42529353" class="c"><input type="checkbox" id="c-42529353" checked=""/><div class="controls bullet"><span class="by">jonlong</span><span>|</span><a href="#42529097">prev</a><span>|</span><a href="#42528983">next</a><span>|</span><label class="collapse" for="c-42529353">[-]</label><label class="expand" for="c-42529353">[8 more]</label></div><br/><div class="children"><div class="content">Coming from the type theory side with only a passing glance at Ada, I am nevertheless sure: this is not what type theorists mean when they talk about dependently typed languages. Such languages derive from the formulation of Per Martin-Löf (also called Intuitionistic Type Theory), they include dependent sum and dependent product types, and they allow type checkers to <i>prove</i> complex statements about code. (The history of dependent types is intertwined with the history of formalizing mathematics; dependent types were designed to encode essentially arbitrary mathematical statements.)<p>The interesting feature of Ada here seems to be what it calls &quot;subtype predicates&quot;. As you&#x27;ve explained, these come in a &quot;dynamic&quot; flavor, which are a nice syntax for runtime assertions, and a static flavor, which are compile-time checked but restricted to certain static expressions (per <a href="https:&#x2F;&#x2F;ada-lang.io&#x2F;docs&#x2F;arm&#x2F;AA-3&#x2F;AA-3.2#p15_3_3.2.4" rel="nofollow">https:&#x2F;&#x2F;ada-lang.io&#x2F;docs&#x2F;arm&#x2F;AA-3&#x2F;AA-3.2#p15_3_3.2.4</a>).<p>An example of something you can do in a dependently typed language is write a sorting function in such a way that the type checker proves that the output will always be in sorted order. I am pretty sure this cannot be done in Ada; checking at runtime does not count!<p>I do believe (having heard from multiple sources) that Ada&#x27;s type system was ahead of its time and its success in creating practical programs that are likely to be correct is probably underrated. But I&#x27;m not here just to legislate semantics; one should be aware that there is something vastly more powerful out there called &quot;dependent types&quot; (even if that power is not likely to come into most people&#x27;s day-to-day).<p>(Unfortunately Wikipedia is quite poor on this topic; you will see, for example, that on the Talk page someone asked &quot;Is Ada really dependently typed?&quot; two years ago; no reply. And it makes no sense to say that Ada has &quot;tactics&quot; but not &quot;proof terms&quot;; tactics are a way of generating proof terms. There are many better resources out there (especially ones associated with the languages Agda, Coq (currently being renamed Rocq), and Lean, e.g. <a href="https:&#x2F;&#x2F;lean-lang.org&#x2F;theorem_proving_in_lean4&#x2F;dependent_type_theory.html" rel="nofollow">https:&#x2F;&#x2F;lean-lang.org&#x2F;theorem_proving_in_lean4&#x2F;dependent_typ...</a>). But be warned, there is no &quot;short version&quot;: dependent types cannot be explained in a sentence, and they are not something you will arrive at with enough &quot;hacking away&quot;.)</div><br/><div id="42529449" class="c"><input type="checkbox" id="c-42529449" checked=""/><div class="controls bullet"><span class="by">LiamPowell</span><span>|</span><a href="#42529353">parent</a><span>|</span><a href="#42529439">next</a><span>|</span><label class="collapse" for="c-42529449">[-]</label><label class="expand" for="c-42529449">[4 more]</label></div><br/><div class="children"><div class="content">&gt; An example of something you can do in a dependently typed language is write a sorting function in such a way that the type checker proves that the output will always be in sorted order. I am pretty sure this cannot be done in Ada; checking at runtime does not count!<p>It actually can be done in Ada, but not purely with the type system, instead we rely on SPARK, which converts Ada code and passes it through various automatic theorem provers. Some examples of fully proven sorting functions are here: <a href="https:&#x2F;&#x2F;github.com&#x2F;AdaCore&#x2F;spark2014&#x2F;blob&#x2F;master&#x2F;testsuite&#x2F;gnatprove&#x2F;tests&#x2F;281__sorts&#x2F;main.adb">https:&#x2F;&#x2F;github.com&#x2F;AdaCore&#x2F;spark2014&#x2F;blob&#x2F;master&#x2F;testsuite&#x2F;g...</a><p>You can also see from the above code just how good theorem provers and SPARK are now with the reasonably low number of assertions required to both prove that the output is sorted and prove that the input and output contain the same elements, not to mention all the hidden proofs relating to integer overflow, out-of-bounds access, etc..<p>You could maybe do all this with types and SPARK, but it&#x27;s not the approach that would usually be taken.</div><br/><div id="42529579" class="c"><input type="checkbox" id="c-42529579" checked=""/><div class="controls bullet"><span class="by">jonlong</span><span>|</span><a href="#42529353">root</a><span>|</span><a href="#42529449">parent</a><span>|</span><a href="#42529522">next</a><span>|</span><label class="collapse" for="c-42529579">[-]</label><label class="expand" for="c-42529579">[1 more]</label></div><br/><div class="children"><div class="content">Ah, very interesting. It does seem that the Ada community has done serious engineering work to build in powerful formal verification, in a way that is somehow parallel to the (much slower, for practical purposes, if more elegant) arc of type theory...</div><br/></div></div><div id="42529522" class="c"><input type="checkbox" id="c-42529522" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#42529353">root</a><span>|</span><a href="#42529449">parent</a><span>|</span><a href="#42529579">prev</a><span>|</span><a href="#42529439">next</a><span>|</span><label class="collapse" for="c-42529522">[-]</label><label class="expand" for="c-42529522">[2 more]</label></div><br/><div class="children"><div class="content">what is the flow for working through this kind of proof? Is there an interactive proof mode like you find in a lot of dependent type provers? Or is there some other guiding mechanism for telling you that you haven&#x27;t provided enough guidance with asserts?</div><br/><div id="42529577" class="c"><input type="checkbox" id="c-42529577" checked=""/><div class="controls bullet"><span class="by">LiamPowell</span><span>|</span><a href="#42529353">root</a><span>|</span><a href="#42529522">parent</a><span>|</span><a href="#42529439">next</a><span>|</span><label class="collapse" for="c-42529577">[-]</label><label class="expand" for="c-42529577">[1 more]</label></div><br/><div class="children"><div class="content">SPARK will give you some guidance, but there&#x27;s no particularly fancy interactive tools. Here&#x27;s an example of working through a different sorting algorithm: <a href="https:&#x2F;&#x2F;blog.adacore.com&#x2F;i-cant-believe-that-i-can-prove-that-it-can-sort" rel="nofollow">https:&#x2F;&#x2F;blog.adacore.com&#x2F;i-cant-believe-that-i-can-prove-tha...</a></div><br/></div></div></div></div></div></div><div id="42529439" class="c"><input type="checkbox" id="c-42529439" checked=""/><div class="controls bullet"><span class="by">chamomeal</span><span>|</span><a href="#42529353">parent</a><span>|</span><a href="#42529449">prev</a><span>|</span><a href="#42529554">next</a><span>|</span><label class="collapse" for="c-42529439">[-]</label><label class="expand" for="c-42529439">[2 more]</label></div><br/><div class="children"><div class="content">Super interesting! Thanks for the link.<p>Would you say Lean is a somewhat learnable language for somebody who only has cursory exposure to functional programming and static types? I’ve almost exclusively used typescript for the last few years, except for some clojure in the last few months.<p>Sometimes I find a neat language, but my very TS-oriented brain has a hard time getting into it.</div><br/><div id="42529507" class="c"><input type="checkbox" id="c-42529507" checked=""/><div class="controls bullet"><span class="by">jonlong</span><span>|</span><a href="#42529353">root</a><span>|</span><a href="#42529439">parent</a><span>|</span><a href="#42529554">next</a><span>|</span><label class="collapse" for="c-42529507">[-]</label><label class="expand" for="c-42529507">[1 more]</label></div><br/><div class="children"><div class="content">I would say dependent types are going into the deep end; unless you have a real need to prove things, it may be hard to see the motivation to learn such abstractions.<p>In between <i>ad hoc</i> types like TypeScript and dependently-typed languages like Agda, Coq&#x2F;Rocq, and Lean are well-typed, polymorphic (but not dependent) languages like OCaml, F#, or Haskell (&quot;ML family&quot; or &quot;Hindley-Milner&quot; are related terms). Those are what I&#x27;d suggest checking out first!</div><br/></div></div></div></div><div id="42529554" class="c"><input type="checkbox" id="c-42529554" checked=""/><div class="controls bullet"><span class="by">timhh</span><span>|</span><a href="#42529353">parent</a><span>|</span><a href="#42529439">prev</a><span>|</span><a href="#42528983">next</a><span>|</span><label class="collapse" for="c-42529554">[-]</label><label class="expand" for="c-42529554">[1 more]</label></div><br/><div class="children"><div class="content">Maybe they&#x27;re not implying this kind of limited dependent type system but surely it is still dependently typed? It&#x27;s just not the &quot;full fat&quot; dependent typing.<p>Another example of a language with limited dependent typing is Sail. It has &quot;lightweight&quot; dependent types for integers and array lengths (pretty similar to Ada from what it sounds like).<p>It&#x27;s very good in my experience - it lets you do a lot of powerful stuff without having to have a PhD in formal verification (again, sounds similar to Ada).<p>&gt; An example of something you can do in a dependently typed language is write a sorting function in such a way that the type checker proves that the output will always be in sorted order.<p>Yeah you can&#x27;t do that but you can have the type checker say things like &quot;n^m is positive if n is positive or even&quot; or &quot;foo(x) -&gt; (bits(n), bits(m)) with m+n=x&quot; (not the actual syntax). I&#x27;m pretty sure you can&#x27;t do that stuff in a type system without dependent types right?</div><br/></div></div></div></div><div id="42528983" class="c"><input type="checkbox" id="c-42528983" checked=""/><div class="controls bullet"><span class="by">Validark</span><span>|</span><a href="#42529353">prev</a><span>|</span><a href="#42529196">next</a><span>|</span><label class="collapse" for="c-42528983">[-]</label><label class="expand" for="c-42528983">[1 more]</label></div><br/><div class="children"><div class="content">Very interesting. As a Zig enthusiast I&#x27;ve long suspected that Ada has the ability to express more invariants and types that we will want in Zig (some, like ranges, are planned, last I heard). I&#x27;m definitely interested to learn more about Ada.</div><br/></div></div><div id="42529196" class="c"><input type="checkbox" id="c-42529196" checked=""/><div class="controls bullet"><span class="by">LiamPowell</span><span>|</span><a href="#42528983">prev</a><span>|</span><a href="#42529176">next</a><span>|</span><label class="collapse" for="c-42529196">[-]</label><label class="expand" for="c-42529196">[1 more]</label></div><br/><div class="children"><div class="content">One other neat thing about discriminated records is that you&#x27;re not limited to just a single field with a variable size, you can also write something like this:<p><pre><code>    type My_Record (A, B : My_Integer) is record
       X : My_Array (1 .. A);
       Y : My_Array (1 .. B);
    end record;
</code></pre>
A record that&#x27;s created from this will have those arrays tightly packed rather than leaving space at the end of the first one like you might expect (this might be compiler dependant, but it&#x27;s definitely how GCC does it). Also note that these values can be set at runtime, so this isn&#x27;t just a generic in disguise (although in Ada you can also instantiate generics at runtime).</div><br/></div></div><div id="42529176" class="c"><input type="checkbox" id="c-42529176" checked=""/><div class="controls bullet"><span class="by">TypingOutBugs</span><span>|</span><a href="#42529196">prev</a><span>|</span><a href="#42528971">next</a><span>|</span><label class="collapse" for="c-42529176">[-]</label><label class="expand" for="c-42529176">[5 more]</label></div><br/><div class="children"><div class="content">I’d love to work with Ada but never had the opportunity. Anyone know which companies hire for it?</div><br/><div id="42529232" class="c"><input type="checkbox" id="c-42529232" checked=""/><div class="controls bullet"><span class="by">seabird</span><span>|</span><a href="#42529176">parent</a><span>|</span><a href="#42529217">next</a><span>|</span><label class="collapse" for="c-42529232">[-]</label><label class="expand" for="c-42529232">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen a single company that does warehouse management software out of Sweden that advertises (in job listings) that they&#x27;re using it. Otherwise, it&#x27;s pretty slim pickings if you&#x27;re not applying in its wheelhouse (high integrity systems -- aerospace, defense, medical, etc).<p>If you do microcontroller firmware development, I&#x27;d say it&#x27;s perfectly reasonable to float it for a smaller project and just give it a spin. The language is <i>significantly</i> more modern&#x2F;sane than C so you&#x27;re not really exposing yourself to much talent risk. There&#x27;s no gaping holes in the environment, experienced firmware devs will adjust easily, and new devs will feel more at home with the facilities provided.</div><br/><div id="42529550" class="c"><input type="checkbox" id="c-42529550" checked=""/><div class="controls bullet"><span class="by">TypingOutBugs</span><span>|</span><a href="#42529176">root</a><span>|</span><a href="#42529232">parent</a><span>|</span><a href="#42529217">next</a><span>|</span><label class="collapse" for="c-42529550">[-]</label><label class="expand" for="c-42529550">[1 more]</label></div><br/><div class="children"><div class="content">What was the company in Sweden? Thankfully I live in Stockholm!</div><br/></div></div></div></div><div id="42529217" class="c"><input type="checkbox" id="c-42529217" checked=""/><div class="controls bullet"><span class="by">jghn</span><span>|</span><a href="#42529176">parent</a><span>|</span><a href="#42529232">prev</a><span>|</span><a href="#42528971">next</a><span>|</span><label class="collapse" for="c-42529217">[-]</label><label class="expand" for="c-42529217">[2 more]</label></div><br/><div class="children"><div class="content">The military</div><br/><div id="42529378" class="c"><input type="checkbox" id="c-42529378" checked=""/><div class="controls bullet"><span class="by">sharpy</span><span>|</span><a href="#42529176">root</a><span>|</span><a href="#42529217">parent</a><span>|</span><a href="#42528971">next</a><span>|</span><label class="collapse" for="c-42529378">[-]</label><label class="expand" for="c-42529378">[1 more]</label></div><br/><div class="children"><div class="content">I have been out of the defense industry for quite a while now, but even back then, more and more projects were using C&#x2F;C++, because it was so hard to hire Ada developers.</div><br/></div></div></div></div></div></div><div id="42528971" class="c"><input type="checkbox" id="c-42528971" checked=""/><div class="controls bullet"><span class="by">nmilo</span><span>|</span><a href="#42529176">prev</a><span>|</span><a href="#42528802">next</a><span>|</span><label class="collapse" for="c-42528971">[-]</label><label class="expand" for="c-42528971">[3 more]</label></div><br/><div class="children"><div class="content">The 2 stacks is really cool. Seems like it solves a lot of problems dynamic allocation + RAII solves. Is there more written about this?</div><br/><div id="42529090" class="c"><input type="checkbox" id="c-42529090" checked=""/><div class="controls bullet"><span class="by">nytpu</span><span>|</span><a href="#42528971">parent</a><span>|</span><a href="#42529190">next</a><span>|</span><label class="collapse" for="c-42529090">[-]</label><label class="expand" for="c-42529090">[1 more]</label></div><br/><div class="children"><div class="content">Not really much other than tangential mentions.  I did write an addendum to the OP going over the secondary stack as well as where you still use normal dynamic allocation in Ada: <a href="https:&#x2F;&#x2F;nytpu.com&#x2F;gemlog&#x2F;2024-12-27-2" rel="nofollow">https:&#x2F;&#x2F;nytpu.com&#x2F;gemlog&#x2F;2024-12-27-2</a><p>All my knowledge on it comes from some documentation on configuring the secondary stack for embedded targets and from comments+diagrams in the GCC GNAT source code (and maybe I saw a conversation on it on the comp.lang.ada Usenet group at some point…):
<a href="https:&#x2F;&#x2F;docs.adacore.com&#x2F;gnat_ugx-docs&#x2F;html&#x2F;gnat_ugx&#x2F;gnat_ugx&#x2F;the_stacks.html#the-secondary-stack" rel="nofollow">https:&#x2F;&#x2F;docs.adacore.com&#x2F;gnat_ugx-docs&#x2F;html&#x2F;gnat_ugx&#x2F;gnat_ug...</a>
<a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;git&#x2F;?p=gcc.git;a=blob;f=gcc&#x2F;ada&#x2F;libgnat&#x2F;s-secsta.adb;hb=HEAD#l39" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;git&#x2F;?p=gcc.git;a=blob;f=gcc&#x2F;ada&#x2F;libgnat&#x2F;...</a></div><br/></div></div><div id="42529190" class="c"><input type="checkbox" id="c-42529190" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#42528971">parent</a><span>|</span><a href="#42529090">prev</a><span>|</span><a href="#42528802">next</a><span>|</span><label class="collapse" for="c-42529190">[-]</label><label class="expand" for="c-42529190">[1 more]</label></div><br/><div class="children"><div class="content">Forth is another language with separate control flow and data stacks, for similar reasons, although at a much lower level - the stacks are a part of the language spec that is fully exposed to you, not just an implementation detail.</div><br/></div></div></div></div></div></div></div></div></div></body></html>