<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1737190875754" as="style"/><link rel="stylesheet" href="styles.css?v=1737190875754"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://cceckman.com/writing/branchless-utf8-encoding/">Branchless UTF-8 Encoding</a> <span class="domain">(<a href="https://cceckman.com">cceckman.com</a>)</span></div><div class="subtext"><span>vortex_ape</span> | <span>33 comments</span></div><br/><div><div id="42742950" class="c"><input type="checkbox" id="c-42742950" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#42743509">next</a><span>|</span><label class="collapse" for="c-42742950">[-]</label><label class="expand" for="c-42742950">[4 more]</label></div><br/><div class="children"><div class="content">Incidentally, this automatic branch-if-zero from LLVM is being improved.<p>First of all, a recent LLVM patch apparently changes codegen to use CMOV instead of a branch:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;pull&#x2F;102885">https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;pull&#x2F;102885</a><p>Beyond that, Intel recently updated their manual to retroactively define the behavior of BSR&#x2F;BSF on zero inputs: it leaves the destination register unmodified.  This matches the AMD manual, and I suspect it matches the behavior of all existing x86-64 processors (but that will need to be tested, I guess).<p>If so, you don&#x27;t need either a branch or CMOV.  Just set a register to 32, then run BSR with the same register as destination.  If the BSR input is nonzero, the 32 is overwritten with the trailing-zero count.  If the BSR input is zero, then BSR leaves the register unmodified and you get 32.<p>Since this behavior is now guaranteed for future x86-64 processors, and assuming it&#x27;s indeed compatible with all existing x86-64 processors (maybe even all x86 processors period?), LLVM will no longer need the old path regardless of what it&#x27;s targeting.<p>Note that if you&#x27;re targeting a newer x86-64 version, LLVM will just emit TZCNT, which just does what you&#x27;d expect and returns 32 if the input is zero (or 64 for a 64-bit TZCNT).  But as the blog post demonstrates, many people still build for baseline x86_64.<p>(Intel does document one discrepancy between processors: &quot;On some older processors, use of a 32-bit operand size may clear the upper 32 bits of a 64-bit destination while leaving the lower 32 bits unmodified.&quot;)</div><br/><div id="42746262" class="c"><input type="checkbox" id="c-42746262" checked=""/><div class="controls bullet"><span class="by">charleslmunger</span><span>|</span><a href="#42742950">parent</a><span>|</span><a href="#42744209">next</a><span>|</span><label class="collapse" for="c-42746262">[-]</label><label class="expand" for="c-42746262">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Beyond that, Intel recently updated their manual to retroactively define the behavior of BSR&#x2F;BSF on zero inputs: it leaves the destination register unmodified.<p>This is very nice of them to do, but I found while optimizing a routine in protobuf that BSR is dramatically slower on AMD CPUs than LZCNT, and so I never want to use it again - it&#x27;s pretty rare to have a function using BSR that can&#x27;t use CLZ instead, and CLZ is faster on arm, AMD, and equivalent on Intel since haswell.<p>I believe there is also some errata where on some processors Intel LZCNT had a false dependency for the output register as an input, probably because of this BSR behavior, but compilers will insert a self-xor in loops where that carried dependency would matter.</div><br/></div></div><div id="42744209" class="c"><input type="checkbox" id="c-42744209" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42742950">parent</a><span>|</span><a href="#42746262">prev</a><span>|</span><a href="#42743509">next</a><span>|</span><label class="collapse" for="c-42744209">[-]</label><label class="expand" for="c-42744209">[2 more]</label></div><br/><div class="children"><div class="content">I was watching a video ranting about bad benchmarks yesterday and in an aside they pointed out the (gcc) generated code used Conditional Move (cmov) in several places to handle and if&#x2F;else if in the code with no branches.<p>I think the days of trying to branches by trying to remove conditional assignments are either gone or close to it. You may still have a subsequent data race, but the conditional assignment isn&#x27;t your biggest problem with throughput.</div><br/><div id="42744883" class="c"><input type="checkbox" id="c-42744883" checked=""/><div class="controls bullet"><span class="by">achierius</span><span>|</span><a href="#42742950">root</a><span>|</span><a href="#42744209">parent</a><span>|</span><a href="#42743509">next</a><span>|</span><label class="collapse" for="c-42744883">[-]</label><label class="expand" for="c-42744883">[1 more]</label></div><br/><div class="children"><div class="content">What makes you say that? I&#x27;ve seen several cases where an over-usage of branchless programming actually slowed things down. Especially once you get past 2 nested conditionals (so 4+ pathways) you do just end up executing a lot of ultimately-unused code. In fact this has been going the other direction, in some ways, for a little while now: people overestimate how much branches cost, particularly small, local, and easy-to-predict ones.</div><br/></div></div></div></div></div></div><div id="42743509" class="c"><input type="checkbox" id="c-42743509" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#42742950">prev</a><span>|</span><a href="#42744623">next</a><span>|</span><label class="collapse" for="c-42743509">[-]</label><label class="expand" for="c-42743509">[2 more]</label></div><br/><div class="children"><div class="content">If you have access to the BMI2 instruction set I can do branchless UTF-8 encoding like in the article using only 9 instructions and 73 bytes of lookup tables:<p><pre><code>    branchless_utf8:
        mov     rax, rdi
        lzcnt   ecx, esi
        lea     rdx, [rip + .L__unnamed_1]
        movzx   ecx, byte ptr [rcx + rdx]
        lea     rdx, [rip + example::DEP_AND_OR::h78cbe1dc7fe823a9]
        pdep    esi, esi, dword ptr [rdx + 8*rcx]
        or      esi, dword ptr [rdx + 8*rcx + 4]
        movbe   dword ptr [rdi], esi
        mov     qword ptr [rdi + 8], rcx
        ret

</code></pre>
The code:<p><pre><code>    static DEP_AND_OR: [(u32, u32); 5] = [
        (0, 0),
        (0b01111111_00000000_00000000_00000000, 0b00000000_00000000_00000000_00000000),
        (0b00011111_00111111_00000000_00000000, 0b11000000_10000000_00000000_00000000),
        (0b00001111_00111111_00111111_00000000, 0b11100000_10000000_10000000_00000000),
        (0b00000111_00111111_00111111_00111111, 0b11110000_10000000_10000000_10000000),
    ];

    const LEN: [u8; 33] = [
        &#x2F;&#x2F; 0-10 leading zeros: not valid.
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        &#x2F;&#x2F; 11-15 leading zeros: 4 bytes.
        4, 4, 4, 4, 4,
        &#x2F;&#x2F; 16-20 leading zeros: 3 bytes.
        3, 3, 3, 3, 3,
        &#x2F;&#x2F; 21-24 leading zeros: 2 bytes.
        2, 2, 2, 2,
        &#x2F;&#x2F; 25-32 leading zeros: 1 byte.
        1, 1, 1, 1, 1, 1, 1, 1,
    ];

    pub unsafe fn branchless_utf8(codepoint: u32) -&gt; ([u8; 4], usize) {
        let leading_zeros = codepoint.leading_zeros() as usize;
        let bytes = LEN[leading_zeros] as usize;
        let (mask, or) = *DEP_AND_OR.get_unchecked(bytes);
        let ret = core::arch::x86_64::_pdep_u32(codepoint, mask) | or;
        (ret.swap_bytes().to_le_bytes(), bytes)
    }</code></pre></div><br/></div></div><div id="42744623" class="c"><input type="checkbox" id="c-42744623" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#42743509">prev</a><span>|</span><a href="#42743600">next</a><span>|</span><label class="collapse" for="c-42744623">[-]</label><label class="expand" for="c-42744623">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  &#x2F;&#x2F;&#x2F; Encode a UTF-8 codepoint.
  &#x2F;&#x2F;&#x2F; […]
  &#x2F;&#x2F;&#x2F; Returns a length of zero for invalid codepoints (surrogates and out-of-bounds values);
  &#x2F;&#x2F;&#x2F; it&#x27;s up to the caller to turn that into U+FFFD, or return an error.
</code></pre>
It&#x27;s not a &quot;UTF-8 codepoint&quot;, that&#x27;s horridly mangling the terminology. Code points are just code points.<p>The input to a UTF-8 encode is a scalar value, not a code point, and encoding a scalar value is infallible. What doubly kills me is that Rust <i>has a dedicated type for scalar values</i>. (`char`.)<p>(In languages with non-[USV]-strings…, Python raises an exception, JS emits garbage.)</div><br/></div></div><div id="42743600" class="c"><input type="checkbox" id="c-42743600" checked=""/><div class="controls bullet"><span class="by">koala_man</span><span>|</span><a href="#42744623">prev</a><span>|</span><a href="#42742731">next</a><span>|</span><label class="collapse" for="c-42743600">[-]</label><label class="expand" for="c-42743600">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m surprised there are no UTF-8 specific decode instructions yet, the way ARM has &quot;FJCVTZS - Floating-point Javascript Convert to Signed fixed-point, rounding toward Zero&quot;</div><br/><div id="42744044" class="c"><input type="checkbox" id="c-42744044" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#42743600">parent</a><span>|</span><a href="#42743620">next</a><span>|</span><label class="collapse" for="c-42744044">[-]</label><label class="expand" for="c-42744044">[1 more]</label></div><br/><div class="children"><div class="content">FJCVTZS isn&#x27;t really as specific to Javascript as the name suggests, it actually copies the semantics of an x86 instruction, which JS took its semantics from.<p>JS runtimes do use it but it&#x27;s useful anywhere you need to do what x86 does, which obviously includes running x86 binaries under emulation.</div><br/></div></div><div id="42743620" class="c"><input type="checkbox" id="c-42743620" checked=""/><div class="controls bullet"><span class="by">HeliumHydride</span><span>|</span><a href="#42743600">parent</a><span>|</span><a href="#42744044">prev</a><span>|</span><a href="#42742731">next</a><span>|</span><label class="collapse" for="c-42743620">[-]</label><label class="expand" for="c-42743620">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;developer.arm.com&#x2F;documentation&#x2F;ddi0602&#x2F;2024-12&#x2F;SIMD-FP-Instructions&#x2F;FJCVTZS--Floating-point-Javascript-convert-to-signed-fixed-point--rounding-toward-zero-?lang=en" rel="nofollow">https:&#x2F;&#x2F;developer.arm.com&#x2F;documentation&#x2F;ddi0602&#x2F;2024-12&#x2F;SIMD...</a></div><br/></div></div></div></div><div id="42742731" class="c"><input type="checkbox" id="c-42742731" checked=""/><div class="controls bullet"><span class="by">xeeeeeeeeeeenu</span><span>|</span><a href="#42743600">prev</a><span>|</span><a href="#42742535">next</a><span>|</span><label class="collapse" for="c-42742731">[-]</label><label class="expand" for="c-42742731">[5 more]</label></div><br/><div class="children"><div class="content">&gt; So on x86_64 processors, we have to branch to say “a 32-bit zero value has 32 leading zeros”.<p>Not if you&#x27;re targeting x86-64-v3 or higher. Haswell (Intel) and Piledriver (AMD) introduced the LZCNT instruction that doesn&#x27;t have this problem.</div><br/><div id="42742835" class="c"><input type="checkbox" id="c-42742835" checked=""/><div class="controls bullet"><span class="by">sltkr</span><span>|</span><a href="#42742731">parent</a><span>|</span><a href="#42742859">next</a><span>|</span><label class="collapse" for="c-42742835">[-]</label><label class="expand" for="c-42742835">[1 more]</label></div><br/><div class="children"><div class="content">You can also very trivially do (codepoint | 1).leading_zeros(), then you can also shave one byte off the LEN table. (This doesn&#x27;t affect the result because LEN[32] == LEN[33] == 1).</div><br/></div></div><div id="42742859" class="c"><input type="checkbox" id="c-42742859" checked=""/><div class="controls bullet"><span class="by">pklausler</span><span>|</span><a href="#42742731">parent</a><span>|</span><a href="#42742835">prev</a><span>|</span><a href="#42742535">next</a><span>|</span><label class="collapse" for="c-42742859">[-]</label><label class="expand" for="c-42742859">[3 more]</label></div><br/><div class="children"><div class="content">Easy to count leading zeroes in a branch-free manner without a hardware instruction using a conditional move and a de Bruijn sequence; see <a href="https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;blob&#x2F;main&#x2F;flang&#x2F;include&#x2F;flang&#x2F;Common&#x2F;leading-zero-bit-count.h">https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;blob&#x2F;main&#x2F;flang&#x2F;include...</a> .</div><br/><div id="42744263" class="c"><input type="checkbox" id="c-42744263" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42742731">root</a><span>|</span><a href="#42742859">parent</a><span>|</span><a href="#42742535">next</a><span>|</span><label class="collapse" for="c-42744263">[-]</label><label class="expand" for="c-42744263">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    x |= x &gt;&gt; 1;
    x |= x &gt;&gt; 2;
    x |= x &gt;&gt; 4;
    x |= x &gt;&gt; 8;
    x |= x &gt;&gt; 16;
    x |= x &gt;&gt; 32;
</code></pre>
Isn&#x27;t there another way to do this without so many data races?<p>I feel like this should be<p><pre><code>   x |= x &gt;&gt; 1 | x &gt;&gt; ??? ...</code></pre></div><br/><div id="42744484" class="c"><input type="checkbox" id="c-42744484" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#42742731">root</a><span>|</span><a href="#42744263">parent</a><span>|</span><a href="#42742535">next</a><span>|</span><label class="collapse" for="c-42744484">[-]</label><label class="expand" for="c-42744484">[1 more]</label></div><br/><div class="children"><div class="content">By data races I assume you actually mean data dependencies?</div><br/></div></div></div></div></div></div></div></div><div id="42742535" class="c"><input type="checkbox" id="c-42742535" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#42742731">prev</a><span>|</span><a href="#42743519">next</a><span>|</span><label class="collapse" for="c-42742535">[-]</label><label class="expand" for="c-42742535">[1 more]</label></div><br/><div class="children"><div class="content">&gt;So on x86_64 processors, we have to branch to say “a 32-bit zero value has 32 leading zeros”. Put differently, the “count leading zeros” intrinsic isn’t necessarily a branchless instruction. This might look nicer on another architecture!<p>Yes, RISC-V for example defines the instructions for counting leading &#x2F; trailing zeros (clz, clzw, ctz, ctzw) such that an N-bit zero value has N of them.<p>I don&#x27;t know if I can show it on Rust Godbolt because none of the default RISC-V targets that Rust has support the Zbb extension, but I checked with a custom target that I use locally for my emulator, and `leading_zeros()` indeed compiles to just one `clz` without any further branches. Here&#x27;s a C demonstration though: <a href="https:&#x2F;&#x2F;gcc.godbolt.org&#x2F;z&#x2F;cKx3ajsjh" rel="nofollow">https:&#x2F;&#x2F;gcc.godbolt.org&#x2F;z&#x2F;cKx3ajsjh</a></div><br/></div></div><div id="42743519" class="c"><input type="checkbox" id="c-42743519" checked=""/><div class="controls bullet"><span class="by">Validark</span><span>|</span><a href="#42742535">prev</a><span>|</span><a href="#42744606">next</a><span>|</span><label class="collapse" for="c-42743519">[-]</label><label class="expand" for="c-42743519">[1 more]</label></div><br/><div class="children"><div class="content">I wrote this stub a while back<p><a href="https:&#x2F;&#x2F;gist.github.com&#x2F;Validark&#x2F;457b6db8aa00ded26a6681d4d25708ca" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;Validark&#x2F;457b6db8aa00ded26a6681d4d25...</a></div><br/></div></div><div id="42744606" class="c"><input type="checkbox" id="c-42744606" checked=""/><div class="controls bullet"><span class="by">purplesyringa</span><span>|</span><a href="#42743519">prev</a><span>|</span><a href="#42742790">next</a><span>|</span><label class="collapse" for="c-42744606">[-]</label><label class="expand" for="c-42744606">[1 more]</label></div><br/><div class="children"><div class="content">Instead of<p><pre><code>    let surrogate_mask = surrogate_bit &lt;&lt; 2 | surrogate_bit &lt;&lt; 1 | surrogate_bit;
    len &amp;= !surrogate_mask;
</code></pre>
consider<p><pre><code>    len &amp;= surrogate_bit.wrapping_sub(1);
</code></pre>
This should still work better. Alternatively, invert the conditions and do<p><pre><code>    len &amp;= non_surrogate_bit.wrapping_neg();</code></pre></div><br/></div></div><div id="42742790" class="c"><input type="checkbox" id="c-42742790" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#42744606">prev</a><span>|</span><a href="#42743634">next</a><span>|</span><label class="collapse" for="c-42742790">[-]</label><label class="expand" for="c-42742790">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Compiler explorer confirms that, with optimizations enabled, this function is branchless.<p>Only if you don&#x27;t consider conditional move instructions branching&#x2F;cheating :)</div><br/></div></div><div id="42743634" class="c"><input type="checkbox" id="c-42743634" checked=""/><div class="controls bullet"><span class="by">RenThraysk</span><span>|</span><a href="#42742790">prev</a><span>|</span><a href="#42743566">next</a><span>|</span><label class="collapse" for="c-42743634">[-]</label><label class="expand" for="c-42743634">[1 more]</label></div><br/><div class="children"><div class="content">Or-ing 1 onto codepoint before calling leading_zeroes() should get a decent compiler to remove the branch.</div><br/></div></div><div id="42743566" class="c"><input type="checkbox" id="c-42743566" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#42743634">prev</a><span>|</span><a href="#42742391">next</a><span>|</span><label class="collapse" for="c-42743566">[-]</label><label class="expand" for="c-42743566">[3 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t branchless UTF-8 encoding always write 3 bytes to RAM for every character (possibly to the same address)?</div><br/><div id="42745222" class="c"><input type="checkbox" id="c-42745222" checked=""/><div class="controls bullet"><span class="by">ack_complete</span><span>|</span><a href="#42743566">parent</a><span>|</span><a href="#42743614">next</a><span>|</span><label class="collapse" for="c-42745222">[-]</label><label class="expand" for="c-42745222">[1 more]</label></div><br/><div class="children"><div class="content">CPUs are surprisingly good at dealing with this in their store queues. I see this write-all-and-increment-some technique used a lot in optimized code, like branchless left-pack routines or overcopying in the copy handler of an LZ&#x2F;Deflate decompressor.</div><br/></div></div><div id="42743614" class="c"><input type="checkbox" id="c-42743614" checked=""/><div class="controls bullet"><span class="by">ngoldbaum</span><span>|</span><a href="#42743566">parent</a><span>|</span><a href="#42745222">prev</a><span>|</span><a href="#42742391">next</a><span>|</span><label class="collapse" for="c-42743614">[-]</label><label class="expand" for="c-42743614">[1 more]</label></div><br/><div class="children"><div class="content">You could do two passes over the string, first get the total length in bytes, then fill it in codepoint by codepoint.<p>You could also pessimistically over-allocate assuming four bytes per character and then resize afterwards.<p>With the API in the linked blog post it&#x27;s up to the user to decide how they want to use the output [u8;4] array.</div><br/></div></div></div></div><div id="42742391" class="c"><input type="checkbox" id="c-42742391" checked=""/><div class="controls bullet"><span class="by">ThatGuyRaion</span><span>|</span><a href="#42743566">prev</a><span>|</span><a href="#42745657">next</a><span>|</span><label class="collapse" for="c-42742391">[-]</label><label class="expand" for="c-42742391">[4 more]</label></div><br/><div class="children"><div class="content">So is this potentially performance improving?.</div><br/><div id="42742719" class="c"><input type="checkbox" id="c-42742719" checked=""/><div class="controls bullet"><span class="by">not2b</span><span>|</span><a href="#42742391">parent</a><span>|</span><a href="#42742494">next</a><span>|</span><label class="collapse" for="c-42742719">[-]</label><label class="expand" for="c-42742719">[1 more]</label></div><br/><div class="children"><div class="content">Usually people are interested in branchless implementations for cryptography applications, to avoid timing side channels (though you then have to make sure that the generated instructions don&#x27;t have different timing for different input values), and will pay some time penalty if they have to.</div><br/></div></div><div id="42742494" class="c"><input type="checkbox" id="c-42742494" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#42742391">parent</a><span>|</span><a href="#42742719">prev</a><span>|</span><a href="#42745657">next</a><span>|</span><label class="collapse" for="c-42742494">[-]</label><label class="expand" for="c-42742494">[2 more]</label></div><br/><div class="children"><div class="content">Last time I tested branchless UTF-8 algorithms, I came to the conclusion that they only perform [slightly] better for text consisting of foreign multibyte characters. Unless you expect lots of such inputs on the hot path, just go with traditional algorithms instead. Even in the worst case the difference isn&#x27;t that big.<p>Sometimes people fail to appreciate how insanely fast a predictable branch really is.</div><br/><div id="42744257" class="c"><input type="checkbox" id="c-42744257" checked=""/><div class="controls bullet"><span class="by">dbcurtis</span><span>|</span><a href="#42742391">root</a><span>|</span><a href="#42742494">parent</a><span>|</span><a href="#42745657">next</a><span>|</span><label class="collapse" for="c-42744257">[-]</label><label class="expand" for="c-42744257">[1 more]</label></div><br/><div class="children"><div class="content">Pretty much. A strongly predicted branch is as fast as straight-line code, for most practical purposes (in modern processors).  It is the mis-predicted branch that causes a pipeline flush and a re-fetch and so forth.  The whole point of instructions like CMOV is to replace &quot;flakey&quot; branches with a CMOV so that you can execute both code paths and the test condition path all in parallel and grab the right answer at the end.  This avoids paying the mis-predict penalty, and gives more time to compute the test condition, which for a branch is almost always only available awkwardly late in the pipeline.  So as long as the compiler can do a decent job of identifying &quot;flakey&quot; branches up front for replacement with CMOV, it is a win.  And many branches are easy for the compiler to classify.  For instance -- if(SomeRareExceptionCondition) handle_exception(); -- for bonus points, move the exception handling code way the heck out to a different text page so that it isn&#x27;t hanging around taking up I-cache space for no good reason.</div><br/></div></div></div></div></div></div><div id="42745657" class="c"><input type="checkbox" id="c-42745657" checked=""/><div class="controls bullet"><span class="by">marxisttemp</span><span>|</span><a href="#42742391">prev</a><span>|</span><a href="#42744923">next</a><span>|</span><label class="collapse" for="c-42745657">[-]</label><label class="expand" for="c-42745657">[1 more]</label></div><br/><div class="children"><div class="content">I love weird little tricks with popcnt&#x2F;leading&#x2F;trailing zero instructions.<p>I recently had a lot of fun getting Swift’s OptionSet bitset interface to iterate over active members.<p>(Unfortunately, because of weird specifics of Swift protocol associated types, I wasn’t able to actually conform OptionSet to Collection like I wanted to originally. I find it amusing that one of the first examples in the official documentation for Swift macros is to make OptionSet used an associated enum like it should.)</div><br/></div></div><div id="42744923" class="c"><input type="checkbox" id="c-42744923" checked=""/><div class="controls bullet"><span class="by">emilfihlman</span><span>|</span><a href="#42745657">prev</a><span>|</span><a href="#42744742">next</a><span>|</span><label class="collapse" for="c-42744923">[-]</label><label class="expand" for="c-42744923">[1 more]</label></div><br/><div class="children"><div class="content">I mean, isn&#x27;t the trivial answer to just collapse the if else tree into just math that&#x27;s evaluated always?<p><pre><code>  u32 a = (code &lt;= 0x7F);
  u32 b = (code &lt;= 0x07FF);
  u32 c = ((code &lt; 0xD800) || 
  (0xDFFF &lt; code));
  u32 d = (code &lt;= 0xFFFF) * c;
  u32 e = (code &lt;= 0x10FFFF);
  u32 v = (c &amp;&amp; e);
  return(-1 * !v + v * (4 - a - b - d));
</code></pre>
Highly likely easy to optimise.</div><br/></div></div><div id="42744742" class="c"><input type="checkbox" id="c-42744742" checked=""/><div class="controls bullet"><span class="by">decafbad</span><span>|</span><a href="#42744923">prev</a><span>|</span><a href="#42743001">next</a><span>|</span><label class="collapse" for="c-42744742">[-]</label><label class="expand" for="c-42744742">[2 more]</label></div><br/><div class="children"><div class="content">Checkout Erlang bit parsing.</div><br/><div id="42746304" class="c"><input type="checkbox" id="c-42746304" checked=""/><div class="controls bullet"><span class="by">SALCKIN</span><span>|</span><a href="#42744742">parent</a><span>|</span><a href="#42743001">next</a><span>|</span><label class="collapse" for="c-42746304">[-]</label><label class="expand" for="c-42746304">[1 more]</label></div><br/><div class="children"><div class="content">Reply</div><br/></div></div></div></div></div></div></div></div></div></body></html>