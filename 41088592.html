<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1722157261556" as="style"/><link rel="stylesheet" href="styles.css?v=1722157261556"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/managarm/managarm">Managarm: Pragmatic microkernel-based OS with asynchronous I/O</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>ksp-atlas</span> | <span>41 comments</span></div><br/><div><div id="41088830" class="c"><input type="checkbox" id="c-41088830" checked=""/><div class="controls bullet"><span class="by">jcelerier</span><span>|</span><a href="#41089795">next</a><span>|</span><label class="collapse" for="c-41088830">[-]</label><label class="expand" for="c-41088830">[18 more]</label></div><br/><div class="children"><div class="content">people always say that C++ is not a good fit for kernels, but so far this is the only language I know where small teams or individuals are regularly able to create non-trivial hobby OSes from scratch that go from zero to GUI:<p>- Serenity (<a href="https:&#x2F;&#x2F;github.com&#x2F;SerenityOS&#x2F;serenity">https:&#x2F;&#x2F;github.com&#x2F;SerenityOS&#x2F;serenity</a>) - not really a small team, but it managed to get to GUI as pretty much a one-man-show<p>- Skift (<a href="https:&#x2F;&#x2F;github.com&#x2F;skift-org&#x2F;skift">https:&#x2F;&#x2F;github.com&#x2F;skift-org&#x2F;skift</a>)<p>- hhu: <a href="https:&#x2F;&#x2F;github.com&#x2F;hhuOS&#x2F;hhuOS">https:&#x2F;&#x2F;github.com&#x2F;hhuOS&#x2F;hhuOS</a><p>- MaxOS: <a href="https:&#x2F;&#x2F;github.com&#x2F;maxtyson123&#x2F;MaxOS">https:&#x2F;&#x2F;github.com&#x2F;maxtyson123&#x2F;MaxOS</a><p>- MorphiOS: <a href="https:&#x2F;&#x2F;github.com&#x2F;syedtaqi95&#x2F;morphiOS">https:&#x2F;&#x2F;github.com&#x2F;syedtaqi95&#x2F;morphiOS</a><p>- Macaron: <a href="https:&#x2F;&#x2F;github.com&#x2F;MacaronOS&#x2F;Macaron">https:&#x2F;&#x2F;github.com&#x2F;MacaronOS&#x2F;Macaron</a><p>- Ghost: <a href="https:&#x2F;&#x2F;github.com&#x2F;maxdev1&#x2F;ghost">https:&#x2F;&#x2F;github.com&#x2F;maxdev1&#x2F;ghost</a><p>most big ones in C don&#x27;t manage to get to the GUI level, except toaruos:  <a href="https:&#x2F;&#x2F;github.com&#x2F;klange&#x2F;toaruos">https:&#x2F;&#x2F;github.com&#x2F;klange&#x2F;toaruos</a></div><br/><div id="41088918" class="c"><input type="checkbox" id="c-41088918" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#41088830">parent</a><span>|</span><a href="#41088966">next</a><span>|</span><label class="collapse" for="c-41088918">[-]</label><label class="expand" for="c-41088918">[1 more]</label></div><br/><div class="children"><div class="content">HelenOS[1] is in C and has a GUI. I don’t know how many people participated over its (quite extensive) history.<p>Axle[2] is a one-man project with a GUI that the author has been gradually transitioning from C to Rust.<p>Among C++ projects, I think Essence[3] also merits a mention.<p>[1] <a href="http:&#x2F;&#x2F;www.helenos.org&#x2F;" rel="nofollow">http:&#x2F;&#x2F;www.helenos.org&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;codyd51&#x2F;axle">https:&#x2F;&#x2F;github.com&#x2F;codyd51&#x2F;axle</a><p>[3] <a href="https:&#x2F;&#x2F;gitlab.com&#x2F;nakst&#x2F;essence" rel="nofollow">https:&#x2F;&#x2F;gitlab.com&#x2F;nakst&#x2F;essence</a></div><br/></div></div><div id="41088966" class="c"><input type="checkbox" id="c-41088966" checked=""/><div class="controls bullet"><span class="by">ironhaven</span><span>|</span><a href="#41088830">parent</a><span>|</span><a href="#41088918">prev</a><span>|</span><a href="#41089334">next</a><span>|</span><label class="collapse" for="c-41088966">[-]</label><label class="expand" for="c-41088966">[1 more]</label></div><br/><div class="children"><div class="content">There is Redox written in rust. <a href="https:&#x2F;&#x2F;gitlab.redox-os.org&#x2F;redox-os&#x2F;redox" rel="nofollow">https:&#x2F;&#x2F;gitlab.redox-os.org&#x2F;redox-os&#x2F;redox</a></div><br/></div></div><div id="41089334" class="c"><input type="checkbox" id="c-41089334" checked=""/><div class="controls bullet"><span class="by">asveikau</span><span>|</span><a href="#41088830">parent</a><span>|</span><a href="#41088966">prev</a><span>|</span><a href="#41089048">next</a><span>|</span><label class="collapse" for="c-41089334">[-]</label><label class="expand" for="c-41089334">[10 more]</label></div><br/><div class="children"><div class="content">I think C++ is especially good for a GUI.<p>The two counter-examples I can think of with plain C:<p>* GTK+, though honestly speaking I think quality has dipped over the decades where C++ equivalents have flourished.<p>* Old school Win32 style. Counter to the bad reputation, I find it easy to be productive with in plain C once you adjust your mental model to its expectations. Though it&#x27;s probably better from C++ than C, for a few convenience features to reduce boiler plate.</div><br/><div id="41089370" class="c"><input type="checkbox" id="c-41089370" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#41088830">root</a><span>|</span><a href="#41089334">parent</a><span>|</span><a href="#41089048">next</a><span>|</span><label class="collapse" for="c-41089370">[-]</label><label class="expand" for="c-41089370">[9 more]</label></div><br/><div class="children"><div class="content">Old Win32 style received less attention than it deserves, I think. It&#x27;s an object system in its own right—a Smalltalkish one, at that, with an (admittedly muddled) E-style separation of synchronous and asynchronous calls!—but one rarely sees it mentioned in the same sentence as Objective-C, C++, and GObject&#x2F;Vala. Part of the blame for that undoubtedly rests on Microsoft’s incompetence at documenting concepts, but whatever the causes I’d definitely like to see that corner of the object-system design space explored more, with or without GUIs.</div><br/><div id="41089489" class="c"><input type="checkbox" id="c-41089489" checked=""/><div class="controls bullet"><span class="by">asveikau</span><span>|</span><a href="#41088830">root</a><span>|</span><a href="#41089370">parent</a><span>|</span><a href="#41089581">next</a><span>|</span><label class="collapse" for="c-41089489">[-]</label><label class="expand" for="c-41089489">[1 more]</label></div><br/><div class="children"><div class="content">When win32 was dominant they didn&#x27;t need to document it, people had the motivation to figure it out.<p>Successive waves of Microsoft people then tried to make it easier to use or replace it entirely, which, they never did so with the same quality as the original.<p>Unfortunately some of those misadventures became synonymous with building a windows UI.</div><br/></div></div><div id="41089581" class="c"><input type="checkbox" id="c-41089581" checked=""/><div class="controls bullet"><span class="by">tomcam</span><span>|</span><a href="#41088830">root</a><span>|</span><a href="#41089370">parent</a><span>|</span><a href="#41089489">prev</a><span>|</span><a href="#41089048">next</a><span>|</span><label class="collapse" for="c-41089581">[-]</label><label class="expand" for="c-41089581">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Part of the blame for that undoubtedly rests on Microsoft’s incompetence at documenting concepts<p>I mean Charles Petzold did that so successfully redoing it would be superfluous</div><br/><div id="41089837" class="c"><input type="checkbox" id="c-41089837" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#41088830">root</a><span>|</span><a href="#41089581">parent</a><span>|</span><a href="#41089048">next</a><span>|</span><label class="collapse" for="c-41089837">[-]</label><label class="expand" for="c-41089837">[6 more]</label></div><br/><div class="children"><div class="content">Kind of. He stops somewhat short of admitting that Win16&#x2F;32 windows <i>are</i> objects and their graphical representation is mostly incidental. That’s not a bad thing—the book is introductory on many topics, in a good way, and just dropping such an idea somewhere in the beginning portions would be more confusing than helpful for the intended audience. That audience would almost certainly not be helped by the observation that they are dealing with a sort of Smalltalkish&#x2F;Actorish system with badly bolted-on multithreading—most of it wouldn’t have knowm what that meant, at the time.<p>Still, this is kind of a common theme. Perhaps “you had to have been there” worked as an approach to documentation for the first ten to fifteen years, but afterwards any newcomer is just guaranteed to get lost.<p>If you want to learn Win32, you need to read Petzold. If you’re interested specifically in how the dialog manager works, you need to invent a time machine and read a series of blog posts Raymond Chen wrote in 2005[1]. If you want the particulars on message queueing, you need to invent a time machine and read the chapter about then in Raymond Chen’s blogobook[2]. If you want to learn about STRICT and the very useful message cracker macros in WINDOWSX.H, first, you were probably reading Raymond Chen, because the official documentation is basically mum about it, but second, you need to track down that one KB article about porting to Win32 that accompanied one particular Windows 3.1-era Microsoft compiler[3].<p>If you want to learn DCOM95-vintage COM, you need to read Box and Brockschmidt and that <i>COM Programmer’s Cookbook</i>[4] thing that was somebody’s own private initiative inside Microsoft and is buried somewhere in the technotes and <i>then</i> the COM Specification[5] will be accessible to you, and <i>only after that</i> will the MSDN specification make some sort of sense. If you want to learn the how or why of COM marshalling in particular, you will perhaps be helped by some of the above, but really you need to invent a time machine and read a series of blog posts Raymond Chen wrote in <i>2022</i>[6]. Only then will the MSDN reference be even slightly helpful (and even then not that much over the IntelliSense hints).<p>If you want to learn ActiveX ... I have no idea what you need to read! And that itself is indicative of a problem (took me five years to stumble upon Brockschmidt).<p>If you want to learn MSMQ&#x2F;MTS&#x2F;COM+&#x2F;whatever, you need to read that one book[7] that’s still going to leave you with more questions than answers, and then maybe track down some MSJ articles from after COM+ was only a vague marketing term for something internal, but before .NET completely overtook all Microsoft communications channels. If you want to learn about using COM contexts, first, my condolences, second, AFAIK your <i>only</i> source for this Win2K-era, and I quote, “backdoor into the very low-level COM infrastructure” is Raymond Chen’s post from two decades later[8]. There’s no motivating spec for any of this, even one as scarce on details as the later parts of the COM one.<p>If you want to learn about WinRT internals, well, there are some blog posts random people on the Internet have written[9], and maybe you can spelunk some in the Win8-era legacy MSDN docs that are somewhat more explicit about what’s happening. If you want to learn about WinRT’s headline feature of “metadata-driven marshalling”, <i>fuck you</i>, it’s not explained anywhere, nor is an up-to-date MIDL grammar that would include the ways to adjust it a “priority” for that team—or maybe it’s just that I don’t have a time machine, but Raymond Chen is mortal too, and it’s been over a decade.<p>And it’s all like that. (Eric Lippert copied <i>some</i> of the articles on Active Scripting &#x2F; WSH from his now-deleted MSDN blogs, but not all of them. Michael Kaplan’s blog, one of the best resources on Windows i18n, was speed-deleted from MSDN after he published a Vista leak, and the man himself died shortly afterwards, so for anything after that you’re out of luck. Etc., etc. Need I say there’s no type system spec for TypeScript?)<p>Again, if you were there at the time and you subscribed to MSDN, until 2005 or so I think you would’ve gotten basically all of the things I listed on the CDs, and more besides (Dr. GUI and Dr. International anyone?). But if you only joined in 1995 or 1998 or 2000, God help you. (WinRT happened after 2005, though, so the sum total of in-depth, under-the-hood narrative stuff about it is fuck all.) The references from that era are excellent, but as far as, again, narrative docs are concerned— C’mon, guys, you had <i>Ted Chiang</i> at your disposal and that’s what you managed?..<p>(Then again, it probably had very little to do with the technical writers themselves and a lot to with the preposterously hectic development and a management culture that just did not prioritize this sort of thing. But still.)<p>[1] <a href="http:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20231204102018&#x2F;https:&#x2F;&#x2F;bytepointer.com&#x2F;resources&#x2F;old_new_thing&#x2F;20050329_078_the_dialog_manager_part_1_warm_ups.htm" rel="nofollow">http:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20231204102018&#x2F;https:&#x2F;&#x2F;bytepointe...</a> (wait, has bytepointer.com died? that would make me very sad...)<p>[2] <a href="https:&#x2F;&#x2F;openlibrary.org&#x2F;works&#x2F;OL9256722W&#x2F;The_old_new_thing" rel="nofollow">https:&#x2F;&#x2F;openlibrary.org&#x2F;works&#x2F;OL9256722W&#x2F;The_old_new_thing</a><p>[3] Nope, can’t find it right now! Good thing Microsoft deleted most of the old KB articles from their website... <i>—an hour passes—</i> Found it! Q83456: <a href="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeffpar&#x2F;kbarchive&#x2F;master&#x2F;txt&#x2F;083&#x2F;Q83456.TXT" rel="nofollow">https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeffpar&#x2F;kbarchive&#x2F;master&#x2F;t...</a> (thank goodness these were numbered).<p>[4] <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;previous-versions&#x2F;ms809982(v=msdn.10)" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;previous-versions&#x2F;ms809982...</a><p>[5] What, were you expecting a microsoft.com link? Hahaha, nope! Just imagine you’re listening to Rick Astley, I guess. Anyway, there are two versions in circulation (originally as DOC). The “Component Object Model specification”, version 0.9, is dated 1995 and is easier to find, e.g.: <a href="https:&#x2F;&#x2F;groups.csail.mit.edu&#x2F;medg&#x2F;ftp&#x2F;emjordan&#x2F;COM&#x2F;THE%20COM.DOC" rel="nofollow">https:&#x2F;&#x2F;groups.csail.mit.edu&#x2F;medg&#x2F;ftp&#x2F;emjordan&#x2F;COM&#x2F;THE%20COM...</a>. The “COM core technology specification”, version 1.0, is dated 1998 and is, as far as I know, only available from this one Russian-language homepage, last updated 2004 (and you can certainly tell): <a href="https:&#x2F;&#x2F;thegercog.narod.ru&#x2F;index.htm?u=https:&#x2F;&#x2F;thegercog.narod.ru&#x2F;Pages&#x2F;Docs.htm" rel="nofollow">https:&#x2F;&#x2F;thegercog.narod.ru&#x2F;index.htm?u=https:&#x2F;&#x2F;thegercog.nar...</a>, direct link: <a href="https:&#x2F;&#x2F;thegercog.narod.ru&#x2F;Files&#x2F;Docs&#x2F;ds&#x2F;com&#x2F;com_spec.rar" rel="nofollow">https:&#x2F;&#x2F;thegercog.narod.ru&#x2F;Files&#x2F;Docs&#x2F;ds&#x2F;com&#x2F;com_spec.rar</a>. A lot of the same material is in the DCOM Internet-Draft and the ActiveX Spec drafts on the Open Group website.<p>[6] <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20220615-00&#x2F;?p=106753" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20220615-00&#x2F;?p=10...</a><p>[7] <a href="https:&#x2F;&#x2F;thrysoee.dk&#x2F;InsideCOM+&#x2F;" rel="nofollow">https:&#x2F;&#x2F;thrysoee.dk&#x2F;InsideCOM+&#x2F;</a><p>[8] <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20191128-00&#x2F;?p=103157" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20191128-00&#x2F;?p=10...</a><p>[9] <a href="https:&#x2F;&#x2F;www.interact-sw.co.uk&#x2F;iangblog&#x2F;2011&#x2F;09&#x2F;25&#x2F;native-winrt-inheritance" rel="nofollow">https:&#x2F;&#x2F;www.interact-sw.co.uk&#x2F;iangblog&#x2F;2011&#x2F;09&#x2F;25&#x2F;native-win...</a></div><br/><div id="41090230" class="c"><input type="checkbox" id="c-41090230" checked=""/><div class="controls bullet"><span class="by">tomcam</span><span>|</span><a href="#41088830">root</a><span>|</span><a href="#41089837">parent</a><span>|</span><a href="#41090032">next</a><span>|</span><label class="collapse" for="c-41090230">[-]</label><label class="expand" for="c-41090230">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for debunking my answer so comprehensively. Cannot disagree.</div><br/></div></div><div id="41090032" class="c"><input type="checkbox" id="c-41090032" checked=""/><div class="controls bullet"><span class="by">asveikau</span><span>|</span><a href="#41088830">root</a><span>|</span><a href="#41089837">parent</a><span>|</span><a href="#41090230">prev</a><span>|</span><a href="#41089983">next</a><span>|</span><label class="collapse" for="c-41090032">[-]</label><label class="expand" for="c-41090032">[1 more]</label></div><br/><div class="children"><div class="content">I learned a bunch of these things largely on my own, but it probably helped that I was at MSFT for a few years.</div><br/></div></div><div id="41089983" class="c"><input type="checkbox" id="c-41089983" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#41088830">root</a><span>|</span><a href="#41089837">parent</a><span>|</span><a href="#41090032">prev</a><span>|</span><a href="#41089048">next</a><span>|</span><label class="collapse" for="c-41089983">[-]</label><label class="expand" for="c-41089983">[3 more]</label></div><br/><div class="children"><div class="content">Completely amazed that you could write this comprehensive reply just like that.</div><br/><div id="41090231" class="c"><input type="checkbox" id="c-41090231" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#41088830">root</a><span>|</span><a href="#41089983">parent</a><span>|</span><a href="#41091285">next</a><span>|</span><label class="collapse" for="c-41090231">[-]</label><label class="expand" for="c-41090231">[1 more]</label></div><br/><div class="children"><div class="content">I guess I’m just a bit obsessed with Golden Age Microsoft, having grown up during that time without understanding much of what was going on. My original point, though, was that they had some very nice, perhaps thesis-chapter-worthy points that ended up buried in the specifics of (and on more than one occasion, in the same grave as) their products.<p>Windows’s, well, windows as a object&#x2F;concurrency system are one (even if the Win32 transition to multithreading is IMO conceptually botched). The actor model admittedly already existed at that point, but Mark Miller et al.’s work on E (the only other source I know for having separate synchronous and asynchronous sends) hadn’t even started at that point. (There are innumerable papers on various versions of actors, though, so I might have missed it.)<p>COM aggregation is another. It would probably have been much more successful had they used fat pointers, and there are a couple of old papers pointing this approach is a viable way to do implementation (as opposed to interface) inheritance. But I know of no precedent in the literature for the inside-out way WinRT builds its allegedly more conventional inheritance mechanism on it. (I guess I would’ve referenced BETA if I were writing a paper on it?)<p>DCOM’s “causality IDs” for reentrancy control are yet another. You can basically have calls to your object guarded by a <i>recursive</i> mutex whose ownership is passed along with any remote calls that that object itself makes. I’m not sure they are a <i>good</i> idea (recursive mutexes are perilous in the simplest of situations, and this is most definitely not one of those), but I’m almost certain it’s an <i>original</i> one.<p>That’s it, for now, but I’m almost certain I could find more, if only I knew where to look.</div><br/></div></div><div id="41091285" class="c"><input type="checkbox" id="c-41091285" checked=""/><div class="controls bullet"><span class="by">tomcam</span><span>|</span><a href="#41088830">root</a><span>|</span><a href="#41089983">parent</a><span>|</span><a href="#41090231">prev</a><span>|</span><a href="#41089048">next</a><span>|</span><label class="collapse" for="c-41091285">[-]</label><label class="expand" for="c-41091285">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. It is a tour de force.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41089048" class="c"><input type="checkbox" id="c-41089048" checked=""/><div class="controls bullet"><span class="by">fbdab103</span><span>|</span><a href="#41088830">parent</a><span>|</span><a href="#41089334">prev</a><span>|</span><a href="#41089949">next</a><span>|</span><label class="collapse" for="c-41089048">[-]</label><label class="expand" for="c-41089048">[2 more]</label></div><br/><div class="children"><div class="content">Is the kernel really the differentiator there? seL4 is a Proven microkernel that is some 9000 lines of C. This ancient SO post[0] claims Linux is 140k lines. The kernel is just a tiny component of the many things required to get an OS up and running. I suspect most projects just peter out as the enormity of the complexity becomes apparent.<p>[0] <a href="https:&#x2F;&#x2F;unix.stackexchange.com&#x2F;questions&#x2F;223746&#x2F;why-is-the-linux-kernel-15-million-lines-of-code" rel="nofollow">https:&#x2F;&#x2F;unix.stackexchange.com&#x2F;questions&#x2F;223746&#x2F;why-is-the-l...</a></div><br/><div id="41089758" class="c"><input type="checkbox" id="c-41089758" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#41088830">root</a><span>|</span><a href="#41089048">parent</a><span>|</span><a href="#41089949">next</a><span>|</span><label class="collapse" for="c-41089758">[-]</label><label class="expand" for="c-41089758">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s just the architecture and driver independent part of the kernel.  The kernel source tree is 15M lines or so.</div><br/></div></div></div></div><div id="41089949" class="c"><input type="checkbox" id="c-41089949" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#41088830">parent</a><span>|</span><a href="#41089048">prev</a><span>|</span><a href="#41089795">next</a><span>|</span><label class="collapse" for="c-41089949">[-]</label><label class="expand" for="c-41089949">[3 more]</label></div><br/><div class="children"><div class="content">You are seeing a creation date bias.  And it doesn&#x27;t help that there just aren&#x27;t that many systems programming languages.<p>Until Rust in 2010, there basically was almost no motion in the &quot;system programming space&quot;.  Even afterward, there needs to be enough uptake to actually have critical mass.  Only then can people start using it for projects.<p>Side note: D actually predates a lot of this by being from 2001, but, sadly, never seemed to get any traction.  It seems like it had the misfortune of being about 10 years too early and that programmers just weren&#x27;t ready for a new systems programming language at that point.</div><br/><div id="41090624" class="c"><input type="checkbox" id="c-41090624" checked=""/><div class="controls bullet"><span class="by">pezezin</span><span>|</span><a href="#41088830">root</a><span>|</span><a href="#41089949">parent</a><span>|</span><a href="#41089795">next</a><span>|</span><label class="collapse" for="c-41090624">[-]</label><label class="expand" for="c-41090624">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Side note: D actually predates a lot of this by being from 2001, but, sadly, never seemed to get any traction. It seems like it had the misfortune of being about 10 years too early and that programmers just weren&#x27;t ready for a new systems programming language at that point.<p>I was only a kid starting my university degree at that time, but I had been coding since I was 9 and I was very excited about D. What I remember is that getting it up and running was a cumbersome, fully manual process. The compiler was closed-source, delivered as a tarball without any kind of installation script, ditto for the libraries. I wrote some little programs and I liked the language, but in the end I gave up.<p>On the other hand, Rust has rustup and Cargo which are just amazing. I am sure that a big part of Rust&#x27;s popularity comes from Cargo.</div><br/><div id="41091392" class="c"><input type="checkbox" id="c-41091392" checked=""/><div class="controls bullet"><span class="by">voidfunc</span><span>|</span><a href="#41088830">root</a><span>|</span><a href="#41090624">parent</a><span>|</span><a href="#41089795">next</a><span>|</span><label class="collapse" for="c-41091392">[-]</label><label class="expand" for="c-41091392">[1 more]</label></div><br/><div class="children"><div class="content">Yea D stagnated due to some terrible decisions by Digital Mars.. it never built a serious community.</div><br/></div></div></div></div></div></div></div></div><div id="41089795" class="c"><input type="checkbox" id="c-41089795" checked=""/><div class="controls bullet"><span class="by">dilippkumar</span><span>|</span><a href="#41088830">prev</a><span>|</span><a href="#41089693">next</a><span>|</span><label class="collapse" for="c-41089795">[-]</label><label class="expand" for="c-41089795">[4 more]</label></div><br/><div class="children"><div class="content">This is mostly a note to myself.<p>It&#x27;s interesting to consider &quot;what next&quot; once an OS project reaches this stage. There are soo many directions a team can take, but also, none of those direction lead to a clear path towards massive user adoption.<p>There are obvious holes&#x2F;gaps in what mainstream OSes offer today, however it is not clear how a project goes from here to addressing those gaps, and even if those were to be addressed, it is not clear how it could displace mainstream OSes.<p>We are clearly better off having projects like this, that give us options in case something were to go horribly wrong with mainstream OSes. However, what is the incentive to keep projects like this alive when the path ahead is soo unclear?<p>How does one disrupt the operating systems market?</div><br/><div id="41090334" class="c"><input type="checkbox" id="c-41090334" checked=""/><div class="controls bullet"><span class="by">lasiotus</span><span>|</span><a href="#41089795">parent</a><span>|</span><a href="#41090865">next</a><span>|</span><label class="collapse" for="c-41090334">[-]</label><label class="expand" for="c-41090334">[1 more]</label></div><br/><div class="children"><div class="content">Motor OS (<a href="https:&#x2F;&#x2F;motor-os.org" rel="nofollow">https:&#x2F;&#x2F;motor-os.org</a>) attempts to do exactly that, by focusing on a rather narrow, from a &quot;mainstream OS&quot;, point of view, niche. Kind of &quot;do this one thing better&quot; approach.</div><br/></div></div><div id="41090865" class="c"><input type="checkbox" id="c-41090865" checked=""/><div class="controls bullet"><span class="by">globalnode</span><span>|</span><a href="#41089795">parent</a><span>|</span><a href="#41090334">prev</a><span>|</span><a href="#41089693">next</a><span>|</span><label class="collapse" for="c-41090865">[-]</label><label class="expand" for="c-41090865">[2 more]</label></div><br/><div class="children"><div class="content">rather than displace mainstream os&#x27;s what id rather have is some way to easily switch os depending on my task, gaming? windows, anything else? linux (for now), and have that run directly on the hardware with little interference... like a meta task switcher os.<p>someone is going to come on here and tell me we already have this (i hope).<p>ive been out of computing for so long i dont know if this reliably exists, but back in the day this is what i would have wished for.</div><br/><div id="41091229" class="c"><input type="checkbox" id="c-41091229" checked=""/><div class="controls bullet"><span class="by">globalnode</span><span>|</span><a href="#41089795">root</a><span>|</span><a href="#41090865">parent</a><span>|</span><a href="#41089693">next</a><span>|</span><label class="collapse" for="c-41091229">[-]</label><label class="expand" for="c-41091229">[1 more]</label></div><br/><div class="children"><div class="content">and since i dont trust windows to host my work os securely, and performance of games would be abysmal with the hosting roles reversed, what i really need is 2 boxes and a kvm switch!. the question now becomes, are there physical systems that turn on and off at the same time... i.e. share a psu but host different os&#x27;s!<p>suppose i could build my own<p>am i looking at building a rack mounted system? heh, think i just found a project for myself.<p>1 psu, 1 gpu (for gaming), 1 kb&#x2F;monitor, 2 hdd, 2 motherboards, 1 kvm switch, build my own rack out of wood, done! so the only extra cost really should be the 2nd motherboard and the kvm switch.</div><br/></div></div></div></div></div></div><div id="41089693" class="c"><input type="checkbox" id="c-41089693" checked=""/><div class="controls bullet"><span class="by">tomcam</span><span>|</span><a href="#41089795">prev</a><span>|</span><a href="#41089608">next</a><span>|</span><label class="collapse" for="c-41089693">[-]</label><label class="expand" for="c-41089693">[5 more]</label></div><br/><div class="children"><div class="content">Very neat project! It appears to run on qemu. Can someone tell me at the 30,000&#x27; view what&#x27;s required to get it running on actual hardware? I&#x27;m imagining something like signed boot manager, hard disk drivers, etc. They seem to have a ton of USB stuff working which seems amazing to me, but I&#x27;ve been out of the low-level PC loop for a couple decades and don&#x27;t know what prevents working on bare metal in 2024.</div><br/><div id="41089798" class="c"><input type="checkbox" id="c-41089798" checked=""/><div class="controls bullet"><span class="by">boricj</span><span>|</span><a href="#41089693">parent</a><span>|</span><a href="#41090157">next</a><span>|</span><label class="collapse" for="c-41089798">[-]</label><label class="expand" for="c-41089798">[1 more]</label></div><br/><div class="children"><div class="content">At 30,000&#x27; I&#x27;m not seeing anything that would prevent this from booting on hardware. It seems to have a reasonable complement of modern, real-world drivers. On the other hand, physical hardware tends to have bugs, quirks and diversity that VMs don&#x27;t have, so hobby operating systems may have trouble with it if they aren&#x27;t tested on it.</div><br/></div></div><div id="41090157" class="c"><input type="checkbox" id="c-41090157" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41089693">parent</a><span>|</span><a href="#41089798">prev</a><span>|</span><a href="#41090184">next</a><span>|</span><label class="collapse" for="c-41090157">[-]</label><label class="expand" for="c-41090157">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve got a hobby OS that runs on real hardware (sometimes, on some hardware). Mostly it&#x27;s just patience and debugging effort to get things going. qemu defaults to doing some things quickly instead of accurately, so it&#x27;s easy to do things wrong as an OS and if you don&#x27;t test regularly, you can end up with a lot of breakage.<p>I don&#x27;t have a boot manager, my OS is multiboot compatible, so I can boot with qemu&#x27;s multiboot support or PXElinux, or grub or whatever. IMHO, with the multiboot standard, there&#x27;s no need to write a boot loader if you want to build an OS, and no need to write an OS if you want to build a boot loader.<p>Looks like this OS has a good selection of storage drivers, so should be good to go there.</div><br/></div></div><div id="41090184" class="c"><input type="checkbox" id="c-41090184" checked=""/><div class="controls bullet"><span class="by">no92</span><span>|</span><a href="#41089693">parent</a><span>|</span><a href="#41090157">prev</a><span>|</span><a href="#41089608">next</a><span>|</span><label class="collapse" for="c-41090184">[-]</label><label class="expand" for="c-41090184">[2 more]</label></div><br/><div class="children"><div class="content">I have managarm installed on a partition on my testing ThinkPad. The steps needed to get it set up were creating the partition, copying over the sysroot, and adding an entry to my grub configuration.</div><br/><div id="41090215" class="c"><input type="checkbox" id="c-41090215" checked=""/><div class="controls bullet"><span class="by">tomcam</span><span>|</span><a href="#41089693">root</a><span>|</span><a href="#41090184">parent</a><span>|</span><a href="#41089608">next</a><span>|</span><label class="collapse" for="c-41090215">[-]</label><label class="expand" for="c-41090215">[1 more]</label></div><br/><div class="children"><div class="content">Awesome. How is the overall experience?</div><br/></div></div></div></div></div></div><div id="41089608" class="c"><input type="checkbox" id="c-41089608" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#41089693">prev</a><span>|</span><a href="#41090691">next</a><span>|</span><label class="collapse" for="c-41089608">[-]</label><label class="expand" for="c-41089608">[2 more]</label></div><br/><div class="children"><div class="content">Apparently very little past discussion:<p><i>Managarm: August 2022 Update</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32515546">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32515546</a> - Aug 2022 (3 comments)<p><i>The Managarm Operating System</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=24689727">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=24689727</a> - Oct 2020 (1 comment)</div><br/><div id="41089995" class="c"><input type="checkbox" id="c-41089995" checked=""/><div class="controls bullet"><span class="by">npalli</span><span>|</span><a href="#41089608">parent</a><span>|</span><a href="#41090691">next</a><span>|</span><label class="collapse" for="c-41089995">[-]</label><label class="expand" for="c-41089995">[1 more]</label></div><br/><div class="children"><div class="content">The github repo was updated just 5 days back. Not sure what the state was previously, so not much discussion.</div><br/></div></div></div></div><div id="41090691" class="c"><input type="checkbox" id="c-41090691" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#41089608">prev</a><span>|</span><a href="#41088925">next</a><span>|</span><label class="collapse" for="c-41090691">[-]</label><label class="expand" for="c-41090691">[1 more]</label></div><br/><div class="children"><div class="content">Is this a hobby project or intended for real applications? How does it compare performance-wise to Minix 3 or the L4 family (one of which, Hazelnut, was also written in C++)?</div><br/></div></div><div id="41088925" class="c"><input type="checkbox" id="c-41088925" checked=""/><div class="controls bullet"><span class="by">mrbluecoat</span><span>|</span><a href="#41090691">prev</a><span>|</span><a href="#41088956">next</a><span>|</span><label class="collapse" for="c-41088925">[-]</label><label class="expand" for="c-41088925">[2 more]</label></div><br/><div class="children"><div class="content">Are ARM and RISC supported or are the errors on <a href="https:&#x2F;&#x2F;builds.managarm.org" rel="nofollow">https:&#x2F;&#x2F;builds.managarm.org</a> placeholder stubs?</div><br/><div id="41089028" class="c"><input type="checkbox" id="c-41089028" checked=""/><div class="controls bullet"><span class="by">no92</span><span>|</span><a href="#41088925">parent</a><span>|</span><a href="#41088956">next</a><span>|</span><label class="collapse" for="c-41089028">[-]</label><label class="expand" for="c-41089028">[1 more]</label></div><br/><div class="children"><div class="content">The ARM and RISC-V ports are in different states of being a work-in-progress.</div><br/></div></div></div></div><div id="41088956" class="c"><input type="checkbox" id="c-41088956" checked=""/><div class="controls bullet"><span class="by">ironhaven</span><span>|</span><a href="#41088925">prev</a><span>|</span><label class="collapse" for="c-41088956">[-]</label><label class="expand" for="c-41088956">[8 more]</label></div><br/><div class="children"><div class="content">The hubris of calling your operating system pragmatic</div><br/><div id="41089800" class="c"><input type="checkbox" id="c-41089800" checked=""/><div class="controls bullet"><span class="by">bobnamob</span><span>|</span><a href="#41088956">parent</a><span>|</span><a href="#41088972">next</a><span>|</span><label class="collapse" for="c-41089800">[-]</label><label class="expand" for="c-41089800">[1 more]</label></div><br/><div class="children"><div class="content">Doesn’t pragmatic just mean that you’ve knowingly made some tradeoffs that go against the ideal?<p>Admitting that doesn’t read like hubris to me</div><br/></div></div><div id="41088972" class="c"><input type="checkbox" id="c-41088972" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#41088956">parent</a><span>|</span><a href="#41089800">prev</a><span>|</span><a href="#41089072">next</a><span>|</span><label class="collapse" for="c-41088972">[-]</label><label class="expand" for="c-41088972">[1 more]</label></div><br/><div class="children"><div class="content">Your <i>microkernel</i>. I expect the intended point of comparison was “principled and pure”, not “unsuitable for general use”.</div><br/></div></div><div id="41089072" class="c"><input type="checkbox" id="c-41089072" checked=""/><div class="controls bullet"><span class="by">ArsenArsen</span><span>|</span><a href="#41088956">parent</a><span>|</span><a href="#41088972">prev</a><span>|</span><a href="#41089585">next</a><span>|</span><label class="collapse" for="c-41089072">[-]</label><label class="expand" for="c-41089072">[4 more]</label></div><br/><div class="children"><div class="content">WDYM?  &#x27;pragmatic&#x27; here means &#x27;not necessarily purely microkernel-y if very difficult&#x27;.  for instance, the memory manager is in the kernel in managarm</div><br/><div id="41089719" class="c"><input type="checkbox" id="c-41089719" checked=""/><div class="controls bullet"><span class="by">ecjhdnc2025</span><span>|</span><a href="#41088956">root</a><span>|</span><a href="#41089072">parent</a><span>|</span><a href="#41089585">next</a><span>|</span><label class="collapse" for="c-41089719">[-]</label><label class="expand" for="c-41089719">[3 more]</label></div><br/><div class="children"><div class="content">But this &quot;not necessarily purely microkernel-y if very difficult&quot; interpretation essentially means that Windows NT is pragmatic.<p>Because this is pretty much exactly how NT came to be the mess it now is.<p>I wonder if the parent commenter&#x27;s point is that really, almost any OS design can be called &quot;pragmatic&quot;, and therefore stressing it is particularly prideful.</div><br/><div id="41089777" class="c"><input type="checkbox" id="c-41089777" checked=""/><div class="controls bullet"><span class="by">netbsdusers</span><span>|</span><a href="#41088956">root</a><span>|</span><a href="#41089719">parent</a><span>|</span><a href="#41089585">next</a><span>|</span><label class="collapse" for="c-41089777">[-]</label><label class="expand" for="c-41089777">[2 more]</label></div><br/><div class="children"><div class="content">NT is no microkernel, nor has it ever been. It has always been monolithic.</div><br/><div id="41089821" class="c"><input type="checkbox" id="c-41089821" checked=""/><div class="controls bullet"><span class="by">ecjhdnc2025</span><span>|</span><a href="#41088956">root</a><span>|</span><a href="#41089777">parent</a><span>|</span><a href="#41089585">next</a><span>|</span><label class="collapse" for="c-41089821">[-]</label><label class="expand" for="c-41089821">[1 more]</label></div><br/><div class="children"><div class="content">You are perhaps missing the point of what I am saying.<p>But anyway: around the introduction of NT [0] there was clear discussion about how the kernel design was informed by the Mach&#x2F;kernel boundary.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Windows_NT" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Windows_NT</a><p><i>&quot;Like VMS,[24] Windows NT&#x27;s kernel mode code distinguishes between the &quot;kernel&quot;, whose primary purpose is to implement processor- and architecture-dependent functions, and the &quot;executive&quot;. This was designed as a modified microkernel, as the Windows NT kernel was influenced by the Mach microkernel developed by Richard Rashid at Carnegie Mellon University,[26] but does not meet all of the criteria of a pure microkernel.&quot;</i><p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Architecture_of_Windows_NT#Hybrid_kernel_design" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Architecture_of_Windows_NT#Hyb...</a><p><i>[...] the strict distinction between Executive and Kernel is the most prominent remnant of the original microkernel design, and historical design documentation consistently refers to the kernel component as &quot;the microkernel&quot;.</i><p>[0] which I am old enough to remember as an adult and a graduate -- I remember particular criticism from academics in OS design around the time of NT 4.0, which as I (admittedly hazily) recall relaxed some of the distinctive design because 3.5&#x27;s graphics performance was too poor and the graphics subsystem had to be moved essentially into the kernel.</div><br/></div></div></div></div></div></div></div></div><div id="41089585" class="c"><input type="checkbox" id="c-41089585" checked=""/><div class="controls bullet"><span class="by">tomcam</span><span>|</span><a href="#41088956">parent</a><span>|</span><a href="#41089072">prev</a><span>|</span><label class="collapse" for="c-41089585">[-]</label><label class="expand" for="c-41089585">[1 more]</label></div><br/><div class="children"><div class="content">Please elaborate</div><br/></div></div></div></div></div></div></div></div></div></body></html>