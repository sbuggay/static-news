<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1702371683181" as="style"/><link rel="stylesheet" href="styles.css?v=1702371683181"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/TobyLobster/multiply_test">Comparing 6502 Multiply Routines</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>adunk</span> | <span>32 comments</span></div><br/><div><div id="38609394" class="c"><input type="checkbox" id="c-38609394" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#38599200">next</a><span>|</span><label class="collapse" for="c-38609394">[-]</label><label class="expand" for="c-38609394">[3 more]</label></div><br/><div class="children"><div class="content">Although this isn&#x27;t about the 6502, this reminds me of how I had to write x86_64 assembly for class, and was trying to use LEA to avoid a multiplication. After I wrote it, I wondered if the compiler did the same thing I did, but it didn&#x27;t; the compiler&#x27;s version used a register unnecessarily. Compare:<p><pre><code>  ;; Goal: r8 := 10 * r9

  ;; Mine:
  ;; 10x = x + 9x
  ;;  9x = x + 8x
  lea r8, [r9 + 8 * r9]
  add r8, r9

  ;; Compiler&#x27;s code:
  ;; 10x = 2 * 5x = 5x + 5x
  ;;  5x = x + 4x
  lea rdi, [r9 + 4 * r9]
  lea r8, [rdi + rdi]
</code></pre>
At first, I wondered why the compiler introduced a temporary.<p>However, I had just done the exercises from the book <i>The Structure and Interpretation of Computer Programs</i> that ask you to create recursive and iterative routines that multiply integers through successive doubling and halving, by taking advantage of the fact that Cx = C + (C - 1)x, if C is odd, and Cx = 2 * (C &#x2F; 2)x, if C is even (although that&#x27;s not exactly how they explained it; I don&#x27;t perfectly remember and I don&#x27;t feel like looking it up, even though this wasn&#x27;t that long ago).<p>I realized: the compiler must be using a variant of the Russian peasant method of multiplication (which was the name of the method, as the book had explained) as a form of strength reduction. I was impressed, but I also realized that this meant that it was suboptimal for minimizing temporary registers. However, I couldn&#x27;t think of some algorithm that would multiply it the way I did when I wrote that assembly, since I hadn&#x27;t really had an algorithm in mind when writing it.</div><br/><div id="38609972" class="c"><input type="checkbox" id="c-38609972" checked=""/><div class="controls bullet"><span class="by">jlokier</span><span>|</span><a href="#38609394">parent</a><span>|</span><a href="#38599200">next</a><span>|</span><label class="collapse" for="c-38609972">[-]</label><label class="expand" for="c-38609972">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; I was impressed, but I also realized that this meant that it was suboptimal for minimizing temporary registers. However, I couldn&#x27;t think of some algorithm that would multiply it the way I did when I wrote that assembly, since I hadn&#x27;t really had an algorithm in mind when writing it.</i><p>If the compiler were minimising touched architectural registers, it could use the same multiplication method it already does, but output this code:<p><pre><code>  lea r8, [r9 + 4 * r9]
  lea r8, [r8 + r8]
</code></pre>
Or this:<p><pre><code>  lea r8, [r9 + 4 * r9]
  add r8, r8
</code></pre>
If it used your multiplication method, but with the register allocation decisions it appears to use, it could output this code:<p><pre><code>  lea rdi, [r9 + 8 * r9]
  lea r8, [rdi + r9]
</code></pre>
So the compiler&#x27;s decision to use temporary RDI looks to me like a register allocation decision only, independent of multiplication method. (But maybe affected by an lea&#x2F;add decision).</div><br/><div id="38610053" class="c"><input type="checkbox" id="c-38610053" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#38609394">root</a><span>|</span><a href="#38609972">parent</a><span>|</span><a href="#38599200">next</a><span>|</span><label class="collapse" for="c-38610053">[-]</label><label class="expand" for="c-38610053">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right. I don&#x27;t know why, but I didn&#x27;t realize that neither method of multiplication required you to use more than 2 registers here. The use of a temporary register was probably coincidental. Maybe it wouldn&#x27;t have used an extra register if it had needed to spill to the stack in order to use one, and instead maybe it would have written one of the alternatives you wrote. Thanks for letting me know.</div><br/></div></div></div></div></div></div><div id="38599200" class="c"><input type="checkbox" id="c-38599200" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#38609394">prev</a><span>|</span><a href="#38608514">next</a><span>|</span><label class="collapse" for="c-38599200">[-]</label><label class="expand" for="c-38599200">[4 more]</label></div><br/><div class="children"><div class="content">Exactly what the title sounds like. At least one person has gone very far down this rabbit hole, possibly two people. A joy to read through, thank you for posting.<p>This is the sort of comparison that would be great to do for a compiler runtime implementation. Integer division comes to mind. Hard to justify the time.</div><br/><div id="38606245" class="c"><input type="checkbox" id="c-38606245" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#38599200">parent</a><span>|</span><a href="#38608748">next</a><span>|</span><label class="collapse" for="c-38606245">[-]</label><label class="expand" for="c-38606245">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Integer division comes to mind.<p>In case you don’t know about it: <a href="https:&#x2F;&#x2F;libdivide.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;libdivide.com&#x2F;</a><p>Does what you ask for, but for 8-bit CPUs like the 6502, you probably would want to do additional work (I would at least read the output of the C compiler to see whether there’s an ‘easily’ cuttable corner left)</div><br/><div id="38606390" class="c"><input type="checkbox" id="c-38606390" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#38599200">root</a><span>|</span><a href="#38606245">parent</a><span>|</span><a href="#38608748">next</a><span>|</span><label class="collapse" for="c-38606390">[-]</label><label class="expand" for="c-38606390">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In case you don’t know about it: <a href="https:&#x2F;&#x2F;libdivide.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;libdivide.com&#x2F;</a><p>The division routines generated by libdivide assume that fast integer multiplication is available. If it isn&#x27;t, you may be better off with other approaches.</div><br/></div></div></div></div><div id="38608748" class="c"><input type="checkbox" id="c-38608748" checked=""/><div class="controls bullet"><span class="by">djmips</span><span>|</span><a href="#38599200">parent</a><span>|</span><a href="#38606245">prev</a><span>|</span><a href="#38608514">next</a><span>|</span><label class="collapse" for="c-38608748">[-]</label><label class="expand" for="c-38608748">[1 more]</label></div><br/><div class="children"><div class="content">6502 Divide by a constant.
<a href="https:&#x2F;&#x2F;forums.atariage.com&#x2F;blogs&#x2F;entry&#x2F;10805-unsigned-integer-division-routines&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;forums.atariage.com&#x2F;blogs&#x2F;entry&#x2F;10805-unsigned-integ...</a><p>And double coverage - NesDev forum post (same info)
<a href="https:&#x2F;&#x2F;forums.nesdev.org&#x2F;viewtopic.php?t=11336" rel="nofollow noreferrer">https:&#x2F;&#x2F;forums.nesdev.org&#x2F;viewtopic.php?t=11336</a></div><br/></div></div></div></div><div id="38608514" class="c"><input type="checkbox" id="c-38608514" checked=""/><div class="controls bullet"><span class="by">dzdt</span><span>|</span><a href="#38599200">prev</a><span>|</span><a href="#38606248">next</a><span>|</span><label class="collapse" for="c-38608514">[-]</label><label class="expand" for="c-38608514">[4 more]</label></div><br/><div class="children"><div class="content">Just for fun...  I think this should be on the efficient frontier of 8 x 8 -&gt; 16 bit multipliers, at an average cost of around 43 cycles  and memory of 1330 bytes or so. Compare 45.5 cycles and 1580 bytes for the mult66.a fastest in the collection linked.<p><pre><code>  lmul0           = $06   ; pointer into square table low
  lmul1           = $08   ; pointer into square table high
  labs0           = $0a   ; pointer into table of abs(i-1)
  prod_low        = $0c

  \* = $0200

  ; Align tables to start of page
  abstable
    !for i, 0, 255 {
        !byte &lt;(abs(i-1))
    }
  squaretable1_lsb
    !for i, 0, 511 {
        !byte &lt;((i*i)&#x2F;4)
    }
  squaretable1_msb
    !for i, 0, 511 {
        !byte &gt;((i*i)&#x2F;4)
    }

  ; multiply
  ;
  ; f(x) = x*x&#x2F;4
  ;
  ; return f(X+Y) - f(|Y-X|)
  ;
  ; 8 bit x 8bit unsigned multiply, 16 bit result
  ;

  ; On Entry:
  ;  A: multiplier
  ;  Y: multiplicand
  ; On Exit:
  ;  (prod_low, A): product

  mult
    sta lmul0
    sta lmul1
    eor #ff
    sta labs0
    ldx (labs0),Y ;X = abs(Y-A)
    lda (lmul0),Y
    sec
    sbc squaretable1_lsb,X
    sta prod_low
    lda (lmul1),Y
    sbc squaretable1_msb,X
    rts

  ;call this once to initialise high bytes of pointers to table
  mult_init
    lda #&gt;abstable          
    sta labs0+1
    lda #&gt;squaretable1_lsb          
  ; high byte (#2 in this instance)
    sta lmul0+1
    lda #&gt;squaretable1_msb          
  ; high byte (#4 in this instance)
    sta lmul1+1
    rts</code></pre></div><br/><div id="38608720" class="c"><input type="checkbox" id="c-38608720" checked=""/><div class="controls bullet"><span class="by">djmips</span><span>|</span><a href="#38608514">parent</a><span>|</span><a href="#38606248">next</a><span>|</span><label class="collapse" for="c-38608720">[-]</label><label class="expand" for="c-38608720">[3 more]</label></div><br/><div class="children"><div class="content">Nice.  Bonus is that it doesn&#x27;t use self modifying code and another plus one for using ldx(labs0),Y   - Looks like this one can also be optimized for repeated multiplication by the same factor by skipping the first 4 instructions.<p>Did you write this one?</div><br/><div id="38609163" class="c"><input type="checkbox" id="c-38609163" checked=""/><div class="controls bullet"><span class="by">dzdt</span><span>|</span><a href="#38608514">root</a><span>|</span><a href="#38608720">parent</a><span>|</span><a href="#38606248">next</a><span>|</span><label class="collapse" for="c-38609163">[-]</label><label class="expand" for="c-38609163">[2 more]</label></div><br/><div class="children"><div class="content">Oh crap. The LDX (labs0),Y instruction doesn&#x27;t actually exist! If you are cool with undocumented opcodes you can replace that with LAX (labs0),Y which does exist. Otherwise it would need another 2 cycles for TAX.<p>Yes I wrote, based on mult65.a credited to Nick Jameson. That is one of the better ones; I took a look and thought about how it could be sped up a little.</div><br/><div id="38610469" class="c"><input type="checkbox" id="c-38610469" checked=""/><div class="controls bullet"><span class="by">djmips</span><span>|</span><a href="#38608514">root</a><span>|</span><a href="#38609163">parent</a><span>|</span><a href="#38606248">next</a><span>|</span><label class="collapse" for="c-38610469">[-]</label><label class="expand" for="c-38610469">[1 more]</label></div><br/><div class="children"><div class="content">Haha, just like chatgpt - that&#x27;s the same mistakes it makes</div><br/></div></div></div></div></div></div></div></div><div id="38606248" class="c"><input type="checkbox" id="c-38606248" checked=""/><div class="controls bullet"><span class="by">saulpw</span><span>|</span><a href="#38608514">prev</a><span>|</span><a href="#38608241">next</a><span>|</span><label class="collapse" for="c-38606248">[-]</label><label class="expand" for="c-38606248">[10 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t miss those early days of programming.  It&#x27;s fun to optimize and it&#x27;s amazing what you can do with minimal resources, but it took an incredible amount of effort to get a 70s-era computer to do elementary school arithmetic fast enough to be useful.  People spent their lives working on analyses like this, only to find in a scant few years that the next chip has it built-in as a single instruction.</div><br/><div id="38606277" class="c"><input type="checkbox" id="c-38606277" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#38606248">parent</a><span>|</span><a href="#38606526">next</a><span>|</span><label class="collapse" for="c-38606277">[-]</label><label class="expand" for="c-38606277">[1 more]</label></div><br/><div class="children"><div class="content">To be fair, those chips made multiply a single instruction, but they would take tens or hundreds of clock cycles to complete.  What it really saved you was precious working memory, no longer needing to consume a significant chunk of memory with a lookup table in order to multiply at a decent speed.  If your platform has 16kb of working memory then a 2k lookup table is a huge ask.  Even a small 512k lookup table is serious chunk of your memory budget, you have to really consider if wasting hundreds of clock cycles per multiply is a better option.</div><br/></div></div><div id="38606526" class="c"><input type="checkbox" id="c-38606526" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#38606248">parent</a><span>|</span><a href="#38606277">prev</a><span>|</span><a href="#38607069">next</a><span>|</span><label class="collapse" for="c-38606526">[-]</label><label class="expand" for="c-38606526">[5 more]</label></div><br/><div class="children"><div class="content">I love these early days of programming as I do it as hobby.  What&#x27;s pretty amazing is how much you can do without any multiplication or division at all.  With add, substract, and shifts you can do a surprising amount on a computer.</div><br/><div id="38609062" class="c"><input type="checkbox" id="c-38609062" checked=""/><div class="controls bullet"><span class="by">dhosek</span><span>|</span><a href="#38606248">root</a><span>|</span><a href="#38606526">parent</a><span>|</span><a href="#38607776">next</a><span>|</span><label class="collapse" for="c-38609062">[-]</label><label class="expand" for="c-38609062">[1 more]</label></div><br/><div class="children"><div class="content">I remember “discovering” shift and add as a high school student for doing multiply by 40 (a useful operation for screen mapping) as an improvement over the more naïve <i>x</i>×<i>y</i> = <i>x</i>+<i>x</i>+…(<i>y</i> times)…+<i>x</i>.<p>But seeing the table of squares thing, I see the genius of being able to take (<i>x</i>+<i>y</i>)²-(<i>x</i>-<i>y</i>)²=(<i>x</i>²+2<i>xy</i>+<i>y</i>²)-(<i>x</i>²-2<i>xy</i>+<i>y</i>²)= 4<i>xy</i> and what a brilliant piece of math that is.</div><br/></div></div><div id="38607776" class="c"><input type="checkbox" id="c-38607776" checked=""/><div class="controls bullet"><span class="by">gary_0</span><span>|</span><a href="#38606248">root</a><span>|</span><a href="#38606526">parent</a><span>|</span><a href="#38609062">prev</a><span>|</span><a href="#38607069">next</a><span>|</span><label class="collapse" for="c-38607776">[-]</label><label class="expand" for="c-38607776">[3 more]</label></div><br/><div class="children"><div class="content">With shifts, you can multiply and divide by any number you want, as long as it&#x27;s a power of two. ;)</div><br/><div id="38609130" class="c"><input type="checkbox" id="c-38609130" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#38606248">root</a><span>|</span><a href="#38607776">parent</a><span>|</span><a href="#38607841">next</a><span>|</span><label class="collapse" for="c-38609130">[-]</label><label class="expand" for="c-38609130">[1 more]</label></div><br/><div class="children"><div class="content">You can do it by any number if you toss in addition. If you’re multiplying by a constant, you can factor it out.<p>For example multiply by 40 (coincidentally the number of characters per line on common microcomputers), you could shift to multiply by 32, shift to multiply by 8, and add them together. Took some additional storage but was faster, particularly for 16 bit, than a general routine.</div><br/></div></div><div id="38607841" class="c"><input type="checkbox" id="c-38607841" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#38606248">root</a><span>|</span><a href="#38607776">parent</a><span>|</span><a href="#38609130">prev</a><span>|</span><a href="#38607069">next</a><span>|</span><label class="collapse" for="c-38607841">[-]</label><label class="expand" for="c-38607841">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Doctor, my arm really hurts when I bend it this way, do you have any advice?&quot;  &quot;Don&#x27;t bend your arm that way&quot;<p>You can honestly get around not needing arbitrary multiplication and division by just avoiding numbers that aren&#x27;t powers of two.  No oddly sized data structures, for example.  It works well unless, of course, you&#x27;re building a calculator.</div><br/></div></div></div></div></div></div><div id="38607069" class="c"><input type="checkbox" id="c-38607069" checked=""/><div class="controls bullet"><span class="by">JohnFen</span><span>|</span><a href="#38606248">parent</a><span>|</span><a href="#38606526">prev</a><span>|</span><a href="#38606652">next</a><span>|</span><label class="collapse" for="c-38607069">[-]</label><label class="expand" for="c-38607069">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m the exact opposite from you on this. One of the main reasons why I switched to extremely tiny microcontrollers for my hobby projects is because they bring a lot of those days back for me.<p>Vive la différence! :)</div><br/></div></div><div id="38606652" class="c"><input type="checkbox" id="c-38606652" checked=""/><div class="controls bullet"><span class="by">tonyedgecombe</span><span>|</span><a href="#38606248">parent</a><span>|</span><a href="#38607069">prev</a><span>|</span><a href="#38608284">next</a><span>|</span><label class="collapse" for="c-38606652">[-]</label><label class="expand" for="c-38606652">[1 more]</label></div><br/><div class="children"><div class="content">I quite enjoyed working within those tight constraints. It&#x27;s very satisfying squeezing every last drop of blood from the system.<p>What I don&#x27;t miss is the lack of reliability. Modern systems are so dependable compared to what we had to deal with back then. Also it&#x27;s nice being able to download your tools for free and find documentation online.</div><br/></div></div><div id="38608284" class="c"><input type="checkbox" id="c-38608284" checked=""/><div class="controls bullet"><span class="by">m463</span><span>|</span><a href="#38606248">parent</a><span>|</span><a href="#38606652">prev</a><span>|</span><a href="#38608241">next</a><span>|</span><label class="collapse" for="c-38608284">[-]</label><label class="expand" for="c-38608284">[1 more]</label></div><br/><div class="children"><div class="content">I remember at the time thinking how much they could pull off with so little hardware.<p>An IBM mainframe could do a giant block move (with padding) in one instruction.<p>but a normal person couldn&#x27;t afford that.  But a 6502 was in reach.<p>With the 6502 you had to be clever and do something similar in software.<p>But yeah.  It was enlightening when the 6502 didn&#x27;t have an add instruction.<p>(you had to do clear carry, then add with carry)<p>These kind of tradeoffs persist through time.  People do all kinds of ridiculous things with an inexpensive ESP8266 or ESP32.</div><br/></div></div></div></div><div id="38608241" class="c"><input type="checkbox" id="c-38608241" checked=""/><div class="controls bullet"><span class="by">sambeau</span><span>|</span><a href="#38606248">prev</a><span>|</span><a href="#38607790">next</a><span>|</span><label class="collapse" for="c-38608241">[-]</label><label class="expand" for="c-38608241">[1 more]</label></div><br/><div class="children"><div class="content">Yet again I am struck by how incredible it is that Braben and Bell, two undergraduate students, could produce something as ground-breaking as Elite—all the way down to writing their own multiplication routines.</div><br/></div></div><div id="38607790" class="c"><input type="checkbox" id="c-38607790" checked=""/><div class="controls bullet"><span class="by">justinlloyd</span><span>|</span><a href="#38608241">prev</a><span>|</span><a href="#38608063">next</a><span>|</span><label class="collapse" for="c-38607790">[-]</label><label class="expand" for="c-38607790">[1 more]</label></div><br/><div class="children"><div class="content">The customization section is interesting, though it is missing things such as multiply &amp; conquer, table wrapping, and the mask &amp; jump techniques, but then, you aren&#x27;t going to find every custom technique covered in any one text. Sine, cosine, and atan, usually used dual interweaving tables that wrapped, and for distance, you could use a short table and a long table that used Manhattan distance to do the lookup depending on whether X &gt; Y or Y &gt; X.<p>Edit: I see a link to another github on that page to sqrt implementations. I suspect that will make for interesting reading too.</div><br/></div></div><div id="38608063" class="c"><input type="checkbox" id="c-38608063" checked=""/><div class="controls bullet"><span class="by">deater</span><span>|</span><a href="#38607790">prev</a><span>|</span><a href="#38607291">next</a><span>|</span><label class="collapse" for="c-38608063">[-]</label><label class="expand" for="c-38608063">[1 more]</label></div><br/><div class="children"><div class="content">My Apple II &quot;Mode 7&quot; demo relies heavily on a &quot;table of squares&quot; multiply alogorithm, though it&#x27;s signed (vs unsigned) which is even more of a pain on 6502.
<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=o8427JsfGwk" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=o8427JsfGwk</a><p>So many 16-bit demo effects assume you have a decently fast multiply or divide instruction, which makes it really hard to do the same effects on 6502 (as I found with the second reality remake)</div><br/></div></div><div id="38607291" class="c"><input type="checkbox" id="c-38607291" checked=""/><div class="controls bullet"><span class="by">dzdt</span><span>|</span><a href="#38608063">prev</a><span>|</span><a href="#38606606">next</a><span>|</span><label class="collapse" for="c-38607291">[-]</label><label class="expand" for="c-38607291">[3 more]</label></div><br/><div class="children"><div class="content">He is missing the state-of-the-art result for 16 x 16 -&gt; 32 bit. That would be Repose in this CSDB thread : <a href="https:&#x2F;&#x2F;csdb.dk&#x2F;forums&#x2F;?roomid=11&amp;topicid=91766" rel="nofollow noreferrer">https:&#x2F;&#x2F;csdb.dk&#x2F;forums&#x2F;?roomid=11&amp;topicid=91766</a> at 190 cycles (depending on how exactly you count).</div><br/><div id="38607570" class="c"><input type="checkbox" id="c-38607570" checked=""/><div class="controls bullet"><span class="by">mwcremer</span><span>|</span><a href="#38607291">parent</a><span>|</span><a href="#38606606">next</a><span>|</span><label class="collapse" for="c-38607570">[-]</label><label class="expand" for="c-38607570">[2 more]</label></div><br/><div class="children"><div class="content">That same thread seems to indicate Repose&#x27;s code is mult15.a, which indeed holds the cycles record at 206.60.</div><br/><div id="38607683" class="c"><input type="checkbox" id="c-38607683" checked=""/><div class="controls bullet"><span class="by">dzdt</span><span>|</span><a href="#38607291">root</a><span>|</span><a href="#38607570">parent</a><span>|</span><a href="#38606606">next</a><span>|</span><label class="collapse" for="c-38607683">[-]</label><label class="expand" for="c-38607683">[1 more]</label></div><br/><div class="children"><div class="content">No, he improved it since the version TonyLobster tested. Quoting:<p>It&#x27;s 2023 - is your 16x16=32 bit unsigned multiply under 190 cycles yet? What? No?!? Let me help you out buddy!
Much to my surprise, I have surpassed by previous best by 10.5 cycles or 5%, when I thought it couldn&#x27;t be optimized further. How is this possible you ask?
The first trick had to do with how cycles are counted. As a shortcut, we usually average branches&#x2F;boundary crossings. However, some carries happen only 7% of the time, so optimizing for the average case actually slows you down. You should be optimizing for the no carry case.
The other trick was playing with using registers to accumulate results. It wasn&#x27;t as simple as it sounds; the order of multiplies had to be optimized to leave a target value in the A register.<p>The goal: multiply the two 16-bit numbers in x0, x1 and y0, y1 (low bytes and high bytes) and return the results in the fastest way possible (which may leave some results in registers, preferably in a useful way like the high bytes). I measure the timing in this convention to expose a timing which could be used in-line, as is often the case for demo effects. In this case, the 3rd byte is returned in A, which could be useful for a multiple accumulate where only the high 16-bits are kept.<p>The time is 188.1 cycles, averaged over all possible inputs. The (accurate) time of my version on codebase is 198.6<p>To be clear, z=x<i>y or (z3, z2, z1, z0) = (x1, x0) </i> (y1, y0).<p>;This section performs the 4 sub-multiplies to form
;  the partials to be added later in self-mod code.
;Addresses like &quot;x1y0l+1&quot; refer to low(x1*y0) stored
;  to the argument of a later &quot;adc #{value}&quot;
;mult8_set_mier_snippet {multiplier}
;mult8_snippet {multiplicand}, {low result}, {high result}
+mult8_set_mier_snippet x1          ;17
+mult8_snippet y0, x1y0l+1, x1y0h+1 ;35
+mult8_snippet y1, x1y1l+1, z3      ;32
+mult8_set_mier_snippet x0          ;17
+mult8_snippet &quot;Y&quot;, x0y1l+1, &quot;X&quot;    ;28
+mult8_snippet y0, z0, &quot;A&quot;          ;28
;results in X=x0y1h and A=x0y0h
;multiply part total: 149-165, average 157
;z3           z2           z1
                           clc
                     x0y1l adc #0 ;x0y0h + x0y1l
                           tay ;6
              txa
        x1y0h adc #0 ;x0y1h + x1y0h
              tax
              bcc + ;9
inc z3
clc ;(+6) taken 7% of the time
                         + tya
                     x1y0l adc #0 ;+ x1y0l
                           sta z1 ;7
              txa
        x1y1l adc #0 ;+ x1y1l
              bcc done ;7
inc z3 ;(+4) taken 42% of the time<p>Column 1 takes 13 cycles, column 2 takes 16 cycles, and column 3 takes 2.1 cycles.
The total time to add the partial products is 29-39 with an average of 31.1.
The results are returned as a 32-bit result:
z3, A(=z2), z1, z0.
The total time is 156.96875+31.1=188.06875 (178-204).</div><br/></div></div></div></div></div></div><div id="38606606" class="c"><input type="checkbox" id="c-38606606" checked=""/><div class="controls bullet"><span class="by">sunpazed</span><span>|</span><a href="#38607291">prev</a><span>|</span><a href="#38608128">next</a><span>|</span><label class="collapse" for="c-38606606">[-]</label><label class="expand" for="c-38606606">[2 more]</label></div><br/><div class="children"><div class="content">I’m writing a pinball game in assembly for the original Gameboy, and recently had to hand-craft multiply, division and cosine routines to trade off accuracy for spare cycles. Something like this would have come in handy!!</div><br/><div id="38606719" class="c"><input type="checkbox" id="c-38606719" checked=""/><div class="controls bullet"><span class="by">OnlyMortal</span><span>|</span><a href="#38606606">parent</a><span>|</span><a href="#38608128">next</a><span>|</span><label class="collapse" for="c-38606719">[-]</label><label class="expand" for="c-38606719">[1 more]</label></div><br/><div class="children"><div class="content">I assume you used a table of cosine values bit shifted?</div><br/></div></div></div></div><div id="38608128" class="c"><input type="checkbox" id="c-38608128" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#38606606">prev</a><span>|</span><a href="#38606252">next</a><span>|</span><label class="collapse" for="c-38608128">[-]</label><label class="expand" for="c-38608128">[1 more]</label></div><br/><div class="children"><div class="content">If you want to multiply by a constant, you instead do Bitsifts and Additions&#x2F;Subtrations in a particular sequence.</div><br/></div></div><div id="38606252" class="c"><input type="checkbox" id="c-38606252" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#38608128">prev</a><span>|</span><label class="collapse" for="c-38606252">[-]</label><label class="expand" for="c-38606252">[1 more]</label></div><br/><div class="children"><div class="content">The graphical error plots for the versions that approximate are a joy to behold.  You can clearly see the ringing and how the error bars tend to grow larger with bigger inputs.</div><br/></div></div></div></div></div></div></div></body></html>