<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1724835687388" as="style"/><link rel="stylesheet" href="styles.css?v=1724835687388"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/klee/klee">KLEE Symbolic Execution Engine</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>nateb2022</span> | <span>13 comments</span></div><br/><div><div id="41372952" class="c"><input type="checkbox" id="c-41372952" checked=""/><div class="controls bullet"><span class="by">MaxBarraclough</span><span>|</span><a href="#41373054">next</a><span>|</span><label class="collapse" for="c-41372952">[-]</label><label class="expand" for="c-41372952">[1 more]</label></div><br/><div class="children"><div class="content">The project&#x27;s webpage is a more helpful starting point than the repository: <a href="https:&#x2F;&#x2F;klee-se.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;klee-se.org&#x2F;</a></div><br/></div></div><div id="41373054" class="c"><input type="checkbox" id="c-41373054" checked=""/><div class="controls bullet"><span class="by">anonymousDan</span><span>|</span><a href="#41372952">prev</a><span>|</span><a href="#41376086">next</a><span>|</span><label class="collapse" for="c-41373054">[-]</label><label class="expand" for="c-41373054">[9 more]</label></div><br/><div class="children"><div class="content">Is anyone actually using symbolic execution in industry these days? I personally like it but I feel like fuzzing has completely taken over in terms of academic research at least.</div><br/><div id="41375354" class="c"><input type="checkbox" id="c-41375354" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#41373054">parent</a><span>|</span><a href="#41373590">next</a><span>|</span><label class="collapse" for="c-41375354">[-]</label><label class="expand" for="c-41375354">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s certainly still being used. I use bounded model checking, which performs a kind of symbolic execution using an SMT solver.<p>For more complex things that aren&#x27;t as easy to model check, such as the formal verification of a deeply recursive algorithm or a cryptographic algorithm against specification, I&#x27;ll use Coq or Lean to define an abstract machine model, then either extract code from this model into C, C++, or machine code, or when something hand written is required, extract code into an intermediate format, then import hand written source code into this same format, then prove the two equivalent.<p>Fuzzing is useful, but fuzzing serves different goals. With fuzzing, you can find execution paths that are incorrect, with a reproducer. However, these paths must be reachable with the fuzzer within the search depth defined. Fuzzing can find failure cases, but it can&#x27;t prove the absence of such cases. Model checking can be significantly faster if well engineered, and it can be used to prove the absence of classes of errors. The same goes with constructive proofs in a proof assistant. The two approaches are complementary. One doesn&#x27;t replace the other.</div><br/></div></div><div id="41373590" class="c"><input type="checkbox" id="c-41373590" checked=""/><div class="controls bullet"><span class="by">nekitamo</span><span>|</span><a href="#41373054">parent</a><span>|</span><a href="#41375354">prev</a><span>|</span><a href="#41376150">next</a><span>|</span><label class="collapse" for="c-41373590">[-]</label><label class="expand" for="c-41373590">[2 more]</label></div><br/><div class="children"><div class="content">I’ve been using Triton a lot lately to make sense of heavily obfuscated code. The ability to translate a symbolic “trace” into an LLVM bitcode listing is super useful. You can do a lot of optimizations from there easily to recover the original code:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;JonathanSalwan&#x2F;Triton&#x2F;wiki">https:&#x2F;&#x2F;github.com&#x2F;JonathanSalwan&#x2F;Triton&#x2F;wiki</a></div><br/><div id="41373787" class="c"><input type="checkbox" id="c-41373787" checked=""/><div class="controls bullet"><span class="by">__alexander</span><span>|</span><a href="#41373054">root</a><span>|</span><a href="#41373590">parent</a><span>|</span><a href="#41376150">next</a><span>|</span><label class="collapse" for="c-41373787">[-]</label><label class="expand" for="c-41373787">[1 more]</label></div><br/><div class="children"><div class="content">Your deobfuscating process would make a good blog post :)</div><br/></div></div></div></div><div id="41376150" class="c"><input type="checkbox" id="c-41376150" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#41373054">parent</a><span>|</span><a href="#41373590">prev</a><span>|</span><a href="#41373345">next</a><span>|</span><label class="collapse" for="c-41376150">[-]</label><label class="expand" for="c-41376150">[2 more]</label></div><br/><div class="children"><div class="content">Yes, we do. Fuzzing takes forever and only finds errors by luck, whilst with cbmc you&#x27;ll find all errors within short loops (=data).<p>Klee is dead for years.<p>Both needs extra setup, but my make verify targets are still much easier to setup and run, than make fuzz.</div><br/><div id="41377291" class="c"><input type="checkbox" id="c-41377291" checked=""/><div class="controls bullet"><span class="by">anonymousDan</span><span>|</span><a href="#41373054">root</a><span>|</span><a href="#41376150">parent</a><span>|</span><a href="#41373345">next</a><span>|</span><label class="collapse" for="c-41377291">[-]</label><label class="expand" for="c-41377291">[1 more]</label></div><br/><div class="children"><div class="content">CBMC is a model checker though  right, not a symbolic execution engine? Or do you feel for all intents and purposes there is no difference?</div><br/></div></div></div></div><div id="41373345" class="c"><input type="checkbox" id="c-41373345" checked=""/><div class="controls bullet"><span class="by">topazas</span><span>|</span><a href="#41373054">parent</a><span>|</span><a href="#41376150">prev</a><span>|</span><a href="#41373475">next</a><span>|</span><label class="collapse" for="c-41373345">[-]</label><label class="expand" for="c-41373345">[1 more]</label></div><br/><div class="children"><div class="content">I would like to - but unable to find any libraries &#x2F; engines that would function in a some sort of &#x27;mocked&#x27; environment. for example - i need to cover all execution paths for only single function with high cyclomatic complexity, given all other stuff is mocked. Maybe it would be called unit test mix with se. also for dynamic languages such as php&#x2F;python&#x2F;ruby.</div><br/></div></div><div id="41373475" class="c"><input type="checkbox" id="c-41373475" checked=""/><div class="controls bullet"><span class="by">drdrey</span><span>|</span><a href="#41373054">parent</a><span>|</span><a href="#41373345">prev</a><span>|</span><a href="#41376086">next</a><span>|</span><label class="collapse" for="c-41373475">[-]</label><label class="expand" for="c-41373475">[2 more]</label></div><br/><div class="children"><div class="content">does Kani count?<p><a href="https:&#x2F;&#x2F;github.com&#x2F;model-checking&#x2F;kani">https:&#x2F;&#x2F;github.com&#x2F;model-checking&#x2F;kani</a></div><br/><div id="41375027" class="c"><input type="checkbox" id="c-41375027" checked=""/><div class="controls bullet"><span class="by">PartiallyTyped</span><span>|</span><a href="#41373054">root</a><span>|</span><a href="#41373475">parent</a><span>|</span><a href="#41376086">next</a><span>|</span><label class="collapse" for="c-41375027">[-]</label><label class="expand" for="c-41375027">[1 more]</label></div><br/><div class="children"><div class="content">It should! Kani’s used by AWS’ Firecracker hypervisor.</div><br/></div></div></div></div></div></div><div id="41376086" class="c"><input type="checkbox" id="c-41376086" checked=""/><div class="controls bullet"><span class="by">xanzi2048</span><span>|</span><a href="#41373054">prev</a><span>|</span><label class="collapse" for="c-41376086">[-]</label><label class="expand" for="c-41376086">[2 more]</label></div><br/><div class="children"><div class="content">Nowhere in the repo or the linked website does this explain what it does or why it&#x27;s useful. What is this for?</div><br/><div id="41376116" class="c"><input type="checkbox" id="c-41376116" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#41376086">parent</a><span>|</span><label class="collapse" for="c-41376116">[-]</label><label class="expand" for="c-41376116">[1 more]</label></div><br/><div class="children"><div class="content">Symbolic Execution is a term of art for a kind of program analysis using symbolic value inputs.  <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Symbolic_execution" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Symbolic_execution</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>