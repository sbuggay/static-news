<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1696064459061" as="style"/><link rel="stylesheet" href="styles.css?v=1696064459061"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://concurrencyfreaks.blogspot.com/2023/09/50-years-later-is-two-phase-locking.html">50 years later, is two-phase locking the best we can do?</a> <span class="domain">(<a href="http://concurrencyfreaks.blogspot.com">concurrencyfreaks.blogspot.com</a>)</span></div><div class="subtext"><span>ingve</span> | <span>59 comments</span></div><br/><div><div id="37712572" class="c"><input type="checkbox" id="c-37712572" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#37712020">next</a><span>|</span><label class="collapse" for="c-37712572">[-]</label><label class="expand" for="c-37712572">[13 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a beginner in this topic and I find this topic interesting. I really want there to be an easy-to-deploy consistency solution.<p>If I have a distributed microservice architecture and I want to keep multiple datastores in synchronization or &quot;consistent&quot; what&#x27;s the industry best practice?<p>A few days ago I was trying to solve the inconsistency problem with &quot;settled timestamps&quot; which is a kind of multiversioning idea except that timestamps elapsed with the absence of reported error represent a valid save&#x2F;commit. Kind of like two phase commit with the second phase being time. The idea is that we watch the clocks of other servers and if they don&#x27;t update then we know we cannot trust their settled timestamps. (My intent was to allow scaling consistency across many servers, because we don&#x27;t need to wait for response for every update, we only need to wait for the next timestamp interval)<p>Here&#x27;s my Multithreaded multiprocessing Python code to test indeterminancy. 10 threads all send eachother random updates. They also broadcast their own timestamp and the timestamps of their own perspective of the timestamps every other server.<p><a href="https:&#x2F;&#x2F;replit.com&#x2F;@Chronological&#x2F;InconsistencySimulation#main.py">https:&#x2F;&#x2F;replit.com&#x2F;@Chronological&#x2F;InconsistencySimulation#ma...</a>
(click Run and watch the output, you&#x27;ll have to wait 10 seconds)<p>A read in this simulation is the MIN of all timestamps of all servers reported timestamps.<p>10 seconds into the simulation, we ask every thread for its own perspective of what the counter value is. Sometimes they will all report the same value, a lot of the time they shall be split brained.<p>I am aware that wall clock timestamps are not suitable for ordering in a distributed system and that logical or vector clocks should be used for ordering.<p>If you can get the simulation to all report the same number at any point in time, then that would be great :-)<p>Ordering in distributed systems is significant, as the eventual consistency of the simulation means that some values can arrive late but affect the value, meaning it is not linearizable. Bloomlang tries to solve this.<p>I&#x27;m specifically interested in scaling WITH consistency but I think this is quite difficult.</div><br/><div id="37713657" class="c"><input type="checkbox" id="c-37713657" checked=""/><div class="controls bullet"><span class="by">theptip</span><span>|</span><a href="#37712572">parent</a><span>|</span><a href="#37712617">next</a><span>|</span><label class="collapse" for="c-37713657">[-]</label><label class="expand" for="c-37713657">[2 more]</label></div><br/><div class="children"><div class="content">Look at the Raft protocol. In general you’d rather not integrate at the protocol layer; it’s standard to use a consistent store like etcd that implements Raft for the coordination&#x2F;data that needs to be serializable.<p>(Kubernetes uses etcd so it scales pretty well for a strongly-consistent k&#x2F;v store.)<p>You said “multiple datastores” so I’m assuming you have heterogenous data and something like CockroachDB isn’t an option.<p>&gt; I&#x27;m a beginner in this topic and I find this topic interesting.<p>Not trying to gatekeepe but rolling your own is dangerous. See <a href="https:&#x2F;&#x2F;aphyr.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;aphyr.com&#x2F;</a> for the gold standard in testing (great educational material). You can use Jepsen to test your distributed systems. But better to just use datastores that Kyle has shown are solid.</div><br/><div id="37713723" class="c"><input type="checkbox" id="c-37713723" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#37712572">root</a><span>|</span><a href="#37713657">parent</a><span>|</span><a href="#37712617">next</a><span>|</span><label class="collapse" for="c-37713723">[-]</label><label class="expand" for="c-37713723">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for your reply.<p>I&#x27;ve experimented with a toy Raft implementation but I haven&#x27;t Jepsen tested that and it&#x27;s incomplete<p>I did write a Jepsen test for a different eventually consistent protocol which understandably fails the linearizability test because I&#x27;m still learning - eventually consistent is not linearizable.<p><a href="https:&#x2F;&#x2F;GitHub.com&#x2F;samsquire&#x2F;eventually-consistent-mesh">https:&#x2F;&#x2F;GitHub.com&#x2F;samsquire&#x2F;eventually-consistent-mesh</a><p>I want to have my cake and eat it too. Scalability and consistency.</div><br/></div></div></div></div><div id="37712617" class="c"><input type="checkbox" id="c-37712617" checked=""/><div class="controls bullet"><span class="by">rawgabbit</span><span>|</span><a href="#37712572">parent</a><span>|</span><a href="#37713657">prev</a><span>|</span><a href="#37713123">next</a><span>|</span><label class="collapse" for="c-37712617">[-]</label><label class="expand" for="c-37712617">[7 more]</label></div><br/><div class="children"><div class="content">For distributed systems, the main idea is a centralized write ordering journal that is replayed by individual nodes.<p>Multiple systems write sequentially to the central journal. The journal is simply taking requests like a key value store. The journal is replicated to all the nodes. The nodes read from the journal and performs the  complex logic requested.</div><br/><div id="37712942" class="c"><input type="checkbox" id="c-37712942" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#37712572">root</a><span>|</span><a href="#37712617">parent</a><span>|</span><a href="#37713563">next</a><span>|</span><label class="collapse" for="c-37712942">[-]</label><label class="expand" for="c-37712942">[5 more]</label></div><br/><div class="children"><div class="content">If business software practices is not enough of a proof, look at any massive online games. They all use  one central server as a source of truth about the game world, and broadcast that state to the clients. Anything a client reports that diverges from the central server view is either corrected, rejected, or becomes a reason to disconnect the client for cheating attempts.<p>If you need strict order, that order should happen in strictly one place. (The universe itself does not support strict order at a distance, as Special Relativity shows.)</div><br/><div id="37713464" class="c"><input type="checkbox" id="c-37713464" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#37712572">root</a><span>|</span><a href="#37712942">parent</a><span>|</span><a href="#37713563">next</a><span>|</span><label class="collapse" for="c-37713464">[-]</label><label class="expand" for="c-37713464">[4 more]</label></div><br/><div class="children"><div class="content">Bitcoin: Am I joke to you?<p>Everyone: yes.</div><br/><div id="37713747" class="c"><input type="checkbox" id="c-37713747" checked=""/><div class="controls bullet"><span class="by">sfifs</span><span>|</span><a href="#37712572">root</a><span>|</span><a href="#37713464">parent</a><span>|</span><a href="#37713690">next</a><span>|</span><label class="collapse" for="c-37713747">[-]</label><label class="expand" for="c-37713747">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t bitcoin actually eventual consensus determined by increasing unlikelihood of finding a conflicting sequence of hashes?</div><br/></div></div><div id="37713690" class="c"><input type="checkbox" id="c-37713690" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#37712572">root</a><span>|</span><a href="#37713464">parent</a><span>|</span><a href="#37713747">prev</a><span>|</span><a href="#37713525">next</a><span>|</span><label class="collapse" for="c-37713690">[-]</label><label class="expand" for="c-37713690">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no performance gain from bitcoin&#x27;s approach though. The distributed consensus is there for trustless operation, not performance. It&#x27;s many orders of magnitude slower (and a few more orders of magnitude more power inefficient!) than just having one server handle it.</div><br/></div></div><div id="37713525" class="c"><input type="checkbox" id="c-37713525" checked=""/><div class="controls bullet"><span class="by">rusk</span><span>|</span><a href="#37712572">root</a><span>|</span><a href="#37713464">parent</a><span>|</span><a href="#37713690">prev</a><span>|</span><a href="#37713563">next</a><span>|</span><label class="collapse" for="c-37713525">[-]</label><label class="expand" for="c-37713525">[1 more]</label></div><br/><div class="children"><div class="content">Bitcoin is an interesting exception to the above. Issue is latency.</div><br/></div></div></div></div></div></div><div id="37713563" class="c"><input type="checkbox" id="c-37713563" checked=""/><div class="controls bullet"><span class="by">mjan22640</span><span>|</span><a href="#37712572">root</a><span>|</span><a href="#37712617">parent</a><span>|</span><a href="#37712942">prev</a><span>|</span><a href="#37713123">next</a><span>|</span><label class="collapse" for="c-37713563">[-]</label><label class="expand" for="c-37713563">[1 more]</label></div><br/><div class="children"><div class="content">that is server&#x2F;many clients, not distributed</div><br/></div></div></div></div><div id="37713123" class="c"><input type="checkbox" id="c-37713123" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#37712572">parent</a><span>|</span><a href="#37712617">prev</a><span>|</span><a href="#37713201">next</a><span>|</span><label class="collapse" for="c-37713123">[-]</label><label class="expand" for="c-37713123">[1 more]</label></div><br/><div class="children"><div class="content">I’d suggest to re-evaluate if you really, <i>really</i> need (a) distributed data stores and (b) synchronous consistency. Things become much simpler if you can forego one of them.</div><br/></div></div><div id="37713201" class="c"><input type="checkbox" id="c-37713201" checked=""/><div class="controls bullet"><span class="by">infogulch</span><span>|</span><a href="#37712572">parent</a><span>|</span><a href="#37713123">prev</a><span>|</span><a href="#37712809">next</a><span>|</span><label class="collapse" for="c-37713201">[-]</label><label class="expand" for="c-37713201">[1 more]</label></div><br/><div class="children"><div class="content">I suspect TigerBeetle DB will be the industry benchmark for consistent, high throughput, fault tolerant, distributed databases in 5 years.</div><br/></div></div><div id="37712809" class="c"><input type="checkbox" id="c-37712809" checked=""/><div class="controls bullet"><span class="by">acuozzo</span><span>|</span><a href="#37712572">parent</a><span>|</span><a href="#37713201">prev</a><span>|</span><a href="#37712020">next</a><span>|</span><label class="collapse" for="c-37712809">[-]</label><label class="expand" for="c-37712809">[1 more]</label></div><br/><div class="children"><div class="content">Is your inter-machine messaging asynchronous and is it possible for one of your machines to crash?</div><br/></div></div></div></div><div id="37712020" class="c"><input type="checkbox" id="c-37712020" checked=""/><div class="controls bullet"><span class="by">eartheaterrr</span><span>|</span><a href="#37712572">prev</a><span>|</span><a href="#37713705">next</a><span>|</span><label class="collapse" for="c-37712020">[-]</label><label class="expand" for="c-37712020">[2 more]</label></div><br/><div class="children"><div class="content">I wonder how this new approach compares to serializable snapshot isolation (SSI)
<a href="https:&#x2F;&#x2F;wiki.postgresql.org&#x2F;wiki&#x2F;SSI" rel="nofollow noreferrer">https:&#x2F;&#x2F;wiki.postgresql.org&#x2F;wiki&#x2F;SSI</a><p>I&#x27;m not familiar with these technologies, but when I was studying databases, SSI was touted as the &quot;better&quot; 2PL on the horizon. I wonder how SSI compares to 2PLSF, and why it wasn&#x27;t mentioned here?</div><br/><div id="37712299" class="c"><input type="checkbox" id="c-37712299" checked=""/><div class="controls bullet"><span class="by">3cats-in-a-coat</span><span>|</span><a href="#37712020">parent</a><span>|</span><a href="#37713705">next</a><span>|</span><label class="collapse" for="c-37712299">[-]</label><label class="expand" for="c-37712299">[1 more]</label></div><br/><div class="children"><div class="content">I’m working on a memory model for a new platform which is almost entirely based around copy on write, snapshots and SSI. But in distributed effects you still need locks and two phase transactions and so on. These are largely complementary features imo.</div><br/></div></div></div></div><div id="37711863" class="c"><input type="checkbox" id="c-37711863" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#37713705">prev</a><span>|</span><a href="#37712836">next</a><span>|</span><label class="collapse" for="c-37711863">[-]</label><label class="expand" for="c-37711863">[7 more]</label></div><br/><div class="children"><div class="content">For Wait-Or-Die, do you really need to fetch_and_add to get a transaction ID?  Do you need a transaction ID at all?  It sounds like the goal is just to have an arbitrary-but-consistent ordering of active transactions so that different transactions can agree on who should wait and who should die in the event of a conflict.  So why not just use the thread ID?  Or even a random number might work (if ties are treated as “die”, so the worst that happens is that both transactions unnecessarily abort, and then retry with new random numbers).<p>While it’s not mentioned, I suppose you want to prioritize older transactions in order to prevent long-running transactions from being starved by shorter-running transactions.  (If one long transaction conflicts with an average of, say, three short transactions, and on each conflict it’s effectively random who wins, then each long transaction has only a 1&#x2F;8 chance of winning all three conflicts and being able to commit.)<p>But preventing starvation only requires older transactions to be prioritized most of the time, not every single time, especially not if the transaction is only slightly older.  So some kind of timestamp &#x2F; cycle counter should work fine, even if there’s skew between threads or other sources of inaccuracy.  Ties could be broken by thread ID, or again by having both sides abort.</div><br/><div id="37711961" class="c"><input type="checkbox" id="c-37711961" checked=""/><div class="controls bullet"><span class="by">djbusby</span><span>|</span><a href="#37711863">parent</a><span>|</span><a href="#37712836">next</a><span>|</span><label class="collapse" for="c-37711961">[-]</label><label class="expand" for="c-37711961">[6 more]</label></div><br/><div class="children"><div class="content">I would use a ULID rather than thread ID.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ulid&#x2F;spec">https:&#x2F;&#x2F;github.com&#x2F;ulid&#x2F;spec</a><p>They (and others) are great for this kind of case - and many others.</div><br/><div id="37711980" class="c"><input type="checkbox" id="c-37711980" checked=""/><div class="controls bullet"><span class="by">codetrotter</span><span>|</span><a href="#37711863">root</a><span>|</span><a href="#37711961">parent</a><span>|</span><a href="#37712836">next</a><span>|</span><label class="collapse" for="c-37711980">[-]</label><label class="expand" for="c-37711980">[5 more]</label></div><br/><div class="children"><div class="content">ulid is great, I use it a lot.<p>There is also a draft to make a new uuid variant – uuid v7 – that will be very similar to how ulid works.<p><a href="https:&#x2F;&#x2F;www.ietf.org&#x2F;archive&#x2F;id&#x2F;draft-peabody-dispatch-new-uuid-format-01.html#name-uuidv7-layout-and-bit-order" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.ietf.org&#x2F;archive&#x2F;id&#x2F;draft-peabody-dispatch-new-u...</a></div><br/><div id="37712135" class="c"><input type="checkbox" id="c-37712135" checked=""/><div class="controls bullet"><span class="by">techdragon</span><span>|</span><a href="#37711863">root</a><span>|</span><a href="#37711980">parent</a><span>|</span><a href="#37712836">next</a><span>|</span><label class="collapse" for="c-37712135">[-]</label><label class="expand" for="c-37712135">[4 more]</label></div><br/><div class="children"><div class="content">I use ULID  a lot too and It’s frustrating how close the new spec UUIDs are to it without actually being the same… so I’ve got a bunch of code to modify once Postgres supports generation of the new UUIDs server side without extensions or stored procedures. Relatively painless work, but frustrating since it could have been avoided.</div><br/><div id="37713219" class="c"><input type="checkbox" id="c-37713219" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#37711863">root</a><span>|</span><a href="#37712135">parent</a><span>|</span><a href="#37712157">next</a><span>|</span><label class="collapse" for="c-37713219">[-]</label><label class="expand" for="c-37713219">[2 more]</label></div><br/><div class="children"><div class="content">&gt; frustrating since it could have been avoided.<p>How? UUID is a structured format so the only options I can see is ulid creating their own unregistered uuid variant (probably a terrible idea) or adding ulid support to postgres (nothing to do with uuid).</div><br/><div id="37713314" class="c"><input type="checkbox" id="c-37713314" checked=""/><div class="controls bullet"><span class="by">techdragon</span><span>|</span><a href="#37711863">root</a><span>|</span><a href="#37713219">parent</a><span>|</span><a href="#37712157">next</a><span>|</span><label class="collapse" for="c-37713314">[-]</label><label class="expand" for="c-37713314">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d love for Postgres to adopt ULID as a first class variant of the same basic 128bit wide binary optimized column type they use for UUIDs, but I don&#x27;t expect they will, while its &quot;popular&quot; its not likely popular enough to have support for them to maintain it in the long run... Also the smart money ahead of time would  have been for the ULID spec to sacrifice a few data bits to leave the version specifying sections of the bit field layout unused in the ULID binary spec (<a href="https:&#x2F;&#x2F;github.com&#x2F;ulid&#x2F;spec#binary-layout-and-byte-order">https:&#x2F;&#x2F;github.com&#x2F;ulid&#x2F;spec#binary-layout-and-byte-order</a>) for the sake of future compatibility with &quot;proper&quot; UUIDs... Performing one quick bitfield modification on every row in PostgreSQL would have been less painful as in set bit, vs load parse, repack in order to re-computing the appropriate UUIDv7s (or UUIDv8s for some reason) since the primary key update transaction should be roughly the same speed either way.</div><br/></div></div></div></div><div id="37712157" class="c"><input type="checkbox" id="c-37712157" checked=""/><div class="controls bullet"><span class="by">djbusby</span><span>|</span><a href="#37711863">root</a><span>|</span><a href="#37712135">parent</a><span>|</span><a href="#37713219">prev</a><span>|</span><a href="#37712836">next</a><span>|</span><label class="collapse" for="c-37712157">[-]</label><label class="expand" for="c-37712157">[1 more]</label></div><br/><div class="children"><div class="content">Yes. V7 looks good but ULID already does it. Rather than change code, I&#x27;m just staying with ULID. All give us 128 bits. That should be enough for anyone ;&#x2F;</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37712836" class="c"><input type="checkbox" id="c-37712836" checked=""/><div class="controls bullet"><span class="by">telez</span><span>|</span><a href="#37711863">prev</a><span>|</span><a href="#37713227">next</a><span>|</span><label class="collapse" for="c-37712836">[-]</label><label class="expand" for="c-37712836">[4 more]</label></div><br/><div class="children"><div class="content">I do not quite understand the last figure for the relaxed avl tree. For the 100 % lookup (rightmost) the TL2 algo should scale linearly with the number of threads. For read-only transactions, TL2 needs to sample the global version, then for all reads make sure the local version is less than or equal to the sampled version. given this, it is difficult to understand why the graph is sub linear and that TL2 is not as fast as the other STM implementations.</div><br/><div id="37712976" class="c"><input type="checkbox" id="c-37712976" checked=""/><div class="controls bullet"><span class="by">colanderman</span><span>|</span><a href="#37712836">parent</a><span>|</span><a href="#37713227">next</a><span>|</span><label class="collapse" for="c-37712976">[-]</label><label class="expand" for="c-37712976">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see such a graph for TL2? I do see one for TLRW though which does use reader locks, hence the scalability cap.</div><br/><div id="37713120" class="c"><input type="checkbox" id="c-37713120" checked=""/><div class="controls bullet"><span class="by">telez</span><span>|</span><a href="#37712836">root</a><span>|</span><a href="#37712976">parent</a><span>|</span><a href="#37713227">next</a><span>|</span><label class="collapse" for="c-37713120">[-]</label><label class="expand" for="c-37713120">[2 more]</label></div><br/><div class="children"><div class="content">the chart doesn&#x27;t seem visible on ios safari but i can see it on firefox desktop however, the figure seems to be the same as from the linked paper: <a href="https:&#x2F;&#x2F;zenodo.org&#x2F;record&#x2F;7886718" rel="nofollow noreferrer">https:&#x2F;&#x2F;zenodo.org&#x2F;record&#x2F;7886718</a></div><br/><div id="37713400" class="c"><input type="checkbox" id="c-37713400" checked=""/><div class="controls bullet"><span class="by">colanderman</span><span>|</span><a href="#37712836">root</a><span>|</span><a href="#37713120">parent</a><span>|</span><a href="#37713227">next</a><span>|</span><label class="collapse" for="c-37713400">[-]</label><label class="expand" for="c-37713400">[1 more]</label></div><br/><div class="children"><div class="content">Ah ok I found it there, I see what you mean now. My only guess would be cache effects? With that large AVL tree (1 M entries, so likely dozens of MiB), you are escaping L2 cache and hitting shared L3 or main memory for a large portion of lookups, and are bandwidth-constrained at the die level, thus adding that knee (which I think is visible with some of the other algorithms as well).</div><br/></div></div></div></div></div></div></div></div><div id="37713227" class="c"><input type="checkbox" id="c-37713227" checked=""/><div class="controls bullet"><span class="by">gigatexal</span><span>|</span><a href="#37712836">prev</a><span>|</span><a href="#37712281">next</a><span>|</span><label class="collapse" for="c-37713227">[-]</label><label class="expand" for="c-37713227">[1 more]</label></div><br/><div class="children"><div class="content">2PLSF paper the author claims is what 2PL should have been. <a href="https:&#x2F;&#x2F;zenodo.org&#x2F;record&#x2F;7886718" rel="nofollow noreferrer">https:&#x2F;&#x2F;zenodo.org&#x2F;record&#x2F;7886718</a></div><br/></div></div><div id="37712281" class="c"><input type="checkbox" id="c-37712281" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#37713227">prev</a><span>|</span><a href="#37712011">next</a><span>|</span><label class="collapse" for="c-37712281">[-]</label><label class="expand" for="c-37712281">[1 more]</label></div><br/><div class="children"><div class="content">Interesting re the transaction ID generation. Sled generates ~70-120 million transaction IDs per second. The author points out that it’s still a scaling bottleneck but I wonder if Sled’s approach might raise the TPS for the contended case.</div><br/></div></div><div id="37712011" class="c"><input type="checkbox" id="c-37712011" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#37712281">prev</a><span>|</span><a href="#37712213">next</a><span>|</span><label class="collapse" for="c-37712011">[-]</label><label class="expand" for="c-37712011">[3 more]</label></div><br/><div class="children"><div class="content">One thing I didn’t quite catch was: I thought most write transactions needs <i>consistent reads</i> on many (contended) “objects”, but the actual writes are often just one or two objects. Is 2PL addressing this or does a write transaction take <i>write locks</i> on all objects?</div><br/><div id="37712169" class="c"><input type="checkbox" id="c-37712169" checked=""/><div class="controls bullet"><span class="by">rawgabbit</span><span>|</span><a href="#37712011">parent</a><span>|</span><a href="#37712213">next</a><span>|</span><label class="collapse" for="c-37712169">[-]</label><label class="expand" for="c-37712169">[2 more]</label></div><br/><div class="children"><div class="content">You can take locks on all objects before you write. Most systems don’t do that.<p>Usually there are multiple writes to complete a business process. In each step stale data is read to create a write request similar to how you place your order with the wait staff at the restaurant. The wait staff will orchestrate your request. First the chef prepares your meal according to the order ticket. Second the wait staff delivers your meal based on the chef’s internal work order. Lastly they take your payment based on the original  order ticket. Notice there are at least three microtransactions based on stale data. No one is holding locks until the diner finishes eating.</div><br/><div id="37712783" class="c"><input type="checkbox" id="c-37712783" checked=""/><div class="controls bullet"><span class="by">zaphirplane</span><span>|</span><a href="#37712011">root</a><span>|</span><a href="#37712169">parent</a><span>|</span><a href="#37712213">next</a><span>|</span><label class="collapse" for="c-37712783">[-]</label><label class="expand" for="c-37712783">[1 more]</label></div><br/><div class="children"><div class="content">IIUC, That’s a micro service way, missing cancellations and rollback and timeouts<p>What happens if the chef can’t fulfill the meal, the customer leaves cause the order is taking long … etc 
Most real life will not charge the customer is the chef can’t make the meal and cancel the cooking if the customer leaves<p>The analogy maybe going far ;)</div><br/></div></div></div></div></div></div><div id="37712213" class="c"><input type="checkbox" id="c-37712213" checked=""/><div class="controls bullet"><span class="by">johnthescott</span><span>|</span><a href="#37712011">prev</a><span>|</span><a href="#37712306">next</a><span>|</span><label class="collapse" for="c-37712213">[-]</label><label class="expand" for="c-37712213">[1 more]</label></div><br/><div class="children"><div class="content">huh?  no mention of serializable snapshot isolation (SSI), used by most commercial dbs for years.  what gives?</div><br/></div></div><div id="37712306" class="c"><input type="checkbox" id="c-37712306" checked=""/><div class="controls bullet"><span class="by">indus</span><span>|</span><a href="#37712213">prev</a><span>|</span><a href="#37710949">next</a><span>|</span><label class="collapse" for="c-37712306">[-]</label><label class="expand" for="c-37712306">[2 more]</label></div><br/><div class="children"><div class="content">Isn’t 2PL a limited applicability construct?<p>All my incoming and outgoing “transactions” are over loosely-coupled API calls.<p>Is there a point I’m missing?</div><br/><div id="37712373" class="c"><input type="checkbox" id="c-37712373" checked=""/><div class="controls bullet"><span class="by">grivant</span><span>|</span><a href="#37712306">parent</a><span>|</span><a href="#37710949">next</a><span>|</span><label class="collapse" for="c-37712373">[-]</label><label class="expand" for="c-37712373">[1 more]</label></div><br/><div class="children"><div class="content">IMO it’s about what’s happening underneath those API calls. You might be doing lots of POST requests that touch the same underlying sql table.</div><br/></div></div></div></div><div id="37710949" class="c"><input type="checkbox" id="c-37710949" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#37712306">prev</a><span>|</span><a href="#37710842">next</a><span>|</span><label class="collapse" for="c-37710949">[-]</label><label class="expand" for="c-37710949">[3 more]</label></div><br/><div class="children"><div class="content">MVCC is what most databases do.</div><br/><div id="37711659" class="c"><input type="checkbox" id="c-37711659" checked=""/><div class="controls bullet"><span class="by">vore</span><span>|</span><a href="#37710949">parent</a><span>|</span><a href="#37711829">next</a><span>|</span><label class="collapse" for="c-37711659">[-]</label><label class="expand" for="c-37711659">[1 more]</label></div><br/><div class="children"><div class="content">MVCC is optimistic concurrency control – you may end up having to retry your write transaction multiple times, which might suck if the transaction is expensive. Pessimistic concurrency control like locking may be cheaper in those cases, since the cost of locking may be drastically lower. Having one doesn&#x27;t preclude the other!</div><br/></div></div><div id="37711829" class="c"><input type="checkbox" id="c-37711829" checked=""/><div class="controls bullet"><span class="by">endisneigh</span><span>|</span><a href="#37710949">parent</a><span>|</span><a href="#37711659">prev</a><span>|</span><a href="#37710842">next</a><span>|</span><label class="collapse" for="c-37711829">[-]</label><label class="expand" for="c-37711829">[1 more]</label></div><br/><div class="children"><div class="content">has its own tradeoffs tho</div><br/></div></div></div></div><div id="37710842" class="c"><input type="checkbox" id="c-37710842" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#37710949">prev</a><span>|</span><a href="#37710955">next</a><span>|</span><label class="collapse" for="c-37710842">[-]</label><label class="expand" for="c-37710842">[10 more]</label></div><br/><div class="children"><div class="content">this is a great paper that provides a framework for comparing 2 phase and paxos.<p><a href="https:&#x2F;&#x2F;lamport.azurewebsites.net&#x2F;video&#x2F;consensus-on-transaction-commit.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;lamport.azurewebsites.net&#x2F;video&#x2F;consensus-on-transac...</a></div><br/><div id="37710973" class="c"><input type="checkbox" id="c-37710973" checked=""/><div class="controls bullet"><span class="by">thoughtlede</span><span>|</span><a href="#37710842">parent</a><span>|</span><a href="#37710955">next</a><span>|</span><label class="collapse" for="c-37710973">[-]</label><label class="expand" for="c-37710973">[9 more]</label></div><br/><div class="children"><div class="content">Two-phase locking is different from two-phase commit, in spite of an overlap in their naming. Two-phase commit is relevant to be compared against Paxos - both of which fall under the category of consensus protocols.<p>Two-phase locking is a concurrency control mechanism.</div><br/><div id="37711118" class="c"><input type="checkbox" id="c-37711118" checked=""/><div class="controls bullet"><span class="by">roncesvalles</span><span>|</span><a href="#37710842">root</a><span>|</span><a href="#37710973">parent</a><span>|</span><a href="#37710955">next</a><span>|</span><label class="collapse" for="c-37711118">[-]</label><label class="expand" for="c-37711118">[8 more]</label></div><br/><div class="children"><div class="content">A little summary:<p>2PC: An algorithm used in the context of distributed transactions where each machine handles a <i>different</i> part of the transaction. This means that nothing is redundant - the success of each and every participant is required for the transaction to be committed.<p>Paxos&#x2F;Raft&#x2F;consensus: An algorithm usually used in the context of distributed replication. Since every participant is doing the <i>same</i> thing, it&#x27;s tolerable if a few fail or give outputs that diverge from the majority.<p>2PL: A method of acquiring multiple locks such that first you acquire all the required locks (first phase), then you do what you need to do, and then you release all the locks (second phase). This is in contrast to a locking scheme where lock acquisitions and releases are interspersed. This isn&#x27;t strictly limited to distributed systems, although it&#x27;s common to see 2PC with 2PL.<p>If this piques your interest, read the Spanner paper! Spanner uses all three - 2PC with 2PL for distributed read-write transactions, and Paxos for replication.<p>PS: &quot;Distributed&quot; just means there&#x27;s more than one machine involved, any of which may fail independently, and communication among these machines happens over unreliable wire.</div><br/><div id="37711459" class="c"><input type="checkbox" id="c-37711459" checked=""/><div class="controls bullet"><span class="by">thoughtlede</span><span>|</span><a href="#37710842">root</a><span>|</span><a href="#37711118">parent</a><span>|</span><a href="#37712506">next</a><span>|</span><label class="collapse" for="c-37711459">[-]</label><label class="expand" for="c-37711459">[5 more]</label></div><br/><div class="children"><div class="content">In a multi-replica system, where, say, we cannot tolerate any failures or lags, is 2PC used in practice to achieve consensus? Or are there other methods for achieving such strict consensus?</div><br/><div id="37712425" class="c"><input type="checkbox" id="c-37712425" checked=""/><div class="controls bullet"><span class="by">mjb</span><span>|</span><a href="#37710842">root</a><span>|</span><a href="#37711459">parent</a><span>|</span><a href="#37711778">next</a><span>|</span><label class="collapse" for="c-37712425">[-]</label><label class="expand" for="c-37712425">[1 more]</label></div><br/><div class="children"><div class="content">2PC (or atomic commitment more generally) is needed for sharded&#x2F;partitioned systems with different data on each node. In these systems, each node gets a vote on whether a transaction should be allowed to commit. Replication, making multiple copies of the same data, doesn&#x27;t need 2PC. Instead, algorithms like Paxos, Raft, or chain replication are used.</div><br/></div></div><div id="37711778" class="c"><input type="checkbox" id="c-37711778" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#37710842">root</a><span>|</span><a href="#37711459">parent</a><span>|</span><a href="#37712425">prev</a><span>|</span><a href="#37712506">next</a><span>|</span><label class="collapse" for="c-37711778">[-]</label><label class="expand" for="c-37711778">[3 more]</label></div><br/><div class="children"><div class="content">There are other means, the most common being Calvin like protocols where every replica deterministically processes some log, and so only one round of distributed calls is necessary.</div><br/><div id="37711885" class="c"><input type="checkbox" id="c-37711885" checked=""/><div class="controls bullet"><span class="by">reubenbond</span><span>|</span><a href="#37710842">root</a><span>|</span><a href="#37711778">parent</a><span>|</span><a href="#37712506">next</a><span>|</span><label class="collapse" for="c-37711885">[-]</label><label class="expand" for="c-37711885">[2 more]</label></div><br/><div class="children"><div class="content">Which systems use Calvin-like protocols?</div><br/><div id="37713162" class="c"><input type="checkbox" id="c-37713162" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#37710842">root</a><span>|</span><a href="#37711885">parent</a><span>|</span><a href="#37712506">next</a><span>|</span><label class="collapse" for="c-37713162">[-]</label><label class="expand" for="c-37713162">[1 more]</label></div><br/><div class="children"><div class="content">FaunaDB is the most popular, I believe.</div><br/></div></div></div></div></div></div></div></div><div id="37712506" class="c"><input type="checkbox" id="c-37712506" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#37710842">root</a><span>|</span><a href="#37711118">parent</a><span>|</span><a href="#37711459">prev</a><span>|</span><a href="#37711906">next</a><span>|</span><label class="collapse" for="c-37712506">[-]</label><label class="expand" for="c-37712506">[1 more]</label></div><br/><div class="children"><div class="content">Concurrency control &gt; 
Concurrency control in databases &gt; Why is concurrency control needed?: 
<a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Concurrency_control#Why_is_concurrency_control_needed" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Concurrency_control#Why_is_c...</a>?<p>Locks (computer science) &gt; Disadvantages: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Lock_(computer_science)#Disadvantages" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Lock_(computer_science)#Disadv...</a><p>Two-phase locking (2PL) <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Two-phase_locking" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Two-phase_locking</a><p>Two-phase commit protocol (2PC)
<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Two-phase_commit_protocol" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Two-phase_commit_protocol</a><p>Paxos: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Paxos_(computer_science)" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Paxos_(computer_science)</a><p>Raft: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Raft_(algorithm)" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Raft_(algorithm)</a><p>Consensus (computer science) <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Consensus_(computer_science)" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Consensus_(computer_science)</a><p>Spanner: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Spanner_(database)" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Spanner_(database)</a><p>Non-blocking algorithm; &quot;lock-free concurrency&quot;, &quot;wait-free&quot; 
<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Non-blocking_algorithm" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Non-blocking_algorithm</a><p>&quot;Ask HN: Why don&#x27;t PCs have better entropy sources?&quot; [for generating txids&#x2F;uuids] 
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30877296">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30877296</a><p>&quot;100-Gbit&#x2F;s Integrated Quantum Random Number Generator Based on Vacuum Fluctuations&quot; <a href="https:&#x2F;&#x2F;link.aps.org&#x2F;doi&#x2F;10.1103&#x2F;PRXQuantum.4.010330" rel="nofollow noreferrer">https:&#x2F;&#x2F;link.aps.org&#x2F;doi&#x2F;10.1103&#x2F;PRXQuantum.4.010330</a><p>Re: tests of randomness: <a href="https:&#x2F;&#x2F;mail.python.org&#x2F;archives&#x2F;list&#x2F;python-ideas@python.org&#x2F;message&#x2F;T3CM5FIVVUZRDP7RQ2QRNQTPWUR4WAR7&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;mail.python.org&#x2F;archives&#x2F;list&#x2F;python-ideas@python.or...</a><p>TIL there&#x27;s a regular heartbeat in the quantum foam; there&#x27;s a regular monotonic heartbeat in the quantum Rydberg wave packet interference; and that should be useful for distributed applications with and without vector clocks and an initial time synchronization service (WhiteRabbit &gt; PTP &gt; NTP Network Time Protocol)
<a href="https:&#x2F;&#x2F;journals.aps.org&#x2F;prresearch&#x2F;abstract&#x2F;10.1103&#x2F;PhysRevResearch.4.043041" rel="nofollow noreferrer">https:&#x2F;&#x2F;journals.aps.org&#x2F;prresearch&#x2F;abstract&#x2F;10.1103&#x2F;PhysRev...</a> :<p>&gt; <i>The [quantum time-keeping application of this research] relies on the unique fingerprint that is created by the time-dependent photoionization of these complex wave packets. These fingerprints determine how much time has passed since the wave packet was formed and provide an assurance that the measured time is correct. Unlike any other clock, this quantum watch does not utilize a counter and is fully quantum mechanical in its nature. The quantum watch has the potential to become an invaluable tool in pump-probe spectroscopy due to its simplicity, assurance of accuracy, and ability to provide an absolute timestamp, i.e., there is no need to find time zero.</i><p>IIUC a Rydberg antenna can read and&#x2F;or write such noise?<p>&quot;Patterns of Distributed Systems (2022)&quot; <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36504073">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36504073</a></div><br/></div></div><div id="37711906" class="c"><input type="checkbox" id="c-37711906" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#37710842">root</a><span>|</span><a href="#37711118">parent</a><span>|</span><a href="#37712506">prev</a><span>|</span><a href="#37710955">next</a><span>|</span><label class="collapse" for="c-37711906">[-]</label><label class="expand" for="c-37711906">[1 more]</label></div><br/><div class="children"><div class="content">I find it interesting that “distributed” and “concurrent” end up falling under the mathematical concept of nondeterminism with respect to correctness. Of course a practically efficient implementation has additional concerns.</div><br/></div></div></div></div></div></div></div></div><div id="37710955" class="c"><input type="checkbox" id="c-37710955" checked=""/><div class="controls bullet"><span class="by">onedognight</span><span>|</span><a href="#37710842">prev</a><span>|</span><a href="#37709092">next</a><span>|</span><label class="collapse" for="c-37710955">[-]</label><label class="expand" for="c-37710955">[5 more]</label></div><br/><div class="children"><div class="content">2500 years later and the best hypotenuse algorithm is still Pythagoras’.</div><br/><div id="37711561" class="c"><input type="checkbox" id="c-37711561" checked=""/><div class="controls bullet"><span class="by">goalieca</span><span>|</span><a href="#37710955">parent</a><span>|</span><a href="#37711917">next</a><span>|</span><label class="collapse" for="c-37711561">[-]</label><label class="expand" for="c-37711561">[2 more]</label></div><br/><div class="children"><div class="content">You jest but this is a computationally slow algorithm that only works for right angle triangles in a Cartesian space. There’s very reasonable and fast trigonometric approximations. The general form would be the cosine law which applies to any triangle. We can derive this from more abstract metrics over an inner product space.. a sort of vector space of any dimension.</div><br/><div id="37711649" class="c"><input type="checkbox" id="c-37711649" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#37710955">root</a><span>|</span><a href="#37711561">parent</a><span>|</span><a href="#37711917">next</a><span>|</span><label class="collapse" for="c-37711649">[-]</label><label class="expand" for="c-37711649">[1 more]</label></div><br/><div class="children"><div class="content">First thing I thought of is <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fast_inverse_square_root" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fast_inverse_square_root</a></div><br/></div></div></div></div><div id="37711917" class="c"><input type="checkbox" id="c-37711917" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#37710955">parent</a><span>|</span><a href="#37711561">prev</a><span>|</span><a href="#37711732">next</a><span>|</span><label class="collapse" for="c-37711917">[-]</label><label class="expand" for="c-37711917">[1 more]</label></div><br/><div class="children"><div class="content">Funny you should say that. Here[1] is an interesting improvement. More interestingly he shows his work.<p>[1] <a href="https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;~EWD&#x2F;transcriptions&#x2F;EWD09xx&#x2F;EWD975.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;~EWD&#x2F;transcriptions&#x2F;EWD09xx&#x2F;EWD975...</a></div><br/></div></div></div></div><div id="37712404" class="c"><input type="checkbox" id="c-37712404" checked=""/><div class="controls bullet"><span class="by">djha-skin</span><span>|</span><a href="#37709092">prev</a><span>|</span><label class="collapse" for="c-37712404">[-]</label><label class="expand" for="c-37712404">[4 more]</label></div><br/><div class="children"><div class="content">We are so arrogant sometimes. <i>The passage of time has nothing to do with reality.</i> People seem to think that given enough time and energy and ingenuity we can do anything we want. This is not how the real world works.<p>Sometimes, we find a good solution, and it&#x27;s the best possible one and we found it early on. We think we can do better, but we can&#x27;t. A classic example of this is Euclid&#x27;s fifth axiom. It wasn&#x27;t proven until the 19th century that this axiom was necessary but everyone from Euclid to Gauss tried to get rid of it. Foolish.</div><br/><div id="37712434" class="c"><input type="checkbox" id="c-37712434" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#37712404">parent</a><span>|</span><a href="#37713548">next</a><span>|</span><label class="collapse" for="c-37712434">[-]</label><label class="expand" for="c-37712434">[2 more]</label></div><br/><div class="children"><div class="content">It seems to me that while it&#x27;s foolish to <i>assume</i> we can always improve on something, it&#x27;s not at all foolish to try to do better (even if the attempts don&#x27;t succeed). Asking &quot;can we do better than this?&quot; and trying to find a better way is a prerequisite for progress, after all.</div><br/><div id="37713570" class="c"><input type="checkbox" id="c-37713570" checked=""/><div class="controls bullet"><span class="by">patrulek</span><span>|</span><a href="#37712404">root</a><span>|</span><a href="#37712434">parent</a><span>|</span><a href="#37713548">next</a><span>|</span><label class="collapse" for="c-37713570">[-]</label><label class="expand" for="c-37713570">[1 more]</label></div><br/><div class="children"><div class="content">And trying to improve something will often result in improving ourselves (by learning).</div><br/></div></div></div></div><div id="37713548" class="c"><input type="checkbox" id="c-37713548" checked=""/><div class="controls bullet"><span class="by">stevenhuang</span><span>|</span><a href="#37712404">parent</a><span>|</span><a href="#37712434">prev</a><span>|</span><label class="collapse" for="c-37713548">[-]</label><label class="expand" for="c-37713548">[1 more]</label></div><br/><div class="children"><div class="content">An excellent illustration of how a lack of diversity in thinking can hinder forward progress. Thank God everyone doesn&#x27;t think the same as you.<p>I think it&#x27;s a testament to the human condition there are those of us willing to entertain the folly of pushing the boundaries, or of being foolish as you put it.</div><br/></div></div></div></div></div></div></div></div></div></body></html>