<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1694595675911" as="style"/><link rel="stylesheet" href="styles.css?v=1694595675911"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://bricolage.io/some-notes-on-local-first-development/">Some notes on local-first development</a> <span class="domain">(<a href="https://bricolage.io">bricolage.io</a>)</span></div><div class="subtext"><span>calcsam</span> | <span>51 comments</span></div><br/><div><div id="37493941" class="c"><input type="checkbox" id="c-37493941" checked=""/><div class="controls bullet"><span class="by">thecodrr</span><span>|</span><a href="#37491263">next</a><span>|</span><label class="collapse" for="c-37493941">[-]</label><label class="expand" for="c-37493941">[1 more]</label></div><br/><div class="children"><div class="content">As someone who has been doing local-first for the last 3 years with Notesnook, let me tell you: it&#x27;s not all gardens and roses. Local first has its own very unique set of problems:<p>1. What to do with stale user data? What happens if a user doesn&#x27;t open the app for a year? How do you handle migrations?<p>2. What about data corruption? What happens if the user has a network interruption during a sync? How do you handle partial states?<p>3. What happens when you have merge conflicts during a sync? CRDT structures are not even close to enough for this.<p>4. What happens when the user has millions of items? How do you handle sync and storage for that? How do you handle backups? How do you handle exports?<p>One would imagine that having all your data locally would make things fast and easy, but oh boy! Not everyone has a high end machine. Mobiles are really bad with memory. iOS and Android have insane level of restrictions on how much memory an app can consume, and for good reason because most consumer mobile phones have 4-6 gbs of RAM.<p>All these problems do not exist in a non-local-first situation (but other problems do). Things are actually simpler in a server-first environment because all the heavy lifting is done by you instead of the user.</div><br/></div></div><div id="37491263" class="c"><input type="checkbox" id="c-37491263" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#37493941">prev</a><span>|</span><a href="#37492041">next</a><span>|</span><label class="collapse" for="c-37491263">[-]</label><label class="expand" for="c-37491263">[4 more]</label></div><br/><div class="children"><div class="content">I was exploring an interesting local-first component earlier today: cr-sqlite, which adds CRDTs to SQLite so you can have multiple databases that receive writes and then sync up and merge their changes later on.<p>My notes here: <a href="https:&#x2F;&#x2F;til.simonwillison.net&#x2F;sqlite&#x2F;cr-sqlite-macos" rel="nofollow noreferrer">https:&#x2F;&#x2F;til.simonwillison.net&#x2F;sqlite&#x2F;cr-sqlite-macos</a></div><br/><div id="37491925" class="c"><input type="checkbox" id="c-37491925" checked=""/><div class="controls bullet"><span class="by">obeavs</span><span>|</span><a href="#37491263">parent</a><span>|</span><a href="#37492202">next</a><span>|</span><label class="collapse" for="c-37491925">[-]</label><label class="expand" for="c-37491925">[1 more]</label></div><br/><div class="children"><div class="content">Think you&#x27;d really enjoy exploring Electric SQL (<a href="https:&#x2F;&#x2F;electric-sql.com&#x2F;blog&#x2F;2023&#x2F;08&#x2F;14&#x2F;introducing-electricsql-v0.5" rel="nofollow noreferrer">https:&#x2F;&#x2F;electric-sql.com&#x2F;blog&#x2F;2023&#x2F;08&#x2F;14&#x2F;introducing-electri...</a>).<p>They&#x27;re syncing client-side SQLite to server-side Postgres on backend via an Erlang service that enables bi-directional active-active replication. They have a little more work to go until they solve the RLS concerns, but its been an incredible project to follow.</div><br/></div></div><div id="37492202" class="c"><input type="checkbox" id="c-37492202" checked=""/><div class="controls bullet"><span class="by">rapnie</span><span>|</span><a href="#37491263">parent</a><span>|</span><a href="#37491925">prev</a><span>|</span><a href="#37491596">next</a><span>|</span><label class="collapse" for="c-37492202">[-]</label><label class="expand" for="c-37492202">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s another local-first collaborative component: SQLSync [0].<p><i>&quot;SQLSync is a collaborative offline-first wrapper around SQLite. It is designed to synchronize web application state between users, devices, and the edge.&quot;</i><p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;orbitinghail&#x2F;sqlsync">https:&#x2F;&#x2F;github.com&#x2F;orbitinghail&#x2F;sqlsync</a></div><br/></div></div><div id="37491596" class="c"><input type="checkbox" id="c-37491596" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#37491263">parent</a><span>|</span><a href="#37492202">prev</a><span>|</span><a href="#37492041">next</a><span>|</span><label class="collapse" for="c-37491596">[-]</label><label class="expand" for="c-37491596">[1 more]</label></div><br/><div class="children"><div class="content">Oh that is very interesting. Thanks for writing it up for all to learn off! The internet is made better because you put in the effort!</div><br/></div></div></div></div><div id="37492041" class="c"><input type="checkbox" id="c-37492041" checked=""/><div class="controls bullet"><span class="by">nixpulvis</span><span>|</span><a href="#37491263">prev</a><span>|</span><a href="#37493695">next</a><span>|</span><label class="collapse" for="c-37492041">[-]</label><label class="expand" for="c-37492041">[10 more]</label></div><br/><div class="children"><div class="content">What even is “local-first”.<p>I’m a big proponent of being able to run the code locally, but this seems to be more along the lines of, first update some local DB, then sync it.<p>I see nothing fundamentally different here than using a well designed API for ‘sync’, and none of it does anything to revive the web browsing experience. Gone are the days where “page load” meant that you could safely begin reading without interruption. This whole “web application” thing was a foobar’d mess. Yes, we probably want some level of interactivity, but I fail to see how casting the web application problem as a database sync issue addresses the fundamental issues.<p>That being said, I can see the appeal. It’s a clean interface to work with and it allows for new frameworks to displace existing problematic frameworks.<p>I just worry that in 5 years we’ll all be complaining about poorly designed schema and overloaded table updates again. The solution? Microservices with their own smaller tables which batch updates to the larger system of course!</div><br/><div id="37492077" class="c"><input type="checkbox" id="c-37492077" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#37492041">parent</a><span>|</span><a href="#37492084">next</a><span>|</span><label class="collapse" for="c-37492077">[-]</label><label class="expand" for="c-37492077">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s local first because you write your data locally, first, then you sync it.<p>As opposed to writing it remotely first.<p>Also how many well designed APIs for sync really exist in the wild? I feel like you need a decent knowledge of distributed systems theory to even understand the problem space. &quot;Last write wins&quot; is a cop out and just means you are throwing away data semi-arbitrarily.</div><br/></div></div><div id="37492084" class="c"><input type="checkbox" id="c-37492084" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#37492041">parent</a><span>|</span><a href="#37492077">prev</a><span>|</span><a href="#37493695">next</a><span>|</span><label class="collapse" for="c-37492084">[-]</label><label class="expand" for="c-37492084">[7 more]</label></div><br/><div class="children"><div class="content">A local first tool, for me is one that works for most productive purposes without any network connection after the initial page load.<p>Having just returned from a multi-day hiking trip without a lot of network coverage I think people don&#x27;t realize the utility to such things.</div><br/><div id="37492619" class="c"><input type="checkbox" id="c-37492619" checked=""/><div class="controls bullet"><span class="by">SkyMarshal</span><span>|</span><a href="#37492041">root</a><span>|</span><a href="#37492084">parent</a><span>|</span><a href="#37492281">next</a><span>|</span><label class="collapse" for="c-37492619">[-]</label><label class="expand" for="c-37492619">[3 more]</label></div><br/><div class="children"><div class="content">Exactly.  A great working example is Obsidian.  Every version of it - desktop, android, iOS, writes locally first and then syncs to remote (if you’re subscribed to the Sync service, otherwise just writes locally).  Other than Sync (and some other optional services like Publish), it is 100% functional without network connectivity.</div><br/><div id="37492813" class="c"><input type="checkbox" id="c-37492813" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#37492041">root</a><span>|</span><a href="#37492619">parent</a><span>|</span><a href="#37492281">next</a><span>|</span><label class="collapse" for="c-37492813">[-]</label><label class="expand" for="c-37492813">[2 more]</label></div><br/><div class="children"><div class="content">Call me old fashioned, but why would anybody ever think doing it differently was a good idea?<p>Having it run locally and only sending requests when really needed is a way to make your app feel reliable and snappy. If every ailly button of your app sends out requests that means the snappiness of your whole UI will depend on the mercy of the network gods. Maybe it is the thrill of the gamble?</div><br/><div id="37493140" class="c"><input type="checkbox" id="c-37493140" checked=""/><div class="controls bullet"><span class="by">BHSPitMonkey</span><span>|</span><a href="#37492041">root</a><span>|</span><a href="#37492813">parent</a><span>|</span><a href="#37492281">next</a><span>|</span><label class="collapse" for="c-37493140">[-]</label><label class="expand" for="c-37493140">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Call me old fashioned, but why would anybody ever think doing it differently was a good idea?<p>Most would probably agree, but then you&#x27;re adding a layer of complexity on top of what could be a very simple client&#x2F;server application that satisfies 80% of your users. There is more &quot;cheap&quot; software out in the world than robust, complex software because most software doesn&#x27;t make it far from MVP.</div><br/></div></div></div></div></div></div><div id="37492281" class="c"><input type="checkbox" id="c-37492281" checked=""/><div class="controls bullet"><span class="by">nixpulvis</span><span>|</span><a href="#37492041">root</a><span>|</span><a href="#37492084">parent</a><span>|</span><a href="#37492619">prev</a><span>|</span><a href="#37493505">next</a><span>|</span><label class="collapse" for="c-37492281">[-]</label><label class="expand" for="c-37492281">[2 more]</label></div><br/><div class="children"><div class="content">I really like this way of thinking about it. I try to advocate for internetless development, so it meshes nicely with that.<p>It also helps me understand the scope of the frameworks. They need to maintain local state akin to saving files locally.<p>It’s just funny to me how we had this as the default mode of operation many years ago, then lost it because everything went to the cloud, and now we’re realizing that was kinda a mistake and we’re trying to fix it in the new environment.</div><br/><div id="37493265" class="c"><input type="checkbox" id="c-37493265" checked=""/><div class="controls bullet"><span class="by">erhaetherth</span><span>|</span><a href="#37492041">root</a><span>|</span><a href="#37492281">parent</a><span>|</span><a href="#37493505">next</a><span>|</span><label class="collapse" for="c-37493265">[-]</label><label class="expand" for="c-37493265">[1 more]</label></div><br/><div class="children"><div class="content">I think most of us knew this was a mistake instantly. Internet was even shoddier 10 years ago.</div><br/></div></div></div></div><div id="37493505" class="c"><input type="checkbox" id="c-37493505" checked=""/><div class="controls bullet"><span class="by">developer93</span><span>|</span><a href="#37492041">root</a><span>|</span><a href="#37492084">parent</a><span>|</span><a href="#37492281">prev</a><span>|</span><a href="#37493695">next</a><span>|</span><label class="collapse" for="c-37493505">[-]</label><label class="expand" for="c-37493505">[1 more]</label></div><br/><div class="children"><div class="content">Organicmaps &amp; co ftw</div><br/></div></div></div></div></div></div><div id="37493695" class="c"><input type="checkbox" id="c-37493695" checked=""/><div class="controls bullet"><span class="by">svilen_dobrev</span><span>|</span><a href="#37492041">prev</a><span>|</span><a href="#37492437">next</a><span>|</span><label class="collapse" for="c-37493695">[-]</label><label class="expand" for="c-37493695">[1 more]</label></div><br/><div class="children"><div class="content">About 12+ years ago, i &quot;invented&quot; similar RPC-over-couchDB architecture as there wasn&#x27;t much other distributed ways.<p>Worked wonders - each user reading&#x2F;posting requests&#x2F;responses in own &quot;channel&quot;, the channel being replicated to server and any of user&#x27;s devices, central server responding to requests and eventually cross-polinating the channels if need be.<p>Did a web client (pouchDB), android (touchDB), ios (forgot the name).. essentially each platform has its own implementation of the relatively simple protocol of Couchdb. So all one does is listen&#x2F;read&#x2F;write to a single local db.. and then db is doing all the communication, whenever possible. Simplified the clients sooooo much - reduced work and complexity like 50%.<p>Eh, the thing didn&#x27;t go anywhere as product but nevermind :&#x2F;<p>have fun</div><br/></div></div><div id="37492437" class="c"><input type="checkbox" id="c-37492437" checked=""/><div class="controls bullet"><span class="by">pmontra</span><span>|</span><a href="#37493695">prev</a><span>|</span><a href="#37492941">next</a><span>|</span><label class="collapse" for="c-37492437">[-]</label><label class="expand" for="c-37492437">[3 more]</label></div><br/><div class="children"><div class="content">The post writes about multiplayer, especially at the end. In games, but also in basically every other application, there is a state known to players (the cards in hand, the map around, etc) and a state that must be secret (the cards of the other players, the rest of the map, etc.) The server with the knowledge of all the state can be a client like the others but it has access to the real database. It can have the code to resolve interactions between players or that code runs locally to players too.<p>In complex turn based games there is a lot to do locally before sending the move to the server. Think about moving tens of units on a map. The problem here is of there are unknown parts of the map to explore. You need a connection to the server. However anything else will run faster because it doesn&#x27;t have to hit the network and a round trip to the database on the server.<p>The post writes about Figma being developed local first. You don&#x27;t have to hit the network while drawing, if you don&#x27;t have to collaborate with someone on a shared document. Then you send the state to the server and your private state becomes known to all the other coworkers.</div><br/><div id="37493108" class="c"><input type="checkbox" id="c-37493108" checked=""/><div class="controls bullet"><span class="by">phildenhoff</span><span>|</span><a href="#37492437">parent</a><span>|</span><a href="#37493533">next</a><span>|</span><label class="collapse" for="c-37493108">[-]</label><label class="expand" for="c-37493108">[1 more]</label></div><br/><div class="children"><div class="content">I think this article is focused on &quot;multiplayer&quot; in the contemporary non-game sense (which I still find weird).<p>However, I think an interesting thought experiment is a system that DOES share that secret state between players in a way where some facts are verifiable, but others are not. For example, when playing cards, I have the state of your hand in such a way that I can verify the card you played is valid, but cannot reasonably see (or find out) your hand.</div><br/></div></div><div id="37493533" class="c"><input type="checkbox" id="c-37493533" checked=""/><div class="controls bullet"><span class="by">bbor</span><span>|</span><a href="#37492437">parent</a><span>|</span><a href="#37493108">prev</a><span>|</span><a href="#37492941">next</a><span>|</span><label class="collapse" for="c-37493533">[-]</label><label class="expand" for="c-37493533">[1 more]</label></div><br/><div class="children"><div class="content">I just want to say that I spent a long time re-reading your comment to understand your criticism before I saw that you&#x27;re actually complimenting this idea, lol. I think that&#x27;s a great way to highlight the strength of this approach: adding access control to such an app is about as easy as adding it to a simple DB.</div><br/></div></div></div></div><div id="37492941" class="c"><input type="checkbox" id="c-37492941" checked=""/><div class="controls bullet"><span class="by">madspindel</span><span>|</span><a href="#37492437">prev</a><span>|</span><a href="#37493461">next</a><span>|</span><label class="collapse" for="c-37492941">[-]</label><label class="expand" for="c-37492941">[1 more]</label></div><br/><div class="children"><div class="content">This is about offline-first applications. I first thought it was about developing on localhost instead of in the cloud...</div><br/></div></div><div id="37493461" class="c"><input type="checkbox" id="c-37493461" checked=""/><div class="controls bullet"><span class="by">bfung</span><span>|</span><a href="#37492941">prev</a><span>|</span><a href="#37491651">next</a><span>|</span><label class="collapse" for="c-37493461">[-]</label><label class="expand" for="c-37493461">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s an older term for &quot;local-first&quot;, aka, <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rich_client" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rich_client</a><p>The thin&#x2F;thick client cycle starts again...</div><br/><div id="37493612" class="c"><input type="checkbox" id="c-37493612" checked=""/><div class="controls bullet"><span class="by">bbor</span><span>|</span><a href="#37493461">parent</a><span>|</span><a href="#37491651">next</a><span>|</span><label class="collapse" for="c-37493612">[-]</label><label class="expand" for="c-37493612">[1 more]</label></div><br/><div class="children"><div class="content">Hmm I just stumbled on this and am loving it so far, and your objection interests me: I&#x27;d be curious to hear what you see as the cycle? Lets say in WebDev only.<p>My best guess:<p><pre><code>  1990-2010: *thin* static sites w&#x2F; minimal JS (e.g. JQuery).

  2011-2019: *thick* SPAs

  2020-2023: *thin* Server Side Rendered SPAs

  2023-20??: *thick* Local-First apps
</code></pre>
Is that close to your thoughts?<p>If so, I don&#x27;t really see how this is promoting thicker apps. This whole approach assumes from the jump that you have complex state interactions on the client, and is just providing a wrapper around that to simplify syncing that state with the server. Couldn&#x27;t you write a very thin SSR app that uses this paradigm to offload as much business logic (e.g. update cascades) to the server as possible? I suppose it would lose the offline capabilities, but otherwise it seems like the same fundamental approach.<p>All of this is assuming we&#x27;re not going with what Hacker News <i>wishes</i> was true: that pure static sites are becoming the standard again ;)</div><br/></div></div></div></div><div id="37491651" class="c"><input type="checkbox" id="c-37491651" checked=""/><div class="controls bullet"><span class="by">sarchertech</span><span>|</span><a href="#37493461">prev</a><span>|</span><a href="#37493196">next</a><span>|</span><label class="collapse" for="c-37491651">[-]</label><label class="expand" for="c-37491651">[10 more]</label></div><br/><div class="children"><div class="content">There are use cases that can benefit from this, and I built a saas door access control system based around some of these ideas over 10 years ago.<p>However, the vast majority of apps don’t need this. Please don’t do anything like this for your boring enterprise CRUD app (60 fps CRUD? What even?).<p>I know many of you will, so I guess I’ll just console myself with the likelihood I’ll have a ton of consulting work in the next 5-10 years.</div><br/><div id="37492002" class="c"><input type="checkbox" id="c-37492002" checked=""/><div class="controls bullet"><span class="by">Qwertious</span><span>|</span><a href="#37491651">parent</a><span>|</span><a href="#37493196">next</a><span>|</span><label class="collapse" for="c-37492002">[-]</label><label class="expand" for="c-37492002">[9 more]</label></div><br/><div class="children"><div class="content">Counter-point: you don&#x27;t need local-first because you&#x27;re <i>privileged</i>. The crappier and less reliable your internet, the more valuable local-first is - and of the ~6 billion smartphone owners, most of them live somewhere with spotty connections.<p>For most people in the first world though, you&#x27;re probably right.</div><br/><div id="37492265" class="c"><input type="checkbox" id="c-37492265" checked=""/><div class="controls bullet"><span class="by">verisimilidude</span><span>|</span><a href="#37491651">root</a><span>|</span><a href="#37492002">parent</a><span>|</span><a href="#37492179">next</a><span>|</span><label class="collapse" for="c-37492265">[-]</label><label class="expand" for="c-37492265">[7 more]</label></div><br/><div class="children"><div class="content">Ah yes, let&#x27;s ask people on spotty connections to download a (likely) megabytes-large JavaScript bundle. What could go wrong?<p>Most of my users have old phones and bad connections. I&#x27;ve tried this JS-heavy bundle-first approach. It doesn&#x27;t work.<p>The solution is way simpler than local-first. Just shrink every page and interaction. Fewer requests, little JavaScript (if any at all), low latency. Use static pages when possible. Even the oldest phones on the most remote connections can usually deal with a sub-50kb page all-in. It feels like people forget how simple web interactions can be.<p>I&#x27;m sure local-first can be great for highly interactive tools like Figma. But the grandparent is right. Most sites don&#x27;t need anything close to that level of complexity.</div><br/><div id="37492414" class="c"><input type="checkbox" id="c-37492414" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#37491651">root</a><span>|</span><a href="#37492265">parent</a><span>|</span><a href="#37492350">next</a><span>|</span><label class="collapse" for="c-37492414">[-]</label><label class="expand" for="c-37492414">[3 more]</label></div><br/><div class="children"><div class="content">I feel like you&#x27;re conflating a few different things here.<p>Small pages and interactions are good, sure, but I don&#x27;t really see a tension between this and local first. My homepage is static HTML (minus google analytics) and it works offline.<p>The multi-mb JS bundle is also a red herring. The only multi-mb JS bundle I ever worked with did not work offline at all. Feel this is orthogonal.<p>Also connectivity for people is usually something that changes with time. You have it in the farmhouse, but not out in the field. You have it at the office, but not on the road. So downloading stuff when you have connectivity and still being able to read&#x2F;write what you don&#x27;t is the real aim of the game here.</div><br/><div id="37492513" class="c"><input type="checkbox" id="c-37492513" checked=""/><div class="controls bullet"><span class="by">verisimilidude</span><span>|</span><a href="#37491651">root</a><span>|</span><a href="#37492414">parent</a><span>|</span><a href="#37492350">next</a><span>|</span><label class="collapse" for="c-37492513">[-]</label><label class="expand" for="c-37492513">[2 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re using browser APIs to do lean local interactions, then good for you. Gold star. Fully approved. That&#x27;s not what I&#x27;ve been seeing recently from the people around me who are most excited about this stuff.<p>And you&#x27;re right about how connectivity changes over time. But how many people are on their bikes when applying for unemployment insurance? I just don&#x27;t think most business apps benefit from this level of offline support. There are of course use cases for this! But it&#x27;s not the common case.</div><br/><div id="37493138" class="c"><input type="checkbox" id="c-37493138" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#37491651">root</a><span>|</span><a href="#37492513">parent</a><span>|</span><a href="#37492350">next</a><span>|</span><label class="collapse" for="c-37493138">[-]</label><label class="expand" for="c-37493138">[1 more]</label></div><br/><div class="children"><div class="content">I think we&#x27;re in broad agreement.<p>And you&#x27;re right, if it&#x27;s OK to not be able to read or write during a network partition - then you don&#x27;t need this. But I would encourage everyone out there to figure it out first as bolting it on after the fact is a real challenge.</div><br/></div></div></div></div></div></div><div id="37492350" class="c"><input type="checkbox" id="c-37492350" checked=""/><div class="controls bullet"><span class="by">rapnie</span><span>|</span><a href="#37491651">root</a><span>|</span><a href="#37492265">parent</a><span>|</span><a href="#37492414">prev</a><span>|</span><a href="#37492179">next</a><span>|</span><label class="collapse" for="c-37492350">[-]</label><label class="expand" for="c-37492350">[3 more]</label></div><br/><div class="children"><div class="content">You are making an assumption on megabytes-large JS bundles. Also, how well do lean and mean pages load when you lose internet connection?</div><br/><div id="37492444" class="c"><input type="checkbox" id="c-37492444" checked=""/><div class="controls bullet"><span class="by">verisimilidude</span><span>|</span><a href="#37491651">root</a><span>|</span><a href="#37492350">parent</a><span>|</span><a href="#37492179">next</a><span>|</span><label class="collapse" for="c-37492444">[-]</label><label class="expand" for="c-37492444">[2 more]</label></div><br/><div class="children"><div class="content">Not much of an assumption. Many local-first solutions work from a big wad of JS. I&#x27;ve seen use of WASM to include things like SQLite. It&#x27;s not pretty.<p>My point is that if you&#x27;re in danger of losing your internet connection, you&#x27;re not going to be able to reliably get that initial JS bundle anyway.</div><br/><div id="37492494" class="c"><input type="checkbox" id="c-37492494" checked=""/><div class="controls bullet"><span class="by">rapnie</span><span>|</span><a href="#37491651">root</a><span>|</span><a href="#37492444">parent</a><span>|</span><a href="#37492179">next</a><span>|</span><label class="collapse" for="c-37492494">[-]</label><label class="expand" for="c-37492494">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but &quot;local-first&quot; and &quot;Big JS&quot; aren&#x27;t related. Sure you can build any monstrosity and make it local-first. And my local-first software can be a Tauri app, installed-once, or any kind of local software for that matter.</div><br/></div></div></div></div></div></div></div></div><div id="37492179" class="c"><input type="checkbox" id="c-37492179" checked=""/><div class="controls bullet"><span class="by">aaronbrethorst</span><span>|</span><a href="#37491651">root</a><span>|</span><a href="#37492002">parent</a><span>|</span><a href="#37492265">prev</a><span>|</span><a href="#37493196">next</a><span>|</span><label class="collapse" for="c-37492179">[-]</label><label class="expand" for="c-37492179">[1 more]</label></div><br/><div class="children"><div class="content">Counter-counter-point, they may well be better served by a lightweight UI that doesn’t require JS.</div><br/></div></div></div></div></div></div><div id="37493196" class="c"><input type="checkbox" id="c-37493196" checked=""/><div class="controls bullet"><span class="by">xg15</span><span>|</span><a href="#37491651">prev</a><span>|</span><a href="#37492412">next</a><span>|</span><label class="collapse" for="c-37493196">[-]</label><label class="expand" for="c-37493196">[3 more]</label></div><br/><div class="children"><div class="content">Hearing the name, I first thought this was about reducing complexity and removing unnecessary dependencies on cloud services. But it seems rather about adding yet another layer of complexity: You still have to track the state on the server, but now you want to <i>also</i> track it on the client.</div><br/><div id="37493743" class="c"><input type="checkbox" id="c-37493743" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#37493196">parent</a><span>|</span><a href="#37493628">next</a><span>|</span><label class="collapse" for="c-37493743">[-]</label><label class="expand" for="c-37493743">[1 more]</label></div><br/><div class="children"><div class="content">There’s a big risk that it moves in that direction, indeed. But that depends on what kind of tech gains traction. Imo, a great local-first app has a rich client and a dumb server that serves simple functions like relaying, backing up and auth.<p>The main challenge is social. Once you have true local first, lots of apps have no plausible excuse to store all your private data in plain text. I can already see the disappointed faces of the VCs and other bean counters when they understand this. But for good or bad, that also means that there will be very little money behind these efforts.</div><br/></div></div><div id="37493628" class="c"><input type="checkbox" id="c-37493628" checked=""/><div class="controls bullet"><span class="by">bbor</span><span>|</span><a href="#37493196">parent</a><span>|</span><a href="#37493743">prev</a><span>|</span><a href="#37492412">next</a><span>|</span><label class="collapse" for="c-37493628">[-]</label><label class="expand" for="c-37493628">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious what kind of app doesn&#x27;t already require tracking state on the client...? Very confused about your objection, but probably just because of inexperience on my part. It seems to me that basically every web app I can think of (e.g. Facebook, Figma, ChatGPT, Spotify, Discord) revolves around the server and client sharing some responsibility for tracking and updating the state.<p>If your objection is that we should <i>just</i> have state as a DB table on a server and just sync it to the client as needed, then that&#x27;s basically what this is -- just with a client DB instead of a client Redux store&#x2F;bespoke javascript mess&#x2F;etc.</div><br/></div></div></div></div><div id="37491239" class="c"><input type="checkbox" id="c-37491239" checked=""/><div class="controls bullet"><span class="by">edweis</span><span>|</span><a href="#37492412">prev</a><span>|</span><a href="#37493284">next</a><span>|</span><label class="collapse" for="c-37491239">[-]</label><label class="expand" for="c-37491239">[8 more]</label></div><br/><div class="children"><div class="content">Does someone has a successful local-first product used by paying customers?<p>I am interested in your take on local-first.</div><br/><div id="37492012" class="c"><input type="checkbox" id="c-37492012" checked=""/><div class="controls bullet"><span class="by">enra</span><span>|</span><a href="#37491239">parent</a><span>|</span><a href="#37491261">next</a><span>|</span><label class="collapse" for="c-37492012">[-]</label><label class="expand" for="c-37492012">[2 more]</label></div><br/><div class="children"><div class="content">We created Linear[1] as local-first product. Back in to 2019 there wasn&#x27;t much anything available so we created our sync engine. Today we have several thousands companies, from early stage to public companies as paying customers (companies such as Vercel, Replit, Substack, Square..)<p>Our co-founder did talk about sync engine back in 2020 and recently did updated talk about scaling it [3]. The scaling has definitely taken lot of work and optimizing as datasets for company wide workspace with potentially thousands of users ands object they created can become quite large.<p>1: <a href="https:&#x2F;&#x2F;linear.app" rel="nofollow noreferrer">https:&#x2F;&#x2F;linear.app</a><p>2: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=WxK11RsLqp4&amp;t=2169s">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=WxK11RsLqp4&amp;t=2169s</a><p>3: <a href="https:&#x2F;&#x2F;linear.app&#x2F;blog&#x2F;scaling-the-linear-sync-engine" rel="nofollow noreferrer">https:&#x2F;&#x2F;linear.app&#x2F;blog&#x2F;scaling-the-linear-sync-engine</a></div><br/><div id="37492766" class="c"><input type="checkbox" id="c-37492766" checked=""/><div class="controls bullet"><span class="by">aidos</span><span>|</span><a href="#37491239">root</a><span>|</span><a href="#37492012">parent</a><span>|</span><a href="#37491261">next</a><span>|</span><label class="collapse" for="c-37492766">[-]</label><label class="expand" for="c-37492766">[1 more]</label></div><br/><div class="children"><div class="content">It was off the back of that talk that I was able to finally convince my team to go this route (back in 2019). They&#x27;d been trying to handle optimistic updates through Apollo and I was pushing the to make our own sync system over our mobx models to fix the DX.<p>After watching the talk we picked apart Linear&#x27;s minified code to better understand the structure and then jumped on a call with Tuomas where he kindly filled any holes in our understanding.<p>Initially we tried to use IndexDB to give us more of the local-first features by caching between loads, but it was more hassle than it was worth. Instead we settled on live queries using Hasrua (we were a <i>very</i> early user &#x2F; paying customer). We preload all the data that the user is going to need on app boot and then selectively load large chunks as they open their projects. These are then keeping mobx models up to date.<p>For mutating data we have a simple transaction system that you wrap around models to update them. It records and sends the mutations and makes sure that outstanding mutations are replayed over model changes locally.<p>We&#x27;re not very &quot;local-first&quot; feature-wise; we don&#x27;t handle conflicts perfectly, really relying on the fact that people <i>are online</i> and receive updates quickly. In practice it works.<p>Most importantly developers get a familiar graph of objects locally that they can just manipulate and <i>not think</i> about:<p><pre><code>    project.name = &#x27;New name&#x27;
    project.save()
</code></pre>
PS <a href="https:&#x2F;&#x2F;www.countfire.com" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.countfire.com</a> (always looking for UK based devs to join the team)<p>EDIT Love your design work on Linear, Karri. You guys have made such an amazing product.</div><br/></div></div></div></div><div id="37491261" class="c"><input type="checkbox" id="c-37491261" checked=""/><div class="controls bullet"><span class="by">SenHeng</span><span>|</span><a href="#37491239">parent</a><span>|</span><a href="#37492012">prev</a><span>|</span><a href="#37492392">next</a><span>|</span><label class="collapse" for="c-37491261">[-]</label><label class="expand" for="c-37491261">[1 more]</label></div><br/><div class="children"><div class="content">I found this sometime last year somewhere, that shows a list of companies&#x2F;apps&#x2F;technologies and talks about starting local first.<p><a href="https:&#x2F;&#x2F;localfirstweb.dev" rel="nofollow noreferrer">https:&#x2F;&#x2F;localfirstweb.dev</a></div><br/></div></div><div id="37492392" class="c"><input type="checkbox" id="c-37492392" checked=""/><div class="controls bullet"><span class="by">adamddev1</span><span>|</span><a href="#37491239">parent</a><span>|</span><a href="#37491261">prev</a><span>|</span><a href="#37491829">next</a><span>|</span><label class="collapse" for="c-37492392">[-]</label><label class="expand" for="c-37492392">[1 more]</label></div><br/><div class="children"><div class="content">I made an open-source Pashto dictionary with a (local-first) word list (with spaced repititon review) that syncs with PouchDb&#x2F;CouchDb. It&#x27;s a free dictionary but you pay to get the word list sync. The whole dictionary is designed to be an offline-first SPA so a local-first DB&#x2F;sync for the word made sense.<p><a href="https:&#x2F;&#x2F;dictionary.lingdocs.com" rel="nofollow noreferrer">https:&#x2F;&#x2F;dictionary.lingdocs.com</a></div><br/></div></div><div id="37491829" class="c"><input type="checkbox" id="c-37491829" checked=""/><div class="controls bullet"><span class="by">knubie</span><span>|</span><a href="#37491239">parent</a><span>|</span><a href="#37492392">prev</a><span>|</span><a href="#37492867">next</a><span>|</span><label class="collapse" for="c-37491829">[-]</label><label class="expand" for="c-37491829">[1 more]</label></div><br/><div class="children"><div class="content">I built Mochi [0] from the ground up to be local first. The architecture is built around pouchdb for the local database which syncs to and from a remote couchdb database.<p>It&#x27;s been a challenge to implement and in hindsight I wonder if it was even worth it. Unfortunately neither of these technologies are very widely used any more (if they ever were).<p>I am glad there is a lot of development and research in this area though. I think with the right DX and architecture local first makes a lot more sense than the status quo of continuously fetching everything from a remote database.<p>[0] <a href="https:&#x2F;&#x2F;mochi.cards" rel="nofollow noreferrer">https:&#x2F;&#x2F;mochi.cards</a></div><br/></div></div><div id="37492867" class="c"><input type="checkbox" id="c-37492867" checked=""/><div class="controls bullet"><span class="by">hobofan</span><span>|</span><a href="#37491239">parent</a><span>|</span><a href="#37491829">prev</a><span>|</span><a href="#37493011">next</a><span>|</span><label class="collapse" for="c-37492867">[-]</label><label class="expand" for="c-37492867">[1 more]</label></div><br/><div class="children"><div class="content">Obsidian[0], as well as many other Zettelkasten applications are local-first.<p><a href="https:&#x2F;&#x2F;obsidian.md" rel="nofollow noreferrer">https:&#x2F;&#x2F;obsidian.md</a></div><br/></div></div><div id="37493011" class="c"><input type="checkbox" id="c-37493011" checked=""/><div class="controls bullet"><span class="by">joecobb</span><span>|</span><a href="#37491239">parent</a><span>|</span><a href="#37492867">prev</a><span>|</span><a href="#37493284">next</a><span>|</span><label class="collapse" for="c-37493011">[-]</label><label class="expand" for="c-37493011">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.inkandswitch.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.inkandswitch.com&#x2F;</a></div><br/></div></div></div></div><div id="37493284" class="c"><input type="checkbox" id="c-37493284" checked=""/><div class="controls bullet"><span class="by">steve1977</span><span>|</span><a href="#37491239">prev</a><span>|</span><a href="#37493164">next</a><span>|</span><label class="collapse" for="c-37493284">[-]</label><label class="expand" for="c-37493284">[1 more]</label></div><br/><div class="children"><div class="content">The JavaScript&#x2F;webapp world will soon have reached its goal and have a complete operating system running the browser. Then someone will come along and develop some kind of browser in that operating system and the whole game starts again …</div><br/></div></div><div id="37493164" class="c"><input type="checkbox" id="c-37493164" checked=""/><div class="controls bullet"><span class="by">chadk</span><span>|</span><a href="#37493284">prev</a><span>|</span><a href="#37493657">next</a><span>|</span><label class="collapse" for="c-37493164">[-]</label><label class="expand" for="c-37493164">[1 more]</label></div><br/><div class="children"><div class="content">If anyone will be in St Louis for Strange Loop next week come out to the LoFi Unconf to talk more about local first.<p><a href="https:&#x2F;&#x2F;lu.ma&#x2F;localfirstswunconf-stlouis" rel="nofollow noreferrer">https:&#x2F;&#x2F;lu.ma&#x2F;localfirstswunconf-stlouis</a></div><br/></div></div><div id="37493657" class="c"><input type="checkbox" id="c-37493657" checked=""/><div class="controls bullet"><span class="by">mooktakim</span><span>|</span><a href="#37493164">prev</a><span>|</span><a href="#37492795">next</a><span>|</span><label class="collapse" for="c-37493657">[-]</label><label class="expand" for="c-37493657">[1 more]</label></div><br/><div class="children"><div class="content">This is what they call a &quot;desktop application&quot;</div><br/></div></div><div id="37492795" class="c"><input type="checkbox" id="c-37492795" checked=""/><div class="controls bullet"><span class="by">pacifika</span><span>|</span><a href="#37493657">prev</a><span>|</span><a href="#37491271">next</a><span>|</span><label class="collapse" for="c-37492795">[-]</label><label class="expand" for="c-37492795">[1 more]</label></div><br/><div class="children"><div class="content">The analogy is Traditional backend development is thin client software, reactive frameworks are networked software, and local first is the native software (keep data with the client). The browser is the OS.<p>Why not skip the whole App Store generation that’s to come and build a browser extension today?</div><br/></div></div><div id="37491271" class="c"><input type="checkbox" id="c-37491271" checked=""/><div class="controls bullet"><span class="by">emmanueloga_</span><span>|</span><a href="#37492795">prev</a><span>|</span><label class="collapse" for="c-37491271">[-]</label><label class="expand" for="c-37491271">[2 more]</label></div><br/><div class="children"><div class="content">wow, I never heard of &quot;60 FPS CRUD&quot;... that must be next level of form filling efficiency :-p</div><br/><div id="37492712" class="c"><input type="checkbox" id="c-37492712" checked=""/><div class="controls bullet"><span class="by">aayushdutt</span><span>|</span><a href="#37491271">parent</a><span>|</span><label class="collapse" for="c-37492712">[-]</label><label class="expand" for="c-37492712">[1 more]</label></div><br/><div class="children"><div class="content">I think that means you can do CRUD operations &gt;60 times a second. An example could be a multiplayer game running at 60 fps (like agar-dot-io).</div><br/></div></div></div></div></div></div></div></div></div></body></html>