<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1697878857372" as="style"/><link rel="stylesheet" href="styles.css?v=1697878857372"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://lwn.net/Articles/947138/">Progress on No-GIL CPython</a>Â <span class="domain">(<a href="https://lwn.net">lwn.net</a>)</span></div><div class="subtext"><span>belter</span> | <span>164 comments</span></div><br/><div><div id="37965190" class="c"><input type="checkbox" id="c-37965190" checked=""/><div class="controls bullet"><span class="by">DanielHB</span><span>|</span><a href="#37961786">next</a><span>|</span><label class="collapse" for="c-37965190">[-]</label><label class="expand" for="c-37965190">[1 more]</label></div><br/><div class="children"><div class="content">I am not an expert in python but I feel that the JS model where everything is on the event loop and there is no actual threads seem better for a dynamic language. A lot of parallelization can be achieved with web-workers, but of course at the cost of relying on copying memory between workers (ie no shared memory).<p>There have been some proposals to add full shared memory constructs (SharedArrayBuffer) and synchronization (Atomics) mechanisms, but they are special constructs and don&#x27;t work with normal javascript objects. Quite limited but provide full parallelism for things that usually need it (buffers).<p>One thing people often forget is that thread-safe data structures are usually a lot slower than single-threaded one, everything in JS is single threaded and in the event loop, but if you really need it there are some scape hatches.<p>I don&#x27;t know, this just feels better and simpler? If you really need to you can go down to a lower level language for full memory sharing data structures.</div><br/></div></div><div id="37961786" class="c"><input type="checkbox" id="c-37961786" checked=""/><div class="controls bullet"><span class="by">Affric</span><span>|</span><a href="#37965190">prev</a><span>|</span><a href="#37964493">next</a><span>|</span><label class="collapse" for="c-37961786">[-]</label><label class="expand" for="c-37961786">[35 more]</label></div><br/><div class="children"><div class="content">Interesting discussion there too.<p>With modern computers I wonder if explicit parallelism is more fundamental to what our computer science will be than is in vogue in textbooks. Perhaps we should always be writing explicitly parallel code at this point.</div><br/><div id="37961889" class="c"><input type="checkbox" id="c-37961889" checked=""/><div class="controls bullet"><span class="by">Gh0stRAT</span><span>|</span><a href="#37961786">parent</a><span>|</span><a href="#37963411">next</a><span>|</span><label class="collapse" for="c-37961889">[-]</label><label class="expand" for="c-37961889">[15 more]</label></div><br/><div class="children"><div class="content">Humans are bad at reasoning about multiple threads simultaneously, so I suspect the more practical shift is the trend we&#x27;ve already been seeing toward more declarative syntax.<p>eg `for` loops are being replaced by `foreach` loops,`map` and `filter` operations, etc. These tell the compiler&#x2F;interpreter that you want to do some operation to all the items in your datastructure, leaving it up to the compiler&#x2F;runtime whether and how to  parallelize the work for you.</div><br/><div id="37962428" class="c"><input type="checkbox" id="c-37962428" checked=""/><div class="controls bullet"><span class="by">MR4D</span><span>|</span><a href="#37961786">root</a><span>|</span><a href="#37961889">parent</a><span>|</span><a href="#37965124">next</a><span>|</span><label class="collapse" for="c-37962428">[-]</label><label class="expand" for="c-37962428">[7 more]</label></div><br/><div class="children"><div class="content">I would upvote this 100 times if I could.<p>I&#x27;ve thought this way ever since MacOS added the Grand Central Dispatch [1].  Of course, I thought industry would follow quickly and that tooling would coalesce around this concept pretty quickly. Seems the industry wants to take its sweet time.<p>[1] - <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Grand_Central_Dispatch" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Grand_Central_Dispatch</a></div><br/><div id="37962559" class="c"><input type="checkbox" id="c-37962559" checked=""/><div class="controls bullet"><span class="by">cpgxiii</span><span>|</span><a href="#37961786">root</a><span>|</span><a href="#37962428">parent</a><span>|</span><a href="#37963461">next</a><span>|</span><label class="collapse" for="c-37962559">[-]</label><label class="expand" for="c-37962559">[5 more]</label></div><br/><div class="children"><div class="content">I mean, OpenMP dates back to 1997 (1998 for C and C++). Apple, however, has never supported it for what can only be selfish reasons (particularly since Clang has a quite good implementation provided by Intel, which can easily be installed on a Mac if you want). GCD came a decade later.<p>For basic parallelism, nothing beats OpenMP for ease of adapting existing code (often a single &quot;#pragma omp parallel for&quot; directive is enough). Even for more complex parallelism, particularly where per-thread resources need to be managed, OpenMP still provides a much simpler programming model than the alternatives.</div><br/><div id="37962620" class="c"><input type="checkbox" id="c-37962620" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#37961786">root</a><span>|</span><a href="#37962559">parent</a><span>|</span><a href="#37963461">next</a><span>|</span><label class="collapse" for="c-37962620">[-]</label><label class="expand" for="c-37962620">[4 more]</label></div><br/><div class="children"><div class="content">OpenMP and GCD solve different problems. You&#x27;d not want to use GCD to parallelize the same tasks you&#x27;re parallelizing with OpenMP in most cases. GCD is more suited for the one-off cases (toss this task into the queue, toss that task into the queue; or &quot;as we get new items from the user toss the processing into the queue&quot; but we don&#x27;t know the rate of new items coming in so batching doesn&#x27;t make as much sense), vice OpenMP which is targeting things like scientific computing&#x2F;simulations where you <i>know</i> you have a million objects you want to perform a computation on. The GCD version of the same would be slower by a large measure if you spawned a task per work item or you&#x27;d recreate parts of OpenMP to divide the work across a smaller number of tasks. And you wouldn&#x27;t want to use OpenMP for parallelizing the kind of things you toss into a work queue model like GCD offers.</div><br/><div id="37962772" class="c"><input type="checkbox" id="c-37962772" checked=""/><div class="controls bullet"><span class="by">cpgxiii</span><span>|</span><a href="#37961786">root</a><span>|</span><a href="#37962620">parent</a><span>|</span><a href="#37963461">next</a><span>|</span><label class="collapse" for="c-37962772">[-]</label><label class="expand" for="c-37962772">[3 more]</label></div><br/><div class="children"><div class="content">Sure, OpenMP and GCD provide different interfaces around the same concept of a managed threadpool. Given both, one would use them for different tasks (in the same way one actually uses OpenMP and std::async for complementary purposes). But in the context of GP&#x27;s basic parallelelized for&#x2F;map&#x2F;reduce  operations, either can be used fine (although OpenMP would probably be more pleasant to write).</div><br/><div id="37963476" class="c"><input type="checkbox" id="c-37963476" checked=""/><div class="controls bullet"><span class="by">osigurdson</span><span>|</span><a href="#37961786">root</a><span>|</span><a href="#37962772">parent</a><span>|</span><a href="#37963461">next</a><span>|</span><label class="collapse" for="c-37963476">[-]</label><label class="expand" for="c-37963476">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not familiar with GCD but after reading the wiki page, I&#x27;d say most languages have something like that: a queue that you can add things to, items can then be processed by multiple threads of execution.<p>I&#x27;d also say that most languages have something similar to OpenMP, parallel for loops, etc. Great if you have some read only data in arrays and wish to process it.<p>However, in my opinion, it doesn&#x27;t really matter how convenient a parallel &#x2F; async programming model is to use as the real work is ensuring that there isn&#x27;t any shared mutable state being updated in parallel. The other issue is, once you have formulated &#x2F; re-formulated a particular problem to this model, ensuring that it remains this way is pretty challenging on larger teams. Someone can easily unknowingly commit something that breaks such assumptions.</div><br/><div id="37964241" class="c"><input type="checkbox" id="c-37964241" checked=""/><div class="controls bullet"><span class="by">cpgxiii</span><span>|</span><a href="#37961786">root</a><span>|</span><a href="#37963476">parent</a><span>|</span><a href="#37963461">next</a><span>|</span><label class="collapse" for="c-37964241">[-]</label><label class="expand" for="c-37964241">[1 more]</label></div><br/><div class="children"><div class="content">At the end of the day, no matter what kind of code you are writing, you either have tools and processes in place that reduce the risk&#x2F;mitigate the impacts of bugs, or there is always the risk of serious problems being introduced. An unknowing change that breaks parallelism in another component could just as well be an unknowing change that breaks authentication or defeats a security boundary.<p>Parallelism introduces an additional class of bugs, but they are fundamentally addressed the same way as any other class of bugs - e.g. testing, tools, and code review. If some_one_ can unknowingly break a system, that means the tools and processes weren&#x27;t good enough.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37963461" class="c"><input type="checkbox" id="c-37963461" checked=""/><div class="controls bullet"><span class="by">dogleash</span><span>|</span><a href="#37961786">root</a><span>|</span><a href="#37962428">parent</a><span>|</span><a href="#37962559">prev</a><span>|</span><a href="#37965124">next</a><span>|</span><label class="collapse" for="c-37963461">[-]</label><label class="expand" for="c-37963461">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Seems the industry wants to take its sweet time.<p>We&#x27;re inching towards an in vogue way to do what erlang had figured out in the 80&#x27;s.  We&#x27;ll pick up the pace any day now. Surely.</div><br/></div></div></div></div><div id="37965124" class="c"><input type="checkbox" id="c-37965124" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#37961786">root</a><span>|</span><a href="#37961889">parent</a><span>|</span><a href="#37962428">prev</a><span>|</span><a href="#37964913">next</a><span>|</span><label class="collapse" for="c-37965124">[-]</label><label class="expand" for="c-37965124">[1 more]</label></div><br/><div class="children"><div class="content">C++ has had std::execution_policy for a long time now - you pass that with an algorithm like sort, for_each, etc. and it will choose a way to parallelize that for you.</div><br/></div></div><div id="37964913" class="c"><input type="checkbox" id="c-37964913" checked=""/><div class="controls bullet"><span class="by">psalminen</span><span>|</span><a href="#37961786">root</a><span>|</span><a href="#37961889">parent</a><span>|</span><a href="#37965124">prev</a><span>|</span><a href="#37965180">next</a><span>|</span><label class="collapse" for="c-37964913">[-]</label><label class="expand" for="c-37964913">[1 more]</label></div><br/><div class="children"><div class="content">I like the way you word this. Similar to the product I make, I describe my mind as an asynchronous queue. I can only reason about one thing at a time, but when I do that is fairly random.<p>How this has played out in my life gives me caution about making this standard in computing.</div><br/></div></div><div id="37965180" class="c"><input type="checkbox" id="c-37965180" checked=""/><div class="controls bullet"><span class="by">minikomi</span><span>|</span><a href="#37961786">root</a><span>|</span><a href="#37961889">parent</a><span>|</span><a href="#37964913">prev</a><span>|</span><a href="#37963312">next</a><span>|</span><label class="collapse" for="c-37965180">[-]</label><label class="expand" for="c-37965180">[1 more]</label></div><br/><div class="children"><div class="content">Shades of clojure&#x27;s transducers</div><br/></div></div><div id="37963312" class="c"><input type="checkbox" id="c-37963312" checked=""/><div class="controls bullet"><span class="by">Affric</span><span>|</span><a href="#37961786">root</a><span>|</span><a href="#37961889">parent</a><span>|</span><a href="#37965180">prev</a><span>|</span><a href="#37963357">next</a><span>|</span><label class="collapse" for="c-37963312">[-]</label><label class="expand" for="c-37963312">[1 more]</label></div><br/><div class="children"><div class="content">I agree to a large extent but I am referring more to our teaching of Computer Science. For our teaching of Software Engineering I think you&#x27;re largely correct.<p>&gt; Humans are bad at reasoning about multiple threads simultaneously<p>I am not so sure this is true, I do believe that people are poorly practiced. My experiences have led me to believe Universities silo explicit parallel programming too much. It&#x27;s generally it&#x27;s own non-compulsory subject in a Comp-Sci major.</div><br/></div></div><div id="37963357" class="c"><input type="checkbox" id="c-37963357" checked=""/><div class="controls bullet"><span class="by">johnloeber</span><span>|</span><a href="#37961786">root</a><span>|</span><a href="#37961889">parent</a><span>|</span><a href="#37963312">prev</a><span>|</span><a href="#37963892">next</a><span>|</span><label class="collapse" for="c-37963357">[-]</label><label class="expand" for="c-37963357">[1 more]</label></div><br/><div class="children"><div class="content">Yep! The only thing that remains is to focus on that code being properly functional; i.e. avoiding side-effects. Side-effects and parallelism don&#x27;t mix well. Wonder if this will give rise to more functional languages.</div><br/></div></div><div id="37963892" class="c"><input type="checkbox" id="c-37963892" checked=""/><div class="controls bullet"><span class="by">FpUser</span><span>|</span><a href="#37961786">root</a><span>|</span><a href="#37961889">parent</a><span>|</span><a href="#37963357">prev</a><span>|</span><a href="#37963411">next</a><span>|</span><label class="collapse" for="c-37963892">[-]</label><label class="expand" for="c-37963892">[2 more]</label></div><br/><div class="children"><div class="content">&gt;&quot;Humans are bad at reasoning about multiple threads simultaneously&quot;<p>Humans are bad at reasoning about way too many things. I think mostly because many are lazy and do not want to learn. The ones who do have little problems. I do not find thread management particularly hard for the most parts (there are some exceptions but those are very uncommon).</div><br/><div id="37965097" class="c"><input type="checkbox" id="c-37965097" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#37961786">root</a><span>|</span><a href="#37963892">parent</a><span>|</span><a href="#37963411">next</a><span>|</span><label class="collapse" for="c-37965097">[-]</label><label class="expand" for="c-37965097">[1 more]</label></div><br/><div class="children"><div class="content">Fine then.  Your compiler is bad at reasoning about multiple threads simultaneously.</div><br/></div></div></div></div></div></div><div id="37963411" class="c"><input type="checkbox" id="c-37963411" checked=""/><div class="controls bullet"><span class="by">dehrmann</span><span>|</span><a href="#37961786">parent</a><span>|</span><a href="#37961889">prev</a><span>|</span><a href="#37962753">next</a><span>|</span><label class="collapse" for="c-37963411">[-]</label><label class="expand" for="c-37963411">[2 more]</label></div><br/><div class="children"><div class="content">Parallelism ended up going off in a few different directions.<p>For things like running a web service, requests are fast enough, and the real win from parallelism is in handling lots of requests side-by-side. This is where No-GIL comes in.<p>Within handling a single request, if there are a lot of sub-requests, that&#x27;s usually handled by async code, but not so much for the async performance win as much as spinning up threads is either expensive or thread pools are a hassle. Remember that async is better for throughput, but worse for latency, and if you&#x27;re parallelizing a service request, you&#x27;re probably more worried about latency. Async won mostly on ergonomics.<p>The other place you see parallelism is large offline jobs. Things like Map-reduce and Presto. Those tend to look like divide-and-conquer problems. GPU model training looks something like this.<p>What never happened is local, highly parallel algorithms. For a web service, data size is too small to see a latency win, they&#x27;re complicated, and coordination between threads become costly. The small exceptions are vectorized algorithms, but these run one one core, so there isn&#x27;t coordination overhead, and online inference, but again, this is heavily vectorized.</div><br/><div id="37963418" class="c"><input type="checkbox" id="c-37963418" checked=""/><div class="controls bullet"><span class="by">rsaxvc</span><span>|</span><a href="#37961786">root</a><span>|</span><a href="#37963411">parent</a><span>|</span><a href="#37962753">next</a><span>|</span><label class="collapse" for="c-37963418">[-]</label><label class="expand" for="c-37963418">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What never happened is local, highly parallel algorithms.<p>GPUs maybe? Also, excellent answer.</div><br/></div></div></div></div><div id="37962753" class="c"><input type="checkbox" id="c-37962753" checked=""/><div class="controls bullet"><span class="by">eslaught</span><span>|</span><a href="#37961786">parent</a><span>|</span><a href="#37963411">prev</a><span>|</span><a href="#37962489">next</a><span>|</span><label class="collapse" for="c-37962753">[-]</label><label class="expand" for="c-37962753">[4 more]</label></div><br/><div class="children"><div class="content">Parallelism in CS is a bit like security in CS. People know it matters in the abstract senses but you really only get into it if you look for the training specifically. We&#x27;re getting better at both over time: just as more languages&#x2F;libraries&#x2F;etc. are secure by default, more now are parallel by default. There&#x27;s a ways to go, but I&#x27;m glad we didn&#x27;t do this prematurely, because the technology has improved a lot in the last decade. Look for example at what we can do (safely!) with Rayon in Rust vs (unsafely!) with OpenMP in C++.<p>And there are things even further afield like what I work on [1][2][3].<p>[1]: <a href="https:&#x2F;&#x2F;legion.stanford.edu&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;legion.stanford.edu&#x2F;</a><p>[2]: <a href="https:&#x2F;&#x2F;regent-lang.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;regent-lang.org&#x2F;</a><p>[3]: <a href="https:&#x2F;&#x2F;github.com&#x2F;nv-legate&#x2F;cunumeric">https:&#x2F;&#x2F;github.com&#x2F;nv-legate&#x2F;cunumeric</a></div><br/><div id="37963307" class="c"><input type="checkbox" id="c-37963307" checked=""/><div class="controls bullet"><span class="by">eyegor</span><span>|</span><a href="#37961786">root</a><span>|</span><a href="#37962753">parent</a><span>|</span><a href="#37964021">next</a><span>|</span><label class="collapse" for="c-37963307">[-]</label><label class="expand" for="c-37963307">[1 more]</label></div><br/><div class="children"><div class="content">See also<p><a href="https:&#x2F;&#x2F;github.com&#x2F;cupy&#x2F;cupy">https:&#x2F;&#x2F;github.com&#x2F;cupy&#x2F;cupy</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;inducer&#x2F;pyopencl">https:&#x2F;&#x2F;github.com&#x2F;inducer&#x2F;pyopencl</a></div><br/></div></div><div id="37964021" class="c"><input type="checkbox" id="c-37964021" checked=""/><div class="controls bullet"><span class="by">winter_blue</span><span>|</span><a href="#37961786">root</a><span>|</span><a href="#37962753">parent</a><span>|</span><a href="#37963307">prev</a><span>|</span><a href="#37962489">next</a><span>|</span><label class="collapse" for="c-37964021">[-]</label><label class="expand" for="c-37964021">[2 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the difference between Legion and Regent, by the way?<p>I noticed the Regent code is inside the Legion repo. Is Legion <i>the system</i>, and <i>Regent</i> the language?<p>Can Legion be used without Regent, or vice versa?</div><br/><div id="37964068" class="c"><input type="checkbox" id="c-37964068" checked=""/><div class="controls bullet"><span class="by">eslaught</span><span>|</span><a href="#37961786">root</a><span>|</span><a href="#37964021">parent</a><span>|</span><a href="#37962489">next</a><span>|</span><label class="collapse" for="c-37964068">[-]</label><label class="expand" for="c-37964068">[1 more]</label></div><br/><div class="children"><div class="content">Legion is a C++ runtime system. It exposes APIs in C++ and C. You can write code directly to it with C++ (and CUDA&#x2F;HIP&#x2F;SyCL if you want to use GPUs). But the only requirement is a C++ compiler and standard build system (Make&#x2F;CMake).<p>Regent is a programming language. The compiler for Regent generates Legion code. Semantically, Regent is mostly a simplification of Legion. There are fewer moving pieces, so fewer things you need to worry about. Many of the &quot;gotchas&quot; that exist in Legion are taken care of by the language&#x2F;compiler so idiomatic code usually &quot;just works&quot;. It also does GPU code generation for you so you don&#x27;t need to hand-write CUDA&#x2F;HIP&#x2F;etc. The tradeoff is that you&#x27;re using a new programming language, so you have to be willing to take that risk.</div><br/></div></div></div></div></div></div><div id="37962489" class="c"><input type="checkbox" id="c-37962489" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#37961786">parent</a><span>|</span><a href="#37962753">prev</a><span>|</span><a href="#37962508">next</a><span>|</span><label class="collapse" for="c-37962489">[-]</label><label class="expand" for="c-37962489">[4 more]</label></div><br/><div class="children"><div class="content">LMAX Disruptor has on their wiki that average latency to send a message from one thread to another at 53 nanoseconds. For comparison a mutex is like 25 nanoseconds and more if Contended but a mutex is point to point synchronization.<p>The great thing about the disruptor it is that multiple threads can receive the same message without much more effort.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;LMAX-Exchange&#x2F;disruptor&#x2F;wiki&#x2F;Performance-Results">https:&#x2F;&#x2F;github.com&#x2F;LMAX-Exchange&#x2F;disruptor&#x2F;wiki&#x2F;Performance-...</a><p><a href="https:&#x2F;&#x2F;gist.github.com&#x2F;rmacy&#x2F;2879257" rel="nofollow noreferrer">https:&#x2F;&#x2F;gist.github.com&#x2F;rmacy&#x2F;2879257</a><p>I am dreaming of language that is similar to Smalltalk that stays single threaded until it makes sense to parallise.<p>I am looking for problems for parallelism that are not big data. Parallelism is like adding more cars to the road rather than increasing the speed of the car. But what does a desktop or mobile user need to do locally that could take advantage of the mathematical power of a computer? I&#x27;m still searching.<p>I am thoughtful of the Itanium and VLIW architecture for parallelism ideas.</div><br/><div id="37964373" class="c"><input type="checkbox" id="c-37964373" checked=""/><div class="controls bullet"><span class="by">sitkack</span><span>|</span><a href="#37961786">root</a><span>|</span><a href="#37962489">parent</a><span>|</span><a href="#37963317">next</a><span>|</span><label class="collapse" for="c-37964373">[-]</label><label class="expand" for="c-37964373">[1 more]</label></div><br/><div class="children"><div class="content">Pervasive parallelism could make massive efficiency gains in computation possible. If we could move many work loads to hundreds or thousands of threads we could run it much lower clock frequencies and thus lower power. It could also enable the use of cheap, small in order cores, further boosting core counts.<p>Multithreading doesnât always have to be around increasing speed, it can also reduce power</div><br/></div></div><div id="37963317" class="c"><input type="checkbox" id="c-37963317" checked=""/><div class="controls bullet"><span class="by">Affric</span><span>|</span><a href="#37961786">root</a><span>|</span><a href="#37962489">parent</a><span>|</span><a href="#37964373">prev</a><span>|</span><a href="#37963829">next</a><span>|</span><label class="collapse" for="c-37963317">[-]</label><label class="expand" for="c-37963317">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I am looking for problems for parallelism that are not big data. Parallelism is like adding more cars to the road rather than increasing the speed of the car. But what does a desktop or mobile user need to do locally that could take advantage of the mathematical power of a computer? I&#x27;m still searching.<p>The things we currently let servers do but it would mean we can keep user data local and not hand it over to service providers. I believe that is a worthy end goal.</div><br/></div></div><div id="37963829" class="c"><input type="checkbox" id="c-37963829" checked=""/><div class="controls bullet"><span class="by">tmountain</span><span>|</span><a href="#37961786">root</a><span>|</span><a href="#37962489">parent</a><span>|</span><a href="#37963317">prev</a><span>|</span><a href="#37962508">next</a><span>|</span><label class="collapse" for="c-37963829">[-]</label><label class="expand" for="c-37963829">[1 more]</label></div><br/><div class="children"><div class="content">It sounds like you are thinking about concurrency more than parallelism. The answer to your question is very general at a high level. Any task that can be broken up into chunks benefits. In the simplest terms, tasks that can be computed in buckets with a final result computed from those buckets will benefit from concurrency. Think of a video game as a good example. Environment calculations are happening in the background while the main game loop is processing. There are almost infinite use cases and examples, so I wonât try to enumerate them all.</div><br/></div></div></div></div><div id="37962508" class="c"><input type="checkbox" id="c-37962508" checked=""/><div class="controls bullet"><span class="by">xboxnolifes</span><span>|</span><a href="#37961786">parent</a><span>|</span><a href="#37962489">prev</a><span>|</span><a href="#37962543">next</a><span>|</span><label class="collapse" for="c-37962508">[-]</label><label class="expand" for="c-37962508">[1 more]</label></div><br/><div class="children"><div class="content">As I see it, parallelism is in the same vein as memory management. Most of what we program can, and should, use some form of automatic management, and manual management is reserved for the areas where it is needed for performance.<p>It&#x27;s an implementation detail, and if we can abstract it away to make it easier to utilize, we should.</div><br/></div></div><div id="37962543" class="c"><input type="checkbox" id="c-37962543" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#37961786">parent</a><span>|</span><a href="#37962508">prev</a><span>|</span><a href="#37964054">next</a><span>|</span><label class="collapse" for="c-37962543">[-]</label><label class="expand" for="c-37962543">[1 more]</label></div><br/><div class="children"><div class="content">Do you mean implicit parallelism? Because what we have now is typically explicit paralellism. Creating a thread or forking a subprocess is explicit parallelism, the programmer <i>chooses</i> that option. A function like `map` that can utilize a parallel or sequential implementation depending on circumstances the runtime or compiler are aware of without direct input from the programmer would be implicit parallelism. If the `map` function takes an execution context that signifies parallel or sequential execution then we&#x27;re back to explicit.</div><br/></div></div><div id="37964054" class="c"><input type="checkbox" id="c-37964054" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#37961786">parent</a><span>|</span><a href="#37962543">prev</a><span>|</span><a href="#37962380">next</a><span>|</span><label class="collapse" for="c-37964054">[-]</label><label class="expand" for="c-37964054">[1 more]</label></div><br/><div class="children"><div class="content">It seems serious parallel programming has mostly gone with shader&#x2F;ISPC style data-parallel computation with low-level languages and the old school threads &amp; locks model has been relegated to a side support role lost except on the CPU side.<p>There&#x27;s interesting stuff going on in the VHLL world with languages like Futhark, Jax, Mojo, etc that would be a better peer group for Python and its high level of abstraction.</div><br/></div></div><div id="37962380" class="c"><input type="checkbox" id="c-37962380" checked=""/><div class="controls bullet"><span class="by">jeremycarter</span><span>|</span><a href="#37961786">parent</a><span>|</span><a href="#37964054">prev</a><span>|</span><a href="#37962500">next</a><span>|</span><label class="collapse" for="c-37962380">[-]</label><label class="expand" for="c-37962380">[2 more]</label></div><br/><div class="children"><div class="content">I think this is why I&#x27;m a huge advocate of the Actor Model.</div><br/><div id="37963141" class="c"><input type="checkbox" id="c-37963141" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#37961786">root</a><span>|</span><a href="#37962380">parent</a><span>|</span><a href="#37962500">next</a><span>|</span><label class="collapse" for="c-37963141">[-]</label><label class="expand" for="c-37963141">[1 more]</label></div><br/><div class="children"><div class="content">Likewise, it is one of the best solutions to this problem. And it also nicely maps onto language constructs, much nicer than the other options that I&#x27;ve worked with.</div><br/></div></div></div></div><div id="37962500" class="c"><input type="checkbox" id="c-37962500" checked=""/><div class="controls bullet"><span class="by">ketralnis</span><span>|</span><a href="#37961786">parent</a><span>|</span><a href="#37962380">prev</a><span>|</span><a href="#37963136">next</a><span>|</span><label class="collapse" for="c-37962500">[-]</label><label class="expand" for="c-37962500">[1 more]</label></div><br/><div class="children"><div class="content">Can you talk about the difference between what you&#x27;re calling explicit parallelism and said textbooks?</div><br/></div></div><div id="37963136" class="c"><input type="checkbox" id="c-37963136" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#37961786">parent</a><span>|</span><a href="#37962500">prev</a><span>|</span><a href="#37962510">next</a><span>|</span><label class="collapse" for="c-37963136">[-]</label><label class="expand" for="c-37963136">[1 more]</label></div><br/><div class="children"><div class="content">Reasoning about parallel execution is hard. You need high level language and library support for that unless you want to spend the rest of your life in tricky debugging territory.</div><br/></div></div><div id="37962510" class="c"><input type="checkbox" id="c-37962510" checked=""/><div class="controls bullet"><span class="by">dmead</span><span>|</span><a href="#37961786">parent</a><span>|</span><a href="#37963136">prev</a><span>|</span><a href="#37963284">next</a><span>|</span><label class="collapse" for="c-37962510">[-]</label><label class="expand" for="c-37962510">[1 more]</label></div><br/><div class="children"><div class="content">Aren&#x27;t we already?</div><br/></div></div><div id="37963284" class="c"><input type="checkbox" id="c-37963284" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#37961786">parent</a><span>|</span><a href="#37962510">prev</a><span>|</span><a href="#37964493">next</a><span>|</span><label class="collapse" for="c-37963284">[-]</label><label class="expand" for="c-37963284">[1 more]</label></div><br/><div class="children"><div class="content">The formalisms for nondeterminism are over half a century old now. This is fundamentally a solved problem, although the typical case analysis technique many programmers tend to prefer falls down hard. Incidentally thatâs why unix signals suck.</div><br/></div></div></div></div><div id="37964493" class="c"><input type="checkbox" id="c-37964493" checked=""/><div class="controls bullet"><span class="by">VagabundoP</span><span>|</span><a href="#37961786">prev</a><span>|</span><a href="#37961562">next</a><span>|</span><label class="collapse" for="c-37964493">[-]</label><label class="expand" for="c-37964493">[3 more]</label></div><br/><div class="children"><div class="content">The shebang issue should probably lean on existing Python conventions:<p>from future import nogil<p>It would hot swap interpreters at that point.</div><br/><div id="37965071" class="c"><input type="checkbox" id="c-37965071" checked=""/><div class="controls bullet"><span class="by">hsfzxjy</span><span>|</span><a href="#37964493">parent</a><span>|</span><a href="#37964793">next</a><span>|</span><label class="collapse" for="c-37965071">[-]</label><label class="expand" for="c-37965071">[1 more]</label></div><br/><div class="children"><div class="content">`from __future__ import ` is a specialized statement to indicate flags rather than a runtime statement.<p><a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;reference&#x2F;simple_stmts.html#future-statements" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;reference&#x2F;simple_stmts.html#future...</a></div><br/></div></div><div id="37964793" class="c"><input type="checkbox" id="c-37964793" checked=""/><div class="controls bullet"><span class="by">ikari_pl</span><span>|</span><a href="#37964493">parent</a><span>|</span><a href="#37965071">prev</a><span>|</span><a href="#37961562">next</a><span>|</span><label class="collapse" for="c-37964793">[-]</label><label class="expand" for="c-37964793">[1 more]</label></div><br/><div class="children"><div class="content">it could be a nightmare to implement if it&#x27;s not the first module, and then the first import, to execute</div><br/></div></div></div></div><div id="37961562" class="c"><input type="checkbox" id="c-37961562" checked=""/><div class="controls bullet"><span class="by">malcolmgreaves</span><span>|</span><a href="#37964493">prev</a><span>|</span><a href="#37961589">next</a><span>|</span><label class="collapse" for="c-37961562">[-]</label><label class="expand" for="c-37961562">[39 more]</label></div><br/><div class="children"><div class="content">I always openly wonder with this proposal â how are they going to do this while making sure programs are still correct? So much existing multithreaded Python code is written in an unsafe manner.<p>Specifically, talking about data races Iâve seen time and again in codebases across companies and OSS projects. The programs donât break <i>only</i> because they implicitly rely on the GIL providing execution to a single thread at a time. If the GIL is gone, then these programs will break. And since Python is such a dynamically typed language, I seriously doubt that there exists a static analyzer that could identify these issues in existing Python programs. More likely, theyâll be insidious bugs that crop up at runtime in a non-deterministic fashion. Ideally leading to a crash, With this class of bugs, itâs likely to just result in incorrect operations being performed.<p>Perhaps this GIL-less proposal isnât actually intended to be used on the overwhelming majority of programs? Maybe itâs just a hyper specialized tool for a very few number of circumstances where the programmer knows, there wonât be a GIL, and can program against that fact?</div><br/><div id="37962755" class="c"><input type="checkbox" id="c-37962755" checked=""/><div class="controls bullet"><span class="by">pdonis</span><span>|</span><a href="#37961562">parent</a><span>|</span><a href="#37961722">next</a><span>|</span><label class="collapse" for="c-37962755">[-]</label><label class="expand" for="c-37962755">[7 more]</label></div><br/><div class="children"><div class="content">If you have a multi-threaded program with data races, you already have a problem. The GIL does not mean no data races are possible. It just means that only one thread at a time can run Python bytecode. But the interpreter with the GIL <i>can</i> switch threads <i>between</i> bytecodes, and many Python operations, including built-in methods on built-in types that many people think of as &quot;atomic&quot;, require multiple bytecodes. That&#x27;s why Python already provides you with things like locks, mutexes, and semaphores, even though it currently has the GIL.</div><br/><div id="37963455" class="c"><input type="checkbox" id="c-37963455" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#37961562">root</a><span>|</span><a href="#37962755">parent</a><span>|</span><a href="#37963666">next</a><span>|</span><label class="collapse" for="c-37963455">[-]</label><label class="expand" for="c-37963455">[4 more]</label></div><br/><div class="children"><div class="content">To put a finer point on this, Iâve had the misunderstanding in the past that the GIL made Python like JavaScript in some sense (only releasing the GIL on some explicit parts of code like sleep). But really Python threads can switch in the âmiddleâ of your code. The reason the GIL is annoying is mostly performance related for Python code itself.<p>My understanding is the GIL does not protect against Python-side bugs, and bugs from GIL removal would only be introduced from C extensions.</div><br/><div id="37963785" class="c"><input type="checkbox" id="c-37963785" checked=""/><div class="controls bullet"><span class="by">wokwokwok</span><span>|</span><a href="#37961562">root</a><span>|</span><a href="#37963455">parent</a><span>|</span><a href="#37963666">next</a><span>|</span><label class="collapse" for="c-37963785">[-]</label><label class="expand" for="c-37963785">[3 more]</label></div><br/><div class="children"><div class="content">? Why do you think this?<p>This has been discussed extensively in the past (1), and my understanding of the take away was that the GIL doesn&#x27;t protect you from arbitrary execution order; it protects you from <i>undefined behavior</i> due to concurrent write&#x2F;read in parallel scopes and the resulting data corruption.<p>...which, as I understand it, there is no specific reason it would be restricted to native extensions.<p>Is there some more detail to the nogil proposal that addresses the type of UB you see in eg. c, with this? (Wouldn&#x27;t that require that at some level the GIL still exists?)<p>[1] - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30420579">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30420579</a></div><br/><div id="37964934" class="c"><input type="checkbox" id="c-37964934" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#37961562">root</a><span>|</span><a href="#37963785">parent</a><span>|</span><a href="#37964589">next</a><span>|</span><label class="collapse" for="c-37964934">[-]</label><label class="expand" for="c-37964934">[1 more]</label></div><br/><div class="children"><div class="content">Youâre right that the GIL prevents bugs on clobbering exactly the same part of memory in Python. But in the GIL world, a C extensions method that doesnât release the GIL and doesnât call into Python has an extra guarantee that it wonât be interrupted at all. This means that in GIL-land, a C extension can have implicit critical sections that stop being so in noGIL land.</div><br/></div></div><div id="37964589" class="c"><input type="checkbox" id="c-37964589" checked=""/><div class="controls bullet"><span class="by">rfoo</span><span>|</span><a href="#37961562">root</a><span>|</span><a href="#37963785">parent</a><span>|</span><a href="#37964934">prev</a><span>|</span><a href="#37963666">next</a><span>|</span><label class="collapse" for="c-37964589">[-]</label><label class="expand" for="c-37964589">[1 more]</label></div><br/><div class="children"><div class="content">What you said is precisely what nogil work is about. It&#x27;s about replacing one global lock with finer grained synchronization primitives without much performance regression.</div><br/></div></div></div></div></div></div><div id="37963666" class="c"><input type="checkbox" id="c-37963666" checked=""/><div class="controls bullet"><span class="by">shrimpx</span><span>|</span><a href="#37961562">root</a><span>|</span><a href="#37962755">parent</a><span>|</span><a href="#37963455">prev</a><span>|</span><a href="#37963899">next</a><span>|</span><label class="collapse" for="c-37963666">[-]</label><label class="expand" for="c-37963666">[1 more]</label></div><br/><div class="children"><div class="content">I think by âdata racesâ the parent means that code doesnât lock around operations like += and len(). The data races are there in theory but do not exhibit due to the GIL.</div><br/></div></div><div id="37963899" class="c"><input type="checkbox" id="c-37963899" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#37961562">root</a><span>|</span><a href="#37962755">parent</a><span>|</span><a href="#37963666">prev</a><span>|</span><a href="#37961722">next</a><span>|</span><label class="collapse" for="c-37963899">[-]</label><label class="expand" for="c-37963899">[1 more]</label></div><br/><div class="children"><div class="content">CPython is not really in a good position to change behaviour in incompatible ways and defend it by language lawyering, users expect the same code to mostly work in a backwards compatible way.</div><br/></div></div></div></div><div id="37961722" class="c"><input type="checkbox" id="c-37961722" checked=""/><div class="controls bullet"><span class="by">KeplerBoy</span><span>|</span><a href="#37961562">parent</a><span>|</span><a href="#37962755">prev</a><span>|</span><a href="#37961636">next</a><span>|</span><label class="collapse" for="c-37961722">[-]</label><label class="expand" for="c-37961722">[2 more]</label></div><br/><div class="children"><div class="content">Just a little fun fact: The GIL absolutely does not prevent all race condition bugs. Threads contending for the GIL can already steal it from each other at unfavorable times and cause havoc.</div><br/><div id="37961854" class="c"><input type="checkbox" id="c-37961854" checked=""/><div class="controls bullet"><span class="by">ynik</span><span>|</span><a href="#37961562">root</a><span>|</span><a href="#37961722">parent</a><span>|</span><a href="#37961636">next</a><span>|</span><label class="collapse" for="c-37961854">[-]</label><label class="expand" for="c-37961854">[1 more]</label></div><br/><div class="children"><div class="content">In fact, it prevents very few race condition bugs.<p>Even inside a C extension where the Python API feels like it gives you control over when you release the GIL (with functions you&#x27;d have to call explicitly to release the GIL), it turns out that:<p>* any operation that allocates new Python objects might trigger garbage collection<p>* garbage collection may run `__del__` of objects completely unrelated to the currently running C code<p>* `__del__` can be implemented in python, thus releasing the GIL between bytecode instructions<p>Thus there&#x27;s a lot of (rarely exercised) potential for concurrency even in C extensions that don&#x27;t explicitly release the GIL themselves. nogil will make it easier to trigger data race bugs, but many of them will already have been theoretically possible before.</div><br/></div></div></div></div><div id="37961636" class="c"><input type="checkbox" id="c-37961636" checked=""/><div class="controls bullet"><span class="by">plonk</span><span>|</span><a href="#37961562">parent</a><span>|</span><a href="#37961722">prev</a><span>|</span><a href="#37961951">next</a><span>|</span><label class="collapse" for="c-37961636">[-]</label><label class="expand" for="c-37961636">[10 more]</label></div><br/><div class="children"><div class="content">I think the point was to let libraries declare whether they support nogil mode (opt-in), and your program would only run with no GIL if all the dependencies allow it? So they have all the time in the world to iron out those bugs.</div><br/><div id="37961933" class="c"><input type="checkbox" id="c-37961933" checked=""/><div class="controls bullet"><span class="by">eptcyka</span><span>|</span><a href="#37961562">root</a><span>|</span><a href="#37961636">parent</a><span>|</span><a href="#37964653">next</a><span>|</span><label class="collapse" for="c-37961933">[-]</label><label class="expand" for="c-37961933">[8 more]</label></div><br/><div class="children"><div class="content">At what point can an interpreter establish that a given python script will not be importing any more modules?</div><br/><div id="37962116" class="c"><input type="checkbox" id="c-37962116" checked=""/><div class="controls bullet"><span class="by">lacker</span><span>|</span><a href="#37961562">root</a><span>|</span><a href="#37961933">parent</a><span>|</span><a href="#37964399">next</a><span>|</span><label class="collapse" for="c-37962116">[-]</label><label class="expand" for="c-37962116">[4 more]</label></div><br/><div class="children"><div class="content">Perhaps it could just fail at runtime if you ever import a module that doesn&#x27;t support nogil mode? AFAICT that&#x27;s how it works if, for example, you run Python code that uses f-strings in a Python version that doesn&#x27;t support f-strings.</div><br/><div id="37962537" class="c"><input type="checkbox" id="c-37962537" checked=""/><div class="controls bullet"><span class="by">tyingq</span><span>|</span><a href="#37961562">root</a><span>|</span><a href="#37962116">parent</a><span>|</span><a href="#37964399">next</a><span>|</span><label class="collapse" for="c-37962537">[-]</label><label class="expand" for="c-37962537">[3 more]</label></div><br/><div class="children"><div class="content">Python&#x27;s support for run-time version&#x2F;flag&#x2F;setting detection isn&#x27;t great for this kind of thing either.  With Perl, for example, you get a BEGIN {} block that is run before it tries to parse the script...so you can detect and shim, etc.<p>Python bombs before you can gain any control, because it parses the whole file. So you can separate things into modules to get around that, but it&#x27;s not great when you want a simple one-file script.</div><br/><div id="37963336" class="c"><input type="checkbox" id="c-37963336" checked=""/><div class="controls bullet"><span class="by">siddheshgunjal</span><span>|</span><a href="#37961562">root</a><span>|</span><a href="#37962537">parent</a><span>|</span><a href="#37964399">next</a><span>|</span><label class="collapse" for="c-37963336">[-]</label><label class="expand" for="c-37963336">[2 more]</label></div><br/><div class="children"><div class="content">We experienced programmers who know how to separate things into modules and use it wisely at the correct place. But most of the beginners and intermediate developers  always tend to do it in a &quot;Everything in single script&quot; manner which might also make it difficult to have more control over the application&#x27;s behaviour.</div><br/><div id="37963398" class="c"><input type="checkbox" id="c-37963398" checked=""/><div class="controls bullet"><span class="by">tyingq</span><span>|</span><a href="#37961562">root</a><span>|</span><a href="#37963336">parent</a><span>|</span><a href="#37964399">next</a><span>|</span><label class="collapse" for="c-37963398">[-]</label><label class="expand" for="c-37963398">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re making a lot of assumptions in a smug sort of way.  There&#x27;s plenty of spots where a single script makes sense, and plenty where it doesn&#x27;t.</div><br/></div></div></div></div></div></div></div></div><div id="37964399" class="c"><input type="checkbox" id="c-37964399" checked=""/><div class="controls bullet"><span class="by">Too</span><span>|</span><a href="#37961562">root</a><span>|</span><a href="#37961933">parent</a><span>|</span><a href="#37962116">prev</a><span>|</span><a href="#37962029">next</a><span>|</span><label class="collapse" for="c-37964399">[-]</label><label class="expand" for="c-37964399">[1 more]</label></div><br/><div class="children"><div class="content">If that is the only way. They need to change some semantics around import statements to not be runtime conditional. (Mypy can do it without running the code so to some extent it is possible). With that in place, each module can at the top declare #nogilsafe and the interpreter can know that no more modules will be loaded runtime. Dynamic imports via importlib will need other consideration.<p>Expecting every transitive module to add this marker is very optimistic though. Itâs thousands of packages with hundreds of modules each, that need to add this everywhere.<p>Other languages have done similar journeys, like typescript âstrictâ added at top of each file. Except those are a lot more local, by not expecting all dependencies to follow.</div><br/></div></div><div id="37962029" class="c"><input type="checkbox" id="c-37962029" checked=""/><div class="controls bullet"><span class="by">Borealid</span><span>|</span><a href="#37961562">root</a><span>|</span><a href="#37961933">parent</a><span>|</span><a href="#37964399">prev</a><span>|</span><a href="#37964653">next</a><span>|</span><label class="collapse" for="c-37962029">[-]</label><label class="expand" for="c-37962029">[2 more]</label></div><br/><div class="children"><div class="content">If you import another module the gil could be re-enabled.<p>Not saying that&#x27;s what they will do, just what they could.</div><br/><div id="37962327" class="c"><input type="checkbox" id="c-37962327" checked=""/><div class="controls bullet"><span class="by">KMag</span><span>|</span><a href="#37961562">root</a><span>|</span><a href="#37962029">parent</a><span>|</span><a href="#37964653">next</a><span>|</span><label class="collapse" for="c-37962327">[-]</label><label class="expand" for="c-37962327">[1 more]</label></div><br/><div class="children"><div class="content">Right.  It would be possible to implement the GIL as a readers-writer lock, where thread state includes a counter for the number of frames in the call stack that are within libraries not marked nogil.  (Let&#x27;s call these non-nogil libraries &quot;GIL-dependent&quot;.)<p>When the count goes from zero to one, the thread attempts to upgrade its reader lock to a writer lock.  When its count goes from one to zero, the thread downgrades its lock from writer to reader.<p>That way, there&#x27;s at most one thread executing within GIL-dependent code at a time.  Furthermore, if there is a thread executing within GIL-dependent code, all of the other threads are blocked waiting to acquire the GIL (in reader mode if they&#x27;re nogil-safe, and writer mode if they&#x27;re GIL-dependent.)<p>As now, any thread holding the GIL in writer mode would need to drop the GIL when attempting to acquire any other lock (and re-acquire immediately afterward).<p>To prevent starvation, one would presumably need a mechanism similar to periodic GC safepoints where nogil-safe threads still check if any thread is waiting to acquire the GIL in writer mode.</div><br/></div></div></div></div></div></div><div id="37964653" class="c"><input type="checkbox" id="c-37964653" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#37961562">root</a><span>|</span><a href="#37961636">parent</a><span>|</span><a href="#37961933">prev</a><span>|</span><a href="#37961951">next</a><span>|</span><label class="collapse" for="c-37964653">[-]</label><label class="expand" for="c-37964653">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but the plan is to remove the opt-in in time. That will put a lot of pressure on the eco system. I expect many libraries written in C or relying on C-based extensions to simply get dropped. Which will make that users will stay on the last GIL-supporting version. It&#x27;s Python 2-&gt;3, but potentially worse.</div><br/></div></div></div></div><div id="37961951" class="c"><input type="checkbox" id="c-37961951" checked=""/><div class="controls bullet"><span class="by">baggiponte</span><span>|</span><a href="#37961562">parent</a><span>|</span><a href="#37961636">prev</a><span>|</span><a href="#37961642">next</a><span>|</span><label class="collapse" for="c-37961951">[-]</label><label class="expand" for="c-37961951">[4 more]</label></div><br/><div class="children"><div class="content">I suppose no-GIL Python will be here in no less than 3&#x2F;4 release cycles. 3.11 has been out for a year and most Python code in prod is what, 3.8? So I guess we wonât have to deal with this at scale before idk 2030 is approaching. I also donât see Python runtimes in prod being updated from whatever theyâre on now to newest releases. I donât want to sound harsh, but the SC stated they donât want to have another 2-to-3 migration, so people wonât update lightly. Yes, most of the content online right now might be dangerous to copy paste</div><br/><div id="37962962" class="c"><input type="checkbox" id="c-37962962" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#37961562">root</a><span>|</span><a href="#37961951">parent</a><span>|</span><a href="#37964002">next</a><span>|</span><label class="collapse" for="c-37962962">[-]</label><label class="expand" for="c-37962962">[1 more]</label></div><br/><div class="children"><div class="content">Tangentially, 3.11 was the first release in quite some time to have major speed improvements across the board. The average is 25%, sometimes far more.<p>Anyone who hasnât upgraded to it by now is needlessly spending extra on compute.</div><br/></div></div><div id="37964002" class="c"><input type="checkbox" id="c-37964002" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#37961562">root</a><span>|</span><a href="#37961951">parent</a><span>|</span><a href="#37962962">prev</a><span>|</span><a href="#37961642">next</a><span>|</span><label class="collapse" for="c-37964002">[-]</label><label class="expand" for="c-37964002">[2 more]</label></div><br/><div class="children"><div class="content">&gt; most Python code in prod is what, 3.8?<p>3.8 is the oldest supported version, so I would hope not, but probably.</div><br/><div id="37965114" class="c"><input type="checkbox" id="c-37965114" checked=""/><div class="controls bullet"><span class="by">scbrg</span><span>|</span><a href="#37961562">root</a><span>|</span><a href="#37964002">parent</a><span>|</span><a href="#37961642">next</a><span>|</span><label class="collapse" for="c-37965114">[-]</label><label class="expand" for="c-37965114">[1 more]</label></div><br/><div class="children"><div class="content">Python versions I have to target (occasionally): 2.5, 2.7, 3.5, 3.8.<p>Not the whole world has the luxury to upgrade all their systems all the time.<p><i>Excuse me, would you mind stopping this factory for a few hours so we can replace this perfectly functioning system with an untested one that may or may not work in roughly the same way?</i> is not a question that is generally met with wild enthusiasm.</div><br/></div></div></div></div></div></div><div id="37961642" class="c"><input type="checkbox" id="c-37961642" checked=""/><div class="controls bullet"><span class="by">bratao</span><span>|</span><a href="#37961562">parent</a><span>|</span><a href="#37961951">prev</a><span>|</span><a href="#37961976">next</a><span>|</span><label class="collapse" for="c-37961642">[-]</label><label class="expand" for="c-37961642">[1 more]</label></div><br/><div class="children"><div class="content">The GIL only protect the Interpreter. The only thing it may do is to make it infrequently. 
There are MANY threading bugs in actual Python code.</div><br/></div></div><div id="37961976" class="c"><input type="checkbox" id="c-37961976" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#37961562">parent</a><span>|</span><a href="#37961642">prev</a><span>|</span><a href="#37963148">next</a><span>|</span><label class="collapse" for="c-37961976">[-]</label><label class="expand" for="c-37961976">[1 more]</label></div><br/><div class="children"><div class="content">On the other hand, perhaps translating existing modules to a No-GIL API is tedious but straightforward, and something that can be done using automated tools (perhaps even LLMs).</div><br/></div></div><div id="37963148" class="c"><input type="checkbox" id="c-37963148" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#37961562">parent</a><span>|</span><a href="#37961976">prev</a><span>|</span><a href="#37963908">next</a><span>|</span><label class="collapse" for="c-37963148">[-]</label><label class="expand" for="c-37963148">[1 more]</label></div><br/><div class="children"><div class="content">The easiest way would be to have the GIL behind a feature flag that defaults to &#x27;on&#x27;. That way you avoid yet another language split and if you don&#x27;t want any possibly breaking changes you simply don&#x27;t do anything at all. But if you want to run with the performance gains that a GIL free CPython would give you then you will have to do some extra testing to make sure that your stuff really is bullet proof with that flag set to the &#x27;No-GIL&#x27; position.</div><br/></div></div><div id="37963908" class="c"><input type="checkbox" id="c-37963908" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#37961562">parent</a><span>|</span><a href="#37963148">prev</a><span>|</span><a href="#37962463">next</a><span>|</span><label class="collapse" for="c-37963908">[-]</label><label class="expand" for="c-37963908">[1 more]</label></div><br/><div class="children"><div class="content">Good points. Re analyzability - it wouldn&#x27;t have to be static analysis to be useful, you could do this with dynamic analysis.</div><br/></div></div><div id="37962463" class="c"><input type="checkbox" id="c-37962463" checked=""/><div class="controls bullet"><span class="by">mkoubaa</span><span>|</span><a href="#37961562">parent</a><span>|</span><a href="#37963908">prev</a><span>|</span><a href="#37962027">next</a><span>|</span><label class="collapse" for="c-37962463">[-]</label><label class="expand" for="c-37962463">[1 more]</label></div><br/><div class="children"><div class="content">Even with nogil, libraries can explicitly hold a global lock before any call. They just don&#x27;t have to. I imagine some libraries will do that, and others will target performance. Users will vote with their tomls</div><br/></div></div><div id="37962027" class="c"><input type="checkbox" id="c-37962027" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#37961562">parent</a><span>|</span><a href="#37962463">prev</a><span>|</span><a href="#37961960">next</a><span>|</span><label class="collapse" for="c-37962027">[-]</label><label class="expand" for="c-37962027">[6 more]</label></div><br/><div class="children"><div class="content">There is a very simple practical solution: let the GIL (or something like it that forces single-threaded execution) be an option that you can turn on so that you can run broken legacy code.</div><br/><div id="37962472" class="c"><input type="checkbox" id="c-37962472" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#37961562">root</a><span>|</span><a href="#37962027">parent</a><span>|</span><a href="#37962124">next</a><span>|</span><label class="collapse" for="c-37962472">[-]</label><label class="expand" for="c-37962472">[2 more]</label></div><br/><div class="children"><div class="content">This is, effectively, the plan for the next few Python releases. The plan is for a no-GIL and a GIL execution mode with GIL being the default. At some point, IIRC, the plan is to swap the default and then to eliminate the GIL option.</div><br/><div id="37964694" class="c"><input type="checkbox" id="c-37964694" checked=""/><div class="controls bullet"><span class="by">LtWorf</span><span>|</span><a href="#37961562">root</a><span>|</span><a href="#37962472">parent</a><span>|</span><a href="#37962124">next</a><span>|</span><label class="collapse" for="c-37964694">[-]</label><label class="expand" for="c-37964694">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;d make sense if pypi wasn&#x27;t full of abandoned libraries that nobody can reclaim to update.</div><br/></div></div></div></div><div id="37962124" class="c"><input type="checkbox" id="c-37962124" checked=""/><div class="controls bullet"><span class="by">colordrops</span><span>|</span><a href="#37961562">root</a><span>|</span><a href="#37962027">parent</a><span>|</span><a href="#37962472">prev</a><span>|</span><a href="#37961960">next</a><span>|</span><label class="collapse" for="c-37962124">[-]</label><label class="expand" for="c-37962124">[3 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t the most practical solution be for a script or module to turn it off instead? Then you don&#x27;t break any legacy code. Anyone writing code that is meant to work without the GIL would know to turn it off.</div><br/><div id="37962492" class="c"><input type="checkbox" id="c-37962492" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#37961562">root</a><span>|</span><a href="#37962124">parent</a><span>|</span><a href="#37961960">next</a><span>|</span><label class="collapse" for="c-37962492">[-]</label><label class="expand" for="c-37962492">[2 more]</label></div><br/><div class="children"><div class="content">Sure, whatever.  The point is that breaking legacy code doesn&#x27;t have to be a show-stopper for eliminating the GIL, and backwards-compatibility does not have to be (indeed should not be) an overriding consideration in a GIL-free Python.</div><br/><div id="37962758" class="c"><input type="checkbox" id="c-37962758" checked=""/><div class="controls bullet"><span class="by">colordrops</span><span>|</span><a href="#37961562">root</a><span>|</span><a href="#37962492">parent</a><span>|</span><a href="#37961960">next</a><span>|</span><label class="collapse" for="c-37962758">[-]</label><label class="expand" for="c-37962758">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the rationale? Making it opt-in avoids breaking legacy code, which is a huge advantage. What&#x27;s the caae making it opt-out?</div><br/></div></div></div></div></div></div></div></div><div id="37961960" class="c"><input type="checkbox" id="c-37961960" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#37961562">parent</a><span>|</span><a href="#37962027">prev</a><span>|</span><a href="#37961645">next</a><span>|</span><label class="collapse" for="c-37961960">[-]</label><label class="expand" for="c-37961960">[1 more]</label></div><br/><div class="children"><div class="content">I imagine the way to do this is to start Python with some flag saying that it&#x27;s in no-GIL mode. That way it&#x27;s up to the user to decide if their libraries can handle it.</div><br/></div></div><div id="37963463" class="c"><input type="checkbox" id="c-37963463" checked=""/><div class="controls bullet"><span class="by">perryizgr8</span><span>|</span><a href="#37961562">parent</a><span>|</span><a href="#37961645">prev</a><span>|</span><a href="#37962362">next</a><span>|</span><label class="collapse" for="c-37963463">[-]</label><label class="expand" for="c-37963463">[1 more]</label></div><br/><div class="children"><div class="content">&gt; So much existing multithreaded Python code is written in an unsafe manner.<p>Even multi-process Python code is often broken. The &quot;recommended&quot; way to serve a Django app is to run multiple workers (processes) using gunicorn. If you point the default logs to a file, even with log rotation enabled, all workers will keep stepping over each other because nobody knows which file to use. Keep in mind that this is broken by default, and this is the recommended way to use all this.</div><br/></div></div></div></div><div id="37961589" class="c"><input type="checkbox" id="c-37961589" checked=""/><div class="controls bullet"><span class="by">yodsanklai</span><span>|</span><a href="#37961562">prev</a><span>|</span><a href="#37961815">next</a><span>|</span><label class="collapse" for="c-37961589">[-]</label><label class="expand" for="c-37961589">[2 more]</label></div><br/><div class="children"><div class="content">Didn&#x27;t OCaml undergo a similar evolution? is there anything comparable between these two projects?</div><br/><div id="37961737" class="c"><input type="checkbox" id="c-37961737" checked=""/><div class="controls bullet"><span class="by">debugnik</span><span>|</span><a href="#37961589">parent</a><span>|</span><a href="#37961815">next</a><span>|</span><label class="collapse" for="c-37961737">[-]</label><label class="expand" for="c-37961737">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think so. Rather than removing the global lock and breaking existing code, OCaml 5 introduces a new primitive called a &quot;domain&quot; which manages one or more threads with a shared lock.<p>So the existing threads API spawns threads in the current domain, which lets you isolate code that expects to take the lock, while new code can spawn new domains starting with one thread instead. You can also use both deliberately as a form of scheduling.<p>Python instead is trying to make the lock entirely optional, globally and outside the control of library writers. However, I think the Python lock is only guaranteed to protect the runtime itself, so most code depending on it is probably buggy anyway, so I think their plan is viable.<p>The only thing they may have in common is having to scan the entire codebase of their runtimes for unexpected shared state and fix that, as well as revising their C ABIs.</div><br/></div></div></div></div><div id="37961815" class="c"><input type="checkbox" id="c-37961815" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#37961589">prev</a><span>|</span><a href="#37961349">next</a><span>|</span><label class="collapse" for="c-37961815">[-]</label><label class="expand" for="c-37961815">[1 more]</label></div><br/><div class="children"><div class="content">Use -ng (no-gil or next-generation).</div><br/></div></div><div id="37961349" class="c"><input type="checkbox" id="c-37961349" checked=""/><div class="controls bullet"><span class="by">qeternity</span><span>|</span><a href="#37961815">prev</a><span>|</span><a href="#37963934">next</a><span>|</span><label class="collapse" for="c-37961349">[-]</label><label class="expand" for="c-37961349">[46 more]</label></div><br/><div class="children"><div class="content">I find the current focus on GIL-less Python really strange. The Faster cPython team set an ambitious goal of increasing cPython performance 50% with each release. 3.11 contained some real improvements, but nowhere near 50%. And for much of our testing, 3.12 is either flat or slower. True multi-threading would be great, but I would much rather have improved single threaded performance first.<p>I of course respect that our needs may not represent everyone else&#x27;s, and we are grateful for all the work that has gone into making Python a great language. But what am I missing?</div><br/><div id="37961509" class="c"><input type="checkbox" id="c-37961509" checked=""/><div class="controls bullet"><span class="by">bratao</span><span>|</span><a href="#37961349">parent</a><span>|</span><a href="#37961760">next</a><span>|</span><label class="collapse" for="c-37961509">[-]</label><label class="expand" for="c-37961509">[22 more]</label></div><br/><div class="children"><div class="content">In my opinion, Python needs to have an urgent answer to the use of multiple cores. AMD just launched a CPU with 96 cores. Today the use on multiple cores is through the use multiprocess, which has many limitations. I understand that the multiple interpreters could come with something like Goroutines, but I still like the real multi thread option more.</div><br/><div id="37961756" class="c"><input type="checkbox" id="c-37961756" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37961509">parent</a><span>|</span><a href="#37964676">next</a><span>|</span><label class="collapse" for="c-37961756">[-]</label><label class="expand" for="c-37961756">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve changed my opinion about this after many years.<p>A long time ago IronPython was released which showed that you could build a high performance Python interpreter that was GIL-free.  It had thread-safe containers (so multiple threads could work against the same lists, dictionaries, etc) and in some cases was faster than CPython (it was implemented using CLR and .net)<p>When I saw IronPython I was immediately convinced that CPython should be the same way- already low-cost dual and quad core Intel machines were becoming available and it seemed like core counts were going to increase faster than clock rates.  I figured that a small hit to serial performance would be more than acceptable if people could write multithreaded systems in Python, in much the same way as I wrote multithreaded C++.<p>Over time after watching nogil not going anywhere in CPython (the python leadership didn&#x27;t want to do nogil), with concomitant speedups in the single-processor implementation, along with the increasing use of C++ code that releases the GIL, and seeing that many people just weren&#x27;t good at multithreaded programming, I have started to conclude that the multithreading&#x2F;multiprocess in Python today is about the best we can get.  That is, instead of having threaded containers and multiple interpreter threads all banging on the same underlying data, it&#x27;s a lot easier to just use threads as work queues that have minimal interaction with other threads.<p>So that&#x27;s where I&#x27;ve ended up: some of my code using multiprocessing, typically the Pool or ThreadPool, with the concurrent future API to handle result-gathering, barriers, etc.  Other code has an external system that starts many python <i>processes</i> from the command line and waits for those processes to complete.  Other code is single-threaded in python and launches C++ cores that launch  multiple threads just to return a computational result to python faster.<p>And I think trying to do both gil and nogil interpreters, rather than committing to one or the other, the python leadership will sign us up for untold inconveniences around packaging.  We already see this in the move to async and it will only be worse with threading.<p>So sad to say I think sticking to GIL and using the approaches I mentioned above (along with others that work well for concurrent, rather than parallel, computing, like coroutines) is the best thing to do right now and I&#x27;m a bit bummed that the leadership signalled their intent to accomodate both.</div><br/><div id="37961785" class="c"><input type="checkbox" id="c-37961785" checked=""/><div class="controls bullet"><span class="by">alfalfasprout</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37961756">parent</a><span>|</span><a href="#37962511">next</a><span>|</span><label class="collapse" for="c-37961785">[-]</label><label class="expand" for="c-37961785">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;ve been able to release GIL for a long time though in the C ABI (and C++ via pybind) and that hasn&#x27;t removed the need for nogil.<p>The reason is that a single thread can invoke multicore c&#x2F;c++ code (even calling into specialized accelerators if needed) but having python objects that are shared between threads is extremely clunky. And multiprocessing results in a lot of communication overhead. Worse-- python code cannot proceed in another thread. Mixing python and C++ is very common in ML and scientific computing workloads.<p>&gt; And I think trying to do both gil and nogil interpreters, rather than committing to one or the other, the python leadership will sign us up for untold inconveniences around packaging. We already see this in the move to async and it will only be worse with threading.<p>How has packaging been affected by async? As long as you have a compatible python version what issue do you run into?</div><br/><div id="37962302" class="c"><input type="checkbox" id="c-37962302" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37961785">parent</a><span>|</span><a href="#37962511">next</a><span>|</span><label class="collapse" for="c-37962302">[-]</label><label class="expand" for="c-37962302">[1 more]</label></div><br/><div class="children"><div class="content">boto&#x27;s migration to async has caused no end of package incompatibility problems for me.  So that&#x27;s really more on the aiobotocore developers than python in that case.  
<a href="https:&#x2F;&#x2F;github.com&#x2F;aio-libs&#x2F;aiobotocore&#x2F;issues&#x2F;890">https:&#x2F;&#x2F;github.com&#x2F;aio-libs&#x2F;aiobotocore&#x2F;issues&#x2F;890</a>
OK not a great example but also not worth debating about.</div><br/></div></div></div></div><div id="37962511" class="c"><input type="checkbox" id="c-37962511" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37961756">parent</a><span>|</span><a href="#37961785">prev</a><span>|</span><a href="#37962813">next</a><span>|</span><label class="collapse" for="c-37962511">[-]</label><label class="expand" for="c-37962511">[1 more]</label></div><br/><div class="children"><div class="content">I think this is an interesting take, and it think people should think about their use of Python in general.<p>I personally think that pythons support for the massively parallel hardware we have is lacking, and the devs are being too slow and disparate to respond, combine that with what is basically subpar tooling around threads and you have people reaching for multiprocessing out of necessity.<p>Off the back of this, should Python just maybe give up on threads entirely? Should it relegate itself to simple-scripting and open the floor to something that <i>can</i> do these things?<p>Iâve personally stopped writing Python for these reasons- apart from âAI stuffâ which isnât something I dabble in anymore, thereâs nothing that Python can do anymore that another language canât do better, just as (if not more) easily, without giving anything up.</div><br/></div></div><div id="37962813" class="c"><input type="checkbox" id="c-37962813" checked=""/><div class="controls bullet"><span class="by">lagt_t</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37961756">parent</a><span>|</span><a href="#37962511">prev</a><span>|</span><a href="#37964676">next</a><span>|</span><label class="collapse" for="c-37962813">[-]</label><label class="expand" for="c-37962813">[3 more]</label></div><br/><div class="children"><div class="content">Optional Gil was originally discussed in 2022, PEPd in early 2023 and approved for 3.13, What do you mean going nowhere or that leadership didn&#x27;t want it?</div><br/><div id="37963225" class="c"><input type="checkbox" id="c-37963225" checked=""/><div class="controls bullet"><span class="by">akubera</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37962813">parent</a><span>|</span><a href="#37963412">next</a><span>|</span><label class="collapse" for="c-37963225">[-]</label><label class="expand" for="c-37963225">[1 more]</label></div><br/><div class="children"><div class="content">I think dekhn means the discussions and attempts at removing the GIL before this current PEP. Here&#x27;s Guido&#x27;s thoughts on it from 2007: <a href="https:&#x2F;&#x2F;www.artima.com&#x2F;weblogs&#x2F;viewpost.jsp?thread=214235" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.artima.com&#x2F;weblogs&#x2F;viewpost.jsp?thread=214235</a> and that mentions a fork removing the GIL for Python 1.5 in 1999.</div><br/></div></div><div id="37963412" class="c"><input type="checkbox" id="c-37963412" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37962813">parent</a><span>|</span><a href="#37963225">prev</a><span>|</span><a href="#37964676">next</a><span>|</span><label class="collapse" for="c-37963412">[-]</label><label class="expand" for="c-37963412">[1 more]</label></div><br/><div class="children"><div class="content">Originally?</div><br/></div></div></div></div></div></div><div id="37964676" class="c"><input type="checkbox" id="c-37964676" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37961509">parent</a><span>|</span><a href="#37961756">prev</a><span>|</span><a href="#37963966">next</a><span>|</span><label class="collapse" for="c-37964676">[-]</label><label class="expand" for="c-37964676">[1 more]</label></div><br/><div class="children"><div class="content">How about not using Python when you need performance? That 50% performance increase sounds nice, but it&#x27;s still slow.</div><br/></div></div><div id="37963966" class="c"><input type="checkbox" id="c-37963966" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37961509">parent</a><span>|</span><a href="#37964676">prev</a><span>|</span><a href="#37964019">next</a><span>|</span><label class="collapse" for="c-37963966">[-]</label><label class="expand" for="c-37963966">[2 more]</label></div><br/><div class="children"><div class="content">Threads + locks style heisenbug prone low-level programming is one possible avenue towards exploiting this, but its&#x27; notoriously difficult and a bad fit for Python&#x27;s user base. Also,  most parallelism is found on the GPU platforms.<p>The alternative road is to figure out how Python could automatically  exploit parallelism in the underlying hardware, possibly in a way that would let it work on GPUs as well. The SIMT data-parallel way (seen in eg in ISPC, OpenCL, shader languages) is also more programmer friendly as it doesn&#x27;t require the constant use of error probe synchronisation primitives. Or other HLL approaches in Jax, Futhark, etc.</div><br/><div id="37964451" class="c"><input type="checkbox" id="c-37964451" checked=""/><div class="controls bullet"><span class="by">Too</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37963966">parent</a><span>|</span><a href="#37964019">next</a><span>|</span><label class="collapse" for="c-37964451">[-]</label><label class="expand" for="c-37964451">[1 more]</label></div><br/><div class="children"><div class="content">This is the goal of Mojo. Take existing Python code and compile it to the gpu.</div><br/></div></div></div></div><div id="37964019" class="c"><input type="checkbox" id="c-37964019" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37961509">parent</a><span>|</span><a href="#37963966">prev</a><span>|</span><a href="#37964011">next</a><span>|</span><label class="collapse" for="c-37964019">[-]</label><label class="expand" for="c-37964019">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In my opinion, Python needs to have an urgent answer to the use of multiple cores.<p>Subinterpreters are an answer (heck, so is multiprocessing).<p>Whether between them they are enough for Python&#x27;s domains is another question. Probably not for the long term, but possibly for the neart term. But anything more is going to be a big lift, no-GIL is the obvious broader answer, so its good its being worked on, because by the time its betond question that its needed, itâll be too late to start working in earnest.</div><br/></div></div><div id="37964011" class="c"><input type="checkbox" id="c-37964011" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37961509">parent</a><span>|</span><a href="#37964019">prev</a><span>|</span><a href="#37962289">next</a><span>|</span><label class="collapse" for="c-37964011">[-]</label><label class="expand" for="c-37964011">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Python needs to have an urgent answer to the use of multiple cores<p><a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;multiprocessing.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;multiprocessing.html</a></div><br/></div></div><div id="37962289" class="c"><input type="checkbox" id="c-37962289" checked=""/><div class="controls bullet"><span class="by">jshen</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37961509">parent</a><span>|</span><a href="#37964011">prev</a><span>|</span><a href="#37961720">next</a><span>|</span><label class="collapse" for="c-37962289">[-]</label><label class="expand" for="c-37962289">[2 more]</label></div><br/><div class="children"><div class="content">Why? What are the use cases? I honestly can&#x27;t think of any. If you are making a web app, you can use those cores just fine. If you are doing ML you will be calling into native code which can also do it just fine. If you are trying to make a AAA game, you shouldn&#x27;t use python, etc.<p>Not sure what the use case is.</div><br/><div id="37962601" class="c"><input type="checkbox" id="c-37962601" checked=""/><div class="controls bullet"><span class="by">cpgxiii</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37962289">parent</a><span>|</span><a href="#37961720">next</a><span>|</span><label class="collapse" for="c-37962601">[-]</label><label class="expand" for="c-37962601">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you are doing ML you will be calling into native code which can also do it just fine.<p>This is exactly the use case. You can only parallelize in the native code if the boundary between Python and native code is absolute. But in practice people really do want to pass callbacks into the native code, inherit from native code interfaces in Python, even something as simple as forwarding the logging in their native code back to Python logging (e.g. all of the really useful behavior possible with binding tools like pybind11). All of these are impossible to parallelize effectively today.</div><br/></div></div></div></div><div id="37961720" class="c"><input type="checkbox" id="c-37961720" checked=""/><div class="controls bullet"><span class="by">brianwawok</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37961509">parent</a><span>|</span><a href="#37962289">prev</a><span>|</span><a href="#37961760">next</a><span>|</span><label class="collapse" for="c-37961720">[-]</label><label class="expand" for="c-37961720">[7 more]</label></div><br/><div class="children"><div class="content">My server can easily fill all 96 running standard Python under gunicorn.</div><br/><div id="37962282" class="c"><input type="checkbox" id="c-37962282" checked=""/><div class="controls bullet"><span class="by">b5n</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37961720">parent</a><span>|</span><a href="#37961929">next</a><span>|</span><label class="collapse" for="c-37962282">[-]</label><label class="expand" for="c-37962282">[1 more]</label></div><br/><div class="children"><div class="content">Even simpler:<p><pre><code>  parallel -j96 &#x27;python -c &quot;print(&#x27;{}&#x27;)&quot;&#x27; ::: $(for i in {1..96};do echo $i;done)</code></pre></div><br/></div></div><div id="37961929" class="c"><input type="checkbox" id="c-37961929" checked=""/><div class="controls bullet"><span class="by">iterateoften</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37961720">parent</a><span>|</span><a href="#37962282">prev</a><span>|</span><a href="#37961821">next</a><span>|</span><label class="collapse" for="c-37961929">[-]</label><label class="expand" for="c-37961929">[4 more]</label></div><br/><div class="children"><div class="content">gunicorn uses multiple processes</div><br/><div id="37962621" class="c"><input type="checkbox" id="c-37962621" checked=""/><div class="controls bullet"><span class="by">aeyes</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37961929">parent</a><span>|</span><a href="#37961821">next</a><span>|</span><label class="collapse" for="c-37962621">[-]</label><label class="expand" for="c-37962621">[3 more]</label></div><br/><div class="children"><div class="content">You can still share most of the memory if you load everything before the fork so why is having multiple processes a problem?</div><br/><div id="37965120" class="c"><input type="checkbox" id="c-37965120" checked=""/><div class="controls bullet"><span class="by">skrause</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37962621">parent</a><span>|</span><a href="#37963474">next</a><span>|</span><label class="collapse" for="c-37965120">[-]</label><label class="expand" for="c-37965120">[1 more]</label></div><br/><div class="children"><div class="content">One operating system I have to deploy on (Windows) has neither fork() nor gunicorn.</div><br/></div></div><div id="37963474" class="c"><input type="checkbox" id="c-37963474" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37962621">parent</a><span>|</span><a href="#37965120">prev</a><span>|</span><a href="#37961821">next</a><span>|</span><label class="collapse" for="c-37963474">[-]</label><label class="expand" for="c-37963474">[1 more]</label></div><br/><div class="children"><div class="content">Ive found in practice that memory sharing doesnât work as much as one would want, and multiple processes cost hundreds of megs (annoying!)</div><br/></div></div></div></div></div></div><div id="37961821" class="c"><input type="checkbox" id="c-37961821" checked=""/><div class="controls bullet"><span class="by">NegativeLatency</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37961720">parent</a><span>|</span><a href="#37961929">prev</a><span>|</span><a href="#37961760">next</a><span>|</span><label class="collapse" for="c-37961821">[-]</label><label class="expand" for="c-37961821">[1 more]</label></div><br/><div class="children"><div class="content">and if you use and async framework it&#x27;s even more capable</div><br/></div></div></div></div></div></div><div id="37961760" class="c"><input type="checkbox" id="c-37961760" checked=""/><div class="controls bullet"><span class="by">alfalfasprout</span><span>|</span><a href="#37961349">parent</a><span>|</span><a href="#37961509">prev</a><span>|</span><a href="#37961608">next</a><span>|</span><label class="collapse" for="c-37961760">[-]</label><label class="expand" for="c-37961760">[1 more]</label></div><br/><div class="children"><div class="content">They&#x27;re completely different goals. Yeah in theory multithreaded python lets you speed up certain programs... but the way in which it does so is important.<p>With nogil python you can effectively have multiple threads that eg; call out to C code while having shared state accessible as python objects. This is pretty key for ML-- in fact this current incarnation of the PEP came from the PyTorch team.<p>Single threaded performance is important too but there have already been lots of decent workarounds for critical sections (eg; numba, Cython, and now things like Mojo).<p>The ordering is important too-- a lot of the faster cpython work would be thrown away completely if nogil came about. So the teams have had to coordinate.<p>In the ideal world that means both nogil mode + improvements to single threaded performance (Guido even hinted sophisticated JITing is being considered).</div><br/></div></div><div id="37961608" class="c"><input type="checkbox" id="c-37961608" checked=""/><div class="controls bullet"><span class="by">euiq</span><span>|</span><a href="#37961349">parent</a><span>|</span><a href="#37961760">prev</a><span>|</span><a href="#37961427">next</a><span>|</span><label class="collapse" for="c-37961608">[-]</label><label class="expand" for="c-37961608">[1 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;re missing that your needs are different from those of the people quoted in PEP 703: &lt;<a href="https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0703&#x2F;#motivation" rel="nofollow noreferrer">https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0703&#x2F;#motivation</a>&gt;</div><br/></div></div><div id="37961427" class="c"><input type="checkbox" id="c-37961427" checked=""/><div class="controls bullet"><span class="by">benrutter</span><span>|</span><a href="#37961349">parent</a><span>|</span><a href="#37961608">prev</a><span>|</span><a href="#37961455">next</a><span>|</span><label class="collapse" for="c-37961427">[-]</label><label class="expand" for="c-37961427">[13 more]</label></div><br/><div class="children"><div class="content">My understanding is they are two seperate projects within cpython and don&#x27;t necessarily have the same people working on them.<p>I agree with you that if it was one or the other, most use cases are gonna be better met with straight up faster single threaded code. But why not have both?</div><br/><div id="37961460" class="c"><input type="checkbox" id="c-37961460" checked=""/><div class="controls bullet"><span class="by">slashdev</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37961427">parent</a><span>|</span><a href="#37961455">next</a><span>|</span><label class="collapse" for="c-37961460">[-]</label><label class="expand" for="c-37961460">[12 more]</label></div><br/><div class="children"><div class="content">Both is not really on the table. Getting rid of the Gil will slow down single threaded code.</div><br/><div id="37961545" class="c"><input type="checkbox" id="c-37961545" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37961460">parent</a><span>|</span><a href="#37961813">next</a><span>|</span><label class="collapse" for="c-37961545">[-]</label><label class="expand" for="c-37961545">[2 more]</label></div><br/><div class="children"><div class="content">The last numbers I saw put the performance penalty of no-GIL at under 10%, so both are still on the table since Python has a <i>lot</i> of single-threaded performance left to recover. You can get both a much faster-than-current Python in single-threaded and real threads.</div><br/><div id="37961823" class="c"><input type="checkbox" id="c-37961823" checked=""/><div class="controls bullet"><span class="by">alfalfasprout</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37961545">parent</a><span>|</span><a href="#37961813">next</a><span>|</span><label class="collapse" for="c-37961823">[-]</label><label class="expand" for="c-37961823">[1 more]</label></div><br/><div class="children"><div class="content">Yep and when the faster cpython team gets to implementing advanced JITing (which GVR has said is planned) that&#x27;ll be huge.</div><br/></div></div></div></div><div id="37961813" class="c"><input type="checkbox" id="c-37961813" checked=""/><div class="controls bullet"><span class="by">alfalfasprout</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37961460">parent</a><span>|</span><a href="#37961545">prev</a><span>|</span><a href="#37961505">next</a><span>|</span><label class="collapse" for="c-37961813">[-]</label><label class="expand" for="c-37961813">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Both is not really on the table
Incorrect.
&gt; Getting rid of the Gil will slow down single threaded code
Correct.<p>But that&#x27;s before fastercpython improves single threaded performance closing that gap if not reversing it.</div><br/></div></div><div id="37961505" class="c"><input type="checkbox" id="c-37961505" checked=""/><div class="controls bullet"><span class="by">rowanG077</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37961460">parent</a><span>|</span><a href="#37961813">prev</a><span>|</span><a href="#37961455">next</a><span>|</span><label class="collapse" for="c-37961505">[-]</label><label class="expand" for="c-37961505">[8 more]</label></div><br/><div class="children"><div class="content">Why would removing the GIL slow down single threaded code?</div><br/><div id="37961628" class="c"><input type="checkbox" id="c-37961628" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37961505">parent</a><span>|</span><a href="#37961591">next</a><span>|</span><label class="collapse" for="c-37961628">[-]</label><label class="expand" for="c-37961628">[4 more]</label></div><br/><div class="children"><div class="content">No-GIL forces the addition of locks and other concurrency controls into the execution path of single-threaded code that&#x27;s not there now. It&#x27;s the same kind of hit you get going from thread-unsafe code (hopefully intended for single-threaded execution) to thread-safe in any other project (since, well, it&#x27;s the same; the GIL means they could write code with single-threaded assumptions). Checking and taking locks is not a free action.</div><br/><div id="37962091" class="c"><input type="checkbox" id="c-37962091" checked=""/><div class="controls bullet"><span class="by">rowanG077</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37961628">parent</a><span>|</span><a href="#37961591">next</a><span>|</span><label class="collapse" for="c-37962091">[-]</label><label class="expand" for="c-37962091">[3 more]</label></div><br/><div class="children"><div class="content">I thought the point of No-GIL was to force users of python to provide proper locking.</div><br/><div id="37962440" class="c"><input type="checkbox" id="c-37962440" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37962091">parent</a><span>|</span><a href="#37963090">next</a><span>|</span><label class="collapse" for="c-37962440">[-]</label><label class="expand" for="c-37962440">[1 more]</label></div><br/><div class="children"><div class="content">To <i>achieve</i> no-GIL, libraries and extensions along with the underlying language implementation will need to add in the proper locking.<p>For <i>users</i>, it&#x27;ll be mixed. Users writing single-threaded code shouldn&#x27;t have to change a single line of code, but they&#x27;ll see (sans the concurrent efforts to speed up the underlying implementation) slower performance due to everything done to achieve no-GIL (the actual net effect will be a performance boost due to that concurrent effort over time). If they&#x27;re writing multi-threaded code, then they should be writing it to be threadsafe now, not assuming that the GIL will protect them (because it doesn&#x27;t guarantee it now anyways). So nothing should actually change for most users of Python if they&#x27;re writing correct code today.</div><br/></div></div><div id="37963090" class="c"><input type="checkbox" id="c-37963090" checked=""/><div class="controls bullet"><span class="by">kortex</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37962091">parent</a><span>|</span><a href="#37962440">prev</a><span>|</span><a href="#37961591">next</a><span>|</span><label class="collapse" for="c-37963090">[-]</label><label class="expand" for="c-37963090">[1 more]</label></div><br/><div class="children"><div class="content">Python&#x27;s reference counting garbage collector would also need concurrency controls.</div><br/></div></div></div></div></div></div><div id="37961591" class="c"><input type="checkbox" id="c-37961591" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37961505">parent</a><span>|</span><a href="#37961628">prev</a><span>|</span><a href="#37961619">next</a><span>|</span><label class="collapse" for="c-37961591">[-]</label><label class="expand" for="c-37961591">[1 more]</label></div><br/><div class="children"><div class="content">You still need to run the same memory management&#x2F;accounting for all the objects as when you run multithreaded, because at any point a new thread may be started. And it takes more time to make all MT access safe then to prevent other threads from running.</div><br/></div></div><div id="37961619" class="c"><input type="checkbox" id="c-37961619" checked=""/><div class="controls bullet"><span class="by">Austizzle</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37961505">parent</a><span>|</span><a href="#37961591">prev</a><span>|</span><a href="#37961554">next</a><span>|</span><label class="collapse" for="c-37961619">[-]</label><label class="expand" for="c-37961619">[1 more]</label></div><br/><div class="children"><div class="content">As far as I know, in order to make everything thread safe in the same way the gil did, they need to add locks in a lot of places to make sure that no two objects can be modified at the same time. Adding those locks will slow down execution</div><br/></div></div><div id="37961554" class="c"><input type="checkbox" id="c-37961554" checked=""/><div class="controls bullet"><span class="by">edgyquant</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37961505">parent</a><span>|</span><a href="#37961619">prev</a><span>|</span><a href="#37961455">next</a><span>|</span><label class="collapse" for="c-37961554">[-]</label><label class="expand" for="c-37961554">[1 more]</label></div><br/><div class="children"><div class="content">I believe without a GIL objects need to be thread safe which comes at a price</div><br/></div></div></div></div></div></div></div></div><div id="37961455" class="c"><input type="checkbox" id="c-37961455" checked=""/><div class="controls bullet"><span class="by">softwaredoug</span><span>|</span><a href="#37961349">parent</a><span>|</span><a href="#37961427">prev</a><span>|</span><a href="#37961690">next</a><span>|</span><label class="collapse" for="c-37961455">[-]</label><label class="expand" for="c-37961455">[6 more]</label></div><br/><div class="children"><div class="content">The computationally expensive parts of âPythonâ are done in libraries like numpy, tensorflow, etc. Python makes it really handy to play with low level abstractions in a higher level language.<p>So yeah Iâve never stressed much about the GIL as a long time pythons dev</div><br/><div id="37962342" class="c"><input type="checkbox" id="c-37962342" checked=""/><div class="controls bullet"><span class="by">mardifoufs</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37961455">parent</a><span>|</span><a href="#37961646">next</a><span>|</span><label class="collapse" for="c-37962342">[-]</label><label class="expand" for="c-37962342">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The computationally expensive parts of âPythonâ are done in libraries like numpy, tensorflow, etc. Python makes it really handy to play with low level abstractions in a higher level language.<p>&gt; So yeah Iâve never stressed much about the GIL as a long time pythons dev<p>You almost always have to use python objects at some point or another, even with very high perf libraries. Unless you are using python as nothing else than glue code, and loading and preprocessing the data entirely outside of your python code. At some point (and I&#x27;m not talking about extreme scales here, just feeding a single datqaloader can be enough) you hit a very hard performance bottleneck. Sure you can just use more external code at that point but I think the intention is to make python at least more suitable for the non compute intensive stuff.<p>Like, it is already suitable right now but it&#x27;s not getting better, while everything around it is (I&#x27;m not talking about other languages, what I mean is that the tools and libraries are getting better so without improvement to the language the bottleneck will just get worse)</div><br/></div></div><div id="37961646" class="c"><input type="checkbox" id="c-37961646" checked=""/><div class="controls bullet"><span class="by">jhj</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37961455">parent</a><span>|</span><a href="#37962342">prev</a><span>|</span><a href="#37965051">next</a><span>|</span><label class="collapse" for="c-37961646">[-]</label><label class="expand" for="c-37961646">[1 more]</label></div><br/><div class="children"><div class="content">Yes but coordinating the computationally expensive parts usually needs to be done across multiple CPU threads. Typically one should feed each GPU from a different CPU thread, even in native C&#x2F;C++ land, as in many cases the kernels being run on the GPU may not be entirely heavy compute but instead on the order of the kernel launch overhead from the host (1-4 us); not every kernel run would be orders of magnitude longer runtime than the overheads involved. Data loaders and other non-computationally expensive parts (I&#x2F;O latency or throughput bound things) need to be done as well, which make sense to multi-thread as well.</div><br/></div></div><div id="37965051" class="c"><input type="checkbox" id="c-37965051" checked=""/><div class="controls bullet"><span class="by">kzrdude</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37961455">parent</a><span>|</span><a href="#37961646">prev</a><span>|</span><a href="#37962332">next</a><span>|</span><label class="collapse" for="c-37965051">[-]</label><label class="expand" for="c-37965051">[1 more]</label></div><br/><div class="children"><div class="content">numpy developers seem to prefer a GIL-less python, so better numpy (and other libraries) are possible without GIL.</div><br/></div></div><div id="37964017" class="c"><input type="checkbox" id="c-37964017" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#37961349">root</a><span>|</span><a href="#37961455">parent</a><span>|</span><a href="#37962332">prev</a><span>|</span><a href="#37961690">next</a><span>|</span><label class="collapse" for="c-37964017">[-]</label><label class="expand" for="c-37964017">[1 more]</label></div><br/><div class="children"><div class="content">People in the Numpy&#x2F;ML user camp are like this, but in general usage the computationally expensive parts of Python code are heterogenous application code written with Python dicts, lists, etc that could be run much faster (as evidenced by JS).</div><br/></div></div></div></div><div id="37961690" class="c"><input type="checkbox" id="c-37961690" checked=""/><div class="controls bullet"><span class="by">rvanlaar</span><span>|</span><a href="#37961349">parent</a><span>|</span><a href="#37961455">prev</a><span>|</span><a href="#37962357">next</a><span>|</span><label class="collapse" for="c-37961690">[-]</label><label class="expand" for="c-37961690">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a GIL presentation [1] from 2010 which shows Python 3.2 on a 1 CPU machine was faster than on a dual core.<p>In all, there might be reason to expect GILless python to be faster single core in certain scenario&#x27;s.<p>[1] <a href="https:&#x2F;&#x2F;youtu.be&#x2F;Obt-vMVdM8s?t=2047" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;Obt-vMVdM8s?t=2047</a></div><br/></div></div></div></div><div id="37963934" class="c"><input type="checkbox" id="c-37963934" checked=""/><div class="controls bullet"><span class="by">c-smile</span><span>|</span><a href="#37961349">prev</a><span>|</span><a href="#37961822">next</a><span>|</span><label class="collapse" for="c-37963934">[-]</label><label class="expand" for="c-37963934">[9 more]</label></div><br/><div class="children"><div class="content">Keep GIL but introduce Workers a la JS [0] ?<p>Worker [thread] is a sandboxed VM [context] with its own GIL.<p>Communication between these is done through messaging so no sync primitives are required.<p>Go&#x27;s routines have similar concept.<p>I think that if it OK for Go it should be OK for Python, no?<p>[0] <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Web_Workers_API&#x2F;Using_web_workers" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Web_Workers...</a></div><br/><div id="37963977" class="c"><input type="checkbox" id="c-37963977" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#37963934">parent</a><span>|</span><a href="#37964420">next</a><span>|</span><label class="collapse" for="c-37963977">[-]</label><label class="expand" for="c-37963977">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s subinterpreters in a single process, and the Python runtime already has that (though the only API is from C, not Python, currently); Python API is planned for 3.13.</div><br/></div></div><div id="37964420" class="c"><input type="checkbox" id="c-37964420" checked=""/><div class="controls bullet"><span class="by">akdor1154</span><span>|</span><a href="#37963934">parent</a><span>|</span><a href="#37963977">prev</a><span>|</span><a href="#37964761">next</a><span>|</span><label class="collapse" for="c-37964420">[-]</label><label class="expand" for="c-37964420">[2 more]</label></div><br/><div class="children"><div class="content">Go also has very easy data races when accessing the same data from different goroutines, I&#x27;m not sure Python would accept such a well-cocked footgun.</div><br/><div id="37964621" class="c"><input type="checkbox" id="c-37964621" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#37963934">root</a><span>|</span><a href="#37964420">parent</a><span>|</span><a href="#37964761">next</a><span>|</span><label class="collapse" for="c-37964621">[-]</label><label class="expand" for="c-37964621">[1 more]</label></div><br/><div class="children"><div class="content">No-gil has this plus a bigger footgun.</div><br/></div></div></div></div><div id="37964761" class="c"><input type="checkbox" id="c-37964761" checked=""/><div class="controls bullet"><span class="by">johncolanduoni</span><span>|</span><a href="#37963934">parent</a><span>|</span><a href="#37964420">prev</a><span>|</span><a href="#37964081">next</a><span>|</span><label class="collapse" for="c-37964761">[-]</label><label class="expand" for="c-37964761">[1 more]</label></div><br/><div class="children"><div class="content">That doesn&#x27;t get you much more than Python&#x27;s multiprocessing; you still need to have any state shared between the processors in a simple linear memory and not in Python objects if you follow the web&#x27;s model of postMessage + SharedArrayBuffer.</div><br/></div></div><div id="37964081" class="c"><input type="checkbox" id="c-37964081" checked=""/><div class="controls bullet"><span class="by">ksec</span><span>|</span><a href="#37963934">parent</a><span>|</span><a href="#37964761">prev</a><span>|</span><a href="#37964911">next</a><span>|</span><label class="collapse" for="c-37964081">[-]</label><label class="expand" for="c-37964081">[2 more]</label></div><br/><div class="children"><div class="content">Sounds like Ruby&#x27;s Ractor.</div><br/><div id="37964797" class="c"><input type="checkbox" id="c-37964797" checked=""/><div class="controls bullet"><span class="by">thibaut_barrere</span><span>|</span><a href="#37963934">root</a><span>|</span><a href="#37964081">parent</a><span>|</span><a href="#37964911">next</a><span>|</span><label class="collapse" for="c-37964797">[-]</label><label class="expand" for="c-37964797">[1 more]</label></div><br/><div class="children"><div class="content">Exactly!</div><br/></div></div></div></div><div id="37964510" class="c"><input type="checkbox" id="c-37964510" checked=""/><div class="controls bullet"><span class="by">_ZeD_</span><span>|</span><a href="#37963934">parent</a><span>|</span><a href="#37964911">prev</a><span>|</span><a href="#37961822">next</a><span>|</span><label class="collapse" for="c-37964510">[-]</label><label class="expand" for="c-37964510">[1 more]</label></div><br/><div class="children"><div class="content">that&#x27;s... awful</div><br/></div></div></div></div><div id="37961822" class="c"><input type="checkbox" id="c-37961822" checked=""/><div class="controls bullet"><span class="by">parhamn</span><span>|</span><a href="#37963934">prev</a><span>|</span><a href="#37961980">next</a><span>|</span><label class="collapse" for="c-37961822">[-]</label><label class="expand" for="c-37961822">[15 more]</label></div><br/><div class="children"><div class="content">Hindsight is 20&#x2F;20 but if the Python folks knew how long and bad the 2 to 3 transition would be, they probably would&#x27;ve committed to a much bigger facelift on the interpreter internals too.<p>12 year transition and single threaded performance is still abysmal and it has a few painful transitions left to get to real multi-threading.<p>As kind as one should be with opensource development, at some point is it fair to call it a very poorly managed language?</div><br/><div id="37962366" class="c"><input type="checkbox" id="c-37962366" checked=""/><div class="controls bullet"><span class="by">jeremycarter</span><span>|</span><a href="#37961822">parent</a><span>|</span><a href="#37962534">next</a><span>|</span><label class="collapse" for="c-37962366">[-]</label><label class="expand" for="c-37962366">[4 more]</label></div><br/><div class="children"><div class="content">Yes, you&#x27;re correct. All these years and multiprocessing is still abysmal. I think people are too quick to defend Python. Its important to look at this objectively without bias.</div><br/><div id="37963693" class="c"><input type="checkbox" id="c-37963693" checked=""/><div class="controls bullet"><span class="by">shrimpx</span><span>|</span><a href="#37961822">root</a><span>|</span><a href="#37962366">parent</a><span>|</span><a href="#37964025">next</a><span>|</span><label class="collapse" for="c-37963693">[-]</label><label class="expand" for="c-37963693">[2 more]</label></div><br/><div class="children"><div class="content">Python is a nice language with a shitty implementation. The ergonomics and productivity gain of the ânice languageâ part keeps winning over the other part.</div><br/><div id="37964775" class="c"><input type="checkbox" id="c-37964775" checked=""/><div class="controls bullet"><span class="by">xapata</span><span>|</span><a href="#37961822">root</a><span>|</span><a href="#37963693">parent</a><span>|</span><a href="#37964025">next</a><span>|</span><label class="collapse" for="c-37964775">[-]</label><label class="expand" for="c-37964775">[1 more]</label></div><br/><div class="children"><div class="content">Some of that &quot;shit&quot; was also a competitive advantage in the early days of the language.</div><br/></div></div></div></div><div id="37964025" class="c"><input type="checkbox" id="c-37964025" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#37961822">root</a><span>|</span><a href="#37962366">parent</a><span>|</span><a href="#37963693">prev</a><span>|</span><a href="#37962534">next</a><span>|</span><label class="collapse" for="c-37964025">[-]</label><label class="expand" for="c-37964025">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  All these years and multiprocessing is still abysmal.<p>Shrug. Is it really that much worse than JavaScript or PHP?<p>I mean, maybe they are or have been abysmal, but at least Python is in popular company.</div><br/></div></div></div></div><div id="37962534" class="c"><input type="checkbox" id="c-37962534" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#37961822">parent</a><span>|</span><a href="#37962366">prev</a><span>|</span><a href="#37962195">next</a><span>|</span><label class="collapse" for="c-37962534">[-]</label><label class="expand" for="c-37962534">[6 more]</label></div><br/><div class="children"><div class="content">At what point do we make a language thatâs syntactically identical to Python, but designed from the ground up to have better performance and threading support and just have projects that want performance + Python syntax to that, because clearly the current Python is flailing at multiple goals at once and achieving none of them.</div><br/><div id="37962910" class="c"><input type="checkbox" id="c-37962910" checked=""/><div class="controls bullet"><span class="by">kmod</span><span>|</span><a href="#37961822">root</a><span>|</span><a href="#37962534">parent</a><span>|</span><a href="#37964543">next</a><span>|</span><label class="collapse" for="c-37962910">[-]</label><label class="expand" for="c-37962910">[2 more]</label></div><br/><div class="children"><div class="content">This has been done! Many times, most recently with Mojo. It sounds like you&#x27;re the target user but don&#x27;t use them, so if you&#x27;re interested you could help them out by telling them specifically how they don&#x27;t meet your needs</div><br/><div id="37963776" class="c"><input type="checkbox" id="c-37963776" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#37961822">root</a><span>|</span><a href="#37962910">parent</a><span>|</span><a href="#37964543">next</a><span>|</span><label class="collapse" for="c-37963776">[-]</label><label class="expand" for="c-37963776">[1 more]</label></div><br/><div class="children"><div class="content">Nah Iâve given up on Python wholesale these days, and donât operate in AI stuff anymore either, so not a lot of need for any of the current Python specific libs. Basically everything I write for work or hobby is all Rust now , but Iâve written more than enough Python that Iâm still interested enough to follow the developments from a distance. :)</div><br/></div></div></div></div><div id="37964543" class="c"><input type="checkbox" id="c-37964543" checked=""/><div class="controls bullet"><span class="by">devonkim</span><span>|</span><a href="#37961822">root</a><span>|</span><a href="#37962534">parent</a><span>|</span><a href="#37962910">prev</a><span>|</span><a href="#37962927">next</a><span>|</span><label class="collapse" for="c-37964543">[-]</label><label class="expand" for="c-37964543">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like an argument for Starlark perhaps?</div><br/></div></div><div id="37962927" class="c"><input type="checkbox" id="c-37962927" checked=""/><div class="controls bullet"><span class="by">dist-epoch</span><span>|</span><a href="#37961822">root</a><span>|</span><a href="#37962534">parent</a><span>|</span><a href="#37964543">prev</a><span>|</span><a href="#37962195">next</a><span>|</span><label class="collapse" for="c-37962927">[-]</label><label class="expand" for="c-37962927">[2 more]</label></div><br/><div class="children"><div class="content">The problem was never the language (see PyPy), but the C-extensions.</div><br/><div id="37964467" class="c"><input type="checkbox" id="c-37964467" checked=""/><div class="controls bullet"><span class="by">Too</span><span>|</span><a href="#37961822">root</a><span>|</span><a href="#37962927">parent</a><span>|</span><a href="#37962195">next</a><span>|</span><label class="collapse" for="c-37964467">[-]</label><label class="expand" for="c-37964467">[1 more]</label></div><br/><div class="children"><div class="content">Imagine if one could eliminate the need for C-extensions in the first place.</div><br/></div></div></div></div></div></div><div id="37962195" class="c"><input type="checkbox" id="c-37962195" checked=""/><div class="controls bullet"><span class="by">lacker</span><span>|</span><a href="#37961822">parent</a><span>|</span><a href="#37962534">prev</a><span>|</span><a href="#37962922">next</a><span>|</span><label class="collapse" for="c-37962195">[-]</label><label class="expand" for="c-37962195">[2 more]</label></div><br/><div class="children"><div class="content">Nah, it&#x27;s not poorly managed. Python has a lot of problems. But they are all problems that stem from Python&#x27;s success. The worst parts of Python are the parts that are hard to change because Python is so popular, so the ecosystem is really large, so every sort of change becomes harder due to backward incompatibility.</div><br/><div id="37962723" class="c"><input type="checkbox" id="c-37962723" checked=""/><div class="controls bullet"><span class="by">tyree731</span><span>|</span><a href="#37961822">root</a><span>|</span><a href="#37962195">parent</a><span>|</span><a href="#37962922">next</a><span>|</span><label class="collapse" for="c-37962723">[-]</label><label class="expand" for="c-37962723">[1 more]</label></div><br/><div class="children"><div class="content">One of Pythonâs most serious issues is that it is one of the slowest programming languages actively developed and used today, if it isnât the slowest outright. This isnât due to its success, this is due to the languageâs performance having been deemed not a priority until somewhat recently.</div><br/></div></div></div></div><div id="37962922" class="c"><input type="checkbox" id="c-37962922" checked=""/><div class="controls bullet"><span class="by">dist-epoch</span><span>|</span><a href="#37961822">parent</a><span>|</span><a href="#37962195">prev</a><span>|</span><a href="#37962359">next</a><span>|</span><label class="collapse" for="c-37962922">[-]</label><label class="expand" for="c-37962922">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Hindsight is 20&#x2F;20 but if the Python folks knew how long and bad the 2 to 3 transition would be<p>It was predictable and peopled commented at the time. Perl 5&#x2F;6 was given as an example. And when it became apparent that nobody was switching, it still took about 5 years until they tried making it easier.</div><br/></div></div></div></div><div id="37961980" class="c"><input type="checkbox" id="c-37961980" checked=""/><div class="controls bullet"><span class="by">xwowsersx</span><span>|</span><a href="#37961822">prev</a><span>|</span><a href="#37964901">next</a><span>|</span><label class="collapse" for="c-37961980">[-]</label><label class="expand" for="c-37961980">[2 more]</label></div><br/><div class="children"><div class="content">Always good to get updates on this. Question for folks here: what applications&#x2F;services would you be writing if No-GIL were complete today? Or are there existing applications you have that would benefit from this? Just curious what people are anticipating exactly.</div><br/></div></div><div id="37964901" class="c"><input type="checkbox" id="c-37964901" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#37961980">prev</a><span>|</span><a href="#37962187">next</a><span>|</span><label class="collapse" for="c-37964901">[-]</label><label class="expand" for="c-37964901">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The gil version of python executable is &quot;python3&quot;.<p>Not on Windows!</div><br/></div></div><div id="37962187" class="c"><input type="checkbox" id="c-37962187" checked=""/><div class="controls bullet"><span class="by">facu17y</span><span>|</span><a href="#37964901">prev</a><span>|</span><a href="#37961664">next</a><span>|</span><label class="collapse" for="c-37962187">[-]</label><label class="expand" for="c-37962187">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;d rather port my Python code to Mojo and get, multi-threading, SIMD and other speedups</div><br/><div id="37962299" class="c"><input type="checkbox" id="c-37962299" checked=""/><div class="controls bullet"><span class="by">csjh</span><span>|</span><a href="#37962187">parent</a><span>|</span><a href="#37962321">next</a><span>|</span><label class="collapse" for="c-37962299">[-]</label><label class="expand" for="c-37962299">[2 more]</label></div><br/><div class="children"><div class="content">That would be nice in a world where Mojo is more complete but it is nowhere near that level right now</div><br/><div id="37964470" class="c"><input type="checkbox" id="c-37964470" checked=""/><div class="controls bullet"><span class="by">Too</span><span>|</span><a href="#37962187">root</a><span>|</span><a href="#37962299">parent</a><span>|</span><a href="#37962321">next</a><span>|</span><label class="collapse" for="c-37964470">[-]</label><label class="expand" for="c-37964470">[1 more]</label></div><br/><div class="children"><div class="content">To be fair, neither is nogil.</div><br/></div></div></div></div><div id="37962321" class="c"><input type="checkbox" id="c-37962321" checked=""/><div class="controls bullet"><span class="by">jeremycarter</span><span>|</span><a href="#37962187">parent</a><span>|</span><a href="#37962299">prev</a><span>|</span><a href="#37961664">next</a><span>|</span><label class="collapse" for="c-37962321">[-]</label><label class="expand" for="c-37962321">[2 more]</label></div><br/><div class="children"><div class="content">Agree. I&#x27;d rather just rewrite in Rust, Nim and .NET.</div><br/></div></div></div></div><div id="37961664" class="c"><input type="checkbox" id="c-37961664" checked=""/><div class="controls bullet"><span class="by">bfrog</span><span>|</span><a href="#37962187">prev</a><span>|</span><label class="collapse" for="c-37961664">[-]</label><label class="expand" for="c-37961664">[3 more]</label></div><br/><div class="children"><div class="content">It seems like every 5 years I hear about how someone is going to make python not have a GIL, improve performance drastically, etc etc.<p>Then reality comes in and says, &quot;nah&quot;.<p>Honestly at some point its better to likely start porting code to a language where you <i>can</i> control parallelism better. There&#x27;s a few nice modern options that don&#x27;t involve all the headaches of C++ or C. Could even be extensions as has been the case since the dawn of time.</div><br/><div id="37962947" class="c"><input type="checkbox" id="c-37962947" checked=""/><div class="controls bullet"><span class="by">kmod</span><span>|</span><a href="#37961664">parent</a><span>|</span><a href="#37961692">next</a><span>|</span><label class="collapse" for="c-37962947">[-]</label><label class="expand" for="c-37962947">[1 more]</label></div><br/><div class="children"><div class="content">Ignoring the pessimism for a moment<p>But this nogil version is the first time we have an actually working GIL removal. All of the other ones were incomplete to the point of being non starters, and mostly served as discussion material. This is an actually working implementation which deals with the subtle issues that the other projects didn&#x27;t even get to, and has gotten to the point that it&#x27;s a technical possibility to commit it to main (though obviously with a huge migration to think about). So in this sense this is a very different discussion than all of the previous discussions about the GIL</div><br/></div></div><div id="37961692" class="c"><input type="checkbox" id="c-37961692" checked=""/><div class="controls bullet"><span class="by">voz_</span><span>|</span><a href="#37961664">parent</a><span>|</span><a href="#37962947">prev</a><span>|</span><label class="collapse" for="c-37961692">[-]</label><label class="expand" for="c-37961692">[1 more]</label></div><br/><div class="children"><div class="content">Bad faith take.</div><br/></div></div></div></div></div></div></div></div></div></body></html>