<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1705136466852" as="style"/><link rel="stylesheet" href="styles.css?v=1705136466852"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://www.righto.com/2021/11/reverse-engineering-yamaha-dx7.html">Reverse-engineering the Yamaha DX7 synthesizer&#x27;s sound chip from die photos (2021)</a>Â <span class="domain">(<a href="http://www.righto.com">www.righto.com</a>)</span></div><div class="subtext"><span>throwup238</span> | <span>37 comments</span></div><br/><div><div id="38974908" class="c"><input type="checkbox" id="c-38974908" checked=""/><div class="controls bullet"><span class="by">ajxs</span><span>|</span><a href="#38973919">next</a><span>|</span><label class="collapse" for="c-38974908">[-]</label><label class="expand" for="c-38974908">[5 more]</label></div><br/><div class="children"><div class="content">I wrote the article mentioned by Ken: <a href="https:&#x2F;&#x2F;ajxs.me&#x2F;blog&#x2F;Yamaha_DX7_Technical_Analysis.html" rel="nofollow">https:&#x2F;&#x2F;ajxs.me&#x2F;blog&#x2F;Yamaha_DX7_Technical_Analysis.html</a><p>I&#x27;ve unwittingly become a bit of a Yamaha FM Synth historian!<p>Here are some other contributions to reverse-engineering the DX7:<p>A fully documented disassembly of the DX7 ROM: <a href="https:&#x2F;&#x2F;github.com&#x2F;ajxs&#x2F;yamaha_dx7_rom_disassembly">https:&#x2F;&#x2F;github.com&#x2F;ajxs&#x2F;yamaha_dx7_rom_disassembly</a><p>A new firmware ROM that makes the DX9 function more like a DX7:
<a href="https:&#x2F;&#x2F;github.com&#x2F;ajxs&#x2F;yamaha_dx97">https:&#x2F;&#x2F;github.com&#x2F;ajxs&#x2F;yamaha_dx97</a></div><br/><div id="38974999" class="c"><input type="checkbox" id="c-38974999" checked=""/><div class="controls bullet"><span class="by">djaychela</span><span>|</span><a href="#38974908">parent</a><span>|</span><a href="#38973919">next</a><span>|</span><label class="collapse" for="c-38974999">[-]</label><label class="expand" for="c-38974999">[4 more]</label></div><br/><div class="children"><div class="content">Thanks for this. I&#x27;ve got a dx9 I paid very little for and the lack of velocity sensitivity has always annoyed me about it. I shall give the firmware a go!</div><br/><div id="38975031" class="c"><input type="checkbox" id="c-38975031" checked=""/><div class="controls bullet"><span class="by">ajxs</span><span>|</span><a href="#38974908">root</a><span>|</span><a href="#38974999">parent</a><span>|</span><a href="#38973919">next</a><span>|</span><label class="collapse" for="c-38975031">[-]</label><label class="expand" for="c-38975031">[3 more]</label></div><br/><div class="children"><div class="content">I edited my post to say &quot;more like&quot; a DX7. Unfortunately velocity sensitivity can&#x27;t be added because the physical keyboard doesn&#x27;t support it. The firmware <i>does</i> add velocity sensitivity to incoming MIDI data though!</div><br/><div id="38977482" class="c"><input type="checkbox" id="c-38977482" checked=""/><div class="controls bullet"><span class="by">djaychela</span><span>|</span><a href="#38974908">root</a><span>|</span><a href="#38975031">parent</a><span>|</span><a href="#38976566">next</a><span>|</span><label class="collapse" for="c-38977482">[-]</label><label class="expand" for="c-38977482">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, thanks, I didn&#x27;t think that would be the case, but always wondered why it couldn&#x27;t do it over midi, which is what I&#x27;m most interested in. Thanks again!</div><br/></div></div><div id="38976566" class="c"><input type="checkbox" id="c-38976566" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#38974908">root</a><span>|</span><a href="#38975031">parent</a><span>|</span><a href="#38977482">prev</a><span>|</span><a href="#38973919">next</a><span>|</span><label class="collapse" for="c-38976566">[-]</label><label class="expand" for="c-38976566">[1 more]</label></div><br/><div class="children"><div class="content">isn&#x27;t velocity sensitivity simply two electrical connections (&quot;buttons pushed&quot;) that get made at slightly different points in the arc of a keypress, and the time difference between them is measured to use speed as a proxy for how hard&#x2F;loud the key is pressed? (that was both a question and to explain the mechanism to people not familiar ;)<p>I wonder if it would be simple ot add a sensor to measure that across the keyboard, and then have it do double duty as aftertouch (aftertouch is an effect that measures if you &quot;wiggle&quot; a key after you&#x27;ve pressed it down) Then his DX9 could be better than the DX7 :)</div><br/></div></div></div></div></div></div></div></div><div id="38973919" class="c"><input type="checkbox" id="c-38973919" checked=""/><div class="controls bullet"><span class="by">aamargulies</span><span>|</span><a href="#38974908">prev</a><span>|</span><a href="#38974250">next</a><span>|</span><label class="collapse" for="c-38973919">[-]</label><label class="expand" for="c-38973919">[4 more]</label></div><br/><div class="children"><div class="content">Grey Matter Response reverse-engineered the DX7 with a logic probe to create their E! product:<p><a href="https:&#x2F;&#x2F;www.muzines.co.uk&#x2F;articles&#x2F;grey-matter-response-e&#x2F;2082" rel="nofollow">https:&#x2F;&#x2F;www.muzines.co.uk&#x2F;articles&#x2F;grey-matter-response-e&#x2F;20...</a><p>E! was so good that Yamaha suspected them of industrial espionage.<p>A logic probe.</div><br/><div id="38976504" class="c"><input type="checkbox" id="c-38976504" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#38973919">parent</a><span>|</span><a href="#38974939">next</a><span>|</span><label class="collapse" for="c-38976504">[-]</label><label class="expand" for="c-38976504">[2 more]</label></div><br/><div class="children"><div class="content">not pointing any fingers at all, except to point out that if you engaged in industrial espionage you would undoubtedly then come up with a plausible cover story and hope nobody probed the logic of it too much</div><br/><div id="38977698" class="c"><input type="checkbox" id="c-38977698" checked=""/><div class="controls bullet"><span class="by">ShadowBanThis01</span><span>|</span><a href="#38973919">root</a><span>|</span><a href="#38976504">parent</a><span>|</span><a href="#38974939">next</a><span>|</span><label class="collapse" for="c-38977698">[-]</label><label class="expand" for="c-38977698">[1 more]</label></div><br/><div class="children"><div class="content">I see what you did there, and raise you an octave.</div><br/></div></div></div></div><div id="38974939" class="c"><input type="checkbox" id="c-38974939" checked=""/><div class="controls bullet"><span class="by">ajxs</span><span>|</span><a href="#38973919">parent</a><span>|</span><a href="#38976504">prev</a><span>|</span><a href="#38974250">next</a><span>|</span><label class="collapse" for="c-38974939">[-]</label><label class="expand" for="c-38974939">[1 more]</label></div><br/><div class="children"><div class="content">Reverse-engineering a binary is hard enough in 202x with modern tooling. Doing what they did back in the 80s is truly impressive!</div><br/></div></div></div></div><div id="38974250" class="c"><input type="checkbox" id="c-38974250" checked=""/><div class="controls bullet"><span class="by">dvas</span><span>|</span><a href="#38973919">prev</a><span>|</span><a href="#38974364">next</a><span>|</span><label class="collapse" for="c-38974250">[-]</label><label class="expand" for="c-38974250">[2 more]</label></div><br/><div class="children"><div class="content">This is great! What a lovely read.<p>Reminds me back of my teenage years mesmerised by software&#x2F;hardware synths, daws and everything and anything related to audio tech. Hours spent trying to understand different waves, oscillations, LFOs, modulation, AM, FM and so on and so forth. I could go on all day. Great memories.<p>Anyhow, would be interesting to go down a rabbit hole reading up on the waveform representation for the DX7. Now that I remember, I will go ahead and look for SH-101.</div><br/><div id="38976531" class="c"><input type="checkbox" id="c-38976531" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#38974250">parent</a><span>|</span><a href="#38974364">next</a><span>|</span><label class="collapse" for="c-38976531">[-]</label><label class="expand" for="c-38976531">[1 more]</label></div><br/><div class="children"><div class="content">DX-7 was digital FM synthesis, so while it uses waveforms to modulate other waveforms (digitally at least), and waveforms come out the other end, it&#x27;s not based on typical &quot;analog synth&quot; waveforms the way the SH-101 is.</div><br/></div></div></div></div><div id="38974364" class="c"><input type="checkbox" id="c-38974364" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#38974250">prev</a><span>|</span><a href="#38973942">next</a><span>|</span><label class="collapse" for="c-38974364">[-]</label><label class="expand" for="c-38974364">[1 more]</label></div><br/><div class="children"><div class="content">Here are all the other articles and their previous HN discussions:<p><a href="https:&#x2F;&#x2F;hn.algolia.com&#x2F;?q=righto.com+yamaha+dx7" rel="nofollow">https:&#x2F;&#x2F;hn.algolia.com&#x2F;?q=righto.com+yamaha+dx7</a></div><br/></div></div><div id="38973942" class="c"><input type="checkbox" id="c-38973942" checked=""/><div class="controls bullet"><span class="by">mmastrac</span><span>|</span><a href="#38974364">prev</a><span>|</span><a href="#38975003">next</a><span>|</span><label class="collapse" for="c-38973942">[-]</label><label class="expand" for="c-38973942">[7 more]</label></div><br/><div class="children"><div class="content">Ken, if you have some spare bandwidth I have some high-res decap photos from the chip in the Casio SK-1!<p>I worked on trying to reverse engineer the instruction set from that chip, but most of the code is in a mask ROM that probably needs some debug wires to extract.</div><br/><div id="38978227" class="c"><input type="checkbox" id="c-38978227" checked=""/><div class="controls bullet"><span class="by">johndmcmaster</span><span>|</span><a href="#38973942">parent</a><span>|</span><a href="#38975013">next</a><span>|</span><label class="collapse" for="c-38978227">[-]</label><label class="expand" for="c-38978227">[1 more]</label></div><br/><div class="children"><div class="content">Consider asking in the sipr0n discord decap-commission channel: <a href="https:&#x2F;&#x2F;discord.gg&#x2F;qyne7GZk" rel="nofollow">https:&#x2F;&#x2F;discord.gg&#x2F;qyne7GZk</a></div><br/></div></div><div id="38975013" class="c"><input type="checkbox" id="c-38975013" checked=""/><div class="controls bullet"><span class="by">ajxs</span><span>|</span><a href="#38973942">parent</a><span>|</span><a href="#38978227">prev</a><span>|</span><a href="#38974898">next</a><span>|</span><label class="collapse" for="c-38975013">[-]</label><label class="expand" for="c-38975013">[3 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a zip file here with the Casio SK-1 ROM: <a href="https:&#x2F;&#x2F;dbwbp.com&#x2F;index.php&#x2F;9-misc&#x2F;37-synth-eprom-dumps" rel="nofollow">https:&#x2F;&#x2F;dbwbp.com&#x2F;index.php&#x2F;9-misc&#x2F;37-synth-eprom-dumps</a><p>Maybe this could help. Is there some mask ROM on the CPU that isn&#x27;t included here?</div><br/><div id="38975298" class="c"><input type="checkbox" id="c-38975298" checked=""/><div class="controls bullet"><span class="by">mmastrac</span><span>|</span><a href="#38973942">root</a><span>|</span><a href="#38975013">parent</a><span>|</span><a href="#38974898">next</a><span>|</span><label class="collapse" for="c-38975298">[-]</label><label class="expand" for="c-38975298">[2 more]</label></div><br/><div class="children"><div class="content">Correct. Those have been available for ages, but there&#x27;s a mask ROM on the CPU that is undumpable, at least at this time. I have a huge collection of datasheets and I was unable to even figure out what the instruction set was.</div><br/><div id="38977819" class="c"><input type="checkbox" id="c-38977819" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#38973942">root</a><span>|</span><a href="#38975298">parent</a><span>|</span><a href="#38974898">next</a><span>|</span><label class="collapse" for="c-38977819">[-]</label><label class="expand" for="c-38977819">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s likely to be something Japanese, and I know there&#x27;s been plenty of obscure architectures from them over the years. OKI is known to have made the CPU for Casio, so have you ruled out OKI nX-8?</div><br/></div></div></div></div></div></div><div id="38974898" class="c"><input type="checkbox" id="c-38974898" checked=""/><div class="controls bullet"><span class="by">nobleach</span><span>|</span><a href="#38973942">parent</a><span>|</span><a href="#38975013">prev</a><span>|</span><a href="#38975854">next</a><span>|</span><label class="collapse" for="c-38974898">[-]</label><label class="expand" for="c-38974898">[1 more]</label></div><br/><div class="children"><div class="content">The demo song from that thing will forever live rent-free in my head. Sometimes I sing it to myself, and then pretend I&#x27;ve switched the lead instrument to a sample. (hi, hi hi hi, hi hi hi, hi hi hi hi hi....)</div><br/></div></div><div id="38975854" class="c"><input type="checkbox" id="c-38975854" checked=""/><div class="controls bullet"><span class="by">kens</span><span>|</span><a href="#38973942">parent</a><span>|</span><a href="#38974898">prev</a><span>|</span><a href="#38975003">next</a><span>|</span><label class="collapse" for="c-38975854">[-]</label><label class="expand" for="c-38975854">[1 more]</label></div><br/><div class="children"><div class="content">Thanks. Much as I&#x27;d like to reverse-engineer the Casio SK-1 chip, I&#x27;m trying to stay focused on my current projects.</div><br/></div></div></div></div><div id="38975003" class="c"><input type="checkbox" id="c-38975003" checked=""/><div class="controls bullet"><span class="by">jim-jim-jim</span><span>|</span><a href="#38973942">prev</a><span>|</span><a href="#38974466">next</a><span>|</span><label class="collapse" for="c-38975003">[-]</label><label class="expand" for="c-38975003">[11 more]</label></div><br/><div class="children"><div class="content">I am unfamiliar with low-level workings like this, so forgive me if I&#x27;m talking out of my ass, but received wisdom from places like KVR Audio suggests that on modern machines, fixed point decimal math tends to be slower than just using floats because the integer registers are already clogged with routine operations like incrementing loops, etc. But some claim that anything that needs a phase accumulator as a wavetable index, like FM, still benefits from being kept as integers due to the expense of converting a floating point accumulator to an int address. FM doesn&#x27;t have much arithmetic relative to its reads.<p>I wonder how true this still is. I&#x27;ve been having fun simply assuming it is, and these teardown articles and the other HN discussions around them have been very helpful.</div><br/><div id="38975234" class="c"><input type="checkbox" id="c-38975234" checked=""/><div class="controls bullet"><span class="by">raphlinus</span><span>|</span><a href="#38975003">parent</a><span>|</span><a href="#38975869">next</a><span>|</span><label class="collapse" for="c-38975234">[-]</label><label class="expand" for="c-38975234">[7 more]</label></div><br/><div class="children"><div class="content">I am very familiar with such low level workings. On a modern, fast machine, the amount of computation required by FM synthesis is so small compared with the machine&#x27;s throughput that it just doesn&#x27;t matter.<p>Yes, on modern chips float math will generally be faster than fixed point. This is not so much because the integer units get clogged, as that there&#x27;s a huge amount of chip area and optimization that goes into the float units (often SIMD, and a lot of FM synthesis can benefit from this, though feedback creates data dependencies). For example, multiply-and-add is usually one cycle in float, but would always be two separate instructions in integers.<p>My recollection is that older ARM chips have a special issue with latency of data dependencies originating from the float unit (NEON, which is optimized for SIMD vector operations) to the integer unit. I suspect this is no longer the case, or is less of an issue.</div><br/><div id="38975937" class="c"><input type="checkbox" id="c-38975937" checked=""/><div class="controls bullet"><span class="by">RossBencina</span><span>|</span><a href="#38975003">root</a><span>|</span><a href="#38975234">parent</a><span>|</span><a href="#38975650">next</a><span>|</span><label class="collapse" for="c-38975937">[-]</label><label class="expand" for="c-38975937">[2 more]</label></div><br/><div class="children"><div class="content">Historically, float to integer conversions in C on x86 were very slow due to the compiler reconfiguring the FPU rounding mode for each conversion.</div><br/><div id="38976265" class="c"><input type="checkbox" id="c-38976265" checked=""/><div class="controls bullet"><span class="by">raphlinus</span><span>|</span><a href="#38975003">root</a><span>|</span><a href="#38975937">parent</a><span>|</span><a href="#38975650">next</a><span>|</span><label class="collapse" for="c-38976265">[-]</label><label class="expand" for="c-38976265">[1 more]</label></div><br/><div class="children"><div class="content">Historically yes. This is most definitely not true since processors had SSE3 (~2004), using the FISTTP instruction, or I think you can also use the packed float to integer instructions like CVTTPS2PI as far back as SSE (1999).</div><br/></div></div></div></div><div id="38975650" class="c"><input type="checkbox" id="c-38975650" checked=""/><div class="controls bullet"><span class="by">jim-jim-jim</span><span>|</span><a href="#38975003">root</a><span>|</span><a href="#38975234">parent</a><span>|</span><a href="#38975937">prev</a><span>|</span><a href="#38975557">next</a><span>|</span><label class="collapse" for="c-38975650">[-]</label><label class="expand" for="c-38975650">[1 more]</label></div><br/><div class="children"><div class="content">Cheers for the explanation. I suppose &quot;modern&quot; should be asterisked, since I was parroting posts that date back to the mid-00s. Things have probably changed considerably from then.<p>I&#x27;m specifically targeting an Intel Atom, which is obviously powerful enough for the task, but may not fit all definitions of &quot;modern&quot; now?</div><br/></div></div><div id="38975557" class="c"><input type="checkbox" id="c-38975557" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#38975003">root</a><span>|</span><a href="#38975234">parent</a><span>|</span><a href="#38975650">prev</a><span>|</span><a href="#38975633">next</a><span>|</span><label class="collapse" for="c-38975557">[-]</label><label class="expand" for="c-38975557">[1 more]</label></div><br/><div class="children"><div class="content">&gt; For example, multiply-and-add is usually one cycle in float, but would always be two separate instructions in integers.<p>Unless the multiply is by a constant 2, 4, or 8, in which case you can use `lea`.</div><br/></div></div><div id="38975633" class="c"><input type="checkbox" id="c-38975633" checked=""/><div class="controls bullet"><span class="by">dvas</span><span>|</span><a href="#38975003">root</a><span>|</span><a href="#38975234">parent</a><span>|</span><a href="#38975557">prev</a><span>|</span><a href="#38975869">next</a><span>|</span><label class="collapse" for="c-38975633">[-]</label><label class="expand" for="c-38975633">[2 more]</label></div><br/><div class="children"><div class="content">Got me curious regarding ARM latency, wonder if that was related to particular instructions which added more latency or transfers between the registers&#x2F;memory subsystem internals. Also on the off-chance that you remember, did you inline intrinsics or let the compiler auto-optimize?<p>Interesting to test out on the ARM Mac, and see if different dependency chains show significant latency penalties &#x2F; in with reorder buffer.</div><br/><div id="38976309" class="c"><input type="checkbox" id="c-38976309" checked=""/><div class="controls bullet"><span class="by">raphlinus</span><span>|</span><a href="#38975003">root</a><span>|</span><a href="#38975633">parent</a><span>|</span><a href="#38975869">next</a><span>|</span><label class="collapse" for="c-38976309">[-]</label><label class="expand" for="c-38976309">[1 more]</label></div><br/><div class="children"><div class="content">This is for Cortex A8, which was the chip in the Nexus One. I wrote the original version of sound synthesis directly in ARM assembler[1]. It was <i>very</i> highly optimized, I remember using a cycle counting app that flagged any dependency chain that would cause the processor to stall, and ultimately utilization was in the 90%+ range. Back in those days, processors were simple enough you could do this kind of optimization by hand. By the time of Cortex A15 (Nexus 10 etc), instruction issue was out-of-order and much harder to reason about.<p>The best current info I could find for the latency advice is [2]. Quoting, &quot;Moving data from NEON to ARM registers is Cortex-A8 is expensive.&quot; Looking at [3] partially reveals the reason why: the NEON pipeline is entirely <i>after</i> the integer pipeline, so moves from integer to NEON are cheap, but the reverse direction is potentially a large pipeline stall. This is an unusual design decision that as far as I know is not true for any other CPUs. Edit: I found [4], which is a more authoritative source.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;music-synthesizer-for-android&#x2F;blob&#x2F;master&#x2F;app&#x2F;src&#x2F;main&#x2F;jni&#x2F;neon_fm_kernel.s">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;music-synthesizer-for-android&#x2F;blob...</a><p>[2]: <a href="https:&#x2F;&#x2F;community.arm.com&#x2F;support-forums&#x2F;f&#x2F;armds-forum&#x2F;757&#x2F;neon-instruction-timing-latency" rel="nofollow">https:&#x2F;&#x2F;community.arm.com&#x2F;support-forums&#x2F;f&#x2F;armds-forum&#x2F;757&#x2F;n...</a><p>[3]: <a href="https:&#x2F;&#x2F;www.design-reuse.com&#x2F;articles&#x2F;11580&#x2F;architecture-and-implementation-of-the-arm-cortex-a8-microprocessor.html" rel="nofollow">https:&#x2F;&#x2F;www.design-reuse.com&#x2F;articles&#x2F;11580&#x2F;architecture-and...</a><p>[4]: <a href="https:&#x2F;&#x2F;developer.arm.com&#x2F;documentation&#x2F;den0018&#x2F;a&#x2F;Optimizing-NEON-Code&#x2F;Scheduling&#x2F;Passing-data-between-ARM-general-purpose-registers-and-NEON-registers" rel="nofollow">https:&#x2F;&#x2F;developer.arm.com&#x2F;documentation&#x2F;den0018&#x2F;a&#x2F;Optimizing...</a></div><br/></div></div></div></div></div></div><div id="38975869" class="c"><input type="checkbox" id="c-38975869" checked=""/><div class="controls bullet"><span class="by">RossBencina</span><span>|</span><a href="#38975003">parent</a><span>|</span><a href="#38975234">prev</a><span>|</span><a href="#38975719">next</a><span>|</span><label class="collapse" for="c-38975869">[-]</label><label class="expand" for="c-38975869">[1 more]</label></div><br/><div class="children"><div class="content">Firstly, the DX7 is a hardware implementation, it doesn&#x27;t use a CPU for arithmetic so there is no inherent notion of resource contention. Hardware resources can be (and are) allocated and&#x2F;or shared exactly as are needed by the requirements of the target computation. You mention &quot;reads,&quot; but once again, in a hardware implementation the memory structure may be quite different from the cache hierarchy of a CPU (the situation that KVRists would be most familiar with).<p>In a phase accumulator (or any numerical representation of time) it is generally desirable to have uniform precision across the full phase range. Floating point arithmetic does not have this property. On the other hand, floating point arithmetic can sometimes be more convenient than fixed-point if the hardware to hand can execute it fast. But if you&#x27;re designing hardware from scratch, and especially for FM synthesis, you&#x27;re probably going to find some other tricks that work even better.</div><br/></div></div><div id="38975719" class="c"><input type="checkbox" id="c-38975719" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#38975003">parent</a><span>|</span><a href="#38975869">prev</a><span>|</span><a href="#38974466">next</a><span>|</span><label class="collapse" for="c-38975719">[-]</label><label class="expand" for="c-38975719">[2 more]</label></div><br/><div class="children"><div class="content">&gt; received wisdom from places like KVR Audio<p>bwahahaha.<p>I&#x27;m a DAW author. Have been for 24 years or so. My friends write plugins and DSP modules for mixing consoles.<p>Received wisdom from KVR Audio (and in fact, most online forums) is worth less than the distance than a flea could throw it.<p>Digital audio software users that know almost nothing about the subject seem highly inclined to spend their time blathering on in these forums, while the people who actually do know about it appear to have better things to do.</div><br/><div id="38977639" class="c"><input type="checkbox" id="c-38977639" checked=""/><div class="controls bullet"><span class="by">stevefolta</span><span>|</span><a href="#38975003">root</a><span>|</span><a href="#38975719">parent</a><span>|</span><a href="#38974466">next</a><span>|</span><label class="collapse" for="c-38977639">[-]</label><label class="expand" for="c-38977639">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Received wisdom from KVR Audio (and in fact, most online forums) is worth less than the distance than a flea could throw it.<p>Depends on the forum, I guess.  Lately I&#x27;ve been following the developer subforum of KVR, where folks talk about filter and oscillator algorithms using math I&#x27;ll never understand.  Discussions there seem well-reasoned and entirely civil.  I haven&#x27;t really seen them talk about performance optimizations, though.  And I can&#x27;t say anything about the rest of KVR.</div><br/></div></div></div></div></div></div><div id="38974466" class="c"><input type="checkbox" id="c-38974466" checked=""/><div class="controls bullet"><span class="by">showerst</span><span>|</span><a href="#38975003">prev</a><span>|</span><a href="#38977714">next</a><span>|</span><label class="collapse" for="c-38974466">[-]</label><label class="expand" for="c-38974466">[1 more]</label></div><br/><div class="children"><div class="content">Thanks Ken, that was the best rickroll I&#x27;ve seen in years.</div><br/></div></div><div id="38977714" class="c"><input type="checkbox" id="c-38977714" checked=""/><div class="controls bullet"><span class="by">ShadowBanThis01</span><span>|</span><a href="#38974466">prev</a><span>|</span><a href="#38974074">next</a><span>|</span><label class="collapse" for="c-38977714">[-]</label><label class="expand" for="c-38977714">[3 more]</label></div><br/><div class="children"><div class="content">This is really informative, and the simple FM-synthesis demo confirmed my guess as to what the term meant (since I could never be bothered to look it up). Fun!<p>Is there a highly-regarded software (or hardware + software) emulator for the DX7?</div><br/><div id="38977996" class="c"><input type="checkbox" id="c-38977996" checked=""/><div class="controls bullet"><span class="by">throwaway2046</span><span>|</span><a href="#38977714">parent</a><span>|</span><a href="#38974074">next</a><span>|</span><label class="collapse" for="c-38977996">[-]</label><label class="expand" for="c-38977996">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Is there a highly-regarded software (or hardware + software) emulator for the DX7?<p>Dexed is probably what you&#x27;re looking for, although there are others here: <a href="https:&#x2F;&#x2F;github.com&#x2F;nodiscc&#x2F;awesome-linuxaudio#synthesizers---fm">https:&#x2F;&#x2F;github.com&#x2F;nodiscc&#x2F;awesome-linuxaudio#synthesizers--...</a></div><br/><div id="38978165" class="c"><input type="checkbox" id="c-38978165" checked=""/><div class="controls bullet"><span class="by">ShadowBanThis01</span><span>|</span><a href="#38977714">root</a><span>|</span><a href="#38977996">parent</a><span>|</span><a href="#38974074">next</a><span>|</span><label class="collapse" for="c-38978165">[-]</label><label class="expand" for="c-38978165">[1 more]</label></div><br/><div class="children"><div class="content">Cool, thanks! I wonder how many of those can run well on a Raspberry Pi.</div><br/></div></div></div></div></div></div><div id="38974074" class="c"><input type="checkbox" id="c-38974074" checked=""/><div class="controls bullet"><span class="by">helpfulContrib</span><span>|</span><a href="#38977714">prev</a><span>|</span><a href="#38952340">next</a><span>|</span><label class="collapse" for="c-38974074">[-]</label><label class="expand" for="c-38974074">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m reminded of the folks working on getting the Motorola M56k DSP emulator working so well that it can boot the firmware for many popular digital-analog synthesizers directly, and pretty much produce word-compatible output from factory patches .. astonishing stuff.</div><br/></div></div></div></div></div></div></div></body></html>