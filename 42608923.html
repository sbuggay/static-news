<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1736240477098" as="style"/><link rel="stylesheet" href="styles.css?v=1736240477098"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://crowdhailer.me/2025-01-02/the-evolution-of-a-structural-code-editor/">The evolution of a structural code editor</a> <span class="domain">(<a href="https://crowdhailer.me">crowdhailer.me</a>)</span></div><div class="subtext"><span>crowdhailer</span> | <span>79 comments</span></div><br/><div><div id="42611176" class="c"><input type="checkbox" id="c-42611176" checked=""/><div class="controls bullet"><span class="by">narag</span><span>|</span><a href="#42611567">next</a><span>|</span><label class="collapse" for="c-42611176">[-]</label><label class="expand" for="c-42611176">[7 more]</label></div><br/><div class="children"><div class="content">This is the way. Programs are not text, there&#x27;s an impedance mismatch that shows at the seams.<p>There&#x27;re good reasons it hasn&#x27;t been done more: text is good for troubleshooting, &quot;every program should do one thing well&quot; and maybe preventing lock-in.<p>But with programming tools reaching maturity, we&#x27;ll see more of this. Also there&#x27;s an AI-related aspect: bots can understand structure just fine.</div><br/><div id="42613132" class="c"><input type="checkbox" id="c-42613132" checked=""/><div class="controls bullet"><span class="by">ok_computer</span><span>|</span><a href="#42611176">parent</a><span>|</span><a href="#42612497">next</a><span>|</span><label class="collapse" for="c-42613132">[-]</label><label class="expand" for="c-42613132">[1 more]</label></div><br/><div class="children"><div class="content">In my opinion, that’s the magic of programming languages. I type a few high level words and characters, then there is a deep stack of interpreting the strings into machine code and returning data and side effects. It is stupid simple as the end user and immensely complex chain of machinery.<p>SQL is an extreme example of strings parsed to make complex computer behavior. Shell scripting too.<p>For enforcing complete object correctness and interfaces as they are explicitly designed then low code no code seems like it has a better proposition.<p>Anyway, maybe structured editors fit a space between dumb strings and pointing and clicking blocks and connectors. I’m all for correct tool for the job and end user. I think that minimizing end user tooling with some LSP go-to definitions and linting in a text editor is my preference. Similar to how FIFA used to be against high tech slow mo replay for soccer matches to make the sport egalitarian &#x2F; accessible for the whole world I think that analogously programming should focus on the simplicity and portability of authored documents.</div><br/></div></div><div id="42612497" class="c"><input type="checkbox" id="c-42612497" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#42611176">parent</a><span>|</span><a href="#42613132">prev</a><span>|</span><a href="#42613145">next</a><span>|</span><label class="collapse" for="c-42612497">[-]</label><label class="expand" for="c-42612497">[1 more]</label></div><br/><div class="children"><div class="content">There are good reasons it hasn&#x27;t been done more, and I don&#x27;t think it is just &quot;text is good for troubleshooting.&quot;<p>At large, text wins because the job of a program text is to communicate the program to a user in a way that a computer can also be made to use.  Things that help include that text can have multiple interpretations and meanings.  This is why most variable names are nouns.  You can literally &quot;ascii art&quot; parts of code to help convey some ideas.<p>The most important part of why &quot;text&quot; wins, though, is that it is all visible.  Yes it implies some structure underneath that the computer is going to need.  The text, though, is fully visible to users.  People think they want the ability to &quot;structurally edit,&quot; and you can sometimes make that work rather nicely.  Most of the time, though, you are working with structures that are not complete.  And worse, completing them will <i>not</i> be a process that goes in the same direction as the text.  You will have to start a stack in how you are processing things to complete as you go.<p>I&#x27;m torn on the bots comment, as I just don&#x27;t know.  LLMs, arguably, are leaning in on the structure that has been embedded in our symbolic text over many years.  The same structure has not necessarily been developed in computer programming texts?<p>(Also worth paying attention to how most of these goals were pursued with symbolic programming techniques back in the day.  LISP, of course, but also term rewriting techniques that used to be rather magical.)</div><br/></div></div><div id="42613145" class="c"><input type="checkbox" id="c-42613145" checked=""/><div class="controls bullet"><span class="by">LeftHandPath</span><span>|</span><a href="#42611176">parent</a><span>|</span><a href="#42612497">prev</a><span>|</span><a href="#42620072">next</a><span>|</span><label class="collapse" for="c-42613145">[-]</label><label class="expand" for="c-42613145">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s fascinating because I came to a similar conclusion while working with <i>very</i> old IBM mainframe code editors (AS400 &#x2F; IBM i &quot;Source Entry Utility&quot;)<p>It&#x27;s nearly impossible (if you read the docs) to write something with bad syntax on those machines. Columns are semantic in most of the languages (COBOL, RPG, DDL). When you write a program, if you don&#x27;t know what you&#x27;re doing, you can press &quot;F4&quot; and it will show you what each column means and when&#x2F;how to use it [0]. It&#x27;s not exactly a structured code editor, but it shares some similar concepts (see the link; you often write code in a &quot;prompt&quot; at the bottom of the screen, and the line won&#x27;t insert until it&#x27;s complete, though you can write it by hand if you wish).<p>All of that said, IBM&#x27;s old SEU is still vastly inferior to modern text editors and IDEs, mostly because of the limited view window and the lack of syntax highlighting &#x2F; basic modern features [1].<p>I think that, especially for enterprise code&#x2F;development, there are some benefits to structured editing that are worth exploring. Not having a linter shout at a partially-complete line because you paused for a second or two would be nice, as well.<p>[0]: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;iw_wk5elf3Q?si=m9zVeboTyw0T8_Wu&amp;t=635" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;iw_wk5elf3Q?si=m9zVeboTyw0T8_Wu&amp;t=635</a>
[1]: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;Q3hxwcYB1Oo?si=WE9-rFdYo72A5yXz&amp;t=404" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;Q3hxwcYB1Oo?si=WE9-rFdYo72A5yXz&amp;t=404</a></div><br/></div></div><div id="42620072" class="c"><input type="checkbox" id="c-42620072" checked=""/><div class="controls bullet"><span class="by">enriquto</span><span>|</span><a href="#42611176">parent</a><span>|</span><a href="#42613145">prev</a><span>|</span><a href="#42620263">next</a><span>|</span><label class="collapse" for="c-42620072">[-]</label><label class="expand" for="c-42620072">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Programs are not text<p>Wow.  It&#x27;s amazing to see the beast laid out so clearly before me.<p>As someone who grew with the mantra &quot;a program is a piece of text&quot;, my jaw dropped when I read this post and realized that it was not written in jest.  Of course the mantra is still deeply entrenched in my mind, it&#x27;s too late to remove it now; but I feel as if the world is crumbling around me.  What other sacred beliefs will fall?  Why doesn&#x27;t everybody realize that <i>the text file</i> is one of the finest inventions of the third millennium?<p>Maybe it&#x27;s just another period in the eternal cycle of fashion trends... programs as free-form text files were an exhilarating liberation from the crufty, fixed-form structures of older languages.  Now, we are not only going back to write our code starting at column 4 (like in punched cards), but we still want to add <i>even more</i> structure to it!  Maybe in forty years we will go back to free-form text and  cherish it again.<p>Reading the sentence &quot;programs are not text&quot; was the first time I felt old in my life.</div><br/></div></div><div id="42620263" class="c"><input type="checkbox" id="c-42620263" checked=""/><div class="controls bullet"><span class="by">0x1ceb00da</span><span>|</span><a href="#42611176">parent</a><span>|</span><a href="#42620072">prev</a><span>|</span><a href="#42612960">next</a><span>|</span><label class="collapse" for="c-42620263">[-]</label><label class="expand" for="c-42620263">[1 more]</label></div><br/><div class="children"><div class="content">Then there are languages like lisp. If you ask anyone in the community who&#x27;s drank the s-expression koolaid, they&#x27;ll say &quot;your editor will take care of it bro, 12 closing parenthesis are totally fine&quot;. But every once in a while you&#x27;re stuck in an environment with barebone vim, you mess up some editing, the language provides completely unhelpful error messages, and you&#x27;re stuck debugging a bloody syntax error for 30 minutes.<p>The command line interface of a language should be really good and one should be able to program without any fancy tooling. The compiler shouldn&#x27;t offload any responsibility to the editor&#x2F;lsp.</div><br/></div></div><div id="42612960" class="c"><input type="checkbox" id="c-42612960" checked=""/><div class="controls bullet"><span class="by">throw-the-towel</span><span>|</span><a href="#42611176">parent</a><span>|</span><a href="#42620263">prev</a><span>|</span><a href="#42611567">next</a><span>|</span><label class="collapse" for="c-42612960">[-]</label><label class="expand" for="c-42612960">[1 more]</label></div><br/><div class="children"><div class="content">Hell, even text is not exactly text, it also has structure. I&#x27;d love to have refactoring tools for prose.</div><br/></div></div></div></div><div id="42611567" class="c"><input type="checkbox" id="c-42611567" checked=""/><div class="controls bullet"><span class="by">danielvaughn</span><span>|</span><a href="#42611176">prev</a><span>|</span><a href="#42612415">next</a><span>|</span><label class="collapse" for="c-42611567">[-]</label><label class="expand" for="c-42611567">[4 more]</label></div><br/><div class="children"><div class="content">I’m obsessed with structural editors because it feels intuitively like the right approach to creating software. However I’ve yet to come across an interface that really clicks. Still love it though. Right now I’m building a structured editor for creating UIs, so can attest to how difficult it is to get it right.<p>It’s a super interesting problem space.</div><br/><div id="42612027" class="c"><input type="checkbox" id="c-42612027" checked=""/><div class="controls bullet"><span class="by">crowdhailer</span><span>|</span><a href="#42611567">parent</a><span>|</span><a href="#42615059">next</a><span>|</span><label class="collapse" for="c-42612027">[-]</label><label class="expand" for="c-42612027">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;d really like to get to the point where I have a library of transformations and you can make your own interface. Already the click ui and hot keys ui call the same `insert_function` or `assign_to` functions. Adding a ui with lots of dragging or voice control should be trivial</div><br/><div id="42612712" class="c"><input type="checkbox" id="c-42612712" checked=""/><div class="controls bullet"><span class="by">danielvaughn</span><span>|</span><a href="#42611567">root</a><span>|</span><a href="#42612027">parent</a><span>|</span><a href="#42615059">next</a><span>|</span><label class="collapse" for="c-42612712">[-]</label><label class="expand" for="c-42612712">[1 more]</label></div><br/><div class="children"><div class="content">I’ve actually moved away from GUI controls and towards something resembling a keyboard command language. Similar in spirit to vim motions, but instead of applied to text, it’s applied to an AST.<p>I think that could be the key to making structured editing feel less “clunky”.</div><br/></div></div></div></div></div></div><div id="42612415" class="c"><input type="checkbox" id="c-42612415" checked=""/><div class="controls bullet"><span class="by">cfiggers</span><span>|</span><a href="#42611567">prev</a><span>|</span><a href="#42611639">next</a><span>|</span><label class="collapse" for="c-42612415">[-]</label><label class="expand" for="c-42612415">[2 more]</label></div><br/><div class="children"><div class="content">I enjoy Lisp and Lisp-alike languages specifically because with the right editor support you can do a lot of this kind of structural editing stuff without giving up the niceties of source code as text.</div><br/><div id="42612565" class="c"><input type="checkbox" id="c-42612565" checked=""/><div class="controls bullet"><span class="by">mtreis86</span><span>|</span><a href="#42612415">parent</a><span>|</span><a href="#42611639">next</a><span>|</span><label class="collapse" for="c-42612565">[-]</label><label class="expand" for="c-42612565">[1 more]</label></div><br/><div class="children"><div class="content">Yeah in emacs with paredit&#x2F;smartparens&#x2F;parinfer or whatever, it is both text and structure. With parinfer you change the text and the structure gets modified to match. With the other two you can change the structure directly with a command that has a silly but descriptive name like slurp or barf.</div><br/></div></div></div></div><div id="42611639" class="c"><input type="checkbox" id="c-42611639" checked=""/><div class="controls bullet"><span class="by">xigency</span><span>|</span><a href="#42612415">prev</a><span>|</span><a href="#42611358">next</a><span>|</span><label class="collapse" for="c-42611639">[-]</label><label class="expand" for="c-42611639">[8 more]</label></div><br/><div class="children"><div class="content">This is a topic I&#x27;ve been contemplating heavily and it&#x27;s very instructive to see the iterative progress you&#x27;ve made here.<p>I think development tools like this are necessary to expand coding outside of just the desktop experience. For example, I&#x27;ve seen kids program some pretty impressive robotics with just a touchscreen and Blockly.<p>Also, from a compilers perspective, it feels almost absurd to rely on plaintext. Imagine how much harder code merging is using line diff compared to diffing syntax trees.<p>Thanks for sharing!</div><br/><div id="42619985" class="c"><input type="checkbox" id="c-42619985" checked=""/><div class="controls bullet"><span class="by">eternauta3k</span><span>|</span><a href="#42611639">parent</a><span>|</span><a href="#42612013">next</a><span>|</span><label class="collapse" for="c-42619985">[-]</label><label class="expand" for="c-42619985">[1 more]</label></div><br/><div class="children"><div class="content">You could run a parser in the diff tool without using a structured editor, though.</div><br/></div></div><div id="42612013" class="c"><input type="checkbox" id="c-42612013" checked=""/><div class="controls bullet"><span class="by">crowdhailer</span><span>|</span><a href="#42611639">parent</a><span>|</span><a href="#42619985">prev</a><span>|</span><a href="#42612717">next</a><span>|</span><label class="collapse" for="c-42612013">[-]</label><label class="expand" for="c-42612013">[5 more]</label></div><br/><div class="children"><div class="content">Diffing is really an interesting point. Git is quite (maybe very) good. I wonder how much better a structured approach could be but it&#x27;s obviously a large amount of work that I don&#x27;t yet have time for.</div><br/><div id="42612913" class="c"><input type="checkbox" id="c-42612913" checked=""/><div class="controls bullet"><span class="by">aiono</span><span>|</span><a href="#42611639">root</a><span>|</span><a href="#42612013">parent</a><span>|</span><a href="#42616189">next</a><span>|</span><label class="collapse" for="c-42612913">[-]</label><label class="expand" for="c-42612913">[1 more]</label></div><br/><div class="children"><div class="content">Plain Text diffing has some obvious drawbacks:<p>1. If you rearrange your functions you will see a lot of additions and deletions while semantically there is no change in the program. It&#x27;s just noise.<p>2. If you rename a variable you don&#x27;t really have any actual change in places where it is referenced but text diff will again show a lot of noise. But the code references is still the same code.</div><br/></div></div><div id="42616189" class="c"><input type="checkbox" id="c-42616189" checked=""/><div class="controls bullet"><span class="by">ElevenLathe</span><span>|</span><a href="#42611639">root</a><span>|</span><a href="#42612013">parent</a><span>|</span><a href="#42612913">prev</a><span>|</span><a href="#42612987">next</a><span>|</span><label class="collapse" for="c-42616189">[-]</label><label class="expand" for="c-42616189">[1 more]</label></div><br/><div class="children"><div class="content">Modern SmallTalks have the option to save off a hierarchy of classes to text in order to use modern version control, and also to apply these exports to a running image. This should be even easier for traditional languages with no live running environment. There&#x27;s no reason whatever structure editor you use can&#x27;t export a normalized text representation so that you can still use it with Git</div><br/></div></div><div id="42612987" class="c"><input type="checkbox" id="c-42612987" checked=""/><div class="controls bullet"><span class="by">williamdclt</span><span>|</span><a href="#42611639">root</a><span>|</span><a href="#42612013">parent</a><span>|</span><a href="#42616189">prev</a><span>|</span><a href="#42612335">next</a><span>|</span><label class="collapse" for="c-42612987">[-]</label><label class="expand" for="c-42612987">[1 more]</label></div><br/><div class="children"><div class="content">Git (or whatever does the diff under the hood) is _adequate_. Every week I see diffs that are confusing, especially during merge conflicts, it’s honestly a bit embarrassing that in this day and age we don’t have anything better for something that is so central to our job</div><br/></div></div><div id="42612335" class="c"><input type="checkbox" id="c-42612335" checked=""/><div class="controls bullet"><span class="by">kmoser</span><span>|</span><a href="#42611639">root</a><span>|</span><a href="#42612013">parent</a><span>|</span><a href="#42612987">prev</a><span>|</span><a href="#42612717">next</a><span>|</span><label class="collapse" for="c-42612335">[-]</label><label class="expand" for="c-42612335">[1 more]</label></div><br/><div class="children"><div class="content">A structured approach would be able to easily do things like ignore when a symbol was renamed (since that wouldn&#x27;t affect the tree structure). So there are good reasons for wanting to do it that way, vs. a line-based diff.</div><br/></div></div></div></div><div id="42612717" class="c"><input type="checkbox" id="c-42612717" checked=""/><div class="controls bullet"><span class="by">amar1729</span><span>|</span><a href="#42611639">parent</a><span>|</span><a href="#42612013">prev</a><span>|</span><a href="#42611358">next</a><span>|</span><label class="collapse" for="c-42612717">[-]</label><label class="expand" for="c-42612717">[1 more]</label></div><br/><div class="children"><div class="content">for diffing syntax trees, I&#x27;ve been trying out diffsitter, and it feels pretty good so far<p><a href="https:&#x2F;&#x2F;github.com&#x2F;afnanenayet&#x2F;diffsitter">https:&#x2F;&#x2F;github.com&#x2F;afnanenayet&#x2F;diffsitter</a></div><br/></div></div></div></div><div id="42611358" class="c"><input type="checkbox" id="c-42611358" checked=""/><div class="controls bullet"><span class="by">unshavedyak</span><span>|</span><a href="#42611639">prev</a><span>|</span><a href="#42613617">next</a><span>|</span><label class="collapse" for="c-42611358">[-]</label><label class="expand" for="c-42611358">[8 more]</label></div><br/><div class="children"><div class="content">Awesome! Glad to see more exploration in this space. I too am exploring this, though i am perhaps making it yet even more complicated. I want to represent relationships between AST nodes in a visual way. Eg, i love Node editors in Blender and if it was given a good keyboard based UX i could imagine editing structural code in it.<p>I still imagine the code would be visually text, but i&#x27;m imagining that you&#x27;d be able to see a series of nodes in a code flow graph for your current editing context.<p>I figure AST editing (to some degree) is a generally good thing, but also representing code flow somehow is also a desired thing. It&#x27;s what i do in my head, so can it be visualized in a beneficial way?<p>Difficult to say. Keyboard first will also be a challenge as i&#x27;ll need to have a lot of intelligent alignment and visual compression.<p>Thanks for the post! Love to see work in this space.</div><br/><div id="42612174" class="c"><input type="checkbox" id="c-42612174" checked=""/><div class="controls bullet"><span class="by">alexvitkov</span><span>|</span><a href="#42611358">parent</a><span>|</span><a href="#42611392">next</a><span>|</span><label class="collapse" for="c-42612174">[-]</label><label class="expand" for="c-42612174">[3 more]</label></div><br/><div class="children"><div class="content">My biggest problem with node-based programming interfaces is the absurd number of nodes required for even fairly simple expressions, e.g `b*b-4*a*c` is 9 characters in most textual languages, but it would require 9 nodes in most visual scripting systems.<p>I imagine you could have an arbitrary &quot;expression&quot; node with N inputs and a textfield, but I&#x27;ve never seen it done and it still feels like a bigger hassle than punching out the expression in a textual language.</div><br/><div id="42613980" class="c"><input type="checkbox" id="c-42613980" checked=""/><div class="controls bullet"><span class="by">unshavedyak</span><span>|</span><a href="#42611358">root</a><span>|</span><a href="#42612174">parent</a><span>|</span><a href="#42613735">next</a><span>|</span><label class="collapse" for="c-42613980">[-]</label><label class="expand" for="c-42613980">[1 more]</label></div><br/><div class="children"><div class="content">Well to be clear, my model (that i&#x27;m trying to make, it doesn&#x27;t exist yet) is very mixed with traditional text editing.<p>I agree with you, which is why mine is more of a text editor augmented by nodes. Notably each node is a variable scope window into text. I&#x27;m imaging a single function, more so than individual AST elements. The node can then have multiple inputs and outputs (or relationships of varying types, as i&#x27;m imagining) similar to how Blender can have many fields, inputs and outputs.<p>The variable scoping would mean you can make a single node as large or as small as you need. Including a whole file, or a single expression within a single function, etc. The goal of this would be to visually reduce unrelated clutter, such that relationships should be clear and not dizzying.<p>I want the nodes to visually represent how i normally work. Which is to say i have a text editor open and often i&#x27;m only looking at a single function in the file. Then i jump in and out of the function to related functions. Similarly those are text editor nodes as well, and so the chain continues.<p>I should stress, i really enjoy my text editor (Helix). I&#x27;m trying to add onto that UX ultimately, rather than replace it entirely. Reduce the things i think&#x2F;hope i don&#x27;t care about -- ie unrelated functions in a file -- and add things like visual relationships. Imagine an aggressive traditional text editor setting which folds all code you&#x27;re not using. But with a slightly different representation which hopefully adds to the experience.<p>Sidenote, another motivation for me is to leave the Terminal. I&#x27;ve been in Terminal for 20 years now but <i>just</i> leaving it is not alone worth it. I want to toy with graphical representations that would be difficult in a Terminal. Something to justify it&#x27;s existence when compared to something as easy and flexible as the Terminal is.</div><br/></div></div><div id="42613735" class="c"><input type="checkbox" id="c-42613735" checked=""/><div class="controls bullet"><span class="by">narag</span><span>|</span><a href="#42611358">root</a><span>|</span><a href="#42612174">parent</a><span>|</span><a href="#42613980">prev</a><span>|</span><a href="#42611392">next</a><span>|</span><label class="collapse" for="c-42613735">[-]</label><label class="expand" for="c-42613735">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, a hybrid approach seems better.</div><br/></div></div></div></div><div id="42611392" class="c"><input type="checkbox" id="c-42611392" checked=""/><div class="controls bullet"><span class="by">unshavedyak</span><span>|</span><a href="#42611358">parent</a><span>|</span><a href="#42612174">prev</a><span>|</span><a href="#42611458">next</a><span>|</span><label class="collapse" for="c-42611392">[-]</label><label class="expand" for="c-42611392">[1 more]</label></div><br/><div class="children"><div class="content">Oh, related in this space: <a href="https:&#x2F;&#x2F;mbuffett.com&#x2F;posts&#x2F;structured-editing-syntax&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mbuffett.com&#x2F;posts&#x2F;structured-editing-syntax&#x2F;</a><p>I thought this blog post had an interesting idea too. Basically that a structural editor which truly knew the underlying AST could then alter the visual representation of the code entirely. Eg changing it to look like Python, or whatever insane thing.<p>Not advocating for that of course, but the idea that the editor could be effectively transpiling the code in real time is an interesting area to explore too. I imagine not for the purpose of &quot;Write Python that becomes Rust&quot; or w&#x2F;e, but just in general customizing the experience. Perhaps reducing clutter, &#x2F;shrug</div><br/></div></div><div id="42611458" class="c"><input type="checkbox" id="c-42611458" checked=""/><div class="controls bullet"><span class="by">Slackwise</span><span>|</span><a href="#42611358">parent</a><span>|</span><a href="#42611392">prev</a><span>|</span><a href="#42613617">next</a><span>|</span><label class="collapse" for="c-42611458">[-]</label><label class="expand" for="c-42611458">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Glad to see more exploration in this space.<p>I mean.... ParEdit [1] and ParInfer [2] have been around for a long time now. Structural editing is basically ancient. Lispers have been doing this for a long while, `slurp`ing and `barf`ing their parens.<p>[1]: <a href="https:&#x2F;&#x2F;paredit.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;paredit.org&#x2F;</a><p>[2]: <a href="https:&#x2F;&#x2F;shaunlebron.github.io&#x2F;parinfer&#x2F;" rel="nofollow">https:&#x2F;&#x2F;shaunlebron.github.io&#x2F;parinfer&#x2F;</a></div><br/><div id="42614281" class="c"><input type="checkbox" id="c-42614281" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#42611358">root</a><span>|</span><a href="#42611458">parent</a><span>|</span><a href="#42613617">next</a><span>|</span><label class="collapse" for="c-42614281">[-]</label><label class="expand" for="c-42614281">[2 more]</label></div><br/><div class="children"><div class="content">I have no problem with anyone jousting with the windmills; I have a problem when they don&#x27;t realize they are windmills. Hundreds and probably thousands of programmers have taken a crack at this problem. That doesn&#x27;t prove it&#x27;s a bad idea but it is effective proof until shown otherwise that if it is a good idea it is not such a good idea that it can instantly catch up to the decades of work in text editing. And the way some people talk about it, it&#x27;s clear that a lot of programmers think that it should be that good.<p>This is up there with &quot;everything would be solved with visual programming&quot; and &quot;hey, what if we could put down different syntax on top of the ASTs?&quot;. If your mental model is that it must just be because nobody has put any effort into the question, update your model, because in fact <i>tons</i> of effort has been expended and I&#x27;d suggest anyone interested in adding to the pile and actually solving the problems (as opposed to playing about, anyone can play with anything they like) is best served by examining the large pile of previous efforts and figuring out what they will do better than before.<p>Creating a language designed for being manipulated this way is at least a bit more rare than just declaring structural editing is the way forward in a general sense. Still, I&#x27;m skeptical. The existence of a textual serialization of programming language concepts is not the problem, nor is the usage of said serialization. Every serious tool already immediately deserializes the text into an AST, and when you really get down to the nitty-gritty of how one represents these things in memory, it is not at all clear that there is necessary a &quot;better&quot; way to serialize these structures, or one that is really very different in the ways that matter. There&#x27;s a number of well-known (by those who look) pitfalls built into the idea of structural editing and it is not clear at all that the fundamental disadvantages can be overcome. Maybe they can. But the evidence at this point is effectively proof it&#x27;s going to take more than waving &quot;structural editing!&quot; and some excitement at the problem.</div><br/><div id="42616454" class="c"><input type="checkbox" id="c-42616454" checked=""/><div class="controls bullet"><span class="by">kagevf</span><span>|</span><a href="#42611358">root</a><span>|</span><a href="#42614281">parent</a><span>|</span><a href="#42613617">next</a><span>|</span><label class="collapse" for="c-42616454">[-]</label><label class="expand" for="c-42616454">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Creating a language designed for being manipulated this way<p>AFAIK, Lisp wasn&#x27;t created for structural editing, it was just a &quot;happy accident&quot; that it lends itself so well to the technique. Even without the paredit and parinfer plugins, emacs already has good support for structural editing built-in. It reminds me of VIM text objects, but geared directly for Lisp syntax, ie. symbolic expressions.</div><br/></div></div></div></div></div></div></div></div><div id="42613617" class="c"><input type="checkbox" id="c-42613617" checked=""/><div class="controls bullet"><span class="by">like_any_other</span><span>|</span><a href="#42611358">prev</a><span>|</span><a href="#42611452">next</a><span>|</span><label class="collapse" for="c-42613617">[-]</label><label class="expand" for="c-42613617">[5 more]</label></div><br/><div class="children"><div class="content">For structural code editors to thrive, what is needed is a universal, simple, minimal, txt-like format for the AST, so that AST-editors are not locked to a single programming language each.</div><br/><div id="42613649" class="c"><input type="checkbox" id="c-42613649" checked=""/><div class="controls bullet"><span class="by">crowdhailer</span><span>|</span><a href="#42613617">parent</a><span>|</span><a href="#42613656">next</a><span>|</span><label class="collapse" for="c-42613649">[-]</label><label class="expand" for="c-42613649">[2 more]</label></div><br/><div class="children"><div class="content">What requires the format to be text-like?
I&#x27;m not sure I agree with this assertion. I think structural editors need to be language specific so that they can offer higher value edits that might only make sense for specific languages.</div><br/><div id="42613819" class="c"><input type="checkbox" id="c-42613819" checked=""/><div class="controls bullet"><span class="by">like_any_other</span><span>|</span><a href="#42613617">root</a><span>|</span><a href="#42613649">parent</a><span>|</span><a href="#42613656">next</a><span>|</span><label class="collapse" for="c-42613819">[-]</label><label class="expand" for="c-42613819">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Text-like&quot; meaning easy to parse and universally understood. With language-specific (or indeed, all) AST&#x2F;generic tree attributes serialized in a uniform way that does not entirely break parsing if an editor does not understand one of them. I.e. I can edit code even if my editor doesn&#x27;t understand the language and doesn&#x27;t give me syntax highlighting and completion. More, that that &#x27;understanding&#x27; can be factored out of the editor core, as is done with language servers today.</div><br/></div></div></div></div><div id="42613656" class="c"><input type="checkbox" id="c-42613656" checked=""/><div class="controls bullet"><span class="by">zellyn</span><span>|</span><a href="#42613617">parent</a><span>|</span><a href="#42613649">prev</a><span>|</span><a href="#42611452">next</a><span>|</span><label class="collapse" for="c-42613656">[-]</label><label class="expand" for="c-42613656">[2 more]</label></div><br/><div class="children"><div class="content">You might enjoy reading up on EYG and&#x2F;or listening to podcast appearances of the creator…</div><br/><div id="42613679" class="c"><input type="checkbox" id="c-42613679" checked=""/><div class="controls bullet"><span class="by">crowdhailer</span><span>|</span><a href="#42613617">root</a><span>|</span><a href="#42613656">parent</a><span>|</span><a href="#42611452">next</a><span>|</span><label class="collapse" for="c-42613679">[-]</label><label class="expand" for="c-42613679">[1 more]</label></div><br/><div class="children"><div class="content">Indeed.
Here&#x27;s a link to one episode <a href="https:&#x2F;&#x2F;pod.link&#x2F;developer-voices&#x2F;episode&#x2F;e47720e8c6dc3d16603b53081bde0cb1" rel="nofollow">https:&#x2F;&#x2F;pod.link&#x2F;developer-voices&#x2F;episode&#x2F;e47720e8c6dc3d1660...</a></div><br/></div></div></div></div></div></div><div id="42611452" class="c"><input type="checkbox" id="c-42611452" checked=""/><div class="controls bullet"><span class="by">penteract</span><span>|</span><a href="#42613617">prev</a><span>|</span><a href="#42613627">next</a><span>|</span><label class="collapse" for="c-42611452">[-]</label><label class="expand" for="c-42611452">[1 more]</label></div><br/><div class="children"><div class="content">Having made my own forays into making a structural editor, I&#x27;d like to sing the praises of plain text: storing something that has been created by pressing buttons at a keyboard as something very close to the sequence of buttons that have been pressed is a great idea.<p>The magical ability of plain text is to go back in time and ask &quot;what if I pressed a different button a minute ago&#x2F;yesterday&#x2F;last year?&quot;. This lets you see and fix mistaken keypresses, and even shapes the kind of mistakes you can make in a moment of confusion into ones that are quickly fixable.<p>The direct representation of buttons pressed also really helps with teaching&#x2F;learning: With plain text, for mechanical questions on the level of &quot;What buttons do I press to make a program that looks like that?&quot;, the answer is obvious for anyone who knows how to type. Try the editor discussed in the article to appreciate how different answering that question can be in a structural editor. Seeing and explaining how someone got where they did is also straightforward (&quot;you missed a semicolon&quot;, &quot;you misspelt a variable name&quot;). Ideally, those are problems that don&#x27;t happen in a structural editor, but people who press a slightly wrong sequence of buttons will probably still exist.<p>These arguments get much weaker when you aren&#x27;t using a physical keyboard; I think this is the reason the article starts by talking about writing programs on a phone and a TV. In those environments structural editing has much more to offer.</div><br/></div></div><div id="42613627" class="c"><input type="checkbox" id="c-42613627" checked=""/><div class="controls bullet"><span class="by">andrewl</span><span>|</span><a href="#42611452">prev</a><span>|</span><a href="#42612969">next</a><span>|</span><label class="collapse" for="c-42613627">[-]</label><label class="expand" for="c-42613627">[2 more]</label></div><br/><div class="children"><div class="content">I’m always glad to see new work on tools, and amplifications to our capabilities of any sort.<p>I played with Smalltalk, and later Pharo, a bit, but it was years ago. As I recall the editor was always aware of the state of the system. And I <i>think</i> it was at a level beyond what any current IDE can do. While I do not remember if it allowed you to enter invalid code, it was definitely an interesting approach.<p>So I will be following Eyg for sure.</div><br/><div id="42613707" class="c"><input type="checkbox" id="c-42613707" checked=""/><div class="controls bullet"><span class="by">xkriva11</span><span>|</span><a href="#42613627">parent</a><span>|</span><a href="#42612969">next</a><span>|</span><label class="collapse" for="c-42613707">[-]</label><label class="expand" for="c-42613707">[1 more]</label></div><br/><div class="children"><div class="content">In Pharo, the method needs to be syntactically valid to be saved.</div><br/></div></div></div></div><div id="42612969" class="c"><input type="checkbox" id="c-42612969" checked=""/><div class="controls bullet"><span class="by">EdiX</span><span>|</span><a href="#42613627">prev</a><span>|</span><a href="#42612560">next</a><span>|</span><label class="collapse" for="c-42612969">[-]</label><label class="expand" for="c-42612969">[6 more]</label></div><br/><div class="children"><div class="content">I used a structural text editor a while back (technically a structural text editing mode for emacs). I went in completely buying the structural text editing propaganda (it&#x27;s more logical, it will make you more efficient, it&#x27;s the future...) but I eventually found the experience so excruciatingly bad and stupid that I now think the whole endeavour is a complete waste of time, the idea sounds good on paper but there are some fundamental unsolvable problems with it.<p>The problem is that, when you want to make a change to piece of source code you know its current state and you know how you want it to look like at the end. With a normal text editor you will simply make a bunch of changes that turn the text as it into what it should be, it will normally go through a series of invalid states but you don&#x27;t have to think about what those states will be or care about them. With a structural text editor this is impossible, invalid states <i>can not be represented</i> so when you want to make a change to your source code you don&#x27;t just care about the beginning and end state, you also want to find a series of valid states that takes you from the beginning to the end where each one can be reached from the previous one with an editor command.<p>For example, let&#x27;s say you have a function call:<p><pre><code>    (afunc 1 2 3)
</code></pre>
and you want to turn it into a conditional function call based on a flag:<p><pre><code>    (if flag (afunc 1 2 3))
</code></pre>
with a normal text editor you:<p><pre><code>    1. type &quot;(if flag &quot; before the call
    2. type &quot;)&quot; after the call
</code></pre>
It doesn&#x27;t matter the order in which I do these operations or how I move the cursor.<p>With a structural text editor, I have to:<p><pre><code>    1. create a new form before the function
    2. type &quot;if flag&quot;
    3. select the entire function call
    4. cut it
    5. paste it as the first branch of the if
</code></pre>
This is however only possible if the context where the function call currently is allows adding a new node before it (i.e. it&#x27;s inside the equivalent of a lisp progn). If not I&#x27;d have to use a different strategy, for example:<p><pre><code>    1. select the entire function call
    2. use a command to create a node around it
    3. type &quot;if flag&quot;
</code></pre>
I did this for a few months, eventually I realized that I didn&#x27;t want to think about the syntactical validity of the intermediate states my program goes through while I&#x27;m editing it, because they exist for mere seconds, and I didn&#x27;t want to memorize the large palette of commands necessary to create those intermediate states. It was all additional cognitive load that accomplished nothing but satisfy someone&#x27;s esthetic sense that source code should always be in a syntactically valid state.<p>So of the benefits listed in the article:<p>1. &quot;No syntax errors&quot; is actually a major detriment of the structural editing model<p>2. &quot;Better type information&quot; is a lie, all that the structural text editor guarantees you is that the program is syntactically valid, not that it will pass type checking<p>3. &quot;No keywords&quot; is a lie, it&#x27;s only true if you use a new programming language and don&#x27;t store it on disk as text which opens a whole other can of worms (can&#x27;t even read source code without a special text editor, won&#x27;t work with github, won&#x27;t work with any versioning system, won&#x27;t work with grep, can&#x27;t copy paste a chunk of it in an email...)<p>4. &quot;Rich visualization&quot; is an entirely different story from structural text editing but as far as I know nobody has ever shown visual programming to actually provide any kind of tangible benefit<p>5. &quot;Reduced complexity&quot; is the one I give them, yes if you are making a structured text editor you don&#x27;t have to write a fault tolerant parser, it does make <i>your</i> (aka the text editor&#x27;s implementor) life easier<p>Fans of structural text editors usually mention that they will unlock &quot;more powerful refactoring tools&quot; but actually all you need for those to be &quot;unlocked&quot; is a dumb parser and an automatic code formatter, like &quot;go fmt&quot;. Refactoring a function to be inlined into another is still a difficult operation to implement correctly but it isn&#x27;t like the difficult part is running a parser on the source code, it&#x27;s dealing with variable shadowing.</div><br/><div id="42614407" class="c"><input type="checkbox" id="c-42614407" checked=""/><div class="controls bullet"><span class="by">Twisol</span><span>|</span><a href="#42612969">parent</a><span>|</span><a href="#42620307">next</a><span>|</span><label class="collapse" for="c-42614407">[-]</label><label class="expand" for="c-42614407">[2 more]</label></div><br/><div class="children"><div class="content">I agree with you on basically all points. But to play devil&#x27;s advocate, I&#x27;ve often found myself doing something <i>like</i> structured editing when intentionally, carefully refactoring existing code. In those instances, it really matters to me that the programs at the start and at the end are equivalent, or at least equivalent up to certain semantic conditions (for instance: preconditions, things assumed by the domain, or cases not meant to be handled in the subject code). Since making a complex refactor in one step doesn&#x27;t make me very confident that I got it right, I usually carefully perform a series of small transformations such that, at every step, I have something that <i>manifestly</i> behaves the same as the program before that step.<p>This seems sufficiently like the structured programming model (small edits forming a path of &quot;valid&quot; programs from start to finish) that I wonder if something similar to structured programming might be genuinely useful in this niche. That said, these refactors aren&#x27;t simple atomic tree edits; they&#x27;re more like a small cluster of tree edits that together preserve meaning. So there&#x27;s a difference in content, even if the &quot;small edits that form a path through programs with X property&quot; mental model is the same.</div><br/><div id="42616361" class="c"><input type="checkbox" id="c-42616361" checked=""/><div class="controls bullet"><span class="by">EdiX</span><span>|</span><a href="#42612969">root</a><span>|</span><a href="#42614407">parent</a><span>|</span><a href="#42620307">next</a><span>|</span><label class="collapse" for="c-42616361">[-]</label><label class="expand" for="c-42616361">[1 more]</label></div><br/><div class="children"><div class="content">For Go there&#x27;s a program called rf (<a href="https:&#x2F;&#x2F;pkg.go.dev&#x2F;rsc.io&#x2F;rf" rel="nofollow">https:&#x2F;&#x2F;pkg.go.dev&#x2F;rsc.io&#x2F;rf</a>) that&#x27;s along those lines. It isn&#x27;t worked on as much as I wish it was.</div><br/></div></div></div></div><div id="42620307" class="c"><input type="checkbox" id="c-42620307" checked=""/><div class="controls bullet"><span class="by">k_g_b_</span><span>|</span><a href="#42612969">parent</a><span>|</span><a href="#42614407">prev</a><span>|</span><a href="#42613201">next</a><span>|</span><label class="collapse" for="c-42620307">[-]</label><label class="expand" for="c-42620307">[1 more]</label></div><br/><div class="children"><div class="content">You missed all the cursor movements (whether by mouse&#x2F;keyboard) needed for the plain text editor:<p>1. Position cursor before the call from wherever it is right now (might be quick because your editor already allows some form of structure in it&#x27;s movement commands: words, parentheses, visual jumps, etc or you might need 10+ presses of the left arrow)
2. Type &quot;(if flag &quot;
3. Position cursor after the call - maybe just a press of &quot;End&quot;&#x2F;$&#x2F;shift-A&#x2F;...
4. Type &quot;)&quot;<p>Your two ways of structural editing seems to be an artifact of Lisp - I agree that most programming languages have issues when editing structurally - especially when using an abstract&#x2F;concrete Syntax tree as the structure as compared to a non-syntactic representation (e.g. expression graphs where only types need to match).<p>So when this weird difference does not exist, you can always use the second strategy you listed. This already includes necessary cursor movements&#x2F;selections and is one step shorter than the commands necessary for textual editing.<p>I think that any editor will always have to deal with partial programs - it&#x27;s just the holes&#x2F;errors are in different parts. The right UX can make dealing with that possible, just as auto formatting, syntax highlighting, inline type display, etc help somewhat deal with parts already in existing editing systems.<p>I think there&#x27;s plenty of ways to make the UX work - for a programming language and ecosystem designed for it. So I think that structural programming should be a complete environment - programming language, editor with a good editing meta-language mapped to keys&#x2F;auto complete&#x2F;etc, language server equivalent, structural version control, build system, code sharing&#x2F;review (diffs!) and legacy interface to textual tools. There&#x27;ll be a tipping point where one has enough benefits from the structure in each of these to overcome the unavailability of many existing tools like grep&#x2F;etc. A single structural editor experiment likely isn&#x27;t at that tipping point unless the UX is really a significant improvement like github.com&#x2F;cursorless-dev&#x2F;cursorless is for many folks.</div><br/></div></div><div id="42613201" class="c"><input type="checkbox" id="c-42613201" checked=""/><div class="controls bullet"><span class="by">herrington_d</span><span>|</span><a href="#42612969">parent</a><span>|</span><a href="#42620307">prev</a><span>|</span><a href="#42612560">next</a><span>|</span><label class="collapse" for="c-42613201">[-]</label><label class="expand" for="c-42613201">[2 more]</label></div><br/><div class="children"><div class="content">This is a pretty fair comment. I wonder how structural editing figures out things like formatting&#x2F;searching&#x2F;diffing and copy&#x2F;paste across different editors.</div><br/><div id="42613970" class="c"><input type="checkbox" id="c-42613970" checked=""/><div class="controls bullet"><span class="by">EdiX</span><span>|</span><a href="#42612969">root</a><span>|</span><a href="#42613201">parent</a><span>|</span><a href="#42612560">next</a><span>|</span><label class="collapse" for="c-42613970">[-]</label><label class="expand" for="c-42613970">[1 more]</label></div><br/><div class="children"><div class="content">Those are all orthogonal concerns to the way the text editor behaves. You could have a structural text editor operate on plain text files and a dumb text editor operate on AST, you can do plain text diffs of ASTs or diff AST parsed from plain text files, etc etc...<p>Some of these have existed historically (or even still exist).<p>Paredit-mode is a structural text editor that saves and loads plain text files, Smalltalk was typically implemented as a dumb text editor but then code was saved as compiled binaries (which meant you couldn&#x27;t save your functions if they weren&#x27;t syntactically correct but you could have unsaved syntactically broken functions), Mathematica represents its code in a weird format that might as well be binary but copy&#x2F;paste converts to plain text, there&#x27;s one git plugin (don&#x27;t remember the name right now) that does syntax aware diffs even though git deals with plain text...</div><br/></div></div></div></div></div></div><div id="42612560" class="c"><input type="checkbox" id="c-42612560" checked=""/><div class="controls bullet"><span class="by">perlcommunity</span><span>|</span><a href="#42612969">prev</a><span>|</span><a href="#42613356">next</a><span>|</span><label class="collapse" for="c-42612560">[-]</label><label class="expand" for="c-42612560">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.jgrasp.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.jgrasp.org&#x2F;</a></div><br/></div></div><div id="42613356" class="c"><input type="checkbox" id="c-42613356" checked=""/><div class="controls bullet"><span class="by">herrington_d</span><span>|</span><a href="#42612560">prev</a><span>|</span><a href="#42611070">next</a><span>|</span><label class="collapse" for="c-42613356">[-]</label><label class="expand" for="c-42613356">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Better type information. Because the program is always in a valid state the type checker can always run and give meaningful feedback.<p>Note that programs can be syntactically well-formed but ill-typed. For example `let x = true + 1` has valid syntax but produces an &quot;undefined&quot; type for the variable `x`, if the type system does not support type error recovery.<p>A quote from the great paper from POPL 2024, <a href="https:&#x2F;&#x2F;hazel.org&#x2F;papers&#x2F;marking-popl24.pdf" rel="nofollow">https:&#x2F;&#x2F;hazel.org&#x2F;papers&#x2F;marking-popl24.pdf</a><p>&gt; If a type error appears _anywhere_, the program is formally meaningless _everywhere_</div><br/><div id="42613611" class="c"><input type="checkbox" id="c-42613611" checked=""/><div class="controls bullet"><span class="by">crowdhailer</span><span>|</span><a href="#42613356">parent</a><span>|</span><a href="#42611070">next</a><span>|</span><label class="collapse" for="c-42613611">[-]</label><label class="expand" for="c-42613611">[2 more]</label></div><br/><div class="children"><div class="content">The EYG type system does support recovery, so you will get multiple type errors if that&#x27;s the case in the program.</div><br/><div id="42617023" class="c"><input type="checkbox" id="c-42617023" checked=""/><div class="controls bullet"><span class="by">herrington_d</span><span>|</span><a href="#42613356">root</a><span>|</span><a href="#42613611">parent</a><span>|</span><a href="#42611070">next</a><span>|</span><label class="collapse" for="c-42617023">[-]</label><label class="expand" for="c-42617023">[1 more]</label></div><br/><div class="children"><div class="content">My point is that type error recovery is the property of the type system. Not the property of structural code editor.</div><br/></div></div></div></div></div></div><div id="42611070" class="c"><input type="checkbox" id="c-42611070" checked=""/><div class="controls bullet"><span class="by">norir</span><span>|</span><a href="#42613356">prev</a><span>|</span><a href="#42613846">next</a><span>|</span><label class="collapse" for="c-42611070">[-]</label><label class="expand" for="c-42611070">[1 more]</label></div><br/><div class="children"><div class="content">I think structural editors are a great feature to add on top of a language with a definite textual representation. If you can pretty print the ast (as the fib example shows), you should generally be able to parse the output to generate the structured output.</div><br/></div></div><div id="42613846" class="c"><input type="checkbox" id="c-42613846" checked=""/><div class="controls bullet"><span class="by">tcoff91</span><span>|</span><a href="#42611070">prev</a><span>|</span><a href="#42611152">next</a><span>|</span><label class="collapse" for="c-42613846">[-]</label><label class="expand" for="c-42613846">[2 more]</label></div><br/><div class="children"><div class="content">Haven&#x27;t lisp coders been doing this forever with emacs?</div><br/><div id="42617603" class="c"><input type="checkbox" id="c-42617603" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#42613846">parent</a><span>|</span><a href="#42611152">next</a><span>|</span><label class="collapse" for="c-42617603">[-]</label><label class="expand" for="c-42617603">[1 more]</label></div><br/><div class="children"><div class="content">see for example a structure editor for Lisp, ca. 1967, described by L Peter Deutsch:<p><a href="https:&#x2F;&#x2F;citeseerx.ist.psu.edu&#x2F;document?repid=rep1&amp;type=pdf&amp;doi=028a167a1c72aa817d9d5b8aa6e9099a75bd454f" rel="nofollow">https:&#x2F;&#x2F;citeseerx.ist.psu.edu&#x2F;document?repid=rep1&amp;type=pdf&amp;d...</a></div><br/></div></div></div></div><div id="42611152" class="c"><input type="checkbox" id="c-42611152" checked=""/><div class="controls bullet"><span class="by">criddell</span><span>|</span><a href="#42613846">prev</a><span>|</span><a href="#42612079">next</a><span>|</span><label class="collapse" for="c-42611152">[-]</label><label class="expand" for="c-42611152">[3 more]</label></div><br/><div class="children"><div class="content">Is it far enough along where you could work on the code editor <i>in</i> the code editor?</div><br/><div id="42611451" class="c"><input type="checkbox" id="c-42611451" checked=""/><div class="controls bullet"><span class="by">bennythomsson</span><span>|</span><a href="#42611152">parent</a><span>|</span><a href="#42611907">next</a><span>|</span><label class="collapse" for="c-42611451">[-]</label><label class="expand" for="c-42611451">[1 more]</label></div><br/><div class="children"><div class="content">As the videos show, there are still a few usability issues. Full-screen switching somewhere else just to enter a name for example doesn&#x27;t get you very far.<p>But there is not much missing and I like the POC!</div><br/></div></div><div id="42611907" class="c"><input type="checkbox" id="c-42611907" checked=""/><div class="controls bullet"><span class="by">crowdhailer</span><span>|</span><a href="#42611152">parent</a><span>|</span><a href="#42611451">prev</a><span>|</span><a href="#42612079">next</a><span>|</span><label class="collapse" for="c-42611907">[-]</label><label class="expand" for="c-42611907">[1 more]</label></div><br/><div class="children"><div class="content">The code editor is for the EYG language and implemented in Gleam. So that&#x27;s a blocker. The editor is probably far enough along to have a crack at it by EYG would need some UI or web library so that EYG was able to build an editor.</div><br/></div></div></div></div><div id="42612079" class="c"><input type="checkbox" id="c-42612079" checked=""/><div class="controls bullet"><span class="by">cbm-vic-20</span><span>|</span><a href="#42611152">prev</a><span>|</span><a href="#42611557">next</a><span>|</span><label class="collapse" for="c-42612079">[-]</label><label class="expand" for="c-42612079">[2 more]</label></div><br/><div class="children"><div class="content">This is neat.<p>I wonder if this could be generalized to other languages with Tree-Sitter and LSPs. It could be helpful for programmers with accessibilty issues, among many other use cases.</div><br/><div id="42612130" class="c"><input type="checkbox" id="c-42612130" checked=""/><div class="controls bullet"><span class="by">crowdhailer</span><span>|</span><a href="#42612079">parent</a><span>|</span><a href="#42611557">next</a><span>|</span><label class="collapse" for="c-42612130">[-]</label><label class="expand" for="c-42612130">[1 more]</label></div><br/><div class="children"><div class="content">It could be in principle. EYG was developed along with the editor so that has effected the design of the AST.
Ideally if a useful&#x2F;powerful&#x2F;pleasant&#x2F;intuitive structured editing experience was found for EYG (and it&#x27;s minimal AST) then it would be proven to work and so putting the effort into doing for a program with a more complex AST would be worth the effort.</div><br/></div></div></div></div><div id="42611557" class="c"><input type="checkbox" id="c-42611557" checked=""/><div class="controls bullet"><span class="by">daveloyall</span><span>|</span><a href="#42612079">prev</a><span>|</span><a href="#42610983">next</a><span>|</span><label class="collapse" for="c-42611557">[-]</label><label class="expand" for="c-42611557">[1 more]</label></div><br/><div class="children"><div class="content">Since this is a post about a programming tool, I expected links to repositories.  I like to pick up a tool and turn it around in my hands before I decide if it is a good tool or not.</div><br/></div></div><div id="42610983" class="c"><input type="checkbox" id="c-42610983" checked=""/><div class="controls bullet"><span class="by">datadrivenangel</span><span>|</span><a href="#42611557">prev</a><span>|</span><a href="#42610947">next</a><span>|</span><label class="collapse" for="c-42610983">[-]</label><label class="expand" for="c-42610983">[2 more]</label></div><br/><div class="children"><div class="content">In the data science space, people have been going back and forth on the benefits of Notebooks, which seem very similar, and were historically stored as json under the hood.<p>There are many many benefits to plain text.</div><br/><div id="42611012" class="c"><input type="checkbox" id="c-42611012" checked=""/><div class="controls bullet"><span class="by">jtwaleson</span><span>|</span><a href="#42610983">parent</a><span>|</span><a href="#42610947">next</a><span>|</span><label class="collapse" for="c-42611012">[-]</label><label class="expand" for="c-42611012">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think notebooks are very similar to be honest. The notebooks still emit code (typically python) which is then interpreted as usual.</div><br/></div></div></div></div><div id="42610947" class="c"><input type="checkbox" id="c-42610947" checked=""/><div class="controls bullet"><span class="by">naikrovek</span><span>|</span><a href="#42610983">prev</a><span>|</span><a href="#42611183">next</a><span>|</span><label class="collapse" for="c-42610947">[-]</label><label class="expand" for="c-42610947">[7 more]</label></div><br/><div class="children"><div class="content">I have wanted something like this for so long that I can’t remember when I started.<p>Strongly coupling source code to plain text is a lost opportunity to improve tooling.</div><br/><div id="42611179" class="c"><input type="checkbox" id="c-42611179" checked=""/><div class="controls bullet"><span class="by">norir</span><span>|</span><a href="#42610947">parent</a><span>|</span><a href="#42611106">next</a><span>|</span><label class="collapse" for="c-42611179">[-]</label><label class="expand" for="c-42611179">[1 more]</label></div><br/><div class="children"><div class="content">I disagree that plain text is an obstacle towards better tooling. You can do most of what the author describes with direct plain text edits pipelined into an analysis program.<p>But I also think that the ux the author presents is undesirable. When writing new code, one must pass through a phase of broken code to reach the working code. I would not want an editor blocking me from typing a word that isn&#x27;t yet defined but I do want it to notify me instantly that there is a problem.<p>I also struggled to understand the use case for the mouse based ux. I am typing this comment on an iphone mini and would much rather write raw text on its keyboard than use the clicking interface shown in the fibonacci example.</div><br/></div></div><div id="42611106" class="c"><input type="checkbox" id="c-42611106" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#42610947">parent</a><span>|</span><a href="#42611179">prev</a><span>|</span><a href="#42617271">next</a><span>|</span><label class="collapse" for="c-42611106">[-]</label><label class="expand" for="c-42611106">[1 more]</label></div><br/><div class="children"><div class="content">The emacs mode paredit is basically structural editing for lisp code (and some of its more modern competitors like Smartparens support other languages too, but not as well as Lisp). It&#x27;s great.</div><br/></div></div><div id="42617271" class="c"><input type="checkbox" id="c-42617271" checked=""/><div class="controls bullet"><span class="by">vidarh</span><span>|</span><a href="#42610947">parent</a><span>|</span><a href="#42611106">prev</a><span>|</span><a href="#42610995">next</a><span>|</span><label class="collapse" for="c-42617271">[-]</label><label class="expand" for="c-42617271">[1 more]</label></div><br/><div class="children"><div class="content">The problem is communicating <i>about</i> code.<p>Almost every visual &#x2F; structural programming language attempts strands on how you talk about the code, and e-mail people about the code, and write about the code, or even how you efficiently input it.<p>It&#x27;s a multi-decade-long problem with <i>many</i> attempts.</div><br/></div></div><div id="42610995" class="c"><input type="checkbox" id="c-42610995" checked=""/><div class="controls bullet"><span class="by">jtwaleson</span><span>|</span><a href="#42610947">parent</a><span>|</span><a href="#42617271">prev</a><span>|</span><a href="#42611183">next</a><span>|</span><label class="collapse" for="c-42610995">[-]</label><label class="expand" for="c-42610995">[3 more]</label></div><br/><div class="children"><div class="content">Same! I think we need to free &quot;code&quot; from files, characters, tabs&#x2F;spaces and variable names. Put millions of ASTs in a database. Imagine how much cheaper and better AI code assistants can be if they can only generate valid code with their &quot;next token&quot;.</div><br/><div id="42611562" class="c"><input type="checkbox" id="c-42611562" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#42610947">root</a><span>|</span><a href="#42610995">parent</a><span>|</span><a href="#42611994">next</a><span>|</span><label class="collapse" for="c-42611562">[-]</label><label class="expand" for="c-42611562">[1 more]</label></div><br/><div class="children"><div class="content">At some point the AST needs to be serialized as bytes on disk. In the big picture, the cost of having that serialization format be also human readable is relatively small as long as the syntax is designed to be sane (i.e. not c++&#x2F;perl)</div><br/></div></div><div id="42611994" class="c"><input type="checkbox" id="c-42611994" checked=""/><div class="controls bullet"><span class="by">norman784</span><span>|</span><a href="#42610947">root</a><span>|</span><a href="#42610995">parent</a><span>|</span><a href="#42611562">prev</a><span>|</span><a href="#42611183">next</a><span>|</span><label class="collapse" for="c-42611994">[-]</label><label class="expand" for="c-42611994">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Put millions of ASTs in a database.<p>That&#x27;s basically what unison does, they store the source code in binary format in an sqlite database.</div><br/></div></div></div></div></div></div><div id="42611183" class="c"><input type="checkbox" id="c-42611183" checked=""/><div class="controls bullet"><span class="by">hokkos</span><span>|</span><a href="#42610947">prev</a><span>|</span><a href="#42611072">next</a><span>|</span><label class="collapse" for="c-42611183">[-]</label><label class="expand" for="c-42611183">[4 more]</label></div><br/><div class="children"><div class="content">I remember coding on my casio scientific calculator, you could only input full keyword by selecting from a menu, it was quick and you couldn&#x27;t make syntax errors.</div><br/><div id="42611445" class="c"><input type="checkbox" id="c-42611445" checked=""/><div class="controls bullet"><span class="by">nxobject</span><span>|</span><a href="#42611183">parent</a><span>|</span><a href="#42611619">next</a><span>|</span><label class="collapse" for="c-42611445">[-]</label><label class="expand" for="c-42611445">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps it was tokenising commands to save memory. Did your calculator have keystroke programming&#x2F;some form of programming?</div><br/></div></div><div id="42611619" class="c"><input type="checkbox" id="c-42611619" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#42611183">parent</a><span>|</span><a href="#42611445">prev</a><span>|</span><a href="#42611072">next</a><span>|</span><label class="collapse" for="c-42611619">[-]</label><label class="expand" for="c-42611619">[2 more]</label></div><br/><div class="children"><div class="content">The Sinclair Spectrum Z80-based home computer had a keyboard  that had all its BASIC keywords on the keyboard. I can&#x27;t say I liked it, particularly as the keyboard was a very horrible rubber affair.</div><br/><div id="42611678" class="c"><input type="checkbox" id="c-42611678" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#42611183">root</a><span>|</span><a href="#42611619">parent</a><span>|</span><a href="#42611072">next</a><span>|</span><label class="collapse" for="c-42611678">[-]</label><label class="expand" for="c-42611678">[1 more]</label></div><br/><div class="children"><div class="content">People are now recreating them specifically to have the same feel out of nostalgia. I actually liked them as a kid; it was so easy to write impressive (for the time) graphical programs with BASIC without remembering all these pesky english words (I am not from an English speaking country).</div><br/></div></div></div></div></div></div><div id="42611072" class="c"><input type="checkbox" id="c-42611072" checked=""/><div class="controls bullet"><span class="by">mebazaa</span><span>|</span><a href="#42611183">prev</a><span>|</span><a href="#42611180">next</a><span>|</span><label class="collapse" for="c-42611072">[-]</label><label class="expand" for="c-42611072">[4 more]</label></div><br/><div class="children"><div class="content">My first thought: maybe competitive programmers could find it useful, if it’s a way to reduce the amount of key presses needed to write their code? (At the very least, that’s a crowd that would be motivated enough to get accustomed to that way of writing code.)</div><br/><div id="42611464" class="c"><input type="checkbox" id="c-42611464" checked=""/><div class="controls bullet"><span class="by">poutsku</span><span>|</span><a href="#42611072">parent</a><span>|</span><a href="#42611114">next</a><span>|</span><label class="collapse" for="c-42611464">[-]</label><label class="expand" for="c-42611464">[2 more]</label></div><br/><div class="children"><div class="content">Every year when I participate in advent of code, I have this thought: &quot;wouldn&#x27;t it be great to solve these problems directly from my phone?&quot; (The puzzles unlock quite early morning in my timezone and opening my laptop at that time somehow annoys me.)<p>I have wondered many times if some structural editor with a bunch of high-level library methods (Dijkstra&#x27;s, for instance) would actually give a good&#x2F;fast experience for most days. I haven&#x27;t had the time or interest yet to try and build something yet. But perhaps I should.</div><br/><div id="42611961" class="c"><input type="checkbox" id="c-42611961" checked=""/><div class="controls bullet"><span class="by">crowdhailer</span><span>|</span><a href="#42611072">root</a><span>|</span><a href="#42611464">parent</a><span>|</span><a href="#42611114">next</a><span>|</span><label class="collapse" for="c-42611961">[-]</label><label class="expand" for="c-42611961">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d love to get this to the point where add your own keybindings to structural edits, potentially very involved ones.
It&#x27;s superficially not very different to a combination of vim macros, auto completes or templates in other editors but I think the end result could be interesting as the units of change would be more meaningful.
I think it&#x27;s the same benefit of a hygienic macro system vs a source file manipulating version of meta programming.</div><br/></div></div></div></div></div></div><div id="42611180" class="c"><input type="checkbox" id="c-42611180" checked=""/><div class="controls bullet"><span class="by">rzwitserloot</span><span>|</span><a href="#42611072">prev</a><span>|</span><a href="#42611128">next</a><span>|</span><label class="collapse" for="c-42611180">[-]</label><label class="expand" for="c-42611180">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been toying with the idea of making something very very much lik this, but, for an existing language. Which makes it far, far more complicated; I&#x27;m sure various aspects of the design of whatever language one would build this for are needlessly convoluted due to not having been designed with this kind of editing in mind.<p>A few concerns:<p>* As developers, our &#x27;world&#x27; is so defined by text, we textify things that aren&#x27;t: We write marked up documentation in plain text (HTML, markdown, etc) and we despise using tools like LibreOffice to write that sort of thing, and we even &#x27;draw&#x27; helpful graphs in `.dot` files. We do this for a good reason: It &#x27;works&#x27; with our other tools. git itself, and the cavalcade of git-understanding frontend version control systems, are excellent at showing you diffs between textual representations. They don&#x27;t do &#x27;diffs between these 2 png files&#x27; or &#x27;diffs between these two .docx files&#x27; well or at all.<p>Hence, these projects either balloon, or need a pragmatic take. Either you staple &#x27;also reinvent git&#x27; onto the project (and in passing you are increasing the hurdle to adopt or try out this stuff for any interested folk), or you think about how to adapt the idea to fit existing practices.<p>In this specific case the latter seems like the obvious answer: The way to store the program is as a file that, if opened in a text editor, looks just like it. But, I _can_ edit files in git and it looks like a text file even if it really isn&#x27;t; so what happens if I edit an eyg file with a text editor? How &#x27;perfect&#x27; must it be? What happens if in hand-editing the file I added some whitespace that shouldn&#x27;t have been there as per the canonical storage rule?<p>These are all easily solvable details, of course. But it&#x27;s where my brain went. I&#x27;m pretty sure the correct answer is &#x27;the source file is still text and is still readable; it&#x27;s just that the language has some extreme style requirements (think about a language that has no line continuation facilities whatsoever, long lines will just have to be long lines, and dictates exactly how many tabs you can insert; indenting with spaces is not allowed at all, that sort of thing). This is fine because the language is meant to be read as plain text but only edited with the structural editor.<p>* I often try to think how it would be if I was doing my programming work with a structural editor. From time to time I do things that seem blatantly annoying if I only had a structural editor. Where I really _want_ to dip into syntactically utterly invalid gobbledygook because I&#x27;m doing some text edits which will get back to valid code but I go through invalid code. For example, block-based copy&#x2F;pasting (block = multiselect&#x2F;multicursor). I&#x27;m having a hard time seeing how that would work in a structural editor but I use it from time to time. It feels like a structural editor can hopefully come up with alternatives for all the use cases but I&#x27;m not sure. Should there instead be a &#x27;fallback&#x27; option where your source file turns into raw text mode and your edit functionality is like any plain jane text editor, you do your text-based transformations and then when done exit that mode, at which point the structural editor reparses what you have. I think that&#x27;s right but it means the language does, actually, need all the bells and whistles after all: A Parser, an AST, good error handling for syntax errors, and so forth.</div><br/><div id="42614772" class="c"><input type="checkbox" id="c-42614772" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#42611180">parent</a><span>|</span><a href="#42611128">next</a><span>|</span><label class="collapse" for="c-42614772">[-]</label><label class="expand" for="c-42614772">[1 more]</label></div><br/><div class="children"><div class="content">&gt;They don&#x27;t do &#x27;diffs between these 2 png files&#x27; or &#x27;diffs between these two .docx files&#x27; well or at all.<p>I recently added an option to my gitconfig to allow diffing .docx files. My ugly 2-minute hack with Git is still miles ahead of the built-in Word history tracking. Ironically, to facilitate the diff, .docx is internally converted to text, once again showing how powerful it is to have a common denominator.<p>On the topic of diffs, I think we still have not exhausted the full potential of text-based formats. Just because the inputs are text streams, doesn&#x27;t mean the diff algorithm has to be dumb. As long as it emits readable output, it doesn&#x27;t matter what it is doing internally (like parsing C code, detecting renames, etc.)</div><br/></div></div></div></div><div id="42612230" class="c"><input type="checkbox" id="c-42612230" checked=""/><div class="controls bullet"><span class="by">crabbone</span><span>|</span><a href="#42611128">prev</a><span>|</span><label class="collapse" for="c-42612230">[-]</label><label class="expand" for="c-42612230">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Unlike traditional text-based editors, these tools treat code as a structured tree rather than a flat sequence of characters.<p>This is such an obvious lie... Of course, even the disastrously bad editors like VSCode or IntelliJ tools understand code to have structure and allow interaction with that structure.  Hell, even text editors not intended to deal with code will usually be able to deal with some structure, like identifying words, lines, perhaps even paragraphs and operating on them.<p>&gt; No syntax errors. Zero time is spent on missing quotes, semi-colons or other details.<p>Usually paid for by inability to copy and paste chunks of code... not sure if it&#x27;s worth the price.<p>&gt; Better type information. Because the program is always in a valid state the type checker can always run and give meaningful feedback.<p>Why would you want to run typechecker <i>all the time?</i>  What&#x27;s the benefit?  I run it when I&#x27;m interested in the results... otherwise it&#x27;s just noise.  By the time I&#x27;m interested in results, I&#x27;d get code in a decent enough shape to compile, so it won&#x27;t be a problem.<p>Other known downsides of this approach: having to access the code in places where the editor isn&#x27;t available, s.a. reading diffs, debugging, running third-party tools unaware of structured format (which, given how our programming practices have developed, will be inconsistent between versions and platforms).<p>All in all, I&#x27;ve seen these attempts multiple times before, and it always looks like the benefits simply aren&#x27;t worth the effort.  Or, maybe, too many stars need to align in order for this to actually become really useful in the day-to-day programming work, and so it doesn&#x27;t happen because of some circular dependency where the tools won&#x27;t be built, until the product is good enough to use, but the product is never good enough to use because there aren&#x27;t any tools?</div><br/><div id="42616191" class="c"><input type="checkbox" id="c-42616191" checked=""/><div class="controls bullet"><span class="by">lsaferite</span><span>|</span><a href="#42612230">parent</a><span>|</span><label class="collapse" for="c-42616191">[-]</label><label class="expand" for="c-42616191">[1 more]</label></div><br/><div class="children"><div class="content">&gt; disastrously bad editors like VSCode or IntelliJ tools<p>I&#x27;m curious, what code editor(s) do you hold in high esteem?</div><br/></div></div></div></div></div></div></div></div></div></body></html>