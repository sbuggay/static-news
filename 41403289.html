<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1725354074872" as="style"/><link rel="stylesheet" href="styles.css?v=1725354074872"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://yosefk.com/blog/profiling-with-ctrl-c.html">Profiling with Ctrl-C</a> <span class="domain">(<a href="https://yosefk.com">yosefk.com</a>)</span></div><div class="subtext"><span>jstanley</span> | <span>19 comments</span></div><br/><div><div id="41431118" class="c"><input type="checkbox" id="c-41431118" checked=""/><div class="controls bullet"><span class="by">exmadscientist</span><span>|</span><a href="#41432714">next</a><span>|</span><label class="collapse" for="c-41431118">[-]</label><label class="expand" for="c-41431118">[3 more]</label></div><br/><div class="children"><div class="content">My favorite hack along these lines was to put a timer&#x2F;ISR on an embedded system that did nothing more than crawl up the stack frame the two or three addresses that the ISR used (yep, it was really just as dumb as [sp + 8] or whatever), and then dump that address to the serial terminal every second or so.<p>You can fix a lot of stupid problems that way. (And most problems are stupid.) Yes, yes, a real profiler would be better, but if you don&#x27;t have the fancy tools because your employer doesn&#x27;t buy you such things, and it&#x27;s a primitive and cruddy embedded system so there&#x27;s no obvious better way to do it, and you built this horrible hack <i>right now</i> and... hey, the hack solved the problem, and what do you know? it keeps on solving things....</div><br/><div id="41432773" class="c"><input type="checkbox" id="c-41432773" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#41431118">parent</a><span>|</span><a href="#41431693">next</a><span>|</span><label class="collapse" for="c-41432773">[-]</label><label class="expand" for="c-41432773">[1 more]</label></div><br/><div class="children"><div class="content">&gt; My favorite hack along these lines was to put a timer&#x2F;ISR on an embedded system that did nothing more than crawl up the stack frame the two or three addresses that the ISR used (yep, it was really just as dumb as [sp + 8] or whatever), and then dump that address to the serial terminal every second or so.<p>Did the same, but added a stack canary to tell if I overflowed, and wrote my call-stack results to a hardcoded address at the very end of memory (last 32 bytes, IIRC). When the chip reset, in addition to the reset flags (brownout, etc), I could peek that memory to see what the last addresses in the callstack were.<p>Helped immensely in figuring out a transient bug (device resets) which was hard to repro.</div><br/></div></div><div id="41431693" class="c"><input type="checkbox" id="c-41431693" checked=""/><div class="controls bullet"><span class="by">bgirard</span><span>|</span><a href="#41431118">parent</a><span>|</span><a href="#41432773">prev</a><span>|</span><a href="#41432714">next</a><span>|</span><label class="collapse" for="c-41431693">[-]</label><label class="expand" for="c-41431693">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Yes, yes, a real profiler would be better<p>As someone who wrote several profilers for a living... that is a real profiler.</div><br/></div></div></div></div><div id="41432714" class="c"><input type="checkbox" id="c-41432714" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#41431118">prev</a><span>|</span><a href="#41406331">next</a><span>|</span><label class="collapse" for="c-41432714">[-]</label><label class="expand" for="c-41432714">[1 more]</label></div><br/><div class="children"><div class="content">&gt; what do you know, there’s one billion stack frames from the nlohmann JSON parser, I guess it all gets inlined in the release build;<p>My guess would be that it&#x27;s because tail-call optimisation only happens in -O2 and above.<p>Parsing recursively is frequently the cleanest way to implement a parser of tree-structured input, after all.<p>If you&#x27;re doing anything recursively, it makes sense to slightly restructure the  recursive call to be the last call in the scope, so that TCO can be applied.</div><br/></div></div><div id="41406331" class="c"><input type="checkbox" id="c-41406331" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#41432714">prev</a><span>|</span><a href="#41431182">next</a><span>|</span><label class="collapse" for="c-41406331">[-]</label><label class="expand" for="c-41406331">[1 more]</label></div><br/><div class="children"><div class="content">For something more systematic&#x2F;reproducible, it&#x27;s possible to use rr[1] to record the program, and in a replay run to the end (or whatever boundaries you care about), run &quot;when-ticks&quot;, and do various &quot;seek-ticks 123456789&quot; below that number to seek to various points in the recording.<p>I&#x27;ve made a thing[2] that can display that within a visual timeline (interpolated between ticks of the nearest syscalls&#x2F;events, which do have known real time), essentially giving a sampling flamegraph that can be arbitrarily zoomed-in, with the ability to interact with it at any point in gdb.<p>Though this is not without its issues - rr&#x27;s ticks count retired conditional branches, so a loop with a 200-instruction body takes up the same amount of ticks, and thus visual space, as one with a 5-instruction body; and of course more low-level things like mispredicts&#x2F;stalls&#x2F;IPC are entirely lost.<p>[1]: <a href="https:&#x2F;&#x2F;rr-project.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;rr-project.org&#x2F;</a><p>[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;dzaima&#x2F;grr">https:&#x2F;&#x2F;github.com&#x2F;dzaima&#x2F;grr</a></div><br/></div></div><div id="41431182" class="c"><input type="checkbox" id="c-41431182" checked=""/><div class="controls bullet"><span class="by">Cybergenik</span><span>|</span><a href="#41406331">prev</a><span>|</span><a href="#41432547">next</a><span>|</span><label class="collapse" for="c-41431182">[-]</label><label class="expand" for="c-41431182">[1 more]</label></div><br/><div class="children"><div class="content">&gt;<i>Apparently gcc generates some DWARF data that gdb is slow to handle. The GNU linker fixes this data, so that gdb doesn’t end up handling it slowly. LLD refuses to emulate this behavior of the GNU linker, because it’s gcc’s fault to have produced that DWARF data in the first place. And gdb refuses to handle LLD’s output efficiently, because it’s LLD’s fault to not have handled gcc’s output the way the GNU linker does. So I just remove -ggdb3 - it gives you a bit richer debug info, but it’s not worth the slower linking with gold instead of LLD, nor the slowdown in gdb that you get with LLD. And everyone links happily ever after.</i><p>lol, it&#x27;s a story as old as time. The infinite loop of ego entrenched developers not wanting to change something out of some trivial inconsequential disagreement. The bike shed will be built my way!</div><br/></div></div><div id="41432547" class="c"><input type="checkbox" id="c-41432547" checked=""/><div class="controls bullet"><span class="by">ivoras</span><span>|</span><a href="#41431182">prev</a><span>|</span><a href="#41432654">next</a><span>|</span><label class="collapse" for="c-41432547">[-]</label><label class="expand" for="c-41432547">[2 more]</label></div><br/><div class="children"><div class="content">Speaking of keyboard shortcuts, I miss BSD&#x27;s Ctrl-T and SIGINFO. It often helped to see if a process was hung.</div><br/><div id="41432664" class="c"><input type="checkbox" id="c-41432664" checked=""/><div class="controls bullet"><span class="by">milianw</span><span>|</span><a href="#41432547">parent</a><span>|</span><a href="#41432654">next</a><span>|</span><label class="collapse" for="c-41432664">[-]</label><label class="expand" for="c-41432664">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know exactly what these BSD things did, but there is a super easy way nowadays to get the stack for any process:<p><pre><code>    eu-stack -i -p $(pidof ...)
</code></pre>
Thanks to debuginfod this will even give you good backtraces right away (at the cost of some initial delay to load the data from the web, consecutive runs are fast). If you get a &quot;permission denied&quot; error, you probably need to tweak kernel.yama.ptrace_scope=0</div><br/></div></div></div></div><div id="41432654" class="c"><input type="checkbox" id="c-41432654" checked=""/><div class="controls bullet"><span class="by">kreyenborgi</span><span>|</span><a href="#41432547">prev</a><span>|</span><a href="#41431187">next</a><span>|</span><label class="collapse" for="c-41432654">[-]</label><label class="expand" for="c-41432654">[3 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;poormansprofiler.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;poormansprofiler.org&#x2F;</a></div><br/><div id="41432713" class="c"><input type="checkbox" id="c-41432713" checked=""/><div class="controls bullet"><span class="by">milianw</span><span>|</span><a href="#41432654">parent</a><span>|</span><a href="#41431187">next</a><span>|</span><label class="collapse" for="c-41432713">[-]</label><label class="expand" for="c-41432713">[2 more]</label></div><br/><div class="children"><div class="content">The premise of this website and articles like <a href="https:&#x2F;&#x2F;yosefk.com&#x2F;blog&#x2F;how-profilers-lie-the-cases-of-gprof-and-kcachegrind.html" rel="nofollow">https:&#x2F;&#x2F;yosefk.com&#x2F;blog&#x2F;how-profilers-lie-the-cases-of-gprof...</a> just show that the authors are using the wrong tools. It is nowadays relatively easy to also look at off-CPU time when profiling with perf (e.g. <a href="https:&#x2F;&#x2F;github.com&#x2F;KDAB&#x2F;hotspot&#x2F;?tab=readme-ov-file#off-cpu-profiling">https:&#x2F;&#x2F;github.com&#x2F;KDAB&#x2F;hotspot&#x2F;?tab=readme-ov-file#off-cpu-...</a>). The idea is to use sampling for the on-CPU periods and then combine that with the off-CPU time measured between context switches. VTune also supported this mode for many years.</div><br/><div id="41432815" class="c"><input type="checkbox" id="c-41432815" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#41432654">root</a><span>|</span><a href="#41432713">parent</a><span>|</span><a href="#41431187">next</a><span>|</span><label class="collapse" for="c-41432815">[-]</label><label class="expand" for="c-41432815">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The premise of this website and articles like <a href="https:&#x2F;&#x2F;yosefk.com&#x2F;blog&#x2F;how-profilers-lie-the-cases-of-gprof" rel="nofollow">https:&#x2F;&#x2F;yosefk.com&#x2F;blog&#x2F;how-profilers-lie-the-cases-of-gprof</a>... just show that the authors are using the wrong tools. It is nowadays relatively easy to also look at off-CPU time when profiling with perf (e.g. <a href="https:&#x2F;&#x2F;github.com&#x2F;KDAB&#x2F;hotspot&#x2F;?tab=readme-ov-file#off-cpu-">https:&#x2F;&#x2F;github.com&#x2F;KDAB&#x2F;hotspot&#x2F;?tab=readme-ov-file#off-cpu-</a>...).<p>I think, firstly, that spending 15s trying the CTRL-c approach is a worthwhile tradeoff. If you <i>don&#x27;t</i> find anything, then sure, spend another 30m - 60m setting up perf, KDAB, etc. Maybe more if you&#x27;re on an embedded device.<p>Secondly, the author seems to say that he&#x27;s used this on embedded devices with no output but a serial line for the debugger. This is also a 15s effort[1].<p>It&#x27;s basically a very low effort task, takes seconds to determine if it worked or not, and if it doesn&#x27;t work you&#x27;ve only lost a few seconds.<p>[1] I&#x27;m assuming that if you&#x27;re developing on a device supporting a serial GDB connection, you&#x27;ve <i>already</i> got the debugger working.</div><br/></div></div></div></div></div></div><div id="41431187" class="c"><input type="checkbox" id="c-41431187" checked=""/><div class="controls bullet"><span class="by">dooglius</span><span>|</span><a href="#41432654">prev</a><span>|</span><a href="#41431964">next</a><span>|</span><label class="collapse" for="c-41431187">[-]</label><label class="expand" for="c-41431187">[3 more]</label></div><br/><div class="children"><div class="content">I wonder how hard it would be to have a profiler dump a big chunk of stack on each sample interrupt, convert these into core dump format, and then use gdb or whatever to decode the traces for analysis? This ought to have the touted benefits without the downside of it being slow to capture a bunch of samples.</div><br/><div id="41431306" class="c"><input type="checkbox" id="c-41431306" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#41431187">parent</a><span>|</span><a href="#41431964">next</a><span>|</span><label class="collapse" for="c-41431306">[-]</label><label class="expand" for="c-41431306">[2 more]</label></div><br/><div class="children"><div class="content">I believe this is essentially what linux perf&#x27;s &quot;--call-graph dwarf&quot; does. On my system that ends up producing ~33MB&#x2F;s of recording data for ~4000 samples&#x2F;s.</div><br/><div id="41432677" class="c"><input type="checkbox" id="c-41432677" checked=""/><div class="controls bullet"><span class="by">milianw</span><span>|</span><a href="#41431187">root</a><span>|</span><a href="#41431306">parent</a><span>|</span><a href="#41431964">next</a><span>|</span><label class="collapse" for="c-41432677">[-]</label><label class="expand" for="c-41432677">[1 more]</label></div><br/><div class="children"><div class="content">With `-z` (zstd compression) you can bring down the disk-space cost of dwarf unwinding by a factor of ~100 based on my personal experience.<p>to GP: What you describe sounds like <a href="https:&#x2F;&#x2F;github.com&#x2F;koute&#x2F;not-perf">https:&#x2F;&#x2F;github.com&#x2F;koute&#x2F;not-perf</a> to me</div><br/></div></div></div></div></div></div><div id="41431964" class="c"><input type="checkbox" id="c-41431964" checked=""/><div class="controls bullet"><span class="by">omgtehlion</span><span>|</span><a href="#41431187">prev</a><span>|</span><a href="#41432007">next</a><span>|</span><label class="collapse" for="c-41431964">[-]</label><label class="expand" for="c-41431964">[2 more]</label></div><br/><div class="children"><div class="content">I mostly use GUI-based debuggers (and profilers), but even in this case I found it often useful to pause the program at random times when it appears &quot;stuck&quot;.<p>Most of the time I don&#x27;t event need to reach for a profiler proper.</div><br/><div id="41432755" class="c"><input type="checkbox" id="c-41432755" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#41431964">parent</a><span>|</span><a href="#41432007">next</a><span>|</span><label class="collapse" for="c-41432755">[-]</label><label class="expand" for="c-41432755">[1 more]</label></div><br/><div class="children"><div class="content">Random sampling is not only useful for quick and dirty debugging, but also for engineering nuclear bombs: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Metropolis–Hastings_algorithm#History" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Metropolis–Hastings_algorithm#...</a></div><br/></div></div></div></div><div id="41432007" class="c"><input type="checkbox" id="c-41432007" checked=""/><div class="controls bullet"><span class="by">Angostura</span><span>|</span><a href="#41431964">prev</a><span>|</span><a href="#41432188">next</a><span>|</span><label class="collapse" for="c-41432007">[-]</label><label class="expand" for="c-41432007">[1 more]</label></div><br/><div class="children"><div class="content">I kept waiting for the guy to actually paste the code somewhere</div><br/></div></div></div></div></div></div></div></body></html>