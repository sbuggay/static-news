<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1730019650594" as="style"/><link rel="stylesheet" href="styles.css?v=1730019650594"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.hyperknot.com/p/understanding-round-robin-dns">Understanding Round Robin DNS</a> <span class="domain">(<a href="https://blog.hyperknot.com">blog.hyperknot.com</a>)</span></div><div class="subtext"><span>hyperknot</span> | <span>103 comments</span></div><br/><div><div id="41956258" class="c"><input type="checkbox" id="c-41956258" checked=""/><div class="controls bullet"><span class="by">jgrahamc</span><span>|</span><a href="#41956490">next</a><span>|</span><label class="collapse" for="c-41956258">[-]</label><label class="expand" for="c-41956258">[9 more]</label></div><br/><div class="children"><div class="content">Hmm. I&#x27;ve asked the authoritative DNS team to explain what&#x27;s happening here. I&#x27;ll let HN know when I get an authoritative answer. It&#x27;s been a few years since I looked at the code and a whole bunch of people keep changing it :-)<p>My suspicion is that this is to do with the fact that we want to keep affinity between the client IP and a backend server (which OP mentions in their blog). And the question is &quot;do you break that affinity if the backend server goes down?&quot; But I&#x27;ll reply to my own comment when I know more.</div><br/><div id="41957630" class="c"><input type="checkbox" id="c-41957630" checked=""/><div class="controls bullet"><span class="by">mlhpdx</span><span>|</span><a href="#41956258">parent</a><span>|</span><a href="#41956598">next</a><span>|</span><label class="collapse" for="c-41957630">[-]</label><label class="expand" for="c-41957630">[6 more]</label></div><br/><div class="children"><div class="content">So many sins have been committed in the name of session affinity.</div><br/><div id="41957784" class="c"><input type="checkbox" id="c-41957784" checked=""/><div class="controls bullet"><span class="by">jgrahamc</span><span>|</span><a href="#41956258">root</a><span>|</span><a href="#41957630">parent</a><span>|</span><a href="#41956598">next</a><span>|</span><label class="collapse" for="c-41957784">[-]</label><label class="expand" for="c-41957784">[5 more]</label></div><br/><div class="children"><div class="content">Looks like this has nothing to do with session affinity. I was wrong. Apparently, this is a difference between our paid and free plans. Getting the details, and finding out why there&#x27;s a difference, and will post.</div><br/><div id="41957820" class="c"><input type="checkbox" id="c-41957820" checked=""/><div class="controls bullet"><span class="by">asmor</span><span>|</span><a href="#41956258">root</a><span>|</span><a href="#41957784">parent</a><span>|</span><a href="#41956598">next</a><span>|</span><label class="collapse" for="c-41957820">[-]</label><label class="expand" for="c-41957820">[4 more]</label></div><br/><div class="children"><div class="content">Well, CEO said there is none, get on it engineering :)</div><br/><div id="41958381" class="c"><input type="checkbox" id="c-41958381" checked=""/><div class="controls bullet"><span class="by">eastdakota</span><span>|</span><a href="#41956258">root</a><span>|</span><a href="#41957820">parent</a><span>|</span><a href="#41956598">next</a><span>|</span><label class="collapse" for="c-41958381">[-]</label><label class="expand" for="c-41958381">[3 more]</label></div><br/><div class="children"><div class="content">What’s somewhat complicated here is its apples and oranges. Cloudflare offers DNS and a proxy service. The OP is using both. The comparisons are merely DNS services. I wasn’t clear on X whether OP was getting confused that the IP we return via DNS (which points to our proxy) doesn’t change, or if they were concerned that behind the proxy we’re not routing correctly. I think after reading this the answer is the latter. Confident we always will route optimally as it’s in our interest and our customers’. But why we’re not failing over on failure is interesting. That looks like, as John said, a difference between free and paid plans that if it made sense at some point doesn’t obviously today. Will figure out what’s up and get fixed.</div><br/><div id="41958440" class="c"><input type="checkbox" id="c-41958440" checked=""/><div class="controls bullet"><span class="by">dangoodmanUT</span><span>|</span><a href="#41956258">root</a><span>|</span><a href="#41958381">parent</a><span>|</span><a href="#41956598">next</a><span>|</span><label class="collapse" for="c-41958440">[-]</label><label class="expand" for="c-41958440">[2 more]</label></div><br/><div class="children"><div class="content">Regardless, it&#x27;s really cool to watch you both engage with this</div><br/><div id="41960882" class="c"><input type="checkbox" id="c-41960882" checked=""/><div class="controls bullet"><span class="by">jgrahamc</span><span>|</span><a href="#41956258">root</a><span>|</span><a href="#41958440">parent</a><span>|</span><a href="#41956598">next</a><span>|</span><label class="collapse" for="c-41960882">[-]</label><label class="expand" for="c-41960882">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t forget all the people at Cloudflare who responded to a ping from me on a Saturday and looked into it.<p>We are going to make the change. This will improve our free accounts so it&#x27;s a win for everyone. Thanks to OP for writing this up!</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41956598" class="c"><input type="checkbox" id="c-41956598" checked=""/><div class="controls bullet"><span class="by">delusional</span><span>|</span><a href="#41956258">parent</a><span>|</span><a href="#41957630">prev</a><span>|</span><a href="#41956490">next</a><span>|</span><label class="collapse" for="c-41956598">[-]</label><label class="expand" for="c-41956598">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ll let HN know when I get an authoritative answer<p>Please remember to include a TTL so I know how long I can cache that answer.</div><br/><div id="41956940" class="c"><input type="checkbox" id="c-41956940" checked=""/><div class="controls bullet"><span class="by">jgrahamc</span><span>|</span><a href="#41956258">root</a><span>|</span><a href="#41956598">parent</a><span>|</span><a href="#41956490">next</a><span>|</span><label class="collapse" for="c-41956940">[-]</label><label class="expand" for="c-41956940">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for appreciating my lame joke.</div><br/></div></div></div></div></div></div><div id="41956490" class="c"><input type="checkbox" id="c-41956490" checked=""/><div class="controls bullet"><span class="by">teddyh</span><span>|</span><a href="#41956258">prev</a><span>|</span><a href="#41957105">next</a><span>|</span><label class="collapse" for="c-41956490">[-]</label><label class="expand" for="c-41956490">[3 more]</label></div><br/><div class="children"><div class="content">One of the early proposed solutions for this was the SRV DNS record, which was similar to the MX record, but for every service, not just e-mail.  With MX and SRV records, you can specify a list of servers with associated priority for clients to try.  SRV also had an extra “weight” parameter to facilitate load balancing.  However, SRV did not want the political fight of effectively hijacking every standard protocol to force all clients of every protocol to also check SRV records, so they specified that SRV should <i>only</i> be used by a client if the standard for that protocol explicitly specifies the use of SRV records.  This technically prohibited HTTP clients from using SRV.  Also, when the HTTP&#x2F;2 (and later) HTTP standards were being written, bogus arguments from Google (and others) prevented the new HTTP protocols from specifying SRV.  SRV seems to be effectively dead for new development, only used by some older standards.<p>The new solution for load balancing seems to be the new HTTPS and SVCB DNS records.  As I understand it, they are standardized by people wanting to add extra parameters to the DNS in order to to jump-start the TLS1.3 handshake, thereby making fewer roundtrips.  (The SVCB record type is the same as HTTPS, but generalized like SRV.) The HTTPS and SVCB DNS record types both have the priority parameter from the SRV and MX record types, but HTTPS&#x2F;SVCB lack the weight parameter from SRV.  The standards have been published, and support seem to have been done in some browsers, but not all have enabled it.  We will see what browsers will actually do in the near future.</div><br/><div id="41956521" class="c"><input type="checkbox" id="c-41956521" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#41956490">parent</a><span>|</span><a href="#41957105">next</a><span>|</span><label class="collapse" for="c-41956521">[-]</label><label class="expand" for="c-41956521">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The new solution for load balancing seems to be the new HTTPS and SVCB DNS records. As I understand it, they are standardized by people wanting to add extra parameters to the DNS in order to to jump-start the TLS1.3 handshake, thereby making fewer roundtrips.<p>The other big advantage of the HTTPS record is that it allows for proper CNAME-like delegation at the domain apex, rather than requiring CNAME flattening hacks that can cause routing issues on CDNs which use GeoDNS in addition to or instead of anycast. If you&#x27;ve ever seen a platform recommend using a www subdomain instead of an apex domain, that&#x27;s why, and it&#x27;s part of why Akamai pushed for HTTPS records to be standardized since they use GeoDNS.</div><br/><div id="41956642" class="c"><input type="checkbox" id="c-41956642" checked=""/><div class="controls bullet"><span class="by">teddyh</span><span>|</span><a href="#41956490">root</a><span>|</span><a href="#41956521">parent</a><span>|</span><a href="#41957105">next</a><span>|</span><label class="collapse" for="c-41956642">[-]</label><label class="expand" for="c-41956642">[1 more]</label></div><br/><div class="children"><div class="content">Oh yes¹.  This is an advantage shared by all of MX, SRV and HTTPS&#x2F;SVCB, though.<p>1. &lt;<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38420555">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38420555</a>&gt;</div><br/></div></div></div></div></div></div><div id="41957105" class="c"><input type="checkbox" id="c-41957105" checked=""/><div class="controls bullet"><span class="by">unilynx</span><span>|</span><a href="#41956490">prev</a><span>|</span><a href="#41956211">next</a><span>|</span><label class="collapse" for="c-41957105">[-]</label><label class="expand" for="c-41957105">[3 more]</label></div><br/><div class="children"><div class="content">&gt; So what happens when one of the servers is offline? Say I stop the US server:<p>&gt; service nginx stop<p>But that&#x27;s not how you should test this. A client will see the connection being refused, and go on to the next IP. But in practice, a server may not respond at all, or accept the connection and then go silent.<p>Now you&#x27;re dependent on client timeouts, and round robin DNS will suddenly look a whole lot less attractive to increase reliability.</div><br/><div id="41960774" class="c"><input type="checkbox" id="c-41960774" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#41957105">parent</a><span>|</span><a href="#41957645">next</a><span>|</span><label class="collapse" for="c-41960774">[-]</label><label class="expand" for="c-41960774">[1 more]</label></div><br/><div class="children"><div class="content">Yes, this can be tested by just unplugging or turning off a machine&#x2F;VM with that IP address. Stopping a service is a planned action that you could handle by updating your DNS first.</div><br/></div></div><div id="41957645" class="c"><input type="checkbox" id="c-41957645" checked=""/><div class="controls bullet"><span class="by">Joe_Cool</span><span>|</span><a href="#41957105">parent</a><span>|</span><a href="#41960774">prev</a><span>|</span><a href="#41956211">next</a><span>|</span><label class="collapse" for="c-41957645">[-]</label><label class="expand" for="c-41957645">[1 more]</label></div><br/><div class="children"><div class="content">Yeah SIG_STOP or just ip&#x2F;nftables DROP would be a much more realistic test.</div><br/></div></div></div></div><div id="41956211" class="c"><input type="checkbox" id="c-41956211" checked=""/><div class="controls bullet"><span class="by">tetha</span><span>|</span><a href="#41957105">prev</a><span>|</span><a href="#41958880">next</a><span>|</span><label class="collapse" for="c-41956211">[-]</label><label class="expand" for="c-41956211">[9 more]</label></div><br/><div class="children"><div class="content">&gt; As you can see, all clients correctly detect it and choose an alternative server.<p>This is the nasty key point. The reliability is decided client-side.<p>For example, systemd-resolved at times enacted maximum technical correctness by always returning the lowest IP address. After all, DNS-RR is not well-defined, so always returning the lowest IPs is not wrong. It got changed after some riots, but as far as I know, Debian 11 is stuck with that behavior, or was for a long time.<p>Or, I deal with many applications with shitty or no retry behavior. They go &quot;Oh no, I have one connection refused, gotta cancel everything, shutdown, never try again&quot;. So now 20% - 30% of all requests die in a fire.<p>It&#x27;s an acceptable solution if you have nothing else. As the article notices, if you have quality HTTP clients with a few retries configured on them (like browsers), DNS-RR is fine to find an actual load balancer with health checks and everything, which can provide a 100% success rate.<p>But DNS-RR is no loadbalancer and loadbalancers are better.</div><br/><div id="41958644" class="c"><input type="checkbox" id="c-41958644" checked=""/><div class="controls bullet"><span class="by">aarmenaa</span><span>|</span><a href="#41956211">parent</a><span>|</span><a href="#41956562">next</a><span>|</span><label class="collapse" for="c-41958644">[-]</label><label class="expand" for="c-41958644">[1 more]</label></div><br/><div class="children"><div class="content">True.  On the other hand, if you control the clients and can guarantee their behavior then DNS load balancing is highly effective.  A place I used to work had internal DNS servers with hundreds of millions of records with 60 second TTLs for a bespoke internal routing system that connected incoming connections from customers with the correct resources inside our network.  It was actually excellent.  Changing routing was as simple as doing a DDNS update, and with NOTIFY to push changes to all child servers the average delay was less than 60 seconds for full effect.  This made it easy to write more complicated tools, and I wrote a control panel that could take components from a single server to a whole data center out of service at the click of a button.<p>There were definitely some warts in that system but as those sorts of systems go it was fast, easy to introspect, and relatively bulletproof.</div><br/></div></div><div id="41956562" class="c"><input type="checkbox" id="c-41956562" checked=""/><div class="controls bullet"><span class="by">nerdile</span><span>|</span><a href="#41956211">parent</a><span>|</span><a href="#41958644">prev</a><span>|</span><a href="#41956294">next</a><span>|</span><label class="collapse" for="c-41956562">[-]</label><label class="expand" for="c-41956562">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s putting reliability in the hands of the client, or whatever random caching DNS resolver they&#x27;re sitting behind.<p>It also puts failover in those same hands. If one of your regions goes down, do you want the traffic to spread evenly to your other regions? Or pile on to the next nearest neighbor? If you care what happens, then you want to retain control of your traffic management and not cede it to others.</div><br/></div></div><div id="41956294" class="c"><input type="checkbox" id="c-41956294" checked=""/><div class="controls bullet"><span class="by">latchkey</span><span>|</span><a href="#41956211">parent</a><span>|</span><a href="#41956562">prev</a><span>|</span><a href="#41958880">next</a><span>|</span><label class="collapse" for="c-41956294">[-]</label><label class="expand" for="c-41956294">[6 more]</label></div><br/><div class="children"><div class="content">&gt; <i>It&#x27;s an acceptable solution if you have nothing else.</i><p>I&#x27;d argue it isn&#x27;t acceptable at all in this day and age and that there are other solutions one should pick today long before you get to the &quot;nothing else&quot; choice.</div><br/><div id="41956593" class="c"><input type="checkbox" id="c-41956593" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41956211">root</a><span>|</span><a href="#41956294">parent</a><span>|</span><a href="#41958880">next</a><span>|</span><label class="collapse" for="c-41956593">[-]</label><label class="expand" for="c-41956593">[5 more]</label></div><br/><div class="children"><div class="content">Anycast is nice, but it&#x27;s not something you can do yourself well unless you have large scale. You need to have a large number of PoPs, and direct connectivity to many&#x2F;most transit providers, or you&#x27;ll get weird routing.<p>You also need to find yourself some IP ranges. And learn BGP and find providers where you can use it.<p>DNS round robin works as long as you can manage to find two boxes to run your stuff on, and it scales pretty high too. When I was at WhatsApp, we used DNS round robin until we moved into Facebook&#x27;s hosting where it was infeasible due to servers not having public addresses. Yes, mostly not browsers, but not completely browserless.</div><br/><div id="41956698" class="c"><input type="checkbox" id="c-41956698" checked=""/><div class="controls bullet"><span class="by">latchkey</span><span>|</span><a href="#41956211">root</a><span>|</span><a href="#41956593">parent</a><span>|</span><a href="#41958880">next</a><span>|</span><label class="collapse" for="c-41956698">[-]</label><label class="expand" for="c-41956698">[4 more]</label></div><br/><div class="children"><div class="content">Back in 2013, that might have been the best solution for you. But there were still plenty of headlines... <a href="https:&#x2F;&#x2F;www.wamda.com&#x2F;2013&#x2F;11&#x2F;whatsapp-goes-down" rel="nofollow">https:&#x2F;&#x2F;www.wamda.com&#x2F;2013&#x2F;11&#x2F;whatsapp-goes-down</a><p>We&#x27;re talking about today.<p>The reason why I said Anycast is cause the vast majority of people trying to solve the need for having multiple servers in multiple locations, will just use CF or any one of the various anycast based CDN providers available today.</div><br/><div id="41957483" class="c"><input type="checkbox" id="c-41957483" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41956211">root</a><span>|</span><a href="#41956698">parent</a><span>|</span><a href="#41958880">next</a><span>|</span><label class="collapse" for="c-41957483">[-]</label><label class="expand" for="c-41957483">[3 more]</label></div><br/><div class="children"><div class="content">Oh sure, we had many outages. More outages on the one service where we tried using loadbalancers because the loadbalancers would take a one hour break every 30 days (which is pretty shitty, but that was the load balancer available, unless we wanted to run a software load balancer, which didn&#x27;t make any sense).<p>We didn&#x27;t have many outages due to DNS, because we had fallback ips to contact chat in our clients. Usage was down in the 24 hours after our domain was briefly hijacked (thanks Network Solutions), and I think we lost some usage when our DNS provider was DDoSed by &#x27;angry gamers&#x27;. But when FB broke most of their load balancers, that was a much bigger outage. BGP based outages broke everything, DNS and load balancers, so no wins there.</div><br/><div id="41957533" class="c"><input type="checkbox" id="c-41957533" checked=""/><div class="controls bullet"><span class="by">latchkey</span><span>|</span><a href="#41956211">root</a><span>|</span><a href="#41957483">parent</a><span>|</span><a href="#41958880">next</a><span>|</span><label class="collapse" for="c-41957533">[-]</label><label class="expand" for="c-41957533">[2 more]</label></div><br/><div class="children"><div class="content">&gt; We didn&#x27;t have many outages due to DNS, because we had fallback ips to contact chat in our clients.<p>Exactly! When you control the client, you don&#x27;t even need DNS. Things are actually even more secure when you don&#x27;t use it, nothing to DDoS or hijack. When FB broke one set of LB&#x27;s, the clients should have just routed to another set of LB&#x27;s, by IP.</div><br/><div id="41957563" class="c"><input type="checkbox" id="c-41957563" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41956211">root</a><span>|</span><a href="#41957533">parent</a><span>|</span><a href="#41958880">next</a><span>|</span><label class="collapse" for="c-41957563">[-]</label><label class="expand" for="c-41957563">[1 more]</label></div><br/><div class="children"><div class="content">FB likes to break everything all at once anyway... And healtchecking the load balancers wasn&#x27;t working either. So DNS to regional balancers was sending people to the wrong place, and the anycast ips might have worked if you were lucky, but you might have gotten a PoP that was broken.<p>The servers behind it were fine, if you could get to one. You could push broken DNS responses, I suppose, but it&#x27;s harder than breaking a load balancer.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41958880" class="c"><input type="checkbox" id="c-41958880" checked=""/><div class="controls bullet"><span class="by">__turbobrew__</span><span>|</span><a href="#41956211">prev</a><span>|</span><a href="#41956554">next</a><span>|</span><label class="collapse" for="c-41958880">[-]</label><label class="expand" for="c-41958880">[10 more]</label></div><br/><div class="children"><div class="content">DNS load balancing has some really nasty edge cases. I have had to deal with golang HTTP2 clients using RR DNS and it has caused issues.<p>Golang HTTP2 clients will reuse the first server they can connect to over and over and the DNS is never re-resolved. This can lead to issues where clients will not discover new servers which are added to the pool.<p>An particularly pathological case is if all serving backends go down the clients will all pin to the first serving backend which comes up and they will not move off. As other servers come up few clients will connect since they are already connected to the first server which came back.<p>A similar issue happens with grpc-go. The grpc DNS resolver will only re-resolve when the connection to a backend is broken. Similarly grpc clients can all gang onto a host and never move off. There are suggestions that on the server side you can set `MAX_CONNECTION_AGE` which will periodically disconnect clients after a while which causes the client to re-resolve the DNS.<p>I really wish there was a better standard solution for service discovery. I guess the best you can do is implement a request based load balancer with a virtual IP and have the load balancer perform health checks. But you are still kicking the can down the road as you are just pushing down the problem to the system which implements virtual IPs. I guess you assume that the routing system is relatively static compared to the backends and that is where the benefits come in.<p>I&#x27;m curious how do people do this on bare metal? I know AWS&#x2F;GCP&#x2F;etc... have their internal load balancers, but I am kind of curious what the secret sauce is to doing this. Maybe suggestions on blog posts or white papers?</div><br/><div id="41958894" class="c"><input type="checkbox" id="c-41958894" checked=""/><div class="controls bullet"><span class="by">fotta</span><span>|</span><a href="#41958880">parent</a><span>|</span><a href="#41956554">next</a><span>|</span><label class="collapse" for="c-41958894">[-]</label><label class="expand" for="c-41958894">[9 more]</label></div><br/><div class="children"><div class="content">&gt; Golang HTTP2 clients will reuse the first server they can connect to over and over and the DNS is never re-resolved.<p>I’m not a DNS expert but shouldn’t it re-resolve when the TTL expires?</div><br/><div id="41960043" class="c"><input type="checkbox" id="c-41960043" checked=""/><div class="controls bullet"><span class="by">__turbobrew__</span><span>|</span><a href="#41958880">root</a><span>|</span><a href="#41958894">parent</a><span>|</span><a href="#41959075">next</a><span>|</span><label class="collapse" for="c-41960043">[-]</label><label class="expand" for="c-41960043">[1 more]</label></div><br/><div class="children"><div class="content">You nerd sniped me. The guts of how http2 deals with this in golang is in transport.go :
<a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;master&#x2F;src&#x2F;net&#x2F;http&#x2F;transport.go">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;master&#x2F;src&#x2F;net&#x2F;http&#x2F;transp...</a><p>If I’m reading the code right round trips (HTTP requests) go through queueForIdleConn which picks up any pre-existing connections to a host. The only time these connections are cleaned up (in HTTP2) is if keepalives are turned off and the connection has been idle for too long OR the connection breaks in some way OR the max number of connections is hit LRU cache evictions take place.<p>Furthermore, the golang dnsclient doesn’t even expose record TTLs to callers so how could the HTTP2 transport know when an entry is stale?
<a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;master&#x2F;src&#x2F;net&#x2F;dnsclient_unix.go">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;master&#x2F;src&#x2F;net&#x2F;dnsclient_u...</a></div><br/></div></div><div id="41959075" class="c"><input type="checkbox" id="c-41959075" checked=""/><div class="controls bullet"><span class="by">loevborg</span><span>|</span><a href="#41958880">root</a><span>|</span><a href="#41958894">parent</a><span>|</span><a href="#41960043">prev</a><span>|</span><a href="#41959468">next</a><span>|</span><label class="collapse" for="c-41959075">[-]</label><label class="expand" for="c-41959075">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know about Golang but I swear I&#x27;ve seen this before as well - clients holding on to an old IP address without ever re-resolving the domain name. It makes me wary of using DNS for load balancing or blue-green deployments. I feel like I can&#x27;t trust DNS clients.</div><br/><div id="41959895" class="c"><input type="checkbox" id="c-41959895" checked=""/><div class="controls bullet"><span class="by">ignoramous</span><span>|</span><a href="#41958880">root</a><span>|</span><a href="#41959075">parent</a><span>|</span><a href="#41959468">next</a><span>|</span><label class="collapse" for="c-41959895">[-]</label><label class="expand" for="c-41959895">[2 more]</label></div><br/><div class="children"><div class="content">Some reasons to connect to the same IP: TCP Fast Open, TLS session resumption, connection pools, residual censorship.</div><br/><div id="41960063" class="c"><input type="checkbox" id="c-41960063" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#41958880">root</a><span>|</span><a href="#41959895">parent</a><span>|</span><a href="#41959468">next</a><span>|</span><label class="collapse" for="c-41960063">[-]</label><label class="expand" for="c-41960063">[1 more]</label></div><br/><div class="children"><div class="content">The other reason: you have an open TCP socket that you&#x27;re actively using. Unless you finish with that connection or it breaks, why would you re-resolve it when you&#x27;re not running connect() a second time? The failure mode we noticed most when looking into why clients weren&#x27;t following DNS changes isn&#x27;t that they were long lived connections, like a server copying a large file or streaming logs. Which isn&#x27;t unusual if you think about it, just not a short lived web browser or curl-esque connection.</div><br/></div></div></div></div></div></div><div id="41959468" class="c"><input type="checkbox" id="c-41959468" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41958880">root</a><span>|</span><a href="#41958894">parent</a><span>|</span><a href="#41959075">prev</a><span>|</span><a href="#41959482">next</a><span>|</span><label class="collapse" for="c-41959468">[-]</label><label class="expand" for="c-41959468">[2 more]</label></div><br/><div class="children"><div class="content">It <i>should</i>, but like the sibling, I haven&#x27;t seen what Go does. I&#x27;ve seen it happen elsewhere. Exchange used to cache any answer it got until it restarted. Java has had that behavior from time to time if you&#x27;re not careful as well.<p>Querying DNS can be expensive, so it makes sense to build a cache to avoid querying again when you don&#x27;t need to, but typical APIs for name resolution such as gethostbyname &#x2F; getaddrinfo don&#x27;t return the TTL, so people just assume forever is a good TTL. Especially for a persistant (http) connection, it kind of makes sense to never query DNS again while you already have a working connection that you made with that name, and if it&#x27;s TLS, it&#x27;s quite possible that you don&#x27;t check if the certificate has expired while you&#x27;re connected or if you do a session resumption.<p>But innocent things like this add up to make operating services tricky. Many times, if you start refusing connections, clients figure it out, but sometimes the caches still don&#x27;t get cleared.</div><br/><div id="41959511" class="c"><input type="checkbox" id="c-41959511" checked=""/><div class="controls bullet"><span class="by">fotta</span><span>|</span><a href="#41958880">root</a><span>|</span><a href="#41959468">parent</a><span>|</span><a href="#41959482">next</a><span>|</span><label class="collapse" for="c-41959511">[-]</label><label class="expand" for="c-41959511">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but typical APIs for name resolution such as gethostbyname &#x2F; getaddrinfo don&#x27;t return the TTL<p>Oh wow I didn’t know this but I looked it up and you’re right. Interesting.</div><br/></div></div></div></div><div id="41959482" class="c"><input type="checkbox" id="c-41959482" checked=""/><div class="controls bullet"><span class="by">kkielhofner</span><span>|</span><a href="#41958880">root</a><span>|</span><a href="#41958894">parent</a><span>|</span><a href="#41959468">prev</a><span>|</span><a href="#41959828">next</a><span>|</span><label class="collapse" for="c-41959482">[-]</label><label class="expand" for="c-41959482">[1 more]</label></div><br/><div class="children"><div class="content">TTL isn&#x27;t universally respected. Consider the following path:<p>Your machine -&gt; Local router -&gt; Configured upstream DNS Server (ISP&#x2F;CF&#x2F;Quad8&#x2F;etc) -&gt; ? -&gt; Authoritative DNS Server<p>Any one of those layers can override&#x2F;mess with&#x2F;cache in a variety of ways including TTL. This is why Cloudflare and a variety of other providers use IP anycast. They accepted DNS for what it is and worked around it.<p>Not only is the IP always the IP, the &quot;global&quot; BGP routing table actually universally and consistently updates much faster than DNS. Then whatever routers, machines, etc downstream from that don&#x27;t matter.</div><br/></div></div><div id="41959828" class="c"><input type="checkbox" id="c-41959828" checked=""/><div class="controls bullet"><span class="by">__turbobrew__</span><span>|</span><a href="#41958880">root</a><span>|</span><a href="#41958894">parent</a><span>|</span><a href="#41959482">prev</a><span>|</span><a href="#41956554">next</a><span>|</span><label class="collapse" for="c-41959828">[-]</label><label class="expand" for="c-41959828">[1 more]</label></div><br/><div class="children"><div class="content">I read through the golang code once due to coming across this issue with kubernetes clients which use the standard golang http client under the hood.<p>I would need to re-read the code to refresh my memory.</div><br/></div></div></div></div></div></div><div id="41956554" class="c"><input type="checkbox" id="c-41956554" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#41958880">prev</a><span>|</span><a href="#41956131">next</a><span>|</span><label class="collapse" for="c-41956554">[-]</label><label class="expand" for="c-41956554">[8 more]</label></div><br/><div class="children"><div class="content"><i>&gt; This allows you to share the load between multiple servers, as well as to automatically detect which servers are offline and choose the online ones.</i><p>To [hesitantly] clarify a pedantry regarding &quot;DNS automatic offline detection&quot;:<p>Out of the box, RR-DNS is only good for load balancing.<p>Nothing automatic happens on the availability state detection front unless you build smarts into the client.  TFA introduction does sort of mention this, but it took me several re-reads of the intro to get their meaning (which to be fair could be a PEBKAC).  Then I read the rest of TFA, which is all about the smarts.<p>If the 1&#x2F;N server record selected by your browser ends up being unavailable, no automatic recovery &#x2F; retry occurs at the protocol level.<p>p.s. &quot;Related fun&quot;: Don&#x27;t forget about Java&#x27;s DNS TTL [1] and `.equals()&#x27; [2] behaviors.<p>[1] <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;1256556&#x2F;how-to-make-java-honor-the-dns-caching-timeout" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;1256556&#x2F;how-to-make-java...</a><p>[2] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=21765788">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=21765788</a> (5y ago, 168 comments)</div><br/><div id="41956661" class="c"><input type="checkbox" id="c-41956661" checked=""/><div class="controls bullet"><span class="by">encoderer</span><span>|</span><a href="#41956554">parent</a><span>|</span><a href="#41956131">next</a><span>|</span><label class="collapse" for="c-41956661">[-]</label><label class="expand" for="c-41956661">[7 more]</label></div><br/><div class="children"><div class="content">We accomplish this on Route53 by having it pull servers out of the dns response if they are not healthy, and serving all responses with a very low ttl. A few clients out there ignore ttl but it’s pretty rare.</div><br/><div id="41956746" class="c"><input type="checkbox" id="c-41956746" checked=""/><div class="controls bullet"><span class="by">ChocolateGod</span><span>|</span><a href="#41956554">root</a><span>|</span><a href="#41956661">parent</a><span>|</span><a href="#41957164">next</a><span>|</span><label class="collapse" for="c-41956746">[-]</label><label class="expand" for="c-41956746">[3 more]</label></div><br/><div class="children"><div class="content">I once achieved something similar with PowerDNS, which you can use LUA rules to do health checks on a pool of servers and only return health servers as part of the DNS record, but found odd occurrences of clients not respecting the TTL on DNS records and caching too long.</div><br/><div id="41956918" class="c"><input type="checkbox" id="c-41956918" checked=""/><div class="controls bullet"><span class="by">tetha</span><span>|</span><a href="#41956554">root</a><span>|</span><a href="#41956746">parent</a><span>|</span><a href="#41957164">next</a><span>|</span><label class="collapse" for="c-41956918">[-]</label><label class="expand" for="c-41956918">[2 more]</label></div><br/><div class="children"><div class="content">You usually do this with servers that should be rock-solid and stateless. HAProxy, Traefik, F5. That way, you can pull the DNS record for maintenance 24 - 48 hours in advance. If something overrides DNS TTLs that much, there is probably some reason.</div><br/></div></div></div></div><div id="41957164" class="c"><input type="checkbox" id="c-41957164" checked=""/><div class="controls bullet"><span class="by">d_k_f</span><span>|</span><a href="#41956554">root</a><span>|</span><a href="#41956661">parent</a><span>|</span><a href="#41956746">prev</a><span>|</span><a href="#41956131">next</a><span>|</span><label class="collapse" for="c-41957164">[-]</label><label class="expand" for="c-41957164">[3 more]</label></div><br/><div class="children"><div class="content">Honest question to somebody who seems to have a bit of knowledge about this in the real world: several (German, if relevant) providers default to a TTL of ~4 hours. Lovely if everything is more or less finally set up, but usually our first step is to decrease pretty much everything down to 60 seconds so we can change things around in emergencies.<p>On average, does this really matter&#x2F;make sense?</div><br/><div id="41957477" class="c"><input type="checkbox" id="c-41957477" checked=""/><div class="controls bullet"><span class="by">stackskipton</span><span>|</span><a href="#41956554">root</a><span>|</span><a href="#41957164">parent</a><span>|</span><a href="#41959495">next</a><span>|</span><label class="collapse" for="c-41957477">[-]</label><label class="expand" for="c-41957477">[1 more]</label></div><br/><div class="children"><div class="content">Lower TTLs is cheap insurance so you can move hostnames around.<p>However, you should understand that not ALL clients will respect those TTLs. There are resolvers that may minimum TTL threshold where IF TTL &lt; Threshold, TTL == Threshold, Common with some ISPs, and also, there may be cases where browsers and operating systems will ignore TTLs or fudge them.</div><br/></div></div><div id="41959495" class="c"><input type="checkbox" id="c-41959495" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41956554">root</a><span>|</span><a href="#41957164">parent</a><span>|</span><a href="#41957477">prev</a><span>|</span><a href="#41956131">next</a><span>|</span><label class="collapse" for="c-41959495">[-]</label><label class="expand" for="c-41959495">[1 more]</label></div><br/><div class="children"><div class="content">From experience, 90%+ of traffic will respect your TTLs or something close. So on average, it definitely does make a difference. There&#x27;s always going to be a long tail of straglers though.<p>Personally, my default for names that are likely to change often is 5 minutes, but 1 minute is ok, but might drive a lot more DNS traffic.</div><br/></div></div></div></div></div></div></div></div><div id="41956131" class="c"><input type="checkbox" id="c-41956131" checked=""/><div class="controls bullet"><span class="by">latchkey</span><span>|</span><a href="#41956554">prev</a><span>|</span><a href="#41957435">next</a><span>|</span><label class="collapse" for="c-41956131">[-]</label><label class="expand" for="c-41956131">[24 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  &gt; &quot;It&#x27;s an amazingly simple and elegant solution that avoids using Load Balancers.&quot;
</code></pre>
When a server is down, you have a globally distributed &#x2F; cached IP address that you can&#x27;t prevent people from hitting.<p><a href="https:&#x2F;&#x2F;www.cloudflare.com&#x2F;learning&#x2F;dns&#x2F;glossary&#x2F;round-robin-dns&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.cloudflare.com&#x2F;learning&#x2F;dns&#x2F;glossary&#x2F;round-robin...</a></div><br/><div id="41956526" class="c"><input type="checkbox" id="c-41956526" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41956131">parent</a><span>|</span><a href="#41956250">next</a><span>|</span><label class="collapse" for="c-41956526">[-]</label><label class="expand" for="c-41956526">[8 more]</label></div><br/><div class="children"><div class="content">Skipping an unnecessary intermediary is worth considering.<p>Load balancing isn&#x27;t without cost, and load balancers subtly (or unsubtly) messing up connections is an issue. I&#x27;ve also used providers where their load balancers had worse availability than our hosts.<p>If you control the clients, it&#x27;s reasonable to call the platform dns api to get a list of ips and shuffle and iterate through in an appropriate way. Even better if you have a few stablely allocated IPs you can distribute in client binaries for <i>when</i> DNS is broken; but DNS is often not broken and it&#x27;s nice to use for operational changes without having to push new configuration&#x2F;binaries everytime you update the cluster.<p>If your clients are browsers, default behavior is ok; they usually use IPs in order, which can be problematic [1], but otherwise, they have good retry behavior: on connection refused they try another IP right away, in case of timeout, they try at least a few different IPs. It&#x27;s not ideal, and I&#x27;d use a load balancer for browsers, at least to serve the initial page load if feasible, and maybe DNS RR and semi-smart client logic in JS for websockets&#x2F;etc; but DNS RR is workable for a whole site too.<p>If your clients are not browsers and not controlled by you, best of luck?<p>I will 100% admit that sometimes you have to assume someone built their DNS caching resolver to interpret the TTL field as a number of days, rather than number of seconds. And that clients behind those resolvers will have trouble when you update DNS, but if your loadbalancer is behind a DNS name, <i>when</i> it needs to change addresses, you&#x27;ll deal with that then, and you won&#x27;t have experience.<p>[1] one of the RFCs suggests that OS apis should sort responses by prefix match, which might make sense if IP prefixes were heirarchical as a proxy to get to a least network distance server. But in the real world, numerically adjacent &#x2F;24s are often not network adjacent, but if your servers have widely disparate addresses, you may see traffic from some client ips gravitate towards numerically similar server ips.</div><br/><div id="41959945" class="c"><input type="checkbox" id="c-41959945" checked=""/><div class="controls bullet"><span class="by">ignoramous</span><span>|</span><a href="#41956131">root</a><span>|</span><a href="#41956526">parent</a><span>|</span><a href="#41956790">next</a><span>|</span><label class="collapse" for="c-41959945">[-]</label><label class="expand" for="c-41959945">[4 more]</label></div><br/><div class="children"><div class="content">&gt; <i>you control the clients, it&#x27;s reasonable to call the platform dns api to get a list of ips and shuffle and iterate through in an appropriate way. Even better if you have a few stable allocated IPs you can distribute in client binaries for when DNS is broken</i><p>You know, not many apps do this but in particular WhatsApp does! Was it you?</div><br/><div id="41960028" class="c"><input type="checkbox" id="c-41960028" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41956131">root</a><span>|</span><a href="#41959945">parent</a><span>|</span><a href="#41956790">next</a><span>|</span><label class="collapse" for="c-41960028">[-]</label><label class="expand" for="c-41960028">[3 more]</label></div><br/><div class="children"><div class="content">Not my idea, but I supported it. Originally, client build scripts resolved the service names at build time, and that worked ok because our hosts tended to have a lot of longevity, and DNS tends to work, but things got a little better when we were more intentional about selecting the servers to be in the list, and keep track of which ones were in the list, so retirements could be managed a bit better. And I pushed until we got agreement on a set of FB load balancer IPs to include as well.</div><br/><div id="41960082" class="c"><input type="checkbox" id="c-41960082" checked=""/><div class="controls bullet"><span class="by">ignoramous</span><span>|</span><a href="#41956131">root</a><span>|</span><a href="#41960028">parent</a><span>|</span><a href="#41956790">next</a><span>|</span><label class="collapse" for="c-41960082">[-]</label><label class="expand" for="c-41960082">[2 more]</label></div><br/><div class="children"><div class="content">Nice. Thanks! Another peculiar thing I observed (way back when) was... in the most losiest of lossy EDGE&#x2F;2G environments in rural India, only WhatsApp managed to work (email clients, browsers, other chat apps didn&#x27;t). Not only was WhatsApp able to send&#x2F;recieve messages but also upload&#x2F;download ~100KB PDFs (over what seemed like a 20m to 30m slow process, but it did complete alright). If it is okay to disclose, did WhatsApp build its own protocol&#x2F;impl atop TCP&#x2F;UDP for such scenarios?</div><br/><div id="41960410" class="c"><input type="checkbox" id="c-41960410" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41956131">root</a><span>|</span><a href="#41960082">parent</a><span>|</span><a href="#41956790">next</a><span>|</span><label class="collapse" for="c-41960410">[-]</label><label class="expand" for="c-41960410">[1 more]</label></div><br/><div class="children"><div class="content">The EU marketplace disclosures on protocol seem to be pretty close to what I remember of the non-public protocols.<p>Chat is basically binary encoded XMPP, with essentially a compression dictionary, so per iq overhead is minimal. Especially for the start of connection stuff (login, offline message delivery), we counted bytes and made accomidations for typical network issues we would see. Not acking a big chunk of offline messages after a few tries? Let&#x27;s send one at a time  and see if that works, etc.<p>Our socket timeouts were rather long as well. Before the move into Facebook infra, servers were in the US only, and rural India is a long ways from the US; and last mile contention on 2G gets real rough out there too... I want to say timeouts were on the order of 30 seconds?<p>Multimedia (attachments) was https, with resumption. I don&#x27;t remember the full history, originally I don&#x27;t think we had resumption on uploads, there&#x27;s some coordination required for that, which IIRC started as more or less send an IQ that you want to upload a file with a hash of the file, and get a response of either what the download url is if the file was complete, or where to upload and what byte to start with if not. I think it&#x27;s likely different now, but probably still https based. I wanted to move it so multimedia would be either multiplexed on the chat channel or using a similar protocol to the chat channel, but I didn&#x27;t have the pull, and I got redirected into pushing TLS 1.3 into our Android client&#x27;s mms upload&#x2F;download instead; I didn&#x27;t do the code there, just prototyping to show it could be possible, and then was more of a facilitator than a contributor. I&#x27;m not sure I got all the benefits I was looking for, but there were some, and it kept me busy while I was wrapping up our pre-FB hosting and my time at WA.</div><br/></div></div></div></div></div></div></div></div><div id="41956790" class="c"><input type="checkbox" id="c-41956790" checked=""/><div class="controls bullet"><span class="by">ectospheno</span><span>|</span><a href="#41956131">root</a><span>|</span><a href="#41956526">parent</a><span>|</span><a href="#41959945">prev</a><span>|</span><a href="#41956250">next</a><span>|</span><label class="collapse" for="c-41956790">[-]</label><label class="expand" for="c-41956790">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I will 100% admit that sometimes you have to assume someone built their DNS caching resolver to interpret the TTL field as a number of days, rather than number of seconds.<p>I’ve run a min ttl of 3600 on my home network for over a year. No one has complained yet.</div><br/><div id="41957521" class="c"><input type="checkbox" id="c-41957521" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41956131">root</a><span>|</span><a href="#41956790">parent</a><span>|</span><a href="#41956250">next</a><span>|</span><label class="collapse" for="c-41957521">[-]</label><label class="expand" for="c-41957521">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s only because there&#x27;s no way for service operators to effectively complain when your clients continue to hit service ips for 55 minutes after you should. And if there was, we&#x27;d first yell at all the people who continue to hit service ips for weeks and months after a change... by the time we get to complaining about one home using an hour ttl, it&#x27;s not a big deal.</div><br/><div id="41958034" class="c"><input type="checkbox" id="c-41958034" checked=""/><div class="controls bullet"><span class="by">ectospheno</span><span>|</span><a href="#41956131">root</a><span>|</span><a href="#41957521">parent</a><span>|</span><a href="#41956250">next</a><span>|</span><label class="collapse" for="c-41958034">[-]</label><label class="expand" for="c-41958034">[1 more]</label></div><br/><div class="children"><div class="content">I take the point of view that if me not honoring your 60 second ttl breaks your site for me then I want to know so I stop going there.</div><br/></div></div></div></div></div></div></div></div><div id="41956250" class="c"><input type="checkbox" id="c-41956250" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#41956131">parent</a><span>|</span><a href="#41956526">prev</a><span>|</span><a href="#41956196">next</a><span>|</span><label class="collapse" for="c-41956250">[-]</label><label class="expand" for="c-41956250">[13 more]</label></div><br/><div class="children"><div class="content">An clients tested in the article behaved correctly and chose one of the reachable servers instead.<p>Of course somebody will inevitably misconfigure their local DNS or use a bad client. Either you accept an outage for people with broken setups or you reassign the IP to a different server in the same DC.</div><br/><div id="41956269" class="c"><input type="checkbox" id="c-41956269" checked=""/><div class="controls bullet"><span class="by">latchkey</span><span>|</span><a href="#41956131">root</a><span>|</span><a href="#41956250">parent</a><span>|</span><a href="#41956196">next</a><span>|</span><label class="collapse" for="c-41956269">[-]</label><label class="expand" for="c-41956269">[12 more]</label></div><br/><div class="children"><div class="content">If you know all of your clients, then you don&#x27;t even need DNS. But, you don&#x27;t know all of your clients. Nor do you always know your upstream DNS provider.<p>Design for failure. Don&#x27;t fabricate failure.</div><br/><div id="41956358" class="c"><input type="checkbox" id="c-41956358" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#41956131">root</a><span>|</span><a href="#41956269">parent</a><span>|</span><a href="#41956196">next</a><span>|</span><label class="collapse" for="c-41956358">[-]</label><label class="expand" for="c-41956358">[11 more]</label></div><br/><div class="children"><div class="content">Why would knowing your clients change whether or not you want to use DNS? Even when you <i>control</i> all of the clients you&#x27;ll almost always want to keep using DNS.<p>A large number of services successfully achieve their failure tolerances via these kinds of DNS methods. That doesn&#x27;t mean all services would or that it&#x27;s always the best answer, it just means it&#x27;s a path you can consider when designing for the needs of a system.</div><br/><div id="41956387" class="c"><input type="checkbox" id="c-41956387" checked=""/><div class="controls bullet"><span class="by">latchkey</span><span>|</span><a href="#41956131">root</a><span>|</span><a href="#41956358">parent</a><span>|</span><a href="#41956196">next</a><span>|</span><label class="collapse" for="c-41956387">[-]</label><label class="expand" for="c-41956387">[10 more]</label></div><br/><div class="children"><div class="content">I&#x27;m replying to the comment above. If the article picks a few clients and it happens to work, that is effectively &quot;knowing your clients&quot;. At which point, it means you have control over the client&#x2F;server relationship and if we are trying to simplify by not using load balancers, we might as well simplify things even further, and not use DNS.<p>It is an absurd train of thought that nobody in their right mind would consider... just like using DNS-RR as a replacement for load balancing.</div><br/><div id="41956438" class="c"><input type="checkbox" id="c-41956438" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#41956131">root</a><span>|</span><a href="#41956387">parent</a><span>|</span><a href="#41956196">next</a><span>|</span><label class="collapse" for="c-41956438">[-]</label><label class="expand" for="c-41956438">[9 more]</label></div><br/><div class="children"><div class="content">I must be having trouble following your train of thought here - many large web services like Cloudflare and Akamai serve large volumes of content through round robin DNS balancing, what&#x27;s absurd about their success? They certainly don&#x27;t know every client that&#x27;ll ever connect to a CDN on the internet... it just happens to work almost every time anyways. That very few clients might not instantly flip over isn&#x27;t always a design failure worth deploying full load balancers. I&#x27;m also still not following why the decisions for whether or not you need a load balancer are supposed to be in any way equivalent to the decisions of when using DNS would make sense or not?</div><br/><div id="41956487" class="c"><input type="checkbox" id="c-41956487" checked=""/><div class="controls bullet"><span class="by">latchkey</span><span>|</span><a href="#41956131">root</a><span>|</span><a href="#41956438">parent</a><span>|</span><a href="#41956196">next</a><span>|</span><label class="collapse" for="c-41956487">[-]</label><label class="expand" for="c-41956487">[8 more]</label></div><br/><div class="children"><div class="content">We are not talking about &quot;large web services&quot;, we are talking about small end users spinning up their own DNS-RR &quot;solution&quot;.<p>LWS get away with it because of Anycast...<p><a href="https:&#x2F;&#x2F;www.cloudflare.com&#x2F;en-gb&#x2F;learning&#x2F;cdn&#x2F;glossary&#x2F;anycast-network&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.cloudflare.com&#x2F;en-gb&#x2F;learning&#x2F;cdn&#x2F;glossary&#x2F;anyca...</a></div><br/><div id="41956552" class="c"><input type="checkbox" id="c-41956552" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#41956131">root</a><span>|</span><a href="#41956487">parent</a><span>|</span><a href="#41956196">next</a><span>|</span><label class="collapse" for="c-41956552">[-]</label><label class="expand" for="c-41956552">[7 more]</label></div><br/><div class="children"><div class="content">Anycast is certainly a nice layer to add but it&#x27;s not a requirement for DNS round robin to work reliably. It does save some of the concern around relying on selection of an efficiently close choice by the client though and can be a good option for failover.<p>More directly - is there some set of common web client I&#x27;ve been missing for many years that just doesn&#x27;t follow DNS TTLs or try alternate records? I think the article gets it right with the wish list at the end containing a Amazon Route 53-like &quot;pull dead entries automatically&quot; note but maybe I&#x27;m missing something else? I&#x27;ve used this approach (pull the dead server entries from DNS, wait for TTL) and never caught any unexpected failures during outages but maybe I haven&#x27;t been looking in the right places?<p>If you mean it&#x27;s possible to design something with round-robin DNS in a way that more clients than you expect will fail then absolutely, you can do things the wrong way with most any solution. Sometimes you can be fine with a subset of clients not always working during an outage or you can be fine with a solution which provides slower failover than an active load balancer. What I&#x27;m trying to find is why round-robin DNS must always be the wrong answer in all design cases.</div><br/><div id="41956869" class="c"><input type="checkbox" id="c-41956869" checked=""/><div class="controls bullet"><span class="by">buzer</span><span>|</span><a href="#41956131">root</a><span>|</span><a href="#41956552">parent</a><span>|</span><a href="#41956727">next</a><span>|</span><label class="collapse" for="c-41956869">[-]</label><label class="expand" for="c-41956869">[1 more]</label></div><br/><div class="children"><div class="content">&gt; More directly - is there some set of common web client I&#x27;ve been missing for many years that just doesn&#x27;t follow DNS TTLs or try alternate records?<p>I don&#x27;t know if there is such a list but older versions of Java are pretty famous for caching the DNS responses indefinitely. I don&#x27;t hear much about it these days so I assume it was probably fixed around Java 8.</div><br/></div></div><div id="41956727" class="c"><input type="checkbox" id="c-41956727" checked=""/><div class="controls bullet"><span class="by">latchkey</span><span>|</span><a href="#41956131">root</a><span>|</span><a href="#41956552">parent</a><span>|</span><a href="#41956869">prev</a><span>|</span><a href="#41956196">next</a><span>|</span><label class="collapse" for="c-41956727">[-]</label><label class="expand" for="c-41956727">[5 more]</label></div><br/><div class="children"><div class="content">&gt; <i>is there some set of common web client I&#x27;ve been missing for many years that just doesn&#x27;t follow DNS TTLs or try alternate records?</i><p>Yes. There are tons of people with outdated and&#x2F;or buggy software still using the internet today.</div><br/><div id="41956756" class="c"><input type="checkbox" id="c-41956756" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#41956131">root</a><span>|</span><a href="#41956727">parent</a><span>|</span><a href="#41956196">next</a><span>|</span><label class="collapse" for="c-41956756">[-]</label><label class="expand" for="c-41956756">[4 more]</label></div><br/><div class="children"><div class="content">What % did you find to be &quot;tons&quot; with these specific bugs? I&#x27;m assuming it was quite a significant number (at least 10%?) that broke badly quite often given the certainty it&#x27;s the wrong decision for all solutions, any idea how to help me identify which clients I&#x27;ve been missing or might run into? DNS TTLs are also pretty necessary for most web systems to work reliably, regardless of load balancer or not, so what ways do you work around having large numbers of clients which don&#x27;t obey them (beyond hoping to permanently occupy the same set of IPs for the life of the service of course)?</div><br/><div id="41957447" class="c"><input type="checkbox" id="c-41957447" checked=""/><div class="controls bullet"><span class="by">latchkey</span><span>|</span><a href="#41956131">root</a><span>|</span><a href="#41956756">parent</a><span>|</span><a href="#41956196">next</a><span>|</span><label class="collapse" for="c-41957447">[-]</label><label class="expand" for="c-41957447">[3 more]</label></div><br/><div class="children"><div class="content">The percentage is kind of irrelevant. The issue is that if you&#x27;re running something like an e-commerce site and any percentage of people can&#x27;t hit your site because of a TTL issue with one of your down servers, you&#x27;re likely to never know how much lost revenue you&#x27;ve had. Site is down, go to another store to buy what you need. You also have no control over fixing the issue, other than to get the server back and running. This has downstream effects, how do you cycle the server for upgrades or maintenance?<p>I don&#x27;t understand why anyone would argue for this as a solution when there are near zero effort better ways of doing this that don&#x27;t have any of the negative downsides.</div><br/><div id="41959119" class="c"><input type="checkbox" id="c-41959119" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#41956131">root</a><span>|</span><a href="#41957447">parent</a><span>|</span><a href="#41956196">next</a><span>|</span><label class="collapse" for="c-41959119">[-]</label><label class="expand" for="c-41959119">[2 more]</label></div><br/><div class="children"><div class="content">Why should OpenFreeMapbuild, a free public service with no SLAs, build their solutions based on what&#x27;s optimal for an e-commerce site to retain customer instead of what&#x27;s optimal for their project&#x27;s needs? Some clients can afford to lose connectivity during an active outage, not everyone is the worst case. My web service using round-robin DNS is not an ecommerce site either, the users have already paid by the time they are using it and none have ever filed a ticket or noted a complaint in the service review about the failover being slow or unreliable so why should I build it different just because some other use case could theoretically be losing a customer during an active outage?<p>Running load balancers does have a downside, every single design choice other than &quot;don&#x27;t do anything&quot; is another point of configuration and cost. Round-robin based DNS solutions often require nothing more than adding a second A record and are possible the simplest solution to many problems for that reason. Many cloud DNS systems offer automatic pullout functionality if that&#x27;s even a need, keeping cases where pullout is a must still not needing to move to more complex answers.<p>Solutions only make sense in context of what service one is delivering, not in what thinks sounds sexiest, what is the absolute best, or what could be a possible problem in some other use case. That you can think of a case it could possibly not work out is not the same thing as an example of why it&#x27;s a bad design for everyone - or even that scenario. If you can&#x27;t gather data the answer is to find a way to do so and make a data driven decision, not swag based on personal opinion. Not every app is only correctly scoped when resources are put in to make it a fluid 144 FPS native experience in &lt;1 MB package, not every DC needs 2n redundancy to be up enough for its customers, not every database needs to be designed to scale to a billion users, and not every web service needs a load balancer to be reliable enough for the use case.</div><br/><div id="41959250" class="c"><input type="checkbox" id="c-41959250" checked=""/><div class="controls bullet"><span class="by">latchkey</span><span>|</span><a href="#41956131">root</a><span>|</span><a href="#41959119">parent</a><span>|</span><a href="#41956196">next</a><span>|</span><label class="collapse" for="c-41959250">[-]</label><label class="expand" for="c-41959250">[1 more]</label></div><br/><div class="children"><div class="content">If your use case is so inconsequential as to not have any sort of negative impacts from outages, you don&#x27;t need round robin dns. You just have one IP address and you&#x27;re done. That is truly the simplest solution here.<p>If you get to the point of needing what you think RRD is providing you, then you might as well do it using a solution that doesn&#x27;t have the negative side effects of RRD.<p>If you are going as far as using a cloud dns system with &quot;automatic pullout&quot;, then you might as well just use a cloud dns, like CF, that solves the round robin dns known issues for you.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41956196" class="c"><input type="checkbox" id="c-41956196" checked=""/><div class="controls bullet"><span class="by">arrty88</span><span>|</span><a href="#41956131">parent</a><span>|</span><a href="#41956250">prev</a><span>|</span><a href="#41957435">next</a><span>|</span><label class="collapse" for="c-41956196">[-]</label><label class="expand" for="c-41956196">[2 more]</label></div><br/><div class="children"><div class="content">The standard today is to use a relatively low TTL and to health check the members of the pool from the dns server.</div><br/><div id="41956214" class="c"><input type="checkbox" id="c-41956214" checked=""/><div class="controls bullet"><span class="by">latchkey</span><span>|</span><a href="#41956131">root</a><span>|</span><a href="#41956196">parent</a><span>|</span><a href="#41957435">next</a><span>|</span><label class="collapse" for="c-41956214">[-]</label><label class="expand" for="c-41956214">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s like saying there are traffic rules in Saigon.<p>Exact implementation of TTL, is a suggestion.</div><br/></div></div></div></div></div></div><div id="41957435" class="c"><input type="checkbox" id="c-41957435" checked=""/><div class="controls bullet"><span class="by">realchaika</span><span>|</span><a href="#41956131">prev</a><span>|</span><a href="#41958379">next</a><span>|</span><label class="collapse" for="c-41957435">[-]</label><label class="expand" for="c-41957435">[1 more]</label></div><br/><div class="children"><div class="content">May be worth mentioning Zero downtime failover is a Pro or higher feature I believe, that&#x27;s how it was documented before as well, back when protect your origin server docs were split by plan level. So you may see different behavior&#x2F;retries.</div><br/></div></div><div id="41958379" class="c"><input type="checkbox" id="c-41958379" checked=""/><div class="controls bullet"><span class="by">neuroelectron</span><span>|</span><a href="#41957435">prev</a><span>|</span><a href="#41958142">next</a><span>|</span><label class="collapse" for="c-41958379">[-]</label><label class="expand" for="c-41958379">[1 more]</label></div><br/><div class="children"><div class="content">We used to do this at Amazon in the 00&#x27;s for onsite hosts. At the time round robin DNS was the fastest way to load balance as even with dedicated load balancers of the time, the latency was a few milliseconds slower. A lot of the decisions didn&#x27;t make sense to me and seemed to be grandfathered in from the 90&#x27;s.<p>We had a dedicated DNS host and various other dedicated hosts for various services related to order fulfillment. A batch job would be downloaded in the morning to the order server (app) and split up amongst the symbol scanners which ran basic terminals.  To keep latency as low as possible the scanners would dns round robin. I&#x27;m not sure how much that helped because the wifi was by far the biggest bottleneck simply for the fact of interference, reflection and so on.<p>With this setup an outage would have no effect the throughput of the warehouse since the batch job was all handled locally. As we moved toward same day shipping of course this was no longer a good solution and we moved to redundant, dedicated fiber and cellular data backup then almost completely remote servers for everything but app servers. So what we were left with was million dollars hvac to cool a quarter rack of hardware and a bunch of redundant onsite tech workers.</div><br/></div></div><div id="41958142" class="c"><input type="checkbox" id="c-41958142" checked=""/><div class="controls bullet"><span class="by">freitasm</span><span>|</span><a href="#41958379">prev</a><span>|</span><a href="#41956657">next</a><span>|</span><label class="collapse" for="c-41958142">[-]</label><label class="expand" for="c-41958142">[2 more]</label></div><br/><div class="children"><div class="content">Interesting. The author starts by discussing DNS round robin but then briefly touches on Cloudflare Load Balancing.<p>I use this feature, and there are options to control Affinity, Geolocation and others. I don&#x27;t see this discussed in the article, so I&#x27;m not sure why Cloudflare load balancing is mentioned if the author does not test the whole thing.<p>Their Cloudflare wishlist includes &quot;Offline servers should be detected.&quot;<p>This is also interesting because when creating a Cloudflare load balancing configuration, you create monitors, and if one is down, Cloudflare will automatically switch to other origin servers.<p>These screenshots show what I see on my Load Balancing configuration options:<p><a href="https:&#x2F;&#x2F;cdn.geekzone.co.nz&#x2F;imagessubs&#x2F;62250c035c074a1ee6e98668974359dd.jpg" rel="nofollow">https:&#x2F;&#x2F;cdn.geekzone.co.nz&#x2F;imagessubs&#x2F;62250c035c074a1ee6e986...</a><p><a href="https:&#x2F;&#x2F;cdn.geekzone.co.nz&#x2F;imagessubs&#x2F;04654d4cdda2d6d1976f8630c779859d.jpg" rel="nofollow">https:&#x2F;&#x2F;cdn.geekzone.co.nz&#x2F;imagessubs&#x2F;04654d4cdda2d6d1976f86...</a></div><br/><div id="41958284" class="c"><input type="checkbox" id="c-41958284" checked=""/><div class="controls bullet"><span class="by">hyperknot</span><span>|</span><a href="#41958142">parent</a><span>|</span><a href="#41956657">next</a><span>|</span><label class="collapse" for="c-41958284">[-]</label><label class="expand" for="c-41958284">[1 more]</label></div><br/><div class="children"><div class="content">I briefly mention that I don&#x27;t go into L7 Load Balancing because it&#x27;d be cost prohibitive for my use case (millions of requests).<p>Also, the article is about DNS-RR, not the L7 solution.</div><br/></div></div></div></div><div id="41956657" class="c"><input type="checkbox" id="c-41956657" checked=""/><div class="controls bullet"><span class="by">hypeatei</span><span>|</span><a href="#41958142">prev</a><span>|</span><a href="#41957357">next</a><span>|</span><label class="collapse" for="c-41956657">[-]</label><label class="expand" for="c-41956657">[1 more]</label></div><br/><div class="children"><div class="content">The browser behavior is really nice, good to know that it falls back quickly and smoothly. Round robin DNS has always been referred to as a &quot;poor mans load balancer&quot; which it seems to be living up to.<p>&gt; Curl also works correctly. First time it might not, but if you run the command twice, it always corrects to the nearest server.<p>This took two tries for me, which begs the question how curl is keeping track of RTT (round trip times), interesting.</div><br/></div></div><div id="41957357" class="c"><input type="checkbox" id="c-41957357" checked=""/><div class="controls bullet"><span class="by">edm0nd</span><span>|</span><a href="#41956657">prev</a><span>|</span><a href="#41957580">next</a><span>|</span><label class="collapse" for="c-41957357">[-]</label><label class="expand" for="c-41957357">[1 more]</label></div><br/><div class="children"><div class="content">The dark remix version of this is fast flux hosting and what a lot of the bulletproof hosting providers use.<p><a href="https:&#x2F;&#x2F;unit42.paloaltonetworks.com&#x2F;fast-flux-101&#x2F;" rel="nofollow">https:&#x2F;&#x2F;unit42.paloaltonetworks.com&#x2F;fast-flux-101&#x2F;</a></div><br/></div></div><div id="41957580" class="c"><input type="checkbox" id="c-41957580" checked=""/><div class="controls bullet"><span class="by">nielsole</span><span>|</span><a href="#41957357">prev</a><span>|</span><a href="#41957621">next</a><span>|</span><label class="collapse" for="c-41957580">[-]</label><label class="expand" for="c-41957580">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Curl also works correctly. First time it might not, but if you run the command twice, it always corrects to the nearest server.<p>I always assumed curl was stateless between invocations. What&#x27;s going on here?</div><br/><div id="41957794" class="c"><input type="checkbox" id="c-41957794" checked=""/><div class="controls bullet"><span class="by">barrkel</span><span>|</span><a href="#41957580">parent</a><span>|</span><a href="#41957621">next</a><span>|</span><label class="collapse" for="c-41957794">[-]</label><label class="expand" for="c-41957794">[3 more]</label></div><br/><div class="children"><div class="content">My hypothesis: he&#x27;s running on macOS and he&#x27;s seeing the same behavior from Safari as from curl because they&#x27;re both using OS-provided name resolution which is doing the lowest-latency selection.<p>Firefox and Chrome use DNS over HTTPS by default I believe, which may mean they use a different name resolution path.<p>The above is entirely conjection on my part, but the guess is heavily informed by the surprise of curl&#x27;s behavior.</div><br/><div id="41959998" class="c"><input type="checkbox" id="c-41959998" checked=""/><div class="controls bullet"><span class="by">plagiat0r</span><span>|</span><a href="#41957580">root</a><span>|</span><a href="#41957794">parent</a><span>|</span><a href="#41958250">next</a><span>|</span><label class="collapse" for="c-41959998">[-]</label><label class="expand" for="c-41959998">[1 more]</label></div><br/><div class="children"><div class="content">But this does not make sense. How Mac operating system resolver are supposed to test the latency of (A)ddress records? Browser use this network address to actually make a tcp connection on 443 and measure latency here. Or udp&#x2F;443 when using http3&#x2F;quic.<p>But operating system resolver only speak with DNS servers. It does not make https connections to calculate latency which would pick &quot;the closest server&quot;. Also dns had no way to tell what port you will be using, maybe service is on 8443 or something.<p>For geo DNS I&#x27;ve built a custom backed for powerdns with geo DNS capabilities and healthckecks to quickly remove a broken vps from the DNS responses.</div><br/></div></div><div id="41958250" class="c"><input type="checkbox" id="c-41958250" checked=""/><div class="controls bullet"><span class="by">hyperknot</span><span>|</span><a href="#41957580">root</a><span>|</span><a href="#41957794">parent</a><span>|</span><a href="#41959998">prev</a><span>|</span><a href="#41957621">next</a><span>|</span><label class="collapse" for="c-41958250">[-]</label><label class="expand" for="c-41958250">[1 more]</label></div><br/><div class="children"><div class="content">Correct. I&#x27;m on macOS and I tried turning off DoH in Firefox and then it worked like Safari.</div><br/></div></div></div></div></div></div><div id="41957621" class="c"><input type="checkbox" id="c-41957621" checked=""/><div class="controls bullet"><span class="by">mlhpdx</span><span>|</span><a href="#41957580">prev</a><span>|</span><a href="#41957768">next</a><span>|</span><label class="collapse" for="c-41957621">[-]</label><label class="expand" for="c-41957621">[1 more]</label></div><br/><div class="children"><div class="content">Interesting topic for me, and I’ve been looking at anycast IP services and latency based DNS resolvers as well. I even  made a repo[1] for anyone interested in a quick start for setting up AWS global accelerator.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;mlhpdx&#x2F;cloudformation-examples&#x2F;tree&#x2F;master&#x2F;global-accelerator">https:&#x2F;&#x2F;github.com&#x2F;mlhpdx&#x2F;cloudformation-examples&#x2F;tree&#x2F;maste...</a></div><br/></div></div><div id="41957768" class="c"><input type="checkbox" id="c-41957768" checked=""/><div class="controls bullet"><span class="by">why-el</span><span>|</span><a href="#41957621">prev</a><span>|</span><a href="#41959382">next</a><span>|</span><label class="collapse" for="c-41957768">[-]</label><label class="expand" for="c-41957768">[1 more]</label></div><br/><div class="children"><div class="content">Hm, I thought Happy Eyeballs (HE) was mainly concerned with IPv6 issues and falling back to IPV4. I didn&#x27;t think it was this RFC in which finally some words were said about round-robin specifically, but it looks like it was (from this article).<p>Is it true then that before HE, most round-robin implementations simply cycled and no one considered latency? That&#x27;s a very surprising finding.</div><br/></div></div><div id="41959382" class="c"><input type="checkbox" id="c-41959382" checked=""/><div class="controls bullet"><span class="by">backtoyoujim</span><span>|</span><a href="#41957768">prev</a><span>|</span><a href="#41958208">next</a><span>|</span><label class="collapse" for="c-41959382">[-]</label><label class="expand" for="c-41959382">[1 more]</label></div><br/><div class="children"><div class="content">&quot;I wrote a decoder in Perl.  Everything must be in Perl.&quot;<p>preach on.</div><br/></div></div><div id="41958208" class="c"><input type="checkbox" id="c-41958208" checked=""/><div class="controls bullet"><span class="by">bar000n</span><span>|</span><a href="#41959382">prev</a><span>|</span><a href="#41956424">next</a><span>|</span><label class="collapse" for="c-41958208">[-]</label><label class="expand" for="c-41958208">[1 more]</label></div><br/><div class="children"><div class="content">hey! so i got a cdn for video made of 4 bare metals and 2 are newer and more powerful so i give them each 2 ip addresses from the 6 addresses replied by dns for the respective a record. but from a very diverse pool of devices (proprietary set top boxes, smart tv sets, mobile clients ios and android, web browsers, etc) i still get ~40% of traffic on the older servers instead of the expected 33% given 2 out of 6 ip addresses resolved as dns a records for these hosts. why?</div><br/></div></div><div id="41956424" class="c"><input type="checkbox" id="c-41956424" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#41958208">prev</a><span>|</span><a href="#41957586">next</a><span>|</span><label class="collapse" for="c-41956424">[-]</label><label class="expand" for="c-41956424">[2 more]</label></div><br/><div class="children"><div class="content">Take a look at SRV records instead - they are very intentionally designed for this, and behave vaguely similarly to MX. Creating a DNS server (or a CoreDNS&#x2F;whatever module) that dynamically updates weights based on backend metrics has been a pending pet project of mine for some time now.</div><br/><div id="41957418" class="c"><input type="checkbox" id="c-41957418" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#41956424">parent</a><span>|</span><a href="#41957586">next</a><span>|</span><label class="collapse" for="c-41957418">[-]</label><label class="expand" for="c-41957418">[1 more]</label></div><br/><div class="children"><div class="content">Until the HTTP spec gets updated to include SRV records, using SRV records for HTTP(S) is technically spec-incompliant and practically useless.<p>However, as is common with web tech, the old SRV record has been reinvented as the SVCB record with a smidge of DANE for good measure.</div><br/></div></div></div></div><div id="41957586" class="c"><input type="checkbox" id="c-41957586" checked=""/><div class="controls bullet"><span class="by">jkrauska</span><span>|</span><a href="#41956424">prev</a><span>|</span><a href="#41957178">next</a><span>|</span><label class="collapse" for="c-41957586">[-]</label><label class="expand" for="c-41957586">[1 more]</label></div><br/><div class="children"><div class="content">Check out what happens when you use IPv6 addresses.  RFC 6724 is awkward about ordering with IPv6.<p>How your OS sorts DNS responses also comes in to play.  Depends on what your browser makes DNS requests.</div><br/></div></div><div id="41957178" class="c"><input type="checkbox" id="c-41957178" checked=""/><div class="controls bullet"><span class="by">rebelde</span><span>|</span><a href="#41957586">prev</a><span>|</span><a href="#41956280">next</a><span>|</span><label class="collapse" for="c-41957178">[-]</label><label class="expand" for="c-41957178">[1 more]</label></div><br/><div class="children"><div class="content">I have use round robin for years.<p>Wish I could add instructions like:<p>- random choice #round robin, like now<p>- first response # usually connects to closest server<p>- weights (1.0.0.1:40%; 2.0.0.2:60%)<p>- failover: (quick | never)<p>- etc: naming countries, continents</div><br/></div></div><div id="41956280" class="c"><input type="checkbox" id="c-41956280" checked=""/><div class="controls bullet"><span class="by">cybice</span><span>|</span><a href="#41957178">prev</a><span>|</span><a href="#41956389">next</a><span>|</span><label class="collapse" for="c-41956280">[-]</label><label class="expand" for="c-41956280">[3 more]</label></div><br/><div class="children"><div class="content">Cloudflare results with worker as a reverse proxy can be much better.</div><br/><div id="41956608" class="c"><input type="checkbox" id="c-41956608" checked=""/><div class="controls bullet"><span class="by">easylion</span><span>|</span><a href="#41956280">parent</a><span>|</span><a href="#41956389">next</a><span>|</span><label class="collapse" for="c-41956608">[-]</label><label class="expand" for="c-41956608">[2 more]</label></div><br/><div class="children"><div class="content">But won&#x27;t it add an additional hop hence additional latency to every single request ?</div><br/><div id="41956794" class="c"><input type="checkbox" id="c-41956794" checked=""/><div class="controls bullet"><span class="by">rodcodes</span><span>|</span><a href="#41956280">root</a><span>|</span><a href="#41956608">parent</a><span>|</span><a href="#41956389">next</a><span>|</span><label class="collapse" for="c-41956794">[-]</label><label class="expand" for="c-41956794">[1 more]</label></div><br/><div class="children"><div class="content">Nah, because the Cloudflare Workers run at closest edge location and are real fast.<p>The real solution with Cloudflare is to use their Load Balancing (<a href="https:&#x2F;&#x2F;developers.cloudflare.com&#x2F;load-balancing" rel="nofollow">https:&#x2F;&#x2F;developers.cloudflare.com&#x2F;load-balancing</a>) which is a paid feature.</div><br/></div></div></div></div></div></div><div id="41956389" class="c"><input type="checkbox" id="c-41956389" checked=""/><div class="controls bullet"><span class="by">urbandw311er</span><span>|</span><a href="#41956280">prev</a><span>|</span><a href="#41957132">next</a><span>|</span><label class="collapse" for="c-41956389">[-]</label><label class="expand" for="c-41956389">[1 more]</label></div><br/><div class="children"><div class="content">What a great article! It’s often easy to forget just how flexible and self-correcting the “official” network protocols are. Thanks to the author for putting in the legwork.</div><br/></div></div><div id="41956290" class="c"><input type="checkbox" id="c-41956290" checked=""/><div class="controls bullet"><span class="by">specto</span><span>|</span><a href="#41957132">prev</a><span>|</span><a href="#41956184">next</a><span>|</span><label class="collapse" for="c-41956290">[-]</label><label class="expand" for="c-41956290">[1 more]</label></div><br/><div class="children"><div class="content">Chrome and Firefox use the OS dns server by default, which in most OS&#x27; have caching as well.</div><br/></div></div><div id="41956184" class="c"><input type="checkbox" id="c-41956184" checked=""/><div class="controls bullet"><span class="by">easylion</span><span>|</span><a href="#41956290">prev</a><span>|</span><a href="#41957415">next</a><span>|</span><label class="collapse" for="c-41956184">[-]</label><label class="expand" for="c-41956184">[1 more]</label></div><br/><div class="children"><div class="content">did you try running a simple bash curl loop instead of manually printing. The data and statistics will be become exactly clear. Because i want to understand how to ensure my clients get the nearest edge data center</div><br/></div></div><div id="41957415" class="c"><input type="checkbox" id="c-41957415" checked=""/><div class="controls bullet"><span class="by">stackskipton</span><span>|</span><a href="#41956184">prev</a><span>|</span><a href="#41958306">next</a><span>|</span><label class="collapse" for="c-41957415">[-]</label><label class="expand" for="c-41957415">[5 more]</label></div><br/><div class="children"><div class="content">As SRE, I get a chuckle out of this article and some of the responses. Devs mess this up constantly.<p>DNS has one job. Hostname -&gt; IP. Nothing further. You can mess with it on server side like checking to see if HTTP server is up before delivering the IP but once IP is given, the client takes over and DNS can do nothing further so behavior will be wildly inconsistent IME.<p>Assuming DNS RR is standard where Hostname returns multiple IPs, then it&#x27;s only useful for load balancing in similar latency datacenters. If you want fancy stuff like geographic load balancing or health checks, you need fancy DNS server but at end of day, you should only return single IP so client will target the endpoint you want them to connect to.</div><br/><div id="41960026" class="c"><input type="checkbox" id="c-41960026" checked=""/><div class="controls bullet"><span class="by">plagiat0r</span><span>|</span><a href="#41957415">parent</a><span>|</span><a href="#41957549">next</a><span>|</span><label class="collapse" for="c-41960026">[-]</label><label class="expand" for="c-41960026">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve implemented a custom powerdns backend that combines heathchecks, weighted probabilistic round robin, and geo DNS and it works excellent to build and auto healing CDN.<p>It was specifically built for multi DC or multi cloud or hybrid operations that are on separate continents, with geo DNS, heathchecks and faiolver on the DNS level at the same time. When all usa servers in the WRR pool are down, or DC is down, it starts to answers the closest next set of WRR (Canada) automatically.WRR pools are dynamic and auto healing, constantly doing http heathchecks.<p>It is also dirt cheap, like 100x cheaper as opposed to aquire provider independent IP address space and run and operate AnyCast and having 24&#x2F;7 NOC teams on this AnyCast, constantly adjusting bgp communities etc. and it is not like anycast and bgp solve anything when one server is down but other works. You can&#x27;t stop announcing whole prefix if you run 200 machines but only one or two are down.<p>TTL I&#x27;m using is 30 seconds.<p>I never shared this backed with the world, you can&#x27;t test it or purchase it. But maybe some day I&#x27;ll launch a route53 competitor ;)</div><br/></div></div><div id="41957549" class="c"><input type="checkbox" id="c-41957549" checked=""/><div class="controls bullet"><span class="by">lysace</span><span>|</span><a href="#41957415">parent</a><span>|</span><a href="#41960026">prev</a><span>|</span><a href="#41958306">next</a><span>|</span><label class="collapse" for="c-41957549">[-]</label><label class="expand" for="c-41957549">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never ever come up with a scenario where RR DNS is useful in the goal of achieving high availability. I&#x27;m similarly mystified.<p>What can be useful: dynamically adjusting DNS responses depending on what DC is up. But at this point shouldn&#x27;t you be doing something via BGP instead? (This is where my knowledge breaks down.)</div><br/><div id="41957696" class="c"><input type="checkbox" id="c-41957696" checked=""/><div class="controls bullet"><span class="by">stackskipton</span><span>|</span><a href="#41957415">root</a><span>|</span><a href="#41957549">parent</a><span>|</span><a href="#41958306">next</a><span>|</span><label class="collapse" for="c-41957696">[-]</label><label class="expand" for="c-41957696">[2 more]</label></div><br/><div class="children"><div class="content">Yea, Anycast IP like what Cloudflare does is the best.<p>If you want cheaper load balancing and are ok with some downtime while DNS reconfigures, DNS system that returns IP based on which Datacenter is up works. Examples of this are Route53, Azure Traffic Manager and I assume Google has solution, I just don&#x27;t know what it is.</div><br/><div id="41957919" class="c"><input type="checkbox" id="c-41957919" checked=""/><div class="controls bullet"><span class="by">lysace</span><span>|</span><a href="#41957415">root</a><span>|</span><a href="#41957696">parent</a><span>|</span><a href="#41958306">next</a><span>|</span><label class="collapse" for="c-41957919">[-]</label><label class="expand" for="c-41957919">[1 more]</label></div><br/><div class="children"><div class="content">Worked on implementing a distributed-consensus driven DNS thing like 15 years ago. We had 3 DCs around the world for a very compute-intense but not very stateful service. It actually just worked without any meaningful testing on the first single DC outage. In retrospect I&#x27;m amazed.</div><br/></div></div></div></div></div></div></div></div><div id="41958306" class="c"><input type="checkbox" id="c-41958306" checked=""/><div class="controls bullet"><span class="by">kawsper</span><span>|</span><a href="#41957415">prev</a><span>|</span><a href="#41956870">next</a><span>|</span><label class="collapse" for="c-41958306">[-]</label><label class="expand" for="c-41958306">[1 more]</label></div><br/><div class="children"><div class="content">37signals&#x2F;Basecamp wrote about something similar on their blog, they saw traffic switching almost immediately: <a href="https:&#x2F;&#x2F;signalvnoise.com&#x2F;posts&#x2F;3857-when-disaster-strikes" rel="nofollow">https:&#x2F;&#x2F;signalvnoise.com&#x2F;posts&#x2F;3857-when-disaster-strikes</a> and in their comments they said it was hinted that it was just a DNS update with low TTLs.</div><br/></div></div><div id="41956870" class="c"><input type="checkbox" id="c-41956870" checked=""/><div class="controls bullet"><span class="by">V__</span><span>|</span><a href="#41958306">prev</a><span>|</span><a href="#41958446">next</a><span>|</span><label class="collapse" for="c-41956870">[-]</label><label class="expand" for="c-41956870">[2 more]</label></div><br/><div class="children"><div class="content">This seems like a nice solution for zero-downtime updates. Clone the server, add a the specified ip, deny access to the main one, upgrade and turn the cloned server off.</div><br/><div id="41959867" class="c"><input type="checkbox" id="c-41959867" checked=""/><div class="controls bullet"><span class="by">nrnrjrjrj</span><span>|</span><a href="#41956870">parent</a><span>|</span><a href="#41958446">next</a><span>|</span><label class="collapse" for="c-41959867">[-]</label><label class="expand" for="c-41959867">[1 more]</label></div><br/><div class="children"><div class="content">Those exact words (aka blue green deployment) apply to loadbalancers too and they can do it better. They can even do health checks and slowly ramp traffic to the new server and back off if things go bad for an automated rollback.</div><br/></div></div></div></div><div id="41958446" class="c"><input type="checkbox" id="c-41958446" checked=""/><div class="controls bullet"><span class="by">tiahura</span><span>|</span><a href="#41956870">prev</a><span>|</span><a href="#41956244">next</a><span>|</span><label class="collapse" for="c-41958446">[-]</label><label class="expand" for="c-41958446">[1 more]</label></div><br/><div class="children"><div class="content">Back in the day DNS consumed a lot more oxygen - Bind, double-reverse mx records, windows dns, etc. What happened? Did cloud make all of that go away?</div><br/></div></div><div id="41956244" class="c"><input type="checkbox" id="c-41956244" checked=""/><div class="controls bullet"><span class="by">meindnoch</span><span>|</span><a href="#41958446">prev</a><span>|</span><label class="collapse" for="c-41956244">[-]</label><label class="expand" for="c-41956244">[2 more]</label></div><br/><div class="children"><div class="content">So half of your content is served from another server? Sounds like a recipe for inconsistent states.</div><br/><div id="41956760" class="c"><input type="checkbox" id="c-41956760" checked=""/><div class="controls bullet"><span class="by">ChocolateGod</span><span>|</span><a href="#41956244">parent</a><span>|</span><label class="collapse" for="c-41956760">[-]</label><label class="expand" for="c-41956760">[1 more]</label></div><br/><div class="children"><div class="content">You can easily use something like an object store or shared database to keep data consistent.</div><br/></div></div></div></div></div></div></div></div></div></body></html>