<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1723194080904" as="style"/><link rel="stylesheet" href="styles.css?v=1723194080904"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://bughunters.google.com/blog/6303226026131456/a-deep-dive-into-cve-2023-2163-how-we-found-and-fixed-an-ebpf-linux-kernel-vulnerability">How we found and fixed an eBPF Linux kernel vulnerability</a> <span class="domain">(<a href="https://bughunters.google.com">bughunters.google.com</a>)</span></div><div class="subtext"><span>xxmarkuski</span> | <span>53 comments</span></div><br/><div><div id="41192012" class="c"><input type="checkbox" id="c-41192012" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41191094">next</a><span>|</span><label class="collapse" for="c-41192012">[-]</label><label class="expand" for="c-41192012">[8 more]</label></div><br/><div class="children"><div class="content">A reminder that on the platforms eBPF is most commonly used, verifier bugs don&#x27;t matter much, because unprivileged code isn&#x27;t allowed to load eBPF programs to begin with. Bugs like this are thus root -&gt; ring0 vulnerabilities. That&#x27;s not nothing, but for serverside work it&#x27;s usually worth the tradeoff, especially because eBPF&#x27;s track record for kernel LPEs is actually pretty strong compared to the kernel as a whole.<p>In the setting eBPF is used today, most of the value of the verifier is that it&#x27;s hard to <i>accidentally</i> crash your kernel with a bad eBPF program. That is comically untrue about an ordinary LKM.</div><br/><div id="41192378" class="c"><input type="checkbox" id="c-41192378" checked=""/><div class="controls bullet"><span class="by">chc4</span><span>|</span><a href="#41192012">parent</a><span>|</span><a href="#41193937">next</a><span>|</span><label class="collapse" for="c-41192378">[-]</label><label class="expand" for="c-41192378">[1 more]</label></div><br/><div class="children"><div class="content">The PoC uses eBPF maps as their out-of-bounds pointer, but it sounds like it would also be exploitable via non-extended BPF programs loadable via seccomp since it&#x27;s just improper scalar value range tracking, which doesn&#x27;t require any privileges on most platforms.<p>And, of course, root -&gt; ring0 is less of a problem with unprivileged user namespaces where you can make yourself &quot;root&quot;, as we&#x27;ve seen in every eBPF bug PoC since distros started turning that on (and have since turned it off again, mostly)</div><br/></div></div><div id="41193937" class="c"><input type="checkbox" id="c-41193937" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#41192012">parent</a><span>|</span><a href="#41192378">prev</a><span>|</span><a href="#41194535">next</a><span>|</span><label class="collapse" for="c-41193937">[-]</label><label class="expand" for="c-41193937">[2 more]</label></div><br/><div class="children"><div class="content">Verifier bugs matter because resolving them is a prerequisite for secure unprivileged use of eBPF.</div><br/><div id="41194533" class="c"><input type="checkbox" id="c-41194533" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41192012">root</a><span>|</span><a href="#41193937">parent</a><span>|</span><a href="#41194535">next</a><span>|</span><label class="collapse" for="c-41194533">[-]</label><label class="expand" for="c-41194533">[1 more]</label></div><br/><div class="children"><div class="content">Put it this way: verifier bugs matter, but people probably don&#x27;t do unscheduled fleetwide updates to fix them.</div><br/></div></div></div></div><div id="41194535" class="c"><input type="checkbox" id="c-41194535" checked=""/><div class="controls bullet"><span class="by">dumpling777</span><span>|</span><a href="#41192012">parent</a><span>|</span><a href="#41193937">prev</a><span>|</span><a href="#41191094">next</a><span>|</span><label class="collapse" for="c-41194535">[-]</label><label class="expand" for="c-41194535">[4 more]</label></div><br/><div class="children"><div class="content">Let&#x27;s not forget also that we can give CAP_BPF to containers. With things like Cilium on the rise, the attack vector of landing in container environment that has cap_bpf is more and more realistic</div><br/><div id="41194555" class="c"><input type="checkbox" id="c-41194555" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41192012">root</a><span>|</span><a href="#41194535">parent</a><span>|</span><a href="#41191094">next</a><span>|</span><label class="collapse" for="c-41194555">[-]</label><label class="expand" for="c-41194555">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t believe shared-kernel container systems are real security boundaries to begin with, so, to me, a container running with CAP_BPF isn&#x27;t much different than any other program a machine owner might opt to run; the point is that you trust the workload, and so the verifier is more of a safety net than a vault door.</div><br/><div id="41198540" class="c"><input type="checkbox" id="c-41198540" checked=""/><div class="controls bullet"><span class="by">kortilla</span><span>|</span><a href="#41192012">root</a><span>|</span><a href="#41194555">parent</a><span>|</span><a href="#41191094">next</a><span>|</span><label class="collapse" for="c-41198540">[-]</label><label class="expand" for="c-41198540">[2 more]</label></div><br/><div class="children"><div class="content">That pessimistic view is not shared by everyone who is working on namespaces, cgroups, etc so I think that’s a pretty unproductive comment in this context.<p>It reminds me of early days in hypervisors when someone would get an exploit to break out of the isolation and someone would dismiss it because “virtual machines aren’t real isolation anyway”.<p>Look, I get it and I frankly agree with you in the current state of the world, but this is the time to shut up and get out of the way of people trying to make forward progress. Breakouts of containers are a big deal for people pushing the boundary there.</div><br/><div id="41198699" class="c"><input type="checkbox" id="c-41198699" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41192012">root</a><span>|</span><a href="#41198540">parent</a><span>|</span><a href="#41191094">next</a><span>|</span><label class="collapse" for="c-41198699">[-]</label><label class="expand" for="c-41198699">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know who you&#x27;re really talking to (it&#x27;s not me), but all I&#x27;m saying is that CAP_BPF doesn&#x27;t bother me much, because it&#x27;s problematic only for a security boundary that is already problematic with a much lower degree of difficulty for attackers than the eBPF verifier.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41196203" class="c"><input type="checkbox" id="c-41196203" checked=""/><div class="controls bullet"><span class="by">TacticalCoder</span><span>|</span><a href="#41191094">prev</a><span>|</span><a href="#41191167">next</a><span>|</span><label class="collapse" for="c-41196203">[-]</label><label class="expand" for="c-41196203">[4 more]</label></div><br/><div class="children"><div class="content">&gt; “Uno no es ninguno” (One is none)<p>Literally &quot;One not is none&quot;, aka &quot;One is <i>not</i> none&quot;.</div><br/><div id="41196937" class="c"><input type="checkbox" id="c-41196937" checked=""/><div class="controls bullet"><span class="by">jolmg</span><span>|</span><a href="#41196203">parent</a><span>|</span><a href="#41191167">next</a><span>|</span><label class="collapse" for="c-41196937">[-]</label><label class="expand" for="c-41196937">[3 more]</label></div><br/><div class="children"><div class="content">In Spanish, it&#x27;s common for double negatives to not actually be double negatives. For example, if you wanted to say &quot;there&#x27;s nothing here&quot;, you&#x27;d say &quot;no hay nada aquí&quot;, which word-for-word means &quot;there&#x27;s not nothing here&quot;.<p>Checking out the Royal Spanish Academy, here&#x27;s what they say about it:<p><a href="https:&#x2F;&#x2F;www.rae.es&#x2F;espanol-al-dia&#x2F;doble-negacion-no-vino-nadie-no-hice-nada-no-tengo-ninguna" rel="nofollow">https:&#x2F;&#x2F;www.rae.es&#x2F;espanol-al-dia&#x2F;doble-negacion-no-vino-nad...</a><p>&gt; The so-called &quot;double negation&quot; is due to the obligatory negative agreement that must be established in Spanish, and other Romance languages, in certain circumstances (see New Grammar, § 48.3d), which results in the joint presence in the statement of the adverb <i>no</i> and other elements that also have a negative meaning.<p>&gt; The concurrence of these two &quot;negations&quot; does not annul the negative meaning of the statement.</div><br/><div id="41199749" class="c"><input type="checkbox" id="c-41199749" checked=""/><div class="controls bullet"><span class="by">cassepipe</span><span>|</span><a href="#41196203">root</a><span>|</span><a href="#41196937">parent</a><span>|</span><a href="#41197542">next</a><span>|</span><label class="collapse" for="c-41199749">[-]</label><label class="expand" for="c-41199749">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s true but I don&#x27;t think this would apply for such a simple statement as in this case else how would you say &quot;One is <i>not</i> none&quot; in spanish ?</div><br/></div></div><div id="41197542" class="c"><input type="checkbox" id="c-41197542" checked=""/><div class="controls bullet"><span class="by">stirfish</span><span>|</span><a href="#41196203">root</a><span>|</span><a href="#41196937">parent</a><span>|</span><a href="#41199749">prev</a><span>|</span><a href="#41191167">next</a><span>|</span><label class="collapse" for="c-41197542">[-]</label><label class="expand" for="c-41197542">[1 more]</label></div><br/><div class="children"><div class="content">I like to think of it as additive negatives, as opposed to multiplicative negatives.</div><br/></div></div></div></div></div></div><div id="41191167" class="c"><input type="checkbox" id="c-41191167" checked=""/><div class="controls bullet"><span class="by">katzinsky</span><span>|</span><a href="#41196203">prev</a><span>|</span><a href="#41192062">next</a><span>|</span><label class="collapse" for="c-41191167">[-]</label><label class="expand" for="c-41191167">[31 more]</label></div><br/><div class="children"><div class="content">The one time I tried to use eBPF it wasn&#x27;t expressive enough for what I needed.<p>Does the limited flexibility it provides really justify the added kernel space complexity? I can understand it for packet filtering but some of the other stuff it&#x27;s used for like sandboxing just isn&#x27;t convincing.</div><br/><div id="41191228" class="c"><input type="checkbox" id="c-41191228" checked=""/><div class="controls bullet"><span class="by">knorker</span><span>|</span><a href="#41191167">parent</a><span>|</span><a href="#41191959">next</a><span>|</span><label class="collapse" for="c-41191228">[-]</label><label class="expand" for="c-41191228">[27 more]</label></div><br/><div class="children"><div class="content">There are other technologies for this, such as DTrace. The kernel&#x27;s choice isn&#x27;t eBPF or nothing, it&#x27;s eBPF or something else like it.<p>You may not use it much, but some people use it all day. I think FAANG engineers have said that they run tens (hundreds?) of these things on all servers, all the time. And that&#x27;s excluding one-offs. And FAANG has full time kernel coders on staff, so they&#x27;re also funding this complexity that they use.<p>But also yes, I&#x27;ve solved problems by using eBPF. Problems that are basically unsolvable by non-kernel-gurus without eBPF. I rarely need it. But when I need it, there&#x27;s nothing else that does the trick.<p>In some cases, even for kernel gurus, it&#x27;s a choice between eBPF or maintaining a custom kernel patch forever.</div><br/><div id="41192543" class="c"><input type="checkbox" id="c-41192543" checked=""/><div class="controls bullet"><span class="by">fch42</span><span>|</span><a href="#41191167">root</a><span>|</span><a href="#41191228">parent</a><span>|</span><a href="#41191363">next</a><span>|</span><label class="collapse" for="c-41192543">[-]</label><label class="expand" for="c-41192543">[19 more]</label></div><br/><div class="children"><div class="content">DTrace and eBPF are &quot;not so different&quot; in the sense that dtrace programs &#x2F; hooks are also a form of low-level code &#x2F; instruction set that the kernel (dtrace driver) validates at load. It&#x27;s an &quot;internal&quot; artifact of dtrace though, <a href="https:&#x2F;&#x2F;github.com&#x2F;illumos&#x2F;illumos-gate&#x2F;blob&#x2F;master&#x2F;usr&#x2F;src&#x2F;lib&#x2F;libdtrace&#x2F;common&#x2F;dt_cc.c">https:&#x2F;&#x2F;github.com&#x2F;illumos&#x2F;illumos-gate&#x2F;blob&#x2F;master&#x2F;usr&#x2F;src&#x2F;...</a> and to my knowledge, nothing like a clang&#x2F;gcc &quot;dtrace target&quot; exists to translate more-or-less arbitrary higher-level language &quot;to low-level dtrace&quot;.<p>The additional flexibility eBPF gets from this is amazing really. While dtrace is a more-targeted (and for its intended usecases, in some situations still superior to eBPF) but also less-general tool.<p>(citrus vs. stone fruit ...)</div><br/><div id="41193061" class="c"><input type="checkbox" id="c-41193061" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#41191167">root</a><span>|</span><a href="#41192543">parent</a><span>|</span><a href="#41191363">next</a><span>|</span><label class="collapse" for="c-41193061">[-]</label><label class="expand" for="c-41193061">[18 more]</label></div><br/><div class="children"><div class="content">DTrace&#x27;s bytecode machine is also very very limited.  eBPF&#x27;s is much less limited.  Limiting the scope of what a probe can do is very important.</div><br/><div id="41193794" class="c"><input type="checkbox" id="c-41193794" checked=""/><div class="controls bullet"><span class="by">bcantrill</span><span>|</span><a href="#41191167">root</a><span>|</span><a href="#41193061">parent</a><span>|</span><a href="#41191363">next</a><span>|</span><label class="collapse" for="c-41193794">[-]</label><label class="expand" for="c-41193794">[17 more]</label></div><br/><div class="children"><div class="content">Yes, thank you. Long before eBPF existed, we spent a ton of time on the safety of DTrace[0][1] -- there&#x27;s a bunch of subtlety to it.  The proof is in the pudding, however: thanks to our strict adherence to the safety constraint, we have absolute confidence in using DTrace in production.<p>[0] <a href="https:&#x2F;&#x2F;bcantrill.dtrace.org&#x2F;2005&#x2F;07&#x2F;19&#x2F;dtrace-safety&#x2F;" rel="nofollow">https:&#x2F;&#x2F;bcantrill.dtrace.org&#x2F;2005&#x2F;07&#x2F;19&#x2F;dtrace-safety&#x2F;</a><p>[1] <a href="https:&#x2F;&#x2F;www.usenix.org&#x2F;legacy&#x2F;publications&#x2F;library&#x2F;proceedings&#x2F;usenix04&#x2F;tech&#x2F;general&#x2F;full_papers&#x2F;cantrill&#x2F;cantrill.pdf" rel="nofollow">https:&#x2F;&#x2F;www.usenix.org&#x2F;legacy&#x2F;publications&#x2F;library&#x2F;proceedin...</a>, §3.3</div><br/><div id="41194409" class="c"><input type="checkbox" id="c-41194409" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41191167">root</a><span>|</span><a href="#41193794">parent</a><span>|</span><a href="#41191363">next</a><span>|</span><label class="collapse" for="c-41194409">[-]</label><label class="expand" for="c-41194409">[16 more]</label></div><br/><div class="children"><div class="content">I’m curious which part of these tenets would feel would have prevented the bug demonstrated, besides “oh we tried harder”? I don’t see any of those that seem unique to DTrace other than limiting where probes can be placed.</div><br/><div id="41194592" class="c"><input type="checkbox" id="c-41194592" checked=""/><div class="controls bullet"><span class="by">bcantrill</span><span>|</span><a href="#41191167">root</a><span>|</span><a href="#41194409">parent</a><span>|</span><a href="#41194521">next</a><span>|</span><label class="collapse" for="c-41194592">[-]</label><label class="expand" for="c-41194592">[3 more]</label></div><br/><div class="children"><div class="content">Well, we didn&#x27;t merely &quot;try harder&quot; -- we treated safety as a constraint which informed every aspect of the design.  And yes, treating safety as a constraint rather than merely an objective results in different implementation decisions.  From the article:<p><i>This working model significantly increases the attack surface of the kernel, since it allows executing arbitrary code at a high privilege level. Because of this risk, programs have to be verified before they can be loaded. This ensures that all eBPF security assumptions are met. The verifier, which consists of complex code, is responsible for this task.</i><p><i>Given how difficult the task of validating that a program is safe to execute is, there have been many vulnerabilities found within the eBPF verifier. When one of these vulnerabilities is exploited, the result is usually a local privilege escalation exploit (or container escape in containerized environments). While the verifier’s code has been audited extensively, this task also becomes harder as new features are added to eBPF and the complexity of the verifier grows</i><p>DTrace was developed over 20 years ago; there have not been &quot;many vulnerabilities&quot; found in the verifier -- and we have not grown the complexity of the verifier over time.  You can dismiss these as implementation details, but these details reflect different views of the problem and its contraints.</div><br/><div id="41194767" class="c"><input type="checkbox" id="c-41194767" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41191167">root</a><span>|</span><a href="#41194592">parent</a><span>|</span><a href="#41194521">next</a><span>|</span><label class="collapse" for="c-41194767">[-]</label><label class="expand" for="c-41194767">[2 more]</label></div><br/><div class="children"><div class="content">No, like, the bug that was demonstrated seems to be fairly fundamental to running any sort of bytecode in the kernel: they need to verify all branches, and this is potentially slow, so they optimize it (which is where the bug is). What are you doing differently? It seems to me that you’re either not going to optimize this or you are?</div><br/><div id="41195058" class="c"><input type="checkbox" id="c-41195058" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41191167">root</a><span>|</span><a href="#41194767">parent</a><span>|</span><a href="#41194521">next</a><span>|</span><label class="collapse" for="c-41195058">[-]</label><label class="expand" for="c-41195058">[1 more]</label></div><br/><div class="children"><div class="content">The DTrace instruction set is more limited than that of the eBPF VM; eBPF is essentially a fully functional ISA, where DTrace was (if I&#x27;m remembering this right) designed around the D script language. An eBPF program is often just a clang C program, and you&#x27;re trusting the kernel verifier to reject it if it can&#x27;t be proven safe. Further: eBPF programs are JIT&#x27;d to actual machine code; once you&#x27;ve loaded and verified an eBPF program, it has conceptually all the same power as, say, shellcode you managed to load into the kernel via an LPE.<p>That&#x27;s not to say that security researchers couldn&#x27;t find DTrace vulnerabilities if they, for instance, built DIF&#x2F;DOF fuzzers of 2023 levels of sophistication for them. I don&#x27;t know that anyone&#x27;s doing that, because DTrace is more or less a dead letter.</div><br/></div></div></div></div></div></div><div id="41194521" class="c"><input type="checkbox" id="c-41194521" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#41191167">root</a><span>|</span><a href="#41194409">parent</a><span>|</span><a href="#41194592">prev</a><span>|</span><a href="#41191363">next</a><span>|</span><label class="collapse" for="c-41194521">[-]</label><label class="expand" for="c-41194521">[12 more]</label></div><br/><div class="children"><div class="content">The DTrace bytecode VM is simply more limited:<p><pre><code>  - it cannot branch backwards (this is also true of eBPF)
  - it can only do ternary operator branches
  - it cannot define functions
  - functions it can call are limited to some builtin ones
  - it can only scribble on the one pre-allocated probe buffer
  - it can only access the probe&#x27;s defined parameters</code></pre></div><br/><div id="41196778" class="c"><input type="checkbox" id="c-41196778" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#41191167">root</a><span>|</span><a href="#41194521">parent</a><span>|</span><a href="#41194567">next</a><span>|</span><label class="collapse" for="c-41196778">[-]</label><label class="expand" for="c-41196778">[1 more]</label></div><br/><div class="children"><div class="content">And I should say that DTrace probe actions <i>can dereference pointers</i>, but NULL dereferences do not cause crashes, and rich type data is generally available.</div><br/></div></div><div id="41194567" class="c"><input type="checkbox" id="c-41194567" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41191167">root</a><span>|</span><a href="#41194521">parent</a><span>|</span><a href="#41196778">prev</a><span>|</span><a href="#41191363">next</a><span>|</span><label class="collapse" for="c-41194567">[-]</label><label class="expand" for="c-41194567">[10 more]</label></div><br/><div class="children"><div class="content">eBPF programs can absolutely branch backwards. You may be thinking of cBPF.</div><br/><div id="41195004" class="c"><input type="checkbox" id="c-41195004" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#41191167">root</a><span>|</span><a href="#41194567">parent</a><span>|</span><a href="#41191363">next</a><span>|</span><label class="collapse" for="c-41195004">[-]</label><label class="expand" for="c-41195004">[9 more]</label></div><br/><div class="children"><div class="content">I was thinking of the original BPF.  I didn&#x27;t realize that eBPF added back branching.</div><br/><div id="41195084" class="c"><input type="checkbox" id="c-41195084" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41191167">root</a><span>|</span><a href="#41195004">parent</a><span>|</span><a href="#41191363">next</a><span>|</span><label class="collapse" for="c-41195084">[-]</label><label class="expand" for="c-41195084">[8 more]</label></div><br/><div class="children"><div class="content">If the verifier can prove to itself that a loop is bounded, it&#x27;ll accept it. A good starting place for eBPF itself: if a normal ARM program could do it, eBPF can do it. It&#x27;s a fully functional ISA.</div><br/><div id="41195165" class="c"><input type="checkbox" id="c-41195165" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#41191167">root</a><span>|</span><a href="#41195084">parent</a><span>|</span><a href="#41191363">next</a><span>|</span><label class="collapse" for="c-41195165">[-]</label><label class="expand" for="c-41195165">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;m w&#x2F; the DTrace guys on this.  A turing complete VM is a bad idea for this purpose.</div><br/><div id="41200024" class="c"><input type="checkbox" id="c-41200024" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#41191167">root</a><span>|</span><a href="#41195165">parent</a><span>|</span><a href="#41195263">next</a><span>|</span><label class="collapse" for="c-41200024">[-]</label><label class="expand" for="c-41200024">[1 more]</label></div><br/><div class="children"><div class="content">eBPF isn’t Turing complete because it has to be able to prove that loops are bounded.</div><br/></div></div><div id="41195263" class="c"><input type="checkbox" id="c-41195263" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41191167">root</a><span>|</span><a href="#41195165">parent</a><span>|</span><a href="#41200024">prev</a><span>|</span><a href="#41191363">next</a><span>|</span><label class="collapse" for="c-41195263">[-]</label><label class="expand" for="c-41195263">[5 more]</label></div><br/><div class="children"><div class="content">It depends on what you&#x27;re using it for. If you want to expose this to untrusted code, yes, but I wouldn&#x27;t be comfortable doing that with DTrace either.</div><br/><div id="41196751" class="c"><input type="checkbox" id="c-41196751" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#41191167">root</a><span>|</span><a href="#41195263">parent</a><span>|</span><a href="#41191363">next</a><span>|</span><label class="collapse" for="c-41196751">[-]</label><label class="expand" for="c-41196751">[4 more]</label></div><br/><div class="children"><div class="content">There&#x27;s two untrusted code cases here: untrusted DTrace scripts &#x2F; users, and untrusted targets for inspection.  The latter has to be possible to examine, so the observability tools (like DTrace) have to be secure for that purpose.  This means you want to make it difficult to overflow buffers in the observability tools.<p>There&#x27;s also a need to make sure that even trusted users don&#x27;t accidentally cause too much observability load.  That&#x27;s why DTrace has a circular probe buffer pool, it&#x27;s why it drops probes under load, it&#x27;s why it pre-allocates each probe&#x27;s buffer by computing how much the probe&#x27;s actions will write to it, it&#x27;s why it doesn&#x27;t allow looping (since that would make the probe&#x27;s effect less predictable), etc.<p>Bryan, Adam, and Mike designed it this way two plus decades ago, and Linux still hasn&#x27;t caught up.</div><br/><div id="41196808" class="c"><input type="checkbox" id="c-41196808" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41191167">root</a><span>|</span><a href="#41196751">parent</a><span>|</span><a href="#41191363">next</a><span>|</span><label class="collapse" for="c-41196808">[-]</label><label class="expand" for="c-41196808">[3 more]</label></div><br/><div class="children"><div class="content">Linux has a different design than DTrace; eBPF is more capable as a trusted tool, and less capable for untrusted tools. It doesn&#x27;t make sense to say one approach has &quot;caught up&quot; to the other, unless you really believe the verifier will reach a state where nobody&#x27;s going find verifier bugs --- at which point eBPF will be strictly superior. Beyond that, it&#x27;s a matter of taste. What seems clearly to be true is that eBPF is wildly more popular.</div><br/><div id="41198681" class="c"><input type="checkbox" id="c-41198681" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#41191167">root</a><span>|</span><a href="#41196808">parent</a><span>|</span><a href="#41191363">next</a><span>|</span><label class="collapse" for="c-41198681">[-]</label><label class="expand" for="c-41198681">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s really hard to bring a host to its knees using DTrace, yet it&#x27;s quite powerful for observability.  In my opinion it is better to start with that then add extra power where it&#x27;s needed.</div><br/><div id="41198693" class="c"><input type="checkbox" id="c-41198693" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41191167">root</a><span>|</span><a href="#41198681">parent</a><span>|</span><a href="#41191363">next</a><span>|</span><label class="collapse" for="c-41198693">[-]</label><label class="expand" for="c-41198693">[1 more]</label></div><br/><div class="children"><div class="content">I understand the argument, but it&#x27;s clear which one succeeded in the market. Meanwhile: we take pretty good advantage of the extra power eBPF gives us over what DTrace would, so I&#x27;m happy to be on the golden path for the platform here. Like I said, though: this is a matter of taste.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41191363" class="c"><input type="checkbox" id="c-41191363" checked=""/><div class="controls bullet"><span class="by">lynxmachine</span><span>|</span><a href="#41191167">root</a><span>|</span><a href="#41191228">parent</a><span>|</span><a href="#41192543">prev</a><span>|</span><a href="#41191325">next</a><span>|</span><label class="collapse" for="c-41191363">[-]</label><label class="expand" for="c-41191363">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve solved problems by using eBPF. Problems that are basically unsolvable by non-kernel-gurus without eBPF. I rarely need it.<p>Would you mind giving some examples? I recently started learning about ebpf&#x27;s from Liz Rice&#x27;s book and is curious about what makes ebpf the correct choice in a particular scenario.</div><br/></div></div><div id="41191325" class="c"><input type="checkbox" id="c-41191325" checked=""/><div class="controls bullet"><span class="by">katzinsky</span><span>|</span><a href="#41191167">root</a><span>|</span><a href="#41191228">parent</a><span>|</span><a href="#41191363">prev</a><span>|</span><a href="#41191640">next</a><span>|</span><label class="collapse" for="c-41191325">[-]</label><label class="expand" for="c-41191325">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure &quot;Google engineers use it&quot; is a very good counter argument. They have a very high tolerance for complexity and like most large corporations what actually gets built and used tends to be driven more by internal politics than technical merit.</div><br/><div id="41191387" class="c"><input type="checkbox" id="c-41191387" checked=""/><div class="controls bullet"><span class="by">eggnet</span><span>|</span><a href="#41191167">root</a><span>|</span><a href="#41191325">parent</a><span>|</span><a href="#41192003">next</a><span>|</span><label class="collapse" for="c-41191387">[-]</label><label class="expand" for="c-41191387">[3 more]</label></div><br/><div class="children"><div class="content">Google would maintain a kernel patch or upstream a patch if that was the right choice for a given problem.</div><br/><div id="41191698" class="c"><input type="checkbox" id="c-41191698" checked=""/><div class="controls bullet"><span class="by">katzinsky</span><span>|</span><a href="#41191167">root</a><span>|</span><a href="#41191387">parent</a><span>|</span><a href="#41197458">next</a><span>|</span><label class="collapse" for="c-41191698">[-]</label><label class="expand" for="c-41191698">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s really begging the question. I don&#x27;t believe they would as they have consistently over engineered solutions in the past.</div><br/></div></div><div id="41197458" class="c"><input type="checkbox" id="c-41197458" checked=""/><div class="controls bullet"><span class="by">DaiPlusPlus</span><span>|</span><a href="#41191167">root</a><span>|</span><a href="#41191387">parent</a><span>|</span><a href="#41191698">prev</a><span>|</span><a href="#41192003">next</a><span>|</span><label class="collapse" for="c-41197458">[-]</label><label class="expand" for="c-41197458">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Google would maintain a kernel patch<p>I look forward to seeing that patch on Google Graveyard in a couple years&#x27; time.</div><br/></div></div></div></div><div id="41192003" class="c"><input type="checkbox" id="c-41192003" checked=""/><div class="controls bullet"><span class="by">knorker</span><span>|</span><a href="#41191167">root</a><span>|</span><a href="#41191325">parent</a><span>|</span><a href="#41191387">prev</a><span>|</span><a href="#41191640">next</a><span>|</span><label class="collapse" for="c-41192003">[-]</label><label class="expand" for="c-41192003">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t mean it as a counter argument, or I don&#x27;t think the way you mean it, at least.<p>You may not use it at your smaller scale. But there are millions of machines out there that do use it, and the alternative for the same functionality is much worse.<p>I bet you never use SCTP sockets either. eBPF is used much more than SCTP.<p>And its users &quot;fund&quot; its development, so it&#x27;s not a burden to those who don&#x27;t use it.<p>But are you sure your systems don&#x27;t use it? Run &quot;bpftool prog&quot; to see. Whatever you see there someone thought was better than the alternative.</div><br/></div></div></div></div><div id="41191640" class="c"><input type="checkbox" id="c-41191640" checked=""/><div class="controls bullet"><span class="by">znpy</span><span>|</span><a href="#41191167">root</a><span>|</span><a href="#41191228">parent</a><span>|</span><a href="#41191325">prev</a><span>|</span><a href="#41191959">next</a><span>|</span><label class="collapse" for="c-41191640">[-]</label><label class="expand" for="c-41191640">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There are other technologies for this, such as DTrace. The kernel&#x27;s choice isn&#x27;t eBPF or nothing, it&#x27;s eBPF or something else like it.<p>To add on this point: I successfully used SystemTap a few years ago to debug an issue i was having.<p>Before going further: keep in mind that my point of view (at the time) was the one of somebody working as a devops engineer, debugging some annoyances with containers (managed by Kubernetes) going OOM. I&#x27;m no kernel developer and I have a basic-good understanding of the C language based on first-years university course and geekyness&#x2F;nerdyness. So in this context I&#x27;m a glorified hobbyist.<p>Learning SystemTap is easier in my opinion. I followed a tutorial by RedHat to get the hang of the manual parts but after that I remember being fairly easy:<p>1. Try to reproduce the issue you&#x27;re having (fairly easy for me)<p>2. Skim the source code of the linux about the part that you think might be relevant (for me it was the oom killer)<p>3. Add probes in there, see if they fire when you reproduce the issue<p>4. Look back at the source code of the kernel and see what chain of data structures and fields you can follow to reach the piece of information you need<p>5. Improve your probes<p>6. If successful, you&#x27;re done<p>7. Goto 4<p>I think it took like one or two days between following the tutorial and getting a working probe.<p>It was a pleasant couple of days.</div><br/></div></div></div></div><div id="41191959" class="c"><input type="checkbox" id="c-41191959" checked=""/><div class="controls bullet"><span class="by">ssahoo</span><span>|</span><a href="#41191167">parent</a><span>|</span><a href="#41191228">prev</a><span>|</span><a href="#41191247">next</a><span>|</span><label class="collapse" for="c-41191959">[-]</label><label class="expand" for="c-41191959">[2 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t even the classic loadable kernel mode driver be a better choice than a patch and eBpf? I know they are unsafe but people who deal with it, know the power comes with responsibility.</div><br/><div id="41192023" class="c"><input type="checkbox" id="c-41192023" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41191167">root</a><span>|</span><a href="#41191959">parent</a><span>|</span><a href="#41191247">next</a><span>|</span><label class="collapse" for="c-41192023">[-]</label><label class="expand" for="c-41192023">[1 more]</label></div><br/><div class="children"><div class="content">No? SREs roll eBPF programs on the fly just in the process of debugging problems; if you tried to do that with an LKM, you&#x27;d almost certainly blow up your system. People who write Linux kernel code routinely crash their systems in the process of development.</div><br/></div></div></div></div></div></div><div id="41192062" class="c"><input type="checkbox" id="c-41192062" checked=""/><div class="controls bullet"><span class="by">mrbluecoat</span><span>|</span><a href="#41191167">prev</a><span>|</span><a href="#41190756">next</a><span>|</span><label class="collapse" for="c-41192062">[-]</label><label class="expand" for="c-41192062">[4 more]</label></div><br/><div class="children"><div class="content">&gt; “Uno no es ninguno” (One is none)<p>I believe that translates to &quot;One is not none&quot;<p><a href="https:&#x2F;&#x2F;bughunters.google.com&#x2F;blog&#x2F;6303226026131456&#x2F;a-deep-dive-into-cve-2023-2163-how-we-found-and-fixed-an-ebpf-linux-kernel-vulnerability#-uno-no-es-ninguno-one-is-none-" rel="nofollow">https:&#x2F;&#x2F;bughunters.google.com&#x2F;blog&#x2F;6303226026131456&#x2F;a-deep-d...</a></div><br/><div id="41192298" class="c"><input type="checkbox" id="c-41192298" checked=""/><div class="controls bullet"><span class="by">kmarc</span><span>|</span><a href="#41192062">parent</a><span>|</span><a href="#41192293">next</a><span>|</span><label class="collapse" for="c-41192298">[-]</label><label class="expand" for="c-41192298">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t; It translates to &quot;One is none&quot;
This is the infamous double negation many foreign speakers (including me) struggles with.<p><a href="https:&#x2F;&#x2F;spanish.stackexchange.com&#x2F;questions&#x2F;26777&#x2F;how-does-double-negation-using-no-hay-and-ning%C3%BAn-ninguna-work" rel="nofollow">https:&#x2F;&#x2F;spanish.stackexchange.com&#x2F;questions&#x2F;26777&#x2F;how-does-d...</a></div><br/></div></div><div id="41192293" class="c"><input type="checkbox" id="c-41192293" checked=""/><div class="controls bullet"><span class="by">DanielVZ</span><span>|</span><a href="#41192062">parent</a><span>|</span><a href="#41192298">prev</a><span>|</span><a href="#41195676">next</a><span>|</span><label class="collapse" for="c-41192293">[-]</label><label class="expand" for="c-41192293">[1 more]</label></div><br/><div class="children"><div class="content">Thats the direct translation but for some reason in spanish our double negations are usually just negations.</div><br/></div></div><div id="41195676" class="c"><input type="checkbox" id="c-41195676" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#41192062">parent</a><span>|</span><a href="#41192293">prev</a><span>|</span><a href="#41190756">next</a><span>|</span><label class="collapse" for="c-41195676">[-]</label><label class="expand" for="c-41195676">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps we should translate this as &quot;one ain&#x27;t nothin&#x27;&quot;.</div><br/></div></div></div></div><div id="41191767" class="c"><input type="checkbox" id="c-41191767" checked=""/><div class="controls bullet"><span class="by">techwiz137</span><span>|</span><a href="#41190756">prev</a><span>|</span><label class="collapse" for="c-41191767">[-]</label><label class="expand" for="c-41191767">[3 more]</label></div><br/><div class="children"><div class="content">In my country we have a saying. &quot;Porcupine in the pants&quot;. Sounds like for all the good it can do, it isn&#x27;t written safely and carefully.</div><br/><div id="41193170" class="c"><input type="checkbox" id="c-41193170" checked=""/><div class="controls bullet"><span class="by">deskr</span><span>|</span><a href="#41191767">parent</a><span>|</span><label class="collapse" for="c-41193170">[-]</label><label class="expand" for="c-41193170">[2 more]</label></div><br/><div class="children"><div class="content">With experience you&#x27;ll realise that despite things being done safely and carefully, mistakes can and do pop up.</div><br/><div id="41199262" class="c"><input type="checkbox" id="c-41199262" checked=""/><div class="controls bullet"><span class="by">bugtodiffer</span><span>|</span><a href="#41191767">root</a><span>|</span><a href="#41193170">parent</a><span>|</span><label class="collapse" for="c-41199262">[-]</label><label class="expand" for="c-41199262">[1 more]</label></div><br/><div class="children"><div class="content">True. There are some nasty bugs in some very well written code.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>