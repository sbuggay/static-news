<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1733130057877" as="style"/><link rel="stylesheet" href="styles.css?v=1733130057877"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://parentheticallyspeaking.org/articles/bicameral-not-homoiconic/">Bicameral, Not Homoiconic</a> <span class="domain">(<a href="https://parentheticallyspeaking.org">parentheticallyspeaking.org</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>17 comments</span></div><br/><div><div id="42294318" class="c"><input type="checkbox" id="c-42294318" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#42292885">next</a><span>|</span><label class="collapse" for="c-42294318">[-]</label><label class="expand" for="c-42294318">[1 more]</label></div><br/><div class="children"><div class="content">It seems that the Rust macro system is inspired by a similar idea: In the first step (the &quot;reader&quot; in this article&#x27;s terminology), the source is converted into something called a <i>token tree</i>.<p>A token tree is not a full parse tree with resolved operator precedence and whatnot. It only has child nodes for brackets ((), [] and {}) to determine where the macro call ends. Otherwise, it&#x27;s a flat list of tokens that the macro (what this article would call the &quot;parser&quot;) can interpret in any way it wants.</div><br/></div></div><div id="42292885" class="c"><input type="checkbox" id="c-42292885" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#42294318">prev</a><span>|</span><a href="#42293564">next</a><span>|</span><label class="collapse" for="c-42292885">[-]</label><label class="expand" for="c-42292885">[4 more]</label></div><br/><div class="children"><div class="content"><i>Homoiconic</i> has a pretty clear definition. It was coined by someone in reference the property of a specific system, many decades ago. That system stored program definitions in the same form that the programmer entered them in (either just the original character-level text, or some tokenized version of it), allowing the definitions to be recalled at runtime and redefined. He turned &quot;same form&quot; into &quot;homoiconic&quot; with the help of Greek&#x2F;Latin. It&#x27;s all in the Wikipedia.<p>Line numbered BASIC is homoiconic: you can edit any line of code and continue the program.<p>POSIX shell lets functions be redefined. They can be listed with the <i>set</i> command executed without arguments, and copy-pasted.<p>In Common Lisp, there is a function called <i>ed</i>, support for which is implementation-defined. If support is available, it is supposed to bring up an editor of some kind to allow a function definition to be edited. That is squarely a homoiconic feature.<p>Without <i>ed</i> support or anything like it, the implementation does not retain definitions in a way that can be edited; i.e. is not homoiconic. Some Lisps compile everything entered into them; you cannot edit a <i>defun</i> because it has been turned into machine language.</div><br/><div id="42294179" class="c"><input type="checkbox" id="c-42294179" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#42292885">parent</a><span>|</span><a href="#42292971">next</a><span>|</span><label class="collapse" for="c-42294179">[-]</label><label class="expand" for="c-42294179">[1 more]</label></div><br/><div class="children"><div class="content">&gt;<i>In Common Lisp, there is a function called ed, support for which is implementation-defined. If support is available, it is supposed to bring up an editor of some kind to allow a function definition to be edited. That is squarely a homoiconic feature.</i><p>It&#x27;s enough that the language stores the current source code and can reload it for that. So hot-code-swapping&#x2F;reload is enough, not homoiconicity needed - which makes it not so squarely a homoiconic feature.</div><br/></div></div><div id="42292971" class="c"><input type="checkbox" id="c-42292971" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#42292885">parent</a><span>|</span><a href="#42294179">prev</a><span>|</span><a href="#42293882">next</a><span>|</span><label class="collapse" for="c-42292971">[-]</label><label class="expand" for="c-42292971">[1 more]</label></div><br/><div class="children"><div class="content">I think this comment re-enforced my sense the author wanted to drive to a destination and didn&#x27;t want to divert down a road of &quot;why LISP homoiconic is different to eval()&quot; which I think was .. lazy.<p>The idea has merit. Having the REPL deal with the parse structure of data in such a way that taking parsed data and presenting it as code has a lower barrier to effective outcome on the current run state than eval() is pretty big.<p>I&#x27;d say eval() isn&#x27;t self-modifying. You can&#x27;t come out the other side of eval() with future execution state of yourself different. As I understand it, the homoiconic features of LISP means you can.</div><br/></div></div><div id="42293882" class="c"><input type="checkbox" id="c-42293882" checked=""/><div class="controls bullet"><span class="by">thaumasiotes</span><span>|</span><a href="#42292885">parent</a><span>|</span><a href="#42292971">prev</a><span>|</span><a href="#42293564">next</a><span>|</span><label class="collapse" for="c-42293882">[-]</label><label class="expand" for="c-42293882">[1 more]</label></div><br/><div class="children"><div class="content">&gt; He turned &quot;same form&quot; into &quot;homoiconic&quot; with the help of Greek&#x2F;Latin.<p>Well, sort of. Mostly that&#x27;s just English.<p>There&#x27;s no Latin at all, but <i>hom-</i> [same] and <i>icon</i> [image] are arguably Greek roots. The Latin equivalents would be <i>eadem</i> [same, as in &quot;idempotent&quot;] and <i>imago</i> [image, and the feminine gender of this word explains why we need &quot;eadem&quot; and not &quot;idem&quot;]. I&#x27;m not sure how you&#x27;d connect those.<p>However, since <i>icon</i> begins with a vowel, I don&#x27;t think it&#x27;s possible for <i>hom-</i> to take the epenthetic <i>-o-</i> that appears when you&#x27;re connecting two Greek roots that don&#x27;t have an obvious way to connect. If the word was constructed based on Greek principles, it would be <i>hom(e)iconic</i>. Treating <i>homo-</i> as a prefix that automatically includes a final O is a sign of English; in Greek they&#x27;re separate things.<p>I remember that when there was a scandal around cum-ex financial instruments, a lot of people wanted to say that cum-ex was Latin for &quot;with-without&quot;, which it isn&#x27;t; it&#x27;s Latin for &quot;with-from&quot;. (&quot;Without&quot; in Latin is <i>sine</i>, as compare French <i>sans</i> or Spanish <i>sin</i>.) Cum-ex is <i>English</i> for &quot;with-without&quot;, and the same kind of thing is going on with <i>homoiconic</i>.</div><br/></div></div></div></div><div id="42293564" class="c"><input type="checkbox" id="c-42293564" checked=""/><div class="controls bullet"><span class="by">galaxyLogic</span><span>|</span><a href="#42292885">prev</a><span>|</span><a href="#42293911">next</a><span>|</span><label class="collapse" for="c-42293564">[-]</label><label class="expand" for="c-42293564">[2 more]</label></div><br/><div class="children"><div class="content">If I understand the gist of this article it goes like ...<p>1. Scanner divides source-code-string into ordered chunks each with some identifying information, what is the type and content of each chunk.<p>2. The next stage better NOT be a &quot;Parser&quot; but a &quot;Reader&quot; which assembles the chunks into a well-formed tree-structure thus recognizing which chunks belong togeether in the branches of such trees.<p>3. Parser then assigns &quot;meaning&quot; to the nodes and branches of the tree produced by Reader, by visiting them. &quot;Meaning&quot; basically means (!) what kind of calculation will be performed on some nodes of the tree.<p>4. It is beneficial if the programming language has primitives for accessing the output of the reader, so it can  have macros that morph the reader-produced tree so it can ask the parser to do its job on such a re-morphed tree.<p>Did I get it close?</div><br/><div id="42294323" class="c"><input type="checkbox" id="c-42294323" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#42293564">parent</a><span>|</span><a href="#42293911">next</a><span>|</span><label class="collapse" for="c-42294323">[-]</label><label class="expand" for="c-42294323">[1 more]</label></div><br/><div class="children"><div class="content">&gt; 2. The next stage better NOT be a &quot;Parser&quot; but a &quot;Reader&quot; which assembles the chunks into a well-formed tree-structure thus recognizing which chunks belong togeether in the branches of such trees.<p>&gt; 3. Parser then assigns &quot;meaning&quot; to the nodes and branches of the tree produced by Reader, by visiting them. &quot;Meaning&quot; basically means (!) what kind of calculation will be performed on some nodes of the tree.<p>So, an &quot;AST builder&quot; that is followed by a &quot;semantic pass&quot;. That&#x27;s... how most of the compilers have been structured, at least conceptually, since their invention. In particularly memory-starved environments those passes were actually separate programs, launched sequentially; most famously the ancient IBM FORTRAN compilers were structured like this (they couldn&#x27;t manage fit both the program being compiled <i>and</i> the whole compiler into the core; so they&#x27;ve split the compiler into 60-something pieces).</div><br/></div></div></div></div><div id="42293911" class="c"><input type="checkbox" id="c-42293911" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#42293564">prev</a><span>|</span><a href="#42294249">next</a><span>|</span><label class="collapse" for="c-42293911">[-]</label><label class="expand" for="c-42293911">[1 more]</label></div><br/><div class="children"><div class="content">I liked the first half of the article, but I&#x27;m not sure I got anything from the second half. As the author notes, in order to be useful a definition must exclude something, and the &quot;bicameral&quot; distinction doesn&#x27;t seem to exclude anything; even Python eventually gets parsed into a tree. Conceptually splitting out &quot;parsing&quot; into &quot;tree validation&quot; and &quot;syntax validation&quot; is slightly interesting (although isn&#x27;t this now a <i>tricameral</i> system?), but in practice it just seems like a simple aid to constructing DSLs.<p><i>&gt; These advantages are offset by one drawback: some people just don’t like them. It feels constraining to some to always write programs in terms of trees, rather than more free-form syntax.</i><p>I think this is misdiagnosing why many people are averse to Lisp. It&#x27;s not that I don&#x27;t like writing trees; I love trees for representing data. But I don&#x27;t think that thinking of code as data is as intuitive or useful as Lisp users want me to think it is, despite how obviously powerful the notion is.</div><br/></div></div><div id="42294249" class="c"><input type="checkbox" id="c-42294249" checked=""/><div class="controls bullet"><span class="by">peanut-walrus</span><span>|</span><a href="#42293911">prev</a><span>|</span><a href="#42293448">next</a><span>|</span><label class="collapse" for="c-42294249">[-]</label><label class="expand" for="c-42294249">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Data are data, but programs—entities that we can run—seem to be a separate thing.</i><p>Is this a view some people actually hold? Would be interesting to see some argumentation why someone would think this is the case.</div><br/></div></div><div id="42293448" class="c"><input type="checkbox" id="c-42293448" checked=""/><div class="controls bullet"><span class="by">zzo38computer</span><span>|</span><a href="#42294249">prev</a><span>|</span><a href="#42294070">next</a><span>|</span><label class="collapse" for="c-42293448">[-]</label><label class="expand" for="c-42293448">[3 more]</label></div><br/><div class="children"><div class="content">It is not only Lisp. PostScript is also homoiconic; tokens have values like any other values (and procedures are just executable arrays (executing an array involves executing each element of that array in sequence), which can be manipulated like any other arrays). The {} block in PostScript is a single token that contains other tokens; the value of the token is an executable array whose elements are the values of the tokens that it contains.<p>Strings don&#x27;t make it &quot;homoiconic&quot; in the usual way, I think; so, JavaScript does not count.</div><br/><div id="42293684" class="c"><input type="checkbox" id="c-42293684" checked=""/><div class="controls bullet"><span class="by">ashton314</span><span>|</span><a href="#42293448">parent</a><span>|</span><a href="#42294070">next</a><span>|</span><label class="collapse" for="c-42293684">[-]</label><label class="expand" for="c-42293684">[2 more]</label></div><br/><div class="children"><div class="content">You might be interested in what the author has to say about weak vs strong homoiconicity then…</div><br/><div id="42294148" class="c"><input type="checkbox" id="c-42294148" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42293448">root</a><span>|</span><a href="#42293684">parent</a><span>|</span><a href="#42294070">next</a><span>|</span><label class="collapse" for="c-42294148">[-]</label><label class="expand" for="c-42294148">[1 more]</label></div><br/><div class="children"><div class="content">The author doesn&#x27;t go far enough; eval operating on strings is still very weak (unless your language is something like BrainFuck that really doesn&#x27;t have a more structured representation available). The point is exposing the structured form that the language implementation runs as datastructures within the language - and not as some second-class reflection API, but directly as they are. You want to be able to capture something like an AST representation (not necessarily literally an AST), manipulate it, and then run it.<p>I think &quot;Bicameral&quot; isn&#x27;t really a great way to capture this, because there are often multiple layers of parsing&#x2F;lexing&#x2F;compilation&#x2F;interpretation and you might want to hook in at multiple of them (e.g. in lisps you may have both reader macros that operate at a low-level stage and higher-level macros that operate after parsing). And of course it&#x27;s a spectrum, but essentially the more the language exposes itself as a set of compositional libraries rather than just being a monolithic service.</div><br/></div></div></div></div></div></div><div id="42294070" class="c"><input type="checkbox" id="c-42294070" checked=""/><div class="controls bullet"><span class="by">clausecker</span><span>|</span><a href="#42293448">prev</a><span>|</span><a href="#42294105">next</a><span>|</span><label class="collapse" for="c-42294070">[-]</label><label class="expand" for="c-42294070">[1 more]</label></div><br/><div class="children"><div class="content">Another language with this property is FORTH, which has many surprising similarities with LISP.  I like to call it “LISP, but the other way round.”  It usues RPN instead of PN, stacks&#x2F;arrays instead of lists, and is procedural instead of functional.</div><br/></div></div><div id="42294105" class="c"><input type="checkbox" id="c-42294105" checked=""/><div class="controls bullet"><span class="by">acka</span><span>|</span><a href="#42294070">prev</a><span>|</span><a href="#42293384">next</a><span>|</span><label class="collapse" for="c-42294105">[-]</label><label class="expand" for="c-42294105">[1 more]</label></div><br/><div class="children"><div class="content">&quot;We started with Lisp, so let’s go back there. What is Lisp? Lisp is a feeling, an emotion, a sentiment; Lisp is a vibe; Lisp is the dew on morning grass, it’s the scent of pine wafting on a breeze, it’s the sound of a cricket ball on a bat, it’s the…oh, wait, where was I. Sorry.&quot;<p>Leaving this here, with the deepest respect.<p>Eternal Flame - Julia Ecklar
<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=u-7qFAuFGao" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=u-7qFAuFGao</a></div><br/></div></div><div id="42293384" class="c"><input type="checkbox" id="c-42293384" checked=""/><div class="controls bullet"><span class="by">djaouen</span><span>|</span><a href="#42294105">prev</a><span>|</span><label class="collapse" for="c-42293384">[-]</label><label class="expand" for="c-42293384">[2 more]</label></div><br/><div class="children"><div class="content">How one could have spent any time at all studying Lisp starting in the 80s (!) and not understand what the word &quot;homoiconic&quot; means is <i>baffling</i> to me!</div><br/><div id="42293465" class="c"><input type="checkbox" id="c-42293465" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#42293384">parent</a><span>|</span><label class="collapse" for="c-42293465">[-]</label><label class="expand" for="c-42293465">[1 more]</label></div><br/><div class="children"><div class="content">The term homoiconic does not come from the Lisp culture. I think it might have been in the 1990s that it came into use as a way of describing a property of languages in the Lisp family, using a different definition from the original homoiconic, and it might have been introduced by outsiders.<p>Using Google Books search, we can identify that a 1996 book called <i>Advanced Programming Language Design</i> by Raphael A. Finkel uses the word in this new way, claiming that TCL and Lisp are homoiconic.<p>The word returns to flatlining towards the end of the 1990s, and then surges after 2000.</div><br/></div></div></div></div></div></div></div></div></div></body></html>