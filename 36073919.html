<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1685091693682" as="style"/><link rel="stylesheet" href="styles.css?v=1685091693682"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.replit.com/super-colliding-nix-stores">Super Colliding Nix Stores: Nix Flakes for Millions of Developers</a> <span class="domain">(<a href="https://blog.replit.com">blog.replit.com</a>)</span></div><div class="subtext"><span>osener</span> | <span>62 comments</span></div><br/><div><div id="36075326" class="c"><input type="checkbox" id="c-36075326" checked=""/><div class="controls bullet"><span class="by">peter_l_downs</span><span>|</span><a href="#36078609">next</a><span>|</span><label class="collapse" for="c-36075326">[-]</label><label class="expand" for="c-36075326">[32 more]</label></div><br/><div class="children"><div class="content">I think the best part about Nix is that it makes it super easy to get software into your development environment. This layered store is a pretty cool setup to make that efficient for Replit.<p>Not sure how if Nix&#x2F;Replit has the program you’re looking for? Or what package name to use to actually get the program you want? Check out my cli search tool:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;peterldowns&#x2F;nix-search-cli">https:&#x2F;&#x2F;github.com&#x2F;peterldowns&#x2F;nix-search-cli</a><p>Edit: I can’t help myself from ranting, it’s insane that I had to write this tool. Speaks to the lack of user focus in the Nix community. Even the blog post here doesn’t mention how to actually find packages to install!<p>What good is a package manager that makes finding packages difficult? Who should be expected to tolerate such a thing?</div><br/><div id="36075766" class="c"><input type="checkbox" id="c-36075766" checked=""/><div class="controls bullet"><span class="by">jljljl</span><span>|</span><a href="#36075326">parent</a><span>|</span><a href="#36080609">next</a><span>|</span><label class="collapse" for="c-36075766">[-]</label><label class="expand" for="c-36075766">[11 more]</label></div><br/><div class="children"><div class="content">Finding a specific version of a package is also really difficult. It requires you to find the commit hash in the Nixpkgs repo that last contained it, and there isn&#x27;t a central search engine that lets you map version to commit.<p>We ended up building package version search into the Devbox CLI for this reason (<a href="https:&#x2F;&#x2F;www.jetpack.io&#x2F;devbox&#x2F;docs&#x2F;guides&#x2F;pinning_packages&#x2F;#searching-for-available-packages" rel="nofollow">https:&#x2F;&#x2F;www.jetpack.io&#x2F;devbox&#x2F;docs&#x2F;guides&#x2F;pinning_packages&#x2F;#...</a>). There&#x27;s also a 3rd party site that lets you search for Nix package versions (<a href="https:&#x2F;&#x2F;lazamar.co.uk&#x2F;nix-versions&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lazamar.co.uk&#x2F;nix-versions&#x2F;</a>)</div><br/><div id="36081416" class="c"><input type="checkbox" id="c-36081416" checked=""/><div class="controls bullet"><span class="by">chriswarbo</span><span>|</span><a href="#36075326">root</a><span>|</span><a href="#36075766">parent</a><span>|</span><a href="#36076431">next</a><span>|</span><label class="collapse" for="c-36081416">[-]</label><label class="expand" for="c-36081416">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Finding a specific version of a package is also really difficult. It requires you to find the commit hash in the Nixpkgs repo that last contained it, and there isn&#x27;t a central search engine that lets you map version to commit.<p>I don&#x27;t understand this: Nixpkgs can only ever contain a <i>tiny</i> proportion of package <i>versions</i>. It&#x27;s meant as a mostly-consistent set: e.g. if you want packages &quot;foo&quot;, &quot;bar&quot; and &quot;baz&quot;, that should work.<p>It&#x27;s not intended for &quot;foo-1.2&quot;, &quot;bar-0.2&quot; and &quot;baz-99&quot;; let alone toggling the super-duper compiler flag and applying Alice&#x27;s stability patches. However, the latter <i>are</i> intended by the <i>functions</i> which define those packages; and it&#x27;s exactly why so many &quot;override&quot; functions are provided (to do all of the above, we usually just need &#x27;.overrideAttrs&#x27;).<p>If you want a consistent <i>set</i> of packages, the usual approach is to run some sort of dependency solver (e.g. many of the &#x27;foo2nix&#x27; tools), and map over its result. For example, at work our Scala projects run &#x27;mvn2nix&#x27; during their build; use import-from-derivation to turn the results into a local Maven repository; and use that to build the project in Maven&#x27;s &quot;offline mode&quot;.</div><br/></div></div><div id="36076431" class="c"><input type="checkbox" id="c-36076431" checked=""/><div class="controls bullet"><span class="by">NathanOsullivan</span><span>|</span><a href="#36075326">root</a><span>|</span><a href="#36075766">parent</a><span>|</span><a href="#36081416">prev</a><span>|</span><a href="#36076334">next</a><span>|</span><label class="collapse" for="c-36076431">[-]</label><label class="expand" for="c-36076431">[5 more]</label></div><br/><div class="children"><div class="content">Normally I would eye-roll at these kind of self promotions but it looks like you are trying to help with a real pain point of Nix.<p>I put a good amount of time getting to grips with &quot;raw&quot; nix with the I imagine common yo-yo-ing between &quot;I don&#x27;t get it&quot; and &quot;oh I see, this is great&quot; but when I realised how the intersection of nixpkgs and package versioning actually worked.. I was done.<p>For a tool that from the outside seems is so heavily focused on immutability to just continually throw away old versions in nixpkgs head is a head scratcher, and as a monorepo isn&#x27;t a great fit for utilising different revisions for different packages either.<p>I can only guess that due to single repo containing every package it wasn&#x27;t seen as practical to just continually append versions to, but when the diff log is just full of &#x27;delete version X URL and it&#x27;s hash, add X+1 and new hash&#x27; from the outside at least, it felt like a real missed opportunity.</div><br/><div id="36080593" class="c"><input type="checkbox" id="c-36080593" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#36075326">root</a><span>|</span><a href="#36076431">parent</a><span>|</span><a href="#36076614">next</a><span>|</span><label class="collapse" for="c-36080593">[-]</label><label class="expand" for="c-36080593">[1 more]</label></div><br/><div class="children"><div class="content">&gt; just continually throw away old versions in nixpkgs head<p>It is simply completely infeasible to store <i>and build</i> every version of every package.<p>While it is not user friendly to find a package’s version X, it is either just overriding the version field and the hash, or referencing another version of the nixpkgs tree and building the same package from there.<p>It’s not trivial with other package managers either, and on top you can easily get into inconsistent states with those — nix can handle any version of any software correctly.</div><br/></div></div><div id="36076614" class="c"><input type="checkbox" id="c-36076614" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#36075326">root</a><span>|</span><a href="#36076431">parent</a><span>|</span><a href="#36080593">prev</a><span>|</span><a href="#36076703">next</a><span>|</span><label class="collapse" for="c-36076614">[-]</label><label class="expand" for="c-36076614">[2 more]</label></div><br/><div class="children"><div class="content">I would suggest one more step of &quot;oh, this is great&quot;: I don&#x27;t think people need to care as much about finding the right version in the repo as they do. (Unless we&#x27;re talking about something really significant like finding old MySQL 5.6) For smaller apps you can either override or copy the current nix file and update the version and hash - you get the version you want. It will use new version of the dependencies, but normally that&#x27;s just fine.<p>I&#x27;ve got 3 packages which are pinned to a specific version that way in home-manager and I&#x27;m happy. It&#x27;s not an approach for the first time user of course.</div><br/><div id="36076659" class="c"><input type="checkbox" id="c-36076659" checked=""/><div class="controls bullet"><span class="by">jljljl</span><span>|</span><a href="#36075326">root</a><span>|</span><a href="#36076614">parent</a><span>|</span><a href="#36076703">next</a><span>|</span><label class="collapse" for="c-36076659">[-]</label><label class="expand" for="c-36076659">[1 more]</label></div><br/><div class="children"><div class="content">I thought this too, but we got a lot of requests for better version search + pinning. Adding overrides and looking up the right commit hash is a pretty cumbersome for a first time user.<p>For new projects though, I agree that using `latest` is generally the way to go.</div><br/></div></div></div></div><div id="36076703" class="c"><input type="checkbox" id="c-36076703" checked=""/><div class="controls bullet"><span class="by">jljljl</span><span>|</span><a href="#36075326">root</a><span>|</span><a href="#36076431">parent</a><span>|</span><a href="#36076614">prev</a><span>|</span><a href="#36076334">next</a><span>|</span><label class="collapse" for="c-36076703">[-]</label><label class="expand" for="c-36076703">[1 more]</label></div><br/><div class="children"><div class="content">I do think Flakes help with the &quot;throwing away old versions&quot; issue. They also help with the monorepo issue by encouraging developers publish the Nix derivation in their own repo.<p>But they currently have a bit of a discoverability issue, and they need adoption by legacy packages to completely fix the problem.</div><br/></div></div></div></div><div id="36076334" class="c"><input type="checkbox" id="c-36076334" checked=""/><div class="controls bullet"><span class="by">peter_l_downs</span><span>|</span><a href="#36075326">root</a><span>|</span><a href="#36075766">parent</a><span>|</span><a href="#36076431">prev</a><span>|</span><a href="#36079506">next</a><span>|</span><label class="collapse" for="c-36076334">[-]</label><label class="expand" for="c-36076334">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll have to check out devbox, thanks for the link. I don&#x27;t understand why Nix doesn&#x27;t have some way for derivations to claim that they install certain artifacts, which would make searching so much easier.<p>The version thing is also really annoying, thanks for the helpful link, I hadn&#x27;t seen that. Not sure how this will work in a Flakes world. Seems weird to me that sometimes packages are important enough to have multiple derivations each installing a different version (like the pythonFull packages) but there is no standard&#x2F;good&#x2F;default solution for it.</div><br/><div id="36076628" class="c"><input type="checkbox" id="c-36076628" checked=""/><div class="controls bullet"><span class="by">jljljl</span><span>|</span><a href="#36075326">root</a><span>|</span><a href="#36076334">parent</a><span>|</span><a href="#36079506">next</a><span>|</span><label class="collapse" for="c-36076628">[-]</label><label class="expand" for="c-36076628">[2 more]</label></div><br/><div class="children"><div class="content">Versioning is a bit easier with Flakes because they&#x27;re generally published in their own Git repository, meaning you can use tags or branch refs to publish&#x2F;install specific versions of a package. You can usually do something like `github:org&#x2F;repo&#x2F;ref#package` to get what you need.</div><br/><div id="36076729" class="c"><input type="checkbox" id="c-36076729" checked=""/><div class="controls bullet"><span class="by">peter_l_downs</span><span>|</span><a href="#36075326">root</a><span>|</span><a href="#36076628">parent</a><span>|</span><a href="#36079506">next</a><span>|</span><label class="collapse" for="c-36076729">[-]</label><label class="expand" for="c-36076729">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but how will this work for the `nixpkgs` repository? Still very unclear!<p>I&#x27;m 100% onboard with flakes in general, and use flakes to describe devshells + publish binaries when applicable -- like with the tool I linked in my earlier post.</div><br/></div></div></div></div></div></div><div id="36079506" class="c"><input type="checkbox" id="c-36079506" checked=""/><div class="controls bullet"><span class="by">whateveracct</span><span>|</span><a href="#36075326">root</a><span>|</span><a href="#36075766">parent</a><span>|</span><a href="#36076334">prev</a><span>|</span><a href="#36080609">next</a><span>|</span><label class="collapse" for="c-36079506">[-]</label><label class="expand" for="c-36079506">[1 more]</label></div><br/><div class="children"><div class="content">On the flipside, it&#x27;s easy to change the version of any package to any git rev and automatically rebuild any downstream dependency.</div><br/></div></div></div></div><div id="36080609" class="c"><input type="checkbox" id="c-36080609" checked=""/><div class="controls bullet"><span class="by">toastal</span><span>|</span><a href="#36075326">parent</a><span>|</span><a href="#36075766">prev</a><span>|</span><a href="#36075439">next</a><span>|</span><label class="collapse" for="c-36080609">[-]</label><label class="expand" for="c-36080609">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s <i>a</i> use case, but for from the best. Nix lets you create immutable, reproducible packages&#x2F;OSs&#x2F;deploys--and can be built on arbitrary fleets of machines with shared caches. Just bringing in tools to the developer environment means the distribution of its tools is immutable but everything you plan to do with it <i>inside</i> that environment is mututable. The forest is missed for the trees if folks think dev shells are the killer feature.</div><br/></div></div><div id="36075439" class="c"><input type="checkbox" id="c-36075439" checked=""/><div class="controls bullet"><span class="by">ghuntley</span><span>|</span><a href="#36075326">parent</a><span>|</span><a href="#36080609">prev</a><span>|</span><a href="#36076965">next</a><span>|</span><label class="collapse" for="c-36075439">[-]</label><label class="expand" for="c-36075439">[2 more]</label></div><br/><div class="children"><div class="content">or <a href="https:&#x2F;&#x2F;search.nixos.org" rel="nofollow">https:&#x2F;&#x2F;search.nixos.org</a><p>if folks want a easy (and good way) to get up and running in the nix ecosystem w&#x2F;services ala replace docker compose then <a href="https:&#x2F;&#x2F;devenv.sh" rel="nofollow">https:&#x2F;&#x2F;devenv.sh</a> is the shizz</div><br/><div id="36080474" class="c"><input type="checkbox" id="c-36080474" checked=""/><div class="controls bullet"><span class="by">soraminazuki</span><span>|</span><a href="#36075326">root</a><span>|</span><a href="#36075439">parent</a><span>|</span><a href="#36076965">next</a><span>|</span><label class="collapse" for="c-36080474">[-]</label><label class="expand" for="c-36080474">[1 more]</label></div><br/><div class="children"><div class="content">Also, package search is also prominently featured in the NixOS homepage for folks who don&#x27;t want to remember the URL.</div><br/></div></div></div></div><div id="36076965" class="c"><input type="checkbox" id="c-36076965" checked=""/><div class="controls bullet"><span class="by">adarsh-krishna</span><span>|</span><a href="#36075326">parent</a><span>|</span><a href="#36075439">prev</a><span>|</span><a href="#36079178">next</a><span>|</span><label class="collapse" for="c-36076965">[-]</label><label class="expand" for="c-36076965">[1 more]</label></div><br/><div class="children"><div class="content">Ended up building a tool which indexes every version of every package into a searchable tool. Was hacked together in a weekend, so the UI needs some polishing, but it&#x27;s functional :)<p><a href="https:&#x2F;&#x2F;nixdex.dev" rel="nofollow">https:&#x2F;&#x2F;nixdex.dev</a></div><br/></div></div><div id="36079178" class="c"><input type="checkbox" id="c-36079178" checked=""/><div class="controls bullet"><span class="by">jcpsimmons</span><span>|</span><a href="#36075326">parent</a><span>|</span><a href="#36076965">prev</a><span>|</span><a href="#36075544">next</a><span>|</span><label class="collapse" for="c-36079178">[-]</label><label class="expand" for="c-36079178">[2 more]</label></div><br/><div class="children"><div class="content">What is confusing about finding Nix packages? Just go to search.nixos.org<p>There has been a trend in software dev towards solving problems that don’t need solved. I’ve never been confused about how to find packages for nix.</div><br/><div id="36080505" class="c"><input type="checkbox" id="c-36080505" checked=""/><div class="controls bullet"><span class="by">soraminazuki</span><span>|</span><a href="#36075326">root</a><span>|</span><a href="#36079178">parent</a><span>|</span><a href="#36075544">next</a><span>|</span><label class="collapse" for="c-36080505">[-]</label><label class="expand" for="c-36080505">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s genuinely nice to have a CLI frontend for search.nixos.org, so I wouldn&#x27;t call it a problem that doesn&#x27;t need solving. But the rant about not being able to search packages is simply wrong IMHO.</div><br/></div></div></div></div><div id="36075544" class="c"><input type="checkbox" id="c-36075544" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#36075326">parent</a><span>|</span><a href="#36079178">prev</a><span>|</span><a href="#36075709">next</a><span>|</span><label class="collapse" for="c-36075544">[-]</label><label class="expand" for="c-36075544">[8 more]</label></div><br/><div class="children"><div class="content">&gt; Speaks to the lack of user focus in the Nix community.<p>Not really. Nix is not a tool, it&#x27;s a toolkit for making your own tools. Very much in the vein of Unix, shell, etc.<p>Many people don&#x27;t use Nix for &quot;installing&quot; stuff. I personally use it for deploying software to servers without the (congnitive and performance) overhead of containers.<p>I find search.nixos.org immensely useful, but don&#x27;t really need it from the CLI.</div><br/><div id="36075749" class="c"><input type="checkbox" id="c-36075749" checked=""/><div class="controls bullet"><span class="by">sterlind</span><span>|</span><a href="#36075326">root</a><span>|</span><a href="#36075544">parent</a><span>|</span><a href="#36075709">next</a><span>|</span><label class="collapse" for="c-36075749">[-]</label><label class="expand" for="c-36075749">[7 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Not really. Nix is not a tool, it&#x27;s a toolkit for making your own tools. Very much in the vein of Unix, shell, etc</i><p>even tools for tools should be ergonomic to use. the Nix language server should have autocomplete, searches and interacting with the language should be easy, etc. and nearly everyone needs to hunt for packages, even if they&#x27;re not &quot;installing&quot; them - they might be needed for the toolchain.<p>Nix is like early Git. all the raw power is there, but little of the porcelain. it&#x27;s so much better than anything before it that we accept the pain of dealing with exposed plumbing, but we shouldn&#x27;t get used to it.</div><br/><div id="36076164" class="c"><input type="checkbox" id="c-36076164" checked=""/><div class="controls bullet"><span class="by">ghuntley</span><span>|</span><a href="#36075326">root</a><span>|</span><a href="#36075749">parent</a><span>|</span><a href="#36081126">next</a><span>|</span><label class="collapse" for="c-36076164">[-]</label><label class="expand" for="c-36076164">[4 more]</label></div><br/><div class="children"><div class="content">The last two years have seen an increased focus on usability, education and polish now that after circa 15 years of establishing solid foundations are in place. All good things in time.<p>There’s no venture backed cash here paying for the polish that folks typically see in devtools launched in 2023. That polish is expensive to do and isn’t “fun or engaging” for the majority of developers thus classic open source problem of over indexing on serving the needs&#x2F;existing people who do not need the polish.<p>There’s some notable call-outs here of folks putting in serious effort such as <a href="https:&#x2F;&#x2F;nix.dev" rel="nofollow">https:&#x2F;&#x2F;nix.dev</a> ala <a href="https:&#x2F;&#x2F;cachix.org" rel="nofollow">https:&#x2F;&#x2F;cachix.org</a> out of love for nix to succeed.<p>Yeah nix wants to grow, and it is, largest bazaar GitHub community&#x2F;repo out there right now.<p>starting to see venture backed companies forming who are building the polish as porcelain over the top and giving back. see <a href="https:&#x2F;&#x2F;floxdev.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;floxdev.com&#x2F;</a><p>at this stage nix is a damn safe bet because of what it can do, the problems it solves and the size of community.</div><br/><div id="36077313" class="c"><input type="checkbox" id="c-36077313" checked=""/><div class="controls bullet"><span class="by">pxc</span><span>|</span><a href="#36075326">root</a><span>|</span><a href="#36076164">parent</a><span>|</span><a href="#36079403">next</a><span>|</span><label class="collapse" for="c-36077313">[-]</label><label class="expand" for="c-36077313">[2 more]</label></div><br/><div class="children"><div class="content">&gt; at this stage nix is a damn safe bet because of what it can do, the problems it solves and the size of community.<p>In the last few years, Nix has gone from a place where I was sometimes uncomfortable recommending it to people to one where I feel like it would be unstrategic not to use it where it fits. If you know Nix today, you should be pushing it at your company wherever you can see a good use case.</div><br/><div id="36077825" class="c"><input type="checkbox" id="c-36077825" checked=""/><div class="controls bullet"><span class="by">ghuntley</span><span>|</span><a href="#36075326">root</a><span>|</span><a href="#36077313">parent</a><span>|</span><a href="#36079403">next</a><span>|</span><label class="collapse" for="c-36077825">[-]</label><label class="expand" for="c-36077825">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In the last few years, Nix has gone from a place where I was sometimes uncomfortable recommending it to people to one where I feel like it would be unstrategic not to use it.<p>Super agree. Been using nix now for six(?) years and always been advocating for it but hesentiant to recommend companies adopt it (unless you can use it to attract talent as walmart did with nodejs back in the day) however with <a href="https:&#x2F;&#x2F;devenv.sh" rel="nofollow">https:&#x2F;&#x2F;devenv.sh</a> and <a href="https:&#x2F;&#x2F;nix.dev" rel="nofollow">https:&#x2F;&#x2F;nix.dev</a> in the existence the time to amaze is now measured in &lt; 5 minutes. nixpkgs also partially solves sbom topics, enables monkey patching any linux application&#x2F;kernel&#x2F;ffi dependency, has the freshest collection of packages (it&#x27;s more fresh than archlinux by a major factor) whilst all being under CI&#x2F;CD (shamefully rare in linux land)</div><br/></div></div></div></div><div id="36079403" class="c"><input type="checkbox" id="c-36079403" checked=""/><div class="controls bullet"><span class="by">tomberek</span><span>|</span><a href="#36075326">root</a><span>|</span><a href="#36076164">parent</a><span>|</span><a href="#36077313">prev</a><span>|</span><a href="#36081126">next</a><span>|</span><label class="collapse" for="c-36079403">[-]</label><label class="expand" for="c-36079403">[1 more]</label></div><br/><div class="children"><div class="content">At flox, we are specifically focusing on those people who are the advocates and bringing Nix into their organizations, teams, and companies. We call them the “Ambassadors”, and want to call out how important that role is in making Nix mainstream. Ideally, it should become the obvious choice - the default choice - where specific reasons need to be provided when not using it.</div><br/></div></div></div></div><div id="36081126" class="c"><input type="checkbox" id="c-36081126" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#36075326">root</a><span>|</span><a href="#36075749">parent</a><span>|</span><a href="#36076164">prev</a><span>|</span><a href="#36079188">next</a><span>|</span><label class="collapse" for="c-36081126">[-]</label><label class="expand" for="c-36081126">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m just saying that like Git and shell people will eventually make their own porcelain for a myriad different use cases. Most of those will probably be buried in some corporate proprietary repo.</div><br/></div></div><div id="36079188" class="c"><input type="checkbox" id="c-36079188" checked=""/><div class="controls bullet"><span class="by">jcpsimmons</span><span>|</span><a href="#36075326">root</a><span>|</span><a href="#36075749">parent</a><span>|</span><a href="#36081126">prev</a><span>|</span><a href="#36075709">next</a><span>|</span><label class="collapse" for="c-36079188">[-]</label><label class="expand" for="c-36079188">[1 more]</label></div><br/><div class="children"><div class="content">Should? By whose standard?<p>Also nix does have some autocomplete, check out Nil…</div><br/></div></div></div></div></div></div><div id="36075709" class="c"><input type="checkbox" id="c-36075709" checked=""/><div class="controls bullet"><span class="by">sterlind</span><span>|</span><a href="#36075326">parent</a><span>|</span><a href="#36075544">prev</a><span>|</span><a href="#36078453">next</a><span>|</span><label class="collapse" for="c-36075709">[-]</label><label class="expand" for="c-36075709">[5 more]</label></div><br/><div class="children"><div class="content">why does it query search.nixos.org, rather than looking through your local nixpkgs? just because of how tricky it&#x27;d be to handle the nix language or hacking on the nix toolchain proper?<p>also I agree that it&#x27;s ridiculous nix doesn&#x27;t have a search command. it baffles me.</div><br/><div id="36076287" class="c"><input type="checkbox" id="c-36076287" checked=""/><div class="controls bullet"><span class="by">peter_l_downs</span><span>|</span><a href="#36075326">root</a><span>|</span><a href="#36075709">parent</a><span>|</span><a href="#36077504">next</a><span>|</span><label class="collapse" for="c-36076287">[-]</label><label class="expand" for="c-36076287">[1 more]</label></div><br/><div class="children"><div class="content">This exists and searches `search.nixos.org` for a few reasons:<p>- you may want to search without downloading and indexing nixpkgs and the hydra results yourself<p>- you may want to search by the name of the binaries&#x2F;programs that will be installed, which is impossible to do by looking through a local package store alone<p>- you may want the search to be fast<p>- you may want to search from the command line<p>`nix search` is a cruel joke which doesn&#x27;t allow searching by the name&#x2F;program that would be installed, only package name, and requires a flake name every time. Absolutely terrible interface.<p>My tool is a single-install binary that performs fast and accurate search to help you find the right package name to install a given binary. I don&#x27;t understand how after years of using other package managers anyone could want a search tool that does anything other than this by default.<p>For more details on why this exists, check out <a href="https:&#x2F;&#x2F;github.com&#x2F;peterldowns&#x2F;nix-search-cli#motivation">https:&#x2F;&#x2F;github.com&#x2F;peterldowns&#x2F;nix-search-cli#motivation</a></div><br/></div></div><div id="36077504" class="c"><input type="checkbox" id="c-36077504" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#36075326">root</a><span>|</span><a href="#36075709">parent</a><span>|</span><a href="#36076287">prev</a><span>|</span><a href="#36076085">next</a><span>|</span><label class="collapse" for="c-36077504">[-]</label><label class="expand" for="c-36077504">[1 more]</label></div><br/><div class="children"><div class="content">Nix has several search commands, it&#x27;s just none of them do quite what people want (e.g. &quot;nix search&quot; with flakes and &quot;nix-query&quot; without flakes search by name and description, &quot;nix-locate&quot; can search by contents but the interface is a bit obtuse)<p>For those who want a local search for executables, and don&#x27;t mind running nix-index:<p><pre><code>    #!&#x2F;bin&#x2F;sh
    results=&quot;$(nix-locate -1 --regex --top-level &quot;^&#x2F;bin&#x2F;${1}\$&quot;)&quot;
    for item in $results; do
        nix search &quot;nixpkgs#${item%.*}&quot;
    done
</code></pre>
will search for a specific executable and give you (hopefully) reasonable output.  If you don&#x27;t have flakes enabled, you can just print the result of the command-substitution directly, but you won&#x27;t get the short description.</div><br/></div></div><div id="36076085" class="c"><input type="checkbox" id="c-36076085" checked=""/><div class="controls bullet"><span class="by">ghuntley</span><span>|</span><a href="#36075326">root</a><span>|</span><a href="#36075709">parent</a><span>|</span><a href="#36077504">prev</a><span>|</span><a href="#36076102">next</a><span>|</span><label class="collapse" for="c-36076085">[-]</label><label class="expand" for="c-36076085">[1 more]</label></div><br/><div class="children"><div class="content">search.nixos.org also includes flakes that people PR into the index via GitHub at <a href="https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixos-search&#x2F;issues">https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixos-search&#x2F;issues</a><p>ps: $ nix search exists via experimental flags <a href="https:&#x2F;&#x2F;nixos.org&#x2F;manual&#x2F;nix&#x2F;stable&#x2F;command-ref&#x2F;new-cli&#x2F;nix3-search.html" rel="nofollow">https:&#x2F;&#x2F;nixos.org&#x2F;manual&#x2F;nix&#x2F;stable&#x2F;command-ref&#x2F;new-cli&#x2F;nix3...</a></div><br/></div></div><div id="36076102" class="c"><input type="checkbox" id="c-36076102" checked=""/><div class="controls bullet"><span class="by">lilyball</span><span>|</span><a href="#36075326">root</a><span>|</span><a href="#36075709">parent</a><span>|</span><a href="#36076085">prev</a><span>|</span><a href="#36078453">next</a><span>|</span><label class="collapse" for="c-36076102">[-]</label><label class="expand" for="c-36076102">[1 more]</label></div><br/><div class="children"><div class="content">It does though. `nix search`.</div><br/></div></div></div></div></div></div><div id="36078609" class="c"><input type="checkbox" id="c-36078609" checked=""/><div class="controls bullet"><span class="by">hbrundage</span><span>|</span><a href="#36075326">prev</a><span>|</span><a href="#36076004">next</a><span>|</span><label class="collapse" for="c-36078609">[-]</label><label class="expand" for="c-36078609">[1 more]</label></div><br/><div class="children"><div class="content">Dang this is cool! I get why replit went so heavy on nix but I also feel like it must have a cost for them — nix is hard to learn, especially for folks new to development which I know makes up a lot of replits customer base.<p>We built a solution to the same problem with a similar approach[1], but that just snapshots any old files instead of doing nix derivations. Nix couples the build process to the content-addressability of the output, which works great if you want to put all the effort in to deterministic builds. We just read files like git does which works great for non-deterministic processes like npm install (tragically).<p>I like the idea of the Big Disk style of attaching a content addressable cache, but in our experiments we still found the network latency to the attached disk too high when reading file by file, like when booting a node app, so we’re caching a much smaller amount on a local SSD for each prod server. Maybe replit isn’t as sensitive to read perf from the cache layer, or they have fancy local per-node read through caching within the overlay setup? Regardless, cool!!<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;gadget-inc&#x2F;dateilager">https:&#x2F;&#x2F;github.com&#x2F;gadget-inc&#x2F;dateilager</a></div><br/></div></div><div id="36076004" class="c"><input type="checkbox" id="c-36076004" checked=""/><div class="controls bullet"><span class="by">smasher164</span><span>|</span><a href="#36078609">prev</a><span>|</span><a href="#36078284">next</a><span>|</span><label class="collapse" for="c-36076004">[-]</label><label class="expand" for="c-36076004">[7 more]</label></div><br/><div class="children"><div class="content">I love Nix as a package manager, and flakes are awesome for setting up environments. I wish it had more affordances for being a proper build system. If only there were a Buck2 and Nix hybrid.</div><br/><div id="36076396" class="c"><input type="checkbox" id="c-36076396" checked=""/><div class="controls bullet"><span class="by">chills</span><span>|</span><a href="#36076004">parent</a><span>|</span><a href="#36076246">next</a><span>|</span><label class="collapse" for="c-36076396">[-]</label><label class="expand" for="c-36076396">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If only there were a Buck2 and Nix hybrid<p>You&#x27;ll be interested in <a href="https:&#x2F;&#x2F;github.com&#x2F;thoughtpolice&#x2F;buck2-nix">https:&#x2F;&#x2F;github.com&#x2F;thoughtpolice&#x2F;buck2-nix</a></div><br/></div></div><div id="36076246" class="c"><input type="checkbox" id="c-36076246" checked=""/><div class="controls bullet"><span class="by">ghuntley</span><span>|</span><a href="#36076004">parent</a><span>|</span><a href="#36076396">prev</a><span>|</span><a href="#36077376">next</a><span>|</span><label class="collapse" for="c-36076246">[-]</label><label class="expand" for="c-36076246">[4 more]</label></div><br/><div class="children"><div class="content">would love it if the compilation closure was more incremental rather than at a derivation level. specifically caching sub modules. many folks working on improving this space.<p>last week benchmarks from tvnix (a rust rewrite of the nix cli) was published which saw a THIRTEEN second evaluation speed up on a basic derivation evaluation.<p><a href="https:&#x2F;&#x2F;twitter.com&#x2F;matthewcroughan&#x2F;status&#x2F;1660613835655348228?s=46" rel="nofollow">https:&#x2F;&#x2F;twitter.com&#x2F;matthewcroughan&#x2F;status&#x2F;16606138356553482...</a></div><br/><div id="36077400" class="c"><input type="checkbox" id="c-36077400" checked=""/><div class="controls bullet"><span class="by">pxc</span><span>|</span><a href="#36076004">root</a><span>|</span><a href="#36076246">parent</a><span>|</span><a href="#36077376">next</a><span>|</span><label class="collapse" for="c-36077400">[-]</label><label class="expand" for="c-36077400">[3 more]</label></div><br/><div class="children"><div class="content">I saw that tweet and thought it was pretty exciting!<p>How much of Nixpkgs can Tvix build these days?</div><br/><div id="36078922" class="c"><input type="checkbox" id="c-36078922" checked=""/><div class="controls bullet"><span class="by">RaitoBezarius</span><span>|</span><a href="#36076004">root</a><span>|</span><a href="#36077400">parent</a><span>|</span><a href="#36077376">next</a><span>|</span><label class="collapse" for="c-36078922">[-]</label><label class="expand" for="c-36078922">[2 more]</label></div><br/><div class="children"><div class="content">Those benchmarks are wrong and misleading. Tvix contributor (but mostly reviewer I would say) here. We still don&#x27;t have finished the integration with our own store, using the Nix store forces us to be slower than Nix, therefore the claims are bogus alas.<p>Tvix can *evaluate* a serious (?) chunk of Nixpkgs, but we have strictness bugs in some areas.<p>Tvix has no builder yet.</div><br/><div id="36079352" class="c"><input type="checkbox" id="c-36079352" checked=""/><div class="controls bullet"><span class="by">pxc</span><span>|</span><a href="#36076004">root</a><span>|</span><a href="#36078922">parent</a><span>|</span><a href="#36077376">next</a><span>|</span><label class="collapse" for="c-36079352">[-]</label><label class="expand" for="c-36079352">[1 more]</label></div><br/><div class="children"><div class="content">Well, congrats to y&#x27;all on good progress with the evaluator, then! That&#x27;s definitely still worth celebrating. :)</div><br/></div></div></div></div></div></div></div></div><div id="36077376" class="c"><input type="checkbox" id="c-36077376" checked=""/><div class="controls bullet"><span class="by">pxc</span><span>|</span><a href="#36076004">parent</a><span>|</span><a href="#36076246">prev</a><span>|</span><a href="#36078284">next</a><span>|</span><label class="collapse" for="c-36077376">[-]</label><label class="expand" for="c-36077376">[1 more]</label></div><br/><div class="children"><div class="content">bob.build looks kinda nice as a Nix-based, make-like tool, but IDK how it compares to the real, fancy, big tech monorepo build tools because I&#x27;ve never used them.<p><a href="https:&#x2F;&#x2F;bob.build&#x2F;" rel="nofollow">https:&#x2F;&#x2F;bob.build&#x2F;</a></div><br/></div></div></div></div><div id="36078284" class="c"><input type="checkbox" id="c-36078284" checked=""/><div class="controls bullet"><span class="by">tormeh</span><span>|</span><a href="#36076004">prev</a><span>|</span><a href="#36078413">next</a><span>|</span><label class="collapse" for="c-36078284">[-]</label><label class="expand" for="c-36078284">[6 more]</label></div><br/><div class="children"><div class="content">Nix Flakes are deemed experimental and explicitly not recommended in prod by the Nix project, afaict. Despite these warnings it’s widely used, but breakage is very much a possibility because it hasn’t gone through the Nix RFC process.</div><br/><div id="36079519" class="c"><input type="checkbox" id="c-36079519" checked=""/><div class="controls bullet"><span class="by">whateveracct</span><span>|</span><a href="#36078284">parent</a><span>|</span><a href="#36079418">next</a><span>|</span><label class="collapse" for="c-36079519">[-]</label><label class="expand" for="c-36079519">[2 more]</label></div><br/><div class="children"><div class="content">Where did anyone say &quot;not recommended in prod&quot;? The experimental tag is mostly saying they may change the API when they upgrade Nix itself.<p>Also, &quot;in prod&quot; is such an odd thing to say about Nix. It&#x27;s a built-time thing. Nix doesn&#x27;t run in prod. Even NixOS isn&#x27;t running Nix code. It&#x27;s running systemd units.</div><br/><div id="36080256" class="c"><input type="checkbox" id="c-36080256" checked=""/><div class="controls bullet"><span class="by">rgoulter</span><span>|</span><a href="#36078284">root</a><span>|</span><a href="#36079519">parent</a><span>|</span><a href="#36079418">next</a><span>|</span><label class="collapse" for="c-36080256">[-]</label><label class="expand" for="c-36080256">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Also, &quot;in prod&quot; is such an odd thing to say about Nix. It&#x27;s a built-time thing. Nix doesn&#x27;t run in prod.<p>What people mean by &quot;use X in production&quot; is that X is a key dependency as part of the production process.<p>If you describe a NixOS configuration for the system where your services are running, you&#x27;re &quot;using&quot; Nix, even though the Nix-specific stuff is already done.<p>This relates to risk. -- If it turned out that using Nix to build packages or to configure a system then caused problems when running services later, that would be a problem. Whereas, &quot;using in prod&quot; suggests confidence in no problems, or in being able to fix any issue in a timely manner.</div><br/></div></div></div></div><div id="36079418" class="c"><input type="checkbox" id="c-36079418" checked=""/><div class="controls bullet"><span class="by">tomberek</span><span>|</span><a href="#36078284">parent</a><span>|</span><a href="#36079519">prev</a><span>|</span><a href="#36080698">next</a><span>|</span><label class="collapse" for="c-36079418">[-]</label><label class="expand" for="c-36079418">[1 more]</label></div><br/><div class="children"><div class="content">Stabilization of flakes and certain other experimental features is a top priority for the Nix team at the moment (disclaimer: myself included). Please take a look at RFC136 for an outline of our plan for the way ahead…… and please comment.</div><br/></div></div><div id="36080698" class="c"><input type="checkbox" id="c-36080698" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#36078284">parent</a><span>|</span><a href="#36079418">prev</a><span>|</span><a href="#36078398">next</a><span>|</span><label class="collapse" for="c-36080698">[-]</label><label class="expand" for="c-36080698">[1 more]</label></div><br/><div class="children"><div class="content">Flakes seem to be in &quot;beta&quot; the way Gmail was for years.  Just about everyone I know that uses nix uses flakes now, and I&#x27;ve mostly switched myself.</div><br/></div></div><div id="36078398" class="c"><input type="checkbox" id="c-36078398" checked=""/><div class="controls bullet"><span class="by">breakds</span><span>|</span><a href="#36078284">parent</a><span>|</span><a href="#36080698">prev</a><span>|</span><a href="#36078413">next</a><span>|</span><label class="collapse" for="c-36078398">[-]</label><label class="expand" for="c-36078398">[1 more]</label></div><br/><div class="children"><div class="content">Have been using flakes in production for more than 2 years - I think it is stable enough for daily use.</div><br/></div></div></div></div><div id="36076030" class="c"><input type="checkbox" id="c-36076030" checked=""/><div class="controls bullet"><span class="by">Stammon</span><span>|</span><a href="#36078413">prev</a><span>|</span><a href="#36079821">next</a><span>|</span><label class="collapse" for="c-36076030">[-]</label><label class="expand" for="c-36076030">[2 more]</label></div><br/><div class="children"><div class="content">So do they share their implementation of overlaying stores somewhere?  It would be a huge benefit for the community to have it open source and available for being  used in countless other use cases.</div><br/><div id="36076062" class="c"><input type="checkbox" id="c-36076062" checked=""/><div class="controls bullet"><span class="by">bb010g</span><span>|</span><a href="#36076030">parent</a><span>|</span><a href="#36079821">next</a><span>|</span><label class="collapse" for="c-36076062">[-]</label><label class="expand" for="c-36076062">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In the coming weeks, we will be developing the Layered Store features, releasing a Nix Community RFC, and working to upstream it into Nix.<p>Doesn&#x27;t look like specs or implementations are public yet.</div><br/></div></div></div></div><div id="36079821" class="c"><input type="checkbox" id="c-36079821" checked=""/><div class="controls bullet"><span class="by">firstlink</span><span>|</span><a href="#36076030">prev</a><span>|</span><a href="#36078507">next</a><span>|</span><label class="collapse" for="c-36079821">[-]</label><label class="expand" for="c-36079821">[4 more]</label></div><br/><div class="children"><div class="content">Nix is solving the wrong problems, and I&#x27;m dismayed that it is being adopted more and more to solve those wrong problems. The very concept of a &quot;development environment&quot; is indicative of broken build systems. Ecosystems like python are trying desperately to tame the insanity using venvs, while ecosystems like rust were built correctly from the start with Cargo. Neither of these benefits in the least way from Nix or the most popular alternative, Docker (except that both end up falling victim to the insanity of other ecosystems when FFI comes into play).<p>What Nix could have been was a global un-fscked dependency manager, a la Portage but with Nix&#x27;s special sauce for local environments -- thereby working around fundamentally and permanently broken ecosystems like C, which would be useful even in the FFI case. But somehow it never got around to actually managing dependencies. By failing to manage dependencies (by pretending that versioning doesn&#x27;t exist, and supporting only exact software sets), Nix only re-entrenches the same bad behavior and broken systems which it should have been replacing: i.e., <i>encouraging</i> &quot;works-on-my-system&quot; build environments, by making them part of mandatory collaboration workflows.<p>So, soon: Encounter a bug because the build depends on the environment in some inappropriate, insane way? Then it&#x27;s your own fault for not adhering to the approved Nix build instructions which would set up a system which doesn&#x27;t exhibit that bug.</div><br/><div id="36080669" class="c"><input type="checkbox" id="c-36080669" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#36079821">parent</a><span>|</span><a href="#36081471">next</a><span>|</span><label class="collapse" for="c-36080669">[-]</label><label class="expand" for="c-36080669">[1 more]</label></div><br/><div class="children"><div class="content">There is a lot to unpack here — first of all, Nix and Docker are not at all competitors. Docker doesn’t even try to be reproducible, most builds will just apt install the newest available version that could easily change between invocations.<p>Next, Cargo is not a solution: it can only do a tiny part of the problem, namely managing Rust dependencies for a Rust project.<p>What if you are building a tool that needs a shared lib to communicate with.. basically anything? Rust has an enthusiastic community, but it is still a tiny language — most problems require more than what can be found in any one language’s berks.<p>Also, what even is a version? 3.4 of package X doesn’t mean anything — if it has like 10 flags than it can be built 2^10 different ways, and then we didn’t even count its dependencies that are also not just a number. Nix does the <i>correct</i> thing, not the naive one.</div><br/></div></div><div id="36081471" class="c"><input type="checkbox" id="c-36081471" checked=""/><div class="controls bullet"><span class="by">chriswarbo</span><span>|</span><a href="#36079821">parent</a><span>|</span><a href="#36080669">prev</a><span>|</span><a href="#36080403">next</a><span>|</span><label class="collapse" for="c-36081471">[-]</label><label class="expand" for="c-36081471">[1 more]</label></div><br/><div class="children"><div class="content">Nix is not about &quot;development environments&quot; (i.e. &#x27;nix-shell&#x27;); that&#x27;s just a side-effect which comes for free. Nix&#x27;s main entry-point is &#x27;nix-build&#x27;, which runs a specified executable with specified arguments and environment variables.<p>(The same applies for the newer &#x27;nix&#x27; CLI, but I&#x27;m less familiar with that)</div><br/></div></div><div id="36080403" class="c"><input type="checkbox" id="c-36080403" checked=""/><div class="controls bullet"><span class="by">colordrops</span><span>|</span><a href="#36079821">parent</a><span>|</span><a href="#36081471">prev</a><span>|</span><a href="#36078507">next</a><span>|</span><label class="collapse" for="c-36080403">[-]</label><label class="expand" for="c-36080403">[1 more]</label></div><br/><div class="children"><div class="content">Is this a real problem? I&#x27;ve been using Nix for a year and a half constantly updating on 3 systems and haven&#x27;t seen the issues you describe.</div><br/></div></div></div></div><div id="36078507" class="c"><input type="checkbox" id="c-36078507" checked=""/><div class="controls bullet"><span class="by">nwmcsween</span><span>|</span><a href="#36079821">prev</a><span>|</span><a href="#36076636">next</a><span>|</span><label class="collapse" for="c-36078507">[-]</label><label class="expand" for="c-36078507">[1 more]</label></div><br/><div class="children"><div class="content">A less painful alternative to dancing around the issue is just to use the filesystem itself as a global database.</div><br/></div></div><div id="36076636" class="c"><input type="checkbox" id="c-36076636" checked=""/><div class="controls bullet"><span class="by">woleium</span><span>|</span><a href="#36078507">prev</a><span>|</span><label class="collapse" for="c-36076636">[-]</label><label class="expand" for="c-36076636">[7 more]</label></div><br/><div class="children"><div class="content">But oh my, the security implications. Nix is great, but there&#x27;s no chain of trust on where these packages come from. Did we learn nothing from &#x27;left_pad&#x27;?</div><br/><div id="36077069" class="c"><input type="checkbox" id="c-36077069" checked=""/><div class="controls bullet"><span class="by">tomberek</span><span>|</span><a href="#36076636">parent</a><span>|</span><a href="#36081489">next</a><span>|</span><label class="collapse" for="c-36077069">[-]</label><label class="expand" for="c-36077069">[3 more]</label></div><br/><div class="children"><div class="content">Other than the very explicit tracking of the packages, their dependencies, the full build instructions, the public history, cryptographic signatures for the pre-built binaries, and the trivial ability for anyone to re-build from source and audit the entire chain all the way from bootstrap if they wished?<p>I’m not sure what golden standard we are comparing this to. It is not perfect, but I’d say this is a far more solid bedrock upon which to build software than anything else I’ve encountered.</div><br/><div id="36078942" class="c"><input type="checkbox" id="c-36078942" checked=""/><div class="controls bullet"><span class="by">RaitoBezarius</span><span>|</span><a href="#36076636">root</a><span>|</span><a href="#36077069">parent</a><span>|</span><a href="#36081489">next</a><span>|</span><label class="collapse" for="c-36078942">[-]</label><label class="expand" for="c-36078942">[2 more]</label></div><br/><div class="children"><div class="content">Did you mention sandboxed builds? Actively preventing pip to execute code arbitrarily at install time? Same for Node.js?<p>I cannot live without that anymore, that&#x27;s the new golden standard.</div><br/><div id="36079344" class="c"><input type="checkbox" id="c-36079344" checked=""/><div class="controls bullet"><span class="by">tomberek</span><span>|</span><a href="#36076636">root</a><span>|</span><a href="#36078942">parent</a><span>|</span><a href="#36081489">next</a><span>|</span><label class="collapse" for="c-36079344">[-]</label><label class="expand" for="c-36079344">[1 more]</label></div><br/><div class="children"><div class="content">It’s funny; I forgot to mention sandboxed builds because at this point I’ve forgotten that they are not ubiquitous. Oops. Thanks!</div><br/></div></div></div></div></div></div><div id="36081489" class="c"><input type="checkbox" id="c-36081489" checked=""/><div class="controls bullet"><span class="by">chriswarbo</span><span>|</span><a href="#36076636">parent</a><span>|</span><a href="#36077069">prev</a><span>|</span><a href="#36079203">next</a><span>|</span><label class="collapse" for="c-36081489">[-]</label><label class="expand" for="c-36081489">[1 more]</label></div><br/><div class="children"><div class="content">You can see exactly where everything&#x27;s come from, using a command like:<p><pre><code>  nix-store --query --tree &quot;$(nix-store --query --deriver &quot;$(which python3)&quot;)&quot;</code></pre></div><br/></div></div><div id="36079203" class="c"><input type="checkbox" id="c-36079203" checked=""/><div class="controls bullet"><span class="by">jcpsimmons</span><span>|</span><a href="#36076636">parent</a><span>|</span><a href="#36081489">prev</a><span>|</span><a href="#36078071">next</a><span>|</span><label class="collapse" for="c-36079203">[-]</label><label class="expand" for="c-36079203">[1 more]</label></div><br/><div class="children"><div class="content">There are no security implications other than those brought by the user. Freeze and host your own copies of libraries in an overlay (or write your own). The developer chooses which packages to use and from where, VERY explicitly and with a SHA which is far more secure than NPM for example (which is in production…everywhere)</div><br/></div></div><div id="36078071" class="c"><input type="checkbox" id="c-36078071" checked=""/><div class="controls bullet"><span class="by">anon291</span><span>|</span><a href="#36076636">parent</a><span>|</span><a href="#36079203">prev</a><span>|</span><label class="collapse" for="c-36078071">[-]</label><label class="expand" for="c-36078071">[1 more]</label></div><br/><div class="children"><div class="content">Every nix package has to be signed in order for it to be installed via binary cache.</div><br/></div></div></div></div></div></div></div></div></div></body></html>