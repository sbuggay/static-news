<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1686906067921" as="style"/><link rel="stylesheet" href="styles.css?v=1686906067921"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.mermaidchart.com/blog/posts/sequence-diagrams-the-good-thing-uml-brought-to-software-development">Sequence diagrams, the only good thing UML brought to software development</a> <span class="domain">(<a href="https://www.mermaidchart.com">www.mermaidchart.com</a>)</span></div><div class="subtext"><span>knsv</span> | <span>216 comments</span></div><br/><div><div id="36343997" class="c"><input type="checkbox" id="c-36343997" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#36343389">next</a><span>|</span><label class="collapse" for="c-36343997">[-]</label><label class="expand" for="c-36343997">[43 more]</label></div><br/><div class="children"><div class="content">I also find sequence diagrams to be the most useful, but disagree that the rest of UML is useless. Class, component, package, activity and state machine diagrams are all useful ways to model the structure and behavior of a system visually.<p>The only reason the other diagram types fell out of favor is because of the development methodology change starting in the early 2000s. The industry started rejecting Waterfall, early design and system architects, in favor of Agile, just-in-time design and empowering developers. So we saw no need for these visual design tools to model the entire system, since we ended up changing the design during the lifetime of the project anyway. The drawback of this, of course, is that with the Agile approach these diagrams never end up being made, so developers are left to assemble their own mental model of the system, which hurts the overall comprehension. Most developers IME actively reject these diagrams because they are quickly outdated, or require constant changes to keep up to date, which is true, but this is not unlike documentation, comments, and a myriad other things that needs to be synced with the code.<p>Yet sequence diagrams are useful in a wide variety of use cases, and let&#x27;s face it, they&#x27;re the easiest ones to comprehend, and are even understandable by a non-technical audience. In contrast to the other UML diagram types that have strange notations and the information is more densely packed.</div><br/><div id="36352989" class="c"><input type="checkbox" id="c-36352989" checked=""/><div class="controls bullet"><span class="by">BerislavLopac</span><span>|</span><a href="#36343997">parent</a><span>|</span><a href="#36344389">next</a><span>|</span><label class="collapse" for="c-36352989">[-]</label><label class="expand" for="c-36352989">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Class, component, package, activity and state machine diagrams are all useful ways to model the structure and behavior of a system visually<p>They&#x27;re not bad, but the C4 model is a much better approach to high level modelling (while you can still use class diagrams on the lowest level). <a href="https:&#x2F;&#x2F;c4model.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;c4model.com&#x2F;</a></div><br/></div></div><div id="36344389" class="c"><input type="checkbox" id="c-36344389" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#36343997">parent</a><span>|</span><a href="#36352989">prev</a><span>|</span><a href="#36344506">next</a><span>|</span><label class="collapse" for="c-36344389">[-]</label><label class="expand" for="c-36344389">[10 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Class, component, package, activity and state machine diagrams are all useful ways to model the structure and behavior of a system visually.</i><p>I completely agree with you.<p>It&#x27;s a good way for <i>other people</i> to present information, for me to look at.<p>I just won&#x27;t do it myself.<p>It&#x27;s not only me; and that&#x27;s why it&#x27;s dead.<p>I won&#x27;t do it because the first thing that comes to mind is how it will go out of date in a month, and have to be maintained to stay accurate.<p>Maybe in the not-too-distant future we will have AI grokking large code bases and cranking out accurate, useful, UML diagrams out of it.<p>All those diagrams, when they are complete, correct and up-to-date, do convey what they are supposed to convey.</div><br/><div id="36345147" class="c"><input type="checkbox" id="c-36345147" checked=""/><div class="controls bullet"><span class="by">lemmsjid</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36344389">parent</a><span>|</span><a href="#36348520">next</a><span>|</span><label class="collapse" for="c-36345147">[-]</label><label class="expand" for="c-36345147">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve taken a throwaway approach to diagramming, where I&#x27;ll produce them more or less on demand for a meeting or presentation, but not think of them as an enduring artifact.  PlantUML is my friend here because I can knock out ugly but gets-the-point-across diagrams in 30 minutes before a meeting and check them into source control, so I can then take the bones of older diagrams and rework them for a fresh meeting.<p>I used to whiteboard for this, but that hasn&#x27;t carried over well in the remote world.  What I miss about whiteboarding though is that you can tell a story as you draw, so whoever&#x27;s viewing can watch something unfold from a blank slate while I&#x27;m walking them through the history of whatever system we&#x27;re describing.  That said, I can make a PlantUML diagram much more correct than a whiteboard.<p>All that said I too would love for more of that to be automated increasingly through AI.  And I suppose it should make sense conceptually, because for me the value of a crafted diagram over an automated one is that no one really wants to look at the insane ERD of an OLTP database or a production object model.  They want the digestible high level vision of the important bits, or the bits that are relevant to the conversation taking place.  So it&#x27;s a summarization problem.  How to get the right data to produce a correct summary is interesting--I&#x27;m sure if I look there&#x27;s a dozen papers to read on a similar subject :).</div><br/><div id="36346020" class="c"><input type="checkbox" id="c-36346020" checked=""/><div class="controls bullet"><span class="by">theK</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36345147">parent</a><span>|</span><a href="#36345657">next</a><span>|</span><label class="collapse" for="c-36346020">[-]</label><label class="expand" for="c-36346020">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a great approach that has worked for me too. I think plant is a great little system. Not only can you get your point over in a handful of lines of text but I have found out that it is quite easy to generate the plantuml programmatically. So instead of having to keep docs and code in sync you can end up generating your graphs in ci. The upside compared to big diagramming products is that plant requites no boilerplate and you can provably grep and sed most diagrams out of your codebase which is a quite low barrier to entry.</div><br/></div></div><div id="36345657" class="c"><input type="checkbox" id="c-36345657" checked=""/><div class="controls bullet"><span class="by">4lejandrito</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36345147">parent</a><span>|</span><a href="#36346020">prev</a><span>|</span><a href="#36348520">next</a><span>|</span><label class="collapse" for="c-36345657">[-]</label><label class="expand" for="c-36345657">[2 more]</label></div><br/><div class="children"><div class="content">For whiteboarding remotely I use <a href="https:&#x2F;&#x2F;excalidraw.com" rel="nofollow noreferrer">https:&#x2F;&#x2F;excalidraw.com</a>. I use it exactly for your use case. I’ve told live stories with it.</div><br/><div id="36346037" class="c"><input type="checkbox" id="c-36346037" checked=""/><div class="controls bullet"><span class="by">theK</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36345657">parent</a><span>|</span><a href="#36348520">next</a><span>|</span><label class="collapse" for="c-36346037">[-]</label><label class="expand" for="c-36346037">[1 more]</label></div><br/><div class="children"><div class="content">excalidraw is great especially the paid product. One of the cases of a very good open core business plan. I hope they do well.</div><br/></div></div></div></div></div></div><div id="36348520" class="c"><input type="checkbox" id="c-36348520" checked=""/><div class="controls bullet"><span class="by">starlust2</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36344389">parent</a><span>|</span><a href="#36345147">prev</a><span>|</span><a href="#36345121">next</a><span>|</span><label class="collapse" for="c-36348520">[-]</label><label class="expand" for="c-36348520">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Maybe in the not-too-distant future we will have AI grokking large code bases and cranking out accurate, useful, UML diagrams out of it.<p>&gt; All those diagrams, when they are complete, correct and up-to-date, do convey what they are supposed to convey.<p>I spent a bit of time prototyping this recently. It&#x27;s definitely possible. Rational Rose also had the capability to generate diagrams from code though. I don&#x27;t remember how good it was at the task though. Was Rational Rose just a very bad implementation?<p>I find the hate in this chat strange because diagrams are incredibly useful when working through complex problems* and then conveying that information to other engineers. My experience over 20+ years is that a huge portion of engineers can&#x27;t grok complex problems from code alone.<p>*Most of my projects are optimizing billion+ row databases, micro-service architectures, and various other scaling challenges.</div><br/><div id="36349160" class="c"><input type="checkbox" id="c-36349160" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36348520">parent</a><span>|</span><a href="#36345121">next</a><span>|</span><label class="collapse" for="c-36349160">[-]</label><label class="expand" for="c-36349160">[2 more]</label></div><br/><div class="children"><div class="content">The problem isn&#x27;t generating UML from code, the problem is generating useful UML from code.<p>Where those boxes are in relation to each other matters. You can&#x27;t just randomly throw boxes and lines on the page, you need to arrange them so that boxes that we can tell what things are related by how close they are to each other. Automatic UML doesn&#x27;t capture that.<p>Sometime you have complexity in code that needs tobe hidden by default. I don&#x27;t care about rare error cases most of the time, but automatic UML can&#x27;t know what is the complexity needed for rare cases and what is complexity you need to show the junior on the first day.. related to this when i&#x27;m interested in one error path how do you hide the others?<p>Then the real killer of both.  Next week there is a minor requirement change (new features we always knew were coming and planned for even), and now the code changed.  UML doesn&#x27;t follow that. Either you generate UML and have the above problems. Or you manually update UML in theory, but in practice just let it slide as the week after you know something else will change and you don&#x27;t nees it today anyway.</div><br/><div id="36352099" class="c"><input type="checkbox" id="c-36352099" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36349160">parent</a><span>|</span><a href="#36345121">next</a><span>|</span><label class="collapse" for="c-36352099">[-]</label><label class="expand" for="c-36352099">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Or you manually update UML in theory, but in practice just let it slide as the week after you know something else will change and you don&#x27;t nees it today anyway.<p>I&#x27;ve heard this argument many times, but how is it different from keeping documentation, comments, tests, or the issue tracker up to date?<p>They all require some discipline, but if the team finds value in any of these things, they would make an effort to keep them synchronized with the code.<p>Besides, I suggest not falling in the trap of having formal design documents early on in the project&#x27;s lifetime. Rather start with informal diagrams and sketches, and once the design has mostly settled, switch to something like UML. This would mean it wouldn&#x27;t require changes every other week.<p>As for automatically generating, and dynamically arranging diagrams, this is more up to the generating tool than UML. These tools are still stuck using decades old technology at this point AFAIA, but there&#x27;s no reason that a smarter tool couldn&#x27;t do the things you mention.</div><br/></div></div></div></div></div></div><div id="36345121" class="c"><input type="checkbox" id="c-36345121" checked=""/><div class="controls bullet"><span class="by">slowmovintarget</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36344389">parent</a><span>|</span><a href="#36348520">prev</a><span>|</span><a href="#36345810">next</a><span>|</span><label class="collapse" for="c-36345121">[-]</label><label class="expand" for="c-36345121">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll draw those diagrams... on a whiteboard, sans boxes (Tufte). Great for point-in-time communication, less useful as specifications.</div><br/></div></div><div id="36345810" class="c"><input type="checkbox" id="c-36345810" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36344389">parent</a><span>|</span><a href="#36345121">prev</a><span>|</span><a href="#36344506">next</a><span>|</span><label class="collapse" for="c-36345810">[-]</label><label class="expand" for="c-36345810">[1 more]</label></div><br/><div class="children"><div class="content">surprisingly, for average crowds, who usually describe stuff in fluffy text, UML-like diagrams suddenly feel like going from VB5 to python3</div><br/></div></div></div></div><div id="36344506" class="c"><input type="checkbox" id="c-36344506" checked=""/><div class="controls bullet"><span class="by">cubefox</span><span>|</span><a href="#36343997">parent</a><span>|</span><a href="#36344389">prev</a><span>|</span><a href="#36346297">next</a><span>|</span><label class="collapse" for="c-36344506">[-]</label><label class="expand" for="c-36344506">[14 more]</label></div><br/><div class="children"><div class="content">People who say &quot;UML is useless&quot; basically say &quot;diagrams are useless&quot;. Which obviously isn&#x27;t true. The alternative to UML is everyone inventing their own &quot;diagram language&quot; when they want to visualize something.<p>Moreover, I think comparing different UML diagrams can also be enlightening for university students. E.g. state machine digrams look quite similar to activity diagrams, but the former emphasize states and the latter actions. And class diagrams let you learn the connection between class structures of OOP languages and database structures.<p>UML lets you visually learn the abstract higher level concepts without having to rely on irrelevant specifics of practical implementations, or just on dry theoretical text.</div><br/><div id="36345166" class="c"><input type="checkbox" id="c-36345166" checked=""/><div class="controls bullet"><span class="by">radicalbyte</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36344506">parent</a><span>|</span><a href="#36344561">next</a><span>|</span><label class="collapse" for="c-36345166">[-]</label><label class="expand" for="c-36345166">[4 more]</label></div><br/><div class="children"><div class="content">UML as a projection is fine and a valuable tool.<p>Starting with UML to describe a set of classes or - worse yet - an entire system is lunacy and a massive red flag.</div><br/><div id="36349093" class="c"><input type="checkbox" id="c-36349093" checked=""/><div class="controls bullet"><span class="by">cubefox</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36345166">parent</a><span>|</span><a href="#36344561">next</a><span>|</span><label class="collapse" for="c-36349093">[-]</label><label class="expand" for="c-36349093">[3 more]</label></div><br/><div class="children"><div class="content">What&#x27;s wrong with describing some classes first with a UML diagram?</div><br/><div id="36352258" class="c"><input type="checkbox" id="c-36352258" checked=""/><div class="controls bullet"><span class="by">wiz21c</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36349093">parent</a><span>|</span><a href="#36344561">next</a><span>|</span><label class="collapse" for="c-36352258">[-]</label><label class="expand" for="c-36352258">[2 more]</label></div><br/><div class="children"><div class="content">Nothing wrong, but code is already formal enough that you don&#x27;t need a formal visual language (UML is not just a bunch of diagrams, it&#x27;s a formal language). So yeah, a bit of drawing might help to understand, a few ideas from UML might help, but it&#x27;s not like it is super necessary.<p>As said, the sequence diagram is a real plus because sequence information is not very well expressed by code, so that diagram has much added value.<p>I personnaly find UML hard to use becaues if you want to communicate your ideas precisely, you have to know much of its formalism and most often, people who read your drawings don&#x27;t master its intricacies, so communication quality is no good...</div><br/><div id="36352674" class="c"><input type="checkbox" id="c-36352674" checked=""/><div class="controls bullet"><span class="by">throwaway290</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36352258">parent</a><span>|</span><a href="#36344561">next</a><span>|</span><label class="collapse" for="c-36352674">[-]</label><label class="expand" for="c-36352674">[1 more]</label></div><br/><div class="children"><div class="content">&gt; code is already formal enough that you don&#x27;t need a formal visual language<p>Code can be formal enough but in reality it is almost never formal enough. Many constraints can be expressed imperatively (eg. someone validates the number of related objects in the create view) and in unexpected places (across repositories and libraries and maybe not even in code but in some stored procedure). And then it is all in flux and can go away the moment you change your stack.<p>I don&#x27;t know if UML is perfectly flexible (maybe?) but its sure benefit is a source of truth that does not depend on your implementation.</div><br/></div></div></div></div></div></div></div></div><div id="36344561" class="c"><input type="checkbox" id="c-36344561" checked=""/><div class="controls bullet"><span class="by">auggierose</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36344506">parent</a><span>|</span><a href="#36345166">prev</a><span>|</span><a href="#36346304">next</a><span>|</span><label class="collapse" for="c-36344561">[-]</label><label class="expand" for="c-36344561">[3 more]</label></div><br/><div class="children"><div class="content">The nice thing about visual stuff is that it is self-explanatory. Instead of needing to read a book about UML first, maybe just use some prose in addition to your diagrams, and you don&#x27;t need UML at all then. That&#x27;s also more flexibel.</div><br/><div id="36346606" class="c"><input type="checkbox" id="c-36346606" checked=""/><div class="controls bullet"><span class="by">bigbillheck</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36344561">parent</a><span>|</span><a href="#36346304">next</a><span>|</span><label class="collapse" for="c-36346606">[-]</label><label class="expand" for="c-36346606">[2 more]</label></div><br/><div class="children"><div class="content">&gt; it is self-explanatory<p>It most certainly is not.</div><br/></div></div></div></div><div id="36346304" class="c"><input type="checkbox" id="c-36346304" checked=""/><div class="controls bullet"><span class="by">pavon</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36344506">parent</a><span>|</span><a href="#36344561">prev</a><span>|</span><a href="#36345635">next</a><span>|</span><label class="collapse" for="c-36346304">[-]</label><label class="expand" for="c-36346304">[1 more]</label></div><br/><div class="children"><div class="content">There are other types of diagrams beyond what UML formalizes. For example, Data Flow diagrams can be very helpful, but they don&#x27;t exist in UML (Component, Composite Structure, and Activity diagrams all have similarities with Data Flow diagrams, but none are really a great fit).</div><br/></div></div><div id="36345635" class="c"><input type="checkbox" id="c-36345635" checked=""/><div class="controls bullet"><span class="by">pshc</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36344506">parent</a><span>|</span><a href="#36346304">prev</a><span>|</span><a href="#36344872">next</a><span>|</span><label class="collapse" for="c-36345635">[-]</label><label class="expand" for="c-36345635">[1 more]</label></div><br/><div class="children"><div class="content">The superior alternative is drawing a diagram on a piece of paper to exercise the mind and show to collaborators, and never setting foot anywhere close to the UML tarpit.</div><br/></div></div><div id="36344872" class="c"><input type="checkbox" id="c-36344872" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36344506">parent</a><span>|</span><a href="#36345635">prev</a><span>|</span><a href="#36346297">next</a><span>|</span><label class="collapse" for="c-36344872">[-]</label><label class="expand" for="c-36344872">[4 more]</label></div><br/><div class="children"><div class="content">&gt; everyone inventing their own &quot;diagram language&quot;<p>This is clearly better than UML. UML is full of shorthands that nobody remembers. That&#x27;s worse than people making labelled custom diagrams.<p>Here&#x27;s an example:<p><a href="https:&#x2F;&#x2F;buck2.build&#x2F;docs&#x2F;concepts&#x2F;concept_map&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;buck2.build&#x2F;docs&#x2F;concepts&#x2F;concept_map&#x2F;</a><p>Imagine how much worse that would be with UML arrows.</div><br/><div id="36346966" class="c"><input type="checkbox" id="c-36346966" checked=""/><div class="controls bullet"><span class="by">cubefox</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36344872">parent</a><span>|</span><a href="#36346297">next</a><span>|</span><label class="collapse" for="c-36346966">[-]</label><label class="expand" for="c-36346966">[3 more]</label></div><br/><div class="children"><div class="content">That concept map example is only a loose association of ideas, where the nodes aren&#x27;t of the same type (e.g. event, state, class etc), or sorted into types, and apparently included quite arbitrarily. Mind maps are similarly loose. UML is for when you want more precise diagrams about a fixed subject matter.<p>I agree on the &quot;shorthands&quot;, like empty&#x2F;filled arrows, that people may not know. But there isn&#x27;t much alternative to such shorthands other than leaving them out completely, which wouldn&#x27;t be an advantage. In diagrams some information is either conveyed succinctly or not at all. The &quot;alternative&quot; is a block of text instead of a diagram.</div><br/><div id="36348816" class="c"><input type="checkbox" id="c-36348816" checked=""/><div class="controls bullet"><span class="by">yencabulator</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36346966">parent</a><span>|</span><a href="#36346297">next</a><span>|</span><label class="collapse" for="c-36348816">[-]</label><label class="expand" for="c-36348816">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s heavy backpedaling from your earlier<p>&gt; People who say &quot;UML is useless&quot; basically say &quot;diagrams are useless&quot;.</div><br/><div id="36349114" class="c"><input type="checkbox" id="c-36349114" checked=""/><div class="controls bullet"><span class="by">cubefox</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36348816">parent</a><span>|</span><a href="#36346297">next</a><span>|</span><label class="collapse" for="c-36349114">[-]</label><label class="expand" for="c-36349114">[1 more]</label></div><br/><div class="children"><div class="content">Well, if you only allow concept maps and mind maps, then I guess, yes, you don&#x27;t actually say (all) diagrams are useless. But you are pretty close.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36346297" class="c"><input type="checkbox" id="c-36346297" checked=""/><div class="controls bullet"><span class="by">johnyzee</span><span>|</span><a href="#36343997">parent</a><span>|</span><a href="#36344506">prev</a><span>|</span><a href="#36345374">next</a><span>|</span><label class="collapse" for="c-36346297">[-]</label><label class="expand" for="c-36346297">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Most developers IME actively reject these diagrams because they are quickly outdated, or require constant changes to keep up to date</i><p>Plans are useless, but planning is indispensable. The act of diagramming things up front is useful to get you thinking about the problem space and come up with the outline of a solution. After that, keeping the initial design documents up-to-date is optional, and often might not be necessary.</div><br/><div id="36347060" class="c"><input type="checkbox" id="c-36347060" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36346297">parent</a><span>|</span><a href="#36345374">next</a><span>|</span><label class="collapse" for="c-36347060">[-]</label><label class="expand" for="c-36347060">[1 more]</label></div><br/><div class="children"><div class="content">I think about it the other way around, actually.<p>During the prototyping phase diagrams do help, but they&#x27;re usually sketches written on paper or whiteboard. You don&#x27;t want to waste time with tools and strict specifications to design perfect diagrams, mostly because the design will change frequently, and you don&#x27;t want your tools getting in the way.<p>Later on, once the design has settled down and maybe once development has started, those initial diagrams are mostly worthless, but you _do_ want neat and professionally done design documents that describe the system. This allows you to share them with coworkers, and quickly onboard other developers to the project. Hopefully by then the design won&#x27;t change frequently, which would make updating these a chore.</div><br/></div></div></div></div><div id="36345374" class="c"><input type="checkbox" id="c-36345374" checked=""/><div class="controls bullet"><span class="by">lesuorac</span><span>|</span><a href="#36343997">parent</a><span>|</span><a href="#36346297">prev</a><span>|</span><a href="#36347180">next</a><span>|</span><label class="collapse" for="c-36345374">[-]</label><label class="expand" for="c-36345374">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The only reason the other diagram types fell out of favor is because of the development methodology change starting in the early 2000s. The industry started rejecting Waterfall, early design and system architects, in favor of Agile, just-in-time design and empowering developers.<p>I dunno, whenever I heard people say they&#x27;re doing Agile all I see is them doing Waterfall without documentation.</div><br/><div id="36349462" class="c"><input type="checkbox" id="c-36349462" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36345374">parent</a><span>|</span><a href="#36347180">next</a><span>|</span><label class="collapse" for="c-36349462">[-]</label><label class="expand" for="c-36349462">[3 more]</label></div><br/><div class="children"><div class="content">How is that worse than waterfall with outdated documentation which is what we had before.</div><br/><div id="36352579" class="c"><input type="checkbox" id="c-36352579" checked=""/><div class="controls bullet"><span class="by">sfn42</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36349462">parent</a><span>|</span><a href="#36347180">next</a><span>|</span><label class="collapse" for="c-36352579">[-]</label><label class="expand" for="c-36352579">[2 more]</label></div><br/><div class="children"><div class="content">&quot;we are lazy assholes who can&#x27;t keep docs up to date, therefore docs are useless&quot;<p>Is essentially the argument i see over and over again. And every time i start a new project and that project has docs or uml or whatever I appreciate it. Even if it is a bit out of date, it&#x27;s way better than nothing.<p>In my opinion, every project should have a readme file with instructions for running the project locally, and ideally also a high level visual representation of the system.<p>It should be separated into sub systems&#x2F;modules for separate functionality and each module could have it&#x27;s own set of readme and high level visuals. In addition, modules should have small coupling points, typically interfaces and these should have documentation comments describing what they do, inputs, outputs etc. APIs should have something like a swagger doc.</div><br/><div id="36353362" class="c"><input type="checkbox" id="c-36353362" checked=""/><div class="controls bullet"><span class="by">hitchstory</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36352579">parent</a><span>|</span><a href="#36347180">next</a><span>|</span><label class="collapse" for="c-36353362">[-]</label><label class="expand" for="c-36353362">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not a question of laziness. People just need to use better tools to generate docs and fail CI if the implementation and docs diverge.<p>I used to hear people say the same thing about laziness about code style before reformatting&#x2F;linting tools became standard.</div><br/></div></div></div></div></div></div></div></div><div id="36347180" class="c"><input type="checkbox" id="c-36347180" checked=""/><div class="controls bullet"><span class="by">codalan</span><span>|</span><a href="#36343997">parent</a><span>|</span><a href="#36345374">prev</a><span>|</span><a href="#36344851">next</a><span>|</span><label class="collapse" for="c-36347180">[-]</label><label class="expand" for="c-36347180">[1 more]</label></div><br/><div class="children"><div class="content">UML was (and still is) really useful when embarking on a greenfield design. Most people I&#x27;ve worked with know some basic UML notation, so when it comes to whiteboarding and refining the design, it makes sense to go with that.<p>In terms of artifacts for future maintainers? Maybe not as helpful. As previous posters have mentioned, the diagrams go stale very quickly if the engineering department isn&#x27;t disciplined about keeping documentation up to date. But this is true for any documentation.<p>Some diagrams (class and activity, in particular) are less valuable as time passes. I can get the idea of the class structure by just looking at the code itself. The class diagram just ends up being a stale representation of the code.<p>It is unfortunate that UML has developed a reputation as being overly complex. Now I see more ad-hoc diagrams being created, with whatever notation&#x2F;symbols make sense to author, rather than using a common diagram system that can be read by many.</div><br/></div></div><div id="36344851" class="c"><input type="checkbox" id="c-36344851" checked=""/><div class="controls bullet"><span class="by">Kwpolska</span><span>|</span><a href="#36343997">parent</a><span>|</span><a href="#36347180">prev</a><span>|</span><a href="#36350001">next</a><span>|</span><label class="collapse" for="c-36344851">[-]</label><label class="expand" for="c-36344851">[8 more]</label></div><br/><div class="children"><div class="content">Class diagrams feel pointless to me, this information works better as code, and how do you draw a class diagram with more than 10 classes and keep it readable?</div><br/><div id="36345031" class="c"><input type="checkbox" id="c-36345031" checked=""/><div class="controls bullet"><span class="by">johannes1234321</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36344851">parent</a><span>|</span><a href="#36344945">next</a><span>|</span><label class="collapse" for="c-36345031">[-]</label><label class="expand" for="c-36345031">[1 more]</label></div><br/><div class="children"><div class="content">If you use class diagrams to show the &quot;truth&quot; you are in painland in my experience.<p>However I sometimes find them useful to extract key parts of the system and showing their interaction. Cutting away many attributes, many helper classes, many other things.<p>That can lead to pictures which are quick to grasp and then allow further digging based on code.</div><br/></div></div><div id="36344945" class="c"><input type="checkbox" id="c-36344945" checked=""/><div class="controls bullet"><span class="by">prepend</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36344851">parent</a><span>|</span><a href="#36345031">prev</a><span>|</span><a href="#36345084">next</a><span>|</span><label class="collapse" for="c-36344945">[-]</label><label class="expand" for="c-36344945">[1 more]</label></div><br/><div class="children"><div class="content">I think class diagrams are a good way to visually display classes and hierarchy. If I have a package or module that has 10 classes and I want to show inheritance, properties, and methods I think it’s easier to show the class diagram then hand someone 10+ source files.<p>Also, class diagrams are more useful when you can’t give out source.<p>That being said, I think you can autogenerate class diagrams from code so it’s not like you should spend a lot of time making them.</div><br/></div></div><div id="36345084" class="c"><input type="checkbox" id="c-36345084" checked=""/><div class="controls bullet"><span class="by">holoduke</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36344851">parent</a><span>|</span><a href="#36344945">prev</a><span>|</span><a href="#36350001">next</a><span>|</span><label class="collapse" for="c-36345084">[-]</label><label class="expand" for="c-36345084">[5 more]</label></div><br/><div class="children"><div class="content">Maybe before you actually start writing code its nice to create some domain diagrams which you can convert to class diagrams. Saves a ton of time. And you have good discussions about the general high level workings of an architecture. Can be done on a whiteboard. Make some pics and start coding.</div><br/><div id="36345211" class="c"><input type="checkbox" id="c-36345211" checked=""/><div class="controls bullet"><span class="by">radicalbyte</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36345084">parent</a><span>|</span><a href="#36350001">next</a><span>|</span><label class="collapse" for="c-36345211">[-]</label><label class="expand" for="c-36345211">[4 more]</label></div><br/><div class="children"><div class="content">Assuming that you&#x27;re using a modern IDE: it is an order of magnitude quicker to model the domain (classes + attributes) in code and project them as diagrams, say with graphvis.<p>High level boxes are great for thinking about systems but the key there is abstraction - minimal viable level of detail..</div><br/><div id="36352127" class="c"><input type="checkbox" id="c-36352127" checked=""/><div class="controls bullet"><span class="by">TuringTest</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36345211">parent</a><span>|</span><a href="#36352505">next</a><span>|</span><label class="collapse" for="c-36352127">[-]</label><label class="expand" for="c-36352127">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re creating diagrams with graphvis, you&#x27;re just coding on another language. The benefits of diagrams appear when you draw them by hand (or graphically by mouse).</div><br/></div></div><div id="36352505" class="c"><input type="checkbox" id="c-36352505" checked=""/><div class="controls bullet"><span class="by">jxramos</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36345211">parent</a><span>|</span><a href="#36352127">prev</a><span>|</span><a href="#36346854">next</a><span>|</span><label class="collapse" for="c-36352505">[-]</label><label class="expand" for="c-36352505">[1 more]</label></div><br/><div class="children"><div class="content">this phrase caught my eye, &quot;minimally viable level of detail&quot;, to which I immediately thought &quot;minimal detail for a coherent thought&quot;. That&#x27;s a cool concept actually I might hold on to and develop.</div><br/></div></div><div id="36346854" class="c"><input type="checkbox" id="c-36346854" checked=""/><div class="controls bullet"><span class="by">holoduke</span><span>|</span><a href="#36343997">root</a><span>|</span><a href="#36345211">parent</a><span>|</span><a href="#36352505">prev</a><span>|</span><a href="#36350001">next</a><span>|</span><label class="collapse" for="c-36346854">[-]</label><label class="expand" for="c-36346854">[1 more]</label></div><br/><div class="children"><div class="content">Dont you want to discuss and talk about a design before you even touch a keyboard? In my projects we always discus high level overviews with pen and whiteboards. Nobody should even dare to touch a keyboard.</div><br/></div></div></div></div></div></div></div></div><div id="36350001" class="c"><input type="checkbox" id="c-36350001" checked=""/><div class="controls bullet"><span class="by">jameshart</span><span>|</span><a href="#36343997">parent</a><span>|</span><a href="#36344851">prev</a><span>|</span><a href="#36351145">next</a><span>|</span><label class="collapse" for="c-36350001">[-]</label><label class="expand" for="c-36350001">[1 more]</label></div><br/><div class="children"><div class="content">Sequence diagrams are <i>the only bit of UML that also applies to distributed systems</i>. And everything today is a distributed system.</div><br/></div></div><div id="36351145" class="c"><input type="checkbox" id="c-36351145" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#36343997">parent</a><span>|</span><a href="#36350001">prev</a><span>|</span><a href="#36343389">next</a><span>|</span><label class="collapse" for="c-36351145">[-]</label><label class="expand" for="c-36351145">[1 more]</label></div><br/><div class="children"><div class="content">to me seq diagrams are .. too sequential, my brain needs a protocol &#x2F; graph proof like formalism to see things more globally.</div><br/></div></div></div></div><div id="36343389" class="c"><input type="checkbox" id="c-36343389" checked=""/><div class="controls bullet"><span class="by">Dig1t</span><span>|</span><a href="#36343997">prev</a><span>|</span><a href="#36346262">next</a><span>|</span><label class="collapse" for="c-36343389">[-]</label><label class="expand" for="c-36343389">[41 more]</label></div><br/><div class="children"><div class="content">Spot on, I agree that sequence diagrams are super useful, I see them used all the time in FAANG.<p>I do really wonder why UML is still taught in universities, as the article states, it&#x27;s pretty useless. I took a masters Software Engineering course at Georgia Tech two years ago and a big part of the class was learning UML. That time was mostly wasted as I&#x27;ve never used any of it and never met anyone who has used it.<p>It wasn&#x27;t my first time learning it either, we also had a section on it in my undergrad software engineering course. So I learned the same useless stuff twice.</div><br/><div id="36343491" class="c"><input type="checkbox" id="c-36343491" checked=""/><div class="controls bullet"><span class="by">civilized</span><span>|</span><a href="#36343389">parent</a><span>|</span><a href="#36344020">next</a><span>|</span><label class="collapse" for="c-36343491">[-]</label><label class="expand" for="c-36343491">[10 more]</label></div><br/><div class="children"><div class="content">Why the university teaches outdated useless stuff? My guesses:<p>- For the university, it fills out offerings and takes up credit hours, keeps the tuition dollars flowing<p>- For the teacher, it&#x27;s something they already know how to teach, so it doesn&#x27;t require nearly as much effort to teach as something more useful but maybe less familiar<p>- Universities are trusted with the decisions of what to teach and don&#x27;t face much short-term accountability, so there&#x27;s no real downside to teaching a useless course for another year<p>- They probably don&#x27;t know it&#x27;s useless. (They also don&#x27;t care to find out because of the aforementioned points)</div><br/><div id="36343887" class="c"><input type="checkbox" id="c-36343887" checked=""/><div class="controls bullet"><span class="by">comfypotato</span><span>|</span><a href="#36343389">root</a><span>|</span><a href="#36343491">parent</a><span>|</span><a href="#36344254">next</a><span>|</span><label class="collapse" for="c-36343887">[-]</label><label class="expand" for="c-36343887">[1 more]</label></div><br/><div class="children"><div class="content">My graduate program did not teach UML, but I did learn it during my undergrad program. It was a relatively small part of the major software engineering course. It introduced the idea of formally specifying software, and it forced me to reestablish, visualize, and otherwise integrate what I was simultaneously learning about things like interfaces and inheritance. It was presented as an educational tool and not at all that we would be using it in industry. Far from useless or out of date in an educational context.</div><br/></div></div><div id="36344254" class="c"><input type="checkbox" id="c-36344254" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#36343389">root</a><span>|</span><a href="#36343491">parent</a><span>|</span><a href="#36343887">prev</a><span>|</span><a href="#36343847">next</a><span>|</span><label class="collapse" for="c-36344254">[-]</label><label class="expand" for="c-36344254">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a bureaucratic reason too. Changing curricula is not fast and can take years (depending on the institution of course).<p>My department profs actually got in a bit of trouble with the university because they took the course that they should use for undergrad&#x2F;graduate mentoring (something like a &quot;special studies in XXX&quot; placeholder, usually for independent or small group study that was special enough for course credit) and used it to create their own courses outside the review of approving a new course with a distinct number and credit count.<p>The reason they did it in the first place was because if they wanted to change the curricula for the existing courses, remove course numbers, or create new ones, the bureaucracy would take 4-8 semesters to get approval and complete. By which time some of the material was obsolete. One of the profs got fired and the rest quit, eventually.</div><br/></div></div><div id="36343847" class="c"><input type="checkbox" id="c-36343847" checked=""/><div class="controls bullet"><span class="by">ryanisnan</span><span>|</span><a href="#36343389">root</a><span>|</span><a href="#36343491">parent</a><span>|</span><a href="#36344254">prev</a><span>|</span><a href="#36344565">next</a><span>|</span><label class="collapse" for="c-36343847">[-]</label><label class="expand" for="c-36343847">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d offer another, possible reason:<p>- University professors who remain exclusively in academia missed the rising tide and teach what they know</div><br/></div></div><div id="36344565" class="c"><input type="checkbox" id="c-36344565" checked=""/><div class="controls bullet"><span class="by">TheCondor</span><span>|</span><a href="#36343389">root</a><span>|</span><a href="#36343491">parent</a><span>|</span><a href="#36343847">prev</a><span>|</span><a href="#36347989">next</a><span>|</span><label class="collapse" for="c-36344565">[-]</label><label class="expand" for="c-36344565">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Useless&quot; is a strong word.   Definitely a bit less useful than intended though.<p>Before UML, it&#x27;s hard to capture the state of corporate software development that allowed the insanity to take part.   I mean, UML was the marriage of two different approaches to drawing object models that were locked in a battle: OMT and Booch method.  There weren&#x27;t tons of open forums for discussion and debate like the internet has now, there were conferences and such and these guys were basically trying to create formal methods for objects in a vacuum.<p>It was kind of existential stuff for a lot of the smaller players in the industry, everyone saw value in this newer approach to building software. &quot;Reusable components&quot; seemed huge.  Tooling was expensive, training was expensive.  Microsoft was moving as a scary rate,  connect your cart to the wrong horse and it could cost you the company...  On some of the usenet forums, about the most open discussion there was at the time, I read debates about the virtue of C++ style multiple inheritance vs single inheritance and there were product matrices for programming tools that had check boxes for crap like that.   C++ and CLOS both supported multiple inheritance so to the casual observer they were &quot;better.&quot;   Now I&#x27;ve never seen serious industrial software written in CLOS or anyone even considering it but it &quot;had the features.&quot;  It was just a different and crazy time,  kind of amazing how open source&#x2F;free&#x2F;libre has altered things, the entire culture of building software is different and probably more healthy.<p>Anyone want to shit on design patterns next?</div><br/></div></div><div id="36347989" class="c"><input type="checkbox" id="c-36347989" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#36343389">root</a><span>|</span><a href="#36343491">parent</a><span>|</span><a href="#36344565">prev</a><span>|</span><a href="#36344220">next</a><span>|</span><label class="collapse" for="c-36347989">[-]</label><label class="expand" for="c-36347989">[1 more]</label></div><br/><div class="children"><div class="content">I’m on the advisory board of my school’s comp sci department. Each of us advisors has our own experience and perspectives on what useful things the students should learn. Sometimes I’m arguing that no, they probably don’t need to learn RPG, just because that’s what one of my colleagues sees a lot in their branch of industry. In turn, they argue that some of my recommendations are more useful at SF tech startups than in long-term positions in the companies local to the school.<p>Without those various perspectives, you end up with students learning all kinds of goofy things just because no one said, nah, they’re probably not going to need that.</div><br/></div></div><div id="36344220" class="c"><input type="checkbox" id="c-36344220" checked=""/><div class="controls bullet"><span class="by">hollander</span><span>|</span><a href="#36343389">root</a><span>|</span><a href="#36343491">parent</a><span>|</span><a href="#36347989">prev</a><span>|</span><a href="#36344349">next</a><span>|</span><label class="collapse" for="c-36344220">[-]</label><label class="expand" for="c-36344220">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t UML about conceptual thinking first, before you loose yourself in editing?</div><br/><div id="36345951" class="c"><input type="checkbox" id="c-36345951" checked=""/><div class="controls bullet"><span class="by">petsfed</span><span>|</span><a href="#36343389">root</a><span>|</span><a href="#36344220">parent</a><span>|</span><a href="#36344349">next</a><span>|</span><label class="collapse" for="c-36345951">[-]</label><label class="expand" for="c-36345951">[1 more]</label></div><br/><div class="children"><div class="content">That was my take on it. How do you get students to practice the process of thinking conceptually first, then evaluate how thorough the planning is, without some tool like UML? Its one thing to lecture your students on the necessity of planning ahead. Its quite another to evaluate whether or not they know how to plan ahead.<p>Granted, UML is not used hardly anywhere, but I must&#x27;ve learned 30 different specific software tools in college that I never used outside of college. However, I&#x27;ve used <i>something like</i> each one of them. I took a technical drawing class in high school and I still use some of the techniques I learned in that, even though absolutely no one uses t-squares, triangles, and <i>actual paper</i> in modern technical drawing today.<p>There&#x27;s a fair argument re: how much planning and conceptualizing should be done ahead of starting the Agile process, and also a fair argument re: what that planning should look like (crude flowchart? UML-compliant class diagram?). But in rejecting the UML <i>tool</i>, are we rejecting also the idea of advanced planning too? Like, how completely do you need to reject advance planning that it takes the Agile loop to reveal that the customer actually needs software that uses an observer pattern?</div><br/></div></div></div></div><div id="36344349" class="c"><input type="checkbox" id="c-36344349" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#36343389">root</a><span>|</span><a href="#36343491">parent</a><span>|</span><a href="#36344220">prev</a><span>|</span><a href="#36344020">next</a><span>|</span><label class="collapse" for="c-36344349">[-]</label><label class="expand" for="c-36344349">[1 more]</label></div><br/><div class="children"><div class="content">It exists, you will see it, and when that happens you will be expected to understand what is there.<p>So it is well worth 1 hour or 2 to look at it.</div><br/></div></div></div></div><div id="36344020" class="c"><input type="checkbox" id="c-36344020" checked=""/><div class="controls bullet"><span class="by">ivan_gammel</span><span>|</span><a href="#36343389">parent</a><span>|</span><a href="#36343491">prev</a><span>|</span><a href="#36344803">next</a><span>|</span><label class="collapse" for="c-36344020">[-]</label><label class="expand" for="c-36344020">[18 more]</label></div><br/><div class="children"><div class="content">Every software engineering team in my 20+ years career actually used 2-5 types of UML diagrams: classes, sequences, deployment, activity, state. I think it mostly depends on maturity of the team and engineering culture, whether UML is used or not. There’s certainly some value in it.</div><br/><div id="36344324" class="c"><input type="checkbox" id="c-36344324" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#36343389">root</a><span>|</span><a href="#36344020">parent</a><span>|</span><a href="#36344164">next</a><span>|</span><label class="collapse" for="c-36344324">[-]</label><label class="expand" for="c-36344324">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think I have ever seen anybody actually getting value from a class diagram. I have seen many people creating them, but they are always useless.<p>I also don&#x27;t think the UML variant of state machines and workflow are any popular. But well, there is probably somewhere where people use them. Also, those lists usually ignore entity-relationship diagrams, where UML just adopted the popular format (without even minor changes, like for workflows), and thus everybody uses the UML one.<p>But yes, people don&#x27;t remember about deployment diagrams. Those are used a lot.</div><br/><div id="36347745" class="c"><input type="checkbox" id="c-36347745" checked=""/><div class="controls bullet"><span class="by">ivan_gammel</span><span>|</span><a href="#36343389">root</a><span>|</span><a href="#36344324">parent</a><span>|</span><a href="#36344445">next</a><span>|</span><label class="collapse" for="c-36347745">[-]</label><label class="expand" for="c-36347745">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I have seen many people creating them, but they are always useless.<p>Not every artifact is worth keeping, instead the value can come from the process of creation as a way to structure your thoughts or to explain or brainstorm possible solution.
The value of class diagrams for those people is in the moment and it’s ok to throw them away later if they <i>become</i> useless.</div><br/></div></div><div id="36344445" class="c"><input type="checkbox" id="c-36344445" checked=""/><div class="controls bullet"><span class="by">francois14</span><span>|</span><a href="#36343389">root</a><span>|</span><a href="#36344324">parent</a><span>|</span><a href="#36347745">prev</a><span>|</span><a href="#36344164">next</a><span>|</span><label class="collapse" for="c-36344445">[-]</label><label class="expand" for="c-36344445">[2 more]</label></div><br/><div class="children"><div class="content">Class diagrams are a good way to detect circular dependencies.</div><br/><div id="36344999" class="c"><input type="checkbox" id="c-36344999" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#36343389">root</a><span>|</span><a href="#36344445">parent</a><span>|</span><a href="#36344164">next</a><span>|</span><label class="collapse" for="c-36344999">[-]</label><label class="expand" for="c-36344999">[1 more]</label></div><br/><div class="children"><div class="content">If your class diagram is comprehensive enough to get circular dependencies, then I&#x27;m completely sure¹ nobody will use them for anything.<p>Computers are much better at this kind of checks anyway, and they don&#x27;t need diagrams.<p>1 - Instead of &quot;well, maybe it&#x27;s possible despite I never seeing it&quot;</div><br/></div></div></div></div></div></div><div id="36344164" class="c"><input type="checkbox" id="c-36344164" checked=""/><div class="controls bullet"><span class="by">feoren</span><span>|</span><a href="#36343389">root</a><span>|</span><a href="#36344020">parent</a><span>|</span><a href="#36344324">prev</a><span>|</span><a href="#36344126">next</a><span>|</span><label class="collapse" for="c-36344164">[-]</label><label class="expand" for="c-36344164">[8 more]</label></div><br/><div class="children"><div class="content">&gt; I think it mostly depends on maturity of the team and engineering culture, whether UML is used or not.<p>I suspect that&#x27;s true: teams with a very immature engineering culture probably do use a lot more UML. It&#x27;s a good way to feel like you&#x27;re doing something useful instead of actually doing the hard part. Mature teams write code.</div><br/><div id="36347555" class="c"><input type="checkbox" id="c-36347555" checked=""/><div class="controls bullet"><span class="by">ivan_gammel</span><span>|</span><a href="#36343389">root</a><span>|</span><a href="#36344164">parent</a><span>|</span><a href="#36345011">next</a><span>|</span><label class="collapse" for="c-36347555">[-]</label><label class="expand" for="c-36347555">[5 more]</label></div><br/><div class="children"><div class="content">Part of engineering culture in general, not just software engineering, is ability to share knowledge though documentation and best practices. If you share the source code, you communicate your solution on a very low level.  It is often necessary to zoom out to see the big picture and there visualization helps. You can create ad-hoc diagrams, but their expressive power is low: without a convention it’s basically just space, text, arrows and generic shapes. To increase the expressive power you need a visual language in which different shapes and lines have some semantics. And here comes UML and other diagram languages. If you are not using them, it is likely that you are not communicating efficiently. Can a mature team fail at communication? I leave the answer to you.</div><br/><div id="36349500" class="c"><input type="checkbox" id="c-36349500" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#36343389">root</a><span>|</span><a href="#36347555">parent</a><span>|</span><a href="#36345011">next</a><span>|</span><label class="collapse" for="c-36349500">[-]</label><label class="expand" for="c-36349500">[4 more]</label></div><br/><div class="children"><div class="content">UML didn&#x27;t help though because it is never kept up to date with what the code really is</div><br/><div id="36350200" class="c"><input type="checkbox" id="c-36350200" checked=""/><div class="controls bullet"><span class="by">ivan_gammel</span><span>|</span><a href="#36343389">root</a><span>|</span><a href="#36349500">parent</a><span>|</span><a href="#36345011">next</a><span>|</span><label class="collapse" for="c-36350200">[-]</label><label class="expand" for="c-36350200">[3 more]</label></div><br/><div class="children"><div class="content">How was it supposed to keep up? The most popular programming languages did not introduce concepts that are too hard to reflect with UML.
Or do you mean the problem of maintaining documentation?</div><br/><div id="36351246" class="c"><input type="checkbox" id="c-36351246" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#36343389">root</a><span>|</span><a href="#36350200">parent</a><span>|</span><a href="#36345011">next</a><span>|</span><label class="collapse" for="c-36351246">[-]</label><label class="expand" for="c-36351246">[2 more]</label></div><br/><div class="children"><div class="content">Maintaining documentation. UML cannot go even one developer-week without being updated, but the developer will often not do that. By the time your UML is a month out of date it is useless at best, and misleading at worst.</div><br/><div id="36353136" class="c"><input type="checkbox" id="c-36353136" checked=""/><div class="controls bullet"><span class="by">ivan_gammel</span><span>|</span><a href="#36343389">root</a><span>|</span><a href="#36351246">parent</a><span>|</span><a href="#36345011">next</a><span>|</span><label class="collapse" for="c-36353136">[-]</label><label class="expand" for="c-36353136">[1 more]</label></div><br/><div class="children"><div class="content">This has nothing to do with UML. Ad-hoc diagrams or plain text descriptions become outdated at the same speed, which depends only on the level of detail that you put in documentation and not on the format if it. If you cannot keep up with the changes in the code, you are choosing the wrong level of detail, that’s it.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36345011" class="c"><input type="checkbox" id="c-36345011" checked=""/><div class="controls bullet"><span class="by">prepend</span><span>|</span><a href="#36343389">root</a><span>|</span><a href="#36344164">parent</a><span>|</span><a href="#36347555">prev</a><span>|</span><a href="#36346444">next</a><span>|</span><label class="collapse" for="c-36345011">[-]</label><label class="expand" for="c-36345011">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Mature teams write code.<p>Sounds very Dunning-Krugerish “smart people like me do X and not smart people do Y”<p>Coding and documenting aren’t exclusive. Modeling is part of documenting. UML is a type of modeling.<p>I would think effective teams will want to build good software. And to build good software they’ll want to capture requirements, communicate with other teams, and test their software. Design helps with this and is part of coding.<p>At the end of a successful day, I should have some updated models, some code, and some running software. If someone wants to see what I did, they’d likely read through different parts.<p>Just like trying to figure out a stage by just reading models sucks, so does trying to figure it out by just running the software.</div><br/></div></div><div id="36346444" class="c"><input type="checkbox" id="c-36346444" checked=""/><div class="controls bullet"><span class="by">ableeb</span><span>|</span><a href="#36343389">root</a><span>|</span><a href="#36344164">parent</a><span>|</span><a href="#36345011">prev</a><span>|</span><a href="#36344126">next</a><span>|</span><label class="collapse" for="c-36346444">[-]</label><label class="expand" for="c-36346444">[1 more]</label></div><br/><div class="children"><div class="content">Mature teams document their code</div><br/></div></div></div></div><div id="36344126" class="c"><input type="checkbox" id="c-36344126" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#36343389">root</a><span>|</span><a href="#36344020">parent</a><span>|</span><a href="#36344164">prev</a><span>|</span><a href="#36344237">next</a><span>|</span><label class="collapse" for="c-36344126">[-]</label><label class="expand" for="c-36344126">[3 more]</label></div><br/><div class="children"><div class="content">With the odd caveat that you probably use sketches of these diagrams?  As soon as you are trying to cram in all of the extra details stuff like class diagrams can do, you are probably wasting time.</div><br/><div id="36347665" class="c"><input type="checkbox" id="c-36347665" checked=""/><div class="controls bullet"><span class="by">ivan_gammel</span><span>|</span><a href="#36343389">root</a><span>|</span><a href="#36344126">parent</a><span>|</span><a href="#36344237">next</a><span>|</span><label class="collapse" for="c-36347665">[-]</label><label class="expand" for="c-36347665">[2 more]</label></div><br/><div class="children"><div class="content">I do not understand your question. If I do not deviate from convention but omit unimportant details, is it a sketch for you?<p>If you have a project document template from PMBoK, do you feel obliged to fill all the sections or you document only information relevant to your project? With UML it’s the same: it offers a lot, but you do not have to use everything to produce a conforming diagram.</div><br/><div id="36347829" class="c"><input type="checkbox" id="c-36347829" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#36343389">root</a><span>|</span><a href="#36347665">parent</a><span>|</span><a href="#36344237">next</a><span>|</span><label class="collapse" for="c-36347829">[-]</label><label class="expand" for="c-36347829">[1 more]</label></div><br/><div class="children"><div class="content">It it a sketch if you don&#x27;t include every detail that UML was specifically designed to convey?  Yeah?  Noting that a sketch is not a derogatory phrase here.<p>Note that, for many of these diagrams, they existed before UML.  It was an attempt to formalize them.  In classes, they are often used as code generation tools in an attempt to keep a 1:1 between document and code.  Laudable, but I have yet to see that work out well.<p>To your point, I think, the same ultimately goes for document templates.  Way too many are used prescriptively as a way to make a successful project.  Much to the chagrin of the document writer when the project fails.  Often miserably.  To the point that I&#x27;m convinced most accurate project documents are after the fact.  Certainly not waterfall to the project that they are describing.</div><br/></div></div></div></div></div></div><div id="36344066" class="c"><input type="checkbox" id="c-36344066" checked=""/><div class="controls bullet"><span class="by">pydry</span><span>|</span><a href="#36343389">root</a><span>|</span><a href="#36344020">parent</a><span>|</span><a href="#36344237">prev</a><span>|</span><a href="#36344803">next</a><span>|</span><label class="collapse" for="c-36344066">[-]</label><label class="expand" for="c-36344066">[1 more]</label></div><br/><div class="children"><div class="content">&gt;I think it mostly depends on maturity of the team<p>yep. kids out of college feel most inclined to use it.</div><br/></div></div></div></div><div id="36344803" class="c"><input type="checkbox" id="c-36344803" checked=""/><div class="controls bullet"><span class="by">poulsbohemian</span><span>|</span><a href="#36343389">parent</a><span>|</span><a href="#36344020">prev</a><span>|</span><a href="#36343530">next</a><span>|</span><label class="collapse" for="c-36344803">[-]</label><label class="expand" for="c-36344803">[2 more]</label></div><br/><div class="children"><div class="content">&gt;That time was mostly wasted as I&#x27;ve never used any of it and never met anyone who has used it.<p>So here&#x27;s the conflict: if we agree that planning is good, communication is good, and that it is faster &#x2F; cheaper to design before we build rather than rushing in to build something, then is it not a good idea to have something <i>like</i> UML in our tool kit? Perhaps UML was too complicated or overbearing, but I&#x27;ve always felt like a <i>universal</i> tool to describe aspects of the software we are building is fundamentally a good concept. Further, it feels like the right idea to document &#x2F; designing up front in a way that increases buy-in and communicates what we are doing.<p>So if not UML, then what?</div><br/><div id="36349535" class="c"><input type="checkbox" id="c-36349535" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#36343389">root</a><span>|</span><a href="#36344803">parent</a><span>|</span><a href="#36343530">next</a><span>|</span><label class="collapse" for="c-36349535">[-]</label><label class="expand" for="c-36349535">[1 more]</label></div><br/><div class="children"><div class="content">UML doesn&#x27;t give me anything over random boxes on a whiteboard that are non standard, so long as the others understand them.</div><br/></div></div></div></div><div id="36343530" class="c"><input type="checkbox" id="c-36343530" checked=""/><div class="controls bullet"><span class="by">gautamdivgi</span><span>|</span><a href="#36343389">parent</a><span>|</span><a href="#36344803">prev</a><span>|</span><a href="#36344362">next</a><span>|</span><label class="collapse" for="c-36343530">[-]</label><label class="expand" for="c-36343530">[1 more]</label></div><br/><div class="children"><div class="content">Activity diagrams do a decent job too. But yes, sequence and activity diagrams are all I have used.</div><br/></div></div><div id="36344362" class="c"><input type="checkbox" id="c-36344362" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#36343389">parent</a><span>|</span><a href="#36343530">prev</a><span>|</span><a href="#36346936">next</a><span>|</span><label class="collapse" for="c-36344362">[-]</label><label class="expand" for="c-36344362">[1 more]</label></div><br/><div class="children"><div class="content">It would be useful if everyone would at least be vaguely familiar with basic UML notation, i.e. action vs. object, multiplicity, connectors (association vs. composition vs. dependency vs. specialization, interface&#x2F;implementation), class vs. instance, fork&#x2F;join, swimlanes, etc. Otherwise you have to clarify over and over what means what in a diagram.<p>One powerful aspect of UML is that you can combine different diagram types. For example, you can use activity-diagram elements in parts of a sequence diagram.<p>For pragmatic use, “UML Distilled” [0] by Martin Fowler is a good introduction and reference.<p>[0] <a href="https:&#x2F;&#x2F;martinfowler.com&#x2F;books&#x2F;uml.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;martinfowler.com&#x2F;books&#x2F;uml.html</a></div><br/></div></div><div id="36346936" class="c"><input type="checkbox" id="c-36346936" checked=""/><div class="controls bullet"><span class="by">esfandia</span><span>|</span><a href="#36343389">parent</a><span>|</span><a href="#36344362">prev</a><span>|</span><a href="#36343613">next</a><span>|</span><label class="collapse" for="c-36346936">[-]</label><label class="expand" for="c-36346936">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s certainly given too much importance in the curriculum, but the idea of having a common language (with standard semantics) for sharing design decisions is valuable.<p>I&#x27;d argue the issue is that because UML is not seen as valuable, everyone improvises their own dialect when drawing stuff, and so since nobody trusts people following correct diagram semantics (e.g., meaning of different arrow shapes), nobody trusts the resulting diagrams either, further reinforcing the notion that it&#x27;s useless.</div><br/></div></div><div id="36343613" class="c"><input type="checkbox" id="c-36343613" checked=""/><div class="controls bullet"><span class="by">giobox</span><span>|</span><a href="#36343389">parent</a><span>|</span><a href="#36346936">prev</a><span>|</span><a href="#36345888">next</a><span>|</span><label class="collapse" for="c-36343613">[-]</label><label class="expand" for="c-36343613">[1 more]</label></div><br/><div class="children"><div class="content">Sequence diagrams aside (they are useful!), I also felt far too much time was wasted on UML in my university course. The only small argument I can see in favor is perhaps to encourage some thinking and discussion around software design among students in an educational context, even if I&#x27;ve never once seen it used in industry. I can&#x27;t say I&#x27;d miss it&#x27;s removal all that much either though.</div><br/></div></div><div id="36345888" class="c"><input type="checkbox" id="c-36345888" checked=""/><div class="controls bullet"><span class="by">ignite</span><span>|</span><a href="#36343389">parent</a><span>|</span><a href="#36343613">prev</a><span>|</span><a href="#36343712">next</a><span>|</span><label class="collapse" for="c-36345888">[-]</label><label class="expand" for="c-36345888">[1 more]</label></div><br/><div class="children"><div class="content">I have an undergrad friend. Learning this last semester. It&#x27;s still taught, and it&#x27;s still not used.</div><br/></div></div><div id="36343712" class="c"><input type="checkbox" id="c-36343712" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#36343389">parent</a><span>|</span><a href="#36345888">prev</a><span>|</span><a href="#36343484">next</a><span>|</span><label class="collapse" for="c-36343712">[-]</label><label class="expand" for="c-36343712">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I see them used all the time in FAANG.<p>Does that mean something? Besides you saying you worked in them? It’s a question ; I don’t know.</div><br/><div id="36344260" class="c"><input type="checkbox" id="c-36344260" checked=""/><div class="controls bullet"><span class="by">Dig1t</span><span>|</span><a href="#36343389">root</a><span>|</span><a href="#36343712">parent</a><span>|</span><a href="#36344219">next</a><span>|</span><label class="collapse" for="c-36344260">[-]</label><label class="expand" for="c-36344260">[2 more]</label></div><br/><div class="children"><div class="content">It is shorthand for saying that it is used by engineers working on high-profile, high-impact, software that ships to hundreds of millions of people. Some people might argue that these teams work on some of the most important software in the world. So if the people who work on this important software do a thing, like use sequence diagrams, that is a decently good signal that the thing is useful.</div><br/><div id="36345353" class="c"><input type="checkbox" id="c-36345353" checked=""/><div class="controls bullet"><span class="by">musha68k</span><span>|</span><a href="#36343389">root</a><span>|</span><a href="#36344260">parent</a><span>|</span><a href="#36344219">next</a><span>|</span><label class="collapse" for="c-36345353">[-]</label><label class="expand" for="c-36345353">[1 more]</label></div><br/><div class="children"><div class="content">Also used a lot in automotive software development processes for example. Basically, the more safety critical a system is the more formal diagramming &#x2F; modelling there will be part of the design and development process. It’s important to be able to reason about complexities of such systems across a team &#x2F; teams.</div><br/></div></div></div></div></div></div><div id="36343484" class="c"><input type="checkbox" id="c-36343484" checked=""/><div class="controls bullet"><span class="by">knsv</span><span>|</span><a href="#36343389">parent</a><span>|</span><a href="#36343712">prev</a><span>|</span><a href="#36346262">next</a><span>|</span><label class="collapse" for="c-36343484">[-]</label><label class="expand" for="c-36343484">[1 more]</label></div><br/><div class="children"><div class="content">Was it easier the second time around? :)</div><br/></div></div></div></div><div id="36346262" class="c"><input type="checkbox" id="c-36346262" checked=""/><div class="controls bullet"><span class="by">dahwolf</span><span>|</span><a href="#36343389">prev</a><span>|</span><a href="#36344420">next</a><span>|</span><label class="collapse" for="c-36346262">[-]</label><label class="expand" for="c-36346262">[64 more]</label></div><br/><div class="children"><div class="content">In some ways, software development practices have degraded since that era. It largely has to do with the need for speed which comes at the expense of careful consideration, quality, integrity and the formal standards that support it.<p>In fact, I believe it pretty much killed the profession of software architect. Many teams had it as a dedicated role, and this indeed would be a person documenting&#x2F;designing systems using UML or otherwise. And they&#x27;d know the classics, like memorizing all design patterns. Finally, they&#x27;d use formalized architectural decision making methodologies to justify tech choices.<p>Nobody seems to do anything like that anymore. Everybody is half-assing design or skipping it entirely. Solutions are reinvented and tech choices made on a whim by the loudest person whom won&#x27;t see the consequences of it anyway. Because we&#x27;ve told ourselves that shipping garbage in short cycles is the one and only way to do things.</div><br/><div id="36346523" class="c"><input type="checkbox" id="c-36346523" checked=""/><div class="controls bullet"><span class="by">mkozlows</span><span>|</span><a href="#36346262">parent</a><span>|</span><a href="#36347069">next</a><span>|</span><label class="collapse" for="c-36346523">[-]</label><label class="expand" for="c-36346523">[15 more]</label></div><br/><div class="children"><div class="content">Yeah, hard disagree on all that. As someone who lived through that era professionally, and who has had an &quot;architect&quot; title in the past, I was actually resistant to ever stepping into that role, because I had so many bad experience with the Formal Architecture Methodology crew, who would produce the most absurd and out-of-touch designs. There&#x27;s a reason that &quot;architecture astronaut&quot; is a term from that era.<p>Lots of people make bad designs today, sure, but it&#x27;s not for a lack of formal methodologies, because average design quality was way worse back in the design patterns &#x27;n&#x27; UML days.</div><br/><div id="36350536" class="c"><input type="checkbox" id="c-36350536" checked=""/><div class="controls bullet"><span class="by">snapdaddy</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36346523">parent</a><span>|</span><a href="#36346837">next</a><span>|</span><label class="collapse" for="c-36350536">[-]</label><label class="expand" for="c-36350536">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think it was software architecture, UML or design patterns that was bad. I think the &#x27;Open-Closed Principle&#x27; is one of the worst ideas to ever gain popular acceptance.<p>For anyone who didn&#x27;t live through that time, the Open-Closed Principle states that software should be open for extension, but closed for modification.<p>However, you could also rephrase that principle to be: &#x27;you should always prematurely abstract your designs&#x27;.<p>I think if abstraction was viewed as a negative to be avoided unless necessary, software architecture would have been far better off.<p>To be fair, premature abstraction is a lot of fun for those that do it. It&#x27;s just those that follow who aren&#x27;t so keen.</div><br/><div id="36351970" class="c"><input type="checkbox" id="c-36351970" checked=""/><div class="controls bullet"><span class="by">carlmr</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36350536">parent</a><span>|</span><a href="#36350761">next</a><span>|</span><label class="collapse" for="c-36351970">[-]</label><label class="expand" for="c-36351970">[1 more]</label></div><br/><div class="children"><div class="content">This is very on point. Premature abstraction has always a struck me as way now evil than what premature optimization can create.<p>Every class has an interface abstraction, or worse inheritance hierarchy, that adds friction to change, even though it&#x27;s the only implementation.<p>When something similar comes along it&#x27;s pressed into that shape, because the abstraction is already there.<p>It&#x27;s like this meme video where it&#x27;s hard to watch all the round and triangular pieces being fit in the square hole.<p>And the problem is that while software is more flexible than traditional architecture, hence soft, the complexity limit is also soft or virtually non-existent. So in software it&#x27;s worth more to be simple and flexible than to have a plan that&#x27;s long and detailed.</div><br/></div></div><div id="36350761" class="c"><input type="checkbox" id="c-36350761" checked=""/><div class="controls bullet"><span class="by">WuxiFingerHold</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36350536">parent</a><span>|</span><a href="#36351970">prev</a><span>|</span><a href="#36346837">next</a><span>|</span><label class="collapse" for="c-36350761">[-]</label><label class="expand" for="c-36350761">[1 more]</label></div><br/><div class="children"><div class="content">That is an import perspective. I&#x27;ve always struggled to understand why (esp. in the Java enterprise world) things were so complex. It took me a while to see through it and now I create abstractions when I need them, not just in case. That&#x27;s why I don&#x27;t like things like Clean Architecture.<p>E.g. I don&#x27;t create an abstraction in case I someday need to switch the database from SQL to NoSQL, but when I need the abstraction right now for an alternative implementation (e.g. mocks for testing).</div><br/></div></div></div></div><div id="36346837" class="c"><input type="checkbox" id="c-36346837" checked=""/><div class="controls bullet"><span class="by">fmajid</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36346523">parent</a><span>|</span><a href="#36350536">prev</a><span>|</span><a href="#36351164">next</a><span>|</span><label class="collapse" for="c-36346837">[-]</label><label class="expand" for="c-36346837">[6 more]</label></div><br/><div class="children"><div class="content">Seconded. I once went to an IBM seminar with Grady Booch and seldom have I heard such an inane string of platitudes. Architecture Astronauts are the worst, and if there is one thing Agile can legitimately claim for, it&#x27;s getting us rid of that plague.</div><br/><div id="36346905" class="c"><input type="checkbox" id="c-36346905" checked=""/><div class="controls bullet"><span class="by">doctor_eval</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36346837">parent</a><span>|</span><a href="#36351164">next</a><span>|</span><label class="collapse" for="c-36346905">[-]</label><label class="expand" for="c-36346905">[5 more]</label></div><br/><div class="children"><div class="content">I agree with you both except that architects are alive and well. I worked with an ex IBM architect a couple of years ago. Lovely guy but for someone designing software systems, I found it remarkable that he didn’t know how to write code.</div><br/><div id="36349018" class="c"><input type="checkbox" id="c-36349018" checked=""/><div class="controls bullet"><span class="by">snapetom</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36346905">parent</a><span>|</span><a href="#36348582">next</a><span>|</span><label class="collapse" for="c-36349018">[-]</label><label class="expand" for="c-36349018">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;d say this is a company red flag if they are still having these people around.  About four years ago I was at a company that still had someone like that.  Useless and highfalutin, he obstructed many projects thanks to an archaic director who thought he was still necessary.<p>I got out after butting heads with him constantly, and I don&#x27;t think said company ever shipped anything meaningful in his entire tenure here.</div><br/><div id="36349310" class="c"><input type="checkbox" id="c-36349310" checked=""/><div class="controls bullet"><span class="by">doctor_eval</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36349018">parent</a><span>|</span><a href="#36348582">next</a><span>|</span><label class="collapse" for="c-36349310">[-]</label><label class="expand" for="c-36349310">[1 more]</label></div><br/><div class="children"><div class="content">I think you get these people in body shops - companies that basically rent out their skilled staff to other companies. The Architect sounds super important and is the most expensive resource, so obviously they sell it super hard.<p>When I worked there I was a product guy, and it took me an embarrassingly long time to understand why I didn&#x27;t fit in... but yeah, I didn&#x27;t last long.</div><br/></div></div></div></div><div id="36348582" class="c"><input type="checkbox" id="c-36348582" checked=""/><div class="controls bullet"><span class="by">cogogo</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36346905">parent</a><span>|</span><a href="#36349018">prev</a><span>|</span><a href="#36348011">next</a><span>|</span><label class="collapse" for="c-36348582">[-]</label><label class="expand" for="c-36348582">[1 more]</label></div><br/><div class="children"><div class="content">All of these experiences resonate with me. The pendulum has swung hard to the continuous deployment model and just like the other side of the long arc of the pendulum not everything about it is good.</div><br/></div></div><div id="36348011" class="c"><input type="checkbox" id="c-36348011" checked=""/><div class="controls bullet"><span class="by">gedy</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36346905">parent</a><span>|</span><a href="#36348582">prev</a><span>|</span><a href="#36351164">next</a><span>|</span><label class="collapse" for="c-36348011">[-]</label><label class="expand" for="c-36348011">[1 more]</label></div><br/><div class="children"><div class="content">I worked for a company not long ago that had leadership which felt you can&#x27;t be a real architect if you write code.   See ya!</div><br/></div></div></div></div></div></div><div id="36351164" class="c"><input type="checkbox" id="c-36351164" checked=""/><div class="controls bullet"><span class="by">ChicagoDave</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36346523">parent</a><span>|</span><a href="#36346837">prev</a><span>|</span><a href="#36347453">next</a><span>|</span><label class="collapse" for="c-36351164">[-]</label><label class="expand" for="c-36351164">[1 more]</label></div><br/><div class="children"><div class="content">I’d argue software architecture has never been more healthy.<p>DDD Europe by all accounts was a resounding success. We’ve replaced older architecture activities like data modeling first with event modeling and Domain-Driven Design.<p>We’ve learned to embrace monoliths when appropriate and reduce complexity with bounded contexts.<p>We have phenomenal testing capabilities that didn’t exist 20 years ago.<p>We have a myriad of data storage tools.<p>We understand front-end engineering from an information architecture perspective.<p>We can design detailed architectures in tools like LucidChart very quickly with detailed solution details.<p>I’ve been at this for 40 years and I’ve never felt better about being a software architect.</div><br/></div></div><div id="36347453" class="c"><input type="checkbox" id="c-36347453" checked=""/><div class="controls bullet"><span class="by">contravariant</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36346523">parent</a><span>|</span><a href="#36351164">prev</a><span>|</span><a href="#36347069">next</a><span>|</span><label class="collapse" for="c-36347453">[-]</label><label class="expand" for="c-36347453">[4 more]</label></div><br/><div class="children"><div class="content">Could we bring back the UI people from that era though? Trying to standardize good software is insane but having a consistent UI with standard elements for all programs that&#x27;s usable with both mouse and keyboard was kind of nice.</div><br/><div id="36348604" class="c"><input type="checkbox" id="c-36348604" checked=""/><div class="controls bullet"><span class="by">svachalek</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36347453">parent</a><span>|</span><a href="#36347069">next</a><span>|</span><label class="collapse" for="c-36348604">[-]</label><label class="expand" for="c-36348604">[3 more]</label></div><br/><div class="children"><div class="content">Very nice. There were decades of thoughtfulness and science that suddenly got replaced with &quot;well, it looks cooler&quot;.</div><br/><div id="36348978" class="c"><input type="checkbox" id="c-36348978" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36348604">parent</a><span>|</span><a href="#36349089">next</a><span>|</span><label class="collapse" for="c-36348978">[-]</label><label class="expand" for="c-36348978">[1 more]</label></div><br/><div class="children"><div class="content">There was a.lot of looks cool UI back then too, but mocking it was common, and none of it was successful despite itself.</div><br/></div></div><div id="36349089" class="c"><input type="checkbox" id="c-36349089" checked=""/><div class="controls bullet"><span class="by">rchaud</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36348604">parent</a><span>|</span><a href="#36348978">prev</a><span>|</span><a href="#36347069">next</a><span>|</span><label class="collapse" for="c-36349089">[-]</label><label class="expand" for="c-36349089">[1 more]</label></div><br/><div class="children"><div class="content">Struggling to think of any B2B apps whose design could be considered even remotely cool.</div><br/></div></div></div></div></div></div></div></div><div id="36347069" class="c"><input type="checkbox" id="c-36347069" checked=""/><div class="controls bullet"><span class="by">jrochkind1</span><span>|</span><a href="#36346262">parent</a><span>|</span><a href="#36346523">prev</a><span>|</span><a href="#36346632">next</a><span>|</span><label class="collapse" for="c-36347069">[-]</label><label class="expand" for="c-36347069">[11 more]</label></div><br/><div class="children"><div class="content">&gt; And they&#x27;d know the classics, like memorizing all design patterns.<p>That sentence is bringing back ptsd-like flashbacks.<p>I remember distinctly how much everyone thought that approach you describe was broken when it was the trendy thing.<p>I&#x27;m not sure how universal it ever was, but it was at one point a trendy thing that everyone thought they should be doing... and that so many people subject to found disastrous.  [The phrase &quot;architecture astronaut&quot; was a common epithet, and not a friendly one]<p>That above paragraph [without the brackets], ironically, could certainly be said of &quot;agile&quot; more recently too. I don&#x27;t know how universal it ever was, but it was at one point a trendy thing that everyone thought they should be doing... and that so many people subject to found disastrous.<p>But yeah, I&#x27;m pretty convinced going back to appointing some almighty deity architecture astronaut who isn&#x27;t responsible for or involved in any implementation (let alone operations!), who hands down plans from on high after &quot;memorizing all design patterns&quot; and drafting some diagrams, never sullied by &quot;contact with the enemy&quot;... no thank you, but thank you.<p>----<p>Instead of just complaining about that though, what I&#x27;ll say in addition is -- I think the real problem is that engineers aren&#x27;t given the <i>time</i> to carefully consider top-level designs.  it&#x27;s a basic business&#x2F;resource issue -- until engineers have more breathing room to talk to each other and research and consider and come to decisions in an unhurried way, the top-level design stuff will remain chaotic. It&#x27;s not an issue of appointing an ivory tower &quot;architect&quot;, or something solved by it.<p>Although sure, there should be senior and even &quot;staff&quot; or &quot;principal&quot; people with more authority&#x2F;responsibility for higher-level designs.<p>Everyone should be responsible for design at the level they are working. Everyone needs enough time to feel like they are doing it well, instead of running on a sweatshop code production treadmill.</div><br/><div id="36347529" class="c"><input type="checkbox" id="c-36347529" checked=""/><div class="controls bullet"><span class="by">jrumbut</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36347069">parent</a><span>|</span><a href="#36347697">next</a><span>|</span><label class="collapse" for="c-36347529">[-]</label><label class="expand" for="c-36347529">[9 more]</label></div><br/><div class="children"><div class="content">To be fair to the design patterns people, a lot of them got baked into pieces of infrastructure like web servers and frameworks, while others are part of frequently included libraries.<p>If I went through and inspected any Node, Rails, Django, etc app I would find many Gang of Four design patterns, but very few of them would be in the project-specific code. They got implemented well, and now programmers can build new things that would have taken too long to do before.<p>And that was the intent of the Gang of Four book, not to teach you patterns you should copy mindlessly, but to give examples of how to identify and extract useful patterns from the software you&#x27;ve already written and describe them to others. Since that is a lot more difficult than memorization, very few took up that work.</div><br/><div id="36347976" class="c"><input type="checkbox" id="c-36347976" checked=""/><div class="controls bullet"><span class="by">ivan_gammel</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36347529">parent</a><span>|</span><a href="#36347598">next</a><span>|</span><label class="collapse" for="c-36347976">[-]</label><label class="expand" for="c-36347976">[1 more]</label></div><br/><div class="children"><div class="content">This. As a hiring manager I noticed on interviews that many engineers when asked about patterns, do not even realize how much they rely on them in standard libraries and rarely understand that it’s not a fixed collection of templates, but rather a way of working with code. If you identify a common design and give it a name, you can save a lot of time explaining solutions based on it.</div><br/></div></div><div id="36347598" class="c"><input type="checkbox" id="c-36347598" checked=""/><div class="controls bullet"><span class="by">greiskul</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36347529">parent</a><span>|</span><a href="#36347976">prev</a><span>|</span><a href="#36351533">next</a><span>|</span><label class="collapse" for="c-36347598">[-]</label><label class="expand" for="c-36347598">[6 more]</label></div><br/><div class="children"><div class="content">Design patterns are missing language features.<p><a href="http:&#x2F;&#x2F;norvig.com&#x2F;design-patterns&#x2F;" rel="nofollow noreferrer">http:&#x2F;&#x2F;norvig.com&#x2F;design-patterns&#x2F;</a></div><br/><div id="36348998" class="c"><input type="checkbox" id="c-36348998" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36347598">parent</a><span>|</span><a href="#36351533">next</a><span>|</span><label class="collapse" for="c-36348998">[-]</label><label class="expand" for="c-36348998">[5 more]</label></div><br/><div class="children"><div class="content">People who say that don&#x27;t understand design patterns and have never worked on a very large project with code dating back a few decades.<p>Design patterns are what let you deal with the mess that results from that.</div><br/><div id="36353282" class="c"><input type="checkbox" id="c-36353282" checked=""/><div class="controls bullet"><span class="by">rottc0dd</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36348998">parent</a><span>|</span><a href="#36350945">next</a><span>|</span><label class="collapse" for="c-36353282">[-]</label><label class="expand" for="c-36353282">[1 more]</label></div><br/><div class="children"><div class="content">Even GoF says that class and interface are part of language for C++ or Java can be a design pattern for languages like C.<p>I think in some ways AspectJ can make the observer design pattern obsolete in Java. I have arguments against doing it in aspect way, but it was revelation nonetheless.</div><br/></div></div><div id="36350945" class="c"><input type="checkbox" id="c-36350945" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36348998">parent</a><span>|</span><a href="#36353282">prev</a><span>|</span><a href="#36350258">next</a><span>|</span><label class="collapse" for="c-36350945">[-]</label><label class="expand" for="c-36350945">[2 more]</label></div><br/><div class="children"><div class="content">So, here&#x27;s something I hate on this site.  Arguments that are made in the fashion &quot;People who disagree with me must not understand X&quot;.  When in fact you&#x27;re often talking to some of the smartest people in programming on here (though, maybe not in other things.)<p>It&#x27;s possible to understand design patterns and work in a language that doesn&#x27;t require them as much.<p>Here&#x27;s a talk about it from 2009 with regards to python.<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=kSQFZrTDaQ0">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=kSQFZrTDaQ0</a></div><br/><div id="36351291" class="c"><input type="checkbox" id="c-36351291" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36350945">parent</a><span>|</span><a href="#36350258">next</a><span>|</span><label class="collapse" for="c-36351291">[-]</label><label class="expand" for="c-36351291">[1 more]</label></div><br/><div class="children"><div class="content">Some design patterns work around a bad language, but most are about complex problems. They are a way of describing abstraction, and that is what languages are about.</div><br/></div></div></div></div><div id="36350258" class="c"><input type="checkbox" id="c-36350258" checked=""/><div class="controls bullet"><span class="by">kristjansson</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36348998">parent</a><span>|</span><a href="#36350945">prev</a><span>|</span><a href="#36351533">next</a><span>|</span><label class="collapse" for="c-36350258">[-]</label><label class="expand" for="c-36350258">[1 more]</label></div><br/><div class="children"><div class="content">Good _design_ improves long term maintainability. Design Patterns (in the GoF sense) are basically orthogonal to good design.<p>Besides, Peter Norvig, even as of 1996, is not not the sort of neophyte you’re referring to.</div><br/></div></div></div></div></div></div><div id="36351533" class="c"><input type="checkbox" id="c-36351533" checked=""/><div class="controls bullet"><span class="by">nivertech</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36347529">parent</a><span>|</span><a href="#36347598">prev</a><span>|</span><a href="#36347697">next</a><span>|</span><label class="collapse" for="c-36351533">[-]</label><label class="expand" for="c-36351533">[1 more]</label></div><br/><div class="children"><div class="content">this.<p>Back in the day (before open sourse became so prevalent), lots of software was designed from scratch with the minimal use of outside components and frameworks.<p>Today OSS frameworks (especially web frameworks) and libraries, PaaS, and Cloud provides you with an already baked-in design patterns. So there is less need in SW Architect and proper design.<p>Also, most of the Gang of Four patterns are just addressing the deficiences of OOP and older PLs, so if you&#x27;re using a modern PL with closures&#x2F;etc. there is no need in them.<p>EDIT:<p>Novadays a vast majority of design patterns are dealing with the complexities of microservices architecture, so if your product is a monolith then there is no need in them.<p>IMO the most useful design patterns are the ones dealing with error handling, reliability, and the essential complexity comming from the real world and human actors, not the self-inflicted accidental complexity comming from the bad design decisions. The good SW Architect should be able to help in avoiding that.</div><br/></div></div></div></div><div id="36347697" class="c"><input type="checkbox" id="c-36347697" checked=""/><div class="controls bullet"><span class="by">devin</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36347069">parent</a><span>|</span><a href="#36347529">prev</a><span>|</span><a href="#36346632">next</a><span>|</span><label class="collapse" for="c-36347697">[-]</label><label class="expand" for="c-36347697">[1 more]</label></div><br/><div class="children"><div class="content">I tend to agree about the time thing, namely that people aren&#x27;t given enough of it to sit down and take their time with design decisions. If you squint you can kind of see that &quot;software architects&quot; are a business&#x27;s way of creating a &quot;solution&quot; to this problem, but with lackluster results.<p>That said, I&#x27;ve been at places where management did a pretty good job of making sure that there was enough time to do this kind of work with middling results. People have to enjoy the work or feel invested in a way that makes them care about &quot;3 years from now&quot;, and sadly in a lot of places there&#x27;s a lot of &quot;whatever, it&#x27;ll be fine for as long as I work here.&quot;<p>It seemed to me that in let&#x27;s say 50% of cases, having the extra time didn&#x27;t really matter. Assumptions about what was being built were proven incorrect not long after a design was laid down and work had begun, or particular engineering types would create increasingly complicated designs with their time rather than doing the hard work of distilling the problem, sometimes including $PET_TECHNOLOGY as part of their solution.<p>The &quot;let&#x27;s design something truly great&quot; really has to be in a team&#x27;s DNA in my experience or you wind up with a good design that isn&#x27;t followed, one person who does all the work, a gold plated design, etc.</div><br/></div></div></div></div><div id="36346632" class="c"><input type="checkbox" id="c-36346632" checked=""/><div class="controls bullet"><span class="by">opportune</span><span>|</span><a href="#36346262">parent</a><span>|</span><a href="#36347069">prev</a><span>|</span><a href="#36347270">next</a><span>|</span><label class="collapse" for="c-36346632">[-]</label><label class="expand" for="c-36346632">[4 more]</label></div><br/><div class="children"><div class="content">That’s because software architecture is something any senior employee should be able to do, and it’s not as important as people thought.<p>Like many abandoned corporate practices, I think it was abandoned for good reason. It may have made sense under different circumstances, like when you had a large army of cheap offshore devs who could not be trusted to architect a maintainable application.<p>If I had some ivory tower “architect” trying to interfere with my work I’d be so pissed. Anybody I’ve seen with that title, that wasn’t doing 1P cloud consulting where the title means something different, usually had no clue what they were doing and had been given the title as a soft retirement.</div><br/><div id="36347600" class="c"><input type="checkbox" id="c-36347600" checked=""/><div class="controls bullet"><span class="by">eropple</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36346632">parent</a><span>|</span><a href="#36347270">next</a><span>|</span><label class="collapse" for="c-36347600">[-]</label><label class="expand" for="c-36347600">[3 more]</label></div><br/><div class="children"><div class="content">As much as I do think that software architecture does matter (though it should probably be somebody with a staff or principal hat, not a specific job title) I recently took a job at a place that really does like architect titles. Mine&#x27;s even &quot;lead architect&quot;.<p>It is pretty funny when somebody runs into me and realizes for the first time that I have the job because I build stuff and write code, not because I&#x27;m good at LucidChart. I&#x27;m planning things out beyond immediate needs, but not because I&#x27;m looking for job security--it&#x27;s because I&#x27;ve built the thing we&#x27;re doing before and would like to not make the same mistakes I&#x27;ve made in the past. I&#x27;m over here demanding adequate standards of code and low- to mid-level design, and the &quot;wait he&#x27;s serious?&quot; of it is sometimes honestly pretty fun to run up against.<p>I am good at LucidChart though.</div><br/><div id="36348651" class="c"><input type="checkbox" id="c-36348651" checked=""/><div class="controls bullet"><span class="by">opportune</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36347600">parent</a><span>|</span><a href="#36347270">next</a><span>|</span><label class="collapse" for="c-36348651">[-]</label><label class="expand" for="c-36348651">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, I guess I would in retrospect refine my opinion to “software architecture is iterable and not completely separable from implementation” or that “architecture (as imagined by distinct architects who are shielded from implementation concerns) is not important”.<p>Principal engineers and such who are still involved in operations, implementation, and more tactical approaches are who I also think are “supposed” to be doing architecture, but even then, more as guides and first among equals than as people who hand down decisions from on-high.<p>The fundamental issue I have with a separate architect position is that it disempowers teams and makes them beholden to decisions that they may not agree with (and which very well may not understand the problem to the extent they do). It sounds like you’re doing the better thing of running up and down the layers of abstraction so your contributions empower people rather than disempower them</div><br/><div id="36349045" class="c"><input type="checkbox" id="c-36349045" checked=""/><div class="controls bullet"><span class="by">eropple</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36348651">parent</a><span>|</span><a href="#36347270">next</a><span>|</span><label class="collapse" for="c-36349045">[-]</label><label class="expand" for="c-36349045">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt;  Yeah, I guess I would in retrospect refine my opinion to “software architecture is iterable and not completely separable from implementation” or that “architecture (as imagined by distinct architects who are shielded from implementation concerns) is not important”.</i><p>This, I&#x27;d agree with. You have to be at the coalface to know what the hell is going on. At the same time, you have to be cognizant of business needs and why things are the way they are, which is to me a fair approximation of &quot;the job of a principal engineer.&quot;<p>(My other hat here is &quot;head of API governance&quot; and that&#x27;s largely a business-flavored analysis of APIs being brought onto our company-spanning platform. I couldn&#x27;t escape having both in my head if I tried.)<p><i>&gt; It sounds like you’re doing the better thing of running up and down the layers of abstraction so your contributions empower people rather than disempower them </i><p>Ideally, yes. In reality, I work for The Phone Company, and The Phone Company hires a lot, and I mean a lot, of vendor devs. I am doing their thinking for them a lot of the time; the swerve is that I can and do write code (have released moderately popular open-source libraries on their framework of choice, for example) and so the usual development practices of &quot;sure let&#x27;s make a dozen packages for marginal functionality&quot; don&#x27;t fly.<p>I am disempowering them, because ultimately, we will eventually be cycling out our vendors and I will be the one who has to own their output. So that output has to be something I can live with. But this place is Processes Georg and should absolutely not be counted.<p>(I like the job. I will enjoy when I eventually go back to a shop where the developers have a reason to feel ownership over the work.)</div><br/></div></div></div></div></div></div></div></div><div id="36347270" class="c"><input type="checkbox" id="c-36347270" checked=""/><div class="controls bullet"><span class="by">hejcloud</span><span>|</span><a href="#36346262">parent</a><span>|</span><a href="#36346632">prev</a><span>|</span><a href="#36347774">next</a><span>|</span><label class="collapse" for="c-36347270">[-]</label><label class="expand" for="c-36347270">[6 more]</label></div><br/><div class="children"><div class="content">German speaking. You can take German IT to get an idea what would have happened to SWE if you&#x27;d have kept those bureaucratic methods from the 2000s as the backbone of all SWE endeavors: a horrible, expensive, non-working mess with barely any progress.<p>I think what many people, esp. from outside the SWE world, don&#x27;t get: Software engineering is a deeply social kind of work. There are dozens of solutions for the given problems, you have to agree on one that works for all peers. That&#x27;s the job. Optimizing it for drawing funny diagrams is not an issue if not for communication.</div><br/><div id="36347743" class="c"><input type="checkbox" id="c-36347743" checked=""/><div class="controls bullet"><span class="by">devin</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36347270">parent</a><span>|</span><a href="#36347418">next</a><span>|</span><label class="collapse" for="c-36347743">[-]</label><label class="expand" for="c-36347743">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m also interested in the german software engineering culture. And also, heavy plus to this being a social problem more than a &quot;engineers just need more time&quot; problem. I tried to articulate this in another comment of mine but mostly beat around the bush. This is more directly what I was attempting to say.</div><br/><div id="36350020" class="c"><input type="checkbox" id="c-36350020" checked=""/><div class="controls bullet"><span class="by">hejcloud</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36347743">parent</a><span>|</span><a href="#36347418">next</a><span>|</span><label class="collapse" for="c-36350020">[-]</label><label class="expand" for="c-36350020">[1 more]</label></div><br/><div class="children"><div class="content">Well in my theory core reason is that Germany never developed a thriving startup IT economy[0] that was ever relevant for the GDP, especially not in comparison with the industrial sectors (cars, steel, chemistry) and so IT completely got ignored by politicians. 
That resulted in no one who&#x27;d challenge the biggest gatekeepers Telekom and SAP, so they lobbied for and enforced whatever they wanted[1].<p>If you study CS in a German university you can easily get an MA without being able to write software at all (I personally happen to know several people). German universities teach what is easy to teach top down and test for: The textbook stuff that came out of the whole Java EE&#x2F;OOP&#x2F;SOAP&#x2F;UML sector. You barely get practical coding lessons and can avoid them completely if you want. The academic sector never realized how crappy German software products are and never bothered looking at what Big Tech is doing. With given data protection and soon AI regulations, as a university you&#x27;d have a hard time collecting enough training data because your law department would step in referring to the current legal insecurity (I&#x27;ve heard stories from friends).<p>Then we have this little crazy island Berlin which up until maybe 10ys ago was mainly driven by the infamous Rocket Internet &quot;startup incubator&quot; which is led by a couple of MBA sociopath billionaires, trying to copycat everything from SV  and then sell it back to the SV company whenever they wanted to start conquering Europe. Thing is they never really developed enough SWE excellence to get the copycat successful in Germany or anywhere in Europe (with some exceptions).<p>Third example? Here you are: Today I learned that the gov&#x27;t already decided 20ys ago that they want to provide all usual governmental services online. 20ys later they (allegedly) poured 3.5Bn EUR into an unholy setup of consulting businesses, incompetent civil servants and a panel of software architect astronauts who could never really agree on things.
All their deliverables are click-dummies, gazillions of PDFs with SOAP&#x2F;WSDL&#x2F;OMG&#x2F;UML thingies and prototype projects rolled out in &quot;experimental&quot; cities. So if you happen to live in Bremen you might be able to register your dog online but not in Berlin. Therefore in Berlin you might be able to get a license plate for your car online. Pretty much all governmental projects (Covid vaccination registration, special governmental aid for students because of high inflation, etc.) broke down because all their systems are incapable of handling more than maybe 10k visitors (in my theory it always breaks down whenever the biggest single Oracle DB host they could buy is going down).<p>Germany has some decent software engineers, especially if they&#x27;re self-trained and not brainwashed by one of the universities or big corps. But the environment manages to regularly piss them off and make em emigrate to somewhere else.<p>Ouff, much text. Hope at least someone enjoys reading it.<p>---<p>[0] This is because if you start a company in Germany you&#x27;re faced with horrible bureaucracy wrt taxes, laws, politics, governmental authorities, etc. For example, you&#x27;re forced to pay for a membership in a funny non-IT institution called &quot;Industrie- und Handelskammer (IHK)&quot; which essentially consists of a crowd of old men who are officially supposed to lobby for you and create a networking environment but if you ask them something like &quot;hey, can you tell me how many companies are having problem XYZ right now?&quot; they will tell you that they don&#x27;t have any numbers and have no means to collect them. In 2023 they still send out a meaningless paper printed magazine. So not helpful at all but take a significant share of your gross turnover mainly to pay for their pensions.
Additionally, with all the regulations the governments set up over years they&#x27;re now facing a significant cut in civil servants because Germany is getting older and older. As a result they&#x27;re not having enough people to enforce or check regulations in time and never managed to develop any IT-based systems. Big problem with the influx of refugees in recent years and affects many other concerns as well.
Finally, there&#x27;s this cultural difference to, e.g., the US that average Germans are not business-savy at all. If you tell the average German mom that you want to start a business, she will tell you that you&#x27;re a dreamer and should get a proper job. Germans generally tend to think that companies are something god-given.<p>[1] They are still the go-to businesses if the gov&#x27;t quickly needs something, like the Covid tracing app which German tax payers AFAIR ended up paying 120M EUR for (lol).</div><br/></div></div></div></div><div id="36347418" class="c"><input type="checkbox" id="c-36347418" checked=""/><div class="controls bullet"><span class="by">_dain_</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36347270">parent</a><span>|</span><a href="#36347743">prev</a><span>|</span><a href="#36347774">next</a><span>|</span><label class="collapse" for="c-36347418">[-]</label><label class="expand" for="c-36347418">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not familiar with how IT works in Germany. What&#x27;s different about it? Got any stories?</div><br/><div id="36348532" class="c"><input type="checkbox" id="c-36348532" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36347418">parent</a><span>|</span><a href="#36347774">next</a><span>|</span><label class="collapse" for="c-36348532">[-]</label><label class="expand" for="c-36348532">[2 more]</label></div><br/><div class="children"><div class="content">One word: SAP.</div><br/><div id="36349489" class="c"><input type="checkbox" id="c-36349489" checked=""/><div class="controls bullet"><span class="by">artyom</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36348532">parent</a><span>|</span><a href="#36347774">next</a><span>|</span><label class="collapse" for="c-36349489">[-]</label><label class="expand" for="c-36349489">[1 more]</label></div><br/><div class="children"><div class="content">Oh no. I&#x27;m so sorry.</div><br/></div></div></div></div></div></div></div></div><div id="36347774" class="c"><input type="checkbox" id="c-36347774" checked=""/><div class="controls bullet"><span class="by">mytailorisrich</span><span>|</span><a href="#36346262">parent</a><span>|</span><a href="#36347270">prev</a><span>|</span><a href="#36346672">next</a><span>|</span><label class="collapse" for="c-36347774">[-]</label><label class="expand" for="c-36347774">[1 more]</label></div><br/><div class="children"><div class="content">The problem is that the expection was to document the software design in excruciating details (e.g. class diagrams with all fields and methods, etc.) before any coding. To the extreme you were meant to all the coding in your head and a Word document before doing it again in your IDE.<p>This wastes a huge amount of time and usually the documents become obsolete as soon as you try to actually run some code.<p>This is the very issue the Agile manifesto identifies and proposes a solution to when it says &quot;<i>working software over comprehensive documentation</i>&quot;. &#x27;Comprehensive&#x27; is a key word as they don&#x27;t mean NO documentation  but effectively just what&#x27;s needed to plan and help people understand the code.</div><br/></div></div><div id="36346672" class="c"><input type="checkbox" id="c-36346672" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36346262">parent</a><span>|</span><a href="#36347774">prev</a><span>|</span><a href="#36346534">next</a><span>|</span><label class="collapse" for="c-36346672">[-]</label><label class="expand" for="c-36346672">[4 more]</label></div><br/><div class="children"><div class="content">We stopped doing that stuff because it was useless. We eliminated those practices and that profession because it was actively harmful to making good software. All those decision making methodologies consistently lead to worse technology choices than one dude actually trying to write some code with the thing for half an hour.</div><br/><div id="36347537" class="c"><input type="checkbox" id="c-36347537" checked=""/><div class="controls bullet"><span class="by">icedchai</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36346672">parent</a><span>|</span><a href="#36346534">next</a><span>|</span><label class="collapse" for="c-36347537">[-]</label><label class="expand" for="c-36347537">[3 more]</label></div><br/><div class="children"><div class="content">UML is mostly useless, but thinking ahead, even a bit, has value. I&#x27;ve seen stuff shipped in a sprint that was not used by any actual end users, only to be &quot;redone&quot; in the next sprint.</div><br/><div id="36347776" class="c"><input type="checkbox" id="c-36347776" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36347537">parent</a><span>|</span><a href="#36346534">next</a><span>|</span><label class="collapse" for="c-36347776">[-]</label><label class="expand" for="c-36347776">[2 more]</label></div><br/><div class="children"><div class="content">My experience is that shipping stuff that doesn&#x27;t get used by any actual end users is more often caused by thinking ahead too much than by thinking ahead too little.</div><br/><div id="36348054" class="c"><input type="checkbox" id="c-36348054" checked=""/><div class="controls bullet"><span class="by">icedchai</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36347776">parent</a><span>|</span><a href="#36346534">next</a><span>|</span><label class="collapse" for="c-36348054">[-]</label><label class="expand" for="c-36348054">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve actually seen it both ways: whole features (or even products) that were too early. But on the implementation level, I&#x27;ve seen someone pick the wrong thing (library, database, whatever) &quot;because it was simple&quot;, only to have it be thrown out before getting any real usage.</div><br/></div></div></div></div></div></div></div></div><div id="36346534" class="c"><input type="checkbox" id="c-36346534" checked=""/><div class="controls bullet"><span class="by">doctor_eval</span><span>|</span><a href="#36346262">parent</a><span>|</span><a href="#36346672">prev</a><span>|</span><a href="#36349448">next</a><span>|</span><label class="collapse" for="c-36346534">[-]</label><label class="expand" for="c-36346534">[1 more]</label></div><br/><div class="children"><div class="content">I don’t think this is any more true than it ever was. If anything, the rise of open source libraries, GitHub and friends has made it easier than ever to reuse software and avoid NIH. This has lead to a different set of problems, but relative to when I was writing C in the 90s I’d say software reuse and design is far advanced from those days.<p>I do however agree that design is sorely missing from the current software project management zeitgeist, which means it’s done in a more ad hoc way. People are taking frameworks like Scrum far too literally, and I agree that in some cases there is little vision or overall architecture because the framework doesn’t include these things. There should be design and review activities both before and after coding, but these are largely neglected from most project management frameworks. Scrum for example doesn’t even include backlog management, which in my work is a critical activity.<p>While that doesn’t mean design, architecture and scope management is not done, it’s certainly less visible than it might be.<p>All of that said, I’m a big believer that the ultimate expression of any design is code. The design artefacts that come before code is written are scaffolding, age quickly, and are soon useless. So there’s not much need to keep them around, and they are mostly of interest as preliminary directions.<p>In this regard I’m a big fan of Jack Reeves essays from the same period at <a href="https:&#x2F;&#x2F;www.developerdotstar.com&#x2F;mag&#x2F;articles&#x2F;reeves_design_main.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.developerdotstar.com&#x2F;mag&#x2F;articles&#x2F;reeves_design_...</a></div><br/></div></div><div id="36349448" class="c"><input type="checkbox" id="c-36349448" checked=""/><div class="controls bullet"><span class="by">wpietri</span><span>|</span><a href="#36346262">parent</a><span>|</span><a href="#36346534">prev</a><span>|</span><a href="#36347163">next</a><span>|</span><label class="collapse" for="c-36349448">[-]</label><label class="expand" for="c-36349448">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In fact, I believe it pretty much killed the profession of software architect.<p>And thank goodness. I am all in favor of more consideration, more quality, more integrity. I like good <i>architecture</i>. But I think it&#x27;s a giant mistake to create a software <i>architect</i> role. Every company where I saw that in practice, the average architect was a bloviator who did no actual work but was very excited to tell everybody else how to work.<p>At the code level, this resulted in a lot of messes. The edicts and white papers sounded good in theory to the kind of people who decided the bonuses of the architects. But frequently they were unworkable in practice, causing a lot of code that conformed to the theory but was a pain to actually deal with.<p>I agree with you that a lot of things are half-assed and rushed, of course. But we are never going back to a world of 18-36 month release cycles where people could stroke their chins for a quarter or two before building anything. Instead, we need to move in the direction of continually investing in quality, so that the design of systems improves over time. Something that I think is actually easier, in that waterfall design practices locked in important decisions early on, when people knew the least.</div><br/></div></div><div id="36347163" class="c"><input type="checkbox" id="c-36347163" checked=""/><div class="controls bullet"><span class="by">yafbum</span><span>|</span><a href="#36346262">parent</a><span>|</span><a href="#36349448">prev</a><span>|</span><a href="#36352269">next</a><span>|</span><label class="collapse" for="c-36347163">[-]</label><label class="expand" for="c-36347163">[5 more]</label></div><br/><div class="children"><div class="content"><i>We</i> haven&#x27;t told ourselves that shipping garbage in short cycles is the only way to do things. <i>The market</i> has pretty much determined that companies that over invest in formal software design activities lose out competitively in the long run, and the survivors are the ones with the right balance. You&#x27;re welcome to prove the market wrong.</div><br/><div id="36349465" class="c"><input type="checkbox" id="c-36349465" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36347163">parent</a><span>|</span><a href="#36347636">next</a><span>|</span><label class="collapse" for="c-36349465">[-]</label><label class="expand" for="c-36349465">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The market has pretty much determined that companies that over invest in formal software design activities lose out competitively in the long run<p>The same market that gave us AT&amp;T, Comcast, DRMed IoT Juice presses, FTX, Enron, and so on? Not sure it’s wise to conclude that the market produces optimal solutions, or even incrementally better solutions than yesterday. Especially in domains with extremely long feedback cycles, like organizational trends.<p>I DO think there is some hocus pocus market zeitgeist that does something resembling gradient descent, but it’s acting over very long cycles and there’s a ton of room for cargo culting, grifting, and opportunistic grabs along the way. Heck, marketing is an entire field dedicated to affecting “rational actors” in the marketplace.</div><br/></div></div><div id="36347636" class="c"><input type="checkbox" id="c-36347636" checked=""/><div class="controls bullet"><span class="by">RachelF</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36347163">parent</a><span>|</span><a href="#36349465">prev</a><span>|</span><a href="#36347582">next</a><span>|</span><label class="collapse" for="c-36347636">[-]</label><label class="expand" for="c-36347636">[2 more]</label></div><br/><div class="children"><div class="content">In truth it depends on the software. For web or phone or desktop apps which can be upgraded on the fly, short cycles are ok.<p>On the other hand, Boeing&#x27;s crappy software practices resulting in the 737-MAX crashes are an area where short-cuts killed people.</div><br/><div id="36352116" class="c"><input type="checkbox" id="c-36352116" checked=""/><div class="controls bullet"><span class="by">phs318u</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36347636">parent</a><span>|</span><a href="#36347582">next</a><span>|</span><label class="collapse" for="c-36352116">[-]</label><label class="expand" for="c-36352116">[1 more]</label></div><br/><div class="children"><div class="content">So much this. Coding to marketing dictums on the cycle of days&#x2F;weeks is completely NOTHING like engineering solutions where subtle design issues can make the difference between life and death (or IRL super good thing A and IRL super bad thing B).</div><br/></div></div></div></div><div id="36347582" class="c"><input type="checkbox" id="c-36347582" checked=""/><div class="controls bullet"><span class="by">ilyt</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36347163">parent</a><span>|</span><a href="#36347636">prev</a><span>|</span><a href="#36352269">next</a><span>|</span><label class="collapse" for="c-36347582">[-]</label><label class="expand" for="c-36347582">[1 more]</label></div><br/><div class="children"><div class="content">And they just shipped garbage in longer cycles... as anyone that had to deal with such designed legacy apps can confirm.</div><br/></div></div></div></div><div id="36352269" class="c"><input type="checkbox" id="c-36352269" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#36346262">parent</a><span>|</span><a href="#36347163">prev</a><span>|</span><a href="#36346617">next</a><span>|</span><label class="collapse" for="c-36352269">[-]</label><label class="expand" for="c-36352269">[1 more]</label></div><br/><div class="children"><div class="content">In my short experience this is mostly due to OOP falling out of style, being replaced by a more hybrid approach that combines a lot of functional programming, procedural programming, and OOP - that, together with newer languages providing alternatives for inheritance (traits&#x2F;concepts), and such, you rarely find yourself needing much more than visitor- and factory pattern.</div><br/></div></div><div id="36346617" class="c"><input type="checkbox" id="c-36346617" checked=""/><div class="controls bullet"><span class="by">_proofs</span><span>|</span><a href="#36346262">parent</a><span>|</span><a href="#36352269">prev</a><span>|</span><a href="#36349699">next</a><span>|</span><label class="collapse" for="c-36346617">[-]</label><label class="expand" for="c-36346617">[2 more]</label></div><br/><div class="children"><div class="content">while i feel as if i largely understand what you&#x27;re pointing out, i kinda want to offer my own speculation as a SWE who is very guilty in thinking in terms of sequence diagrams (and also more formal UML) -- sometimes UML is so fucking bogged down with (impl) <i>details</i>, i am just over here going &quot;i don&#x27;t give a shit about the (impl) details, i just want to know the abstract concept(s), and logical <i>flows</i>, and focus on necessary system interactions&quot; -- bc i can (and should at this stage) worry about (impl) details later.<p>i prefer to reason about a system and component relationships using, say, a single word as representation, instead of glaring at one or many inheritance directionals, interface details, and other &quot;field&quot; information, which is usually conveyed in a UML node.<p>i do not think the lack of formalism is a degradation -- we work with <i>abstractions</i> after-all, so it makes sense to further leverage that fact and express things simply, at a high-level, and straight-forwardly -- you can pack a lot into a single word.<p>of course as the nature of any tool, there is a time and a place for its application. but i don&#x27;t think it is fair to call it a degradation.</div><br/><div id="36351077" class="c"><input type="checkbox" id="c-36351077" checked=""/><div class="controls bullet"><span class="by">DSMan195276</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36346617">parent</a><span>|</span><a href="#36349699">next</a><span>|</span><label class="collapse" for="c-36351077">[-]</label><label class="expand" for="c-36351077">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve noticed the &quot;over-detailed&quot; problem a lot at my company that has dedicated &quot;software architect&quot; roles. IMO part of the issue is that most of them do not write any code anymore, but &#x27;architecture&#x27; alone just doesn&#x27;t have a full-time job&#x27;s worth of stuff to do (or they&#x27;re bad about finding it). The &#x27;solution&#x27; they end up on is just treating UML like code and specifying exactly how they would have written the whole thing - which is a huge waste of time when they could have just been writing real code.</div><br/></div></div></div></div><div id="36349699" class="c"><input type="checkbox" id="c-36349699" checked=""/><div class="controls bullet"><span class="by">rr808</span><span>|</span><a href="#36346262">parent</a><span>|</span><a href="#36346617">prev</a><span>|</span><a href="#36347164">next</a><span>|</span><label class="collapse" for="c-36349699">[-]</label><label class="expand" for="c-36349699">[1 more]</label></div><br/><div class="children"><div class="content">Now hardware and bandwidth is so cheap now you dont have to care about design so much. Make a service, JSON in JSON out. Some kind of loose versioning but no formal schema and fix it up as it goes.</div><br/></div></div><div id="36347164" class="c"><input type="checkbox" id="c-36347164" checked=""/><div class="controls bullet"><span class="by">maximinus_thrax</span><span>|</span><a href="#36346262">parent</a><span>|</span><a href="#36349699">prev</a><span>|</span><a href="#36346539">next</a><span>|</span><label class="collapse" for="c-36347164">[-]</label><label class="expand" for="c-36347164">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Everybody is half-assing design or skipping it entirely. Solutions are reinvented and tech choices made on a whim by the loudest person whom won&#x27;t see the consequences of it anyway. Because we&#x27;ve told ourselves that shipping garbage in short cycles is the one and only way to do things.<p>I agree. I don&#x27;t personally fetishize the old slow processes nor ivory tower architectures, but I think there&#x27;s a healthy spectrum between that and the complete &#x27;software fuckery&#x27; (<a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20160308032127&#x2F;https:&#x2F;&#x2F;medium.com&#x2F;@bryanedds&#x2F;living-in-the-age-of-software-fuckery-8859f81ca877" rel="nofollow noreferrer">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20160308032127&#x2F;https:&#x2F;&#x2F;medium.co...</a>)</div><br/></div></div><div id="36346539" class="c"><input type="checkbox" id="c-36346539" checked=""/><div class="controls bullet"><span class="by">peanut-walrus</span><span>|</span><a href="#36346262">parent</a><span>|</span><a href="#36347164">prev</a><span>|</span><a href="#36349313">next</a><span>|</span><label class="collapse" for="c-36346539">[-]</label><label class="expand" for="c-36346539">[2 more]</label></div><br/><div class="children"><div class="content">Software architects, much like real architects, often end up with absolutely beautiful elegant designs which are unfit for purpose and have leaky roofs.</div><br/><div id="36349061" class="c"><input type="checkbox" id="c-36349061" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36346539">parent</a><span>|</span><a href="#36349313">next</a><span>|</span><label class="collapse" for="c-36349061">[-]</label><label class="expand" for="c-36349061">[1 more]</label></div><br/><div class="children"><div class="content">And other architects make buildings&#x2F;software that gets done on time because unlike babies adding people can make things go faster (it is always sub linear, but good architecture can get close to linear, while bad can go negative slope)</div><br/></div></div></div></div><div id="36349313" class="c"><input type="checkbox" id="c-36349313" checked=""/><div class="controls bullet"><span class="by">zitterbewegung</span><span>|</span><a href="#36346262">parent</a><span>|</span><a href="#36346539">prev</a><span>|</span><a href="#36347789">next</a><span>|</span><label class="collapse" for="c-36349313">[-]</label><label class="expand" for="c-36349313">[1 more]</label></div><br/><div class="children"><div class="content">Sequence diagrams and state machines should be probably taught much better in CS courses. You generally see state machines in a theoretical course and things like sequence diagrams in an object oriented course.<p>What we should do is probably in your advanced data structure programming course that everyone has to take is to create a model of an elevator and diagram the behavior using a sequence diagrams. This would be achieved by using an associative array AKA a map [1] that would represent where the elevator is and what it has to do next (current state and next state based on input).<p>If you program this correctly it gets around using unit testing even because you have diagramed and all parts of the system are known and can just be gone through and that would be a sufficient test. An example of a library that implements this is at <a href="https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;python-statemachine&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;python-statemachine&#x2F;</a><p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Associative_array" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Associative_array</a></div><br/></div></div><div id="36347789" class="c"><input type="checkbox" id="c-36347789" checked=""/><div class="controls bullet"><span class="by">qwertywert_</span><span>|</span><a href="#36346262">parent</a><span>|</span><a href="#36349313">prev</a><span>|</span><a href="#36349331">next</a><span>|</span><label class="collapse" for="c-36347789">[-]</label><label class="expand" for="c-36347789">[1 more]</label></div><br/><div class="children"><div class="content">Overdesign is one of the worst things to do. Trying to make something fit perfectly into some obscure pattern with horrible class hierarchies. 
Look at the linux kernel sources, it does not look &quot;beautiful&quot; to some architects but the actual ideas and patterns are simple, anyone can jump into it if they know C.</div><br/></div></div><div id="36349331" class="c"><input type="checkbox" id="c-36349331" checked=""/><div class="controls bullet"><span class="by">rukuu001</span><span>|</span><a href="#36346262">parent</a><span>|</span><a href="#36347789">prev</a><span>|</span><a href="#36347567">next</a><span>|</span><label class="collapse" for="c-36349331">[-]</label><label class="expand" for="c-36349331">[1 more]</label></div><br/><div class="children"><div class="content">I think the industry is diverging.<p>- There&#x27;s very high-level engineering occurring (&#x27;computer science&#x27;). I always assumed this would be at places with &#x27;web-scale&#x27; problems, but I&#x27;ve been seeing amazing work in local (not-web-scale) product companies here in Australia.<p>- On the other hand, I think a lot of other development work is not much above building flat-pack furniture. I guess this is where lo&#x2F;no-code solutions will thrive<p>The important thing is to recognise which is being done, and which practices apply each case.</div><br/></div></div><div id="36347567" class="c"><input type="checkbox" id="c-36347567" checked=""/><div class="controls bullet"><span class="by">ilyt</span><span>|</span><a href="#36346262">parent</a><span>|</span><a href="#36349331">prev</a><span>|</span><a href="#36349942">next</a><span>|</span><label class="collapse" for="c-36347567">[-]</label><label class="expand" for="c-36347567">[1 more]</label></div><br/><div class="children"><div class="content">No, that&#x27;s the era of worst, shittiest legacy software to date. The computers were just fast enough to handle layers and layers of extraction and <i>oh boy</i> industry loved to pile them one and UML was just another way to pile up the rot</div><br/></div></div><div id="36349942" class="c"><input type="checkbox" id="c-36349942" checked=""/><div class="controls bullet"><span class="by">anoy8888</span><span>|</span><a href="#36346262">parent</a><span>|</span><a href="#36347567">prev</a><span>|</span><a href="#36346467">next</a><span>|</span><label class="collapse" for="c-36349942">[-]</label><label class="expand" for="c-36349942">[1 more]</label></div><br/><div class="children"><div class="content">Apparently, you probably haven&#x27;t started a real business or created a real successful product . This is what people believe when they are just a cog in the machine and they believe they can spend countless time designing or planning for things that are out of touch with reality</div><br/></div></div><div id="36346467" class="c"><input type="checkbox" id="c-36346467" checked=""/><div class="controls bullet"><span class="by">beyonddream</span><span>|</span><a href="#36346262">parent</a><span>|</span><a href="#36349942">prev</a><span>|</span><a href="#36344420">next</a><span>|</span><label class="collapse" for="c-36346467">[-]</label><label class="expand" for="c-36346467">[3 more]</label></div><br/><div class="children"><div class="content">I am curious to know what are these “formalized architectural decision making methodologies” ? Any books that u know of that cover these topics ?</div><br/><div id="36346585" class="c"><input type="checkbox" id="c-36346585" checked=""/><div class="controls bullet"><span class="by">jt2190</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36346467">parent</a><span>|</span><a href="#36344420">next</a><span>|</span><label class="collapse" for="c-36346585">[-]</label><label class="expand" for="c-36346585">[2 more]</label></div><br/><div class="children"><div class="content">“Rational Unified Process” <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Rational_unified_process" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Rational_unified_process</a></div><br/><div id="36347784" class="c"><input type="checkbox" id="c-36347784" checked=""/><div class="controls bullet"><span class="by">beyonddream</span><span>|</span><a href="#36346262">root</a><span>|</span><a href="#36346585">parent</a><span>|</span><a href="#36344420">next</a><span>|</span><label class="collapse" for="c-36347784">[-]</label><label class="expand" for="c-36347784">[1 more]</label></div><br/><div class="children"><div class="content">Oh this! I suffered learning this during college ;)</div><br/></div></div></div></div></div></div></div></div><div id="36344420" class="c"><input type="checkbox" id="c-36344420" checked=""/><div class="controls bullet"><span class="by">neilv</span><span>|</span><a href="#36346262">prev</a><span>|</span><a href="#36343331">next</a><span>|</span><label class="collapse" for="c-36344420">[-]</label><label class="expand" for="c-36344420">[20 more]</label></div><br/><div class="children"><div class="content">Thinking &quot;the only good thing&quot; is understandable, since there&#x27;s a lot of noise, but that talk discourages people from learning a lot of good stuff that&#x27;s buried.<p>Before UML, there were many methodologies.  UML was started by a unified team of some of the most noted OO methodologists.<p>There was a lot of good thinking, but one of the adoption problems we had before UML (as tools developers and methodologists) was that many people got a poor introduction to it, and missed the whole point.<p>For example, on a diagram metamodel that emphasized formalizing and visualizing the relationships among objects... some people would think it was a TPS Cover Sheet task, to laboriously draw their class inheritance hierarchy and summarize their attributes and method signatures, for purely corporate bureaucratic reasons.<p>You could also contrast people who needed to build complex embedded system behavior, for whom Statecharts were a very valuable tool for keeping the model manageable -- distinguished from people who were told to do it when it wasn&#x27;t appropriate, and they just kinda tried to document their code control flow by misusing that same diagram notation.<p>Today, I can&#x27;t blame people for not understanding, since most examples they&#x27;ll now see are incorrect noise, and the current UML spec itself doesn&#x27;t do this reputation any favors.<p>Half-seriously, maybe we could use a reset, in which people who neither know or care what they&#x27;re doing <i>stop being required to go through the motions of pretending to do it</i>.  Also stop trying to have people who don&#x27;t actually use it teach it to students who just want a good grade in the class (for their FAANG job application), and who have little-to-no experience necessary to appreciate the real thing.  Also don&#x27;t make it a marketable resume keyword.  Then the only people who will be doing or talking about it are people who care enough to figure out the genuine merits, with no incentive to pretend.<p>Then, ideally, the only time others will see it is when someone whips out a formalized diagram for something complicated, and proceeds to start explaining it by walking the audience through the diagram... Some people in the audience will get the tingles, as they&#x27;re not only understanding, but they&#x27;re also sensing a very powerful modeling tool that would address some problems that they and their team have in their work.  (Realistically, this would start to happen, but as soon as it becomes a resume keyword or interview ritual, history would repeat, but maybe that time with a larger mitigating mass of people who understand and appreciate.)</div><br/><div id="36345205" class="c"><input type="checkbox" id="c-36345205" checked=""/><div class="controls bullet"><span class="by">Xelbair</span><span>|</span><a href="#36344420">parent</a><span>|</span><a href="#36345066">next</a><span>|</span><label class="collapse" for="c-36345205">[-]</label><label class="expand" for="c-36345205">[9 more]</label></div><br/><div class="children"><div class="content">&gt;There was a lot of good thinking, but one of the adoption problems we had before UML (as tools developers and methodologists) was that many people got a poor introduction to it, and missed the whole point.<p>Not really, UML was doomed from start due to increased time to market metric. And frankly you can read the code if you are working on the already built system. Remember that software usually does not need to be correct, or even well designed to support a business case. It is one of software greatest strengths and weaknesses compared to other disciplines.<p>It does helps in some integration tasks, and works decently as schema definition language that&#x27;s format agnostic.<p>I&#x27;ll also concede that state diagrams are good, but well.. they are also quite simple.<p>Then there&#x27;s readability issue - unless you worked tons with UML you WILL make mistakes when it comes to object relationship counts, and there&#x27;s a lot of other non-obvious gotchas for newcomers(i used to teach reading entity relationship diagrams to non-technical people so they could understand the model they were working with, as it was a part of legal bill).<p>Not to mention that only proponents of UML that i&#x27;ve personally met, were people who were stuck in academia, and never worked on any real software product..<p>And even for R&amp;D work on a harder problems it&#x27;s usually easier to write a toy side project and test solutions.<p>Code you write in such toy project IS an entity relationship model. Tests, and example usage is a happy path of sequence.
etc.</div><br/><div id="36345613" class="c"><input type="checkbox" id="c-36345613" checked=""/><div class="controls bullet"><span class="by">neilv</span><span>|</span><a href="#36344420">root</a><span>|</span><a href="#36345205">parent</a><span>|</span><a href="#36345887">next</a><span>|</span><label class="collapse" for="c-36345613">[-]</label><label class="expand" for="c-36345613">[3 more]</label></div><br/><div class="children"><div class="content">You might enjoy looking a little deeper.  For one example:<p>&gt; <i>I&#x27;ll also concede that state diagrams are good, but well.. they are also quite simple.</i><p>One of the goals of state modeling is to simplify.  A sufficient metamodel will include (in addition to states and transitions on events that people might see in automata theory and misc. CS education) less-simple features like concurrency, superstates, transition guards, maybe real-time constraints.<p>When you need a nontrivial system to actually work, in all cases, (not just toss your sprint task over the wall, and then do bug tasks later) good use of the abstractions of this &quot;simple&quot; diagram, and inspecting it, will tend to avert problems that even an unusually conscientious programmer might miss in just code.  And it also helps communicate less-ambiguously to others who come later and need to evolve the code.  Unlike formal proofs, it&#x27;s pretty accessible to read.<p>(It can be <i>too</i> accessible, in that people who are accustomed to seeing hand-wavy business diagrams with ad hoc notation used inconsistently think they also get the gist of this diagram, while not realizing how much more rigorous it is.  But that&#x27;s not a big problem -- you just have to walk them through it, ask questions to confirm facts expressed, emphasize when something has to be precise and exhaustive, etc.  The problems are more when the diagram is poor, yet the technical appearance confers an undeserved aura of respectability, and people who can&#x27;t tell the difference, act on that, but that&#x27;s not unique to these diagrams.)</div><br/><div id="36345867" class="c"><input type="checkbox" id="c-36345867" checked=""/><div class="controls bullet"><span class="by">theK</span><span>|</span><a href="#36344420">root</a><span>|</span><a href="#36345613">parent</a><span>|</span><a href="#36347998">next</a><span>|</span><label class="collapse" for="c-36345867">[-]</label><label class="expand" for="c-36345867">[1 more]</label></div><br/><div class="children"><div class="content">&gt; good use of the abstractions of this &quot;simple&quot; diagram, and inspecting it, will tend to avert problems that even an unusually conscientious programmer might miss in just code<p>Very good point. If you have expertly written UML and an expert viewer, they will get quite a lot out of it. One of the biggest issues I have seen with UML documentation is that it is extremely difficult to keep it in sync with what the actual implementation does. In one of my past jobs we actually had started an effort to quelch this by generating plantml from code but it never really came to fruition.</div><br/></div></div><div id="36347998" class="c"><input type="checkbox" id="c-36347998" checked=""/><div class="controls bullet"><span class="by">Xelbair</span><span>|</span><a href="#36344420">root</a><span>|</span><a href="#36345613">parent</a><span>|</span><a href="#36345867">prev</a><span>|</span><a href="#36345887">next</a><span>|</span><label class="collapse" for="c-36347998">[-]</label><label class="expand" for="c-36347998">[1 more]</label></div><br/><div class="children"><div class="content">I used those features, i used to work with UML, and as i said - even teach how to read it to non-technical folks.<p>It helps in very niche cases - as i said mostly state diagrams, and non-trivial data models when you have to interop with different systems, or define a common data model. Haven&#x27;t worked with designing protocols, but that&#x27;s basically a committee work..<p>That does not change the fact that it is useless for 99.9%, or higher, of typical dev work, for typical dev systems - which are basically CRUD systems with some fluff. This is the biggest barrier for UML to gain traction, and it is completely incompatible with that.<p>And that&#x27;s disregarding parity of diagrams with codebase - there&#x27;s a reason why a lot of codebases reduce comments - as they go out of date pretty fast.</div><br/></div></div></div></div><div id="36345887" class="c"><input type="checkbox" id="c-36345887" checked=""/><div class="controls bullet"><span class="by">zby</span><span>|</span><a href="#36344420">root</a><span>|</span><a href="#36345205">parent</a><span>|</span><a href="#36345613">prev</a><span>|</span><a href="#36345947">next</a><span>|</span><label class="collapse" for="c-36345887">[-]</label><label class="expand" for="c-36345887">[3 more]</label></div><br/><div class="children"><div class="content">Is ERD part of UML? I find ERDs useful representations of databases. They can be generated automatically and are very good for quickly locating the right tables for a query. So I wanted to add a comment stating this to the parent - but  then I googled to check if they really are part of UML - and it seems that they predate UML and are not really related.</div><br/><div id="36346031" class="c"><input type="checkbox" id="c-36346031" checked=""/><div class="controls bullet"><span class="by">codeulike</span><span>|</span><a href="#36344420">root</a><span>|</span><a href="#36345887">parent</a><span>|</span><a href="#36346028">next</a><span>|</span><label class="collapse" for="c-36346031">[-]</label><label class="expand" for="c-36346031">[1 more]</label></div><br/><div class="children"><div class="content">Correct uml didn&#x27;t have anything to say about relational databases.<p>I use two types of diagrams:<p>Erds<p>and<p>Random blocks and arrows and icons that mean whatever I want them to mean for that particular diagram, based on whatever concept I want to communicate at that point. Maybe it&#x27;s network architecture, maybe it&#x27;s dataflows, maybe it&#x27;s software components. Each diagram comes with some text explaining what it represents.</div><br/></div></div><div id="36346028" class="c"><input type="checkbox" id="c-36346028" checked=""/><div class="controls bullet"><span class="by">neilv</span><span>|</span><a href="#36344420">root</a><span>|</span><a href="#36345887">parent</a><span>|</span><a href="#36346031">prev</a><span>|</span><a href="#36345947">next</a><span>|</span><label class="collapse" for="c-36346028">[-]</label><label class="expand" for="c-36346028">[1 more]</label></div><br/><div class="children"><div class="content">A subset of UML&#x27;s static object modeling diagram notation (which they adapted from OMT) can be used like ERDs, for a relational database without an ORM.</div><br/></div></div></div></div><div id="36345947" class="c"><input type="checkbox" id="c-36345947" checked=""/><div class="controls bullet"><span class="by">tomohawk</span><span>|</span><a href="#36344420">root</a><span>|</span><a href="#36345205">parent</a><span>|</span><a href="#36345887">prev</a><span>|</span><a href="#36345066">next</a><span>|</span><label class="collapse" for="c-36345947">[-]</label><label class="expand" for="c-36345947">[2 more]</label></div><br/><div class="children"><div class="content">&gt; increased time to market<p>I&#x27;ve seen people spend days and days trying to save a few hours of paper design time.<p>We often do quick paper or marker board designs, which often have some UML.  You don&#x27;t want to spend more than 10% of your time on this, but it can save quite a bit of time to market.  If someone <i>really</i> wants the design saved somewhere, we just take a pic and upload it.</div><br/><div id="36346504" class="c"><input type="checkbox" id="c-36346504" checked=""/><div class="controls bullet"><span class="by">ajmurmann</span><span>|</span><a href="#36344420">root</a><span>|</span><a href="#36345947">parent</a><span>|</span><a href="#36345066">next</a><span>|</span><label class="collapse" for="c-36346504">[-]</label><label class="expand" for="c-36346504">[1 more]</label></div><br/><div class="children"><div class="content">I think you are right and it depends so much on what you are building and in what context.<p>If shipping is expensive, you build something complex and correctness matters, you want to go all in on design and verification. You might even want to use TLA+ to verify your algorithms beforehand.<p>If you build a SaaS app that people use for leisure and is mostly CRUD, you probably don&#x27;t need UML diagrams for the vast majority of your work. Exceptions will be the larger systems design where you still need to plan things like DB sharding approach, services etc.</div><br/></div></div></div></div></div></div><div id="36345066" class="c"><input type="checkbox" id="c-36345066" checked=""/><div class="controls bullet"><span class="by">mikepurvis</span><span>|</span><a href="#36344420">parent</a><span>|</span><a href="#36345205">prev</a><span>|</span><a href="#36347215">next</a><span>|</span><label class="collapse" for="c-36345066">[-]</label><label class="expand" for="c-36345066">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if there&#x27;s a parallel here with the journey that some people go on with respect to design documentation in general. In can be easy to have a mandate from on high that your process should be research -&gt; planning -&gt; design -&gt; review -&gt; implementation -&gt; review -&gt; ship, and that the design doc is the key deliverable between the design and implementation stages. You can even argue that this is an &quot;agile&quot; process, if there&#x27;s a feedback loop that permits the design to be revised as further discovery emerges during implementation.<p>But the reality is that an awful lot of the software we build just isn&#x27;t complex enough to warrant all this ceremony. It&#x27;s not branchy, there&#x27;s no significant error handling to talk about, no big new dependencies being added, no security implications, no long-term maintenance of an external interface— it&#x27;s just grabbing widgets from pile A, frobnicating them, and dropping them on pile B. There&#x27;s barely enough there to even <i>unit test</i> much less write a &quot;design doc&quot; about and agonize over in a meeting with bigwigs.<p>And unfortunately a lot of the projects that junior developers start out with look exactly like this. Boring, obvious code that does one thing in the exact boring, obvious way that you&#x27;d expect. So it&#x27;s easy to fall out of the habit of thinking intentionally about design, until you&#x27;re suddenly faced with a big thorny problem that legitimately has multiple paths forward, and what starts as a rubber-duck conversation with the person beside you eventually becomes &quot;hmm... I think I need to write down a page or two that describes these options, gives background on why the choice matters, describes why the selection was made that was made; then maybe afterward I&#x27;ll circulate that document to my colleagues for their review and thumbs-up, because maybe there&#x27;s something I&#x27;m overlooking here that they could contribute to?&quot;<p>Oh wait.</div><br/></div></div><div id="36347215" class="c"><input type="checkbox" id="c-36347215" checked=""/><div class="controls bullet"><span class="by">esfandia</span><span>|</span><a href="#36344420">parent</a><span>|</span><a href="#36345066">prev</a><span>|</span><a href="#36345591">next</a><span>|</span><label class="collapse" for="c-36347215">[-]</label><label class="expand" for="c-36347215">[1 more]</label></div><br/><div class="children"><div class="content">Definitely, bad diagrams (as opposed to bad diagram notation) give UML a bad name. Your example of the misuse of state diagrams as a glorified flowchart is something I see very often.<p>Undergraduate students probably don&#x27;t have the experience and design maturity to fully appreciate when and how to use most UML diagrams. I think you need to get stuck at design problems a few times before you can appreciate the need to capture ideas using the right diagram, and then you might be ready to adopt some standard so you can share your design decisions with others in a way that correctly captures and conveys just the right amount of detail.</div><br/></div></div><div id="36345591" class="c"><input type="checkbox" id="c-36345591" checked=""/><div class="controls bullet"><span class="by">0x69420</span><span>|</span><a href="#36344420">parent</a><span>|</span><a href="#36347215">prev</a><span>|</span><a href="#36345301">next</a><span>|</span><label class="collapse" for="c-36345591">[-]</label><label class="expand" for="c-36345591">[3 more]</label></div><br/><div class="children"><div class="content">&quot;real UML has never been tried&quot;<p>significantly more interesting technological failures deserve dibs on this excuse</div><br/><div id="36345786" class="c"><input type="checkbox" id="c-36345786" checked=""/><div class="controls bullet"><span class="by">neilv</span><span>|</span><a href="#36344420">root</a><span>|</span><a href="#36345591">parent</a><span>|</span><a href="#36345301">next</a><span>|</span><label class="collapse" for="c-36345786">[-]</label><label class="expand" for="c-36345786">[2 more]</label></div><br/><div class="children"><div class="content">Some of these methodologies and their tools have been used very successfully.  By people who built complex systems that really needed to come together and work correctly.<p>I&#x27;m addressing the masses of us Webrogrammers, who classify all that space as &quot;UML&quot;, and dismiss it.  Not everyone is just going to be tossing (ChatGPT-assisted) sprint tasks over the wall, while calculating when to make their next job hop.  Some teams will have to build complex things that work, and they can benefit from informed and judicious use of abstractions and views on the system.</div><br/><div id="36346702" class="c"><input type="checkbox" id="c-36346702" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36344420">root</a><span>|</span><a href="#36345786">parent</a><span>|</span><a href="#36345301">next</a><span>|</span><label class="collapse" for="c-36346702">[-]</label><label class="expand" for="c-36346702">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m addressing the masses of us Webrogrammers, who classify all that space as &quot;UML&quot;, and dismiss it. Not everyone is just going to be tossing (ChatGPT-assisted) sprint tasks over the wall, while calculating when to make their next job hop. Some teams will have to build complex things that work, and they can benefit from informed and judicious use of abstractions and views on the system.<p>On the contrary, people who are doing routine webdev are the ones who can afford the overhead of doing this nonsense, whereas for people who actually have to make something complex that works it will sink them.</div><br/></div></div></div></div></div></div><div id="36345301" class="c"><input type="checkbox" id="c-36345301" checked=""/><div class="controls bullet"><span class="by">jacobr1</span><span>|</span><a href="#36344420">parent</a><span>|</span><a href="#36345591">prev</a><span>|</span><a href="#36346184">next</a><span>|</span><label class="collapse" for="c-36345301">[-]</label><label class="expand" for="c-36345301">[1 more]</label></div><br/><div class="children"><div class="content">Part of the disconnect is formal modeling methods vs informal. There is tremendous value in having a shared understanding of the architecture of system such as how components interact, the data model and any type of sequence or state modeling if needed. That can sometimes be accomplished just with ephemeral whiteboard diagrams and sometimes more complex situations require deeper analysis.<p>The challenge comes when trying to document the entirety of the system, and keep that up to date. The overhead is too high and complexity is such that it defeats the value of a model used to communicate shared understanding.</div><br/></div></div><div id="36346184" class="c"><input type="checkbox" id="c-36346184" checked=""/><div class="controls bullet"><span class="by">galaxyLogic</span><span>|</span><a href="#36344420">parent</a><span>|</span><a href="#36345301">prev</a><span>|</span><a href="#36346598">next</a><span>|</span><label class="collapse" for="c-36346184">[-]</label><label class="expand" for="c-36346184">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Before UML, there were many methodologies.<p>UML really wasn&#x27;t a methodology. It was a &quot;visual modeling language&quot; telling you how you should draw a picture of a code construct.<p>It didn&#x27;t give much (if any?) advise on which development tasks you should do in which order. It was just a TOOL that could be used as part of your SW development activities.<p>I&#x27;m not sure how people used it. Did they first draw the picture and then code, or vice versa? Or maybe drawing the pictures was optional? A &quot;Software Development Method&quot; should answer such questions, among others.<p>A note about words: &quot;Methodology&quot; means something like &quot;study of methods&quot;. A more proper word for individual documented or prescribed approaches to how to develop software would be simply &quot;method&quot;. A &quot;method&quot; tells you how to do something.</div><br/></div></div><div id="36346598" class="c"><input type="checkbox" id="c-36346598" checked=""/><div class="controls bullet"><span class="by">commandlinefan</span><span>|</span><a href="#36344420">parent</a><span>|</span><a href="#36346184">prev</a><span>|</span><a href="#36345764">next</a><span>|</span><label class="collapse" for="c-36346598">[-]</label><label class="expand" for="c-36346598">[1 more]</label></div><br/><div class="children"><div class="content">I like the class diagram notation, although I get frustrated at the tendency to try to auto-generate it, which ends up including way more detail than is useful.</div><br/></div></div><div id="36345764" class="c"><input type="checkbox" id="c-36345764" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#36344420">parent</a><span>|</span><a href="#36346598">prev</a><span>|</span><a href="#36345959">next</a><span>|</span><label class="collapse" for="c-36345764">[-]</label><label class="expand" for="c-36345764">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Half-seriously, maybe we could use a reset, in which people who neither know or care what they&#x27;re doing stop being required to go through the motions of pretending to do it.<p>UML.  Use what you need, but <i>need what you use</i>.<p>Come to think of it, that probably applies to abstraction.  And threads.  And probably several other things.</div><br/></div></div><div id="36345959" class="c"><input type="checkbox" id="c-36345959" checked=""/><div class="controls bullet"><span class="by">bsenftner</span><span>|</span><a href="#36344420">parent</a><span>|</span><a href="#36345764">prev</a><span>|</span><a href="#36343331">next</a><span>|</span><label class="collapse" for="c-36345959">[-]</label><label class="expand" for="c-36345959">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like you never had to deliver something created with that god awful Rational Rose crapware. Who&#x27;s genius idea was to use UML as a code skeleton generator? That is a perfect the recipe to guarantee your non-lead developers never gain any ownership nor intimacy with the software they are working on.<p>The only organizations using UML were bureaucratic heavy nightmare places to work too.</div><br/></div></div></div></div><div id="36343331" class="c"><input type="checkbox" id="c-36343331" checked=""/><div class="controls bullet"><span class="by">thesnide</span><span>|</span><a href="#36344420">prev</a><span>|</span><a href="#36346740">next</a><span>|</span><label class="collapse" for="c-36343331">[-]</label><label class="expand" for="c-36343331">[1 more]</label></div><br/><div class="children"><div class="content">I discovered FMC some time ago, and it really feels &quot;UML, the good parts&quot;.<p>Fundamental Modeling Concepts
<a href="http:&#x2F;&#x2F;fmc-modeling.org&#x2F;" rel="nofollow noreferrer">http:&#x2F;&#x2F;fmc-modeling.org&#x2F;</a><p>Used consistently it really helps a lingua franca across teams. Which was the UML aim all along, but it got caught in into &quot;Enterprise Bloat&quot; (like SOAP or XML)</div><br/></div></div><div id="36346740" class="c"><input type="checkbox" id="c-36346740" checked=""/><div class="controls bullet"><span class="by">mhandley</span><span>|</span><a href="#36343331">prev</a><span>|</span><a href="#36343535">next</a><span>|</span><label class="collapse" for="c-36346740">[-]</label><label class="expand" for="c-36346740">[5 more]</label></div><br/><div class="children"><div class="content">Sequence diagrams are very useful, but UML just adopted a representation that already existed decades before.  For example, the original 1981 TCP specification in RFC 793 [0] has ASCII sequence diagrams (see figures 7 to 14, etc).  I don&#x27;t know if they predate that - less from that era is online - but I wouldn&#x27;t be surprised.<p>[0] <a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc793" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc793</a><p>Edit: there are a form of sequence diagram in an early FTP specification from 1971:
<a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc172.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc172.html</a></div><br/><div id="36347872" class="c"><input type="checkbox" id="c-36347872" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#36346740">parent</a><span>|</span><a href="#36346846">next</a><span>|</span><label class="collapse" for="c-36347872">[-]</label><label class="expand" for="c-36347872">[3 more]</label></div><br/><div class="children"><div class="content">Sequence and activity diagrams were already present in Jacobsons original method, which again is based on the &quot;Ericsson Approach&quot; (originating in 1967), long before UML; they were called interaction diagram and state transition graph.</div><br/><div id="36349852" class="c"><input type="checkbox" id="c-36349852" checked=""/><div class="controls bullet"><span class="by">cachvico</span><span>|</span><a href="#36346740">root</a><span>|</span><a href="#36347872">parent</a><span>|</span><a href="#36346846">next</a><span>|</span><label class="collapse" for="c-36349852">[-]</label><label class="expand" for="c-36349852">[2 more]</label></div><br/><div class="children"><div class="content">Who&#x27;s Jacobson? Google doesn&#x27;t turn anything up.<p>Neither does &quot;Ericsson Approach&quot; for that matter..</div><br/><div id="36351176" class="c"><input type="checkbox" id="c-36351176" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#36346740">root</a><span>|</span><a href="#36349852">parent</a><span>|</span><a href="#36346846">next</a><span>|</span><label class="collapse" for="c-36351176">[-]</label><label class="expand" for="c-36351176">[1 more]</label></div><br/><div class="children"><div class="content">This guy <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ivar_Jacobson" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ivar_Jacobson</a></div><br/></div></div></div></div></div></div><div id="36346846" class="c"><input type="checkbox" id="c-36346846" checked=""/><div class="controls bullet"><span class="by">esfandia</span><span>|</span><a href="#36346740">parent</a><span>|</span><a href="#36347872">prev</a><span>|</span><a href="#36343535">next</a><span>|</span><label class="collapse" for="c-36346846">[-]</label><label class="expand" for="c-36346846">[1 more]</label></div><br/><div class="children"><div class="content">Exactly, UML mostly borrowed from existing representations and its purpose was standardizing semantics and providing some consistency among the diagrams.</div><br/></div></div></div></div><div id="36343535" class="c"><input type="checkbox" id="c-36343535" checked=""/><div class="controls bullet"><span class="by">MilStdJunkie</span><span>|</span><a href="#36346740">prev</a><span>|</span><a href="#36353114">next</a><span>|</span><label class="collapse" for="c-36343535">[-]</label><label class="expand" for="c-36343535">[3 more]</label></div><br/><div class="children"><div class="content">Yeah, Mermaid gets it. Mermaid . . wait a second . . oh, ok, these are the same people that do Mermaid.js, they&#x27;re just trying to make a living doing it.<p>Another useful chart type provided by Mermaid.js is the git diagram, which I use <i>all the time</i> when brainstorming change processes, especially for other folks who might not be git-conversant.<p><a href="https:&#x2F;&#x2F;mermaid.js.org&#x2F;syntax&#x2F;gitgraph.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;mermaid.js.org&#x2F;syntax&#x2F;gitgraph.html</a></div><br/><div id="36344170" class="c"><input type="checkbox" id="c-36344170" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#36343535">parent</a><span>|</span><a href="#36353114">next</a><span>|</span><label class="collapse" for="c-36344170">[-]</label><label class="expand" for="c-36344170">[2 more]</label></div><br/><div class="children"><div class="content">I find Mermaid&#x27;s syntax difficult to use and understand past the simplest examples. I&#x27;ve also run into some strange edge cases with it, but can&#x27;t remember the details right now.<p>Out of these text-to-diagram tools, D2&#x27;s syntax seems the friendliest to me. See <a href="https:&#x2F;&#x2F;text-to-diagram.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;text-to-diagram.com&#x2F;</a>.</div><br/><div id="36345313" class="c"><input type="checkbox" id="c-36345313" checked=""/><div class="controls bullet"><span class="by">MilStdJunkie</span><span>|</span><a href="#36343535">root</a><span>|</span><a href="#36344170">parent</a><span>|</span><a href="#36353114">next</a><span>|</span><label class="collapse" for="c-36345313">[-]</label><label class="expand" for="c-36345313">[1 more]</label></div><br/><div class="children"><div class="content">Is there a way to get a git diagram out of D2? It does have nicely streamlined syntax.<p>One thing that worries me is that the profusion of text-based graph description languages will result in a family of software that&#x27;s unparseable due to its success. We have Graphviz, GNUplot, PlantUML, BlockDiag, Mermaid, Kroki, Vega, and too many others to count - but we don&#x27;t have a Pandoc.</div><br/></div></div></div></div></div></div><div id="36353114" class="c"><input type="checkbox" id="c-36353114" checked=""/><div class="controls bullet"><span class="by">justsayinghi</span><span>|</span><a href="#36343535">prev</a><span>|</span><a href="#36345153">next</a><span>|</span><label class="collapse" for="c-36353114">[-]</label><label class="expand" for="c-36353114">[1 more]</label></div><br/><div class="children"><div class="content">I actually used a sequence diagram today. I put it together for a meeting, to provide some visual guidance while descussing the architecture of a component, and the expected inputs and outputs of it. Helpful for aligning expectations and to spark more dialog.<p>I also use hierarchy diagrams, but a lot less often. Those are used for documenting the architecure of classes that can be annoying to navigate their code through.</div><br/></div></div><div id="36345153" class="c"><input type="checkbox" id="c-36345153" checked=""/><div class="controls bullet"><span class="by">ThinkBeat</span><span>|</span><a href="#36353114">prev</a><span>|</span><a href="#36352611">next</a><span>|</span><label class="collapse" for="c-36345153">[-]</label><label class="expand" for="c-36345153">[2 more]</label></div><br/><div class="children"><div class="content">I thought UML was pretty great when it came out. 
It attempted to establish a uniform manner to model
and communicate out software models &#x2F; systems.<p>I still think it is great.
People who never learned about UML tend to reinvent
some such thing when they wish to communicate the same
structures and information.<p>Then you end up with 10 different people drawing approximately
the same information in 10 different forms, and all will
require some level of explanation of notation and grammar
for others to grok it.<p>A class diagram can contain a lot of rather valuable information.<p>I do agree that sequence diagrams are great, but if you rip
them out of context and throw the rest in the bin it can only
partially communicate, whereas if you had the object model to
study as well as the sequence diagrams new connections can be
quickly made.<p>To this day I prefer to create my object structures in a UML
diagram. Plenty of software takes it creates the code, or 
takes the code and produces the diagram.<p>I love creating the diagram(s) when I first start working on an
existing system.<p>What I have seen of code generation off of sequence diagrams have
bit hit or miss. more miss.   But reverse engineering sequence diagrams
can be quite revealing.</div><br/><div id="36352369" class="c"><input type="checkbox" id="c-36352369" checked=""/><div class="controls bullet"><span class="by">snapdaddy</span><span>|</span><a href="#36345153">parent</a><span>|</span><a href="#36352611">next</a><span>|</span><label class="collapse" for="c-36352369">[-]</label><label class="expand" for="c-36352369">[1 more]</label></div><br/><div class="children"><div class="content">I agree completely. I tend to do &#x27;UML light&#x27;, where I don&#x27;t worry about the finer details (e.g. marking fields public or private). The best solution is one where I can sketch out the outlines of a class and have some tool automatically generate UML which I can then edit.<p>And C4 diagrams are great for explaining software architecture, which wouldn&#x27;t have been possible without UML and esp. class diagrams.</div><br/></div></div></div></div><div id="36352611" class="c"><input type="checkbox" id="c-36352611" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#36345153">prev</a><span>|</span><a href="#36344211">next</a><span>|</span><label class="collapse" for="c-36352611">[-]</label><label class="expand" for="c-36352611">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve use sequence diagrams a few times. I find any kind of diagram tooling to be a tedious time sink. The resulting output is a talking point at best. Some window dressing for a presentation or internal document. Fluff you add to impress some easily impressed managers or clients. I always feel slightly dirty doing stuff like this. I have UML distilled on my shelf. A signed copy even. Haven&#x27;t opened it in over two decades. It&#x27;s obsolete.<p>Diagrams are communication and marketing assets at best. They are not creative tools. You create them for other people; not for yourself. And it takes a lot of effort to create them. If you measure the value of your time in dollars per hour (as your clients&#x2F;employer should be doing), a good diagram can be several hours of work. So, it&#x27;s expensive. A few hundred dollars is nothing.<p>Next time you see a diagram, ask yourself the question &quot;would I pay 300$ for this thing?&quot;. In my case, the answer predictably is &quot;hell no&quot; 100% of the time. Asking the question is kind of answering it. Diagrams are rarely helpful. Either they are way to simple to add much value or way to detailed and hard to understand. There seems no middle ground here. So, you have three or four things with some arrows and labels. Well, yay! Tell me something I didn&#x27;t know already.<p>Diagrams are low value window dressing. A literal waste of time and money. I do them rarely, reluctantly, and only when people really insist on them (and I&#x27;ll push back a little). I find tools in this space tedious and frustratingly slow to use. I have more interesting things to do typically. If I do them at all, they are going to be a quick and dirty job.<p>It&#x27;s not just me. Objectively, diagrams are very uncommon in software development these days. They are not part of regular software development processes, clients don&#x27;t ask for them anymore, the vast majority of projects (and close to 100% of OSS projects) don&#x27;t have them, etc.</div><br/><div id="36353293" class="c"><input type="checkbox" id="c-36353293" checked=""/><div class="controls bullet"><span class="by">self</span><span>|</span><a href="#36352611">parent</a><span>|</span><a href="#36344211">next</a><span>|</span><label class="collapse" for="c-36353293">[-]</label><label class="expand" for="c-36353293">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And it takes a lot of effort to create them.<p>Have you tried mermaidjs?  It&#x27;s probably related to mermaidchart.com -- I don&#x27;t know.  The first sequence diagram in the article boils down to this:<p><pre><code>    sequenceDiagram
      Customer-&gt;&gt;Bank: Login request
      Bank--&gt;&gt;Customer: Login approval
</code></pre>
with a fancier image for the customer than a box.  Try it out at <a href="https:&#x2F;&#x2F;mermaid.live" rel="nofollow noreferrer">https:&#x2F;&#x2F;mermaid.live</a> (linked from <a href="https:&#x2F;&#x2F;mermaid.js.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;mermaid.js.org&#x2F;</a>)<p>Or this one, from a service I worked on a couple of years ago:<p><pre><code>    sequenceDiagram
      Title: Service Signup
      autonumber
      User -&gt;&gt; App: User enters email address and password
      App -&gt;&gt; Server: Makes API call to register the user
      alt is not registered or already registered
        Server -&gt;&gt; App: Sends a token for authenticated API calls
        App -&gt;&gt; App: Generates unique ID
        App -&gt;&gt; Server: Makes API call to link user&#x27;s account with unique ID
      else some other error
        Server -&gt;&gt; App: Returns [TODO: add error cases here] error
        App -&gt;&gt; User: Display error
      end

</code></pre>
I hated drawing diagrams with a mouse, but when I found mermaid, I started using sequence diagrams everywhere.<p>&gt; Diagrams are low value window dressing.<p>It&#x27;s about communication, as the article said.  The people who needs the diagrams the most are often not tech-savvy.</div><br/></div></div></div></div><div id="36344211" class="c"><input type="checkbox" id="c-36344211" checked=""/><div class="controls bullet"><span class="by">therealmarv</span><span>|</span><a href="#36352611">prev</a><span>|</span><a href="#36343344">next</a><span>|</span><label class="collapse" for="c-36344211">[-]</label><label class="expand" for="c-36344211">[3 more]</label></div><br/><div class="children"><div class="content">I still remember of a professor in my university who has written also an UML book. He said it will be the most important thing in your software career and you will use it nearly daily in your future as software engineer. I was sceptical because it was too much preaching for my taste. Turns out I was right.<p>20 years later: I used it very seldom and definitely NOT in my daily software development tasks. Actually the sequence diagrams were really the most useful of them all for me too.</div><br/><div id="36344649" class="c"><input type="checkbox" id="c-36344649" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#36344211">parent</a><span>|</span><a href="#36348265">next</a><span>|</span><label class="collapse" for="c-36344649">[-]</label><label class="expand" for="c-36344649">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re lucky if that was the most useless thing you learned. Many peoples&#x27; degrees were useless in their entirety!</div><br/></div></div><div id="36348265" class="c"><input type="checkbox" id="c-36348265" checked=""/><div class="controls bullet"><span class="by">lost_tourist</span><span>|</span><a href="#36344211">parent</a><span>|</span><a href="#36344649">prev</a><span>|</span><a href="#36343344">next</a><span>|</span><label class="collapse" for="c-36348265">[-]</label><label class="expand" for="c-36348265">[1 more]</label></div><br/><div class="children"><div class="content">state diagrams and sequence charts for me, for sure</div><br/></div></div></div></div><div id="36343344" class="c"><input type="checkbox" id="c-36343344" checked=""/><div class="controls bullet"><span class="by">lunatuna</span><span>|</span><a href="#36344211">prev</a><span>|</span><a href="#36343972">next</a><span>|</span><label class="collapse" for="c-36343344">[-]</label><label class="expand" for="c-36343344">[2 more]</label></div><br/><div class="children"><div class="content">This title and article feels plucked out of my brain. Most of my work is a lot of integrations and the best way to get a room full of devs to get what is going on is via sequence diagrams. Every other method, formal or made up, is weak compared to a basic sequence diagram. You can expand from there if needs be but I find it gets people thinking in a more complete way, gets the details out and what ifs and what abouts, and then you have a nice target that teams hit with very high accuracy and completeness.<p>It is one of the few (only) diagram types that is easy to draw and fairly close to the real world implementation. Most other formal approaches are wonky abstractions that only true practitioners can make sense of.</div><br/><div id="36343454" class="c"><input type="checkbox" id="c-36343454" checked=""/><div class="controls bullet"><span class="by">knsv</span><span>|</span><a href="#36343344">parent</a><span>|</span><a href="#36343972">next</a><span>|</span><label class="collapse" for="c-36343454">[-]</label><label class="expand" for="c-36343454">[1 more]</label></div><br/><div class="children"><div class="content">I agree, not having to be an expert in order to understand is important!</div><br/></div></div></div></div><div id="36343972" class="c"><input type="checkbox" id="c-36343972" checked=""/><div class="controls bullet"><span class="by">tonnydourado</span><span>|</span><a href="#36343344">prev</a><span>|</span><a href="#36344336">next</a><span>|</span><label class="collapse" for="c-36343972">[-]</label><label class="expand" for="c-36343972">[9 more]</label></div><br/><div class="children"><div class="content">I work with non-distributed (ish) systems, and I use watered down class diagrams much more often than sequence diagrams.<p>But even when I was working on more distributed systems, I found more value in state machines and simplified class diagrams, actually. I think most cases where you&#x27;re using a sequence diagram, a state machine is a better tool. Both for thought, and for implementation. Surfacing implicit state machines can require some extra upfront design, but if you have a non-trivial amount of states, it&#x27;s pretty much guaranteed to be worth it.</div><br/><div id="36344074" class="c"><input type="checkbox" id="c-36344074" checked=""/><div class="controls bullet"><span class="by">knsv</span><span>|</span><a href="#36343972">parent</a><span>|</span><a href="#36344336">next</a><span>|</span><label class="collapse" for="c-36344074">[-]</label><label class="expand" for="c-36344074">[8 more]</label></div><br/><div class="children"><div class="content">The problem with state machines that I run into often when using them, is &quot;multi-dimensional&quot; states.<p>When managing to get that right they are great, otherwise you get loads of edges...</div><br/><div id="36344152" class="c"><input type="checkbox" id="c-36344152" checked=""/><div class="controls bullet"><span class="by">sidpatil</span><span>|</span><a href="#36343972">root</a><span>|</span><a href="#36344074">parent</a><span>|</span><a href="#36344196">next</a><span>|</span><label class="collapse" for="c-36344152">[-]</label><label class="expand" for="c-36344152">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure what you mean by &quot;multi-dimensional&quot; states. Is it something that statecharts [1] can help with?<p>[1] <a href="https:&#x2F;&#x2F;statecharts.dev&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;statecharts.dev&#x2F;</a></div><br/><div id="36350457" class="c"><input type="checkbox" id="c-36350457" checked=""/><div class="controls bullet"><span class="by">RossBencina</span><span>|</span><a href="#36343972">root</a><span>|</span><a href="#36344152">parent</a><span>|</span><a href="#36345259">next</a><span>|</span><label class="collapse" for="c-36350457">[-]</label><label class="expand" for="c-36350457">[1 more]</label></div><br/><div class="children"><div class="content">UML Statecharts are Harel Statecharts, which are hierarchical state machines. Described here:<p>Statecharts - A visual formalism for complex systems. David Harel. 1987<p><a href="https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;7.-statecharts" rel="nofollow noreferrer">https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;7.-statecharts</a><p>Looks like you can also freely download the paper from here:
<a href="https:&#x2F;&#x2F;www.sciencedirect.com&#x2F;science&#x2F;article&#x2F;pii&#x2F;0167642387900359" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.sciencedirect.com&#x2F;science&#x2F;article&#x2F;pii&#x2F;0167642387...</a></div><br/></div></div><div id="36345259" class="c"><input type="checkbox" id="c-36345259" checked=""/><div class="controls bullet"><span class="by">barrkel</span><span>|</span><a href="#36343972">root</a><span>|</span><a href="#36344152">parent</a><span>|</span><a href="#36350457">prev</a><span>|</span><a href="#36344196">next</a><span>|</span><label class="collapse" for="c-36345259">[-]</label><label class="expand" for="c-36345259">[2 more]</label></div><br/><div class="children"><div class="content">The cross product of multiple state machines, I expect. If you try and use a single state diagram to encode the product of states, everything multiplies.</div><br/><div id="36346141" class="c"><input type="checkbox" id="c-36346141" checked=""/><div class="controls bullet"><span class="by">michaelsbradley</span><span>|</span><a href="#36343972">root</a><span>|</span><a href="#36345259">parent</a><span>|</span><a href="#36344196">next</a><span>|</span><label class="collapse" for="c-36346141">[-]</label><label class="expand" for="c-36346141">[1 more]</label></div><br/><div class="children"><div class="content">That’s where statecharts can help.</div><br/></div></div></div></div></div></div><div id="36344196" class="c"><input type="checkbox" id="c-36344196" checked=""/><div class="controls bullet"><span class="by">tonnydourado</span><span>|</span><a href="#36343972">root</a><span>|</span><a href="#36344074">parent</a><span>|</span><a href="#36344152">prev</a><span>|</span><a href="#36344336">next</a><span>|</span><label class="collapse" for="c-36344196">[-]</label><label class="expand" for="c-36344196">[3 more]</label></div><br/><div class="children"><div class="content">Not sure what you mean by multidimensional states?</div><br/><div id="36345499" class="c"><input type="checkbox" id="c-36345499" checked=""/><div class="controls bullet"><span class="by">hwayne</span><span>|</span><a href="#36343972">root</a><span>|</span><a href="#36344196">parent</a><span>|</span><a href="#36344336">next</a><span>|</span><label class="collapse" for="c-36345499">[-]</label><label class="expand" for="c-36345499">[2 more]</label></div><br/><div class="children"><div class="content">The car can be in drive, neutral, or reverse, the light can be red, green, yellow, or broken, the seatbelt can be off or on. That&#x27;s 24 states.</div><br/><div id="36346395" class="c"><input type="checkbox" id="c-36346395" checked=""/><div class="controls bullet"><span class="by">tonnydourado</span><span>|</span><a href="#36343972">root</a><span>|</span><a href="#36345499">parent</a><span>|</span><a href="#36344336">next</a><span>|</span><label class="collapse" for="c-36346395">[-]</label><label class="expand" for="c-36346395">[1 more]</label></div><br/><div class="children"><div class="content">Ah, ok. That&#x27;s kind of what I meant by upfront design, though. Yeah, mapping this out is gonna suck, but it&#x27;s better than having it hidden in a bunch of ifs.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36344336" class="c"><input type="checkbox" id="c-36344336" checked=""/><div class="controls bullet"><span class="by">smusamashah</span><span>|</span><a href="#36343972">prev</a><span>|</span><a href="#36344983">next</a><span>|</span><label class="collapse" for="c-36344336">[-]</label><label class="expand" for="c-36344336">[3 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;sequencediagram.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;sequencediagram.org&#x2F;</a> is the best text-to-sequence-diagram tool. Its the only one of these which lets you draw sequence diagram with your mouse too and will generate text accordingly. Completely offline (localstorage) and also  supports saving to onedrive and google drive.</div><br/><div id="36346731" class="c"><input type="checkbox" id="c-36346731" checked=""/><div class="controls bullet"><span class="by">tandr</span><span>|</span><a href="#36344336">parent</a><span>|</span><a href="#36344401">next</a><span>|</span><label class="collapse" for="c-36346731">[-]</label><label class="expand" for="c-36346731">[1 more]</label></div><br/><div class="children"><div class="content">This is insanely good, thank you very much for the link! Should be a great tool to &quot;bootstrap&quot; some diagrams during brainstorm meetings, or just to put into documentation, and be able to change them later.</div><br/></div></div><div id="36344401" class="c"><input type="checkbox" id="c-36344401" checked=""/><div class="controls bullet"><span class="by">xnx</span><span>|</span><a href="#36344336">parent</a><span>|</span><a href="#36346731">prev</a><span>|</span><a href="#36344983">next</a><span>|</span><label class="collapse" for="c-36344401">[-]</label><label class="expand" for="c-36344401">[1 more]</label></div><br/><div class="children"><div class="content">Good tool. They really need to change the cursor on hover to give some hint that you can draw arrows that way!</div><br/></div></div></div></div><div id="36344983" class="c"><input type="checkbox" id="c-36344983" checked=""/><div class="controls bullet"><span class="by">ghamelin</span><span>|</span><a href="#36344336">prev</a><span>|</span><a href="#36352692">next</a><span>|</span><label class="collapse" for="c-36344983">[-]</label><label class="expand" for="c-36344983">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. We published a post recently about how to interpret a sequence diagram based on the 7 basic features and how our dev tool makes them automatic and interactive. <a href="https:&#x2F;&#x2F;dev.to&#x2F;appmap&#x2F;quickly-learn-how-new-to-you-code-works-using-sequence-diagrams-h9g" rel="nofollow noreferrer">https:&#x2F;&#x2F;dev.to&#x2F;appmap&#x2F;quickly-learn-how-new-to-you-code-work...</a></div><br/></div></div><div id="36352692" class="c"><input type="checkbox" id="c-36352692" checked=""/><div class="controls bullet"><span class="by">psychoslave</span><span>|</span><a href="#36344983">prev</a><span>|</span><a href="#36344814">next</a><span>|</span><label class="collapse" for="c-36352692">[-]</label><label class="expand" for="c-36352692">[1 more]</label></div><br/><div class="children"><div class="content">UML is great to clarify situations that are harder to grasp with other communication tools. And by communication, I don’t mean only with other, but also with oneself.<p>Cerntainly UML is not always the best tool, but I see no point to pretend it’s a garbage toolbox no one should care about except for the only tool that ever helped for the work you had to do.</div><br/></div></div><div id="36344814" class="c"><input type="checkbox" id="c-36344814" checked=""/><div class="controls bullet"><span class="by">c4mpute</span><span>|</span><a href="#36352692">prev</a><span>|</span><a href="#36344193">next</a><span>|</span><label class="collapse" for="c-36344814">[-]</label><label class="expand" for="c-36344814">[1 more]</label></div><br/><div class="children"><div class="content">I think autogenerating UML from existing code to get an overview over e.g. your database schema, state machine or class hierarchy is fine. Hand-drawn UML is useless busywork, it is usually faster and quicker to just write the code. Also, autogenerated UML doesn&#x27;t go stale as easily, since you can just automatically recreate it.<p>And I agree, the most useful diagram type is a sequence diagram. The rest is often useless because OOP has declined, weird arrow types are unintuitive, language features do not always correspond to UML features and UML tooling doesn&#x27;t fit very well into common software development methods. E.g. you cannot &#x27;git diff&#x27; UML diagrams; while it would be theoretically possible (git diff can take helpers), no software implements this, that I know of.<p>Overall, about UML&#x27;s decline, good riddance. Throwing boxes and arrows at a whiteboard occasionally (without tons of formal semantics) is all anyone needs.</div><br/></div></div><div id="36344193" class="c"><input type="checkbox" id="c-36344193" checked=""/><div class="controls bullet"><span class="by">myth2018</span><span>|</span><a href="#36344814">prev</a><span>|</span><a href="#36343678">next</a><span>|</span><label class="collapse" for="c-36344193">[-]</label><label class="expand" for="c-36344193">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the only good thing UML brought to software development<p>Interesting perspective, which differs from my own experience though. I found some value in class and package diagrams, which proved helpful in detecting problematic relationships between packages at a very early stage. Deployment diagrams have aided me in resource planning and communicating with deployment teams. On the other hand, I&#x27;ve personally never used sequence diagrams beyond academical assignments or simply satisfying my curiosity.<p>However I definitely agree that UML is extremely bloated. It introduced a myriad of problems so that they could sell solutions in the form of courses, books and certifications. Rational&#x27;s acquisition by IBM certainly didn&#x27;t help matters either. And the reference guide by Booch&#x2F;Rumbaugh&#x2F;Jacobson is severely painful to read.</div><br/></div></div><div id="36343678" class="c"><input type="checkbox" id="c-36343678" checked=""/><div class="controls bullet"><span class="by">hcarvalhoalves</span><span>|</span><a href="#36344193">prev</a><span>|</span><a href="#36343392">next</a><span>|</span><label class="collapse" for="c-36343678">[-]</label><label class="expand" for="c-36343678">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Comprehensibility &gt; Comprehensiveness #<p>&gt; The most common failure mode for sequence diagrams is over-complication. (This also is the failure mode for most diagrams, as I wrote in an article on flow charts).<p>Agreed.<p>UML – with the goal of being a graphical language for _complete_ specification of a system (both for code generation as well as to have diagrams generated from code introspection) – has to be exhaustive, therefore fails at showing the big picture.<p>Use of UML that could accommodate multiple levels of abstraction would fix that. I believe this is what C4 [1] tries to achieve with 4 levels of diagram. Unfortunately everybody who invents a new diagram model also reinvents the wheel and throws the entire UML away. One could easily use UML visual language, but just standardise on using the 4 levels diagrams of C4.<p>[1] <a href="https:&#x2F;&#x2F;c4model.com" rel="nofollow noreferrer">https:&#x2F;&#x2F;c4model.com</a></div><br/></div></div><div id="36343392" class="c"><input type="checkbox" id="c-36343392" checked=""/><div class="controls bullet"><span class="by">JohnFen</span><span>|</span><a href="#36343678">prev</a><span>|</span><a href="#36352260">next</a><span>|</span><label class="collapse" for="c-36343392">[-]</label><label class="expand" for="c-36343392">[1 more]</label></div><br/><div class="children"><div class="content">Although I never use any aspect of UML in my work, I absolutely benefitted from learning it. Learning how to model things in UML required me to change the way I broke down and formalized problems and solutions. That change stuck with me, and I&#x27;ve very much benefitted from it, for the rest of my career.</div><br/></div></div><div id="36352260" class="c"><input type="checkbox" id="c-36352260" checked=""/><div class="controls bullet"><span class="by">kitd</span><span>|</span><a href="#36343392">prev</a><span>|</span><a href="#36343507">next</a><span>|</span><label class="collapse" for="c-36352260">[-]</label><label class="expand" for="c-36352260">[1 more]</label></div><br/><div class="children"><div class="content">Sequence diagrams are good when you&#x27;re already inside the system. Showing my age here but IMO, for sketching a high-level view of the whole system and how its components interact,  nothing beats SSADM&#x27;s data flow diagrams. You can go as detailed as you like. Break up parts into a new component:  draw a ring around them, network traffic: note where the flows cross the rings and document the message sizes and rates.<p><i>Sigh</i> Happy days ...</div><br/></div></div><div id="36343507" class="c"><input type="checkbox" id="c-36343507" checked=""/><div class="controls bullet"><span class="by">strictfp</span><span>|</span><a href="#36352260">prev</a><span>|</span><a href="#36352570">next</a><span>|</span><label class="collapse" for="c-36343507">[-]</label><label class="expand" for="c-36343507">[1 more]</label></div><br/><div class="children"><div class="content">Class diagrams and object diagrams are also really useful, for instance when making presentations.<p>The problem with UML is that the industry went overboard with it&#x27;s usage, like it did with pretty much every tech trend.</div><br/></div></div><div id="36352570" class="c"><input type="checkbox" id="c-36352570" checked=""/><div class="controls bullet"><span class="by">hasa</span><span>|</span><a href="#36343507">prev</a><span>|</span><a href="#36343258">next</a><span>|</span><label class="collapse" for="c-36352570">[-]</label><label class="expand" for="c-36352570">[1 more]</label></div><br/><div class="children"><div class="content">I remember times in 90&#x27;s when we planned a software system in UML powered tool called Rational Rose. Oh my god its was clumsy and slow process. But yes, sequence diagrams are very useful tool.</div><br/></div></div><div id="36343258" class="c"><input type="checkbox" id="c-36343258" checked=""/><div class="controls bullet"><span class="by">eurekin</span><span>|</span><a href="#36352570">prev</a><span>|</span><a href="#36343281">next</a><span>|</span><label class="collapse" for="c-36343258">[-]</label><label class="expand" for="c-36343258">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m still waiting intently for debugging tools to be able to create * object * diagrams of an running app. Debuggers are excellent, but I keep forgetting, if the object in question is @Hdj637 or @HU83NS</div><br/></div></div><div id="36343281" class="c"><input type="checkbox" id="c-36343281" checked=""/><div class="controls bullet"><span class="by">jxramos</span><span>|</span><a href="#36343258">prev</a><span>|</span><a href="#36345078">next</a><span>|</span><label class="collapse" for="c-36343281">[-]</label><label class="expand" for="c-36343281">[1 more]</label></div><br/><div class="children"><div class="content">I just referenced the concept of multiplicity in the values of pytest fixtures a single fixture may return just yesterday and I referenced it in the context of UML to make my point. Numerical distinctions in instance counts and collections and what not is a valuable articulation I think UML encapsulates. Maybe there’s other ways to communicate this concept but if someone talks of multiplicity in software design UML is directly where my mind goes.</div><br/></div></div><div id="36345078" class="c"><input type="checkbox" id="c-36345078" checked=""/><div class="controls bullet"><span class="by">brikelly</span><span>|</span><a href="#36343281">prev</a><span>|</span><a href="#36350379">next</a><span>|</span><label class="collapse" for="c-36345078">[-]</label><label class="expand" for="c-36345078">[1 more]</label></div><br/><div class="children"><div class="content">Sequence diagrams are great, but creating them by hand is a pain. It&#x27;s not just manual toil, they also go out of date. AppMap (where I work) can generate them automatically based on runtime analysis of an application: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=8l4-hNih_GQ">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=8l4-hNih_GQ</a></div><br/></div></div><div id="36350379" class="c"><input type="checkbox" id="c-36350379" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#36345078">prev</a><span>|</span><a href="#36347165">next</a><span>|</span><label class="collapse" for="c-36350379">[-]</label><label class="expand" for="c-36350379">[1 more]</label></div><br/><div class="children"><div class="content">UML isn&#x27;t that bad but it isn&#x27;t that good.<p>I was involved in a project based on OMG&#x27;s Meta Object Facility.  The MOF is a tiny system which was designed to be sufficient for bootstrapping an implementation of UML 2 but I found out that the bootstrapping is not so straightforward (I think you have to manifest some objects from UML 1 that doesn&#x27;t exist in UML 2) and there are some chicken-and-egg problems to resolve but I think it would be possible to build something that,  in several stages, can build a complete set of stubs for UML 2 itself as well as any objects defined inside UML 2.  I got my project done without doing the whole bootstrap so I am still wondering...  I&#x27;ve solved so many chicken-and-egg problems that nobody else has and it&#x27;s earned me just about $0 and 0 cents.</div><br/></div></div><div id="36347165" class="c"><input type="checkbox" id="c-36347165" checked=""/><div class="controls bullet"><span class="by">CyrsBel</span><span>|</span><a href="#36350379">prev</a><span>|</span><a href="#36346272">next</a><span>|</span><label class="collapse" for="c-36347165">[-]</label><label class="expand" for="c-36347165">[1 more]</label></div><br/><div class="children"><div class="content">UML is really powerful but definitely could be more simplified to just be basic charts. The problem is that sometimes you need to see the full complexity to be able to start simplifying systems. The real issue involving a decades-old process that gets in the way isn&#x27;t actually UML though it appears at first to fit that description. It&#x27;s actually scrum. Scrum-based methodologies on how to deliver value to the business. Scrum eventually forces engineers to make trade-offs like how thorough their UML and regular flowcharts can be which is not a scalable way to build quality products. The charts should be precisely as complex as is needed to accomplish the business objective and ensure that the business is always able to be in the best starting position possible to continue working on a piece of code or a system with just that documentation as the starting point. Sometimes this does mean that a demo may be just a bunch of UML or simpler flowcharts that have more breadth instead of user functionality.<p>UML makes sure that product functionality knowledge can be more easily restored or understood from an engineering mindset. It encodes a lot of information into the format and simpler options exist too. But I have to say once again that you almost got it right as to which decades-old development methodology is pretty deprecated despite still being in fashion - it&#x27;s not at the diagramming layer, it&#x27;s at the project management layer.</div><br/></div></div><div id="36346272" class="c"><input type="checkbox" id="c-36346272" checked=""/><div class="controls bullet"><span class="by">avodonosov</span><span>|</span><a href="#36347165">prev</a><span>|</span><a href="#36347935">next</a><span>|</span><label class="collapse" for="c-36346272">[-]</label><label class="expand" for="c-36346272">[1 more]</label></div><br/><div class="children"><div class="content">State machine diagram maye useful from time to time.<p>Object diagrams are sometimes great illustrations of how data is structured. I specifically recommend object diagrams, not class diagrams for that. If you are learning unfamiliar system just by reading the code and making user interactions, its easy to loose track what is recorded where. Collecting your observations on a diagram you draw gradually will help to acumulate details and build a clear picture.<p>Maintaining several simple object diagrams for main usage scenarious may help future newcomer developers to quickly grasp the implementation backbone.</div><br/></div></div><div id="36347935" class="c"><input type="checkbox" id="c-36347935" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#36346272">prev</a><span>|</span><label class="collapse" for="c-36347935">[-]</label><label class="expand" for="c-36347935">[1 more]</label></div><br/><div class="children"><div class="content">So we&#x27;re back in the sixties, even 20 years before Objectory, see e.g. <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20060622072014if_&#x2F;http:&#x2F;&#x2F;www.tcrug.org:80&#x2F;Documents&#x2F;PPM02%20final.ppt" rel="nofollow noreferrer">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20060622072014if_&#x2F;http:&#x2F;&#x2F;www.tcr...</a>.</div><br/></div></div></div></div></div></div></div></body></html>