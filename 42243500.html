<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1732611672515" as="style"/><link rel="stylesheet" href="styles.css?v=1732611672515"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://fasterthanli.me/articles/lies-we-tell-ourselves-to-keep-using-golang">Lies we tell ourselves to keep using Golang</a> <span class="domain">(<a href="https://fasterthanli.me">fasterthanli.me</a>)</span></div><div class="subtext"><span>reillyse</span> | <span>44 comments</span></div><br/><div><div id="42243663" class="c"><input type="checkbox" id="c-42243663" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#42243551">next</a><span>|</span><label class="collapse" for="c-42243663">[-]</label><label class="expand" for="c-42243663">[6 more]</label></div><br/><div class="children"><div class="content">Every time I read a critique of Go, I feel the same way: I&#x27;m still going to continue to use it anyways. The reason why I am going to continue to use it anyways is because while I understand that it has plenty of easily documented issues in theory (and that people regularly do actually run into in practice), I still find that it is one of the better programming languages in practice anyways. Some of the things that people commonly list as shortcomings I don&#x27;t agree with (I <i>like</i> the explicit error handling everywhere) and for other things... I often agree, but it doesn&#x27;t bother me much more than the shortcomings of other programming languages, of which there is certainly no shortage.<p>I guess I feel bad for people who are particularly sensitive to the areas that Go does not succeed in, because they are probably going to be complaining about it for the rest of their lives. The truth is though, I don&#x27;t use a bunch of rationale about what is the best programming language to choose which one to work on for a project, I choose a language that I feel works well for me, that I feel I can consistently write good software in, that feels, well, nice to work in. Being a person that values correctness, I do sort of wish that language could be something more like Rust, but for now, it&#x27;s just not, though it&#x27;s not like I hate Rust, it&#x27;s just not what I reach for in a pinch.<p>Enough has been written about how terrible Go is by this point. At least now I know what it&#x27;s like to have been a fan of PHP a few years ago! (That&#x27;s an exaggeration, but it&#x27;s not that big of one in my opinion.)</div><br/><div id="42243725" class="c"><input type="checkbox" id="c-42243725" checked=""/><div class="controls bullet"><span class="by">pif</span><span>|</span><a href="#42243663">parent</a><span>|</span><a href="#42243780">next</a><span>|</span><label class="collapse" for="c-42243725">[-]</label><label class="expand" for="c-42243725">[4 more]</label></div><br/><div class="children"><div class="content">&gt;  I choose a language that I feel works well for me<p>Which is the wisest choice for everyone. Golang is only a problem when a manager imposes it on you.</div><br/><div id="42243736" class="c"><input type="checkbox" id="c-42243736" checked=""/><div class="controls bullet"><span class="by">vasco</span><span>|</span><a href="#42243663">root</a><span>|</span><a href="#42243725">parent</a><span>|</span><a href="#42243780">next</a><span>|</span><label class="collapse" for="c-42243736">[-]</label><label class="expand" for="c-42243736">[3 more]</label></div><br/><div class="children"><div class="content">&quot;Manager imposes it on you&quot; just means you work in a team rather than alone. You can pick whatever you like for side projects, of course you&#x27;re going to use whatever your team uses otherwise.</div><br/><div id="42243804" class="c"><input type="checkbox" id="c-42243804" checked=""/><div class="controls bullet"><span class="by">pif</span><span>|</span><a href="#42243663">root</a><span>|</span><a href="#42243736">parent</a><span>|</span><a href="#42243775">next</a><span>|</span><label class="collapse" for="c-42243804">[-]</label><label class="expand" for="c-42243804">[1 more]</label></div><br/><div class="children"><div class="content">&quot;The key point here is our programmers are Googlers, they’re not researchers. They’re typically, fairly young, fresh out of school, probably learned Java, maybe learned C or C++, probably learned Python. They’re not capable of understanding a brilliant language but we want to use them to build good software. So, the language that we give them has to be easy for them to understand and easy to adopt.&quot;<p>Excerpt of the talk &quot;From Parallel to Concurrent&quot; by Rob Pike from Lang.NEXT 2014<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;uwajp0g-bY4?si=EcOXVaGJ1ObFILb6" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;uwajp0g-bY4?si=EcOXVaGJ1ObFILb6</a><p>People tend to forget that Golang was created _on purpose_ for poor programmers.</div><br/></div></div><div id="42243775" class="c"><input type="checkbox" id="c-42243775" checked=""/><div class="controls bullet"><span class="by">pif</span><span>|</span><a href="#42243663">root</a><span>|</span><a href="#42243736">parent</a><span>|</span><a href="#42243804">prev</a><span>|</span><a href="#42243780">next</a><span>|</span><label class="collapse" for="c-42243775">[-]</label><label class="expand" for="c-42243775">[1 more]</label></div><br/><div class="children"><div class="content">Golang was created on purpose for poor programmers (which casts a doubt about developers actually _liking_ it).<p>Managers who impose such an abomination on their team should just be ashamed of having hired such a team.</div><br/></div></div></div></div></div></div><div id="42243780" class="c"><input type="checkbox" id="c-42243780" checked=""/><div class="controls bullet"><span class="by">tonfreed</span><span>|</span><a href="#42243663">parent</a><span>|</span><a href="#42243725">prev</a><span>|</span><a href="#42243551">next</a><span>|</span><label class="collapse" for="c-42243780">[-]</label><label class="expand" for="c-42243780">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. Every programming language is a tool in your toolbox, and you should choose the appropriate one for the job at hand. For me, that&#x27;s Go around 95% of the time.<p>I have no need to worry about a 24 byte overhead for a slice allocation, if I did have to worry about that, I&#x27;d probably use C or Rust.</div><br/></div></div></div></div><div id="42243551" class="c"><input type="checkbox" id="c-42243551" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#42243663">prev</a><span>|</span><a href="#42243604">next</a><span>|</span><label class="collapse" for="c-42243551">[-]</label><label class="expand" for="c-42243551">[12 more]</label></div><br/><div class="children"><div class="content">This article makes a lot of great points about the shortcomings of Go. I don’t think explicit error handling is one of them however. I’ve previously spoken about my loathing of exception handling because it adds a “magic” layer to things which is way too easy to mess up. From a technical standpoint that isn’t necessarily a good argument, but from a pragmatic standpoint and decades of experience… well I will take explicit error handling which happens exactly where the errors occur every day. You can argue that Rust does it in a more elegant way, and I prefer it for personal projects. For big projects with a lot of developers of various skill level joining and leaving I think Go’s philosophy is one of the sanest approaches to error handling in the modern world.<p>Staying in that lane. In my part of the world Go is seeing adoption that no other “new” language has exactly because of its simplicity. It’s not the best language, but it’s often the best general purpose language because it has a lot of build in opinions which protect you from yourself.</div><br/><div id="42243706" class="c"><input type="checkbox" id="c-42243706" checked=""/><div class="controls bullet"><span class="by">the_gipsy</span><span>|</span><a href="#42243551">parent</a><span>|</span><a href="#42243599">next</a><span>|</span><label class="collapse" for="c-42243706">[-]</label><label class="expand" for="c-42243706">[1 more]</label></div><br/><div class="children"><div class="content">There are several shortcomings with go&#x27;s error handling. The author heavily lies onto rust, so the alternative is not exceptions but a `Result&lt;T, Error&gt;` sum type.<p>No stacktraces and error wrapping forces you to not only invent unique error messages. You must also conceive a unique wrapping message at every call-site so that you can grep the error message and approximate a stacktrace.<p>The weird &quot;return tuple&quot; , which obviously just exists for errors because there is not a single other place where you can use tuples in the language, and the awkward variable initialization rules, make it so that you use the wrong `err` var at some point. E.g. if you want to reassign the result to an existing var, suddenly you have to declare `var err error`, and if `err` already exists then you have to reuse it.<p>There should be an enum type in go, or instead of the bizarre &quot;return tuple&quot; mechanics exclusive for errors, they should have added a better syntax sugar for errors like rust&#x27;s `?` sugar. Instead we have something extremely tedious and quite error prone.<p>&gt; it has a lot of build in opinions which protect you from yourself<p>It does have opinions, but too often they seem to be there to protect the language from being criticized. Sadly, this works, as marketing (lying) is an important factor towards making a PL popular in today&#x27;s market.</div><br/></div></div><div id="42243599" class="c"><input type="checkbox" id="c-42243599" checked=""/><div class="controls bullet"><span class="by">monksy</span><span>|</span><a href="#42243551">parent</a><span>|</span><a href="#42243706">prev</a><span>|</span><a href="#42243680">next</a><span>|</span><label class="collapse" for="c-42243599">[-]</label><label class="expand" for="c-42243599">[1 more]</label></div><br/><div class="children"><div class="content">I would certainly argue against the claim that explicit error handling is far overkill.<p>Where I agree: It forces you to think about all of the possibilities your code might generate. (This is more of a C question than it is with other languages)<p>However, when abstracting blocks of code away, you don&#x27;t always need to handle the error immediently or you may want to handle it down the stack.<p>You&#x27;re giving up a lot of readability in order for the language to be particular.</div><br/></div></div><div id="42243680" class="c"><input type="checkbox" id="c-42243680" checked=""/><div class="controls bullet"><span class="by">abtinf</span><span>|</span><a href="#42243551">parent</a><span>|</span><a href="#42243599">prev</a><span>|</span><a href="#42243601">next</a><span>|</span><label class="collapse" for="c-42243680">[-]</label><label class="expand" for="c-42243680">[3 more]</label></div><br/><div class="children"><div class="content">Having programmed for over 30 years, including nearly a decade of C#, I would say exceptions are one of the worst ideas in all of programming.<p>They are just horrific gotos that any library can invoke against your code. They are pretty much never, ever handled correctly. And nearly always, after an exception is “handled”, the application is actually in an unknown state and cannot be reasoned about.<p>Even junior engineers have a trivial time debugging most go errors, while even experienced principles struggle with figuring out the true cause of a Java exception.</div><br/><div id="42243777" class="c"><input type="checkbox" id="c-42243777" checked=""/><div class="controls bullet"><span class="by">rand_r</span><span>|</span><a href="#42243551">root</a><span>|</span><a href="#42243680">parent</a><span>|</span><a href="#42243601">next</a><span>|</span><label class="collapse" for="c-42243777">[-]</label><label class="expand" for="c-42243777">[2 more]</label></div><br/><div class="children"><div class="content">&gt; never handled correctly<p>I’ve seen this argument, but if you look at real golang code and examples, it’s just a bunch of “if err &lt;&gt; nill” copy pasta on every line. It’s true that handling errors is painstaking, but nothing about golang makes that problem easier. It ends up being a manual, poor-man’s stack-trace with no real advantage over an automatically generated one like in Python.</div><br/><div id="42243802" class="c"><input type="checkbox" id="c-42243802" checked=""/><div class="controls bullet"><span class="by">swiftcoder</span><span>|</span><a href="#42243551">root</a><span>|</span><a href="#42243777">parent</a><span>|</span><a href="#42243601">next</a><span>|</span><label class="collapse" for="c-42243802">[-]</label><label class="expand" for="c-42243802">[1 more]</label></div><br/><div class="children"><div class="content">Which could be solved in one swipe by adding a Result&lt;T, Error&gt; sum type, and a ? operator to the language. This is more a self-inflicted limitation of Go, then a general indictment of explicit error handling.</div><br/></div></div></div></div></div></div><div id="42243601" class="c"><input type="checkbox" id="c-42243601" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#42243551">parent</a><span>|</span><a href="#42243680">prev</a><span>|</span><a href="#42243586">next</a><span>|</span><label class="collapse" for="c-42243601">[-]</label><label class="expand" for="c-42243601">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s actually very rare that it should be the caller who has to handle the errors.<p>Go, however, forces you to spread your error handling over a thousand little pieces with zero overview or control of what&#x27;s happening.<p>Rust eventually realised this and introduced try! and ? to simplify this</div><br/><div id="42243761" class="c"><input type="checkbox" id="c-42243761" checked=""/><div class="controls bullet"><span class="by">koito17</span><span>|</span><a href="#42243551">root</a><span>|</span><a href="#42243601">parent</a><span>|</span><a href="#42243586">next</a><span>|</span><label class="collapse" for="c-42243761">[-]</label><label class="expand" for="c-42243761">[1 more]</label></div><br/><div class="children"><div class="content">More importantly, Rust has the notion of a <i>result type</i> and it is designed to be both generic and composable.<p>A problem I often face in Go and TypeScript code is code that ignores errors, often unintentionally. For instance, many uses of JSON.parse in TypeScript do not check for the SyntaxError that may be thrown. In Go, it is common to see patterns like<p><pre><code>  _ := foo.Bar()
  &#x2F;&#x2F; assume Bar() returns error
</code></pre>
This pattern exists to tell the reader &quot;I don&#x27;t care if this method returns an error&quot;. It allows one to avoid returning an error, but it also stops the caller from ever being handle to the error.<p>Also, the position of the error matters. While the convention in the stdlib is to return errors as the final value, this isn&#x27;t necessarily followed by third party code.<p>Similarly, errors are just an interface and there is no requirement to actually handle returned errors. Even if one wants to handle errors, it&#x27;s quite awkward having to use errors.As or errors.Is to look into a (possibly wrapped) chain of errors.<p>The benefit of Rust&#x27;s Result&lt;T, E&gt; is that<p>- position doesn&#x27;t matter<p>- there is strong, static type checking<p>- the language provides operators like ? to effortlessly pass errors up the call stack, and<p>- the language provides pattern matching, so it&#x27;s easy to exhaustively handle errors in a Result<p>The last two points are extremely important. It&#x27;s what prevents boilerplate like<p><pre><code>  if err != nil {
    return nil, err
  }
</code></pre>
and it&#x27;s what allows one to write type-safe code rather than guess whether errors.As() or errors.Is() should be used to handle a returned error.</div><br/></div></div></div></div><div id="42243586" class="c"><input type="checkbox" id="c-42243586" checked=""/><div class="controls bullet"><span class="by">XorNot</span><span>|</span><a href="#42243551">parent</a><span>|</span><a href="#42243601">prev</a><span>|</span><a href="#42243714">next</a><span>|</span><label class="collapse" for="c-42243586">[-]</label><label class="expand" for="c-42243586">[3 more]</label></div><br/><div class="children"><div class="content">When I started trying to teach myself Rust, the error handling story fell apart on me very quick.<p>Like as soon as I wanted to try and get sensible reporting in their, suddenly we were relieving libraries, adding shims and fighting mismatched types and every article was saying the same thing: haha yeah it&#x27;s kind of a problem.<p>I&#x27;m very, very unsold on explicit error handling compared to exceptions for practical programming. The number of things which can error in a program is far larger then those that can&#x27;t.</div><br/><div id="42243710" class="c"><input type="checkbox" id="c-42243710" checked=""/><div class="controls bullet"><span class="by">usrnm</span><span>|</span><a href="#42243551">root</a><span>|</span><a href="#42243586">parent</a><span>|</span><a href="#42243676">next</a><span>|</span><label class="collapse" for="c-42243710">[-]</label><label class="expand" for="c-42243710">[1 more]</label></div><br/><div class="children"><div class="content">The problems you&#x27;re describing don&#x27;t exist in go. There is exactly one standard type that is used by everyone, at least in public API&#x27;s, you can always just return the error to the caller, if you don&#x27;t want to handle it in place. The main difference with exceptions in my practice is the fact that it&#x27;s a lot easier to mess up, since it requires manual typing. This is probably my main problem with everything being as explicit as possible: it requires people to not make mistakes while performing boring manual tasks. What could possibly go wrong?</div><br/></div></div><div id="42243676" class="c"><input type="checkbox" id="c-42243676" checked=""/><div class="controls bullet"><span class="by">lkirkwood</span><span>|</span><a href="#42243551">root</a><span>|</span><a href="#42243586">parent</a><span>|</span><a href="#42243710">prev</a><span>|</span><a href="#42243714">next</a><span>|</span><label class="collapse" for="c-42243676">[-]</label><label class="expand" for="c-42243676">[1 more]</label></div><br/><div class="children"><div class="content">I felt the same but after switching to anyhow and thiserror in pretty much every Rust project I work on I find it quite painless. It&#x27;s not ideal to rely on crates for a core language feature but I never find myself fighting error types anymore. Have you tried those crates? Do you still hold that opinion?</div><br/></div></div></div></div><div id="42243714" class="c"><input type="checkbox" id="c-42243714" checked=""/><div class="controls bullet"><span class="by">pif</span><span>|</span><a href="#42243551">parent</a><span>|</span><a href="#42243586">prev</a><span>|</span><a href="#42243604">next</a><span>|</span><label class="collapse" for="c-42243714">[-]</label><label class="expand" for="c-42243714">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I’ve previously spoken about my loathing of exception handling because it adds a “magic” layer to things which is way too easy to mess up.<p>I kind of see your point. In this very moment, it doesn&#x27;t matter whether I agree. What I don&#x27;t understand, though, is why (typically) people who abhor exceptions are among the fiercest defenders of garbage collection, which does add a “magic” and uncontrollable layer to object destruction.<p>Personally, having learned to love RAII with C++, I was shocked to discover that other languages discarded it initially and had to add it in later when they realized that their target developers are not as dummy as those choosing Golang.</div><br/></div></div></div></div><div id="42243604" class="c"><input type="checkbox" id="c-42243604" checked=""/><div class="controls bullet"><span class="by">afiodorov</span><span>|</span><a href="#42243551">prev</a><span>|</span><a href="#42243771">next</a><span>|</span><label class="collapse" for="c-42243604">[-]</label><label class="expand" for="c-42243604">[4 more]</label></div><br/><div class="children"><div class="content">Not sure why Go is compared to Rust all the time, whilst most appropriate comparison is Java.</div><br/><div id="42243622" class="c"><input type="checkbox" id="c-42243622" checked=""/><div class="controls bullet"><span class="by">kybernetikos</span><span>|</span><a href="#42243604">parent</a><span>|</span><a href="#42243638">next</a><span>|</span><label class="collapse" for="c-42243622">[-]</label><label class="expand" for="c-42243622">[1 more]</label></div><br/><div class="children"><div class="content">I think this is exactly the right way to understand Go - it&#x27;s targetted at building servers in environments where having strong consistency of code and a short ramp up time for junior engineers is valuable - i.e. it&#x27;s perfect for all the big corp scenarios that Java was used for.<p>I think maybe the more common, but less helpful comparison of go vs rust comes from the fact that they are both part of a new wave of languages and that they both default to producing staticly linked binaries.</div><br/></div></div><div id="42243638" class="c"><input type="checkbox" id="c-42243638" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#42243604">parent</a><span>|</span><a href="#42243622">prev</a><span>|</span><a href="#42243771">next</a><span>|</span><label class="collapse" for="c-42243638">[-]</label><label class="expand" for="c-42243638">[2 more]</label></div><br/><div class="children"><div class="content">Because someone decides what language to write a new thing in is very likely to consider Go and Rust. They are very unlikely to consider Java.<p>Are Rust and Go sufficiently different that they should each be chosen in different cases? Sure! But that’s literally why someone would consider both and pick one.</div><br/><div id="42243776" class="c"><input type="checkbox" id="c-42243776" checked=""/><div class="controls bullet"><span class="by">chikere232</span><span>|</span><a href="#42243604">root</a><span>|</span><a href="#42243638">parent</a><span>|</span><a href="#42243771">next</a><span>|</span><label class="collapse" for="c-42243776">[-]</label><label class="expand" for="c-42243776">[1 more]</label></div><br/><div class="children"><div class="content">They should consider Java though.<p>People have an irrational hate for it based on the enterprise cruft and horrible third party frameworks you can just completely ignore if you build a new thing<p>It&#x27;s not good for commandline stuff but for a long running small service it is pretty great</div><br/></div></div></div></div></div></div><div id="42243771" class="c"><input type="checkbox" id="c-42243771" checked=""/><div class="controls bullet"><span class="by">misonic</span><span>|</span><a href="#42243604">prev</a><span>|</span><a href="#42243645">next</a><span>|</span><label class="collapse" for="c-42243771">[-]</label><label class="expand" for="c-42243771">[1 more]</label></div><br/><div class="children"><div class="content">While the article raises some valid critiques, it often overlooks the fundamental tradeoffs that make Go successful in its niche. Go’s simplicity is not a flaw but a deliberate choice, enabling rapid onboarding and maintainable code for large teams. Its explicit error handling may seem verbose but ensures clarity and avoids hidden surprises common in exception-heavy languages. The complaints about ecosystem isolation and tooling ignore the fact that Go provides powerful built-in tools like pprof and dlv, which are better suited for Go’s runtime than general-purpose alternatives. Go isn’t trying to be Rust or Python—it’s a pragmatic tool for scalable, performant systems.</div><br/></div></div><div id="42243645" class="c"><input type="checkbox" id="c-42243645" checked=""/><div class="controls bullet"><span class="by">serbuvlad</span><span>|</span><a href="#42243771">prev</a><span>|</span><a href="#42243528">next</a><span>|</span><label class="collapse" for="c-42243645">[-]</label><label class="expand" for="c-42243645">[1 more]</label></div><br/><div class="children"><div class="content">I love Go, so I am biased. However, the beautiful thing about Go is that it doesn&#x27;t even attempt to prevent classes of bugs by making them impossible. It&#x27;s a car with ABS but no lane assist, with power steering but no collision detection.<p>Out of all the bugs which Go permits I have yet to see one which could survive in production for some time without being discovered. Almost all of them would cause a failure the first time a segment of code is run.</div><br/></div></div><div id="42243528" class="c"><input type="checkbox" id="c-42243528" checked=""/><div class="controls bullet"><span class="by">gnabgib</span><span>|</span><a href="#42243645">prev</a><span>|</span><a href="#42243702">next</a><span>|</span><label class="collapse" for="c-42243528">[-]</label><label class="expand" for="c-42243528">[1 more]</label></div><br/><div class="children"><div class="content">(2022) Discussions at the time:<p>(130 points, 148 comments) <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34188528">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34188528</a><p>(748 points, 544 comments) <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31205072">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31205072</a></div><br/></div></div><div id="42243702" class="c"><input type="checkbox" id="c-42243702" checked=""/><div class="controls bullet"><span class="by">a-french-anon</span><span>|</span><a href="#42243528">prev</a><span>|</span><a href="#42243770">next</a><span>|</span><label class="collapse" for="c-42243702">[-]</label><label class="expand" for="c-42243702">[1 more]</label></div><br/><div class="children"><div class="content">One of my biggest beefs with Go and dozens of other languages is: static typing without a sufficiently developed type system is masochism.<p>If I can&#x27;t get at least ADTs and parametric typing, give me gradual like CL.</div><br/></div></div><div id="42243770" class="c"><input type="checkbox" id="c-42243770" checked=""/><div class="controls bullet"><span class="by">cedws</span><span>|</span><a href="#42243702">prev</a><span>|</span><a href="#42243773">next</a><span>|</span><label class="collapse" for="c-42243770">[-]</label><label class="expand" for="c-42243770">[1 more]</label></div><br/><div class="children"><div class="content">Go is just an evolution of C, it works at a higher level but shares many ideas. If you can’t appreciate the simplicity of C, then you probably won’t appreciate the works of Bell Labs, and I have lost all interest in the debate.</div><br/></div></div><div id="42243773" class="c"><input type="checkbox" id="c-42243773" checked=""/><div class="controls bullet"><span class="by">Jare</span><span>|</span><a href="#42243770">prev</a><span>|</span><a href="#42243701">next</a><span>|</span><label class="collapse" for="c-42243773">[-]</label><label class="expand" for="c-42243773">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Evidently, the Go team didn&#x27;t want to design a language.<p>This excerpt should be enough for you to know if you will find the article insightful or useless.</div><br/></div></div><div id="42243701" class="c"><input type="checkbox" id="c-42243701" checked=""/><div class="controls bullet"><span class="by">vander_elst</span><span>|</span><a href="#42243773">prev</a><span>|</span><a href="#42243641">next</a><span>|</span><label class="collapse" for="c-42243701">[-]</label><label class="expand" for="c-42243701">[1 more]</label></div><br/><div class="children"><div class="content">Currently onboarding to go. For me personally, it&#x27;s too opinionated e.g. for: error handling, mutability, unit testing, naming conventions, lack of features like sum types.<p>As a new joiner, some things have a &quot;religious&quot; feeling, like the: go gods have given us THE language and we must use it their way, without questioning too much.<p>I have the feeling other languages are less opinionated and this allows for more ergonomics and comfort when developing.</div><br/></div></div><div id="42243641" class="c"><input type="checkbox" id="c-42243641" checked=""/><div class="controls bullet"><span class="by">fabian2k</span><span>|</span><a href="#42243701">prev</a><span>|</span><a href="#42243524">next</a><span>|</span><label class="collapse" for="c-42243641">[-]</label><label class="expand" for="c-42243641">[1 more]</label></div><br/><div class="children"><div class="content">I liked the idea of a language with minimal syntax that is easy to learn and easy to understand because the code is forced to be straightforward. It didn&#x27;t work out that way to me in practice.<p>It&#x27;s a bit too low level for many use cases in my opinion, and that does get in the way somewhat. It also works against the &quot;easy to learn&quot; part unless you start with developers familiar with low level programming.<p>I also found some types of library code surprisingly difficult to read, especially when empty interfaces where used.<p>The standard library was great though, it covered stuff that others don&#x27;t and it just worked out of the box.</div><br/></div></div><div id="42243524" class="c"><input type="checkbox" id="c-42243524" checked=""/><div class="controls bullet"><span class="by">SomeoneOnTheWeb</span><span>|</span><a href="#42243641">prev</a><span>|</span><a href="#42243624">next</a><span>|</span><label class="collapse" for="c-42243524">[-]</label><label class="expand" for="c-42243524">[1 more]</label></div><br/><div class="children"><div class="content">The title lacks a (2022)
Otherwise great article :)</div><br/></div></div><div id="42243624" class="c"><input type="checkbox" id="c-42243624" checked=""/><div class="controls bullet"><span class="by">jamiejquinn</span><span>|</span><a href="#42243524">prev</a><span>|</span><a href="#42243570">next</a><span>|</span><label class="collapse" for="c-42243624">[-]</label><label class="expand" for="c-42243624">[1 more]</label></div><br/><div class="children"><div class="content">Seems like Zig is actually meeting much of the writer&#x27;s expectations for good language design. Although I&#x27;m still not wholly convinced by it&#x27;s move from LLVM and hell-bent desire for incremental compilation.</div><br/></div></div><div id="42243570" class="c"><input type="checkbox" id="c-42243570" checked=""/><div class="controls bullet"><span class="by">fire_lake</span><span>|</span><a href="#42243624">prev</a><span>|</span><a href="#42243550">next</a><span>|</span><label class="collapse" for="c-42243570">[-]</label><label class="expand" for="c-42243570">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Because they&#x27;re Go experts, they know the cost of using Go upfront, and they&#x27;re equipped to make the decision whether or not it&#x27;s worth it<p>Well maybe not.<p>If I’m an expert in only Java 6, I might not be aware of all sorts of useful features that other languages have, such as sum types, traits, type inference… I only know one side of the trade off.<p>I might be vaguely aware of those ideas and dismiss them because I can’t imagine how they would fit in my Java 6 workflow.<p>And yet when some of them arrive in later Javas, I begrudgingly use them. Years later I can’t imagine how I ever lived without them!<p>We’ve seen this play out so many times.<p>Remember when lambdas were just for weird functional languages?</div><br/></div></div><div id="42243550" class="c"><input type="checkbox" id="c-42243550" checked=""/><div class="controls bullet"><span class="by">voidUpdate</span><span>|</span><a href="#42243570">prev</a><span>|</span><a href="#42243623">next</a><span>|</span><label class="collapse" for="c-42243550">[-]</label><label class="expand" for="c-42243550">[1 more]</label></div><br/><div class="children"><div class="content">I really wanted to like go, and I tried to write a discord bot using it, but the very opinionated brace style (which isn&#x27;t the one I prefer to use), and the fact that I struggled to much to try and split my code across two files kinda turned me off it. In the end I just went back to python</div><br/></div></div><div id="42243623" class="c"><input type="checkbox" id="c-42243623" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#42243550">prev</a><span>|</span><a href="#42243589">next</a><span>|</span><label class="collapse" for="c-42243623">[-]</label><label class="expand" for="c-42243623">[1 more]</label></div><br/><div class="children"><div class="content">There _are_ two problems with Golang that I _would_ like to wave a magic wand and fix if that was a power I had.<p>1) Sum types (E.G. C&#x2F;C++ union types) - Yeah, something similar to that should exist... it&#x27;s syntax sugar over #2<p>2) &#x27;casting&#x27; &#x2F; reshaping perspective on data ; as long as something has the same struct size a programmer should be able to tell the compiler &#x27;but this is actually that&#x27;.  Which also implies a way of fixing the layout of a given data structure.  I figure that&#x27;s why Golang doesn&#x27;t allow this already.<p>Yeah, 24 bytes (len, cap, pointer) per slice (dynamic array) has a cost, but if that really gets your goat use a fixed size array, or pointer&#x2F;reference to such [n]thing.<p>3) Seriously, for a slice, make it like a map, a pointer&#x2F;reference to a len,cap,blob - so that when I pass a slice by value I pass the WHOLE slice, not a COPY of len and cap and a reference to the slab.  Current golang has the worst of all worlds with passing slices around, in that changes mutate, UNTIL it&#x27;s resized or manually copied.  The current design has the behavior it does to support slices of slices, which requires the pointer to the blob.  A more complex scheme of a container behind the slice, and references to that could also work, but would be an entirely different datatype.</div><br/></div></div><div id="42243589" class="c"><input type="checkbox" id="c-42243589" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#42243623">prev</a><span>|</span><a href="#42243600">next</a><span>|</span><label class="collapse" for="c-42243589">[-]</label><label class="expand" for="c-42243589">[1 more]</label></div><br/><div class="children"><div class="content">Even async in Go isn&#x27;t that good, ultimately. You can&#x27;t monitor channels, you can&#x27;t properly react to errors, you can&#x27;t shutdown and restart them. A panic in a channel will kill your program. Etc.<p>It&#x27;s &quot;we learned about green threads and didn&#x27;t bother to learn anything else&quot; approach (also prevalent in many other languages)</div><br/></div></div><div id="42243600" class="c"><input type="checkbox" id="c-42243600" checked=""/><div class="controls bullet"><span class="by">WesolyKubeczek</span><span>|</span><a href="#42243589">prev</a><span>|</span><a href="#42243644">next</a><span>|</span><label class="collapse" for="c-42243600">[-]</label><label class="expand" for="c-42243600">[1 more]</label></div><br/><div class="children"><div class="content">The article is great. The bigger picture, of course, is that it’s always “pick your poison”.<p>On one hand, say, I love operator overloading, I love how Python does it (once you satisfy an interface, its operators Just Work).<p>On the other hand, I can appreciate the choice not to do it at all because half of the ecosystem will do it, and another half won’t. Also, it would require implementing function overloading, and it is a can of worms.<p>Or generics and rich type systems, which all come with their own tradeoffs. I hear that Rust cajoles you into tinkering with the type system, and wach tweak requires refactoring of more codebase than anyone would like (don’t take my word for it, it’s just what I heard from a few different sources). I know that Nim is so expressive that it can be annoyingly trivial to be too clever and run into a valid edge case that will make the compiler barf and die. Go sidesteps the issue by not wading into that territory, and that may be perfectly okay, albeit verbose.<p>It’s always picking your poison, so I guess check your tolerances and allergies so it doesn’t kill you before you get the job done…</div><br/></div></div><div id="42243644" class="c"><input type="checkbox" id="c-42243644" checked=""/><div class="controls bullet"><span class="by">rob74</span><span>|</span><a href="#42243600">prev</a><span>|</span><a href="#42243603">next</a><span>|</span><label class="collapse" for="c-42243644">[-]</label><label class="expand" for="c-42243644">[1 more]</label></div><br/><div class="children"><div class="content">Oh well, here we go again... (2022)</div><br/></div></div><div id="42243603" class="c"><input type="checkbox" id="c-42243603" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#42243644">prev</a><span>|</span><a href="#42243565">next</a><span>|</span><label class="collapse" for="c-42243603">[-]</label><label class="expand" for="c-42243603">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve mentioned &quot;leaving struct fields uninitialized&quot;. This happens easily when you make a code change from something like this:<p>Really?  Are you not using gopls?  It absolutely will warn you about this.  And the mutex case.  And a lot of the other similar criticisms.<p>&gt; Go not letting you do operator overloading, harkening back to the Java days where a == b isn&#x27;t the same as a.equals(b)<p>In languages that have it I&#x27;ve never used operator overloading to produce anything good or that was obviously better than just using methods.<p>&gt; The Go toolchain does not use the assembly language everyone else knows about.<p>Honestly I&#x27;ve never noticed or had to care.  And you can build plenty of things that don&#x27;t require CGO.<p>The whole &quot;gnostic&quot; tone in language articles on HN is becoming overbearing.  There are parts of the language to criticize but couching it in this &quot;lies _we_ tell ourselves&quot; and somewhat kitchy writing that presents minor matters of taste as fully existential issues makes this an unsatisfying read.</div><br/><div id="42243774" class="c"><input type="checkbox" id="c-42243774" checked=""/><div class="controls bullet"><span class="by">rvense</span><span>|</span><a href="#42243603">parent</a><span>|</span><a href="#42243565">next</a><span>|</span><label class="collapse" for="c-42243774">[-]</label><label class="expand" for="c-42243774">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In languages that have it I&#x27;ve never used operator overloading to produce anything good or that was obviously better than just using methods.<p>I used a Scala library for S3 once that overloaded + to mean upload.<p><pre><code>    var bucket; var file;
    bucket + file;
</code></pre>
Which is obviously bad and unnecessary.<p>It&#x27;s really a feature that should be used very rarely by those who make basic libraries.</div><br/></div></div></div></div><div id="42243565" class="c"><input type="checkbox" id="c-42243565" checked=""/><div class="controls bullet"><span class="by">bowsamic</span><span>|</span><a href="#42243603">prev</a><span>|</span><a href="#42243665">next</a><span>|</span><label class="collapse" for="c-42243565">[-]</label><label class="expand" for="c-42243565">[1 more]</label></div><br/><div class="children"><div class="content">The author&#x27;s last post they referenced is a bit bizarre. I don&#x27;t think that some overly simplified and error prone std library APIs is a particularly compelling reason to dislike a language. I didn&#x27;t read the <i>entire</i> thing though because it was extremely long</div><br/></div></div><div id="42243683" class="c"><input type="checkbox" id="c-42243683" checked=""/><div class="controls bullet"><span class="by">pif</span><span>|</span><a href="#42243665">prev</a><span>|</span><label class="collapse" for="c-42243683">[-]</label><label class="expand" for="c-42243683">[1 more]</label></div><br/><div class="children"><div class="content">Truth people don&#x27;t tell themselves when choosing Golang: Golang is for dummies, and most programmers in our organization are dummies, thus we cannot afford anything more complicated.<p>[Edit: downvoting this comment because you don&#x27;t like the message is like breaking the mirror because you don&#x27;t like your look]</div><br/></div></div></div></div></div></div></div></body></html>