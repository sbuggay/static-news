<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1726736465026" as="style"/><link rel="stylesheet" href="styles.css?v=1726736465026"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://medium.com/google-cloud/interning-in-go-4319ea635002">Interning in Go</a> <span class="domain">(<a href="https://medium.com">medium.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>32 comments</span></div><br/><div><div id="41589186" class="c"><input type="checkbox" id="c-41589186" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41589395">next</a><span>|</span><label class="collapse" for="c-41589186">[-]</label><label class="expand" for="c-41589186">[1 more]</label></div><br/><div class="children"><div class="content">Interestingly enough, by following up some references of the article I discovered that Go is also following up on Java and .NET design decisions, that maybe could be there early on.<p>- Deprecating finalizers and using cleaner queues (<a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;421" rel="nofollow">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;421</a>)<p>- Weak references (<a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;api&#x2F;system.weakreference" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;api&#x2F;system.weakrefe...</a>, <a href="https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;api&#x2F;java&#x2F;lang&#x2F;ref&#x2F;WeakReference.html" rel="nofollow">https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;api&#x2F;java&#x2F;lang&#x2F;ref&#x2F;Weak...</a>)<p>Related tickets,<p>&quot;runtime: add AddCleanup and deprecate SetFinalizer&quot; - <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;67535">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;67535</a><p>&quot;weak: new package providing weak pointers&quot; - <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;67552">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;67552</a><p>One day Go will eventually have all those features that they deemed unnecessary from &quot;complex&quot; languages.</div><br/></div></div><div id="41589395" class="c"><input type="checkbox" id="c-41589395" checked=""/><div class="controls bullet"><span class="by">nickcw</span><span>|</span><a href="#41589186">prev</a><span>|</span><a href="#41587075">next</a><span>|</span><label class="collapse" for="c-41589395">[-]</label><label class="expand" for="c-41589395">[2 more]</label></div><br/><div class="children"><div class="content">The unique package is my top feature for go1.23. I&#x27;ve been experimenting with it in rclone.<p>People often want to have millions of S3 objects in memory and reducing the memory used would be very desirable.<p>I interned all the strings used - there are a lot of duplicates like Content Type and it reduced the memory usage by about 30% which is great.<p>I wonder how much difference this little fix mentioned in the article for go1.23.2 will make? <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;69370">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;69370</a><p>The article also mentions strings.Clone which has been around for a while. Using that is very easy and it stops big strings being pinned into memory. I had a problem with this in the S3 backend where some string was pinning the entire XML response from the server which strings.Clone fixed.</div><br/><div id="41589443" class="c"><input type="checkbox" id="c-41589443" checked=""/><div class="controls bullet"><span class="by">tapirl</span><span>|</span><a href="#41589395">parent</a><span>|</span><a href="#41587075">next</a><span>|</span><label class="collapse" for="c-41589443">[-]</label><label class="expand" for="c-41589443">[1 more]</label></div><br/><div class="children"><div class="content">Be aware that there is a bug in the current implementation (1.23.0 and 1.23.1) <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;69370">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;69370</a></div><br/></div></div></div></div><div id="41587075" class="c"><input type="checkbox" id="c-41587075" checked=""/><div class="controls bullet"><span class="by">jfoutz</span><span>|</span><a href="#41589395">prev</a><span>|</span><a href="#41587347">next</a><span>|</span><label class="collapse" for="c-41587075">[-]</label><label class="expand" for="c-41587075">[3 more]</label></div><br/><div class="children"><div class="content">Interning is neat. Most of my experience is really dated. Primarily in the JVM, and mostly for class names, for reflection and class loaders. It&#x27;s sort of surprising seeing this added to go, with its desires for minimalism. But when you can use it, it can be a big win.<p>Look past the &quot;loading the whole book in memory&quot; the author gets to the point soon enough.<p>The ip address example is ok. It&#x27;s true, and highlights some important points. But keep in mind pointers are 64 bit. If you&#x27;re not ipv6, and you&#x27;re shuffling a lot of them, you&#x27;re probably better off just keeping the uint64 and converting to string and allocating the struct as needed. interning doesn&#x27;t appear to be much of a win in that narrow case. but if you do care about ipv6, and you&#x27;re connecting to millions of upstreams, it&#x27;s not unreasonable.<p>It&#x27;s neat it&#x27;s available. it&#x27;s good to be aware of interning, but it&#x27;s generally not a huge win. For a few special cases, it can be really awesome.<p>** edit
uint32 for ipv4. bit counting is hard.</div><br/><div id="41588954" class="c"><input type="checkbox" id="c-41588954" checked=""/><div class="controls bullet"><span class="by">wjholden</span><span>|</span><a href="#41587075">parent</a><span>|</span><a href="#41588212">next</a><span>|</span><label class="collapse" for="c-41588954">[-]</label><label class="expand" for="c-41588954">[1 more]</label></div><br/><div class="children"><div class="content">Fun fact: in Go, an IPv4 address is internally represented as an IPv6 address, starting with ten zeroes and two 0xffs. The IPv4 address is copied in the last four bytes.<p><a href="https:&#x2F;&#x2F;cs.opensource.google&#x2F;go&#x2F;go&#x2F;+&#x2F;refs&#x2F;tags&#x2F;go1.23.1:src&#x2F;net&#x2F;ip.go;l=53" rel="nofollow">https:&#x2F;&#x2F;cs.opensource.google&#x2F;go&#x2F;go&#x2F;+&#x2F;refs&#x2F;tags&#x2F;go1.23.1:src&#x2F;...</a><p>This is called an IPv4-Mapped Address.<p><a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc5156#section-2.2" rel="nofollow">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc5156#section-2.2</a></div><br/></div></div><div id="41588212" class="c"><input type="checkbox" id="c-41588212" checked=""/><div class="controls bullet"><span class="by">oefrha</span><span>|</span><a href="#41587075">parent</a><span>|</span><a href="#41588954">prev</a><span>|</span><a href="#41587347">next</a><span>|</span><label class="collapse" for="c-41588212">[-]</label><label class="expand" for="c-41588212">[1 more]</label></div><br/><div class="children"><div class="content">No, the example isn&#x27;t about IP address octets, it&#x27;s about IPv6 <i>zones</i> — we&#x27;re talking strings like &quot;eth0&quot;.</div><br/></div></div></div></div><div id="41587347" class="c"><input type="checkbox" id="c-41587347" checked=""/><div class="controls bullet"><span class="by">survivedurcode</span><span>|</span><a href="#41587075">prev</a><span>|</span><a href="#41588886">next</a><span>|</span><label class="collapse" for="c-41587347">[-]</label><label class="expand" for="c-41587347">[2 more]</label></div><br/><div class="children"><div class="content">Beware the trade-offs of interning affecting GC behavior. Now you can’t have a stack-allocation optimization, for example.</div><br/><div id="41589453" class="c"><input type="checkbox" id="c-41589453" checked=""/><div class="controls bullet"><span class="by">tapirl</span><span>|</span><a href="#41587347">parent</a><span>|</span><a href="#41588886">next</a><span>|</span><label class="collapse" for="c-41589453">[-]</label><label class="expand" for="c-41589453">[1 more]</label></div><br/><div class="children"><div class="content">The interning feature should be only used for some rare cases, it is not intended to be used widely.</div><br/></div></div></div></div><div id="41588886" class="c"><input type="checkbox" id="c-41588886" checked=""/><div class="controls bullet"><span class="by">cherryteastain</span><span>|</span><a href="#41587347">prev</a><span>|</span><a href="#41587073">next</a><span>|</span><label class="collapse" for="c-41588886">[-]</label><label class="expand" for="c-41588886">[3 more]</label></div><br/><div class="children"><div class="content">Cool idea, but sounds detrimental in terms of cache efficiency. Typically processing a string by reading it sequentially is quite cache efficient as the processor will prefetch, but with this method it seems like the string will not be contiguous in memory which will lead to more cache misses.</div><br/><div id="41589450" class="c"><input type="checkbox" id="c-41589450" checked=""/><div class="controls bullet"><span class="by">pimeys</span><span>|</span><a href="#41588886">parent</a><span>|</span><a href="#41589272">next</a><span>|</span><label class="collapse" for="c-41589450">[-]</label><label class="expand" for="c-41589450">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s quite common if you need to parse a schema and keep it in memory for a long time. We&#x27;re working on GraphQL federation gateway and interning strings is really useful there due to schemas sometimes being hundreds of megabytes.<p>Writing your own interner is under hundred lines of code and takes about 15 minutes. Writing a thread-safe interner is a bit trickier problem, but there are good libraries for that.</div><br/></div></div><div id="41589272" class="c"><input type="checkbox" id="c-41589272" checked=""/><div class="controls bullet"><span class="by">SwiftyBug</span><span>|</span><a href="#41588886">parent</a><span>|</span><a href="#41589450">prev</a><span>|</span><a href="#41587073">next</a><span>|</span><label class="collapse" for="c-41589272">[-]</label><label class="expand" for="c-41589272">[1 more]</label></div><br/><div class="children"><div class="content">Seems like the classic trade-off of compute time x memory.</div><br/></div></div></div></div><div id="41587073" class="c"><input type="checkbox" id="c-41587073" checked=""/><div class="controls bullet"><span class="by">morkalork</span><span>|</span><a href="#41588886">prev</a><span>|</span><a href="#41586615">next</a><span>|</span><label class="collapse" for="c-41587073">[-]</label><label class="expand" for="c-41587073">[2 more]</label></div><br/><div class="children"><div class="content">This is new for Go? I remember learning about Java string interning decades ago in the context of xml parsers. If I remember correctly, there were even some memory leaks associated with it and thread locals?</div><br/><div id="41587240" class="c"><input type="checkbox" id="c-41587240" checked=""/><div class="controls bullet"><span class="by">pphysch</span><span>|</span><a href="#41587073">parent</a><span>|</span><a href="#41586615">next</a><span>|</span><label class="collapse" for="c-41587240">[-]</label><label class="expand" for="c-41587240">[1 more]</label></div><br/><div class="children"><div class="content">You could&#x27;ve implemented bespoke interning at any point in Go; it was added to the standard library only recently, though, likely because it may leverage Go&#x27;s relatively recent support for generics.</div><br/></div></div></div></div><div id="41586615" class="c"><input type="checkbox" id="c-41586615" checked=""/><div class="controls bullet"><span class="by">peterldowns</span><span>|</span><a href="#41587073">prev</a><span>|</span><a href="#41588733">next</a><span>|</span><label class="collapse" for="c-41586615">[-]</label><label class="expand" for="c-41586615">[1 more]</label></div><br/><div class="children"><div class="content">I missed the initial blogpost about this; thanks for the solid explanation and the links. Probably won&#x27;t make much of a difference for my use cases but cool to know this is now in the stdlib.</div><br/></div></div><div id="41588733" class="c"><input type="checkbox" id="c-41588733" checked=""/><div class="controls bullet"><span class="by">favflam</span><span>|</span><a href="#41586615">prev</a><span>|</span><a href="#41587725">next</a><span>|</span><label class="collapse" for="c-41588733">[-]</label><label class="expand" for="c-41588733">[1 more]</label></div><br/><div class="children"><div class="content">Is this the same as grpc.SharedBufferPool?  The gRPC implementation does a lot of memory allocation.</div><br/></div></div><div id="41587725" class="c"><input type="checkbox" id="c-41587725" checked=""/><div class="controls bullet"><span class="by">pjot</span><span>|</span><a href="#41588733">prev</a><span>|</span><a href="#41588505">next</a><span>|</span><label class="collapse" for="c-41587725">[-]</label><label class="expand" for="c-41587725">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  &gt; I have a very large plaintext file and I’m loading it fully in memory. This results in a string variable book that occupies 282 MiB of memory.
</code></pre>
At what point does something become (very) large?</div><br/></div></div><div id="41588505" class="c"><input type="checkbox" id="c-41588505" checked=""/><div class="controls bullet"><span class="by">smellybigbelly</span><span>|</span><a href="#41587725">prev</a><span>|</span><a href="#41587297">next</a><span>|</span><label class="collapse" for="c-41588505">[-]</label><label class="expand" for="c-41588505">[1 more]</label></div><br/><div class="children"><div class="content">Couldn’t you read in the book a bit smarter by deduplicating the io stream?</div><br/></div></div><div id="41587297" class="c"><input type="checkbox" id="c-41587297" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#41588505">prev</a><span>|</span><a href="#41586988">next</a><span>|</span><label class="collapse" for="c-41587297">[-]</label><label class="expand" for="c-41587297">[1 more]</label></div><br/><div class="children"><div class="content">For reference, the term comes from Lisp’s INTERN. [1]<p>[1] <a href="http:&#x2F;&#x2F;clhs.lisp.se&#x2F;Body&#x2F;f_intern.htm" rel="nofollow">http:&#x2F;&#x2F;clhs.lisp.se&#x2F;Body&#x2F;f_intern.htm</a></div><br/></div></div><div id="41586988" class="c"><input type="checkbox" id="c-41586988" checked=""/><div class="controls bullet"><span class="by">liotier</span><span>|</span><a href="#41587297">prev</a><span>|</span><label class="collapse" for="c-41586988">[-]</label><label class="expand" for="c-41586988">[13 more]</label></div><br/><div class="children"><div class="content">Is this essentially dictionary compression ?</div><br/><div id="41587118" class="c"><input type="checkbox" id="c-41587118" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41586988">parent</a><span>|</span><a href="#41587119">next</a><span>|</span><label class="collapse" for="c-41587118">[-]</label><label class="expand" for="c-41587118">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s similar. It&#x27;s just not by word, but by entire string, assuming that strings are immutable, long enough, and the same string values are referenced often enough.<p>On 64-bit machines though strings shorter than 8 bytes are better off not interned.</div><br/><div id="41587142" class="c"><input type="checkbox" id="c-41587142" checked=""/><div class="controls bullet"><span class="by">jfoutz</span><span>|</span><a href="#41586988">root</a><span>|</span><a href="#41587118">parent</a><span>|</span><a href="#41587119">next</a><span>|</span><label class="collapse" for="c-41587142">[-]</label><label class="expand" for="c-41587142">[3 more]</label></div><br/><div class="children"><div class="content">as I read it, it&#x27;s any struct! Not just strings. which is cool.</div><br/><div id="41587353" class="c"><input type="checkbox" id="c-41587353" checked=""/><div class="controls bullet"><span class="by">TheDong</span><span>|</span><a href="#41586988">root</a><span>|</span><a href="#41587142">parent</a><span>|</span><a href="#41587119">next</a><span>|</span><label class="collapse" for="c-41587353">[-]</label><label class="expand" for="c-41587353">[2 more]</label></div><br/><div class="children"><div class="content">Any &quot;comparable&quot; struct, which is to say any struct where &#x27;==&#x27; works. No, you can&#x27;t override &#x27;==&#x27;.<p>This will not work for the average struct, and if you do use it, you now no longer can include any, for example `[]byte` fields in the struct or else it will no longer compile.<p>I always find it funny that `string` is comparable, but `[]rune` and `[]byte` are not.</div><br/><div id="41588671" class="c"><input type="checkbox" id="c-41588671" checked=""/><div class="controls bullet"><span class="by">aatd86</span><span>|</span><a href="#41586988">root</a><span>|</span><a href="#41587353">parent</a><span>|</span><a href="#41587119">next</a><span>|</span><label class="collapse" for="c-41588671">[-]</label><label class="expand" for="c-41588671">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s beczuse string values are immutable so at any point in a program, the result of string variable comparison would be the same.<p>For slice types it&#x27;s more complex because there is mutability implicit aliasing.
And the backing array pointed at may change.
I guess the latter should point us toward deep value comparison for slice types since any other comparison would be quite flimsy.</div><br/></div></div></div></div></div></div></div></div><div id="41587119" class="c"><input type="checkbox" id="c-41587119" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#41586988">parent</a><span>|</span><a href="#41587118">prev</a><span>|</span><label class="collapse" for="c-41587119">[-]</label><label class="expand" for="c-41587119">[8 more]</label></div><br/><div class="children"><div class="content">No.  This is avoiding keeping multiple copies of the same value.  There&#x27;s no compression.</div><br/><div id="41587308" class="c"><input type="checkbox" id="c-41587308" checked=""/><div class="controls bullet"><span class="by">VWWHFSfQ</span><span>|</span><a href="#41586988">root</a><span>|</span><a href="#41587119">parent</a><span>|</span><a href="#41587160">next</a><span>|</span><label class="collapse" for="c-41587308">[-]</label><label class="expand" for="c-41587308">[6 more]</label></div><br/><div class="children"><div class="content">That&#x27;s pretty much the definition of compression</div><br/><div id="41587773" class="c"><input type="checkbox" id="c-41587773" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#41586988">root</a><span>|</span><a href="#41587308">parent</a><span>|</span><a href="#41587160">next</a><span>|</span><label class="collapse" for="c-41587773">[-]</label><label class="expand" for="c-41587773">[5 more]</label></div><br/><div class="children"><div class="content">Data compression can reduce the space required to store a single payload.  That&#x27;s not what&#x27;s going here.  I mean, I understand what you&#x27;re saying, but calling this compression seems counter-productive to understand what&#x27;s going on.</div><br/><div id="41589236" class="c"><input type="checkbox" id="c-41589236" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#41586988">root</a><span>|</span><a href="#41587773">parent</a><span>|</span><a href="#41588956">next</a><span>|</span><label class="collapse" for="c-41589236">[-]</label><label class="expand" for="c-41589236">[1 more]</label></div><br/><div class="children"><div class="content">I think it is useful to consider this a form of lossless compression not only because it technically is a form of lossless compression but also because a simple compression algorithm like this is a good introduction to the various tradeoffs that compression algorithms can have.<p>This is an instance of dictionary encoding where terms are words and dictionary code space is the entire machine addressing space (heap).<p>The disadvantage of this approach is that you can only &quot;deduplicate&quot; words that are exactly the same and you cannot remove duplicated substrings. Another disadvantage is that the dictionary code size is 8 bytes which means you achieve some saving only for words that are longer than 8 bytes (plus some other overhead for the interning index).<p>Compression algorithms that use dictionary encoding typically use code&#x2F;symbol sizes smaller than 64 bits, often using variable length encoded numbers encoded with some kind of entropy coding that is able to use short bit sequences for codes representing dictionary entries appearing often and longer bit sequences for less frequent ones.<p>But the idea is the same. During decompression you read each &quot;number&quot; from the compressed stream and you use it effectively to index an array that contains the target (sub)strings.<p>The algorithm in the post just interprets the 64-bit dictionary code as an index in the giant array that is the machine addressing space.</div><br/></div></div><div id="41588956" class="c"><input type="checkbox" id="c-41588956" checked=""/><div class="controls bullet"><span class="by">rat9988</span><span>|</span><a href="#41586988">root</a><span>|</span><a href="#41587773">parent</a><span>|</span><a href="#41589236">prev</a><span>|</span><a href="#41589035">next</a><span>|</span><label class="collapse" for="c-41588956">[-]</label><label class="expand" for="c-41588956">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure I can follow you here. Data compression cannot reduce the size of a single word if we count the dictionary size.</div><br/><div id="41589498" class="c"><input type="checkbox" id="c-41589498" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#41586988">root</a><span>|</span><a href="#41588956">parent</a><span>|</span><a href="#41589035">next</a><span>|</span><label class="collapse" for="c-41589498">[-]</label><label class="expand" for="c-41589498">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not impossible... but who said anything about a single word?</div><br/></div></div></div></div><div id="41589035" class="c"><input type="checkbox" id="c-41589035" checked=""/><div class="controls bullet"><span class="by">wjholden</span><span>|</span><a href="#41586988">root</a><span>|</span><a href="#41587773">parent</a><span>|</span><a href="#41588956">prev</a><span>|</span><a href="#41587160">next</a><span>|</span><label class="collapse" for="c-41589035">[-]</label><label class="expand" for="c-41589035">[1 more]</label></div><br/><div class="children"><div class="content">I like the term &quot;deduplication.&quot;</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>