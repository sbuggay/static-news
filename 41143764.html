<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1722697058039" as="style"/><link rel="stylesheet" href="styles.css?v=1722697058039"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.timestored.com/b/the-future-of-kdb/">The future of kdb+?</a> <span class="domain">(<a href="https://www.timestored.com">www.timestored.com</a>)</span></div><div class="subtext"><span>geph2021</span> | <span>49 comments</span></div><br/><div><div id="41145648" class="c"><input type="checkbox" id="c-41145648" checked=""/><div class="controls bullet"><span class="by">lordnacho</span><span>|</span><a href="#41144557">next</a><span>|</span><label class="collapse" for="c-41145648">[-]</label><label class="expand" for="c-41145648">[1 more]</label></div><br/><div class="children"><div class="content">I thought I&#x27;d throw in TimeScale. It&#x27;s a postgres extension, so all your SQL stuff is just the same (replication, auth, etc).<p>It&#x27;s also a column store, with compression. Runs super fast, I&#x27;ve used it in a couple of financial applications. Huge amounts of tick data, all coming down to your application nearly as fast as the hardware will allow.<p>Good support, the guys on Slack are responsive. No, I don&#x27;t have shares in it, I just like it.<p>Regarding kdb, I&#x27;ve used it, but there are significant drawbacks. Costs a bunch of money, that&#x27;s a big one. And the language... I mean it&#x27;s nice to nerd out sometimes with a bit of code golf, but at some point you are going to snap out of it and decide that single characters are not as expressive as they seem.<p>If your thing is ad-hoc quant analysis, then maybe you like kdb. You can sit there and type little strings into the REPL all day in order to find money. But a lot of things are more like cron jobs, you know you need this particular query run on a schedule, so just turn it into something legible that the next guy will understand and maintain.</div><br/></div></div><div id="41144557" class="c"><input type="checkbox" id="c-41144557" checked=""/><div class="controls bullet"><span class="by">Labo333</span><span>|</span><a href="#41145648">prev</a><span>|</span><a href="#41144170">next</a><span>|</span><label class="collapse" for="c-41144557">[-]</label><label class="expand" for="c-41144557">[14 more]</label></div><br/><div class="children"><div class="content">I actually quit a quant trading job after 2 weeks because they used kdb+. I <i>could</i> use it but the experience was so bad...<p>People could complain about abysmal language design or debugging but what I found the most frustration in the coding conventions that they had (or had not), and I think the language and the community play a big role there. But also the company culture: I asked why the code was so poorly documented (no comments, single letter parameters, arcane function names). &quot;We understand it after some time and this way other teams cannot use our ideas.&quot;<p>Overall, their whole stack was outdated and ofc they could not do very interesting things with a tool such as Q. For example, they plotted graphs by copying data from qStudio to Excel...<p>The only good thing was they did not buy the docker &#x2F; k8s bs and were deploying directly on servers. It makes sense that quants should be able to fix things in production very quickly but I think it would also make sense for web app developers not to wait 10 minutes (and that&#x27;s when you have good infra) to see a fix in production.<p>I have a theory on why quants actually like kdb: it&#x27;s a good *weapon*. It serves some purpose but I would not call it a *tool* as building with it is tedious. People like that it just works out of the box. But although you <i>can</i> use a sword to drive nails, it is not its purpose.<p>Continuing on that theory, LISP (especially Racket) would be the best *tool* available as it is not the most powerful language out of the box but allows to build a lot of abstractions with features to modify the language itself. C++ and Python are just great programming languages as you can build good software on them, Python being also a fairly good weapon.<p>Q might give the illusion of being the best language to explore quant data, but that&#x27;s just because quants do not invest enough time into building good software and using good tools. When you actually master a Python IDE, you are definitely more productive than any Q programmer.<p>And don&#x27;t get me started on performance (the link covers it anyway even though the prose is bad).</div><br/><div id="41146427" class="c"><input type="checkbox" id="c-41146427" checked=""/><div class="controls bullet"><span class="by">dumah</span><span>|</span><a href="#41144557">parent</a><span>|</span><a href="#41145100">next</a><span>|</span><label class="collapse" for="c-41146427">[-]</label><label class="expand" for="c-41146427">[1 more]</label></div><br/><div class="children"><div class="content">You didn’t learn Q in two weeks to the extent that you are qualified to assert that someone who knows how to use a Python IDE is more productive than a quant dev with decades of experience.<p>I find it much more likely that you couldn’t understand their code and quit out of frustration.<p>If you were a highly skilled quant dev and this was a good seat, quitting after two weeks would have been a disaster to manage the next transition given the terms these contracts always have.</div><br/></div></div><div id="41145100" class="c"><input type="checkbox" id="c-41145100" checked=""/><div class="controls bullet"><span class="by">wenc</span><span>|</span><a href="#41144557">parent</a><span>|</span><a href="#41146427">prev</a><span>|</span><a href="#41145069">next</a><span>|</span><label class="collapse" for="c-41145100">[-]</label><label class="expand" for="c-41145100">[6 more]</label></div><br/><div class="children"><div class="content">The article calls out Python and DuckDB as possible successors.<p>I remember being very impressed by Kdb+ (went to their meetups in Chicago). Large queries ran almost instantaneously. The APL like syntax was like a magic incantation that only math types were privy to. The salesperson mentioned KdB was so optimized that it fit in the L1 cache of a processor of the day.<p>Fast forward 10 years. I’m doing the same thing today with Python and DuckDB and Jupyter on Parquet files. DuckDB not only parallelizes, it vectorizes. I’m not sure how it benchmarks against kdb+ but the responsiveness of DuckDB at least feels  as fast as kdb+ on large datasets. (Though I’m sure kdb+ is vastly more optimized). The difference? DuckDB is free.</div><br/><div id="41145176" class="c"><input type="checkbox" id="c-41145176" checked=""/><div class="controls bullet"><span class="by">singhrac</span><span>|</span><a href="#41144557">root</a><span>|</span><a href="#41145100">parent</a><span>|</span><a href="#41145520">next</a><span>|</span><label class="collapse" for="c-41145176">[-]</label><label class="expand" for="c-41145176">[2 more]</label></div><br/><div class="children"><div class="content">We use DuckDB similarly but productionize by writing pyarrow code. All the modern tools (DuckDB, pyarrow, polars) are fast enough if you store your data well (parquet), though we work with not quite “big data” most of the time.<p>It’s worth remembering that all the modern progress builds on top of years of work by Wes McKinney &amp; co (many, many contributors).</div><br/><div id="41146748" class="c"><input type="checkbox" id="c-41146748" checked=""/><div class="controls bullet"><span class="by">wenc</span><span>|</span><a href="#41144557">root</a><span>|</span><a href="#41145176">parent</a><span>|</span><a href="#41145520">next</a><span>|</span><label class="collapse" for="c-41146748">[-]</label><label class="expand" for="c-41146748">[1 more]</label></div><br/><div class="children"><div class="content">Yes Wes McKinney was involved in both Pandas and Parquet and Arrow.</div><br/></div></div></div></div><div id="41145520" class="c"><input type="checkbox" id="c-41145520" checked=""/><div class="controls bullet"><span class="by">cout</span><span>|</span><a href="#41144557">root</a><span>|</span><a href="#41145100">parent</a><span>|</span><a href="#41145176">prev</a><span>|</span><a href="#41145069">next</a><span>|</span><label class="collapse" for="c-41145520">[-]</label><label class="expand" for="c-41145520">[3 more]</label></div><br/><div class="children"><div class="content">Do you use duckdb for real-time queries or just historical?  You mentioned parquet but afaik it&#x27;s not well suited for appending data.</div><br/><div id="41146838" class="c"><input type="checkbox" id="c-41146838" checked=""/><div class="controls bullet"><span class="by">wenc</span><span>|</span><a href="#41144557">root</a><span>|</span><a href="#41145520">parent</a><span>|</span><a href="#41146715">next</a><span>|</span><label class="collapse" for="c-41146838">[-]</label><label class="expand" for="c-41146838">[1 more]</label></div><br/><div class="children"><div class="content">Also a tip: for interactive queries, do not store Parquet in S3.<p>S3 is high-throughput but also high-latency storage. It&#x27;s good for bulk reads, but not random reads, and querying Parquet involves random reads. Parquet on S3 is ok for batch jobs (like Spark jobs) but it&#x27;s very slow for interactive queries (Presto, Athena, DuckDB).<p>The solution is to store Parquet on low-latency storage. S3 has something called S3 Express Zones (which is low-latency S3, costs slightly more). Or EBS, which is block storage that doesn&#x27;t suffer from S3&#x27;s high latency.</div><br/></div></div><div id="41146715" class="c"><input type="checkbox" id="c-41146715" checked=""/><div class="controls bullet"><span class="by">wenc</span><span>|</span><a href="#41144557">root</a><span>|</span><a href="#41145520">parent</a><span>|</span><a href="#41146838">prev</a><span>|</span><a href="#41145069">next</a><span>|</span><label class="collapse" for="c-41146715">[-]</label><label class="expand" for="c-41146715">[1 more]</label></div><br/><div class="children"><div class="content">Not real time, just historical. (I don’t see why it can’t be used for real time though... but haven’t thought through the caveats)<p>Also, not sure what you mean by Parquet is not good at appending? On the contrary, Parquet is designed for an append-only paradigm (like Hadoop back in the day). You can just drop a new parquet file and it’s appended.<p>If you have 1.parquet, all you have you to do is drop 2.parquet in the same folder or Hive hierarchy. Then query&gt;<p><pre><code>  Select * from ‘*.parquet’
</code></pre>
DuckDB automatically scans all the parquet in that directory structure when it queries. If there’s a predicate, it uses Parquet header information to skip files that don’t contain the data requested so it’s very fast.<p>In practice we use a directory structure called Hive partitioning, which helps DuckDB do partition elimination to skip over irrelevant partitions, making it even faster.<p><a href="https:&#x2F;&#x2F;duckdb.org&#x2F;docs&#x2F;data&#x2F;partitioning&#x2F;hive_partitioning" rel="nofollow">https:&#x2F;&#x2F;duckdb.org&#x2F;docs&#x2F;data&#x2F;partitioning&#x2F;hive_partitioning</a><p>Parquet is great for appending!<p>Now, it&#x27;s not so good at updating because it&#x27;s a write-once format (not read-write). To update a single record in a Parquet file entails regenerating the entire Parquet file. So if you have late-arriving updates, you need to do extra work to identify the partition involved and overwrite. Either that or use bitemporal modeling (add data arrival timestamp [1]) and do a latest date clause in your query (entailing more compute). If you have a scenario where existing data changes a lot, Parquet is not a good format for you. You should look into Timescale (time-series database based on Postgres)<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Bitemporal_modeling" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Bitemporal_modeling</a></div><br/></div></div></div></div></div></div><div id="41145069" class="c"><input type="checkbox" id="c-41145069" checked=""/><div class="controls bullet"><span class="by">Jorge1o1</span><span>|</span><a href="#41144557">parent</a><span>|</span><a href="#41145100">prev</a><span>|</span><a href="#41145193">next</a><span>|</span><label class="collapse" for="c-41145069">[-]</label><label class="expand" for="c-41145069">[3 more]</label></div><br/><div class="children"><div class="content">Their pykx integration is going a long way to fix some of the gaps in:<p>- charting<p>- machine learning&#x2F;statsmodels<p>- html processing&#x2F;webscrapes<p>Because for example you can just open a Jupyter Notebook and do:<p><pre><code>  import pykx as kx
  df = kx.q(“select from foo where bar”)
  plt.plot(df[“x”], df[“y”])

</code></pre>
It’s truly an incredibly seamless and powerful integration. You get the best of both worlds and it may be the saving feature of the product in the next 10 years</div><br/><div id="41146510" class="c"><input type="checkbox" id="c-41146510" checked=""/><div class="controls bullet"><span class="by">nivertech</span><span>|</span><a href="#41144557">root</a><span>|</span><a href="#41145069">parent</a><span>|</span><a href="#41145193">next</a><span>|</span><label class="collapse" for="c-41146510">[-]</label><label class="expand" for="c-41146510">[2 more]</label></div><br/><div class="children"><div class="content">I think this will only work with regular qSQL on a specific database node, i.e. RDB, IDB, HDB[1]. It will be much harder for a <i>mortal</i> Python developer to use Functional qSQL[2] which will join&#x2F;merge&#x2F;aggregate data from all these nodes. The join&#x2F;merge&#x2F;aggregation is usually application-specific and done on some kind of gateway node(s). Querying each of them is slightly different, with different keys and secondary indices, and requires using a parse tree (AST) of a query.<p>---<p>[1] RDB - RAM DB (recent in-memory data), IDB (Intraday DB - recent data which doesn&#x27;t fit into RAM), HDB - Historical DB (usually partitioned by date or other time-based or integral column).<p>[2] <a href="https:&#x2F;&#x2F;code.kx.com&#x2F;q&#x2F;basics&#x2F;funsql&#x2F;" rel="nofollow">https:&#x2F;&#x2F;code.kx.com&#x2F;q&#x2F;basics&#x2F;funsql&#x2F;</a></div><br/><div id="41146605" class="c"><input type="checkbox" id="c-41146605" checked=""/><div class="controls bullet"><span class="by">Jorge1o1</span><span>|</span><a href="#41144557">root</a><span>|</span><a href="#41146510">parent</a><span>|</span><a href="#41145193">next</a><span>|</span><label class="collapse" for="c-41146605">[-]</label><label class="expand" for="c-41146605">[1 more]</label></div><br/><div class="children"><div class="content">That’s accurate enough. I think the workflow was more built for a q dev occasionally dipping into python rather than the other way around.<p>I think you touch on something really interesting which is the kink in the kdb+ learning curve when you go from really simple functions,tables, etc. to actually building a performant kdb architecture.</div><br/></div></div></div></div></div></div><div id="41145193" class="c"><input type="checkbox" id="c-41145193" checked=""/><div class="controls bullet"><span class="by">keithalewis</span><span>|</span><a href="#41144557">parent</a><span>|</span><a href="#41145069">prev</a><span>|</span><a href="#41144170">next</a><span>|</span><label class="collapse" for="c-41145193">[-]</label><label class="expand" for="c-41145193">[3 more]</label></div><br/><div class="children"><div class="content">One reason to use kdb is qualification. It is a good way to filter out people not smart enough to learn it or have the personality flaw of getting angry at a programming language. Saves on HR costs.</div><br/><div id="41145334" class="c"><input type="checkbox" id="c-41145334" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41144557">root</a><span>|</span><a href="#41145193">parent</a><span>|</span><a href="#41144170">next</a><span>|</span><label class="collapse" for="c-41145334">[-]</label><label class="expand" for="c-41145334">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not a good filter in that case.  I can learn obscure languages just fine, but that doesn&#x27;t make me any more pleasant to hang out with.</div><br/><div id="41145736" class="c"><input type="checkbox" id="c-41145736" checked=""/><div class="controls bullet"><span class="by">socksy</span><span>|</span><a href="#41144557">root</a><span>|</span><a href="#41145334">parent</a><span>|</span><a href="#41144170">next</a><span>|</span><label class="collapse" for="c-41145736">[-]</label><label class="expand" for="c-41145736">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure that was ever a requirement in these industries</div><br/></div></div></div></div></div></div></div></div><div id="41144170" class="c"><input type="checkbox" id="c-41144170" checked=""/><div class="controls bullet"><span class="by">RodgerTheGreat</span><span>|</span><a href="#41144557">prev</a><span>|</span><a href="#41144218">next</a><span>|</span><label class="collapse" for="c-41144170">[-]</label><label class="expand" for="c-41144170">[5 more]</label></div><br/><div class="children"><div class="content">One of the compelling features of kdb+&#x2F;Q that isn&#x27;t explicitly called out here is <i>vertical integration</i>: it&#x27;s a single piece of technology that can handle the use-cases of a whole stack of other off-the-shelf technologies you&#x27;d otherwise need to select and glue together. The Q language, data serialization primitives, and IPC capabilities allow a skilled programmer to tailor-build <i>exactly the system you need</i> in one language, often in a codebase that would fit on a few sheets of paper instead of a few hundred or thousand.<p>If your organization has already committed to serving some of these roles with other pieces of software, protocols, or formats, the benefits of vertical integration- both in development workflow and overall performance- are diminished. When kdb+ itself is both proprietary and expensive it is understandably difficult to justify a total commitment to it for new projects. It&#x27;s a real shame, because the tech itself is a jewel.</div><br/><div id="41144313" class="c"><input type="checkbox" id="c-41144313" checked=""/><div class="controls bullet"><span class="by">absurdcomputing</span><span>|</span><a href="#41144170">parent</a><span>|</span><a href="#41144425">next</a><span>|</span><label class="collapse" for="c-41144313">[-]</label><label class="expand" for="c-41144313">[3 more]</label></div><br/><div class="children"><div class="content">I agree that the vertical integration capability of kdb+&#x2F;Q is amazing, and it is beyond comprehension why Kx themselves don’t effectively leverage it. Kx Platform appears to be mostly written in Java, and the API’s callable from Q are not very well documented. My team and I find the dashboards product is difficult to use, and there are some nasty bugs that cause frequent editor crashes for dashboards of moderate complexity. Q is so feature rich that it would be a blast to write web applications in, but instead we’re forced to use this drag and drop editor if we want to make something available to our users.<p>I think Shakti could become a viable competitor to Kx if they included libraries that handle some common enterprise usecases, such as load balancing, user permissions and SSO. I have no doubt that an experienced K programmer could whip this up in a week or two, but in my experience a sufficiently large enterprise will specify that all these capabilities need to be implemented before they let the product in the door.</div><br/><div id="41144339" class="c"><input type="checkbox" id="c-41144339" checked=""/><div class="controls bullet"><span class="by">RodgerTheGreat</span><span>|</span><a href="#41144170">root</a><span>|</span><a href="#41144313">parent</a><span>|</span><a href="#41144425">next</a><span>|</span><label class="collapse" for="c-41144339">[-]</label><label class="expand" for="c-41144339">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a little too close to be throwing stones, but without going into specifics I believe that key leaders at Kx do not properly appreciate the unique characteristics and benefits of their own technology, and are trapped in a mindset of trying to make their products more similar to their competition in order to make sales and marketing easier. In the process, they discard their competitive advantage. Tale as old as time.</div><br/><div id="41144877" class="c"><input type="checkbox" id="c-41144877" checked=""/><div class="controls bullet"><span class="by">plorkyeran</span><span>|</span><a href="#41144170">root</a><span>|</span><a href="#41144339">parent</a><span>|</span><a href="#41144425">next</a><span>|</span><label class="collapse" for="c-41144877">[-]</label><label class="expand" for="c-41144877">[1 more]</label></div><br/><div class="children"><div class="content">I think it is very difficult to judge how much of an advantage your competitive advantage actually is. It’s very easy to look at the things which directly cost you sales and conclude that those are the things you need to fix rather than doubling down on your strengths. The most common way to avoid that is to go too far in the other direction and become convinced that your niche technology is vastly superior to the mainstream choice and anyone who rejects you for your shortcomings is just shortsighted and wrong.<p>From the outside it’s always seemed that kdb fans tend to land in the second camp, and I think it would be understandable for Kx to have overcorrected into undervaluing their work instead.</div><br/></div></div></div></div></div></div><div id="41144425" class="c"><input type="checkbox" id="c-41144425" checked=""/><div class="controls bullet"><span class="by">mbroecheler</span><span>|</span><a href="#41144170">parent</a><span>|</span><a href="#41144313">prev</a><span>|</span><a href="#41144218">next</a><span>|</span><label class="collapse" for="c-41144425">[-]</label><label class="expand" for="c-41144425">[1 more]</label></div><br/><div class="children"><div class="content">I agree that being able to write one piece of code that solves your use case is a big benefit over having to cobble together a message queue, stream processor, database, query engine, etc.<p>We&#x27;ve been playing around with the idea of a building such an integration layer in SQL on top of open-source technologies like Kafka, Flink, Postgres, and Iceberg with some syntactic sugar to make timeseries processing nicer in SQL:
<a href="https:&#x2F;&#x2F;github.com&#x2F;DataSQRL&#x2F;sqrl&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;DataSQRL&#x2F;sqrl&#x2F;</a><p>The idea is to give you the power of kdb+ with open-source technologies and SQL in an integrated package by transpiling SQL, building the computational DAG, and then running an cost-based optimizer to &quot;cut&quot; the DAG to the underlying data technologies.</div><br/></div></div></div></div><div id="41144218" class="c"><input type="checkbox" id="c-41144218" checked=""/><div class="controls bullet"><span class="by">gricardo99</span><span>|</span><a href="#41144170">prev</a><span>|</span><a href="#41144382">next</a><span>|</span><label class="collapse" for="c-41144218">[-]</label><label class="expand" for="c-41144218">[3 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>   Get a free version out there that can be used for many things…
</code></pre>
I think this has been the biggest impediment to kdb+ gaining recognition as a great technology&#x2F;product and growing amongst the developer community.<p>Having used kdb+ extensively in the finance world for years, I became a convert and a fan.  There’s an elegance in its design and simplicity that seems very much rooted in the Unix philosophy.   After I left finance, and no longer worked at a company that used kdb+, I often felt the urge to reach for kdb+ to use for little projects here and there.   It was frustrating that I couldn’t use it anymore, or even just show colleagues this little known&#x2F;niche tool and geek out a little on how simple and efficient it was for doing certain tasks&#x2F;computations.</div><br/><div id="41144375" class="c"><input type="checkbox" id="c-41144375" checked=""/><div class="controls bullet"><span class="by">shrubble</span><span>|</span><a href="#41144218">parent</a><span>|</span><a href="#41144382">next</a><span>|</span><label class="collapse" for="c-41144375">[-]</label><label class="expand" for="c-41144375">[2 more]</label></div><br/><div class="children"><div class="content">Were any of the open source versions such as ngn&#x2F;k or Kerf etc. usable for you?</div><br/><div id="41144397" class="c"><input type="checkbox" id="c-41144397" checked=""/><div class="controls bullet"><span class="by">RodgerTheGreat</span><span>|</span><a href="#41144218">root</a><span>|</span><a href="#41144375">parent</a><span>|</span><a href="#41144382">next</a><span>|</span><label class="collapse" for="c-41144397">[-]</label><label class="expand" for="c-41144397">[1 more]</label></div><br/><div class="children"><div class="content">Kerf1 has only been open source for a fairly short time, and prior to that it was proprietary. ngn&#x2F;k is tremendously less feature-rich than Q&#x2F;k4, has some built-in constraints that make building large programs difficult, and does not come with the &quot;batteries included&quot; necessary for building distributed systems. Neither is currently a credible alternative to kdb+ for production environments.</div><br/></div></div></div></div></div></div><div id="41144382" class="c"><input type="checkbox" id="c-41144382" checked=""/><div class="controls bullet"><span class="by">chrisaycock</span><span>|</span><a href="#41144218">prev</a><span>|</span><a href="#41146034">next</a><span>|</span><label class="collapse" for="c-41144382">[-]</label><label class="expand" for="c-41144382">[1 more]</label></div><br/><div class="children"><div class="content">I agree with everything in this article. If you&#x27;re building from scratch, just store your data in Parquet and access it via Polars or DuckDB.<p>I built my own language for time-series analysis because of how much I hated q&#x2F;kdb+, but Python has been the winner for a bunch of years now.</div><br/></div></div><div id="41146034" class="c"><input type="checkbox" id="c-41146034" checked=""/><div class="controls bullet"><span class="by">anonu</span><span>|</span><a href="#41144382">prev</a><span>|</span><a href="#41146422">next</a><span>|</span><label class="collapse" for="c-41146034">[-]</label><label class="expand" for="c-41146034">[2 more]</label></div><br/><div class="children"><div class="content">I built a (moderately successful) startup using kdb+. It was what I knew and it helped us build robust product, quickly. But as we scaled we had to rewrite in FOSS to ensure we could scale the team.<p>Agree with all the recommendations, except I think kx should open source the platform. This will attract the breed of developer that will want to contribute back to the ecosystem with improvements and tools.</div><br/><div id="41146103" class="c"><input type="checkbox" id="c-41146103" checked=""/><div class="controls bullet"><span class="by">mritchie712</span><span>|</span><a href="#41146034">parent</a><span>|</span><a href="#41146422">next</a><span>|</span><label class="collapse" for="c-41146103">[-]</label><label class="expand" for="c-41146103">[1 more]</label></div><br/><div class="children"><div class="content">What was the startup? What FOSS did you move to?</div><br/></div></div></div></div><div id="41146422" class="c"><input type="checkbox" id="c-41146422" checked=""/><div class="controls bullet"><span class="by">zitterbewegung</span><span>|</span><a href="#41146034">prev</a><span>|</span><a href="#41144175">next</a><span>|</span><label class="collapse" for="c-41146422">[-]</label><label class="expand" for="c-41146422">[1 more]</label></div><br/><div class="children"><div class="content">Even if Python has “won” in the space the current inertia of technical debt or it isn’t not broken so why fix it will be an issue. I have 5+ years of Python experience and migration to a new platform is at least a year long project if not multi year.<p>Greenfield development though would use Python.</div><br/></div></div><div id="41144175" class="c"><input type="checkbox" id="c-41144175" checked=""/><div class="controls bullet"><span class="by">7thaccount</span><span>|</span><a href="#41146422">prev</a><span>|</span><a href="#41145847">next</a><span>|</span><label class="collapse" for="c-41144175">[-]</label><label class="expand" for="c-41144175">[4 more]</label></div><br/><div class="children"><div class="content">Kdb+ seems really cool and I&#x27;ve learned it a little bit for fun along with APL. It would actually be pretty cool for a lot of uses in my industry too, but the price is just crazy. We can&#x27;t pay like $100k&#x2F;cpu or whatever it is that the financial banks pay. So they&#x27;ve basically ignored a HUGE amount of potential customers.</div><br/><div id="41144296" class="c"><input type="checkbox" id="c-41144296" checked=""/><div class="controls bullet"><span class="by">coliveira</span><span>|</span><a href="#41144175">parent</a><span>|</span><a href="#41145847">next</a><span>|</span><label class="collapse" for="c-41144296">[-]</label><label class="expand" for="c-41144296">[3 more]</label></div><br/><div class="children"><div class="content">They found a niche that can pay the price to have an innovative product. I believe they did the right thing, after all it is not a product trying to solve all problems in the world. Other people could learn from their techniques and do the same for other areas and languages.</div><br/><div id="41144487" class="c"><input type="checkbox" id="c-41144487" checked=""/><div class="controls bullet"><span class="by">7thaccount</span><span>|</span><a href="#41144175">root</a><span>|</span><a href="#41144296">parent</a><span>|</span><a href="#41144321">next</a><span>|</span><label class="collapse" for="c-41144487">[-]</label><label class="expand" for="c-41144487">[1 more]</label></div><br/><div class="children"><div class="content">Not quite where I was going. The product does seem to be good and there is demand for it in many industries I&#x27;d think, but instead of using discriminatory pricing and having people pay less that have a much lower ability to pay, they just ignore the segment entirely. Maybe they know what they&#x27;re doing though. It&#x27;s a shame I don&#x27;t get to use it at work</div><br/></div></div><div id="41144321" class="c"><input type="checkbox" id="c-41144321" checked=""/><div class="controls bullet"><span class="by">RodgerTheGreat</span><span>|</span><a href="#41144175">root</a><span>|</span><a href="#41144296">parent</a><span>|</span><a href="#41144487">prev</a><span>|</span><a href="#41145847">next</a><span>|</span><label class="collapse" for="c-41144321">[-]</label><label class="expand" for="c-41144321">[1 more]</label></div><br/><div class="children"><div class="content">Semiconductor manufacturers understand that giving free samples of their chips to hobbyists creates an environment that breeds future sales: if 1 out of the 1000 people they mailed samples uses their chip in the design for a commercial product, they come out ahead.<p>Proprietary programming languages that are inconvenient for hobbyists to obtain- any more friction than cloning a git repo or installing via a package manager- have stunted open-source ecosystems, and in turn limited opportunities for grass-roots adoption.</div><br/></div></div></div></div></div></div><div id="41145847" class="c"><input type="checkbox" id="c-41145847" checked=""/><div class="controls bullet"><span class="by">puzpuzpuz-hn</span><span>|</span><a href="#41144175">prev</a><span>|</span><a href="#41144025">next</a><span>|</span><label class="collapse" for="c-41145847">[-]</label><label class="expand" for="c-41145847">[1 more]</label></div><br/><div class="children"><div class="content">Nice article, thanks for sharing it. It&#x27;s a pity kdb+ has a DeWitt Clause, so that no one can benchmark it against other databases from the article. I wonder if they have any public benchmarks held by a 3rd-party.</div><br/></div></div><div id="41144025" class="c"><input type="checkbox" id="c-41144025" checked=""/><div class="controls bullet"><span class="by">zX41ZdbW</span><span>|</span><a href="#41145847">prev</a><span>|</span><a href="#41144107">next</a><span>|</span><label class="collapse" for="c-41144025">[-]</label><label class="expand" for="c-41144025">[3 more]</label></div><br/><div class="children"><div class="content">A few corrections to the article.<p>1. ClickHouse is not a new technology — it has been open-source since 2016 and in development since 2009.<p>2. ClickHouse can do all three use cases: historical and real-time data, distributed and local processing (check clickhouse-local and chdb).<p>3. ClickHouse was the first SQL database with ASOF JOIN in the main product (in 2019) - after kdb+, which is not SQL.</div><br/><div id="41144657" class="c"><input type="checkbox" id="c-41144657" checked=""/><div class="controls bullet"><span class="by">benjaminwootton</span><span>|</span><a href="#41144025">parent</a><span>|</span><a href="#41144188">next</a><span>|</span><label class="collapse" for="c-41144657">[-]</label><label class="expand" for="c-41144657">[1 more]</label></div><br/><div class="children"><div class="content">I run a data consultancy with a big focus on ClickHouse.  There is a lot of interest in replacing KDB with it.  I’ve had probably 10 conversations with companies looking at a migration.<p>Tellingly, nobody has pulled the trigger on a migration yet as I think it’s a big call with all of the integrations that KDB sprouts, but it definetly feels like the spiritual successor.</div><br/></div></div><div id="41144188" class="c"><input type="checkbox" id="c-41144188" checked=""/><div class="controls bullet"><span class="by">fnordpiglet</span><span>|</span><a href="#41144025">parent</a><span>|</span><a href="#41144657">prev</a><span>|</span><a href="#41144107">next</a><span>|</span><label class="collapse" for="c-41144188">[-]</label><label class="expand" for="c-41144188">[1 more]</label></div><br/><div class="children"><div class="content">3 is a point that’s lost on people who use Q and related things for financial calculations. They picked kdb+ for a reason, and it wasn’t the database. I took that as the point of the post.</div><br/></div></div></div></div><div id="41144107" class="c"><input type="checkbox" id="c-41144107" checked=""/><div class="controls bullet"><span class="by">timkpaine</span><span>|</span><a href="#41144025">prev</a><span>|</span><a href="#41144505">next</a><span>|</span><label class="collapse" for="c-41144107">[-]</label><label class="expand" for="c-41144107">[1 more]</label></div><br/><div class="children"><div class="content">There are certainly enough rubes out there to sell the next KDB+ to: <a href="https:&#x2F;&#x2F;shakti.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;shakti.com&#x2F;</a></div><br/></div></div><div id="41144505" class="c"><input type="checkbox" id="c-41144505" checked=""/><div class="controls bullet"><span class="by">haolez</span><span>|</span><a href="#41144107">prev</a><span>|</span><a href="#41146134">next</a><span>|</span><label class="collapse" for="c-41144505">[-]</label><label class="expand" for="c-41144505">[1 more]</label></div><br/><div class="children"><div class="content">Is it still possible to learn from scratch and make big bucks developing for kdb+ (k&#x2F;q)? I remember seeing an open position a few years ago which paid like 1MM per year. Astounding.</div><br/></div></div><div id="41146134" class="c"><input type="checkbox" id="c-41146134" checked=""/><div class="controls bullet"><span class="by">thazework</span><span>|</span><a href="#41144505">prev</a><span>|</span><a href="#41144456">next</a><span>|</span><label class="collapse" for="c-41146134">[-]</label><label class="expand" for="c-41146134">[1 more]</label></div><br/><div class="children"><div class="content">Saudi league I think</div><br/></div></div><div id="41144456" class="c"><input type="checkbox" id="c-41144456" checked=""/><div class="controls bullet"><span class="by">parentheses</span><span>|</span><a href="#41146134">prev</a><span>|</span><a href="#41144349">next</a><span>|</span><label class="collapse" for="c-41144456">[-]</label><label class="expand" for="c-41144456">[1 more]</label></div><br/><div class="children"><div class="content">I feel kdb is like the equivalent of a drag racer - useless generally. Great at a one (or few) things in very limited environments.</div><br/></div></div><div id="41144349" class="c"><input type="checkbox" id="c-41144349" checked=""/><div class="controls bullet"><span class="by">menthe</span><span>|</span><a href="#41144456">prev</a><span>|</span><a href="#41145708">next</a><span>|</span><label class="collapse" for="c-41144349">[-]</label><label class="expand" for="c-41144349">[5 more]</label></div><br/><div class="children"><div class="content">Not 100% sure why it’s often idolized on HN.<p>We’ve maintained a financial exchange w&#x2F; margining for 8 years with it, and I guarantee you that everyone was more than relieved - customers and employees alike, once we were able to lift and shift the whole thing to Java.<p>The readability and scalability is abysmal as soon as you move on from a quant desk scenario (which everyone agrees, it is more than amazing at.. panda and dask frames all feel like kindergarten toys compared), the disaster recovery options are basically bound to having distributed storage - which are by the way “too slow” for any real KDB application given the whole KDB concept marries storage and compute in a single thread.. and use-cases of data historical data, such as mentioned in the article, become very quickly awful: one kdb process handles one request at once, so you end up having to deploy &amp; maintain hundreds of RDB keeping the last hour in memory, HDBs with the actual historical data, pausing for hourly write downs of the data, mirroring trees replicating the data using IPC over TCP from the matching engine down to the RDBs&#x2F;HDBs, recon jobs to verify that the data across all the hosts.. Not to mention that such a TCP-IPC distribution tree with single threaded applications means that any single replica stuck down the line (e.g. big query, or too slow to restart) will typically lead to a complete lockup - all the way to the matching engine - so then you need to start writing logic for circuit breakers to trip both the distribution &amp; the querying (nothing out of the box). And then at some point you need to start implementing custom sharding mechanisms for both distribution &amp; querying (nothing out of the box once again..!) across the hundreds of processes and dozens of servers (which has implications with the circuit breakers) because replicating the whole KDB dataset across dozens of servers (to scale the requests&#x2F;sec you can factually serve in a reasonable timeframe) get absolutely batshit crazy expensive.<p>And this is the architecture as designed and recommended by the KX consultants that you end up having to hire to “scale” to service nothing but a few billions dollars in daily leveraged trades.<p>Everything we have is now in Java - all financial&#x2F;mathematical logic ported over 1:1 with no changes in data schema (neither in house neither for customers), uses disruptors, convenient chronicle&#x2F;aeron queues that we can replay anytime (recovery, certifying, troubleshooting, rollback, benchmarks, etc), and infinitely scalable and sharded s3&#x2F;trino&#x2F;scylladb for historical.. Performance is orders of magnitude up (despite the thousands of hours micro-optimizing the KDB stack + the millions in KX consultants - and without any Java optimizations really), incidents became essentially non-existent overnight, and the payroll + infra bills got also divided by a very meaningful factor :]</div><br/><div id="41144450" class="c"><input type="checkbox" id="c-41144450" checked=""/><div class="controls bullet"><span class="by">parentheses</span><span>|</span><a href="#41144349">parent</a><span>|</span><a href="#41144584">next</a><span>|</span><label class="collapse" for="c-41144450">[-]</label><label class="expand" for="c-41144450">[3 more]</label></div><br/><div class="children"><div class="content">I think the adulation is mainly driven by the a few things:<p>1. it was fast by a huge margin for its time<p>2. the reason for its speed is the language behind it<p>3. it uses an esoteric language and still attains success<p>4. the core engine is implemented using surprisingly few lines of code<p>5. the core has been written and maintained by one person<p>All of these are things I&#x27;ve heard so I can&#x27;t claim it&#x27;s 100% true but I&#x27;m sure it&#x27;s a combination of some of these.<p>I feel like APL and all its relatives had long ago gained legendary status. So the legend lives on - maybe longer than it should.<p>Don&#x27;t get me wrong. It&#x27;s still amazing!</div><br/><div id="41144552" class="c"><input type="checkbox" id="c-41144552" checked=""/><div class="controls bullet"><span class="by">RodgerTheGreat</span><span>|</span><a href="#41144349">root</a><span>|</span><a href="#41144450">parent</a><span>|</span><a href="#41144584">next</a><span>|</span><label class="collapse" for="c-41144552">[-]</label><label class="expand" for="c-41144552">[2 more]</label></div><br/><div class="children"><div class="content">Compared to similar dynamic scripting languages, Q is very vast. Compared to statically compiled languages, it <i>can</i> be surprisingly competitive, but is usually slower. The truly distinctive thing about Q is its efficiency as a <i>user interface</i>: at a REPL you can rattle off a short sequence of characters to transform and interrogate large datasets at interactive speeds and flexibly debug complex distributed systems live. In the right hands, it&#x27;s a stunningly effective rapid-application-development tool (the above &quot;quant desk scenario&quot;); this was perhaps even more true in the k2 days when it was possible to build ugly but blisteringly fast and utilitarian data-bound GUIs for K programs in a few lines of code. There&#x27;s certainly an abundance of romanticism and mythology surrounding it, but <i>some</i> of the claims are real and enduringly unmatched.</div><br/><div id="41144676" class="c"><input type="checkbox" id="c-41144676" checked=""/><div class="controls bullet"><span class="by">benjaminwootton</span><span>|</span><a href="#41144349">root</a><span>|</span><a href="#41144552">parent</a><span>|</span><a href="#41144584">next</a><span>|</span><label class="collapse" for="c-41144676">[-]</label><label class="expand" for="c-41144676">[1 more]</label></div><br/><div class="children"><div class="content">Python in a Notebook is “REPL like” and much more modern.<p>And though I agree low code is important, Streamlit or Dash are a much more fully featured and open way to do that.<p>I agree KDB has a good development workflow, but I think the same is available in an open source stack like ClickHouse + Python + Jupyter.</div><br/></div></div></div></div></div></div><div id="41144584" class="c"><input type="checkbox" id="c-41144584" checked=""/><div class="controls bullet"><span class="by">cheikhcheikh</span><span>|</span><a href="#41144349">parent</a><span>|</span><a href="#41144450">prev</a><span>|</span><a href="#41145708">next</a><span>|</span><label class="collapse" for="c-41144584">[-]</label><label class="expand" for="c-41144584">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m very curious about this rewrite in Java, especially the orders of magnitude improvement. That sounds extremely impressive, and something that I wouldn&#x27;t have considered possible. Can you share a bit more about how this performance improvement is achieved?</div><br/></div></div></div></div><div id="41145708" class="c"><input type="checkbox" id="c-41145708" checked=""/><div class="controls bullet"><span class="by">nhourcard</span><span>|</span><a href="#41144349">prev</a><span>|</span><a href="#41144248">next</a><span>|</span><label class="collapse" for="c-41145708">[-]</label><label class="expand" for="c-41145708">[1 more]</label></div><br/><div class="children"><div class="content">TLDR from the article;<p>Alternatives (which are open source) to KDB+ are split into two categories:<p>New Database Technologies (tick data store &amp; ASOF JOIN):
Clickhouse &amp; QuestDB<p>Local Quant Analysis:
Python – with DuckDB &amp; Polars<p>Some personal thoughts:<p>Q is very expressive, and impressive performance can be extracted from kdb+, but the drawbacks are proprietary formats, vendor lock-in, costs, proprietary language and reliance on external consultants to make the system run adequately, which can increase operational costs.<p>I&#x27;m personally excited to see the open-source alternative stack emerging. Open Source time-series databases and tools like duckdb&#x2F;polars for data science are a good combination. Storing everything in open formats like Parquet and leveraging high-performance frameworks like Arrow is probably where things are heading.<p>Seeing some disruption in this industry specifically is interesting; I think it will be beneficial, particularly for developers.<p>NB: disclosing that I&#x27;m from questdb to put thoughts in perspective</div><br/></div></div><div id="41144248" class="c"><input type="checkbox" id="c-41144248" checked=""/><div class="controls bullet"><span class="by">tarek_computer</span><span>|</span><a href="#41145708">prev</a><span>|</span><label class="collapse" for="c-41144248">[-]</label><label class="expand" for="c-41144248">[3 more]</label></div><br/><div class="children"><div class="content">It is an old product that is no longer relevant, and there is no longer any demand for it. Time to move on.</div><br/><div id="41144309" class="c"><input type="checkbox" id="c-41144309" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#41144248">parent</a><span>|</span><a href="#41144314">next</a><span>|</span><label class="collapse" for="c-41144309">[-]</label><label class="expand" for="c-41144309">[1 more]</label></div><br/><div class="children"><div class="content">&quot;<i>Please don&#x27;t post shallow dismissals, especially of other people&#x27;s work. A good critical comment teaches us something.</i>&quot;<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;newsguidelines.html">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;newsguidelines.html</a></div><br/></div></div><div id="41144314" class="c"><input type="checkbox" id="c-41144314" checked=""/><div class="controls bullet"><span class="by">helsinki</span><span>|</span><a href="#41144248">parent</a><span>|</span><a href="#41144309">prev</a><span>|</span><label class="collapse" for="c-41144314">[-]</label><label class="expand" for="c-41144314">[1 more]</label></div><br/><div class="children"><div class="content">Trillions of dollars in the financial system beg to differ.</div><br/></div></div></div></div></div></div></div></div></div></body></html>