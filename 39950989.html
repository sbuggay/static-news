<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1712566861305" as="style"/><link rel="stylesheet" href="styles.css?v=1712566861305"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://susam.net/programming-with-dos-debugger.html">Programming with DOS Debugger (2003)</a>Â <span class="domain">(<a href="https://susam.net">susam.net</a>)</span></div><div class="subtext"><span>susam</span> | <span>20 comments</span></div><br/><div><div id="39965828" class="c"><input type="checkbox" id="c-39965828" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#39967608">next</a><span>|</span><label class="collapse" for="c-39965828">[-]</label><label class="expand" for="c-39965828">[8 more]</label></div><br/><div class="children"><div class="content"><i>The fact that this debugger program is always available with MS-DOS or Windows 98 system means that these systems are ready for some rudimentary assembly language programming without requiring any additional tools.</i><p>PC magazines from the 80s through the 90s took advantage of this, publishing listings of &quot;source code&quot; that could be typed into DEBUG to create tiny but useful utilities, mostly under 1K in size. It was an era when &quot;power users&quot; or even moderately advanced users would often know some actual programming too and many grew into full-time developers; a stark contrast from these days when many &quot;real&quot; developers barely understand anything about their environment (and are incentivised not to.)</div><br/><div id="39965972" class="c"><input type="checkbox" id="c-39965972" checked=""/><div class="controls bullet"><span class="by">frogulis</span><span>|</span><a href="#39965828">parent</a><span>|</span><a href="#39967608">next</a><span>|</span><label class="collapse" for="c-39965972">[-]</label><label class="expand" for="c-39965972">[7 more]</label></div><br/><div class="children"><div class="content">&gt; and are incentivised not to<p>Could you elaborate on that?</div><br/><div id="39966289" class="c"><input type="checkbox" id="c-39966289" checked=""/><div class="controls bullet"><span class="by">13of40</span><span>|</span><a href="#39965828">root</a><span>|</span><a href="#39965972">parent</a><span>|</span><a href="#39966077">next</a><span>|</span><label class="collapse" for="c-39966289">[-]</label><label class="expand" for="c-39966289">[3 more]</label></div><br/><div class="children"><div class="content">Example:  Everyone knows how to use a Dictionary.  It&#x27;s not worth anyone&#x27;s time to know how it works under the hood, because only a fool would actually implement one from scratch in production code.  Niche embedded cases possibly excepted.</div><br/><div id="39967098" class="c"><input type="checkbox" id="c-39967098" checked=""/><div class="controls bullet"><span class="by">kqr</span><span>|</span><a href="#39965828">root</a><span>|</span><a href="#39966289">parent</a><span>|</span><a href="#39966077">next</a><span>|</span><label class="collapse" for="c-39967098">[-]</label><label class="expand" for="c-39967098">[2 more]</label></div><br/><div class="children"><div class="content">I would argue this is because we&#x27;ve raised the bar for what counts as a computational primitive, and not a qualitative difference.<p>A modern developer can ignore the details of a dictionary in the exact same way a programmer of the past could ignore the details of the mov instruction. (And be more productive for it.)</div><br/><div id="39967313" class="c"><input type="checkbox" id="c-39967313" checked=""/><div class="controls bullet"><span class="by">ale42</span><span>|</span><a href="#39965828">root</a><span>|</span><a href="#39967098">parent</a><span>|</span><a href="#39966077">next</a><span>|</span><label class="collapse" for="c-39967313">[-]</label><label class="expand" for="c-39967313">[1 more]</label></div><br/><div class="children"><div class="content">The problem is when developers having virtually no background in actual computer science (e.g. algorithm complexity) start implementing their own algorithms because what thy want is not directly available as a primitive. I have the impression that this tendency to use more and more complex software primitives, while at the same time introducing further levels of indirection in the actually run machine code, is one of the reasons that many applications are now as slow (or slower) than they were 10 years ago despite the hardware being much faster. Just compare the performance of an Electron-based application (which seems the go-to solution of most developers nowadays for desktop app implementation) with a native one...</div><br/></div></div></div></div></div></div><div id="39966077" class="c"><input type="checkbox" id="c-39966077" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#39965828">root</a><span>|</span><a href="#39965972">parent</a><span>|</span><a href="#39966289">prev</a><span>|</span><a href="#39967608">next</a><span>|</span><label class="collapse" for="c-39966077">[-]</label><label class="expand" for="c-39966077">[3 more]</label></div><br/><div class="children"><div class="content">Not much time for in-depth learning when you have sprint commitments to make. Just have Copilot generate the boilerplate and tests and fix them as you go.</div><br/><div id="39967120" class="c"><input type="checkbox" id="c-39967120" checked=""/><div class="controls bullet"><span class="by">exe34</span><span>|</span><a href="#39965828">root</a><span>|</span><a href="#39966077">parent</a><span>|</span><a href="#39966377">next</a><span>|</span><label class="collapse" for="c-39967120">[-]</label><label class="expand" for="c-39967120">[1 more]</label></div><br/><div class="children"><div class="content">Gotta keep that velocity up!</div><br/></div></div><div id="39966377" class="c"><input type="checkbox" id="c-39966377" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#39965828">root</a><span>|</span><a href="#39966077">parent</a><span>|</span><a href="#39967120">prev</a><span>|</span><a href="#39967608">next</a><span>|</span><label class="collapse" for="c-39966377">[-]</label><label class="expand" for="c-39966377">[1 more]</label></div><br/><div class="children"><div class="content">Or copy-paste from stackunderflow.</div><br/></div></div></div></div></div></div></div></div><div id="39967608" class="c"><input type="checkbox" id="c-39967608" checked=""/><div class="controls bullet"><span class="by">keepamovin</span><span>|</span><a href="#39965828">prev</a><span>|</span><a href="#39966860">next</a><span>|</span><label class="collapse" for="c-39967608">[-]</label><label class="expand" for="c-39967608">[1 more]</label></div><br/><div class="children"><div class="content">This is where I first learned to program. the manual for MS-DOS 3.1 I think it was  came with instructions for the debugger and assembler, and how you could create programs.</div><br/></div></div><div id="39966860" class="c"><input type="checkbox" id="c-39966860" checked=""/><div class="controls bullet"><span class="by">tommieb</span><span>|</span><a href="#39967608">prev</a><span>|</span><a href="#39965906">next</a><span>|</span><label class="collapse" for="c-39966860">[-]</label><label class="expand" for="c-39966860">[1 more]</label></div><br/><div class="children"><div class="content">Lovely article, that brought back memories!
A wee pedantic bit here, to exit the program, it was the school of thought, to use the following instruction - set the exit code to zero and issue terminate.<p>mov ah, 4ch
mov al, 00h
; Or combine both mov into mov ax, 4c00h
int 21h</div><br/></div></div><div id="39965906" class="c"><input type="checkbox" id="c-39965906" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39966860">prev</a><span>|</span><a href="#39966221">next</a><span>|</span><label class="collapse" for="c-39965906">[-]</label><label class="expand" for="c-39965906">[1 more]</label></div><br/><div class="children"><div class="content">I once made a tiny pre-emptive kernel using the DOS debugger. It was like the day after graduating from CS undergrad, and I needed a cleanse from the many years-long C on Unix mission (which happens to be continuing, decades later).</div><br/></div></div><div id="39966221" class="c"><input type="checkbox" id="c-39966221" checked=""/><div class="controls bullet"><span class="by">EvanAnderson</span><span>|</span><a href="#39965906">prev</a><span>|</span><a href="#39954524">next</a><span>|</span><label class="collapse" for="c-39966221">[-]</label><label class="expand" for="c-39966221">[3 more]</label></div><br/><div class="children"><div class="content">Debug is a passable quick-and-dirty assembler. It&#x27;s no fun to refactor code after you&#x27;ve resolved all the addresses and hard-coded them into the &quot;source&quot; but when you&#x27;re in a pinch and don&#x27;t have access to real tools it works well.</div><br/><div id="39966737" class="c"><input type="checkbox" id="c-39966737" checked=""/><div class="controls bullet"><span class="by">netmare</span><span>|</span><a href="#39966221">parent</a><span>|</span><a href="#39954524">next</a><span>|</span><label class="collapse" for="c-39966737">[-]</label><label class="expand" for="c-39966737">[2 more]</label></div><br/><div class="children"><div class="content">I &quot;solved&quot; that by using two assembling passes. The first had dummy jump&#x2F;call addresses in order to determine the code offsets of labels. Then I would resolve the relative offsets, replace the target labels with offset deltas and reassemble.<p>I used that trick to speed up my QBasic programs with graphics, string and list handling, etc. It was one of the first rewarding times in my programming &quot;career&quot; and it actually made me feel proud of myself.</div><br/><div id="39967341" class="c"><input type="checkbox" id="c-39967341" checked=""/><div class="controls bullet"><span class="by">EvanAnderson</span><span>|</span><a href="#39966221">root</a><span>|</span><a href="#39966737">parent</a><span>|</span><a href="#39954524">next</a><span>|</span><label class="collapse" for="c-39967341">[-]</label><label class="expand" for="c-39967341">[1 more]</label></div><br/><div class="children"><div class="content">Yeah-- I did the same thing. It just sucks when you&#x27;ve forgotten s prefix or a push&#x2F;pop early in the code and you have to retarget all the subsequent addresses. It really makes you appreciate a real assembler.</div><br/></div></div></div></div></div></div><div id="39954524" class="c"><input type="checkbox" id="c-39954524" checked=""/><div class="controls bullet"><span class="by">M95D</span><span>|</span><a href="#39966221">prev</a><span>|</span><a href="#39966054">next</a><span>|</span><label class="collapse" for="c-39954524">[-]</label><label class="expand" for="c-39954524">[1 more]</label></div><br/><div class="children"><div class="content">I liked the Hello World program = 17 bytes. 13B is just the text to print.</div><br/></div></div><div id="39966054" class="c"><input type="checkbox" id="c-39966054" checked=""/><div class="controls bullet"><span class="by">dleslie</span><span>|</span><a href="#39954524">prev</a><span>|</span><a href="#39966368">next</a><span>|</span><label class="collapse" for="c-39966054">[-]</label><label class="expand" for="c-39966054">[2 more]</label></div><br/><div class="children"><div class="content">I still have a copy of &quot;Assembly language step-by-step&quot; which started with DEBUG then moved to nasm in later chapters.</div><br/><div id="39966548" class="c"><input type="checkbox" id="c-39966548" checked=""/><div class="controls bullet"><span class="by">Zardoz84</span><span>|</span><a href="#39966054">parent</a><span>|</span><a href="#39966368">next</a><span>|</span><label class="collapse" for="c-39966548">[-]</label><label class="expand" for="c-39966548">[1 more]</label></div><br/><div class="children"><div class="content">I have yet a book of Peter Norton of 80286 assembly that uses DEBUG a lot to do the first steps programming assembly.</div><br/></div></div></div></div><div id="39966368" class="c"><input type="checkbox" id="c-39966368" checked=""/><div class="controls bullet"><span class="by">peter_d_sherman</span><span>|</span><a href="#39966054">prev</a><span>|</span><label class="collapse" for="c-39966368">[-]</label><label class="expand" for="c-39966368">[2 more]</label></div><br/><div class="children"><div class="content">A few things to point out:<p>1) The Debugger and the program being debugged -- are effectively running in the <i>same execution environment</i>; the <i>same memory space</i> (both programs are different ranges of the same memory and both can access each other&#x27;s memory without restrictions, but only one can be running at one time (single stepping swaps control (for an instant) and then swaps it back again, as does running under the debugger until a breakpoint is hit -- as there are absolutely NO threads (concurrent code execution paths) in this environment!)<p>If the debugged program crashes for any reason, for example, enters an infinite loop and&#x2F;or doesn&#x27;t yield control back to the debugger via executing a RET instruction -- then the entire PC (if DOS is running directly on hardware (as opposed to under Windows and&#x2F;or a VM) will crash, AKA &quot;lock-up&quot;!  Powering the entire machine on and off is now necessary to reboot it! (Dave Letterman, many years ago, in response to the then-feared upcoming Y2K disaster: &quot;Just Reboot!&quot;)<p>2) While this mode of programming is hard, laborious, counter-intuitive, slow, and error-prone(!) -- it should also be <i>lauded, praised</i> -- because equal-and-oppositely, whoever is programming at this level has effectively <i>gotten rid of 99.99% of the &quot;tech stack&quot; dependencies</i> -- the code written by other programmers in compilers, operating systems, programing languages, programming environments, libraries, frameworks, tech stacks, other software components, etc., etc.<p>Oh sure, there&#x27;s still DOS in the background... but the DOS code&#x2F;API fits into like what, like 32KB? (That&#x27;s Kilobytes with a &#x27;K&#x27;, not Megabytes or Gigabytes... several orders of magnitude smaller...)<p>And a pure assembly low-level programmer -- does not even need to depend&#x2F;rely on DOS or BIOS calls... they can effectively get rid of those too by writing their own hardware drivers... OS developers that write in Assembly typically do this or something like this...<p>Anyway, an excellent article!</div><br/><div id="39966937" class="c"><input type="checkbox" id="c-39966937" checked=""/><div class="controls bullet"><span class="by">rahen</span><span>|</span><a href="#39966368">parent</a><span>|</span><label class="collapse" for="c-39966937">[-]</label><label class="expand" for="c-39966937">[1 more]</label></div><br/><div class="children"><div class="content">DOS makes a nice runtime for low level and embedded applications.
Some implementations are 64 bits, such as this one: <a href="https:&#x2F;&#x2F;github.com&#x2F;dosemu2&#x2F;fdpp">https:&#x2F;&#x2F;github.com&#x2F;dosemu2&#x2F;fdpp</a><p>I wish there were an ARM-compatible version of DOS, if possible stateless. It would often be more suitable for an ARM board than a full-fledged Linux, given its almost non-existent attack surface, low resource consumption, and simplicity. Heck, I&#x27;d even like to see DOS microservices on stateless nano-VMs.</div><br/></div></div></div></div></div></div></div></div></div></body></html>