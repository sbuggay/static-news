<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1733562053692" as="style"/><link rel="stylesheet" href="styles.css?v=1733562053692"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoUnionTypesComplexities">Union types (&#x27;enum types&#x27;) would be complicated in Go</a> <span class="domain">(<a href="https://utcc.utoronto.ca">utcc.utoronto.ca</a>)</span></div><div class="subtext"><span>misonic</span> | <span>29 comments</span></div><br/><div><div id="42348055" class="c"><input type="checkbox" id="c-42348055" checked=""/><div class="controls bullet"><span class="by">brundolf</span><span>|</span><a href="#42347742">next</a><span>|</span><label class="collapse" for="c-42348055">[-]</label><label class="expand" for="c-42348055">[1 more]</label></div><br/><div class="children"><div class="content">Forget Result, just allow the type system to express non-nullable object references. Use the same layout, just let the compiler know when something is guaranteed to exist and force null-checking when it isn&#x27;t<p>This doesn&#x27;t cover everything people might want to do with unions, but it covers the billion-dollar mistake and doesn&#x27;t run against the grain of the entire language (as far as I know)</div><br/></div></div><div id="42347742" class="c"><input type="checkbox" id="c-42347742" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42348055">prev</a><span>|</span><a href="#42347919">next</a><span>|</span><label class="collapse" for="c-42347742">[-]</label><label class="expand" for="c-42347742">[4 more]</label></div><br/><div class="children"><div class="content">No it wouldn&#x27;t, as there are garbage collected systems programming languages with them, already 40 years ago, but as usual in Go, we ignore computing  history.<p>Additionally, just having actual enumerations, Pascal &#x2F; Algo style, not ML style, would already be an improvement over the iota&#x2F;const hack.</div><br/><div id="42347914" class="c"><input type="checkbox" id="c-42347914" checked=""/><div class="controls bullet"><span class="by">philosopher1234</span><span>|</span><a href="#42347742">parent</a><span>|</span><a href="#42347919">next</a><span>|</span><label class="collapse" for="c-42347914">[-]</label><label class="expand" for="c-42347914">[3 more]</label></div><br/><div class="children"><div class="content">The author of this blog is an internet commenter, not a representative of Go. I don’t see how such a post justifies saying that Go ignores computing history.</div><br/><div id="42348261" class="c"><input type="checkbox" id="c-42348261" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42347742">root</a><span>|</span><a href="#42347914">parent</a><span>|</span><a href="#42347974">next</a><span>|</span><label class="collapse" for="c-42348261">[-]</label><label class="expand" for="c-42348261">[1 more]</label></div><br/><div class="children"><div class="content">Past history of most folks on Go community, including this post essay about Go&#x27;s type system and related &quot;difficulty&quot; of implementation.</div><br/></div></div><div id="42347974" class="c"><input type="checkbox" id="c-42347974" checked=""/><div class="controls bullet"><span class="by">tempodox</span><span>|</span><a href="#42347742">root</a><span>|</span><a href="#42347914">parent</a><span>|</span><a href="#42348261">prev</a><span>|</span><a href="#42347919">next</a><span>|</span><label class="collapse" for="c-42347974">[-]</label><label class="expand" for="c-42347974">[1 more]</label></div><br/><div class="children"><div class="content">This post has nothing to do with Go ignoring computing history.  The authors&#x2F;maintainers of Go can do that just fine on their own.</div><br/></div></div></div></div></div></div><div id="42347919" class="c"><input type="checkbox" id="c-42347919" checked=""/><div class="controls bullet"><span class="by">melodyogonna</span><span>|</span><a href="#42347742">prev</a><span>|</span><a href="#42305999">next</a><span>|</span><label class="collapse" for="c-42347919">[-]</label><label class="expand" for="c-42347919">[5 more]</label></div><br/><div class="children"><div class="content">The important detail that has bogged down almost every union type discussion is &quot;zero values&quot;. What would be the zero value of a union type?
If you&#x27;ve written Go you know the entire language is built around zero values, disabling it for some types is not an option.</div><br/><div id="42348329" class="c"><input type="checkbox" id="c-42348329" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42347919">parent</a><span>|</span><a href="#42347967">next</a><span>|</span><label class="collapse" for="c-42348329">[-]</label><label class="expand" for="c-42348329">[1 more]</label></div><br/><div class="children"><div class="content">You could use the first entry, or require an explicit annotation. That doesn&#x27;t seem like a big issue.</div><br/></div></div><div id="42347967" class="c"><input type="checkbox" id="c-42347967" checked=""/><div class="controls bullet"><span class="by">the_gipsy</span><span>|</span><a href="#42347919">parent</a><span>|</span><a href="#42348329">prev</a><span>|</span><a href="#42305999">next</a><span>|</span><label class="collapse" for="c-42347967">[-]</label><label class="expand" for="c-42347967">[3 more]</label></div><br/><div class="children"><div class="content">Couldn&#x27;t it be just the first enum item? Zero values are somewhat arbitrary anyway.</div><br/><div id="42347986" class="c"><input type="checkbox" id="c-42347986" checked=""/><div class="controls bullet"><span class="by">melodyogonna</span><span>|</span><a href="#42347919">root</a><span>|</span><a href="#42347967">parent</a><span>|</span><a href="#42305999">next</a><span>|</span><label class="collapse" for="c-42347986">[-]</label><label class="expand" for="c-42347986">[2 more]</label></div><br/><div class="children"><div class="content">Why would it be just the first enum item? How do you even determine how the enum is ordered?</div><br/><div id="42348178" class="c"><input type="checkbox" id="c-42348178" checked=""/><div class="controls bullet"><span class="by">riwsky</span><span>|</span><a href="#42347919">root</a><span>|</span><a href="#42347986">parent</a><span>|</span><a href="#42305999">next</a><span>|</span><label class="collapse" for="c-42348178">[-]</label><label class="expand" for="c-42348178">[1 more]</label></div><br/><div class="children"><div class="content">Source order, presumably?</div><br/></div></div></div></div></div></div></div></div><div id="42305999" class="c"><input type="checkbox" id="c-42305999" checked=""/><div class="controls bullet"><span class="by">foldr</span><span>|</span><a href="#42347919">prev</a><span>|</span><a href="#42347623">next</a><span>|</span><label class="collapse" for="c-42305999">[-]</label><label class="expand" for="c-42305999">[10 more]</label></div><br/><div class="children"><div class="content">I think this is mistaken. Go already has a way to represent &#x27;open&#x27; union types (interfaces), so all of these runtime problems have already been solved. What&#x27;s missing is just the type system support to do exhaustive matching on the members of the union. With the addition of generics, &#x27;all&#x27; that would be necessary is to make the following a legal variable definition:<p><pre><code>    var foo interface {
        struct { A int } | struct { B string }
    }
</code></pre>
It currently fails with the following error:<p>&quot;cannot use type interface{struct{A int} | struct{B string}} outside a type constraint: interface contains type constraints&quot;</div><br/><div id="42319851" class="c"><input type="checkbox" id="c-42319851" checked=""/><div class="controls bullet"><span class="by">siebenmann</span><span>|</span><a href="#42305999">parent</a><span>|</span><a href="#42347043">next</a><span>|</span><label class="collapse" for="c-42319851">[-]</label><label class="expand" for="c-42319851">[6 more]</label></div><br/><div class="children"><div class="content">Interfaces aren&#x27;t bit-packed and they force storing all values as a separate allocation that the interface contains a pointer to (escape analysis may allow this separate value to be on the stack, along with the interface itself). I believe that Go used to have an optimization where values that fit in a pointer were stored directly in the interface value, but abandoned it, perhaps partly because of the GC &#x27;is it a pointer or not&#x27; issue. In my view, some of what people want union types for is exactly efficient bit-packing that uses little or no additional storage, and they&#x27;d be unhappy with a &#x27;union values are just interface values&#x27; implementation.<p>(I&#x27;m the author of the linked to article.)</div><br/><div id="42321918" class="c"><input type="checkbox" id="c-42321918" checked=""/><div class="controls bullet"><span class="by">foldr</span><span>|</span><a href="#42305999">root</a><span>|</span><a href="#42319851">parent</a><span>|</span><a href="#42347043">next</a><span>|</span><label class="collapse" for="c-42321918">[-]</label><label class="expand" for="c-42321918">[5 more]</label></div><br/><div class="children"><div class="content">A separate allocation is not forced. The implementation could allocate a block of memory large enough to hold the two pointers for the interface value together with the largest of the types that implements the interface. (You can&#x27;t do that with an open interface because there&#x27;s no upper bound, but the idea here is to let you define closed interfaces.)<p>In cases where there is a lot of variance in the size of the different interface implementations, separate allocations could actually be more memory efficient than a tagged union. In any case, I&#x27;m not sure that memory efficiency is the main reason that people miss Rust-style enums in Go.</div><br/><div id="42322060" class="c"><input type="checkbox" id="c-42322060" checked=""/><div class="controls bullet"><span class="by">siebenmann</span><span>|</span><a href="#42305999">root</a><span>|</span><a href="#42321918">parent</a><span>|</span><a href="#42347043">next</a><span>|</span><label class="collapse" for="c-42322060">[-]</label><label class="expand" for="c-42322060">[4 more]</label></div><br/><div class="children"><div class="content">The problem with allocating bit-packed storage is that then you are into the issue where types don&#x27;t agree on where any pointers are. Interface values solve this today because they are always mono-typed (an interface value always stores two pointers), so the runtime is never forced to know the current pointer-containing shape of a specific interface value. And the values that interface values &#x27;contain&#x27; are also always a fixed type, so they can be allocated and maintained with existing GC mechanisms (including special allocation pools for objects without pointers and etc etc).<p>I agree with you about the overall motivation for Rust-style enums. I just think it&#x27;s surprisingly complex to get even the memory efficiency advantages, never mind anything more ambitious.</div><br/><div id="42347144" class="c"><input type="checkbox" id="c-42347144" checked=""/><div class="controls bullet"><span class="by">ryanpetrich</span><span>|</span><a href="#42305999">root</a><span>|</span><a href="#42322060">parent</a><span>|</span><a href="#42346996">next</a><span>|</span><label class="collapse" for="c-42347144">[-]</label><label class="expand" for="c-42347144">[1 more]</label></div><br/><div class="children"><div class="content">The bigger problem is mutability. Any pointers into the bit-packed enum storage become invalid as soon as you change its type. To solve this you can either prohibit pointers into bit-packed enum storage, which is very limiting, or introduce immutability into the language. Immutability is particularly difficult to add to go, where default zero-values emerge in unexpected places (such as the spare capacity of slices and the default state of named return values)</div><br/></div></div><div id="42346996" class="c"><input type="checkbox" id="c-42346996" checked=""/><div class="controls bullet"><span class="by">treyd</span><span>|</span><a href="#42305999">root</a><span>|</span><a href="#42322060">parent</a><span>|</span><a href="#42347144">prev</a><span>|</span><a href="#42326442">next</a><span>|</span><label class="collapse" for="c-42346996">[-]</label><label class="expand" for="c-42346996">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The problem with allocating bit-packed storage is that then you are into the issue where types don&#x27;t agree on where any pointers are.<p>The solution to this should be trivial.  You just have to extend the gcshape concept to account for the enum discriminator.</div><br/></div></div><div id="42326442" class="c"><input type="checkbox" id="c-42326442" checked=""/><div class="controls bullet"><span class="by">foldr</span><span>|</span><a href="#42305999">root</a><span>|</span><a href="#42322060">parent</a><span>|</span><a href="#42346996">prev</a><span>|</span><a href="#42347043">next</a><span>|</span><label class="collapse" for="c-42326442">[-]</label><label class="expand" for="c-42326442">[1 more]</label></div><br/><div class="children"><div class="content">I was saying that you can have a single allocation without using bit packing.<p>I&#x27;m not sure what you&#x27;re referring to with &#x27;anything more ambitious&#x27;.</div><br/></div></div></div></div></div></div></div></div><div id="42347043" class="c"><input type="checkbox" id="c-42347043" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#42305999">parent</a><span>|</span><a href="#42319851">prev</a><span>|</span><a href="#42347623">next</a><span>|</span><label class="collapse" for="c-42347043">[-]</label><label class="expand" for="c-42347043">[3 more]</label></div><br/><div class="children"><div class="content">The problem with that is that in Go, I need to be able to put methods on those things, for reasons possibly unrelated to the interface in question. For that they need to be named. For that you might as well do what has worked since Go 1.0 and just put an unexported method in the interface and declare several instances of that interface in your package.<p>Honestly interfaces with unexported methods are 90%+ of what people want. It&#x27;s just not spelled the way they expect. And if you&#x27;re not going to be happy except at absolutely 100%, a position I can and do respect, there&#x27;s no point waiting for Go to get any better because I can guarantee you no Go proposal for sum types will fix that you will be forced to have a &quot;nil&quot; value in the sum type, so there&#x27;s no point in waiting.</div><br/><div id="42347531" class="c"><input type="checkbox" id="c-42347531" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#42305999">root</a><span>|</span><a href="#42347043">parent</a><span>|</span><a href="#42347623">next</a><span>|</span><label class="collapse" for="c-42347531">[-]</label><label class="expand" for="c-42347531">[2 more]</label></div><br/><div class="children"><div class="content">The zero would obviously be the zero value of one of the constituents. Coproducts in most of Go are easy: it&#x27;s interfaces that make it hard.</div><br/><div id="42348024" class="c"><input type="checkbox" id="c-42348024" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#42305999">root</a><span>|</span><a href="#42347531">parent</a><span>|</span><a href="#42347623">next</a><span>|</span><label class="collapse" for="c-42348024">[-]</label><label class="expand" for="c-42348024">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The zero would obviously be the zero value of one of the constituents.<p>If interfaces are used for union types then the obvious zero is nil, not any constituent. Nil is the zero value of interfaces.<p>It’s perfectly consistent and in line with the rest of the langage.</div><br/></div></div></div></div></div></div></div></div><div id="42347623" class="c"><input type="checkbox" id="c-42347623" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#42305999">prev</a><span>|</span><a href="#42348023">next</a><span>|</span><label class="collapse" for="c-42347623">[-]</label><label class="expand" for="c-42347623">[4 more]</label></div><br/><div class="children"><div class="content">&gt; One core requirement for this is what Rust calls an Enum and what is broadly known as a Union type<p>Union types and enum types are not the same thing, and this misunderstanding invalidates the entire article. An enum type includes a marker which indicates which value it contains. The garbage collector would be able to read this tag value and know.</div><br/><div id="42347668" class="c"><input type="checkbox" id="c-42347668" checked=""/><div class="controls bullet"><span class="by">hmry</span><span>|</span><a href="#42347623">parent</a><span>|</span><a href="#42347688">next</a><span>|</span><label class="collapse" for="c-42347668">[-]</label><label class="expand" for="c-42347668">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know what to tell you, there are just multiple ways to use the same words.<p>What Rust calls enums are called tagged unions in most other languages. Enum usually refers to a simple collection of named values, what Rust calls fieldless enums or unit-only enums.</div><br/><div id="42347686" class="c"><input type="checkbox" id="c-42347686" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#42347623">root</a><span>|</span><a href="#42347668">parent</a><span>|</span><a href="#42347688">next</a><span>|</span><label class="collapse" for="c-42347686">[-]</label><label class="expand" for="c-42347686">[1 more]</label></div><br/><div class="children"><div class="content">&gt; are called tagged unions in most other languages<p>Not sure about that. Swift also calls them enums, in Java and Kotlin (and maybe Scala? I forget) they&#x27;re sealed classes&#x2F;interfaces and in PL theory and many typed FP languages they&#x27;re called &quot;sum types&quot;.</div><br/></div></div></div></div><div id="42347688" class="c"><input type="checkbox" id="c-42347688" checked=""/><div class="controls bullet"><span class="by">cookiengineer</span><span>|</span><a href="#42347623">parent</a><span>|</span><a href="#42347668">prev</a><span>|</span><a href="#42348023">next</a><span>|</span><label class="collapse" for="c-42347688">[-]</label><label class="expand" for="c-42347688">[1 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t an enum in go not only be different in what the reflections API sees behind the scenes?<p>In the sense that it first points to the type, and then to the value, similar to how other newer types are already implemented?<p>type whatever enum {<p><pre><code>  value1 iota

  value2
</code></pre>
}<p>enum would just be a similar shorthand to uint or whatever you want to identify it uniquely.<p>I don&#x27;t see much problem implementing this apart from the methods in the GC that have to be touched to trace the object tree correctly.<p>The comparison handling must be touched in either case, so I don&#x27;t think an additional pointer to the enum&#x27;s definition there counts as much work.</div><br/></div></div></div></div><div id="42348023" class="c"><input type="checkbox" id="c-42348023" checked=""/><div class="controls bullet"><span class="by">lordofgibbons</span><span>|</span><a href="#42347623">prev</a><span>|</span><a href="#42347863">next</a><span>|</span><label class="collapse" for="c-42348023">[-]</label><label class="expand" for="c-42348023">[1 more]</label></div><br/><div class="children"><div class="content">This is sorely needed to simplify error handling and getting rid of nil pointers panics. Would love to see a linter written for Go after something like this is created to ensure absolutely no naked pointer is ever returned.</div><br/></div></div><div id="42347863" class="c"><input type="checkbox" id="c-42347863" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#42348023">prev</a><span>|</span><a href="#42347695">next</a><span>|</span><label class="collapse" for="c-42347863">[-]</label><label class="expand" for="c-42347863">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve thought about this while working with Go more frequently over the past few months.<p>Metadata.  The same way shapes of functions let Go know which generic &#x27;profile&#x27; to use for a given thing are metadata.  Just like when a reference to something is taken that type is compile time metadata.<p>Structure.  The precise layout of structures and other data fields is also compile time metadata.  They don&#x27;t even need to remain the same between versions of go, or even builds if somehow they&#x27;re randomized.  That isn&#x27;t how programmer&#x27;s think (at least any who were also trained in assembly???).  When I lay out a struct I do expect undersized fields to get padded, but I expect every field in order, and I&#x27;d prefer some way of forcing the issue for precise padding.<p>However, &#x27;union&#x27; of types is just syntax sugar.  Give the programmer the above basics and add one more: builtin.*reshape()*.  reshape() would allow any similarly shaped structures to replace the type of the reshaped item.  E.G. reshape({x, y, z uint64},{x, y, z int64}, A, B) would convert a 192bit chunk of 3 ints of one type to the other.  It could also convert anything else similarly.<p>That&#x27;s a trivial example, what about some private structure from a library?  I&#x27;d think the unsafe package&#x27;s version should allow violation of the private field space, but the normal safe version might force the unexported fields to &#x27;pad&#x27; (inaccessible) space.  I don&#x27;t think this would alter garbage collection, as that process likely has to keep it&#x27;s own track of regions of memory and places that point within them.  That&#x27;s runtime (maybe compiler time sometimes?) metadata which reshape() would have to work with.<p>Generics even _sort_ of do this already when prefixed with ~type in the list of allowed types; the compiler&#x27;s allowed to use the passed thing as that type of value and the return it back the same as input... and I really don&#x27;t see why a reshape function couldn&#x27;t do the same thing.<p>There is something else though: reshape() likely needs to consume &#x2F; claim the resource, since it wouldn&#x27;t initialize anything.  So maybe it needs to return the recast value to be assigned or passed somewhere and further invalidate usage of the variable past that use.  Alternately it could take a single value variable and modify the type as part of it&#x27;s call (also providing the value as it&#x27;s return would be useful sometimes too).</div><br/></div></div><div id="42347695" class="c"><input type="checkbox" id="c-42347695" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#42347863">prev</a><span>|</span><label class="collapse" for="c-42347695">[-]</label><label class="expand" for="c-42347695">[2 more]</label></div><br/><div class="children"><div class="content">Yes, the Go garbage collector would need to support some new memory layouts to make certain kinds of unions efficient. A union between a double, a pointer, and small integer types (as done in languages like JavaScript) might be a good start?</div><br/><div id="42348095" class="c"><input type="checkbox" id="c-42348095" checked=""/><div class="controls bullet"><span class="by">tignaj</span><span>|</span><a href="#42347695">parent</a><span>|</span><label class="collapse" for="c-42348095">[-]</label><label class="expand" for="c-42348095">[1 more]</label></div><br/><div class="children"><div class="content">Here is a fairly efficient version of a simple union like that I did a while back <a href="https:&#x2F;&#x2F;github.com&#x2F;tigrannajaryan&#x2F;govariant">https:&#x2F;&#x2F;github.com&#x2F;tigrannajaryan&#x2F;govariant</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>