<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1724922069026" as="style"/><link rel="stylesheet" href="styles.css?v=1724922069026"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://nnethercote.github.io/2022/07/27/twenty-years-of-valgrind.html">Twenty Years of Valgrind (2022)</a> <span class="domain">(<a href="https://nnethercote.github.io">nnethercote.github.io</a>)</span></div><div class="subtext"><span>fanf2</span> | <span>47 comments</span></div><br/><div><div id="41384898" class="c"><input type="checkbox" id="c-41384898" checked=""/><div class="controls bullet"><span class="by">theideaofcoffee</span><span>|</span><a href="#41385548">next</a><span>|</span><label class="collapse" for="c-41384898">[-]</label><label class="expand" for="c-41384898">[2 more]</label></div><br/><div class="children"><div class="content">In a complex C codebase, valgrind is absolutely indispensable for finding the last few bits of memory that may have leaked out because you got lazy and didn&#x27;t free() or maybe you wrote somewhere in memory you shouldn&#x27;t have, it really is like magic sometimes. I know that more recent languages (and some not so recent, looking at you, Ada!) have a lot of this built in by default, but when you need to do these things, you know you need to and it&#x27;s nice to have a handy all-in-one tool to help out. It&#x27;s saved me many times from myself when I was writing network code in C and I couldn&#x27;t figure out where the leaks were coming from, or a performance regression by inspecting the code alone. A quick run of valgrind had that fixed in minutes.</div><br/><div id="41388318" class="c"><input type="checkbox" id="c-41388318" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#41384898">parent</a><span>|</span><a href="#41385548">next</a><span>|</span><label class="collapse" for="c-41388318">[-]</label><label class="expand" for="c-41388318">[1 more]</label></div><br/><div class="children"><div class="content">IME the main problem with Valgrind is that it reduces performance too much (I remember something around 10x slowdown or worse). Clang&#x27;s address sanitizer OTH finds most of the same problems, but with much a smaller performance hit, which makes it also useable for things like games.<p>Also for leak detection, some IDEs have excellent realtime debugging tools (for instance there a very nice memory debugger in Visual Studio since VS2015, and XCode has Instruments).</div><br/></div></div></div></div><div id="41385548" class="c"><input type="checkbox" id="c-41385548" checked=""/><div class="controls bullet"><span class="by">turtledragonfly</span><span>|</span><a href="#41384898">prev</a><span>|</span><a href="#41387317">next</a><span>|</span><label class="collapse" for="c-41385548">[-]</label><label class="expand" for="c-41385548">[8 more]</label></div><br/><div class="children"><div class="content">I like Valgrind, but day-to-day, I find myself typically reaching for Sanitizers[1] instead (ASan, et. al.), especially since they&#x27;re built-in to many compilers these days, and are a bit faster IME.<p>Are there any use cases that people here have experienced where Valgrind is their <i>first</i> choice?<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;sanitizers">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;sanitizers</a></div><br/><div id="41386282" class="c"><input type="checkbox" id="c-41386282" checked=""/><div class="controls bullet"><span class="by">lbrandy</span><span>|</span><a href="#41385548">parent</a><span>|</span><a href="#41387968">next</a><span>|</span><label class="collapse" for="c-41386282">[-]</label><label class="expand" for="c-41386282">[1 more]</label></div><br/><div class="children"><div class="content">For uninitialized memory reads, which is one of the biggest classes of issues, valgrind can still be invaluable. MSAN is one of the more difficult things to get setup and remove all the false positives. You typically need to transitively compile everything including dependencies, or annotate&#x2F;hint lots of things to get the signal-to-noise ratio right. Sometimes its just easier&#x2F;better&#x2F;faster to run it under valgrind.</div><br/></div></div><div id="41387968" class="c"><input type="checkbox" id="c-41387968" checked=""/><div class="controls bullet"><span class="by">nickelpro</span><span>|</span><a href="#41385548">parent</a><span>|</span><a href="#41386282">prev</a><span>|</span><a href="#41387989">next</a><span>|</span><label class="collapse" for="c-41387968">[-]</label><label class="expand" for="c-41387968">[3 more]</label></div><br/><div class="children"><div class="content">Callgrind is indispensable for performance profiling and has no compiler-based equivalents</div><br/><div id="41388302" class="c"><input type="checkbox" id="c-41388302" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#41385548">root</a><span>|</span><a href="#41387968">parent</a><span>|</span><a href="#41387989">next</a><span>|</span><label class="collapse" for="c-41388302">[-]</label><label class="expand" for="c-41388302">[2 more]</label></div><br/><div class="children"><div class="content">Callgrind is certainly dispensable; just use a profiler. They are much, much faster, and more accurate as well. (Callgrind is using an idealized model of CPUs as they were around 1995, which doesn&#x27;t match up all that well with how they work today.)<p>There are some situations where I find myself using Callgrind, in particular in situations where stack traces are hard to extract using a regular profiler. But overall, it&#x27;s a tool that I find vastly overused.</div><br/><div id="41388357" class="c"><input type="checkbox" id="c-41388357" checked=""/><div class="controls bullet"><span class="by">dennis_moore</span><span>|</span><a href="#41385548">root</a><span>|</span><a href="#41388302">parent</a><span>|</span><a href="#41387989">next</a><span>|</span><label class="collapse" for="c-41388357">[-]</label><label class="expand" for="c-41388357">[1 more]</label></div><br/><div class="children"><div class="content">Which profilers in particular are you referring to because I&#x27;ve always thought that Callgrind is a profiler? perf?</div><br/></div></div></div></div></div></div><div id="41387989" class="c"><input type="checkbox" id="c-41387989" checked=""/><div class="controls bullet"><span class="by">cozzyd</span><span>|</span><a href="#41385548">parent</a><span>|</span><a href="#41387968">prev</a><span>|</span><a href="#41387779">next</a><span>|</span><label class="collapse" for="c-41387989">[-]</label><label class="expand" for="c-41387989">[1 more]</label></div><br/><div class="children"><div class="content">Lots of third party libraries have valgrind suppression files for false positivity.</div><br/></div></div><div id="41387779" class="c"><input type="checkbox" id="c-41387779" checked=""/><div class="controls bullet"><span class="by">patrick451</span><span>|</span><a href="#41385548">parent</a><span>|</span><a href="#41387989">prev</a><span>|</span><a href="#41385699">next</a><span>|</span><label class="collapse" for="c-41387779">[-]</label><label class="expand" for="c-41387779">[1 more]</label></div><br/><div class="children"><div class="content">IME, sanitizer don&#x27;t find enough issues compared valgrind, and valgrind doesn&#x27;t require me to recompile the world.<p>If I have anything that feels like UB, especially that I can trigger in a unit test, I run it through valgrind first. If the issue can only be triggered by running the whole system and valgrind slows it down too much, there&#x27;s a good chance that sanitizers will also slow it down too much.</div><br/></div></div><div id="41385699" class="c"><input type="checkbox" id="c-41385699" checked=""/><div class="controls bullet"><span class="by">synergy20</span><span>|</span><a href="#41385548">parent</a><span>|</span><a href="#41387779">prev</a><span>|</span><a href="#41387317">next</a><span>|</span><label class="collapse" for="c-41385699">[-]</label><label class="expand" for="c-41385699">[1 more]</label></div><br/><div class="children"><div class="content">same here, also for embedded systems valgrind is too heavy to run natively</div><br/></div></div></div></div><div id="41387317" class="c"><input type="checkbox" id="c-41387317" checked=""/><div class="controls bullet"><span class="by">ellis0n</span><span>|</span><a href="#41385548">prev</a><span>|</span><a href="#41384439">next</a><span>|</span><label class="collapse" for="c-41387317">[-]</label><label class="expand" for="c-41387317">[1 more]</label></div><br/><div class="children"><div class="content">I remember adding 64-bit fixes to Valgrind to run it on the iOS Simulator when Macs went 64-bit, and I succeeded, it was incredible. Valgrind is one of the wonders created by humans.</div><br/></div></div><div id="41384439" class="c"><input type="checkbox" id="c-41384439" checked=""/><div class="controls bullet"><span class="by">jmclnx</span><span>|</span><a href="#41387317">prev</a><span>|</span><a href="#41384425">next</a><span>|</span><label class="collapse" for="c-41384439">[-]</label><label class="expand" for="c-41384439">[3 more]</label></div><br/><div class="children"><div class="content">A great tool, I hope these fortune 500 Companies that are involve with Linux are supporting the Valgrind Developers.<p>In reality I really doubt they are.</div><br/><div id="41384873" class="c"><input type="checkbox" id="c-41384873" checked=""/><div class="controls bullet"><span class="by">orochimaaru</span><span>|</span><a href="#41384439">parent</a><span>|</span><a href="#41387835">next</a><span>|</span><label class="collapse" for="c-41384873">[-]</label><label class="expand" for="c-41384873">[1 more]</label></div><br/><div class="children"><div class="content">Fortune 500’s rarely contribute but use a lot. I work for one. It’s usually a tussle between which vendor has managed to convince c-suite that software engineering is a dying discipline and their new genai tool is the utopia.<p>Most Fortune 500 c suite are bean counters with abysmal engineering or product know how. They can’t see past the next quarter earnings report. I doubt long term contribution to meaningful open source is on their list.</div><br/></div></div><div id="41387835" class="c"><input type="checkbox" id="c-41387835" checked=""/><div class="controls bullet"><span class="by">Foobar8568</span><span>|</span><a href="#41384439">parent</a><span>|</span><a href="#41384873">prev</a><span>|</span><a href="#41384425">next</a><span>|</span><label class="collapse" for="c-41387835">[-]</label><label class="expand" for="c-41387835">[1 more]</label></div><br/><div class="children"><div class="content">F500 are the cemetery of IT people.</div><br/></div></div></div></div><div id="41384425" class="c"><input type="checkbox" id="c-41384425" checked=""/><div class="controls bullet"><span class="by">moomin</span><span>|</span><a href="#41384439">prev</a><span>|</span><a href="#41385425">next</a><span>|</span><label class="collapse" for="c-41384425">[-]</label><label class="expand" for="c-41384425">[10 more]</label></div><br/><div class="children"><div class="content">As for the pronunciation, thanks for the tooling, but we’ll take it from here.</div><br/><div id="41385783" class="c"><input type="checkbox" id="c-41385783" checked=""/><div class="controls bullet"><span class="by">ahartmetz</span><span>|</span><a href="#41384425">parent</a><span>|</span><a href="#41385681">next</a><span>|</span><label class="collapse" for="c-41385783">[-]</label><label class="expand" for="c-41385783">[3 more]</label></div><br/><div class="children"><div class="content">No trouble at all here (German) - it&#x27;s simply pronounced as if it was a German word.</div><br/><div id="41388102" class="c"><input type="checkbox" id="c-41388102" checked=""/><div class="controls bullet"><span class="by">ahartmetz</span><span>|</span><a href="#41384425">root</a><span>|</span><a href="#41385783">parent</a><span>|</span><a href="#41388313">next</a><span>|</span><label class="collapse" for="c-41388102">[-]</label><label class="expand" for="c-41388102">[1 more]</label></div><br/><div class="children"><div class="content">(Well, its original nordic pronunciation probably has a more o-like or anyway different &#x27;a&#x27;, a pointier &#x27;i&#x27; sound, and a stronger &#x27;r&#x27; than in German. But it seems to be accepted practice between Germanic languages to pronounce everything as if it was your native language - it&#x27;s easy and ~always intelligible.)</div><br/></div></div><div id="41388313" class="c"><input type="checkbox" id="c-41388313" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#41384425">root</a><span>|</span><a href="#41385783">parent</a><span>|</span><a href="#41388102">prev</a><span>|</span><a href="#41385681">next</a><span>|</span><label class="collapse" for="c-41388313">[-]</label><label class="expand" for="c-41388313">[1 more]</label></div><br/><div class="children"><div class="content">If the “a” is supposed to be as in “value” (i.e. closer to ä in some but not all German dialects), that doesn&#x27;t match typical German pronunciation, does it? (The -grind part is fine.)</div><br/></div></div></div></div><div id="41385681" class="c"><input type="checkbox" id="c-41385681" checked=""/><div class="controls bullet"><span class="by">jepler</span><span>|</span><a href="#41384425">parent</a><span>|</span><a href="#41385783">prev</a><span>|</span><a href="#41385349">next</a><span>|</span><label class="collapse" for="c-41385681">[-]</label><label class="expand" for="c-41385681">[1 more]</label></div><br/><div class="children"><div class="content">at $OLD_JOB I literally joked that we used a fork of valgrind just to fix the pronunciation. of course, our fork was also years behind the official version.<p>these days, since I am doing bare metal embedded, I barely use valgrind; but it is game changing in the situations where it&#x27;s useful.</div><br/></div></div><div id="41385349" class="c"><input type="checkbox" id="c-41385349" checked=""/><div class="controls bullet"><span class="by">kimixa</span><span>|</span><a href="#41384425">parent</a><span>|</span><a href="#41385681">prev</a><span>|</span><a href="#41385437">next</a><span>|</span><label class="collapse" for="c-41385349">[-]</label><label class="expand" for="c-41385349">[1 more]</label></div><br/><div class="children"><div class="content">And the times you end up <i>needing</i> tools like valgrind very much feel like a grind</div><br/></div></div><div id="41385437" class="c"><input type="checkbox" id="c-41385437" checked=""/><div class="controls bullet"><span class="by">cortesoft</span><span>|</span><a href="#41384425">parent</a><span>|</span><a href="#41385349">prev</a><span>|</span><a href="#41384808">next</a><span>|</span><label class="collapse" for="c-41385437">[-]</label><label class="expand" for="c-41385437">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I feel like this is like GIF… the word takes on a life of its own, and the creator of the name does not get final say.</div><br/></div></div><div id="41384808" class="c"><input type="checkbox" id="c-41384808" checked=""/><div class="controls bullet"><span class="by">mistrial9</span><span>|</span><a href="#41384425">parent</a><span>|</span><a href="#41385437">prev</a><span>|</span><a href="#41385860">next</a><span>|</span><label class="collapse" for="c-41384808">[-]</label><label class="expand" for="c-41384808">[2 more]</label></div><br/><div class="children"><div class="content">agree - &quot;grinned&quot; is not at all the feeling I get..&quot;grind&quot; on the other hand, like skating.. yes more like it</div><br/><div id="41388323" class="c"><input type="checkbox" id="c-41388323" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#41384425">root</a><span>|</span><a href="#41384808">parent</a><span>|</span><a href="#41385860">next</a><span>|</span><label class="collapse" for="c-41388323">[-]</label><label class="expand" for="c-41388323">[1 more]</label></div><br/><div class="children"><div class="content">AFAIK it&#x27;s from the old Norse word “grind” meaning fence or gate. It&#x27;s the entrance to Valhalla.</div><br/></div></div></div></div></div></div><div id="41385425" class="c"><input type="checkbox" id="c-41385425" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41384425">prev</a><span>|</span><a href="#41384531">next</a><span>|</span><label class="collapse" for="c-41385425">[-]</label><label class="expand" for="c-41385425">[3 more]</label></div><br/><div class="children"><div class="content">One thing I&#x27;ve never understood regarding valgrind - other than intentional leaks, are suppression files ever actually used due to an actual false positive, or is it just due to the bug being in someone else&#x27;s code that&#x27;s annoying to fix?<p>&quot;We implement our own memory allocator&quot; is no excuse; the primitives you use should be hooked by valgrind so at most there should be false <i>negatives</i> due to your allocations being larger than the user-facing ones ...</div><br/><div id="41385848" class="c"><input type="checkbox" id="c-41385848" checked=""/><div class="controls bullet"><span class="by">wavesquid</span><span>|</span><a href="#41385425">parent</a><span>|</span><a href="#41385679">next</a><span>|</span><label class="collapse" for="c-41385848">[-]</label><label class="expand" for="c-41385848">[1 more]</label></div><br/><div class="children"><div class="content">&gt; are suppression files ever actually used due to an actual false positive,<p>There used to be one in LuaJIT because it had an optimized string comparison that compared outside of the allocation (which is allowed by the OS as long as you don&#x27;t cross a page boundary, which LuaJIT&#x27;s allocation algorithm made sure it never did)<p>The suppression was removed in <a href="https:&#x2F;&#x2F;github.com&#x2F;LuaJIT&#x2F;LuaJIT&#x2F;commit&#x2F;ff34b48ddd6f2b3bdd26d6088662a214ba6b0288">https:&#x2F;&#x2F;github.com&#x2F;LuaJIT&#x2F;LuaJIT&#x2F;commit&#x2F;ff34b48ddd6f2b3bdd26...</a> when the string hashing got a new implementation</div><br/></div></div><div id="41385679" class="c"><input type="checkbox" id="c-41385679" checked=""/><div class="controls bullet"><span class="by">glandium</span><span>|</span><a href="#41385425">parent</a><span>|</span><a href="#41385848">prev</a><span>|</span><a href="#41384531">next</a><span>|</span><label class="collapse" for="c-41385679">[-]</label><label class="expand" for="c-41385679">[1 more]</label></div><br/><div class="children"><div class="content">First and foremost, suppressions can be used for more than leaks. For example, for &quot;Conditional jump or move depends on uninitialised value(s)&quot;, which yes, there are very much false positives for because of e.g. tricky optimizations LLVM performs and that valgrind can&#x27;t handle.<p>But even for leaks, you can also have intentional leaks that valgrind will flag but that you can&#x27;t really do anything about. One example is how using `putenv` can lead to you having to leak memory on purpose. There are many other cases.</div><br/></div></div></div></div><div id="41384531" class="c"><input type="checkbox" id="c-41384531" checked=""/><div class="controls bullet"><span class="by">ChrisArchitect</span><span>|</span><a href="#41385425">prev</a><span>|</span><a href="#41385372">next</a><span>|</span><label class="collapse" for="c-41384531">[-]</label><label class="expand" for="c-41384531">[2 more]</label></div><br/><div class="children"><div class="content">twenty-four years<p>(2022)<p>Some discussion then: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32245136">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32245136</a></div><br/><div id="41384899" class="c"><input type="checkbox" id="c-41384899" checked=""/><div class="controls bullet"><span class="by">munchler</span><span>|</span><a href="#41384531">parent</a><span>|</span><a href="#41385372">next</a><span>|</span><label class="collapse" for="c-41384899">[-]</label><label class="expand" for="c-41384899">[1 more]</label></div><br/><div class="children"><div class="content">2024 - 2022 + 20 = 22 years, not 24 years.</div><br/></div></div></div></div><div id="41385372" class="c"><input type="checkbox" id="c-41385372" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#41384531">prev</a><span>|</span><a href="#41386363">next</a><span>|</span><label class="collapse" for="c-41385372">[-]</label><label class="expand" for="c-41385372">[8 more]</label></div><br/><div class="children"><div class="content">Maybe it&#x27;s just me, but I think people tend to drive by memory leaks nowadays because the footprint of binaries has grown, but the size of ram has grown more-erly. Proper big.<p>I routinely run on 1TB memory 128 core racks, and I don&#x27;t worry about free() much.<p>I&#x27;m not humblebragging, I actually think this is lazy (!) and I would benefit from more explicitly thinking about the memory consequences of what I do but there are some things which I used to freak out about growing to GB and now, I regard it as an investment on the future me, running the same thing: It&#x27;s very likely I&#x27;ve got it in a hash structure of some kind already. I just add columns to the dict() elements.<p>Down the other end, I recall some friends getting code which I expected to have to run on a major rack host to build onto a small memory model rPi and they said rust did that: allowed them to get rid of the overhang of other languages expectations to runtime size and be explicit about use and free in the heap.</div><br/><div id="41385448" class="c"><input type="checkbox" id="c-41385448" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#41385372">parent</a><span>|</span><a href="#41385474">next</a><span>|</span><label class="collapse" for="c-41385448">[-]</label><label class="expand" for="c-41385448">[2 more]</label></div><br/><div class="children"><div class="content">I think the relative popularity of managed memory languages has grown and continues to grow.  Even C++ is largely &quot;managed&quot; via mechanisms like unique_ptr, shared_ptr, or the standard collections.  (Using new&#x2F;delete directly is more or less a code smell these days.)  C will always have a place, but despite working in it from 2011-2021 or so, I just don&#x27;t use it at all these days.  With &quot;owned&quot; allocations, you just don&#x27;t need explicit free().  You&#x27;re more likely to see memory leaks via unbounded collection size than actual unreferenced pointers.</div><br/><div id="41387949" class="c"><input type="checkbox" id="c-41387949" checked=""/><div class="controls bullet"><span class="by">adrianN</span><span>|</span><a href="#41385372">root</a><span>|</span><a href="#41385448">parent</a><span>|</span><a href="#41385474">next</a><span>|</span><label class="collapse" for="c-41387949">[-]</label><label class="expand" for="c-41387949">[1 more]</label></div><br/><div class="children"><div class="content">Every correct program manages memory. Doing it in a structured way just makes it less bugprone.</div><br/></div></div></div></div><div id="41385474" class="c"><input type="checkbox" id="c-41385474" checked=""/><div class="controls bullet"><span class="by">bayindirh</span><span>|</span><a href="#41385372">parent</a><span>|</span><a href="#41385448">prev</a><span>|</span><a href="#41386115">next</a><span>|</span><label class="collapse" for="c-41385474">[-]</label><label class="expand" for="c-41385474">[1 more]</label></div><br/><div class="children"><div class="content">In short, in my discipline, if you don’t free your memory you can eat a TB in 10 minutes. Moreover, if you fragment memory too much, then you’ll start to get segfaults when you want large segments of contiguous memory.<p>Lastly, the same fragmentation will cause advanced libraries like Eigen to use many small memory areas, and jumping between them kills locality, hence causing you performance losses.<p>I’m running tasks on (and administering) clusters with similar resources to yours, yet I always treat them like 486DXs with 4MB RAM, because I can’t restart them every week.</div><br/></div></div><div id="41386115" class="c"><input type="checkbox" id="c-41386115" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#41385372">parent</a><span>|</span><a href="#41385474">prev</a><span>|</span><a href="#41386810">next</a><span>|</span><label class="collapse" for="c-41386115">[-]</label><label class="expand" for="c-41386115">[1 more]</label></div><br/><div class="children"><div class="content">I get it. And I do wish some systems were quicker to let the OS clean up after them on exit. For instance, the other day loaded a CSV with about 20 columns and 10M rows into a list of Python tuples so I could poke at them a bit. That took a short while and I was ok with that. I was more surprised when I closed the REPL and it hung for way longer than expected as it freed a couple hundred million objects.<p>Now it could’ve been the case that some of those objects had a __del__ method that needed to be called or something. Absent that case, I’d have preferred the process just exited and been done with it.<p>If that were a program that ran synchronously from a shell script, the shutdown GC time would’ve been nearly as long as the data loading time. Maybe Python could benefit from a fast_shutdown_GC function that only calls free() if an object is something with a non-trivial delete method. Otherwise, skip it and let the OS do its voodoo it does so well.<p>I’m picking on Python here because that’s where I last saw this. The basic idea applies in lots of other cases though.</div><br/></div></div><div id="41386810" class="c"><input type="checkbox" id="c-41386810" checked=""/><div class="controls bullet"><span class="by">whiterknight</span><span>|</span><a href="#41385372">parent</a><span>|</span><a href="#41386115">prev</a><span>|</span><a href="#41387956">next</a><span>|</span><label class="collapse" for="c-41386810">[-]</label><label class="expand" for="c-41386810">[1 more]</label></div><br/><div class="children"><div class="content">Luckily for us C programmers do care and track down leaks aggressively.</div><br/></div></div><div id="41387956" class="c"><input type="checkbox" id="c-41387956" checked=""/><div class="controls bullet"><span class="by">minkles</span><span>|</span><a href="#41385372">parent</a><span>|</span><a href="#41386810">prev</a><span>|</span><a href="#41385455">next</a><span>|</span><label class="collapse" for="c-41387956">[-]</label><label class="expand" for="c-41387956">[1 more]</label></div><br/><div class="children"><div class="content">Well not at that scale, but it isn&#x27;t uncommon just to malloc&#x2F;HeapAlloc a whole pile of RAM up front, spew your data structures into it and free it when it crashes &#x2F; exits. It is a perfectly valid strategy.<p>In fact I did this a couple of years back on a project I was working on maintaining in win32. It had a complicated memory management scheme for a GUI process that kept screwing up. Turned out it couldn&#x27;t ever use more than 2MB of RAM so I just allocated 10MB up front at the start of the process and wrote a simple incrementing pointing counter in that allocated block and free&#x27;d it at the end like a short life pool. Solved all the issues. Machines it&#x27;s running on all have at least 16GB of RAM so it&#x27;s not exactly breaking the bank!</div><br/></div></div><div id="41385455" class="c"><input type="checkbox" id="c-41385455" checked=""/><div class="controls bullet"><span class="by">vinkelhake</span><span>|</span><a href="#41385372">parent</a><span>|</span><a href="#41387956">prev</a><span>|</span><a href="#41386363">next</a><span>|</span><label class="collapse" for="c-41385455">[-]</label><label class="expand" for="c-41385455">[1 more]</label></div><br/><div class="children"><div class="content">Tracking down memory leaks is just one of things that valgrind can do.</div><br/></div></div></div></div><div id="41386363" class="c"><input type="checkbox" id="c-41386363" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#41385372">prev</a><span>|</span><a href="#41385216">next</a><span>|</span><label class="collapse" for="c-41386363">[-]</label><label class="expand" for="c-41386363">[1 more]</label></div><br/><div class="children"><div class="content">Discussed at the time (of the article):<p><i>Twenty years of Valgrind</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32245136">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32245136</a> - July 2022 (112 comments)</div><br/></div></div><div id="41385216" class="c"><input type="checkbox" id="c-41385216" checked=""/><div class="controls bullet"><span class="by">michael1999</span><span>|</span><a href="#41386363">prev</a><span>|</span><a href="#41386716">next</a><span>|</span><label class="collapse" for="c-41385216">[-]</label><label class="expand" for="c-41385216">[3 more]</label></div><br/><div class="children"><div class="content">I remember how much my work improved when I got to use Purify.  The pager just stopped going off after a while.</div><br/><div id="41385402" class="c"><input type="checkbox" id="c-41385402" checked=""/><div class="controls bullet"><span class="by">ta8645</span><span>|</span><a href="#41385216">parent</a><span>|</span><a href="#41386716">next</a><span>|</span><label class="collapse" for="c-41385402">[-]</label><label class="expand" for="c-41385402">[2 more]</label></div><br/><div class="children"><div class="content">Did you find it superior to Valgrind in some way?</div><br/><div id="41385488" class="c"><input type="checkbox" id="c-41385488" checked=""/><div class="controls bullet"><span class="by">michael1999</span><span>|</span><a href="#41385216">root</a><span>|</span><a href="#41385402">parent</a><span>|</span><a href="#41386716">next</a><span>|</span><label class="collapse" for="c-41385488">[-]</label><label class="expand" for="c-41385488">[1 more]</label></div><br/><div class="children"><div class="content">No.  Purify was the commercial software that inspired Valgrind.  It was Reed Hastings&#x27; first company, and I came across it working at a bank in 1996.<p>I moved to Java with the millennium, and missed the rise of Valgrind.  I&#x27;m just happy that everyone has good tools now.  Writing C in those days was a rough business.</div><br/></div></div></div></div></div></div><div id="41386716" class="c"><input type="checkbox" id="c-41386716" checked=""/><div class="controls bullet"><span class="by">aptitude_moo</span><span>|</span><a href="#41385216">prev</a><span>|</span><a href="#41385755">next</a><span>|</span><label class="collapse" for="c-41386716">[-]</label><label class="expand" for="c-41386716">[1 more]</label></div><br/><div class="children"><div class="content">&gt; As a result, I don’t have much use for Memcheck, but I still use Cachegrind, Callgrind, and DHAT all the time. I’m amazed that I’m still using Cachegrind today, given that it has hardly changed in twenty years. (I only use it for instruction counts, though. I wouldn’t trust the icache&#x2F;dcache results at all given that they come from a best-guess simulation of an AMD Athlon circa 2002.)<p>The few times I used the cache simulator and compared it to (Linux) Perf I found reasonable results. Someone can recommend a better cache simulator?</div><br/></div></div><div id="41385755" class="c"><input type="checkbox" id="c-41385755" checked=""/><div class="controls bullet"><span class="by">brcmthrowaway</span><span>|</span><a href="#41386716">prev</a><span>|</span><a href="#41384529">next</a><span>|</span><label class="collapse" for="c-41385755">[-]</label><label class="expand" for="c-41385755">[3 more]</label></div><br/><div class="children"><div class="content">Has anyone tried to Valgrind the rust runtime?</div><br/><div id="41386249" class="c"><input type="checkbox" id="c-41386249" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#41385755">parent</a><span>|</span><a href="#41384529">next</a><span>|</span><label class="collapse" for="c-41386249">[-]</label><label class="expand" for="c-41386249">[2 more]</label></div><br/><div class="children"><div class="content">It works okay with Rust, but it&#x27;s not really needed, except when integrating C code with Rust.<p>For verifying unsafe code, Rust has a MIRI interpreter that catches UB more precisely, e.g. it knows Rust&#x27;s aliasing rules, precise object boundaries, and has access to lifetimes (they don&#x27;t survive compilation).<p>Non-deliberate leaking of memory in Rust is not possible for the majority of Rust types. In safe Rust it requires a specific combination of a refcounted type that uses interior mutability which contains a type that makes the refcounted smart pointer recursive. Types that meet all three conditions at once are niche.<p>The only annoyance&#x2F;incompatibility is that Valgrind complains that global variables are leaked. Rust does that intentionally, because static destructors have the same problem as SIOF[1] in reverse, plus tricky interactions with atexit mean there&#x27;s no reliable way to destruct arbitrary globals.<p>[1]: <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;siof" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;siof</a></div><br/><div id="41386520" class="c"><input type="checkbox" id="c-41386520" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#41385755">root</a><span>|</span><a href="#41386249">parent</a><span>|</span><a href="#41384529">next</a><span>|</span><label class="collapse" for="c-41386520">[-]</label><label class="expand" for="c-41386520">[1 more]</label></div><br/><div class="children"><div class="content">Hard disagree that it’s not needed. MIRI’s ability to verify non-trivial examples of code is quite limited so I generally just discount it. Valgrind goes beyond just asan+msan with heap and CPU profiling which can be useful if you’re trying to extract every last bit of performance.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>