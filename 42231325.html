<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1732611672515" as="style"/><link rel="stylesheet" href="styles.css?v=1732611672515"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://trilogydata.dev/demo">Show HN: Trilogy – A Reusable, Composable SQL Experiment</a> <span class="domain">(<a href="https://trilogydata.dev">trilogydata.dev</a>)</span></div><div class="subtext"><span>efromvt</span> | <span>42 comments</span></div><br/><div><div id="42237985" class="c"><input type="checkbox" id="c-42237985" checked=""/><div class="controls bullet"><span class="by">hobofan</span><span>|</span><a href="#42242272">next</a><span>|</span><label class="collapse" for="c-42237985">[-]</label><label class="expand" for="c-42237985">[26 more]</label></div><br/><div class="children"><div class="content">One thing that I am always looking for in a new &quot;reusable&quot;, &quot;composable&quot; SQL tool is reuse of the same analytical queries across different source tables.<p>My litmus test:<p>I have a table &quot;people&quot; with the columns &quot;people.firstname&quot;, &quot;people.lastname&quot;, and a table &quot;persons&quot; with the columns &quot;persons.firstname&quot;, &quot;persons.lastname&quot;. I now want to create a query that gives me the &quot;fullname&quot; (&quot;.firstname&quot; + &quot; &quot; + &quot;.lastname&quot;) of all rows of both tables. If I have to spell out the logic for how to calculate the fullname in the query twice, the test is failed.<p>(Taking the shortcut of creating the union of both tables first is not allowed, but I can&#x27;t think of a simple example that enforces that restriction).<p>For some reason, all of the solutions (PRQL, Malloy, dbt) that try to make SQL more reusable don&#x27;t really consider this kind of reuse, and with that ultimately fall flat for the use-cases I would typically have for them. Sadly, Trilogy doesn&#x27;t seem to be any better on that front.</div><br/><div id="42238902" class="c"><input type="checkbox" id="c-42238902" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#42237985">parent</a><span>|</span><a href="#42239575">next</a><span>|</span><label class="collapse" for="c-42238902">[-]</label><label class="expand" for="c-42238902">[6 more]</label></div><br/><div class="children"><div class="content">TBH, I don&#x27;t think your test is very useful in real world environments. That is, you have 2 independent tables, and you&#x27;re wanting the solution to depend on the fact that there are columns that are named the same across both tables.<p>IMO these kinds of &quot;shortcuts based on column naming across tables&quot; usually end in disaster down the road. For example, I&#x27;ve been bitten in the past by &quot;natural joins&quot; when we&#x27;ve wanted to refactor something later.<p>I definitely agree that I don&#x27;t want to have to repeat logic <i>within</i> a single table, but the kind of syntactic sugar that is your litmus test is a big foot gun IMO.</div><br/><div id="42243436" class="c"><input type="checkbox" id="c-42243436" checked=""/><div class="controls bullet"><span class="by">solidsnack9000</span><span>|</span><a href="#42237985">root</a><span>|</span><a href="#42238902">parent</a><span>|</span><a href="#42239228">next</a><span>|</span><label class="collapse" for="c-42243436">[-]</label><label class="expand" for="c-42243436">[1 more]</label></div><br/><div class="children"><div class="content">As far as I can tell, the parent is describing something like a trait or interface: both tables have `.firstname: text` and `.lastname: text`. This may not really be relational -- I guess there should be a third table and they should both reference it -- but it does show up in real world schemas.</div><br/></div></div><div id="42239228" class="c"><input type="checkbox" id="c-42239228" checked=""/><div class="controls bullet"><span class="by">hobofan</span><span>|</span><a href="#42237985">root</a><span>|</span><a href="#42238902">parent</a><span>|</span><a href="#42243436">prev</a><span>|</span><a href="#42238990">next</a><span>|</span><label class="collapse" for="c-42239228">[-]</label><label class="expand" for="c-42239228">[3 more]</label></div><br/><div class="children"><div class="content">Oh, I 100% agree with you.<p>&gt; IMO these kinds of &quot;shortcuts based on column naming across tables&quot; usually end in disaster down the road.<p>I can see that point, and that was not what I wanted to express with my litmus test. It&#x27;s only supposed to be a litmus test after all. In a proper solution there would be additional things I would be looking for, but so far everything I&#x27;ve seen already fails that &quot;trivial&quot; test.<p>One could easily re-formulate it, so that in the one tabel the column is named &quot;.firstname&quot;, and in the other one it is named &quot;.first_part_of_the_name&quot;.<p>The core point is more that no matter the relational logic you layer on top of a table&#x2F;view, that logic should be paramterizable by table&#x2F;view&#x2F;column names, to be properly relocatable. I&#x27;d be happy about suggestions for better examples! Some solutions (I think dbt) do have some relocateability across schemas, but usually in a more singleton-like manner rather than being able to instantiate the logic multiple times.<p>I can just tell you that I interact with queries that would benefit from such kind of reuse on a daily basis. One common thing would also be mechanisms that you want to reuse across many different tables in your schema. E.g. soft-deletes  or historic&#x2F;snapshot tables. Nowadays those kinds of solutions usually end up being expressed in the ORM&#x2F;query builder of a programming language (and thus highly fragmented across programming language ecosystems), instead of living on an SQL-like level and being able to mature better.</div><br/><div id="42239820" class="c"><input type="checkbox" id="c-42239820" checked=""/><div class="controls bullet"><span class="by">fooododododo</span><span>|</span><a href="#42237985">root</a><span>|</span><a href="#42239228">parent</a><span>|</span><a href="#42238990">next</a><span>|</span><label class="collapse" for="c-42239820">[-]</label><label class="expand" for="c-42239820">[2 more]</label></div><br/><div class="children"><div class="content">Curious what your opinion on plpgsql functions is? Could easily solve your initial problem (if I follow). They don&#x27;t seem to come up much though</div><br/><div id="42240179" class="c"><input type="checkbox" id="c-42240179" checked=""/><div class="controls bullet"><span class="by">hobofan</span><span>|</span><a href="#42237985">root</a><span>|</span><a href="#42239820">parent</a><span>|</span><a href="#42238990">next</a><span>|</span><label class="collapse" for="c-42240179">[-]</label><label class="expand" for="c-42240179">[1 more]</label></div><br/><div class="children"><div class="content">I do like PL\pgSQL functions, and I think they can to some extent be used to solve this problem, though I think they are limited in how their internal structure is parameterizable.<p>I am rarely in a position at my client projects where I can employ PL\pgSQL though, so I opt more for out-of-database solutions for composing my queries, as that usually is easier to debug.</div><br/></div></div></div></div></div></div><div id="42238990" class="c"><input type="checkbox" id="c-42238990" checked=""/><div class="controls bullet"><span class="by">default-kramer</span><span>|</span><a href="#42237985">root</a><span>|</span><a href="#42238902">parent</a><span>|</span><a href="#42239228">prev</a><span>|</span><a href="#42239575">next</a><span>|</span><label class="collapse" for="c-42238990">[-]</label><label class="expand" for="c-42238990">[1 more]</label></div><br/><div class="children"><div class="content">&gt; IMO these kinds of &quot;shortcuts based on column naming across tables&quot; usually end in disaster down the road.<p>But sometimes this decision has been made years ago and it&#x27;s not realistic to change it now. I&#x27;ve wanted to do this many times, and I&#x27;ve never been the person who created said tables.<p>Also, certain use cases perform much better if you create temp tables with small subsets of data from the main tables. It sure would be nice to be able to reuse fragments of SQL written against the main tables... if only SQL were better.</div><br/></div></div></div></div><div id="42239575" class="c"><input type="checkbox" id="c-42239575" checked=""/><div class="controls bullet"><span class="by">carlineng</span><span>|</span><a href="#42237985">parent</a><span>|</span><a href="#42238902">prev</a><span>|</span><a href="#42239373">next</a><span>|</span><label class="collapse" for="c-42239575">[-]</label><label class="expand" for="c-42239575">[7 more]</label></div><br/><div class="children"><div class="content">I agree 100% that this needs to be more of a thing. For data engineers building data pipelines, queries are like functions, and table schemas are like types. There needs to be a way to write a query that runs on an abstract interface, rather than an actual table. To do this, most folks rely on string templating in Python or Jinja, which makes the development process really cumbersome. As a result, most teams end up in scenarios where data pipelines are always a big mess of spaghetti SQL, or they are stuck maintaining complex frameworks that abstract away common logic, but are inscrutable to the average user.<p>I wrote a longer blog post about this recently: <a href="https:&#x2F;&#x2F;carlineng.com&#x2F;?postid=holy-grail-data-engineering#blog" rel="nofollow">https:&#x2F;&#x2F;carlineng.com&#x2F;?postid=holy-grail-data-engineering#bl...</a></div><br/><div id="42239840" class="c"><input type="checkbox" id="c-42239840" checked=""/><div class="controls bullet"><span class="by">hobofan</span><span>|</span><a href="#42237985">root</a><span>|</span><a href="#42239575">parent</a><span>|</span><a href="#42240471">next</a><span>|</span><label class="collapse" for="c-42239840">[-]</label><label class="expand" for="c-42239840">[1 more]</label></div><br/><div class="children"><div class="content">I think your blog post frames the problem very well!<p>Seeing that both someone working on PRQL and Malloy replied and to both of you it&#x27;s an understood pain makes me feel a lot better about the future of these tools! When talking about that with people that are not that deep into the problem it is often hard to transport the difference between this kind of composability vs. the composability that the tools are offering today, and the implications that come with that.<p>At a past startup I had the fortune to be able to work on a similar system to what I am looking for: Packageable, reusable relation algebra inspired by Substrait. It had the downside though that it was quite tied to RDF and SPARQL in its implementation, and now I&#x27;m chasing something similar in the SQL world :D</div><br/></div></div><div id="42240471" class="c"><input type="checkbox" id="c-42240471" checked=""/><div class="controls bullet"><span class="by">munk-a</span><span>|</span><a href="#42237985">root</a><span>|</span><a href="#42239575">parent</a><span>|</span><a href="#42239840">prev</a><span>|</span><a href="#42239907">next</a><span>|</span><label class="collapse" for="c-42240471">[-]</label><label class="expand" for="c-42240471">[1 more]</label></div><br/><div class="children"><div class="content">I have used CTEs with dynamic query stitching to solve this problem (specifically my business operates over two very similar but distinct domains which we keep in separate buckets).  If you build the majority of your logic into a CTE that processes named columns coming out of a prior chunk you can swap out what actual columns in the DB are mapped into the columns coming out of that earlier CTE with its definition.  It may be possible to make this more magical using pl&#x2F;pgsql but I&#x27;ve found that dynamic query stitching at the CTE resolution is a level of fiddly-ness I&#x27;m comfortable building into resilient products.<p>I work with complex data models and keeping all that structure in my brain takes enough effort that I want to keep my queries as simple as possible because when it&#x27;s time to debug one there&#x27;s no way I&#x27;m carrying over _any_ memory from when I originally wrote it.</div><br/></div></div><div id="42239916" class="c"><input type="checkbox" id="c-42239916" checked=""/><div class="controls bullet"><span class="by">thesz</span><span>|</span><a href="#42237985">root</a><span>|</span><a href="#42239575">parent</a><span>|</span><a href="#42239907">prev</a><span>|</span><a href="#42239795">next</a><span>|</span><label class="collapse" for="c-42239916">[-]</label><label class="expand" for="c-42239916">[2 more]</label></div><br/><div class="children"><div class="content">&gt; There needs to be a way to write a query that runs on an abstract interface, rather than an actual table.<p>Proper use of SQL inverts control. Instead of parameterizing query by table, you write a query and at the actual use site you join it on the table you need by fields your query provides. VIEWs allows you to not repeat yourself too often.<p>Best thing is that you do not need to even mention that &quot;abstract interface table&quot; as a parameter at all.</div><br/><div id="42240062" class="c"><input type="checkbox" id="c-42240062" checked=""/><div class="controls bullet"><span class="by">hobofan</span><span>|</span><a href="#42237985">root</a><span>|</span><a href="#42239916">parent</a><span>|</span><a href="#42239795">next</a><span>|</span><label class="collapse" for="c-42240062">[-]</label><label class="expand" for="c-42240062">[1 more]</label></div><br/><div class="children"><div class="content">&gt; VIEWs allows you to not repeat yourself too often.<p>No they don&#x27;t. They only offer a solution to the problem &quot;many different predicates for a few tables&quot;, but don&#x27;t offer a solution to the problem &quot;a few similar predicates for many different tables&quot;, as views as per their declaration are already tied to a single table.</div><br/></div></div></div></div><div id="42239795" class="c"><input type="checkbox" id="c-42239795" checked=""/><div class="controls bullet"><span class="by">fooododododo</span><span>|</span><a href="#42237985">root</a><span>|</span><a href="#42239575">parent</a><span>|</span><a href="#42239916">prev</a><span>|</span><a href="#42239373">next</a><span>|</span><label class="collapse" for="c-42239795">[-]</label><label class="expand" for="c-42239795">[1 more]</label></div><br/><div class="children"><div class="content">Do they ever write plpgsql? If not why not?</div><br/></div></div></div></div><div id="42239373" class="c"><input type="checkbox" id="c-42239373" checked=""/><div class="controls bullet"><span class="by">snthpy</span><span>|</span><a href="#42237985">parent</a><span>|</span><a href="#42239575">prev</a><span>|</span><a href="#42240857">next</a><span>|</span><label class="collapse" for="c-42239373">[-]</label><label class="expand" for="c-42239373">[3 more]</label></div><br/><div class="children"><div class="content">Hi,<p>Having this sort of &quot;table polymorphism&quot; is something we&#x27;ve thought a lot about for PRQL and is definitely something we want to get right. That said it&#x27;s not straightforward but you can do a lot of it already. You can try the following examples for yourself in the PRQL Playground (<a href="https:&#x2F;&#x2F;prql-lang.org&#x2F;playground&#x2F;" rel="nofollow">https:&#x2F;&#x2F;prql-lang.org&#x2F;playground&#x2F;</a>).<p>First a simple example using functions as they are documented:<p>```prql<p>let fullname = func firstname lastname -&gt; f&quot;{firstname} {lastname}&quot;<p>from customers<p>select full_name=(fullname first_name last_name)<p>```<p>Now the example above isn&#x27;t quite what you&#x27;re looking for because you still have to specify the columns as function arguments and there really isn&#x27;t much gained here. It serves to illustrate the principle though as the `fullname` function could be doing something more complicated.<p>What you want is:<p>```prql<p>let add_full_name = func tbl&lt;relation&gt; -&gt; (<p><pre><code>    from tbl

    derive full_name = f&quot;{first_name} {last_name}&quot;

    )
</code></pre>
from customers<p>add_full_name<p>select full_name<p>```<p>Now this requires the `&lt;relation&gt;` type annotation which hasn&#x27;t been documented because it&#x27;s still quite experimental. However this works right now and can be applied to different tables or relations, for example you could use the same function in the following:<p>```prql<p>from i=invoices<p>join c=customers (==customer_id)<p>select {c.first_name, c.last_name, i.total}<p>sort {-total}<p>add_full_name<p>select {full_name, total}<p>```<p>I&#x27;ll add some more examples in child comments.<p>Disclaimer: I&#x27;m a PRQL contributor.</div><br/><div id="42239536" class="c"><input type="checkbox" id="c-42239536" checked=""/><div class="controls bullet"><span class="by">snthpy</span><span>|</span><a href="#42237985">root</a><span>|</span><a href="#42239373">parent</a><span>|</span><a href="#42239555">next</a><span>|</span><label class="collapse" for="c-42239536">[-]</label><label class="expand" for="c-42239536">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s a function to normalize values relative to the column range:<p>```prql<p>let normalize = func x -&gt; ((x - min x)&#x2F;((max x) - (min x)) | math.round 2)<p>from tracks<p>take 5<p>derive {ms_norm=(normalize milliseconds), bytes_norm=(normalize bytes)}<p>select {track_id, ms=milliseconds, ms_norm, bytes, bytes_norm}<p>```<p>which produces the following SQL:<p>```sql<p>WITH table_0 AS (<p><pre><code>  SELECT
    track_id,
    bytes,
    milliseconds

  FROM
    tracks

  LIMIT
    5
</code></pre>
)<p>SELECT
  track_id,<p><pre><code>  milliseconds AS ms,

  ROUND(
    (milliseconds - MIN(milliseconds) OVER ()) &#x2F; (
      MAX(milliseconds) OVER () - MIN(milliseconds) OVER ()
    ),
    2
  ) AS ms_norm,

  bytes,

  ROUND(
    (bytes - MIN(bytes) OVER ()) &#x2F; (MAX(bytes) OVER () - MIN(bytes) OVER ()),
    2
  ) AS bytes_norm
</code></pre>
FROM
  table_0<p>-- Generated by PRQL compiler version:0.13.2 (<a href="https:&#x2F;&#x2F;prql-lang.org" rel="nofollow">https:&#x2F;&#x2F;prql-lang.org</a>)<p>```</div><br/></div></div><div id="42239555" class="c"><input type="checkbox" id="c-42239555" checked=""/><div class="controls bullet"><span class="by">hobofan</span><span>|</span><a href="#42237985">root</a><span>|</span><a href="#42239373">parent</a><span>|</span><a href="#42239536">prev</a><span>|</span><a href="#42240857">next</a><span>|</span><label class="collapse" for="c-42239555">[-]</label><label class="expand" for="c-42239555">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the thorough reply! Really glad to see at least one of the solutions working towards it, and I&#x27;ll definitely check PRQL out again in more depth!</div><br/></div></div></div></div><div id="42240857" class="c"><input type="checkbox" id="c-42240857" checked=""/><div class="controls bullet"><span class="by">efromvt</span><span>|</span><a href="#42237985">parent</a><span>|</span><a href="#42239373">prev</a><span>|</span><a href="#42238688">next</a><span>|</span><label class="collapse" for="c-42240857">[-]</label><label class="expand" for="c-42240857">[2 more]</label></div><br/><div class="children"><div class="content">To expand on previous answer, right now this would be represented as:<p>key firstname string;
key lastname string;<p>auto full_name &lt;- concat(firstname, &#x27; &#x27;, lastname);<p>datasource people (
firstname:firstname,
lastname:lastname
)
address people;<p>datasource persons (
firstname: firstname,
last_name:lastname
)
address persons;<p>And a 
select full_name;<p>Could resolve from either table.<p>The missing bit if you&#x27;re trying to define a universe across both is actually the union construct; right now a concept is assumed to have one cardinality space.<p>Something like:
auto all_first_names &lt;- union(first_name1, first_name2);<p>There&#x27;s a coupling between the concept definition both as a function input and as a semantic value. They could be decomposed, but you&#x27;d still need to recompose them at some point before running a query.</div><br/><div id="42241089" class="c"><input type="checkbox" id="c-42241089" checked=""/><div class="controls bullet"><span class="by">efromvt</span><span>|</span><a href="#42237985">root</a><span>|</span><a href="#42240857">parent</a><span>|</span><a href="#42238688">next</a><span>|</span><label class="collapse" for="c-42241089">[-]</label><label class="expand" for="c-42241089">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s an example of what this would look like in practice; <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;greenmtnboy&#x2F;580f479c80e23c5362a70b43048d92c8" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;greenmtnboy&#x2F;580f479c80e23c5362a70b43...</a></div><br/></div></div></div></div><div id="42238688" class="c"><input type="checkbox" id="c-42238688" checked=""/><div class="controls bullet"><span class="by">friendly_deer</span><span>|</span><a href="#42237985">parent</a><span>|</span><a href="#42240857">prev</a><span>|</span><a href="#42239900">next</a><span>|</span><label class="collapse" for="c-42238688">[-]</label><label class="expand" for="c-42238688">[2 more]</label></div><br/><div class="children"><div class="content">This is something I&#x27;ve never thought about before, and haven&#x27;t had a use case for, so I&#x27;m genuinely interested in learning a little more about your use cases if you can elaborate a little futher.</div><br/><div id="42238925" class="c"><input type="checkbox" id="c-42238925" checked=""/><div class="controls bullet"><span class="by">default-kramer</span><span>|</span><a href="#42237985">root</a><span>|</span><a href="#42238688">parent</a><span>|</span><a href="#42239900">next</a><span>|</span><label class="collapse" for="c-42238925">[-]</label><label class="expand" for="c-42238925">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes you want to be able to do something like &quot;run some SQL, but instead of using the normal tables use these temp tables I just created.&quot;<p>In particular, I wanted to do this in SQLite recently. I wanted to have one write process which would always remain unblocked. And I also wanted to be able to run certain tasks which would do some temporary&#x2F;discardable DB manipulations as part of producing an output file. These tasks could open the SQLite DB in read-only mode; load relevant data into temp tables, manipulate that data, and write the output file. Everything would have worked great if only SQL were a more composable language.</div><br/></div></div></div></div><div id="42239900" class="c"><input type="checkbox" id="c-42239900" checked=""/><div class="controls bullet"><span class="by">totalhack</span><span>|</span><a href="#42237985">parent</a><span>|</span><a href="#42238688">prev</a><span>|</span><a href="#42240827">next</a><span>|</span><label class="collapse" for="c-42239900">[-]</label><label class="expand" for="c-42239900">[2 more]</label></div><br/><div class="children"><div class="content">If I&#x27;m understanding your intent correctly, I think you could do that with Zillion.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;totalhack&#x2F;zillion">https:&#x2F;&#x2F;github.com&#x2F;totalhack&#x2F;zillion</a><p>Disclaimer: been sidetracked by an acquisition at my day job this year, intend to put more time into this project soon, but I use it in production to great effect.</div><br/><div id="42239985" class="c"><input type="checkbox" id="c-42239985" checked=""/><div class="controls bullet"><span class="by">hobofan</span><span>|</span><a href="#42237985">root</a><span>|</span><a href="#42239900">parent</a><span>|</span><a href="#42240827">next</a><span>|</span><label class="collapse" for="c-42239985">[-]</label><label class="expand" for="c-42239985">[1 more]</label></div><br/><div class="children"><div class="content">Sure, I could do that in Zillion the same way I&#x27;m currently composing queries in Python at runtime with PyPika.<p>I&#x27;m looking for a more programming language agnostic solution that tools like this (e.g. also PRQL, Malloy) usually offer.</div><br/></div></div></div></div><div id="42240827" class="c"><input type="checkbox" id="c-42240827" checked=""/><div class="controls bullet"><span class="by">efromvt</span><span>|</span><a href="#42237985">parent</a><span>|</span><a href="#42239900">prev</a><span>|</span><a href="#42239009">next</a><span>|</span><label class="collapse" for="c-42240827">[-]</label><label class="expand" for="c-42240827">[1 more]</label></div><br/><div class="children"><div class="content">Hmm - in Trilogy, if both tables had firstname and lastname as concepts bound to them, and you created full name that was the concat of those concepts, you&#x27;d only need to define fullname once and the calculation would work against both without any direct binding to either. The unioning is actually the unsupported part right now, though it&#x27;s planned to be implemented!</div><br/></div></div><div id="42239009" class="c"><input type="checkbox" id="c-42239009" checked=""/><div class="controls bullet"><span class="by">jasonpbecker</span><span>|</span><a href="#42237985">parent</a><span>|</span><a href="#42240827">prev</a><span>|</span><a href="#42242272">next</a><span>|</span><label class="collapse" for="c-42239009">[-]</label><label class="expand" for="c-42239009">[2 more]</label></div><br/><div class="children"><div class="content">This feels like a case for a function.</div><br/><div id="42239306" class="c"><input type="checkbox" id="c-42239306" checked=""/><div class="controls bullet"><span class="by">hobofan</span><span>|</span><a href="#42237985">root</a><span>|</span><a href="#42239009">parent</a><span>|</span><a href="#42242272">next</a><span>|</span><label class="collapse" for="c-42239306">[-]</label><label class="expand" for="c-42239306">[1 more]</label></div><br/><div class="children"><div class="content">See my reply to hn_throwaway_99. The example is overly trivialized and should expand to more complex relational logic as well.</div><br/></div></div></div></div></div></div><div id="42242272" class="c"><input type="checkbox" id="c-42242272" checked=""/><div class="controls bullet"><span class="by">emmanueloga_</span><span>|</span><a href="#42237985">prev</a><span>|</span><a href="#42236609">next</a><span>|</span><label class="collapse" for="c-42242272">[-]</label><label class="expand" for="c-42242272">[1 more]</label></div><br/><div class="children"><div class="content">I might be off here, but this seems like the right place to ask: don&#x27;t most SQL replacements focus heavily on querying while largely overlooking insertion and updating?<p>I get why querying gets more attention, insertions are usually straightforward and don’t need much simplification. Updates, on the other hand, can be a bit trickier since they often involve modifying data derived from complex queries. These tools seem geared toward data analysis and not data generation, which is ok: is nice focusing on a single problem and solving it &quot;right&quot;.<p>But! for projects where a single person handles data creation, analysis, and management, it feels cumbersome to use one set of tools for querying (&quot;R&quot; in CRUD) and another for creation, updates, and deletions (&quot;C,&quot; &quot;U,&quot; and &quot;D&quot;). I think a &quot;SQL replacement&quot; or approach covering all of CRUD could be interesting for projects of any scale. Something that I could pick instead of shopping for ORMs and&#x2F;or lightweight query generators.</div><br/></div></div><div id="42236609" class="c"><input type="checkbox" id="c-42236609" checked=""/><div class="controls bullet"><span class="by">tluyben2</span><span>|</span><a href="#42242272">prev</a><span>|</span><a href="#42237995">next</a><span>|</span><label class="collapse" for="c-42236609">[-]</label><label class="expand" for="c-42236609">[1 more]</label></div><br/><div class="children"><div class="content">This is great; I have been thinking about this for a long time. I like reading about past and current implementations that try to better sql; from a programming and a data science and performance perspective. I am aware of the ones you linked and some others like &#x27;Real&#x27; (shakti.com) sql and some enhancements from papers.<p>Anyway; nice one! Will try.</div><br/></div></div><div id="42239983" class="c"><input type="checkbox" id="c-42239983" checked=""/><div class="controls bullet"><span class="by">totalhack</span><span>|</span><a href="#42237995">prev</a><span>|</span><a href="#42239635">next</a><span>|</span><label class="collapse" for="c-42239983">[-]</label><label class="expand" for="c-42239983">[2 more]</label></div><br/><div class="children"><div class="content">Congrats on the launch. I made a tool that has some similar objectives but doesn&#x27;t present as SQL itself like Trilogy seems to. I&#x27;ll take a deeper look at Trilogy soon, always interested to see the variety of approaches to this.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;totalhack&#x2F;zillion">https:&#x2F;&#x2F;github.com&#x2F;totalhack&#x2F;zillion</a></div><br/><div id="42241113" class="c"><input type="checkbox" id="c-42241113" checked=""/><div class="controls bullet"><span class="by">efromvt</span><span>|</span><a href="#42239983">parent</a><span>|</span><a href="#42239635">next</a><span>|</span><label class="collapse" for="c-42241113">[-]</label><label class="expand" for="c-42241113">[1 more]</label></div><br/><div class="children"><div class="content">Oh wow yeah, a lot of parallels - thanks for sharing, I&#x27;ll take a deeper dive in a bit. I think there&#x27;s a lot of demand and a lot of space for different solutions; Trilogy definitely aspires to hew closer to standard SQL. (I actually really like SQL for the most part!)</div><br/></div></div></div></div><div id="42239635" class="c"><input type="checkbox" id="c-42239635" checked=""/><div class="controls bullet"><span class="by">snthpy</span><span>|</span><a href="#42239983">prev</a><span>|</span><a href="#42236642">next</a><span>|</span><label class="collapse" for="c-42239635">[-]</label><label class="expand" for="c-42239635">[2 more]</label></div><br/><div class="children"><div class="content">Cool project!<p>Will take a proper look when I get a chance.<p>In the meantime, I just wanted to say: nice name! ;-)</div><br/><div id="42241660" class="c"><input type="checkbox" id="c-42241660" checked=""/><div class="controls bullet"><span class="by">efromvt</span><span>|</span><a href="#42239635">parent</a><span>|</span><a href="#42236642">next</a><span>|</span><label class="collapse" for="c-42241660">[-]</label><label class="expand" for="c-42241660">[1 more]</label></div><br/><div class="children"><div class="content">Thanks on the name, hah. Been fun to see the progress PRQL has made going mainstream!</div><br/></div></div></div></div><div id="42236642" class="c"><input type="checkbox" id="c-42236642" checked=""/><div class="controls bullet"><span class="by">mritchie712</span><span>|</span><a href="#42239635">prev</a><span>|</span><a href="#42237549">next</a><span>|</span><label class="collapse" for="c-42236642">[-]</label><label class="expand" for="c-42236642">[3 more]</label></div><br/><div class="children"><div class="content">Not a SQL replacement, but if you&#x27;re looking for an open source semantic layer, Cube is the way to go [0]<p>0 - <a href="https:&#x2F;&#x2F;github.com&#x2F;cube-js&#x2F;cube">https:&#x2F;&#x2F;github.com&#x2F;cube-js&#x2F;cube</a></div><br/><div id="42238003" class="c"><input type="checkbox" id="c-42238003" checked=""/><div class="controls bullet"><span class="by">knowitnone</span><span>|</span><a href="#42236642">parent</a><span>|</span><a href="#42236987">next</a><span>|</span><label class="collapse" for="c-42238003">[-]</label><label class="expand" for="c-42238003">[1 more]</label></div><br/><div class="children"><div class="content">always appreciate links to good tools</div><br/></div></div></div></div></div></div></div></div></div></body></html>