<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1708678853457" as="style"/><link rel="stylesheet" href="styles.css?v=1708678853457"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://juicefs.com/en/blog/engineering/reduce-metadata-memory-usage">A Distributed File System in Go Cut Average Metadata Memory Usage to 100 Bytes</a> <span class="domain">(<a href="https://juicefs.com">juicefs.com</a>)</span></div><div class="subtext"><span>LittleCat38</span> | <span>26 comments</span></div><br/><div><div id="39478313" class="c"><input type="checkbox" id="c-39478313" checked=""/><div class="controls bullet"><span class="by">styluss</span><span>|</span><a href="#39477175">next</a><span>|</span><label class="collapse" for="c-39478313">[-]</label><label class="expand" for="c-39478313">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Techniques like memory pools, manual memory management, directory compression, and compact file formats reduced metadata memory usage by 90%.<p>It is interesting that high performance systems in Go end up needing these kind of performance optimizations.</div><br/></div></div><div id="39477175" class="c"><input type="checkbox" id="c-39477175" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#39478313">prev</a><span>|</span><a href="#39476609">next</a><span>|</span><label class="collapse" for="c-39477175">[-]</label><label class="expand" for="c-39477175">[5 more]</label></div><br/><div class="children"><div class="content">&gt; JuiceFS, written in Go, can manage tens of billions of files in a single namespace.<p>At that scale, I care about integrity. Can someone working in this space <i>please</i> have a real integrity story as part of the offering?  Give each object (object, version pair, perhaps) a cryptographic hash of the contents, and make that hash be part of the inventory. Allow the entire bucket to opt in to mandatory hashing. Let me ask the system to do a scrub in which it verifies those cryptographic hashes.<p>If this blows up metadata to 164 bytes per object, so be it.  But the hash can probably get away with being stored with data, not metadata, as long as there is a mechanism to inventory those hashes. Keeping them in memory doesn’t seem necessary.<p>Even S3 has only desultory support for this. A lot of competitors have nothing of the sort.</div><br/><div id="39477527" class="c"><input type="checkbox" id="c-39477527" checked=""/><div class="controls bullet"><span class="by">daviesliu</span><span>|</span><a href="#39477175">parent</a><span>|</span><a href="#39478110">next</a><span>|</span><label class="collapse" for="c-39477527">[-]</label><label class="expand" for="c-39477527">[1 more]</label></div><br/><div class="children"><div class="content">JuiceFS relies on the object store to provide integrity for data. Besides that, JuiceFS stores the checksum of each object as tags in S3, and verifies that when downloading the objects.<p>Inside the metadata service, it uses merkle tree (hash of hash) to verify the integrity of whole namespace (including id of data blocks) between RAFT replicas. Once we store the hash (4 bytes) of each objects into metadata, it should provide the integrity of the whole namespace.</div><br/></div></div><div id="39478110" class="c"><input type="checkbox" id="c-39478110" checked=""/><div class="controls bullet"><span class="by">fh973</span><span>|</span><a href="#39477175">parent</a><span>|</span><a href="#39477527">prev</a><span>|</span><a href="#39478065">next</a><span>|</span><label class="collapse" for="c-39478110">[-]</label><label class="expand" for="c-39478110">[1 more]</label></div><br/><div class="children"><div class="content">The Quobyte DCFS does end-to-end CRC32 for each 4k block of data. All metadata and communication is also CRC protected, although one other frame boundaries.</div><br/></div></div><div id="39478065" class="c"><input type="checkbox" id="c-39478065" checked=""/><div class="controls bullet"><span class="by">jorticka</span><span>|</span><a href="#39477175">parent</a><span>|</span><a href="#39478110">prev</a><span>|</span><a href="#39477224">next</a><span>|</span><label class="collapse" for="c-39478065">[-]</label><label class="expand" for="c-39478065">[1 more]</label></div><br/><div class="children"><div class="content">RocksDB supports hashing at multiple levels (key, value, files) because Meta also realized the importance of integrity. It also supports verifying them in bulk.<p>Presumably filesystems built over rocksdb also support this.</div><br/></div></div><div id="39477224" class="c"><input type="checkbox" id="c-39477224" checked=""/><div class="controls bullet"><span class="by">snissn</span><span>|</span><a href="#39477175">parent</a><span>|</span><a href="#39478065">prev</a><span>|</span><a href="#39476609">next</a><span>|</span><label class="collapse" for="c-39477224">[-]</label><label class="expand" for="c-39477224">[1 more]</label></div><br/><div class="children"><div class="content">do you use the hash of the items you&#x27;re storing as the key&#x2F;filename?</div><br/></div></div></div></div><div id="39476609" class="c"><input type="checkbox" id="c-39476609" checked=""/><div class="controls bullet"><span class="by">tonyhb</span><span>|</span><a href="#39477175">prev</a><span>|</span><a href="#39476823">next</a><span>|</span><label class="collapse" for="c-39476609">[-]</label><label class="expand" for="c-39476609">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;d like to learn more about JuiceFS, but from their architecture diagrams I&#x27;m struggling to see what benefit they provide if they&#x27;re a layer over blob store systems like Ceph, MinIO, etc.<p>It looks as though you need to set up the underlying storage engine that has its own recordkeeping (one point of failure), then layer JuiceFS on top — another point of failure, and I don&#x27;t know what it gives you.<p>It&#x27;s good that it&#x27;s fast, but if it&#x27;s pointing to another blob store you&#x27;d... expect it to be fast?  Is this only needed if you want properly faked file system primitives over blob stores, if you can&#x27;t use blob stores directly? Definitely need to spend some time reading.</div><br/><div id="39478089" class="c"><input type="checkbox" id="c-39478089" checked=""/><div class="controls bullet"><span class="by">snerbles</span><span>|</span><a href="#39476609">parent</a><span>|</span><a href="#39477231">next</a><span>|</span><label class="collapse" for="c-39478089">[-]</label><label class="expand" for="c-39478089">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Is this only needed if you want properly faked file system primitives over blob stores, if you can&#x27;t use blob stores directly?<p>Semiconductor EDA comes to mind, where users are at the mercy of their tool vendors and they expect something that really hasn&#x27;t evolved much past an office network of Unix workstations from 1999. Object storage is almost completely alien to the tooling, and despite significant file &amp; block storage costs there is little interest from EDA tool vendors to adapt their tools to object storage. This is a challenge for semiconductor firms operating in or moving to a cloud environment.<p>S3FS&#x2F;rclone can of course act as a shim, but are very slow when it comes to metadata operations in a typical shell. But if you were to move your metadata away from the distant object store and closer to to your compute environment things actually start becoming usable - this is the case with JuiceFS. Of course there are also tiered storage systems like Weka would have better overall performance, but is more complicated to set up and more expensive to operate than JuiceFS.</div><br/></div></div><div id="39477231" class="c"><input type="checkbox" id="c-39477231" checked=""/><div class="controls bullet"><span class="by">thinxer</span><span>|</span><a href="#39476609">parent</a><span>|</span><a href="#39478089">prev</a><span>|</span><a href="#39476859">next</a><span>|</span><label class="collapse" for="c-39477231">[-]</label><label class="expand" for="c-39477231">[1 more]</label></div><br/><div class="children"><div class="content">For “cloud-native” apps, JuiceFS is not needed.<p>S3 is not designed for intensive metadata operations, like listing, renaming etc.  For these operations, you will need a somewhat POSIX-complaint system.  For example, if you want to train on ImageNet dataset, the “canonical” way [1] is to extract the images and organize them into folders, class by class.  The whole dataset is discovered by directory listing.  This where JuiceFS shines.<p>Of course, if the dataset is really massive, you will mostly end-up with in-house solutions.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;pytorch&#x2F;examples&#x2F;blob&#x2F;main&#x2F;imagenet&#x2F;extract_ILSVRC.sh">https:&#x2F;&#x2F;github.com&#x2F;pytorch&#x2F;examples&#x2F;blob&#x2F;main&#x2F;imagenet&#x2F;extra...</a></div><br/></div></div><div id="39476859" class="c"><input type="checkbox" id="c-39476859" checked=""/><div class="controls bullet"><span class="by">daviesliu</span><span>|</span><a href="#39476609">parent</a><span>|</span><a href="#39477231">prev</a><span>|</span><a href="#39476823">next</a><span>|</span><label class="collapse" for="c-39476859">[-]</label><label class="expand" for="c-39476859">[1 more]</label></div><br/><div class="children"><div class="content">JuiceFS is similar to HDFS&#x2F;CephFS&#x2F;Lustre, so it MUST has a component to manage metadata, similar to NameNode of HDFS or MDS of CephFS, this point of failure is the problem we have to address.<p>The underlying blob store systems is similar to DataNode or OSD in other distributed file system, could be slower than them a little bit because of the middle layers, the overall performance is determined by the disks.<p>So we can expect similar performance comparing to HDFS&#x2F;CephFS, the benchmark results also confirm that.</div><br/></div></div></div></div><div id="39476823" class="c"><input type="checkbox" id="c-39476823" checked=""/><div class="controls bullet"><span class="by">seungwoolee518</span><span>|</span><a href="#39476609">prev</a><span>|</span><a href="#39476555">next</a><span>|</span><label class="collapse" for="c-39476823">[-]</label><label class="expand" for="c-39476823">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve put this on table for distributed storage on Kubernetes.<p>It&#x27;s quite simple in front, simple to explain that split object and metadata storage.<p>but it&#x27;s too hard to select and tune each storage.<p>So I (or We)&#x27;ve decided to move to Ceph.</div><br/><div id="39476887" class="c"><input type="checkbox" id="c-39476887" checked=""/><div class="controls bullet"><span class="by">daviesliu</span><span>|</span><a href="#39476823">parent</a><span>|</span><a href="#39476555">next</a><span>|</span><label class="collapse" for="c-39476887">[-]</label><label class="expand" for="c-39476887">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, the all-in-one solution (Ceph) should be better, if you have to setup all the components.<p>If you already have the infra (databases and object stores), then JuiceFS is the easiest solution to have a distributed file system.</div><br/></div></div></div></div><div id="39476555" class="c"><input type="checkbox" id="c-39476555" checked=""/><div class="controls bullet"><span class="by">invalidator</span><span>|</span><a href="#39476823">prev</a><span>|</span><a href="#39477141">next</a><span>|</span><label class="collapse" for="c-39476555">[-]</label><label class="expand" for="c-39476555">[5 more]</label></div><br/><div class="children"><div class="content">headline.append(&quot; Per File&quot;)</div><br/><div id="39476678" class="c"><input type="checkbox" id="c-39476678" checked=""/><div class="controls bullet"><span class="by">thwarted</span><span>|</span><a href="#39476555">parent</a><span>|</span><a href="#39476584">next</a><span>|</span><label class="collapse" for="c-39476678">[-]</label><label class="expand" for="c-39476678">[3 more]</label></div><br/><div class="children"><div class="content">This is implied by &quot;average&quot;, assuming it&#x27;s understood that a filesystem&#x27;s primary unit is the &quot;file&quot;.</div><br/><div id="39478152" class="c"><input type="checkbox" id="c-39478152" checked=""/><div class="controls bullet"><span class="by">rat9988</span><span>|</span><a href="#39476555">root</a><span>|</span><a href="#39476678">parent</a><span>|</span><a href="#39476852">next</a><span>|</span><label class="collapse" for="c-39478152">[-]</label><label class="expand" for="c-39478152">[1 more]</label></div><br/><div class="children"><div class="content">Actually, the average here just implies that tested in different configurations and scenarios, it should cut by 100 bytes in averages. Net per file. Adding &quot;per file&quot; does have a benefit.</div><br/></div></div><div id="39476852" class="c"><input type="checkbox" id="c-39476852" checked=""/><div class="controls bullet"><span class="by">LittleCat38</span><span>|</span><a href="#39476555">root</a><span>|</span><a href="#39476678">parent</a><span>|</span><a href="#39478152">prev</a><span>|</span><a href="#39476584">next</a><span>|</span><label class="collapse" for="c-39476852">[-]</label><label class="expand" for="c-39476852">[1 more]</label></div><br/><div class="children"><div class="content">Agree</div><br/></div></div></div></div><div id="39476584" class="c"><input type="checkbox" id="c-39476584" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#39476555">parent</a><span>|</span><a href="#39476678">prev</a><span>|</span><a href="#39477141">next</a><span>|</span><label class="collapse" for="c-39476584">[-]</label><label class="expand" for="c-39476584">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    Uncaught TypeError: headline.append is not a function</code></pre></div><br/></div></div></div></div><div id="39477141" class="c"><input type="checkbox" id="c-39477141" checked=""/><div class="controls bullet"><span class="by">mike_d</span><span>|</span><a href="#39476555">prev</a><span>|</span><a href="#39476611">next</a><span>|</span><label class="collapse" for="c-39477141">[-]</label><label class="expand" for="c-39477141">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll never understand the &quot;we are open source but lock $cool_but_essential_features behind an enterprise license.&quot;<p>Unless you plan to charge less than what a single developer makes in a quarter or two, any of your potential customers could at any point patch in the feature and open source the changes for everyone.<p>(Traefik and Riak are the two biggest offenders I&#x27;ve ran into)</div><br/><div id="39477180" class="c"><input type="checkbox" id="c-39477180" checked=""/><div class="controls bullet"><span class="by">MoOmer</span><span>|</span><a href="#39477141">parent</a><span>|</span><a href="#39477517">next</a><span>|</span><label class="collapse" for="c-39477180">[-]</label><label class="expand" for="c-39477180">[5 more]</label></div><br/><div class="children"><div class="content">Those patches are unlikely to be officially supported, though. I really support this mode of monetization, because community&#x2F;free users get something, well, free, while others get something more for a bit more. It’s [hopefully] sustainable for the engineers and team behind the product, too!</div><br/><div id="39477214" class="c"><input type="checkbox" id="c-39477214" checked=""/><div class="controls bullet"><span class="by">mike_d</span><span>|</span><a href="#39477141">root</a><span>|</span><a href="#39477180">parent</a><span>|</span><a href="#39477517">next</a><span>|</span><label class="collapse" for="c-39477214">[-]</label><label class="expand" for="c-39477214">[4 more]</label></div><br/><div class="children"><div class="content">So sell support? Seems to work really well for a lot of companies.</div><br/><div id="39477240" class="c"><input type="checkbox" id="c-39477240" checked=""/><div class="controls bullet"><span class="by">rapsey</span><span>|</span><a href="#39477141">root</a><span>|</span><a href="#39477214">parent</a><span>|</span><a href="#39477475">next</a><span>|</span><label class="collapse" for="c-39477240">[-]</label><label class="expand" for="c-39477240">[2 more]</label></div><br/><div class="children"><div class="content">No it does not. It is a garbage business model that killed the vast majority of companies pursuing it. The rest barely make a living.<p><a href="https:&#x2F;&#x2F;techcrunch.com&#x2F;2014&#x2F;02&#x2F;13&#x2F;please-dont-tell-me-you-want-to-be-the-next-red-hat&#x2F;" rel="nofollow">https:&#x2F;&#x2F;techcrunch.com&#x2F;2014&#x2F;02&#x2F;13&#x2F;please-dont-tell-me-you-wa...</a></div><br/><div id="39478359" class="c"><input type="checkbox" id="c-39478359" checked=""/><div class="controls bullet"><span class="by">panta</span><span>|</span><a href="#39477141">root</a><span>|</span><a href="#39477240">parent</a><span>|</span><a href="#39477475">next</a><span>|</span><label class="collapse" for="c-39478359">[-]</label><label class="expand" for="c-39478359">[1 more]</label></div><br/><div class="children"><div class="content">While the underlying idea that selling services on open source products is not sustainable from a purely business perspective may be true, the linked article is not particularly convincing to me, it doesn&#x27;t provide strong evidences and it&#x27;s based on an embarrassingly small sample size. Besides, maybe we should start to consider also other metrics when we evaluate a Business success, not only the mere economic profit: there are externalized societal benefits (and damages) that are very important and nonetheless poorly accounted for.</div><br/></div></div></div></div><div id="39477475" class="c"><input type="checkbox" id="c-39477475" checked=""/><div class="controls bullet"><span class="by">daviesliu</span><span>|</span><a href="#39477141">root</a><span>|</span><a href="#39477214">parent</a><span>|</span><a href="#39477240">prev</a><span>|</span><a href="#39477517">next</a><span>|</span><label class="collapse" for="c-39477475">[-]</label><label class="expand" for="c-39477475">[1 more]</label></div><br/><div class="children"><div class="content">The company may want the product to be difficult to use, so they can sell more support, that&#x27;s not win-win for both sides.</div><br/></div></div></div></div></div></div><div id="39477517" class="c"><input type="checkbox" id="c-39477517" checked=""/><div class="controls bullet"><span class="by">1propionyl</span><span>|</span><a href="#39477141">parent</a><span>|</span><a href="#39477180">prev</a><span>|</span><a href="#39476611">next</a><span>|</span><label class="collapse" for="c-39477517">[-]</label><label class="expand" for="c-39477517">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t pay for features. You pay for support.</div><br/></div></div></div></div></div></div></div></div></div></body></html>