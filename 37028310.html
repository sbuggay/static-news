<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1691398881124" as="style"/><link rel="stylesheet" href="styles.css?v=1691398881124"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://people.eecs.berkeley.edu/~wkahan/JAVAhurt.pdf">Java’s floating-point hurts everyone everywhere (1998) [pdf]</a> <span class="domain">(<a href="https://people.eecs.berkeley.edu">people.eecs.berkeley.edu</a>)</span></div><div class="subtext"><span>agomez314</span> | <span>73 comments</span></div><br/><div><div id="37029956" class="c"><input type="checkbox" id="c-37029956" checked=""/><div class="controls bullet"><span class="by">segfaultbuserr</span><span>|</span><a href="#37029645">next</a><span>|</span><label class="collapse" for="c-37029956">[-]</label><label class="expand" for="c-37029956">[1 more]</label></div><br/><div class="children"><div class="content">The problems were not specific to Java, they also exist in most modern programming environments, including FORTRAN and ANSI C. Java just happened to be the hottest language in the news in the late 90s, so the author decided to specifically target Java - &quot;hurts everyone everywhere&quot; was a wordplay of Java&#x27;s advertisement.<p>The main author of this report, W. Kahan, was also the original author of IEEE-754. He was (and is) strongly unsatisfied on the state of floating-point in practical systems, and it was not his first time to complain about these problems. One can find his most recent critique from a few years ago.<p>My understanding is that, Kahan&#x27;s IEEE-754 is meant to:<p>1. The use of double and extended precision should be encouraged to safeguard non-experts from floating-point errors. Everything should be at least double precision by default, and extended precision serves as an additional safeguard. In fact, when IEEE-754 was being drafted, Kahan believed 128-bit floating point should also be supported as computers become more powerful in the future. The computational cost was too high at that time, so he settled on 80-bit as seen on the 8087. He criticized Java for not supporting it.<p>2. Floating-point exceptions should be used and turned on everywhere to safeguard programmers from making mistakes, and possibly to allow programs to handle them as special cases in the logic at runtime. He criticized Java for not supporting it.<p>3. Unsafe optimizations should not be done, such as automatically using FMA, or using algebraic identity in compiler optimization.  He criticized Java for allowing it in some cases.<p>Unfortunately, as far as I can see, these ideals of IEEE-754 have all but largely disappeared in real-world applications since then, for various practical reasons.<p>The industry did not move to 128-bit floating point because its performance overhead is too large, the original assessment of IEEE-754 in the 1980s was too optimistic. Similarly, the industry did not accept 80-bit extended precision as a standard but saw it as an oddity of the Intel 8087, even Intel has abandoned it - x86_64&#x27;s SSE or AVX has removed all support of that, making it an exclusive feature of obsolete i386&#x2F;i686 machines. My impression is that anything above double precision is no longer used in the industry (IBM POWER does have native quad-precision support, to their credit).<p>A secondary overhead of higher-precision floats is the memory wall, arguably a more serious problem today. Memory bandwidth has become the most serious overhead for many numerical programs. Modern computers have a machine balance of 100:1, it means you need to do as many as 100 floating-point operations after loading a single value from RAM to reach the machine&#x27;s peak performance. But this is not compatible with many algorithms with an inherently low arithmetic intensity, including important physics simulations. The use of of FP80 or FP128 will make them unacceptably slower. As a result, today&#x27;s trend is moving from FP64 to FP32, and even to FP16 or a custom 16-bit format if possible, not vice versa.<p>The use of floating-point exceptions similarly became unpopular because of performance problems. I&#x27;m not an expert on this, but it was my impression that signaling a floating-point exception was so expensive on both hardware and operation-system level that it was never seriously used in most practical programs. So in contrary to IEEE-754, these exceptions never became an integral part of the programming environment. In addition to an expensive Unix signal, potential exceptions also inhibit the efficient pipelining of modern out-of-order, superscalar CPUs.<p>Finally, the use of unsafe optimizations is prevalent in many applications when rigor is sacrificed for speed.<p>So overall, the original spirit of IEEE-754 was long gone - for better or worse, unfortunately.</div><br/></div></div><div id="37029645" class="c"><input type="checkbox" id="c-37029645" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#37029956">prev</a><span>|</span><a href="#37029500">next</a><span>|</span><label class="collapse" for="c-37029645">[-]</label><label class="expand" for="c-37029645">[2 more]</label></div><br/><div class="children"><div class="content">This is from <i>March</i> 1998, and predates JVM 1.2 which introduced strictfp (which is important because JVM was otherwise numerically IEEE 754 compliant before strictfp). I believe the core point of this talk has not been &quot;fixed&quot; [1] because it completely missed the problem with IEEE 754 global states. Like, the talk says:<p><i>A flag is a type of global variable raised as a side-effect of exceptional floating-point operations. Also
it can be sensed, saved, restored and lowered by a program. When raised it may, in some systems,
serve an extra-linguistic diagnostic function by pointing to the first or last operation that raised it.</i><p>Any modern programmer knows that side effects are, while inevitable, hard to tame and some discipline is needed. Pure functional programming, mutable XOR shared, software transactional memory, you name it. This part of talk completely handwaves a difficulty of side effects and <i>forces</i> every language to be handcuffed with those global states and side effects. No good.<p>[1] Joe Darcy, one of the students of William Kahan, later went to Sun to improve fp support in Java; see <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20090402234711&#x2F;http:&#x2F;&#x2F;blogs.sun.com&#x2F;darcy&#x2F;entry&#x2F;everything_old_is_new_again" rel="nofollow noreferrer">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20090402234711&#x2F;http:&#x2F;&#x2F;blogs.sun....</a> and <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20100224062224&#x2F;http:&#x2F;&#x2F;blogs.sun.com&#x2F;darcy&#x2F;entry&#x2F;everything_older_is_newer_once" rel="nofollow noreferrer">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20100224062224&#x2F;http:&#x2F;&#x2F;blogs.sun....</a> for example. But his work was more about library supports AFAIK.</div><br/><div id="37030990" class="c"><input type="checkbox" id="c-37030990" checked=""/><div class="controls bullet"><span class="by">smarks</span><span>|</span><a href="#37029645">parent</a><span>|</span><a href="#37029500">next</a><span>|</span><label class="collapse" for="c-37030990">[-]</label><label class="expand" for="c-37030990">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for mentioning Joe Darcy. He continues to work on the JDK at Oracle and occasionally works on numerics issues. Notable for this discussion, he recently updated the Java specifications for JDK 17 to remove non-strict FP semantics (which also entailed removal of the `strictfp` modifier, since the default now is always strict). See JEP 306. [1]<p>[1]: <a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;306" rel="nofollow noreferrer">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;306</a></div><br/></div></div></div></div><div id="37029500" class="c"><input type="checkbox" id="c-37029500" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#37029645">prev</a><span>|</span><a href="#37030583">next</a><span>|</span><label class="collapse" for="c-37029500">[-]</label><label class="expand" for="c-37029500">[14 more]</label></div><br/><div class="children"><div class="content">So half the complaint here is that Java doesn&#x27;t let you use the 80-bit x87 floating-point type. Well, actually it <i>does</i>--if you <i>don&#x27;t</i> add `strictfp` to your method declarations, Java is allowed to compute intermediate results of float and double computations in higher precision, and this was retrofitted because it&#x27;s actually somewhat difficult to get the x87 floating-point unit to actually do single- or double-precision (as opposed to extended-precision) arithmetic. But you don&#x27;t actually want to use the 80-bit type; it&#x27;s slower in practice, and it has some extra wonkiness over other IEEE 754 types that it&#x27;s really not worth it. And on 64-bit x86, everyone just uses SSE for floating-point units and thus you don&#x27;t need to worry about x87 unless you explicitly opt into its insanity.<p>As a numerical analyst, Kahan is pretty obsessed with use-as-much-precision-as-you-can. But there&#x27;s a useful rule of thumb: you need about twice the amount of working precision as your final result. Since double precision has a 53-bit mantissa (~16 decimal digits), that means if you need only 8 or fewer decimal digits, you&#x27;re completely fine with double precision. And furthermore, the experiences I&#x27;ve had with many programmers suggest that getting bit-equivalent results from different machines is a higher priority than squeezing the best possible numerics out of your hardware. HPC does tend to care about the latter a lot more, but that&#x27;s also an area where the solution is almost always to just use your system&#x27;s advanced math libraries (e.g., MKL for dense linear algebra).</div><br/><div id="37031652" class="c"><input type="checkbox" id="c-37031652" checked=""/><div class="controls bullet"><span class="by">ClumsyPilot</span><span>|</span><a href="#37029500">parent</a><span>|</span><a href="#37030528">next</a><span>|</span><label class="collapse" for="c-37031652">[-]</label><label class="expand" for="c-37031652">[2 more]</label></div><br/><div class="children"><div class="content">&gt; precision has a 53-bit mantissa (~16 decimal digits), that means if you need only 8 or fewer decimal digits, you&#x27;re completely fine with double precision<p>phave you ever played Kerbal Soace Program? have you met the Kraken?<p>the game simulates a spacecraft you build piece by piece. So you are flying around in space and a thruster fires and maybe some part of the ship is poorly attached and it wobbling. Everything is fine, but then you clip upper atmosphere of mars, and everything goes to shit - tleven though it shoupd pose no threat, the spacecraft spontaneously shakes itself to pieces<p>That game is plagued by massove problems with floating point errors , they kill you vrew, they ruin your missions, your speed of rotation becomea a NAN</div><br/><div id="37031959" class="c"><input type="checkbox" id="c-37031959" checked=""/><div class="controls bullet"><span class="by">imtringued</span><span>|</span><a href="#37029500">root</a><span>|</span><a href="#37031652">parent</a><span>|</span><a href="#37030528">next</a><span>|</span><label class="collapse" for="c-37031959">[-]</label><label class="expand" for="c-37031959">[1 more]</label></div><br/><div class="children"><div class="content">OpenSpace uses 32 bit floating point numbers and can scale from planck length to the whole diameter of the observable universe with practically no loss of precision. The problem with this approach is that KSP would need to rewrite the entire rendering engine and physics engine from scratch to support infinite precision.</div><br/></div></div></div></div><div id="37030528" class="c"><input type="checkbox" id="c-37030528" checked=""/><div class="controls bullet"><span class="by">mkl</span><span>|</span><a href="#37029500">parent</a><span>|</span><a href="#37031652">prev</a><span>|</span><a href="#37029600">next</a><span>|</span><label class="collapse" for="c-37030528">[-]</label><label class="expand" for="c-37030528">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But there&#x27;s a useful rule of thumb: you need about twice the amount of working precision as your final result. Since double precision has a 53-bit mantissa (~16 decimal digits), that means if you need only 8 or fewer decimal digits, you&#x27;re completely fine with double precision.<p>This doesn&#x27;t seem right, or at least it&#x27;s not very general.  The more operations you do, the more rounding errors you have, and each operation has the potential to magnify earlier errors.  In solving ill-conditioned problems (which are not uncommon) the errors can easily be magnified so much that they&#x27;re bigger than your signal, even with relatively small and simple situations.</div><br/></div></div><div id="37029600" class="c"><input type="checkbox" id="c-37029600" checked=""/><div class="controls bullet"><span class="by">thebooktocome</span><span>|</span><a href="#37029500">parent</a><span>|</span><a href="#37030528">prev</a><span>|</span><a href="#37030583">next</a><span>|</span><label class="collapse" for="c-37029600">[-]</label><label class="expand" for="c-37029600">[10 more]</label></div><br/><div class="children"><div class="content">Strictfp is no longer used as of JVM 17. IEEE-754 semantics are default.<p><a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;306" rel="nofollow noreferrer">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;306</a><p>Ironically, using your system’s math libraries will probably make replicating floating point results harder. Especially on macOS. Accelerate is a curse.<p>I disagree with your gloss of Kahan’s philosophy. His approach is more along the lines of “do not waste precision”. But this philosophy is not the complete truth; as close as I can state it briefly, my modification would be “do not waste precision that may be needed later”.</div><br/><div id="37031157" class="c"><input type="checkbox" id="c-37031157" checked=""/><div class="controls bullet"><span class="by">owlbite</span><span>|</span><a href="#37029500">root</a><span>|</span><a href="#37029600">parent</a><span>|</span><a href="#37029652">next</a><span>|</span><label class="collapse" for="c-37031157">[-]</label><label class="expand" for="c-37031157">[1 more]</label></div><br/><div class="children"><div class="content">Attempting to get bit-exact reproducible results across different hardware is a fool&#x27;s errand (if you care in the least about performance).<p>The nature of the beast is that as soon as you change the order of arithmetic you&#x27;re going to get a different result. Optimized code is going to give you different results on different hardware due to the fact that you need to optimize things differently. Threading, memory alignment and&#x2F;or different versions of the library software are likely to lead to different results even on the same machine unless the authors of the library go out of the way to promise repeatability.<p>(If you want to get the same answer, run on a single thread, page align everything you feed in, and never upgrade your system; alternatively write a scalar loop in C, compile with -O0 and pray the compiler doesn&#x27;t change the order of things on its next upgrade).</div><br/></div></div><div id="37029652" class="c"><input type="checkbox" id="c-37029652" checked=""/><div class="controls bullet"><span class="by">arthur2e5</span><span>|</span><a href="#37029500">root</a><span>|</span><a href="#37029600">parent</a><span>|</span><a href="#37031157">prev</a><span>|</span><a href="#37029648">next</a><span>|</span><label class="collapse" for="c-37029652">[-]</label><label class="expand" for="c-37029652">[4 more]</label></div><br/><div class="children"><div class="content">&gt; It is not a goal to define any sort of &quot;fast-fp&quot; or &quot;loose-fp&quot; (c.f. JSR 84: Floating Point Extensions).<p>(Comic villain sitting in his fast-math lair) Foiled yet again!</div><br/><div id="37029776" class="c"><input type="checkbox" id="c-37029776" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#37029500">root</a><span>|</span><a href="#37029652">parent</a><span>|</span><a href="#37029672">next</a><span>|</span><label class="collapse" for="c-37029776">[-]</label><label class="expand" for="c-37029776">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve long since decided that my write up on floating point will be titled &quot;Floating Point or: How I Learned to Start Worrying and Hate Fast-Math&quot;.</div><br/></div></div><div id="37029672" class="c"><input type="checkbox" id="c-37029672" checked=""/><div class="controls bullet"><span class="by">thebooktocome</span><span>|</span><a href="#37029500">root</a><span>|</span><a href="#37029652">parent</a><span>|</span><a href="#37029776">prev</a><span>|</span><a href="#37029648">next</a><span>|</span><label class="collapse" for="c-37029672">[-]</label><label class="expand" for="c-37029672">[2 more]</label></div><br/><div class="children"><div class="content">As a fellow practitioner of the demonic -ffast-math arts, let us cackle menacingly together. :)</div><br/><div id="37031088" class="c"><input type="checkbox" id="c-37031088" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#37029500">root</a><span>|</span><a href="#37029672">parent</a><span>|</span><a href="#37029648">next</a><span>|</span><label class="collapse" for="c-37031088">[-]</label><label class="expand" for="c-37031088">[1 more]</label></div><br/><div class="children"><div class="content">Did you mean -fbroken-and-not-necessarily-fast-math? [1]<p>[1] But really, if -ffast-math does turn -funsafe-math-optimizations on, it should have been named similarly. There is a possibility of much safer -ffast-math with almost zero breakage (by assuming a subset of IEEE 754, like the fixed rounding mode). The current -ffast-math is so reckless [2].<p>[2] <a href="https:&#x2F;&#x2F;simonbyrne.github.io&#x2F;notes&#x2F;fastmath&#x2F;#flushing_subnormals_to_zero" rel="nofollow noreferrer">https:&#x2F;&#x2F;simonbyrne.github.io&#x2F;notes&#x2F;fastmath&#x2F;#flushing_subnor...</a></div><br/></div></div></div></div></div></div><div id="37029648" class="c"><input type="checkbox" id="c-37029648" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#37029500">root</a><span>|</span><a href="#37029600">parent</a><span>|</span><a href="#37029652">prev</a><span>|</span><a href="#37029840">next</a><span>|</span><label class="collapse" for="c-37029648">[-]</label><label class="expand" for="c-37029648">[1 more]</label></div><br/><div class="children"><div class="content">I was unaware that Java finally got rid of strictfp (though happy that it finally did). It was added in Java 1.2, perhaps in response to this paper, though I don&#x27;t know the entire timeline accurately.</div><br/></div></div><div id="37029840" class="c"><input type="checkbox" id="c-37029840" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#37029500">root</a><span>|</span><a href="#37029600">parent</a><span>|</span><a href="#37029648">prev</a><span>|</span><a href="#37030583">next</a><span>|</span><label class="collapse" for="c-37029840">[-]</label><label class="expand" for="c-37029840">[3 more]</label></div><br/><div class="children"><div class="content">though you imply the contrary, the 8087 is ieee-754-compliant; kahan&#x27;s involvement in its design and in the standards process ensured that</div><br/><div id="37029916" class="c"><input type="checkbox" id="c-37029916" checked=""/><div class="controls bullet"><span class="by">thebooktocome</span><span>|</span><a href="#37029500">root</a><span>|</span><a href="#37029840">parent</a><span>|</span><a href="#37030583">next</a><span>|</span><label class="collapse" for="c-37029916">[-]</label><label class="expand" for="c-37029916">[2 more]</label></div><br/><div class="children"><div class="content">Where did I imply that? The fault was with the JVM.<p>“The impetus for changing the default floating-point semantics of the platform in the late 1990&#x27;s stemmed from a bad interaction between the original Java language and JVM semantics and some unfortunate peculiarities of the x87 floating-point co-processor instruction set of the popular x86 architecture.”</div><br/><div id="37029946" class="c"><input type="checkbox" id="c-37029946" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#37029500">root</a><span>|</span><a href="#37029916">parent</a><span>|</span><a href="#37030583">next</a><span>|</span><label class="collapse" for="c-37029946">[-]</label><label class="expand" for="c-37029946">[1 more]</label></div><br/><div class="children"><div class="content">glad we&#x27;ve cleared that up</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37030583" class="c"><input type="checkbox" id="c-37030583" checked=""/><div class="controls bullet"><span class="by">kstenerud</span><span>|</span><a href="#37029500">prev</a><span>|</span><a href="#37029304">next</a><span>|</span><label class="collapse" for="c-37030583">[-]</label><label class="expand" for="c-37030583">[1 more]</label></div><br/><div class="children"><div class="content">Wow, that document is difficult to read. I was expecting a summary of the main points a the top, followed by a set of sections - each with cogent introductions and a progressive series of arguments to prove the point, followed by a concise conclusion.<p>Instead, this is a rambling, mostly unstructured document where it&#x27;s nearly impossible to follow the many scattered threads of thought, or even catch which side of some of the arguments he&#x27;s actually on.</div><br/></div></div><div id="37029304" class="c"><input type="checkbox" id="c-37029304" checked=""/><div class="controls bullet"><span class="by">shagie</span><span>|</span><a href="#37030583">prev</a><span>|</span><a href="#37028941">next</a><span>|</span><label class="collapse" for="c-37029304">[-]</label><label class="expand" for="c-37029304">[5 more]</label></div><br/><div class="children"><div class="content">From the last page:<p>&gt; Conclusions<p>&gt; ...<p>&gt; To win, Java has to surpass Microsoft&#x27;s J++ in in attractiveness to software developers. This means better design better thought through, less prone to error, easier to debug, ... and many other things.<p>This document is a bit dated.</div><br/><div id="37029420" class="c"><input type="checkbox" id="c-37029420" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#37029304">parent</a><span>|</span><a href="#37028941">next</a><span>|</span><label class="collapse" for="c-37029420">[-]</label><label class="expand" for="c-37029420">[4 more]</label></div><br/><div class="children"><div class="content">If it talks about J++, it&#x27;s ancient. You helped people dodge a time-wasting bullet here.</div><br/><div id="37029525" class="c"><input type="checkbox" id="c-37029525" checked=""/><div class="controls bullet"><span class="by">silisili</span><span>|</span><a href="#37029304">root</a><span>|</span><a href="#37029420">parent</a><span>|</span><a href="#37028941">next</a><span>|</span><label class="collapse" for="c-37029525">[-]</label><label class="expand" for="c-37029525">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s from 1998, for anyone who is curious.  Quite ancient indeed...</div><br/><div id="37030752" class="c"><input type="checkbox" id="c-37030752" checked=""/><div class="controls bullet"><span class="by">re-thc</span><span>|</span><a href="#37029304">root</a><span>|</span><a href="#37029525">parent</a><span>|</span><a href="#37028941">next</a><span>|</span><label class="collapse" for="c-37030752">[-]</label><label class="expand" for="c-37030752">[2 more]</label></div><br/><div class="children"><div class="content">I wonder how many posters were even born before then.</div><br/><div id="37031082" class="c"><input type="checkbox" id="c-37031082" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#37029304">root</a><span>|</span><a href="#37030752">parent</a><span>|</span><a href="#37028941">next</a><span>|</span><label class="collapse" for="c-37031082">[-]</label><label class="expand" for="c-37031082">[1 more]</label></div><br/><div class="children"><div class="content">Java was born before then; by three years.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37028941" class="c"><input type="checkbox" id="c-37028941" checked=""/><div class="controls bullet"><span class="by">verteu</span><span>|</span><a href="#37029304">prev</a><span>|</span><a href="#37030239">next</a><span>|</span><label class="collapse" for="c-37028941">[-]</label><label class="expand" for="c-37028941">[1 more]</label></div><br/><div class="children"><div class="content">I recommend reading from Page 19, it describes the heart of the issue.</div><br/></div></div><div id="37030239" class="c"><input type="checkbox" id="c-37030239" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#37028941">prev</a><span>|</span><a href="#37029445">next</a><span>|</span><label class="collapse" for="c-37030239">[-]</label><label class="expand" for="c-37030239">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>How Java’s Floating-Point Hurts Everyone Everywhere (1998) [pdf]</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=6585828">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=6585828</a> - Oct 2013 (72 comments)</div><br/></div></div><div id="37029445" class="c"><input type="checkbox" id="c-37029445" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#37030239">prev</a><span>|</span><a href="#37029059">next</a><span>|</span><label class="collapse" for="c-37029445">[-]</label><label class="expand" for="c-37029445">[3 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t that just inherited from C?<p>I can&#x27;t think on any widely-used language that does it right nowadays (except Rust, if you change some flags, and not by default).<p>For sure, 20 years ago there were some dying languages that behaved differently, and yes, the Java position there did hurt everybody, but it&#x27;s the same one everybody else took.</div><br/><div id="37029706" class="c"><input type="checkbox" id="c-37029706" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#37029445">parent</a><span>|</span><a href="#37029454">next</a><span>|</span><label class="collapse" for="c-37029706">[-]</label><label class="expand" for="c-37029706">[1 more]</label></div><br/><div class="children"><div class="content">You must be talking about <i>integer</i> overflow checks [1]. This talk is more about something like C&#x27;s fenv.h.<p>[1] <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rustc&#x2F;codegen-options&#x2F;index.html#overflow-checks" rel="nofollow noreferrer">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rustc&#x2F;codegen-options&#x2F;index.html#o...</a></div><br/></div></div><div id="37029454" class="c"><input type="checkbox" id="c-37029454" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#37029445">parent</a><span>|</span><a href="#37029706">prev</a><span>|</span><a href="#37029059">next</a><span>|</span><label class="collapse" for="c-37029454">[-]</label><label class="expand" for="c-37029454">[1 more]</label></div><br/><div class="children"><div class="content">Which flags?</div><br/></div></div></div></div><div id="37029199" class="c"><input type="checkbox" id="c-37029199" checked=""/><div class="controls bullet"><span class="by">breadwinner</span><span>|</span><a href="#37029059">prev</a><span>|</span><a href="#37028916">next</a><span>|</span><label class="collapse" for="c-37029199">[-]</label><label class="expand" for="c-37029199">[1 more]</label></div><br/><div class="children"><div class="content">This PDF is dated 2004. Please add that to the title.</div><br/></div></div><div id="37028916" class="c"><input type="checkbox" id="c-37028916" checked=""/><div class="controls bullet"><span class="by">pestatije</span><span>|</span><a href="#37029199">prev</a><span>|</span><a href="#37029314">next</a><span>|</span><label class="collapse" for="c-37028916">[-]</label><label class="expand" for="c-37028916">[2 more]</label></div><br/><div class="children"><div class="content">1998</div><br/><div id="37030242" class="c"><input type="checkbox" id="c-37030242" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#37028916">parent</a><span>|</span><a href="#37029314">next</a><span>|</span><label class="collapse" for="c-37030242">[-]</label><label class="expand" for="c-37030242">[1 more]</label></div><br/><div class="children"><div class="content">Added. Thanks!</div><br/></div></div></div></div><div id="37029314" class="c"><input type="checkbox" id="c-37029314" checked=""/><div class="controls bullet"><span class="by">6510</span><span>|</span><a href="#37028916">prev</a><span>|</span><a href="#37028334">next</a><span>|</span><label class="collapse" for="c-37029314">[-]</label><label class="expand" for="c-37029314">[21 more]</label></div><br/><div class="children"><div class="content">Floats are such an embarrassment to have to explain to new developers. Then you have to explain that there is no intention to fix it. And then there are all these developers who make the field look like a cult by endlessly chanting how it works the way it should work. Who seem not to know the difference between correct and incorrect, the difference between right and wrong.</div><br/><div id="37029547" class="c"><input type="checkbox" id="c-37029547" checked=""/><div class="controls bullet"><span class="by">dreamcompiler</span><span>|</span><a href="#37029314">parent</a><span>|</span><a href="#37029373">next</a><span>|</span><label class="collapse" for="c-37029547">[-]</label><label class="expand" for="c-37029547">[4 more]</label></div><br/><div class="children"><div class="content">Floats cannot be &quot;fixed&quot; because they are not broken. Floats are an extremely limited subset of the general rationals, and the general rationals are an extremely limited subset of the general reals.<p>It&#x27;s theoretically impossible to compute with the general reals. Full stop.<p>It&#x27;s theoretically possible to compute with the general rationals (Common Lisp for example lets you do so) but it&#x27;s often impractical because you can easily end up running out of memory and&#x2F;or time for the computation to complete.<p>It&#x27;s practical to compute with floats because you can guarantee hard limits on memory usage and time. You just have to live with the fact that you can&#x27;t represent the vast majority of real numbers and you lose associative arithmetic.<p>There are various other, weirder, computational number systems out there but the tradeoffs don&#x27;t go away; they just move around.</div><br/><div id="37031362" class="c"><input type="checkbox" id="c-37031362" checked=""/><div class="controls bullet"><span class="by">constantcrying</span><span>|</span><a href="#37029314">root</a><span>|</span><a href="#37029547">parent</a><span>|</span><a href="#37029809">next</a><span>|</span><label class="collapse" for="c-37031362">[-]</label><label class="expand" for="c-37031362">[1 more]</label></div><br/><div class="children"><div class="content">&gt;It&#x27;s theoretically impossible to compute with the general reals. Full stop.<p>While that is true. It <i>is</i> possible to make mathematical true statememts about results of real number arithmetic on a computer.<p>&gt;you lose associative arithmetic.<p>People like to complain about this, but it is a <i>mathematical</i> consequence of the reuirements. You can not fix that problem.</div><br/></div></div><div id="37029809" class="c"><input type="checkbox" id="c-37029809" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#37029314">root</a><span>|</span><a href="#37029547">parent</a><span>|</span><a href="#37031362">prev</a><span>|</span><a href="#37029373">next</a><span>|</span><label class="collapse" for="c-37029809">[-]</label><label class="expand" for="c-37029809">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s theoretically impossible to compute with the general reals. Full stop.<p>You could limit yourself to the computable numbers. Although you do have an issue determining equality on general computable numbers...<p>But yeah, I would agree that floating-point is generally the best compromise out there for a general-purpose computational approximation to real numbers.</div><br/></div></div></div></div><div id="37029373" class="c"><input type="checkbox" id="c-37029373" checked=""/><div class="controls bullet"><span class="by">FabHK</span><span>|</span><a href="#37029314">parent</a><span>|</span><a href="#37029547">prev</a><span>|</span><a href="#37031292">next</a><span>|</span><label class="collapse" for="c-37029373">[-]</label><label class="expand" for="c-37029373">[12 more]</label></div><br/><div class="children"><div class="content">There are infinitely many real numbers (uncountably even), but your computer can only handle finitely many things. Something has to give.<p>While many people complain about it, IEEE 754 is a very thoughtful and thorough standard, and the reason it is still around is that nothing unambiguously better has been proposed yet.</div><br/><div id="37029397" class="c"><input type="checkbox" id="c-37029397" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#37029314">root</a><span>|</span><a href="#37029373">parent</a><span>|</span><a href="#37031292">next</a><span>|</span><label class="collapse" for="c-37029397">[-]</label><label class="expand" for="c-37029397">[11 more]</label></div><br/><div class="children"><div class="content">For the vast majority of uses: big-number libraries are far better.  They act like people expect numbers to act.<p>Save floats for performance optimizations.  Start out correct, optimize when you can show both need for speed and non-need for correctness.</div><br/><div id="37029451" class="c"><input type="checkbox" id="c-37029451" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#37029314">root</a><span>|</span><a href="#37029397">parent</a><span>|</span><a href="#37029623">next</a><span>|</span><label class="collapse" for="c-37029451">[-]</label><label class="expand" for="c-37029451">[8 more]</label></div><br/><div class="children"><div class="content">If you are doing signal processing, ML, simulations, gaming or the like, you can know going in that you will need to use primitive types from a performance standpoint which sometimes means fixed point but often means floating point.</div><br/><div id="37030531" class="c"><input type="checkbox" id="c-37030531" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37029314">root</a><span>|</span><a href="#37029451">parent</a><span>|</span><a href="#37029526">next</a><span>|</span><label class="collapse" for="c-37030531">[-]</label><label class="expand" for="c-37030531">[1 more]</label></div><br/><div class="children"><div class="content">Occasionally yes. But the niche where you need something other than decimal bignums is narrow, and the niche where you need that but <i>don&#x27;t</i> need to get into the weeds of custom float formats etc. is narrower still. IEEE 754 shouldn&#x27;t be front-and-center in general-purpose programming languages.</div><br/></div></div><div id="37029526" class="c"><input type="checkbox" id="c-37029526" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#37029314">root</a><span>|</span><a href="#37029451">parent</a><span>|</span><a href="#37030531">prev</a><span>|</span><a href="#37029623">next</a><span>|</span><label class="collapse" for="c-37029526">[-]</label><label class="expand" for="c-37029526">[6 more]</label></div><br/><div class="children"><div class="content">Many simulations and gaming are both better off using fixed point.  The range available with a 64-bit integer is staggering and precision varying with distance from an arbitrary origin is a bug, not a feature for those cases.</div><br/><div id="37030942" class="c"><input type="checkbox" id="c-37030942" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#37029314">root</a><span>|</span><a href="#37029526">parent</a><span>|</span><a href="#37031313">next</a><span>|</span><label class="collapse" for="c-37030942">[-]</label><label class="expand" for="c-37030942">[1 more]</label></div><br/><div class="children"><div class="content">The range available with 54 bit fixed point is also staggering.<p>And almost any code that would work with 54 bit fixed point works even better with 64 bit floating point, and the floating point version is much easier to code.<p>So sure, floating point isn&#x27;t optional when you start off assuming the same number of bits.  But if you treat it as a small overhead to make code more robust to large numbers, easier to code, and often faster to run, then it looks a lot better.</div><br/></div></div><div id="37031313" class="c"><input type="checkbox" id="c-37031313" checked=""/><div class="controls bullet"><span class="by">constantcrying</span><span>|</span><a href="#37029314">root</a><span>|</span><a href="#37029526">parent</a><span>|</span><a href="#37030942">prev</a><span>|</span><a href="#37029606">next</a><span>|</span><label class="collapse" for="c-37031313">[-]</label><label class="expand" for="c-37031313">[2 more]</label></div><br/><div class="children"><div class="content">Hilarious. Fixed point is <i>awful</i> it was thrown out the moment people could use floats on their computers. Fixed point numbers cause an enormous programmer overhead <i>and do not fix the problems</i>.</div><br/><div id="37031761" class="c"><input type="checkbox" id="c-37031761" checked=""/><div class="controls bullet"><span class="by">Karellen</span><span>|</span><a href="#37029314">root</a><span>|</span><a href="#37031313">parent</a><span>|</span><a href="#37029606">next</a><span>|</span><label class="collapse" for="c-37031761">[-]</label><label class="expand" for="c-37031761">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Fixed point numbers cause an enormous programmer overhead and do not fix the problems.<p>How so? Is that because of inherent problems with the outcomes of fixed-point arithmetic, or are they just clumsy to use and no-one&#x27;s written a decent library that makes dealing with fixed-point numbers straightforward?</div><br/></div></div></div></div><div id="37029606" class="c"><input type="checkbox" id="c-37029606" checked=""/><div class="controls bullet"><span class="by">gyrovagueGeist</span><span>|</span><a href="#37029314">root</a><span>|</span><a href="#37029526">parent</a><span>|</span><a href="#37031313">prev</a><span>|</span><a href="#37029736">next</a><span>|</span><label class="collapse" for="c-37029606">[-]</label><label class="expand" for="c-37029606">[1 more]</label></div><br/><div class="children"><div class="content">This is absolutely not the case for most physical simulations where the significant digits are more important than fixed decimal accuracy.</div><br/></div></div><div id="37029736" class="c"><input type="checkbox" id="c-37029736" checked=""/><div class="controls bullet"><span class="by">thebooktocome</span><span>|</span><a href="#37029314">root</a><span>|</span><a href="#37029526">parent</a><span>|</span><a href="#37029606">prev</a><span>|</span><a href="#37029623">next</a><span>|</span><label class="collapse" for="c-37029736">[-]</label><label class="expand" for="c-37029736">[1 more]</label></div><br/><div class="children"><div class="content">When exp(45) overflows that 64-bit integer doesn’t seem so impressive.</div><br/></div></div></div></div></div></div><div id="37029623" class="c"><input type="checkbox" id="c-37029623" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#37029314">root</a><span>|</span><a href="#37029397">parent</a><span>|</span><a href="#37029451">prev</a><span>|</span><a href="#37031304">next</a><span>|</span><label class="collapse" for="c-37029623">[-]</label><label class="expand" for="c-37029623">[1 more]</label></div><br/><div class="children"><div class="content">Big-number libraries break down if you want to do anything other than be a 4-function calculator (and honestly, even division can be questionable, since some big-number libraries use fixed base-10 and thus even ⅓ isn&#x27;t accurately representable). Want to throw in a call to sin or exp? Your only realistic option is some sort of floating-point, and that quickly boils down to &quot;do we use IEEE 754 single or double precision? Or are we in the rare case when we need quad [1]?&quot;<p>[1] I believe the biggest use of quad precision is evaluating the accuracy of double precision arithmetic.</div><br/></div></div><div id="37031304" class="c"><input type="checkbox" id="c-37031304" checked=""/><div class="controls bullet"><span class="by">constantcrying</span><span>|</span><a href="#37029314">root</a><span>|</span><a href="#37029397">parent</a><span>|</span><a href="#37029623">prev</a><span>|</span><a href="#37031292">next</a><span>|</span><label class="collapse" for="c-37031304">[-]</label><label class="expand" for="c-37031304">[1 more]</label></div><br/><div class="children"><div class="content">&gt;For the vast majority of uses: big-number libraries are far better. They act like people expect numbers to act.<p>They are usually useless. Almost all programs need fast floats.</div><br/></div></div></div></div></div></div><div id="37031292" class="c"><input type="checkbox" id="c-37031292" checked=""/><div class="controls bullet"><span class="by">constantcrying</span><span>|</span><a href="#37029314">parent</a><span>|</span><a href="#37029373">prev</a><span>|</span><a href="#37029555">next</a><span>|</span><label class="collapse" for="c-37031292">[-]</label><label class="expand" for="c-37031292">[1 more]</label></div><br/><div class="children"><div class="content">All of the flaws of floating point numbers are the <i>mathematical</i> results of its requirements. You have a <i>fixed size</i> datatype which almost always behaves like the real numbers.<p>Floats can be fixed just as much free energy can be invented.</div><br/></div></div><div id="37029555" class="c"><input type="checkbox" id="c-37029555" checked=""/><div class="controls bullet"><span class="by">dikei</span><span>|</span><a href="#37029314">parent</a><span>|</span><a href="#37031292">prev</a><span>|</span><a href="#37029334">next</a><span>|</span><label class="collapse" for="c-37029555">[-]</label><label class="expand" for="c-37029555">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sorry, but what&#x27;s hard to say about &quot;all floating point arithmetic operations can contain errors&quot;. It&#x27;s such a simple statement, that every developers learn in CS 101, that you don&#x27;t even need to understand the reason to remember.</div><br/></div></div><div id="37029901" class="c"><input type="checkbox" id="c-37029901" checked=""/><div class="controls bullet"><span class="by">drivebycomment</span><span>|</span><a href="#37029314">parent</a><span>|</span><a href="#37029334">prev</a><span>|</span><a href="#37028334">next</a><span>|</span><label class="collapse" for="c-37029901">[-]</label><label class="expand" for="c-37029901">[1 more]</label></div><br/><div class="children"><div class="content">So, what do you think is the fix &#x2F; &quot;correct&quot; &#x2F; &quot;right&quot; ?</div><br/></div></div></div></div><div id="37028334" class="c"><input type="checkbox" id="c-37028334" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#37029314">prev</a><span>|</span><label class="collapse" for="c-37028334">[-]</label><label class="expand" for="c-37028334">[19 more]</label></div><br/><div class="children"><div class="content">For general purpose computing I consider floats with base-2 exponents harmful and that&#x27;s worse than the little things Java does wrong.</div><br/><div id="37028638" class="c"><input type="checkbox" id="c-37028638" checked=""/><div class="controls bullet"><span class="by">db48x</span><span>|</span><a href="#37028334">parent</a><span>|</span><a href="#37029401">next</a><span>|</span><label class="collapse" for="c-37028638">[-]</label><label class="expand" for="c-37028638">[2 more]</label></div><br/><div class="children"><div class="content">IEEE 754 defines decimal floats in addition to binary, but you’ve never used them because no x86 processor has provided hardware implementations of them.</div><br/><div id="37029231" class="c"><input type="checkbox" id="c-37029231" checked=""/><div class="controls bullet"><span class="by">yoz</span><span>|</span><a href="#37028334">root</a><span>|</span><a href="#37028638">parent</a><span>|</span><a href="#37029401">next</a><span>|</span><label class="collapse" for="c-37029231">[-]</label><label class="expand" for="c-37029231">[1 more]</label></div><br/><div class="children"><div class="content">And I always thought that IEEE 754 was the problem. Thank you for opening my eyes!</div><br/></div></div></div></div><div id="37029401" class="c"><input type="checkbox" id="c-37029401" checked=""/><div class="controls bullet"><span class="by">FabHK</span><span>|</span><a href="#37028334">parent</a><span>|</span><a href="#37028638">prev</a><span>|</span><a href="#37031217">next</a><span>|</span><label class="collapse" for="c-37029401">[-]</label><label class="expand" for="c-37029401">[15 more]</label></div><br/><div class="children"><div class="content">For general purpose computing (approximating real quantities) floats with base-2 exponents are just right on base-2 computers. For dealing with money (and other quantities that are fundamentally integer), they might be the wrong choice, but that&#x27;s well understood and sort of obvious (use integers to handle integers).</div><br/><div id="37029814" class="c"><input type="checkbox" id="c-37029814" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#37028334">root</a><span>|</span><a href="#37029401">parent</a><span>|</span><a href="#37031217">next</a><span>|</span><label class="collapse" for="c-37029814">[-]</label><label class="expand" for="c-37029814">[14 more]</label></div><br/><div class="children"><div class="content">I disagree.<p>There are many non-professional programmers who get baffled by various &quot;computerisms&quot; such as<p><pre><code>  0.1 + 0.2 != 0.3
</code></pre>
Excel tries to hide this but ends up doing even stranger things if you push it hard enough.  I think a lot of people who could use computers to put their skills on wheels just give up because of this &quot;lack of empathy&quot; that manifests here and in other places.  If you do<p><pre><code>  0.1 + 0.2 - 0.3
</code></pre>
on a pocket calculator you get the right answer and you should get the same right answer in a Jupyter notebook.  The only person who should be exposed to the base 2 arithmetic of the computer is a professional programmer who knows assembly language.<p>There are numerous social consequences of this that are harmful such as the perception that computer programmers are &quot;grinds&quot; and &quot;nerds&quot; and the idea that &quot;idea people&quot; are more worthy than the people that execute,  etc.</div><br/><div id="37029918" class="c"><input type="checkbox" id="c-37029918" checked=""/><div class="controls bullet"><span class="by">moonchild</span><span>|</span><a href="#37028334">root</a><span>|</span><a href="#37029814">parent</a><span>|</span><a href="#37031254">next</a><span>|</span><label class="collapse" for="c-37029918">[-]</label><label class="expand" for="c-37029918">[7 more]</label></div><br/><div class="children"><div class="content">If somebody does not understand the implications of a computation such as a floating-point 0.1 + 0.2, they should not be using floating-point.  It&#x27;s not the job of the language to protect them from that.  Decimal floating-point will be prone to very similar malfeasances, if that is what you are proposing; somebody unaware of the issues of binary floating point will not be helped by decimal floating point.<p>I do think it would be a good idea for programming languages to expose more exact number representations (for example, rational numbers, which are supported by some programming languages).  But numbers are complicated, and you will never be able to imbue a computer with a number type that always behaves exactly the way that someone who knows nothing of computers would naively expect.  Even mathematica does not quite manage it, and mathematica takes some somewhat extreme measures which would not be considered acceptable in many other general-purpose languages.</div><br/><div id="37030515" class="c"><input type="checkbox" id="c-37030515" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37028334">root</a><span>|</span><a href="#37029918">parent</a><span>|</span><a href="#37030704">next</a><span>|</span><label class="collapse" for="c-37030515">[-]</label><label class="expand" for="c-37030515">[3 more]</label></div><br/><div class="children"><div class="content">&gt; If somebody does not understand the implications of a computation such as a floating-point 0.1 + 0.2, they should not be using floating-point. It&#x27;s not the job of the language to protect them from that.<p>Then what is the job of the language? Programming languages should nudge their users in the right direction; they should be safe and maintainable by default. Sometimes sharp-edged parts are necessary (e.g. for performance) and they should be made available to those who need them, but they shouldn&#x27;t be front and center. E.g. floating point literals should be a high&#x2F;arbitrary precision decimal type by default, similar to what Python does with integer literals.<p>&gt; Decimal floating-point will be prone to very similar malfeasances, if that is what you are proposing; somebody unaware of the issues of binary floating point will not be helped by decimal floating point.<p>Disagree. Decimal calculations getting rounded off is a problem that is a lot easier to see and understand.</div><br/><div id="37031527" class="c"><input type="checkbox" id="c-37031527" checked=""/><div class="controls bullet"><span class="by">moonchild</span><span>|</span><a href="#37028334">root</a><span>|</span><a href="#37030515">parent</a><span>|</span><a href="#37030704">next</a><span>|</span><label class="collapse" for="c-37031527">[-]</label><label class="expand" for="c-37031527">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Decimal calculations getting rounded off is a problem that is a lot easier to see and understand.<p>If you carefully, tediously work by hand some calculations such as addition, multiplication, or division (but not, say, square roots, exponentials, or sines, since there are no generally known methods for computing those by hand), you may be able to replicate some specific results of the computer without needing to learn anything new.  I don&#x27;t really see what the point of doing that would be.  Oh, and you must use banker&#x27;s rounding, which is also not generally done.  Otherwise, the results will appear to manifest as just some inaccuracy incurred after every operation, just the same as with binary floating point.  The full complexity of error analysis remains.<p>(Note also in particular that addition, multiplication, and division are closed over the rationals, which can be readily represented exactly by computer—I did mention I think rationals are a good thing.)</div><br/><div id="37031979" class="c"><input type="checkbox" id="c-37031979" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37028334">root</a><span>|</span><a href="#37031527">parent</a><span>|</span><a href="#37030704">next</a><span>|</span><label class="collapse" for="c-37031979">[-]</label><label class="expand" for="c-37031979">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you carefully, tediously work by hand some calculations such as addition, multiplication, or division (but not, say, square roots, exponentials, or sines, since there are no generally known methods for computing those by hand), you may be able to replicate some specific results of the computer without needing to learn anything new.<p>Adding 0.1 and 0.2 to get 0.3 is hardly advanced mathematics.<p>&gt; Otherwise, the results will appear to manifest as just some inaccuracy incurred after every operation, just the same as with binary floating point.<p>Perhaps, but it will be a comprehensible inaccuracy. Running out of decimal places is a well-known and understood phenomenon, and something already experienced with regular calculators.</div><br/></div></div></div></div></div></div><div id="37030704" class="c"><input type="checkbox" id="c-37030704" checked=""/><div class="controls bullet"><span class="by">drekipus</span><span>|</span><a href="#37028334">root</a><span>|</span><a href="#37029918">parent</a><span>|</span><a href="#37030515">prev</a><span>|</span><a href="#37030608">next</a><span>|</span><label class="collapse" for="c-37030704">[-]</label><label class="expand" for="c-37030704">[2 more]</label></div><br/><div class="children"><div class="content">&gt;If somebody does not understand the implications of a computation such as a floating-point 0.1 + 0.2, they should not be using floating-point.<p>&quot;float&quot; is usually the second thing taught in the math tutorial, right after &quot;int&quot;, in many languages.<p>JavaScript and many other languages hide many things away and just call everything &quot;a number&quot; which is a float by disguise.<p>&quot;Decimal&quot; types are usually hidden in some standard library, and not as a first class primitive type of the language.<p>Stop victim blaming, that&#x27;s not going to get the discussion anywhere. You HAVE to acknowledge that the first option is non-obvious of its flaws.</div><br/></div></div><div id="37030608" class="c"><input type="checkbox" id="c-37030608" checked=""/><div class="controls bullet"><span class="by">heisenbit</span><span>|</span><a href="#37028334">root</a><span>|</span><a href="#37029918">parent</a><span>|</span><a href="#37030704">prev</a><span>|</span><a href="#37031254">next</a><span>|</span><label class="collapse" for="c-37030608">[-]</label><label class="expand" for="c-37030608">[1 more]</label></div><br/><div class="children"><div class="content">For better or worse Java is one of the major languages in the financial sector.</div><br/></div></div></div></div><div id="37031254" class="c"><input type="checkbox" id="c-37031254" checked=""/><div class="controls bullet"><span class="by">constantcrying</span><span>|</span><a href="#37028334">root</a><span>|</span><a href="#37029814">parent</a><span>|</span><a href="#37029918">prev</a><span>|</span><a href="#37029870">next</a><span>|</span><label class="collapse" for="c-37031254">[-]</label><label class="expand" for="c-37031254">[2 more]</label></div><br/><div class="children"><div class="content">That isn&#x27;t a computerism. It is a feature of floating point arithmetic. Computers are perfectly able to calculate perfectly.<p>&gt;should get the same right answer in a Jupyter notebook. The only person who should be exposed to the base 2<p>&quot;Why does my notebook take hours to do a simple task&quot;<p>&gt;There are numerous social consequences of this that are harmful such as the perception that computer programmers are &quot;grinds&quot; and &quot;nerds&quot; and the idea that &quot;idea people&quot; are more worthy than the people that execute, etc.<p>The benfits of floating point arithmetic easily outweigh people having to learn it.</div><br/><div id="37031557" class="c"><input type="checkbox" id="c-37031557" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#37028334">root</a><span>|</span><a href="#37031254">parent</a><span>|</span><a href="#37029870">next</a><span>|</span><label class="collapse" for="c-37031557">[-]</label><label class="expand" for="c-37031557">[1 more]</label></div><br/><div class="children"><div class="content"><i>&quot;Why does my notebook take hours to do a simple task&quot;</i><p>“Because the chip it is running on doesn’t have native base-10 math”?<p>See also “why my notebook [is fast but] yields incorrect results”.<p><i>The benfits of floating point arithmetic easily outweigh people having to learn it.</i><p>GP talks about saving non-low-level programmers from base 2 FP, not about removing it. CPUs could use an additional block (or mode) of base 10 exponent FP.<p>This and other geeky issues make programmers programmers instead of making everyone a programmer. The consequence of this is much heavier than any benefits of base 2 FP.</div><br/></div></div></div></div><div id="37029870" class="c"><input type="checkbox" id="c-37029870" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#37028334">root</a><span>|</span><a href="#37029814">parent</a><span>|</span><a href="#37031254">prev</a><span>|</span><a href="#37029847">next</a><span>|</span><label class="collapse" for="c-37029870">[-]</label><label class="expand" for="c-37029870">[1 more]</label></div><br/><div class="children"><div class="content">You are entirely right that user-facing programs should strive to hide IEEE 754 artifacts (see, for example, the Android calculator app that uses exact real arithmetic).<p>But if you are programming, there are tons of quote-unquote computerisms that we have for a good reason but are not really intuitive for newcomers. The whole concept of variables, pointers and general indirections, zero-based indexing, (pseudo)randomness, Unicode, time complexity, concurrency and parallelism and so on. Many (but not all, I admit) professional programmers take them as granted but they are just as arcane as the concept of base-2 floating points.</div><br/></div></div><div id="37029847" class="c"><input type="checkbox" id="c-37029847" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#37028334">root</a><span>|</span><a href="#37029814">parent</a><span>|</span><a href="#37029870">prev</a><span>|</span><a href="#37030546">next</a><span>|</span><label class="collapse" for="c-37029847">[-]</label><label class="expand" for="c-37029847">[1 more]</label></div><br/><div class="children"><div class="content">oh, i thought you meant base 2 as opposed to base 16 (like the 360)<p>there is a significant performance penalty for bcd arithmetic, so bcd floating point has never been attractive to the customers for floating point: cray buyers, fortran programmers, gamers, analog circuit designers, climatologists<p>those people don&#x27;t really care about the beginner issues you mention<p>if you&#x27;re willing to accept a performance penalty in exchange for easier learning, you can implement decimal arithmetic in software; many people have, and it&#x27;s in the cobol and sql standards and the python standard library.  the version i implemented in bubbleos is 83 lines of c, <a href="https:&#x2F;&#x2F;gitlab.com&#x2F;kragen&#x2F;bubbleos&#x2F;blob&#x2F;master&#x2F;yeso&#x2F;decimal.h" rel="nofollow noreferrer">https:&#x2F;&#x2F;gitlab.com&#x2F;kragen&#x2F;bubbleos&#x2F;blob&#x2F;master&#x2F;yeso&#x2F;decimal....</a> <a href="https:&#x2F;&#x2F;gitlab.com&#x2F;kragen&#x2F;bubbleos&#x2F;blob&#x2F;master&#x2F;yeso&#x2F;decimal.c" rel="nofollow noreferrer">https:&#x2F;&#x2F;gitlab.com&#x2F;kragen&#x2F;bubbleos&#x2F;blob&#x2F;master&#x2F;yeso&#x2F;decimal....</a> and compiles to about 1.3k of code<p>but a lot of us are using cpython in jupyter to prototype algorithms we want to run as fast as possible, so we want it to behave like the floating-point hardware does</div><br/></div></div><div id="37030546" class="c"><input type="checkbox" id="c-37030546" checked=""/><div class="controls bullet"><span class="by">eternityforest</span><span>|</span><a href="#37028334">root</a><span>|</span><a href="#37029814">parent</a><span>|</span><a href="#37029847">prev</a><span>|</span><a href="#37029921">next</a><span>|</span><label class="collapse" for="c-37030546">[-]</label><label class="expand" for="c-37030546">[1 more]</label></div><br/><div class="children"><div class="content">I just think of floats as fuzzy analog values.  The only precise operation you can do is copying.  Everything else, you assume it&#x27;s noisy.<p>It&#x27;s not real analog noise, but reasoning about rounding is hard if you&#x27;re not good at math, it&#x27;s something you can explain easily, and it prevents you from doing clever stuff that will confuse the next person.<p>It&#x27;s the opposite of being an idea person. I just accept them as a practical approximation, not a tool for doing real math, and move on.  If you come from electronics it makes perfect sense. Voltages are pretty much always noisy even if it&#x27;s picovolts.<p>If I need precision I use ints or dedicated libraries.</div><br/></div></div><div id="37029921" class="c"><input type="checkbox" id="c-37029921" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#37028334">root</a><span>|</span><a href="#37029814">parent</a><span>|</span><a href="#37030546">prev</a><span>|</span><a href="#37031217">next</a><span>|</span><label class="collapse" for="c-37029921">[-]</label><label class="expand" for="c-37029921">[1 more]</label></div><br/><div class="children"><div class="content">One option is to convert the world to base 16 arithmetic instead of 10.</div><br/></div></div></div></div></div></div><div id="37031217" class="c"><input type="checkbox" id="c-37031217" checked=""/><div class="controls bullet"><span class="by">constantcrying</span><span>|</span><a href="#37028334">parent</a><span>|</span><a href="#37029401">prev</a><span>|</span><label class="collapse" for="c-37031217">[-]</label><label class="expand" for="c-37031217">[1 more]</label></div><br/><div class="children"><div class="content">The floating point standard is <i>really</i> good at pretending to be real numbers on a computer.<p>Every problem is the mathematical consequence of its features.</div><br/></div></div></div></div></div></div></div></div></div></body></html>