<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1689670852196" as="style"/><link rel="stylesheet" href="styles.css?v=1689670852196"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://research.swtch.com/coro">Coroutines for Go</a> <span class="domain">(<a href="https://research.swtch.com">research.swtch.com</a>)</span></div><div class="subtext"><span>trulyrandom</span> | <span>152 comments</span></div><br/><div><div id="36763678" class="c"><input type="checkbox" id="c-36763678" checked=""/><div class="controls bullet"><span class="by">alphazard</span><span>|</span><a href="#36769614">next</a><span>|</span><label class="collapse" for="c-36763678">[-]</label><label class="expand" for="c-36763678">[32 more]</label></div><br/><div class="children"><div class="content">It looks like a lot of people are missing the point here.  Yes a coroutine library would be a worse&#x2F;more cumbersome way to do concurrency than the go keyword.<p>The use case motivating all the complexity is function iterators, where `range` can be used on functions of type `func() (T, bool)`.  That has been discussed in the Go community for a long time, and the semantics would be intuitive&#x2F;obvious to most Go programmers.<p>This post addresses the next thing: Assuming function iterators are added to the language, how do I write one of these iterators that I can use in a for loop?<p>It starts by noticing that it is often very easy to write push iterators, and builds up to a push-to-pull adapter.  It also includes a general purpose mechanism for coroutines, which the adapter is built on.<p>If all of this goes in, I think it will be bad practice to use coroutines for things other than iteration, just like it&#x27;s bad practice to use channels&#x2F;goroutines in places where a mutex would do.</div><br/><div id="36764227" class="c"><input type="checkbox" id="c-36764227" checked=""/><div class="controls bullet"><span class="by">eklitzke</span><span>|</span><a href="#36763678">parent</a><span>|</span><a href="#36768663">next</a><span>|</span><label class="collapse" for="c-36764227">[-]</label><label class="expand" for="c-36764227">[3 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s also worth mentioning that for certain specific use cases coroutines are much more efficient than a full goroutine, because switching to&#x2F;from a coroutine doesn&#x27;t require context switching or rescheduling anything. If you have two cooperating tasks that are logically synchronous anyway (e.g. an iterator) it&#x27;s much more efficient to just run everything on the same CPU because the kernel doesn&#x27;t have to reschedule anything or power down&#x2F;wake up CPU cores, and the data is in the right CPU caches, so you&#x27;ll get better cache latency and hit rates. With goroutines this <i>may</i> happen anyway, but it&#x27;s not guaranteed and at the minimum you have the overhead of going through the Go runtime goroutine scheduler which is fast, but not as fast as just executing a different code context in the same goroutine. Coroutines offer more predictable scheduling behavior because you know that task A is switching directly to task B, whereas otherwise the goroutine scheduler could switch to another available task that wants to run. The last section of the blog post goes into this, where Russ shows that an optimized runtime implementation of coroutines is 10x faster than emulating them with goroutines.<p>Google has internal kernel patches that implement cooperating multithreading this way (internally they&#x27;re called fibers), and the patches exist for precisely this reason: better latency and more predictable scheduling behavior. Paul Turner gave a presentation about this at LPC ~10 years ago that explains more about the motivation for the patches and why they improve efficiency: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=KXuZi9aeGTw">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=KXuZi9aeGTw</a></div><br/><div id="36767909" class="c"><input type="checkbox" id="c-36767909" checked=""/><div class="controls bullet"><span class="by">unscaled</span><span>|</span><a href="#36763678">root</a><span>|</span><a href="#36764227">parent</a><span>|</span><a href="#36768663">next</a><span>|</span><label class="collapse" for="c-36767909">[-]</label><label class="expand" for="c-36767909">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not just about performance, but also safety and ergonomics. Since true coroutines[1] offer predictable scheduling, their behavior with regards to data races and deadlocks is also more predictable.<p>If programmers try to manually implement iterators, generators and interleaved state machines with their own goroutines and channels, it&#x27;s not just performance that suffers - there is too much room for error.<p>[1] I&#x27;m using the qualifier &quot;true&quot; here, since many modern languages (such as Python, Kotlin) use the term &quot;coroutines&quot; for something that is more like Go&#x27;s Goroutines than Lua&#x27;s coroutines. Unlike Go, they are not preemptible, but they are (at least by default) implicitly resumed when necessary by some scheduler, and they may execute on different kernel threads and switch contexts.</div><br/><div id="36768088" class="c"><input type="checkbox" id="c-36768088" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#36763678">root</a><span>|</span><a href="#36767909">parent</a><span>|</span><a href="#36768663">next</a><span>|</span><label class="collapse" for="c-36768088">[-]</label><label class="expand" for="c-36768088">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m using the qualifier &quot;true&quot; here, since many modern languages (such as Python, Kotlin) use the term &quot;coroutines&quot; for something that is more like Go&#x27;s Goroutines than Lua&#x27;s coroutines.<p>Python has both true (ish) coroutines (or at least coroutines which are entirely user controllable), which it mostly uses for iteration, and the concurrency specialised “async”.<p>Initially the goal was to reuse “yield” for concurrency (a big reason why “yield from” was added), but the ergonomics of mixing multiple coroutines uses was found to be awful, at least for the langage python is, and trying to provide relevant sugar difficult.</div><br/></div></div></div></div></div></div><div id="36764011" class="c"><input type="checkbox" id="c-36764011" checked=""/><div class="controls bullet"><span class="by">rcme</span><span>|</span><a href="#36763678">parent</a><span>|</span><a href="#36768663">prev</a><span>|</span><a href="#36766742">next</a><span>|</span><label class="collapse" for="c-36764011">[-]</label><label class="expand" for="c-36764011">[21 more]</label></div><br/><div class="children"><div class="content">What is wrong with:<p><pre><code>    for {
        next := getNext()
        ...
    }
</code></pre>
What is the advantage of writing this as:<p><pre><code>    for next := range getNext {
        ...
    }</code></pre></div><br/><div id="36764231" class="c"><input type="checkbox" id="c-36764231" checked=""/><div class="controls bullet"><span class="by">alphazard</span><span>|</span><a href="#36763678">root</a><span>|</span><a href="#36764011">parent</a><span>|</span><a href="#36764735">next</a><span>|</span><label class="collapse" for="c-36764231">[-]</label><label class="expand" for="c-36764231">[10 more]</label></div><br/><div class="children"><div class="content">In practice the difference would be closer to:<p><pre><code>    getNext := iterableThing.Iterator()
    for {
        next, ok := getNext()
        if !ok {
            break
        }
        ...
    }
</code></pre>
vs.<p><pre><code>    for next := range iterableThing.Iterator() {
       ...
    }
</code></pre>
One advantage is that it&#x27;s slightly shorter, which matters for very common patterns--people complain about `err != nil` after all.  Another advantage is there isn&#x27;t another variable for everyone to name differently.  Another advantage is that everyone can&#x27;t do the control flow slightly differently either.</div><br/><div id="36766445" class="c"><input type="checkbox" id="c-36766445" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#36763678">root</a><span>|</span><a href="#36764231">parent</a><span>|</span><a href="#36765398">next</a><span>|</span><label class="collapse" for="c-36766445">[-]</label><label class="expand" for="c-36766445">[4 more]</label></div><br/><div class="children"><div class="content">Only newbies tend to complain about `err != nil` in my experience. After a certain point it just clicks and they get used to it. There&#x27;s a cadence to Go code (do the thing, check the error, do the thing, check the error) that is easy to read once you&#x27;re used to it, but looks horribly verbose when you&#x27;re coming from an exceptions-based language.<p>Go has simplicity as a design goal. Part of that simplicity is not adding all the features we can think of to the language. Just because it would provide slightly leaner syntax for a relatively small group of use cases isn&#x27;t a good reason to add new language features (imho, from my 10+ years using Go and watching it evolve).<p>If we can implement this using current language features, but it&#x27;s complex and messy to implement, then it&#x27;s a great case for a new library, possibly even inclusion in the standard library. If we can&#x27;t implement this at all using current language features, then maybe it&#x27;s a case for a new language feature to enable this. If we can implement it relatively cleanly using current language features, then we&#x27;re good and don&#x27;t need to do anything. This seems like a &quot;can implement, but not very cleanly&quot; case, which would be a great justification for a library, but not a language feature. Again, imho.</div><br/><div id="36769312" class="c"><input type="checkbox" id="c-36769312" checked=""/><div class="controls bullet"><span class="by">jwestbury</span><span>|</span><a href="#36763678">root</a><span>|</span><a href="#36766445">parent</a><span>|</span><a href="#36766765">next</a><span>|</span><label class="collapse" for="c-36769312">[-]</label><label class="expand" for="c-36769312">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m <i>used to</i> `err != nil`, but it doesn&#x27;t mean I <i>like</i> it. It&#x27;s a lot of what amounts to boilerplate in a language that is mercifully short of boilerplate elsewhere. This is doubly true when you want custom error types, and need to start unpacking values from your custom error struct.</div><br/></div></div><div id="36766765" class="c"><input type="checkbox" id="c-36766765" checked=""/><div class="controls bullet"><span class="by">hgsgm</span><span>|</span><a href="#36763678">root</a><span>|</span><a href="#36766445">parent</a><span>|</span><a href="#36769312">prev</a><span>|</span><a href="#36765398">next</a><span>|</span><label class="collapse" for="c-36766765">[-]</label><label class="expand" for="c-36766765">[2 more]</label></div><br/><div class="children"><div class="content">&gt;This seems like a &quot;can implement, but not very cleanly&quot; case, which would be a great justification for a library, but not a language feature.<p>First sentence of OP:<p>&gt; This post is about why we need a coroutine package for Go<p>Then in the girst section after the intro:<p>&gt; Later, I will argue for an optimized implementation provided directly by the runtime, but that implementation should be indistinguishable from the pure Go definition.</div><br/><div id="36767697" class="c"><input type="checkbox" id="c-36767697" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#36763678">root</a><span>|</span><a href="#36766765">parent</a><span>|</span><a href="#36765398">next</a><span>|</span><label class="collapse" for="c-36767697">[-]</label><label class="expand" for="c-36767697">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, so I&#x27;m agreeing that this would be a great library, but disagreeing that it should be a language feature. Sorry if I didn&#x27;t make that clear.</div><br/></div></div></div></div></div></div><div id="36765398" class="c"><input type="checkbox" id="c-36765398" checked=""/><div class="controls bullet"><span class="by">tmpz22</span><span>|</span><a href="#36763678">root</a><span>|</span><a href="#36764231">parent</a><span>|</span><a href="#36766445">prev</a><span>|</span><a href="#36765701">next</a><span>|</span><label class="collapse" for="c-36765398">[-]</label><label class="expand" for="c-36765398">[2 more]</label></div><br/><div class="children"><div class="content">&gt; complain about `err != nil` after all<p>Not to nitpick this specifically but as a generic reminder not all complaints are worthy of shifting the trajectory of a massively popular programming language.<p>Balancing &quot;worthy&quot; and &quot;unworthy&quot; changes is really hard both in the community and discussions like this one. I don&#x27;t envy the teams that have to do it.</div><br/><div id="36768534" class="c"><input type="checkbox" id="c-36768534" checked=""/><div class="controls bullet"><span class="by">bombolo</span><span>|</span><a href="#36763678">root</a><span>|</span><a href="#36765398">parent</a><span>|</span><a href="#36765701">next</a><span>|</span><label class="collapse" for="c-36768534">[-]</label><label class="expand" for="c-36768534">[1 more]</label></div><br/><div class="children"><div class="content">Not forcing to check errors is akin to what you do in C, and even there compilers complain about this.</div><br/></div></div></div></div><div id="36765701" class="c"><input type="checkbox" id="c-36765701" checked=""/><div class="controls bullet"><span class="by">Kamq</span><span>|</span><a href="#36763678">root</a><span>|</span><a href="#36764231">parent</a><span>|</span><a href="#36765398">prev</a><span>|</span><a href="#36768700">next</a><span>|</span><label class="collapse" for="c-36765701">[-]</label><label class="expand" for="c-36765701">[1 more]</label></div><br/><div class="children"><div class="content">I think more idiomatic go for the first case would be:<p><pre><code>    getNext := iterableThing.Iterator()
    for next, ok := getNext(); ok; next, ok = getNext() {
        ...
    }
</code></pre>
Which, yeah, the range cleans it up a bit, but it&#x27;s not doing quite as much work as you&#x27;re implying.</div><br/></div></div><div id="36765458" class="c"><input type="checkbox" id="c-36765458" checked=""/><div class="controls bullet"><span class="by">JyB</span><span>|</span><a href="#36763678">root</a><span>|</span><a href="#36764231">parent</a><span>|</span><a href="#36768700">prev</a><span>|</span><a href="#36764735">next</a><span>|</span><label class="collapse" for="c-36765458">[-]</label><label class="expand" for="c-36765458">[1 more]</label></div><br/><div class="children"><div class="content">The err!=nil is exactly what you don’t want to mention and the perfect example why you shouldn’t listen to all the close-minded takes some people might have.</div><br/></div></div></div></div><div id="36764735" class="c"><input type="checkbox" id="c-36764735" checked=""/><div class="controls bullet"><span class="by">aaronbee</span><span>|</span><a href="#36763678">root</a><span>|</span><a href="#36764011">parent</a><span>|</span><a href="#36764231">prev</a><span>|</span><a href="#36764836">next</a><span>|</span><label class="collapse" for="c-36764735">[-]</label><label class="expand" for="c-36764735">[1 more]</label></div><br/><div class="children"><div class="content">Your code is an example of a &quot;pull iterator&quot;, and it&#x27;s not as much of a concern.<p>The harder case to deal with is a &quot;push iterator&quot;, which are often much simpler to implement, but less flexible to use. See <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;discussions&#x2F;56413">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;discussions&#x2F;56413</a><p>The OP is about converting a push iterator into a pull iterator efficiently by using coroutines. This provides the best of both worlds, simple iterator implementation and flexible use by its caller.</div><br/></div></div><div id="36764836" class="c"><input type="checkbox" id="c-36764836" checked=""/><div class="controls bullet"><span class="by">starttoaster</span><span>|</span><a href="#36763678">root</a><span>|</span><a href="#36764011">parent</a><span>|</span><a href="#36764735">prev</a><span>|</span><a href="#36764577">next</a><span>|</span><label class="collapse" for="c-36764836">[-]</label><label class="expand" for="c-36764836">[1 more]</label></div><br/><div class="children"><div class="content">Besides what everyone else said, the obvious advantage is the latter builds in the logic for exiting the loop once getNext has run out of elements in the slice&#x2F;map. Your former example will need a final step that&#x27;s like:<p><pre><code>    ...
    if getNext() == nil {
      break
    }
    ...
</code></pre>
This isn&#x27;t a huge boon, and is mostly a matter of style. But I prefer the latter because it&#x27;s logic that gets handled with the range builtin, so my code can be more about application logic, rather than muddling in breaking out of loop logic.</div><br/></div></div><div id="36764577" class="c"><input type="checkbox" id="c-36764577" checked=""/><div class="controls bullet"><span class="by">rakoo</span><span>|</span><a href="#36763678">root</a><span>|</span><a href="#36764011">parent</a><span>|</span><a href="#36764836">prev</a><span>|</span><a href="#36767735">next</a><span>|</span><label class="collapse" for="c-36764577">[-]</label><label class="expand" for="c-36764577">[1 more]</label></div><br/><div class="children"><div class="content">None of the proposals submit your idea of writing things differently. The article proposes an implementation that is fully doable and usable with current spec and no breaking changes.<p>The point of coroutines is that they are little contexts that serve to be called<p>- many times<p>- sometimes with different parameters<p>- change state<p>- might be interrupted by callers<p>- might interrupt callers themselves<p>All of this can be done by other means. Just like any sorting can be done by copy pasting the same code, but generics make it less tedious. That&#x27;s the same idea here. Some problems can be implemented as interleaving coroutines, and their definition is simple enough that you want to write it all in the body of some CreateCoroutine() function instead of taking out another struct with 5 almost empty functions. It will not solve all problems, but can more clearly separate business logic and orchestration.</div><br/></div></div><div id="36767735" class="c"><input type="checkbox" id="c-36767735" checked=""/><div class="controls bullet"><span class="by">ben0x539</span><span>|</span><a href="#36763678">root</a><span>|</span><a href="#36764011">parent</a><span>|</span><a href="#36764577">prev</a><span>|</span><a href="#36764047">next</a><span>|</span><label class="collapse" for="c-36767735">[-]</label><label class="expand" for="c-36767735">[3 more]</label></div><br/><div class="children"><div class="content">Well, what was wrong with:<p><pre><code>    for {
        next := &lt;-channel
        ...
    }</code></pre></div><br/><div id="36767880" class="c"><input type="checkbox" id="c-36767880" checked=""/><div class="controls bullet"><span class="by">Mawr</span><span>|</span><a href="#36763678">root</a><span>|</span><a href="#36767735">parent</a><span>|</span><a href="#36764047">next</a><span>|</span><label class="collapse" for="c-36767880">[-]</label><label class="expand" for="c-36767880">[2 more]</label></div><br/><div class="children"><div class="content">Horrible overhead. If the loop does something simple, like summing integers, 99% of time will be spent switching between goroutines.<p>From TFA:<p>&quot;Because scheduling is explicit (without any preemption) and done entirely without the operating system, a coroutine switch takes at most around ten nanoseconds, usually even less. Startup and teardown is also much cheaper than threads.&quot;<p>&quot;For this taxonomy, Go&#x27;s goroutines are cheap threads: a goroutine switch is closer to a few hundred nanoseconds&quot;<p>Also check out <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29510751">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29510751</a><p>and <a href="https:&#x2F;&#x2F;ewencp.org&#x2F;blog&#x2F;golang-iterators&#x2F;index.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;ewencp.org&#x2F;blog&#x2F;golang-iterators&#x2F;index.html</a>:<p>&quot;Finally, the most natural channel based implementation is… slow. By a factor of nearly 50x. Buffering does help though, reducing that to a factor of 25x.&quot;</div><br/><div id="36768027" class="c"><input type="checkbox" id="c-36768027" checked=""/><div class="controls bullet"><span class="by">unscaled</span><span>|</span><a href="#36763678">root</a><span>|</span><a href="#36767880">parent</a><span>|</span><a href="#36764047">next</a><span>|</span><label class="collapse" for="c-36768027">[-]</label><label class="expand" for="c-36768027">[1 more]</label></div><br/><div class="children"><div class="content">And even if it&#x27;s a toy program and you don&#x27;t care about performance, it&#x27;s not as simple as just:<p><pre><code>    for {
        next := &lt;-channel
        ...
    }

</code></pre>
You have to set up the channel and the goroutine that feeds it, you need to safely close the channel when the iteration is done (but not before, unless you like panics), you need to deal with panics inside the goroutine and possibly support cancellation if the iteration breaks early (unless you love memory leaks).<p>If you try to implement this pattern by hand, you are all too likely to make fatal mistake, and this is doubly true in the hands of an inexperienced programmer.<p>I appreciate the fact that Russ wrote this long post, gradually implementing `coro.New()` and improving its functionality and safety — and only in the very end, we get a short paragraph about performance. Good performance is important to make this feature attractive to use, but if the feature is clunky and error-prone, it wouldn&#x27;t be worth much, even with great performance.</div><br/></div></div></div></div></div></div><div id="36764047" class="c"><input type="checkbox" id="c-36764047" checked=""/><div class="controls bullet"><span class="by">bouk</span><span>|</span><a href="#36763678">root</a><span>|</span><a href="#36764011">parent</a><span>|</span><a href="#36767735">prev</a><span>|</span><a href="#36766742">next</a><span>|</span><label class="collapse" for="c-36764047">[-]</label><label class="expand" for="c-36764047">[4 more]</label></div><br/><div class="children"><div class="content">The first doesn&#x27;t do control flow</div><br/><div id="36764081" class="c"><input type="checkbox" id="c-36764081" checked=""/><div class="controls bullet"><span class="by">rcme</span><span>|</span><a href="#36763678">root</a><span>|</span><a href="#36764047">parent</a><span>|</span><a href="#36766742">next</a><span>|</span><label class="collapse" for="c-36764081">[-]</label><label class="expand" for="c-36764081">[3 more]</label></div><br/><div class="children"><div class="content">Depends how getNext is defined.</div><br/><div id="36764260" class="c"><input type="checkbox" id="c-36764260" checked=""/><div class="controls bullet"><span class="by">alphazard</span><span>|</span><a href="#36763678">root</a><span>|</span><a href="#36764081">parent</a><span>|</span><a href="#36764294">next</a><span>|</span><label class="collapse" for="c-36764260">[-]</label><label class="expand" for="c-36764260">[1 more]</label></div><br/><div class="children"><div class="content">The only way to do control flow in getNext, consistent with how you partially defined it, is to panic.  That means there is some important code wrapping the whole loop body that you left out.</div><br/></div></div><div id="36764294" class="c"><input type="checkbox" id="c-36764294" checked=""/><div class="controls bullet"><span class="by">zeroxfe</span><span>|</span><a href="#36763678">root</a><span>|</span><a href="#36764081">parent</a><span>|</span><a href="#36764260">prev</a><span>|</span><a href="#36766742">next</a><span>|</span><label class="collapse" for="c-36764294">[-]</label><label class="expand" for="c-36764294">[1 more]</label></div><br/><div class="children"><div class="content">That doesn&#x27;t make sense. `getNext()` has no ability to break out of the loop.</div><br/></div></div></div></div></div></div></div></div><div id="36766742" class="c"><input type="checkbox" id="c-36766742" checked=""/><div class="controls bullet"><span class="by">AYBABTME</span><span>|</span><a href="#36763678">parent</a><span>|</span><a href="#36764011">prev</a><span>|</span><a href="#36764005">next</a><span>|</span><label class="collapse" for="c-36766742">[-]</label><label class="expand" for="c-36766742">[2 more]</label></div><br/><div class="children"><div class="content">I think coroutines in Go will make it possible to use Go as a host for clean definition of discrete element simulations. Without it, yielding to an actor is clunky.</div><br/></div></div><div id="36764005" class="c"><input type="checkbox" id="c-36764005" checked=""/><div class="controls bullet"><span class="by">djha-skin</span><span>|</span><a href="#36763678">parent</a><span>|</span><a href="#36766742">prev</a><span>|</span><a href="#36769614">next</a><span>|</span><label class="collapse" for="c-36764005">[-]</label><label class="expand" for="c-36764005">[4 more]</label></div><br/><div class="children"><div class="content">Still a kitchen sink move, though, isn&#x27;t it?<p>Like, no careful thinking and good 80&#x2F;20 solution this time. Just &quot;huh, we&#x27;d need coroutines to do this `right` so let&#x27;s just do that&quot;<p>When they added generics, they <i>really</i>, <i>really</i> thought long and hard, and came up with a <i>compromise</i> that was brilliant and innovative in the balance it struck.<p>I would have hoped to see something like that here, like &quot;we&#x27;re adding this one feature to goroutines to have control in specific situations&quot; feels like something that would be better than &quot;we&#x27;re going full Rust on this problem and just adding it.&quot;</div><br/><div id="36764127" class="c"><input type="checkbox" id="c-36764127" checked=""/><div class="controls bullet"><span class="by">morelisp</span><span>|</span><a href="#36763678">root</a><span>|</span><a href="#36764005">parent</a><span>|</span><a href="#36769614">next</a><span>|</span><label class="collapse" for="c-36764127">[-]</label><label class="expand" for="c-36764127">[3 more]</label></div><br/><div class="children"><div class="content">This has been under discussion for a long time.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;43557">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;43557</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;discussions&#x2F;56413">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;discussions&#x2F;56413</a><p>I&#x27;m not sure Russ&#x27;s personal blog is any kind of official statement &quot;this is what we&#x27;re doing&quot; yet?</div><br/><div id="36765462" class="c"><input type="checkbox" id="c-36765462" checked=""/><div class="controls bullet"><span class="by">chrsig</span><span>|</span><a href="#36763678">root</a><span>|</span><a href="#36764127">parent</a><span>|</span><a href="#36769614">next</a><span>|</span><label class="collapse" for="c-36765462">[-]</label><label class="expand" for="c-36765462">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m not sure Russ&#x27;s personal blog is any kind of official statement &quot;this is what we&#x27;re doing&quot; yet?<p>I&#x27;ve found it&#x27;s generally a <i>very</i> strong indicator.<p>But to your point, this isn&#x27;t a new issue, there&#x27;s been a good amount of discussion around it over the years.</div><br/><div id="36766992" class="c"><input type="checkbox" id="c-36766992" checked=""/><div class="controls bullet"><span class="by">earthboundkid</span><span>|</span><a href="#36763678">root</a><span>|</span><a href="#36765462">parent</a><span>|</span><a href="#36769614">next</a><span>|</span><label class="collapse" for="c-36766992">[-]</label><label class="expand" for="c-36766992">[1 more]</label></div><br/><div class="children"><div class="content">In the old discussion, I specifically complained about how it would add back door coroutines to Go via iterators, and now Russ has a post about formalizing the concept of a coroutine, while also keeping the optimization of coroutines as a runtime implementation detail. I feel vindicated. :-)<p><a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;discussions&#x2F;56413#discussioncomment-4052481">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;discussions&#x2F;56413#discussioncom...</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="36769614" class="c"><input type="checkbox" id="c-36769614" checked=""/><div class="controls bullet"><span class="by">FZambia</span><span>|</span><a href="#36763678">prev</a><span>|</span><a href="#36763477">next</a><span>|</span><label class="collapse" for="c-36769614">[-]</label><label class="expand" for="c-36769614">[1 more]</label></div><br/><div class="children"><div class="content">Wondering whether coroutines may be a step towards async event-based style APIs without allocating read buffers for the entire connection. I.e. a solution to problems discussed in <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;15735">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;15735</a>. Goroutines provide a great way to have non-blocking IO with synchronous code – but when it comes to effective memory management with many connections Go community tend to invent raw epoll implementations: <a href="https:&#x2F;&#x2F;www.freecodecamp.org&#x2F;news&#x2F;million-websockets-and-go-cc58418460bb&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.freecodecamp.org&#x2F;news&#x2F;million-websockets-and-go-...</a>. So my question here – can coroutines somehow bring new possibilities in terms of working with network connections?</div><br/></div></div><div id="36763477" class="c"><input type="checkbox" id="c-36763477" checked=""/><div class="controls bullet"><span class="by">Zach_the_Lizard</span><span>|</span><a href="#36769614">prev</a><span>|</span><a href="#36765758">next</a><span>|</span><label class="collapse" for="c-36763477">[-]</label><label class="expand" for="c-36763477">[13 more]</label></div><br/><div class="children"><div class="content">I have written Go professionally for many years now and don&#x27;t want to see it become something like the Python Twisted &#x2F; Tornado &#x2F; whatever frameworks.<p>The go keyword nicely prevents the annoying function coloring problem, which causes quite a bit of pain.<p>Sometimes in high performance contexts I&#x27;d like to be able to do something like e.g. per CPU core data sharding, but this proposal doesn&#x27;t scratch those kinds of itches.</div><br/><div id="36764361" class="c"><input type="checkbox" id="c-36764361" checked=""/><div class="controls bullet"><span class="by">talideon</span><span>|</span><a href="#36763477">parent</a><span>|</span><a href="#36764608">next</a><span>|</span><label class="collapse" for="c-36764361">[-]</label><label class="expand" for="c-36764361">[3 more]</label></div><br/><div class="children"><div class="content">Coroutines and goroutines fill different niches. The latter already fill the niche the likes of Twisted fill. There&#x27;s nothing here trying to pull anything akin to async&#x2F;await into Go.<p>Coroutines will fill a different nice more akin to Python&#x27;s generators. There are a whole bunch of places where this could dramatically cut down on memory usage and code complexity where you have a composable pipeline of components you need to glue together. The design appears to me to be entirely synchronous.</div><br/><div id="36765486" class="c"><input type="checkbox" id="c-36765486" checked=""/><div class="controls bullet"><span class="by">JyB</span><span>|</span><a href="#36763477">root</a><span>|</span><a href="#36764361">parent</a><span>|</span><a href="#36768743">prev</a><span>|</span><a href="#36764608">next</a><span>|</span><label class="collapse" for="c-36765486">[-]</label><label class="expand" for="c-36765486">[1 more]</label></div><br/><div class="children"><div class="content">For sure cut down code complexity for the single clever code writer who wanted to be fancy. Not so sure about all the readers that will come afterwards.</div><br/></div></div></div></div><div id="36764608" class="c"><input type="checkbox" id="c-36764608" checked=""/><div class="controls bullet"><span class="by">rakoo</span><span>|</span><a href="#36763477">parent</a><span>|</span><a href="#36764361">prev</a><span>|</span><a href="#36764133">next</a><span>|</span><label class="collapse" for="c-36764608">[-]</label><label class="expand" for="c-36764608">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The go keyword nicely prevents the annoying function coloring problem, which causes quite a bit of pain.<p>The good thing is, nothing in the post even proposes anything that might fall in the function coloring problem.</div><br/></div></div><div id="36764133" class="c"><input type="checkbox" id="c-36764133" checked=""/><div class="controls bullet"><span class="by">GaryNumanVevo</span><span>|</span><a href="#36763477">parent</a><span>|</span><a href="#36764608">prev</a><span>|</span><a href="#36765301">next</a><span>|</span><label class="collapse" for="c-36764133">[-]</label><label class="expand" for="c-36764133">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The go keyword nicely prevents the annoying function coloring problem<p>FYI when you write a goroutine and have to use Context, that&#x27;s literally just function coloring</div><br/><div id="36765756" class="c"><input type="checkbox" id="c-36765756" checked=""/><div class="controls bullet"><span class="by">Kamq</span><span>|</span><a href="#36763477">root</a><span>|</span><a href="#36764133">parent</a><span>|</span><a href="#36764212">next</a><span>|</span><label class="collapse" for="c-36765756">[-]</label><label class="expand" for="c-36765756">[1 more]</label></div><br/><div class="children"><div class="content">Is it really? &gt;90% of the time, I&#x27;m just passing a context so that I can cancel the rest of the goroutines if an early one fails and I don&#x27;t need to do the rest of the computation.<p>That works just fine with throwing a context.Background in, which should be available anywhere, and not color the function.</div><br/></div></div><div id="36764212" class="c"><input type="checkbox" id="c-36764212" checked=""/><div class="controls bullet"><span class="by">morelisp</span><span>|</span><a href="#36763477">root</a><span>|</span><a href="#36764133">parent</a><span>|</span><a href="#36765756">prev</a><span>|</span><a href="#36765301">next</a><span>|</span><label class="collapse" for="c-36764212">[-]</label><label class="expand" for="c-36764212">[2 more]</label></div><br/><div class="children"><div class="content">Ad absurdum, then anything other than full curried 1-ary-exclusive functions is coloring.<p>You can easily bridge context-using and non-context-using code, you can have nested contexts, you can have multiple unrelated contexts, you can ignore the context, probably most critically <i>you can&#x27;t pass values back up the context</i>, I don&#x27;t see any way these look like function coloring.</div><br/><div id="36764261" class="c"><input type="checkbox" id="c-36764261" checked=""/><div class="controls bullet"><span class="by">mcronce</span><span>|</span><a href="#36763477">root</a><span>|</span><a href="#36764212">parent</a><span>|</span><a href="#36765301">next</a><span>|</span><label class="collapse" for="c-36764261">[-]</label><label class="expand" for="c-36764261">[1 more]</label></div><br/><div class="children"><div class="content">Not sure about in Python, but in Rust, you can easily bridge sync and async code.  The function coloring problem is, at least in that case, grossly overstated.</div><br/></div></div></div></div></div></div><div id="36765301" class="c"><input type="checkbox" id="c-36765301" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#36763477">parent</a><span>|</span><a href="#36764133">prev</a><span>|</span><a href="#36764110">next</a><span>|</span><label class="collapse" for="c-36765301">[-]</label><label class="expand" for="c-36765301">[1 more]</label></div><br/><div class="children"><div class="content">Arguably the &quot;problem&quot; with other async&#x2F;threading frameworks is that they build threading <i>on top of</i> iterators&#x2F;coroutines.  In this case they would be orthogonal, so it&#x27;s probably not as bad as you think, though almost certainly some clever developer out there will do something stupid with it that will also get very popular (my bet would be abstracting goroutines and coroutines into a single thing)</div><br/></div></div><div id="36764110" class="c"><input type="checkbox" id="c-36764110" checked=""/><div class="controls bullet"><span class="by">cookiengineer</span><span>|</span><a href="#36763477">parent</a><span>|</span><a href="#36765301">prev</a><span>|</span><a href="#36764703">next</a><span>|</span><label class="collapse" for="c-36764110">[-]</label><label class="expand" for="c-36764110">[2 more]</label></div><br/><div class="children"><div class="content">Can you maybe share hints to better channel management patterns&#x2F;frameworks?<p>Usually my goroutines related code feels like a mess because of them, and I don&#x27;t know how to make them &quot;more clean&quot; (whatever that means). Any hints proven to be maintainable patterns would be highly appreciated.</div><br/><div id="36767117" class="c"><input type="checkbox" id="c-36767117" checked=""/><div class="controls bullet"><span class="by">Zach_the_Lizard</span><span>|</span><a href="#36763477">root</a><span>|</span><a href="#36764110">parent</a><span>|</span><a href="#36764703">next</a><span>|</span><label class="collapse" for="c-36767117">[-]</label><label class="expand" for="c-36767117">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t always use channels in the code I write.<p>For example, let&#x27;s say I have []foo as input and I&#x27;m going to call a service on every element of the slice.<p>You could do it with channels, but oftentimes I&#x27;ll reach for creating a slice of results and passing each goroutine an index into the slice. That way I can avoid any overhead that comes from having what is effectively a queue with a lock.<p>It depends on what I&#x27;m doing, how I want to treat failures of a single goroutine, etc. of course.<p>I default to never returning channels unless it&#x27;s a requirement for the use case (e.g. context.Done() returns a channel so callers can listen for when the context is closed).<p>Callers can always create goroutines to make your code run concurrently. It&#x27;s more annoying to erase channels when they aren&#x27;t useful to the caller (e.g. if you made all functions that make HTTP calls return a channel because you assume callers want a new goroutine, but I already have my own goroutine per request)<p>Beyond that, some specific examples would be helpful so I can tailor my advice</div><br/></div></div></div></div><div id="36764703" class="c"><input type="checkbox" id="c-36764703" checked=""/><div class="controls bullet"><span class="by">valenterry</span><span>|</span><a href="#36763477">parent</a><span>|</span><a href="#36764110">prev</a><span>|</span><a href="#36765758">next</a><span>|</span><label class="collapse" for="c-36764703">[-]</label><label class="expand" for="c-36764703">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t worry, it will get even worse, because its foundations are worse than pythons - and it also has less flexibility because it&#x27;s not interpreted. Like it or not, it&#x27;s going to happen. I also predicted that generics would be added to Go and folks here laughed about it. :)</div><br/></div></div></div></div><div id="36765758" class="c"><input type="checkbox" id="c-36765758" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#36763477">prev</a><span>|</span><a href="#36768637">next</a><span>|</span><label class="collapse" for="c-36765758">[-]</label><label class="expand" for="c-36765758">[4 more]</label></div><br/><div class="children"><div class="content">Multitasking systems gave us processes.<p>But those were too much.<p>So we got threads, which are processes that share an address space, file table, and some other things. The scheduler can switch from one to the other more easily than between processes, and data can be shared between threads without needing serialization.<p>But those were too much.<p>So we got user space threads, which are logical threads of execution that are driven by a runtime entirely in user space. The runtime adds scheduling hooks into all I&#x2F;O functions in the standard library, or even uses a system API like Unix signals to preempt logical threads. No system-level context switching is needed. User space threads can be tiny.<p>But those were too much.<p>So we got coroutines, which allow a programmer to define logical &quot;threads&quot; of execution that cooperatively interact with each other. There is no assumption about the presence of a scheduler. The programmer either writes their own event loop or invokes one from a library in a &quot;real&quot; logical thread.<p>I wonder what comes next. As far as [communicating sequential processes][1] are concerned, maybe cooperative coroutines are a low as you can go.<p>[1]: <a href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~crary&#x2F;819-f09&#x2F;Hoare78.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~crary&#x2F;819-f09&#x2F;Hoare78.pdf</a></div><br/><div id="36769329" class="c"><input type="checkbox" id="c-36769329" checked=""/><div class="controls bullet"><span class="by">nasretdinov</span><span>|</span><a href="#36765758">parent</a><span>|</span><a href="#36768760">next</a><span>|</span><label class="collapse" for="c-36769329">[-]</label><label class="expand" for="c-36769329">[1 more]</label></div><br/><div class="children"><div class="content">Even coroutines can&#x27;t save us programmers from the dread of having to explain every little possible detail to the computer, in a way that doesn&#x27;t take forever to execute if you provide input that is even slighly different from what the programmer had in mind</div><br/></div></div><div id="36768760" class="c"><input type="checkbox" id="c-36768760" checked=""/><div class="controls bullet"><span class="by">deepsun</span><span>|</span><a href="#36765758">parent</a><span>|</span><a href="#36769329">prev</a><span>|</span><a href="#36767054">next</a><span>|</span><label class="collapse" for="c-36768760">[-]</label><label class="expand" for="c-36768760">[1 more]</label></div><br/><div class="children"><div class="content">Imagining next step could be something like: &quot;process this collection of task-items as you wish&quot;. If you squint, any concurrent execution can be viewed as sequence of tasks (which can also be collections), even if there is only one or two of them.</div><br/></div></div><div id="36767054" class="c"><input type="checkbox" id="c-36767054" checked=""/><div class="controls bullet"><span class="by">earthboundkid</span><span>|</span><a href="#36765758">parent</a><span>|</span><a href="#36768760">prev</a><span>|</span><a href="#36768637">next</a><span>|</span><label class="collapse" for="c-36767054">[-]</label><label class="expand" for="c-36767054">[1 more]</label></div><br/><div class="children"><div class="content">I don’t think there’s any further down to go, but there’s probably room to go up to distributed computing. IIRC, some early versions of Go when it was in alpha had channels work across machines.</div><br/></div></div></div></div><div id="36768637" class="c"><input type="checkbox" id="c-36768637" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36765758">prev</a><span>|</span><a href="#36763393">next</a><span>|</span><label class="collapse" for="c-36768637">[-]</label><label class="expand" for="c-36768637">[1 more]</label></div><br/><div class="children"><div class="content">I guess it is great that they are finally paying attentio to programming languages like CLU.<p>On the other side, given my experience with .NET and C++ co-routines, and Active Objects (in Symbian C++ and Active Oberon) not sure if this is really something to add to Go.<p>Even the .NET team has acknowledged at this year&#x27;s BUILD, that if they could go back in time having the runtime handle them Go-style would probably been a better decision, given how many developers keep having issues understanding async&#x2F;await.</div><br/></div></div><div id="36763393" class="c"><input type="checkbox" id="c-36763393" checked=""/><div class="controls bullet"><span class="by">djha-skin</span><span>|</span><a href="#36768637">prev</a><span>|</span><a href="#36765188">next</a><span>|</span><label class="collapse" for="c-36763393">[-]</label><label class="expand" for="c-36763393">[10 more]</label></div><br/><div class="children"><div class="content">I thought that <i>the entire point</i> of green threads was so that I didn&#x27;t <i>have</i> to use something like Python&#x27;s `yield` keyword to get nice, cooperative-style scheduling.<p>I thought go&#x27;s `insert resumes at call points and other specific places` design decision was a very nice compromise.<p>This is allowing access to more and more of the metal. At what point are we just recreating Zig here? What&#x27;s next? An <i>optional</i> garbage collector?</div><br/><div id="36763513" class="c"><input type="checkbox" id="c-36763513" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#36763393">parent</a><span>|</span><a href="#36763457">next</a><span>|</span><label class="collapse" for="c-36763513">[-]</label><label class="expand" for="c-36763513">[1 more]</label></div><br/><div class="children"><div class="content">yield and resume here aren&#x27;t keywords, they&#x27;re regular variables (referencing regular closures) given those names purely for pedagogical purposes.<p>The only odd thing here is the creation and use of a cancel callback. I&#x27;ve not done much Go programming, so I don&#x27;t know whether this is just a performance improvement to more quickly collect dropped iterator state, or it&#x27;s a requirement because Go does not garbage collect goroutines waiting on channels for which the waiting goroutine has the only reference. In Lua you wouldn&#x27;t need such a thing because coroutines&#x2F;threads are GC&#x27;d like any other object--once all references are gone they&#x27;re GC&#x27;d even if the last operation was a yield and not a return from the entry function.</div><br/></div></div><div id="36763457" class="c"><input type="checkbox" id="c-36763457" checked=""/><div class="controls bullet"><span class="by">vaastav</span><span>|</span><a href="#36763393">parent</a><span>|</span><a href="#36763513">prev</a><span>|</span><a href="#36765188">next</a><span>|</span><label class="collapse" for="c-36763457">[-]</label><label class="expand" for="c-36763457">[8 more]</label></div><br/><div class="children"><div class="content">Garbage collector in Go is optional. You can switch off garbage collection by setting the environment variable GOGC=off.<p>More info about GOGC: <a href="https:&#x2F;&#x2F;dave.cheney.net&#x2F;tag&#x2F;gogc" rel="nofollow noreferrer">https:&#x2F;&#x2F;dave.cheney.net&#x2F;tag&#x2F;gogc</a></div><br/><div id="36764771" class="c"><input type="checkbox" id="c-36764771" checked=""/><div class="controls bullet"><span class="by">t8sr</span><span>|</span><a href="#36763393">root</a><span>|</span><a href="#36763457">parent</a><span>|</span><a href="#36763515">next</a><span>|</span><label class="collapse" for="c-36764771">[-]</label><label class="expand" for="c-36764771">[1 more]</label></div><br/><div class="children"><div class="content">Only very theoretically - in Go, you don&#x27;t control whether memory goes on your stack or the heap, and heap escape analysis is notoriously unpredictable. There is no explicit free. You would have to write Go in a completely crazy way to be able to turn off the GC and have the program not grow unbounded.<p>You might think &quot;I&#x27;ll just use static buffers everywhere&quot;, but allocations can occur in unexpected places. The compiler does some very basic lifetime analysis to eliminate some obvious cases (loops...), but it&#x27;s really hard to avoid in general.</div><br/></div></div><div id="36763515" class="c"><input type="checkbox" id="c-36763515" checked=""/><div class="controls bullet"><span class="by">gkfasdfasdf</span><span>|</span><a href="#36763393">root</a><span>|</span><a href="#36763457">parent</a><span>|</span><a href="#36764771">prev</a><span>|</span><a href="#36768650">next</a><span>|</span><label class="collapse" for="c-36763515">[-]</label><label class="expand" for="c-36763515">[5 more]</label></div><br/><div class="children"><div class="content">Ok so garbage collection is optional, how about garbage generation? Is there any way to manually clean up resources if GOCG=off, or will memory usage continue to grow unbounded as new objects are created?</div><br/><div id="36763565" class="c"><input type="checkbox" id="c-36763565" checked=""/><div class="controls bullet"><span class="by">vaastav</span><span>|</span><a href="#36763393">root</a><span>|</span><a href="#36763515">parent</a><span>|</span><a href="#36763859">next</a><span>|</span><label class="collapse" for="c-36763565">[-]</label><label class="expand" for="c-36763565">[1 more]</label></div><br/><div class="children"><div class="content">Grows unbounded. I wasn&#x27;t recommending that one should set GOGC=off. Just making a remark that one could should they choose to do so.<p>EDIT: Sorry, I misunderstood part of your question. The memory grows unbounded unless you call runtime.GC() which triggers garbage collection. But this is a blocking call and essentially block your whole program.</div><br/></div></div><div id="36763859" class="c"><input type="checkbox" id="c-36763859" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#36763393">root</a><span>|</span><a href="#36763515">parent</a><span>|</span><a href="#36763565">prev</a><span>|</span><a href="#36768650">next</a><span>|</span><label class="collapse" for="c-36763859">[-]</label><label class="expand" for="c-36763859">[3 more]</label></div><br/><div class="children"><div class="content">I think in theory you can write code (or do some tricks) to avoid all heap allocation.</div><br/><div id="36764785" class="c"><input type="checkbox" id="c-36764785" checked=""/><div class="controls bullet"><span class="by">t8sr</span><span>|</span><a href="#36763393">root</a><span>|</span><a href="#36763859">parent</a><span>|</span><a href="#36764726">next</a><span>|</span><label class="collapse" for="c-36764785">[-]</label><label class="expand" for="c-36764785">[1 more]</label></div><br/><div class="children"><div class="content">&quot;In theory&quot; being the operative words there. Turn on heap escape analysis sometime, you&#x27;ll be surprised how hard it is to avoid.</div><br/></div></div><div id="36764726" class="c"><input type="checkbox" id="c-36764726" checked=""/><div class="controls bullet"><span class="by">dgb23</span><span>|</span><a href="#36763393">root</a><span>|</span><a href="#36763859">parent</a><span>|</span><a href="#36764785">prev</a><span>|</span><a href="#36768650">next</a><span>|</span><label class="collapse" for="c-36764726">[-]</label><label class="expand" for="c-36764726">[1 more]</label></div><br/><div class="children"><div class="content">You mean not growing the heap or literally no allocation?</div><br/></div></div></div></div></div></div><div id="36768650" class="c"><input type="checkbox" id="c-36768650" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#36763393">root</a><span>|</span><a href="#36763457">parent</a><span>|</span><a href="#36763515">prev</a><span>|</span><a href="#36765188">next</a><span>|</span><label class="collapse" for="c-36768650">[-]</label><label class="expand" for="c-36768650">[1 more]</label></div><br/><div class="children"><div class="content">Well, then so is in Java, with the Epsillon “GC”. But not collecting garbage is very different than manual memory management.</div><br/></div></div></div></div></div></div><div id="36765188" class="c"><input type="checkbox" id="c-36765188" checked=""/><div class="controls bullet"><span class="by">chrsig</span><span>|</span><a href="#36763393">prev</a><span>|</span><a href="#36763312">next</a><span>|</span><label class="collapse" for="c-36765188">[-]</label><label class="expand" for="c-36765188">[11 more]</label></div><br/><div class="children"><div class="content">Coroutines are one thing that i&#x27;d probably prefer language support for rather than a library.<p><pre><code>    x := co func(){
        var z int
        for {
            z++
            yield z
        }
    }

    y := x()

    for y := range x {
        ...
    }

</code></pre>
or something to that effect.  It&#x27;s cool that it can be done at all in pure go, and I can see the appeal of having a  standard library package for it with an optimized runtime instead of complecting the language specification.  After all, if it&#x27;s possible to do in pure go, then other implementations can be quickly bootstrapped.<p>My $0.02, as someone that uses go at $work daily: I&#x27;d be happy to have either, but I&#x27;d prefer it baked into the language.  Go&#x27;s concurrency primitives have always been a strength, just lean into it.</div><br/><div id="36768585" class="c"><input type="checkbox" id="c-36768585" checked=""/><div class="controls bullet"><span class="by">uhura</span><span>|</span><a href="#36765188">parent</a><span>|</span><a href="#36766158">next</a><span>|</span><label class="collapse" for="c-36768585">[-]</label><label class="expand" for="c-36768585">[1 more]</label></div><br/><div class="children"><div class="content">I would prefer to add a `yield` param to functions so it can better interact with the current type system.<p>This means that for a function to yield, it needs to have the so called `yield` param and you can only yield inside a yield function functions with the same yield signature or does not contain a signature at all.<p>So the example would be rewritten into something like:<p><pre><code>  x := func(:z int) {
    for {
      z++
      :- z
    }
  }

  for y := range x() {
    ...
  }
</code></pre>
The : adds the yield signature and :&lt; yields the value.<p>Functions that only yield a value `X` would just have the `: X` or `: name X`.
To accept a value of type `Y` in the resume the signature would change to `:[Y] X` or `:[Y] name X`.<p>Accepting is weak, so if something expects a yielding function that resumes with Y and yield X, yielding functions that only yield X without a resume should also be accepted.<p>Consider the following code example:<p><pre><code>  func filter[T comparable](it func(:T), f func(T) bool, :T) {
    for v := range it {
      if f(v) { :- v }
    }
  }

  func map[T](arr []T, :T) {
    for _, v := range arr {
      :- v
    }
  }

  for v := range filter(map({1, 2, 3}), func(x) { return x &lt; 3 }) {
    print(v)
  }
</code></pre>
Special functions in a co package could give resume and New functionality to keep the go style.<p>A basic counter could be written like this:<p><pre><code>  func counter(:[bool]c int) {
    for {
      if ! :- c { break }
      c += 1
    }
  }
</code></pre>
A func that counts twice could be as simple as:<p><pre><code>  func countTwice(:[bool]c int) {
    count()
    count()
  }
</code></pre>
To interact with the resume value the range syntax could be expanded to something like:<p><pre><code>  for c := range count() {
    if c &gt; 10 { -: false }
    -: true
    print(c)
  }
</code></pre>
Range would resume with a default zero value if the range does not pass a value to -:.</div><br/></div></div><div id="36766158" class="c"><input type="checkbox" id="c-36766158" checked=""/><div class="controls bullet"><span class="by">MichaelMoser123</span><span>|</span><a href="#36765188">parent</a><span>|</span><a href="#36768585">prev</a><span>|</span><a href="#36765767">next</a><span>|</span><label class="collapse" for="c-36766158">[-]</label><label class="expand" for="c-36766158">[2 more]</label></div><br/><div class="children"><div class="content">you need language support for coroutines - what happens when the stack runs out in one of the coroutine? With a library solution you would have to kill the co-routine, or kill the program. If you want the stack to grow transparently, then that can only be done by the generated code, it has to watch stack usage and then grow the stack on demand (i think you have something like that with goroutines)<p>Well, maybe a library solution could possibly have a guard page at the end of the stack. When that one is reached, then you could try to grow the stack in an error handler. (but that would probably not work, if you have taken a pointer to some stack variable)</div><br/><div id="36766815" class="c"><input type="checkbox" id="c-36766815" checked=""/><div class="controls bullet"><span class="by">hgsgm</span><span>|</span><a href="#36765188">root</a><span>|</span><a href="#36766158">parent</a><span>|</span><a href="#36765767">next</a><span>|</span><label class="collapse" for="c-36766815">[-]</label><label class="expand" for="c-36766815">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need language support for coroutines if you have language support for relocatable&#x2F;chunkable stack, which Go has.</div><br/></div></div></div></div><div id="36765767" class="c"><input type="checkbox" id="c-36765767" checked=""/><div class="controls bullet"><span class="by">38</span><span>|</span><a href="#36765188">parent</a><span>|</span><a href="#36766158">prev</a><span>|</span><a href="#36763312">next</a><span>|</span><label class="collapse" for="c-36765767">[-]</label><label class="expand" for="c-36765767">[7 more]</label></div><br/><div class="children"><div class="content">wow that is horrible. none of that is intuitive, which is one of Go strength. you would need to specific learn the Go semantic of coroutine to have any chance of writing or even reading code like this.</div><br/><div id="36765970" class="c"><input type="checkbox" id="c-36765970" checked=""/><div class="controls bullet"><span class="by">sk0g</span><span>|</span><a href="#36765188">root</a><span>|</span><a href="#36765767">parent</a><span>|</span><a href="#36766306">next</a><span>|</span><label class="collapse" for="c-36765970">[-]</label><label class="expand" for="c-36765970">[4 more]</label></div><br/><div class="children"><div class="content">Goroutines and channels aren&#x27;t intuitive either. You learn them and become familiar with them over time, at which point they become intuitive __for you__.</div><br/><div id="36766248" class="c"><input type="checkbox" id="c-36766248" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#36765188">root</a><span>|</span><a href="#36765970">parent</a><span>|</span><a href="#36766160">next</a><span>|</span><label class="collapse" for="c-36766248">[-]</label><label class="expand" for="c-36766248">[2 more]</label></div><br/><div class="children"><div class="content">They&#x27;re totally intuitive if you were an Occam programmer.</div><br/><div id="36767460" class="c"><input type="checkbox" id="c-36767460" checked=""/><div class="controls bullet"><span class="by">sk0g</span><span>|</span><a href="#36765188">root</a><span>|</span><a href="#36766248">parent</a><span>|</span><a href="#36766160">next</a><span>|</span><label class="collapse" for="c-36767460">[-]</label><label class="expand" for="c-36767460">[1 more]</label></div><br/><div class="children"><div class="content">So it&#x27;s intuitive because you are familiar with those concepts. I don&#x27;t see how that goes against what I said.</div><br/></div></div></div></div><div id="36766160" class="c"><input type="checkbox" id="c-36766160" checked=""/><div class="controls bullet"><span class="by">38</span><span>|</span><a href="#36765188">root</a><span>|</span><a href="#36765970">parent</a><span>|</span><a href="#36766248">prev</a><span>|</span><a href="#36766306">next</a><span>|</span><label class="collapse" for="c-36766160">[-]</label><label class="expand" for="c-36766160">[1 more]</label></div><br/><div class="children"><div class="content">actually I get it now. the issue is that OP was giving TWO different examples of use, pulling a single value versus multiple. they should have clarified.</div><br/></div></div></div></div><div id="36766306" class="c"><input type="checkbox" id="c-36766306" checked=""/><div class="controls bullet"><span class="by">kissgyorgy</span><span>|</span><a href="#36765188">root</a><span>|</span><a href="#36765767">parent</a><span>|</span><a href="#36765970">prev</a><span>|</span><a href="#36766600">next</a><span>|</span><label class="collapse" for="c-36766306">[-]</label><label class="expand" for="c-36766306">[1 more]</label></div><br/><div class="children"><div class="content">Yes, you need to learn language features in order to use the language, shocker!</div><br/></div></div><div id="36766600" class="c"><input type="checkbox" id="c-36766600" checked=""/><div class="controls bullet"><span class="by">12345hn6789</span><span>|</span><a href="#36765188">root</a><span>|</span><a href="#36765767">parent</a><span>|</span><a href="#36766306">prev</a><span>|</span><a href="#36763312">next</a><span>|</span><label class="collapse" for="c-36766600">[-]</label><label class="expand" for="c-36766600">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve written go for a year or so. That looks close to go code I look at every day. I wouldn&#x27;t be surprised if it was in the language.</div><br/></div></div></div></div></div></div><div id="36763312" class="c"><input type="checkbox" id="c-36763312" checked=""/><div class="controls bullet"><span class="by">silisili</span><span>|</span><a href="#36765188">prev</a><span>|</span><a href="#36766196">next</a><span>|</span><label class="collapse" for="c-36763312">[-]</label><label class="expand" for="c-36763312">[9 more]</label></div><br/><div class="children"><div class="content">Not sure I&#x27;m a fan.  Looking through the examples, I feel like this makes the language much harder to read and follow, but maybe that&#x27;s just my own brain and biases.<p>Further, it doesn&#x27;t seem to me to allow you to do anything you can&#x27;t currently do with blocking channels and&#x2F;or state.</div><br/><div id="36767575" class="c"><input type="checkbox" id="c-36767575" checked=""/><div class="controls bullet"><span class="by">enneff</span><span>|</span><a href="#36763312">parent</a><span>|</span><a href="#36765530">next</a><span>|</span><label class="collapse" for="c-36767575">[-]</label><label class="expand" for="c-36767575">[3 more]</label></div><br/><div class="children"><div class="content">What language change are you talking about? This is just a proposed construct to regularise and make efficient something people already do (as you says with “state”).<p>I’ve used iterators similar to what’s described in this article to avoid allocations in critical code paths, but this would make those much less awkward to use (particularly with the upcoming range iterator language change).</div><br/><div id="36767926" class="c"><input type="checkbox" id="c-36767926" checked=""/><div class="controls bullet"><span class="by">silisili</span><span>|</span><a href="#36763312">root</a><span>|</span><a href="#36767575">parent</a><span>|</span><a href="#36765530">next</a><span>|</span><label class="collapse" for="c-36767926">[-]</label><label class="expand" for="c-36767926">[2 more]</label></div><br/><div class="children"><div class="content">Perhaps language change was bad wording, I guess I meant paradigm change encouraging?  Just look at this func signature and first line...<p>&gt; func Pull[V any](push func(yield func(V) bool)) (pull func() (V, bool), stop func()) {<p>&gt;    copush := func(more bool, yield func(V) bool) V {<p>The main power of Go to me was always quickly being able to read and understand code.  This type of coding has a lot of cognitive load to a reader, I feel.</div><br/><div id="36769286" class="c"><input type="checkbox" id="c-36769286" checked=""/><div class="controls bullet"><span class="by">enneff</span><span>|</span><a href="#36763312">root</a><span>|</span><a href="#36767926">parent</a><span>|</span><a href="#36765530">next</a><span>|</span><label class="collapse" for="c-36769286">[-]</label><label class="expand" for="c-36769286">[1 more]</label></div><br/><div class="children"><div class="content">The implementation of Pull may be a bit mysterious to the casual reader, but its usage seems clear enough to me from the function signature. Even without reading the docs I think it’s easy to guess what yield, pull, and stop should do (and how to implement yield). That’s what matters, imo.<p>Fwiw if you look at the source of some other idiomatic standard library functions you may find their implementation is of similar complexity. That’s the nature of good abstractions, though, they should make tricky things easy to use.</div><br/></div></div></div></div></div></div><div id="36765530" class="c"><input type="checkbox" id="c-36765530" checked=""/><div class="controls bullet"><span class="by">JyB</span><span>|</span><a href="#36763312">parent</a><span>|</span><a href="#36767575">prev</a><span>|</span><a href="#36766789">next</a><span>|</span><label class="collapse" for="c-36765530">[-]</label><label class="expand" for="c-36765530">[4 more]</label></div><br/><div class="children"><div class="content">You’re absolutely right. People advocating for it can’t seem to see beyond their nose.</div><br/><div id="36766271" class="c"><input type="checkbox" id="c-36766271" checked=""/><div class="controls bullet"><span class="by">slantedview</span><span>|</span><a href="#36763312">root</a><span>|</span><a href="#36765530">parent</a><span>|</span><a href="#36766798">next</a><span>|</span><label class="collapse" for="c-36766271">[-]</label><label class="expand" for="c-36766271">[2 more]</label></div><br/><div class="children"><div class="content">More likely they&#x27;re trying to solve real problems you just haven&#x27;t hit yet.</div><br/><div id="36767090" class="c"><input type="checkbox" id="c-36767090" checked=""/><div class="controls bullet"><span class="by">iends</span><span>|</span><a href="#36763312">root</a><span>|</span><a href="#36766271">parent</a><span>|</span><a href="#36766798">next</a><span>|</span><label class="collapse" for="c-36767090">[-]</label><label class="expand" for="c-36767090">[1 more]</label></div><br/><div class="children"><div class="content">The go team has explicitly said this is the past: “You just don’t understand because you’re not at Google’s scale.”</div><br/></div></div></div></div><div id="36766798" class="c"><input type="checkbox" id="c-36766798" checked=""/><div class="controls bullet"><span class="by">hgsgm</span><span>|</span><a href="#36763312">root</a><span>|</span><a href="#36765530">parent</a><span>|</span><a href="#36766271">prev</a><span>|</span><a href="#36766789">next</a><span>|</span><label class="collapse" for="c-36766798">[-]</label><label class="expand" for="c-36766798">[1 more]</label></div><br/><div class="children"><div class="content">Yes, the person who spent 15 years developing the Go language can&#x27;t see beyond his nose.</div><br/></div></div></div></div><div id="36766789" class="c"><input type="checkbox" id="c-36766789" checked=""/><div class="controls bullet"><span class="by">hgsgm</span><span>|</span><a href="#36763312">parent</a><span>|</span><a href="#36765530">prev</a><span>|</span><a href="#36766196">next</a><span>|</span><label class="collapse" for="c-36766789">[-]</label><label class="expand" for="c-36766789">[1 more]</label></div><br/><div class="children"><div class="content">A dozen different incompatible iterator implementations (the current stdlib) isn&#x27;t easier.<p>Channels are slow for no good reason when they aren&#x27;t wrapping blocking operations.</div><br/></div></div></div></div><div id="36766196" class="c"><input type="checkbox" id="c-36766196" checked=""/><div class="controls bullet"><span class="by">xpressvideoz</span><span>|</span><a href="#36763312">prev</a><span>|</span><a href="#36763440">next</a><span>|</span><label class="collapse" for="c-36766196">[-]</label><label class="expand" for="c-36766196">[6 more]</label></div><br/><div class="children"><div class="content">Reading the comments makes me feel bittersweet.<p>- Many people consider coroutines and green threads to be more or less the same thing, when they both have their pros and cons.<p>- The fact that the omission of iterators is even acceptable in the Go community saddens me. They seem to deliberately refuse any feature that might make the language even slightly more complex, in the name of simplicity. But hey, at least they retracted their opinion on generics.<p>I&#x27;m again reminded that Go is not my language.</div><br/><div id="36769061" class="c"><input type="checkbox" id="c-36769061" checked=""/><div class="controls bullet"><span class="by">usrbinbash</span><span>|</span><a href="#36766196">parent</a><span>|</span><a href="#36766707">next</a><span>|</span><label class="collapse" for="c-36769061">[-]</label><label class="expand" for="c-36769061">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But hey, at least they retracted their opinion on generics.<p>No, we really didn&#x27;t.<p>Generics were acceptable to the community only because they are fully backwards compatible with existing code, and can be safely ignored if you don&#x27;t need them.<p>Which, not at all surprising, is what most golang code still does. Because as it turns out, outside of &quot;collections&quot; of one sort or another, practical use cases for generics are not that easy to find. Most code written never gets to see more than one type to begin with, and more than 2 is already a stretch.<p>If anything, the addition of generics showcased to the larger community, how little many of the vaunted <i>features!!!!!</i> that people keep demanding and labeling as &quot;essential&quot; are actually needed for a widely accepted and excellent language.</div><br/></div></div><div id="36766707" class="c"><input type="checkbox" id="c-36766707" checked=""/><div class="controls bullet"><span class="by">38</span><span>|</span><a href="#36766196">parent</a><span>|</span><a href="#36769061">prev</a><span>|</span><a href="#36767099">next</a><span>|</span><label class="collapse" for="c-36766707">[-]</label><label class="expand" for="c-36766707">[1 more]</label></div><br/><div class="children"><div class="content">I use Go daily. honestly generics didn&#x27;t change my code much at all.<p>I use them now somewhat, but only because they offer slightly better sugar at the call site. at the definition site, they are just as ugly as you expect, granted the Go syntax is about the best I have seen from other languages. so in the end I think we really lost some simplicity in order to silence the whining about no generics. not a good tradeoff.</div><br/></div></div><div id="36767099" class="c"><input type="checkbox" id="c-36767099" checked=""/><div class="controls bullet"><span class="by">earthboundkid</span><span>|</span><a href="#36766196">parent</a><span>|</span><a href="#36766707">prev</a><span>|</span><a href="#36768570">next</a><span>|</span><label class="collapse" for="c-36767099">[-]</label><label class="expand" for="c-36767099">[2 more]</label></div><br/><div class="children"><div class="content">I wouldn’t confuse HN with “the Go community”. The head of the Go team wrote this post. Will the coro package proposed in the post be added exactly as written? Maybe, but probably not exactly as written. Will something like it be added? I would be willing to bet money on it, yes. How long will it take? I’d say at least a year (release in Go 1.23 in August of 2024), maybe a little longer. I don’t think it could be much shorter though.</div><br/></div></div><div id="36768570" class="c"><input type="checkbox" id="c-36768570" checked=""/><div class="controls bullet"><span class="by">dgb23</span><span>|</span><a href="#36766196">parent</a><span>|</span><a href="#36767099">prev</a><span>|</span><a href="#36763440">next</a><span>|</span><label class="collapse" for="c-36768570">[-]</label><label class="expand" for="c-36768570">[1 more]</label></div><br/><div class="children"><div class="content">I would have expected that the Go community welcomes a uniform interface for iteration.</div><br/></div></div></div></div><div id="36763440" class="c"><input type="checkbox" id="c-36763440" checked=""/><div class="controls bullet"><span class="by">vaastav</span><span>|</span><a href="#36766196">prev</a><span>|</span><a href="#36763748">next</a><span>|</span><label class="collapse" for="c-36763440">[-]</label><label class="expand" for="c-36763440">[24 more]</label></div><br/><div class="children"><div class="content">Not sure if this really is required. Most cases in Go are served well by GoRoutines and for yield&#x2F;resume semantics, 2 blocking channel are enough. This seems to add complexity for the sake of it and not sure it actually adds any new power to Go that already didn&#x27;t exist.</div><br/><div id="36763488" class="c"><input type="checkbox" id="c-36763488" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#36763440">parent</a><span>|</span><a href="#36766803">next</a><span>|</span><label class="collapse" for="c-36763488">[-]</label><label class="expand" for="c-36763488">[22 more]</label></div><br/><div class="children"><div class="content">Goroutines + channels add an enormous amount of overhead. Using them as iterators is basically insane.</div><br/><div id="36763505" class="c"><input type="checkbox" id="c-36763505" checked=""/><div class="controls bullet"><span class="by">rcme</span><span>|</span><a href="#36763440">root</a><span>|</span><a href="#36763488">parent</a><span>|</span><a href="#36763789">next</a><span>|</span><label class="collapse" for="c-36763505">[-]</label><label class="expand" for="c-36763505">[11 more]</label></div><br/><div class="children"><div class="content">Why? Channels are already iterable using the range keyword.<p><pre><code>    ch := make(chan int)
    go func() {
        for i := 0; i &lt; 100; i += 1 {
            ch &lt;- i
        }
        close(ch)
    }()

    for i := range ch {
        fmt.Println(i)
    }
</code></pre>
That is very simple.</div><br/><div id="36763584" class="c"><input type="checkbox" id="c-36763584" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#36763440">root</a><span>|</span><a href="#36763505">parent</a><span>|</span><a href="#36764831">next</a><span>|</span><label class="collapse" for="c-36763584">[-]</label><label class="expand" for="c-36763584">[5 more]</label></div><br/><div class="children"><div class="content">&quot;Enormous amount of overhead&quot; is the operative phrase. In general, you want your concurrency operations to be significantly smaller than the payload of the operation. In the case of using channels as iterators with goroutines behind them, it works fine for something like a web page scraper, where the act of fetching a web page is enormously larger than a goroutine switch, but as a generalized iteration mechanism it&#x27;s unusably expensive because a lot of iteration payloads are very small compared to a channel send.<p>I&#x27;ve encountered a lot of people who read that on &#x2F;r&#x2F;golang and then ask &quot;well why are send operations so expensive&quot;, and it&#x27;s not that. It&#x27;s that a lot of iteration operations are on the order of single-digit cycles and often very easy to pipeline or predict. No concurrency primitive can keep up with that. A given send operation is generally fairly cheap but there are enough other things that are still an order or two of magnitude cheaper than even the cheapest send operation that if you block all those super cheap operations on a send you&#x27;re looking at multiple factor of magnitude slowdowns. Such as you would experience with your code.</div><br/><div id="36765500" class="c"><input type="checkbox" id="c-36765500" checked=""/><div class="controls bullet"><span class="by">rcme</span><span>|</span><a href="#36763440">root</a><span>|</span><a href="#36763584">parent</a><span>|</span><a href="#36764831">next</a><span>|</span><label class="collapse" for="c-36765500">[-]</label><label class="expand" for="c-36765500">[4 more]</label></div><br/><div class="children"><div class="content">But if your iteration is so fast then you don’t need a channel at all. Just use a plain for loop.</div><br/><div id="36765757" class="c"><input type="checkbox" id="c-36765757" checked=""/><div class="controls bullet"><span class="by">zbentley</span><span>|</span><a href="#36763440">root</a><span>|</span><a href="#36765500">parent</a><span>|</span><a href="#36766171">next</a><span>|</span><label class="collapse" for="c-36765757">[-]</label><label class="expand" for="c-36765757">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that&#x27;s exactly what the article is about: how we can model &quot;plain for-loop&quot; levels of performance in the presence of complex (intricate state at multiple levels and high potential for nesting iterators) code that is supplying the loop(s)</div><br/></div></div><div id="36766171" class="c"><input type="checkbox" id="c-36766171" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#36763440">root</a><span>|</span><a href="#36765500">parent</a><span>|</span><a href="#36765757">prev</a><span>|</span><a href="#36764831">next</a><span>|</span><label class="collapse" for="c-36766171">[-]</label><label class="expand" for="c-36766171">[2 more]</label></div><br/><div class="children"><div class="content">How do you solve the tree fringe problem with a for loop?</div><br/><div id="36766264" class="c"><input type="checkbox" id="c-36766264" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#36763440">root</a><span>|</span><a href="#36766171">parent</a><span>|</span><a href="#36764831">next</a><span>|</span><label class="collapse" for="c-36766264">[-]</label><label class="expand" for="c-36766264">[1 more]</label></div><br/><div class="children"><div class="content">Since all recursive programs can be converted into iterative programs then you can &quot;simply&quot; (not always simple) convert recursive solutions like McCarthy&#x27;s Lisp solution to a loop: <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;action&#x2F;showFmPdf?doi=10.1145%2F1045283" rel="nofollow noreferrer">https:&#x2F;&#x2F;dl.acm.org&#x2F;action&#x2F;showFmPdf?doi=10.1145%2F1045283</a> (page 5)<p><pre><code>  (DE SAMEFRINGE (X Y)
         (OR (EQ X Y)
             (AND (NOT (ATOM X))
                  (NOT (ATOM Y))
                  (SAME (GOPHER X) (GOPHER Y)))))

  (DE SAME (X Y)
         (AND (EQ (CAR X) (CAR Y))
              (SAMEFRINGE (CDR X) (CDR Y))))

  (DE GOPHER (U)
         (COND ((ATOM (CAR U)) U)
               (T (GOPHER (CONS (CAAR U)
                                (CONS (CDAR U) (CDR U)))))))
</code></pre>
Coroutines are not necessary for solving that problem (though they do offer a neat solution to it).</div><br/></div></div></div></div></div></div></div></div><div id="36764831" class="c"><input type="checkbox" id="c-36764831" checked=""/><div class="controls bullet"><span class="by">t8sr</span><span>|</span><a href="#36763440">root</a><span>|</span><a href="#36763505">parent</a><span>|</span><a href="#36763584">prev</a><span>|</span><a href="#36763557">next</a><span>|</span><label class="collapse" for="c-36764831">[-]</label><label class="expand" for="c-36764831">[1 more]</label></div><br/><div class="children"><div class="content">Aside from the massive performance penalty, cache thrashing and context switching, this code will also leak a goroutine (and so, memory) if you don&#x27;t finish receiving from `ch`. It&#x27;s more brittle, longer to write, less local and in every other way worse than a for loop. Why would you ever do it?</div><br/></div></div><div id="36763557" class="c"><input type="checkbox" id="c-36763557" checked=""/><div class="controls bullet"><span class="by">freecodyx</span><span>|</span><a href="#36763440">root</a><span>|</span><a href="#36763505">parent</a><span>|</span><a href="#36764831">prev</a><span>|</span><a href="#36763789">next</a><span>|</span><label class="collapse" for="c-36763557">[-]</label><label class="expand" for="c-36763557">[4 more]</label></div><br/><div class="children"><div class="content">Race conditions. With coroutines you’re not supposed to deal with race. If i am understanding the motives</div><br/><div id="36763575" class="c"><input type="checkbox" id="c-36763575" checked=""/><div class="controls bullet"><span class="by">rcme</span><span>|</span><a href="#36763440">root</a><span>|</span><a href="#36763557">parent</a><span>|</span><a href="#36763789">next</a><span>|</span><label class="collapse" for="c-36763575">[-]</label><label class="expand" for="c-36763575">[3 more]</label></div><br/><div class="children"><div class="content">You can write to a channel concurrently.</div><br/><div id="36763679" class="c"><input type="checkbox" id="c-36763679" checked=""/><div class="controls bullet"><span class="by">ackfoobar</span><span>|</span><a href="#36763440">root</a><span>|</span><a href="#36763575">parent</a><span>|</span><a href="#36763840">next</a><span>|</span><label class="collapse" for="c-36763679">[-]</label><label class="expand" for="c-36763679">[1 more]</label></div><br/><div class="children"><div class="content">And to make the concurrency safe you have to pay the price of synchronization.<p><a href="https:&#x2F;&#x2F;go.dev&#x2F;tour&#x2F;concurrency&#x2F;8" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;tour&#x2F;concurrency&#x2F;8</a><p>In A Tour of Go, concurrency section, &quot;Equivalent Binary Trees&quot; is an example of paying the price when you don&#x27;t need it.</div><br/></div></div><div id="36763840" class="c"><input type="checkbox" id="c-36763840" checked=""/><div class="controls bullet"><span class="by">ikiris</span><span>|</span><a href="#36763440">root</a><span>|</span><a href="#36763575">parent</a><span>|</span><a href="#36763679">prev</a><span>|</span><a href="#36763789">next</a><span>|</span><label class="collapse" for="c-36763840">[-]</label><label class="expand" for="c-36763840">[1 more]</label></div><br/><div class="children"><div class="content">its not that you cant, it&#x27;s that its very expensive.</div><br/></div></div></div></div></div></div></div></div><div id="36763789" class="c"><input type="checkbox" id="c-36763789" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#36763440">root</a><span>|</span><a href="#36763488">parent</a><span>|</span><a href="#36763505">prev</a><span>|</span><a href="#36763533">next</a><span>|</span><label class="collapse" for="c-36763789">[-]</label><label class="expand" for="c-36763789">[3 more]</label></div><br/><div class="children"><div class="content">It’s not insane at all. How did you come to that conclusion?<p>* Mutex lock+unlock: 10ns<p>* Chan send buffered: 21ns<p>* Try send (select with default): 3.5ns<p>Missing from here is context switches.<p>In either case, the overhead is proportional to how fast each iteration is. I have channels of byte slices of 64k and the channel ops don’t even make a dent compared to other ops, like IO.<p>You should absolutely use channels if it’s the right tool for the job.<p>Fwiw, I wouldn’t use channels for “generators” like in the article. I believe they are trying to proof-of-concept a language feature they want. I have no particular opinion about that.</div><br/><div id="36763926" class="c"><input type="checkbox" id="c-36763926" checked=""/><div class="controls bullet"><span class="by">yakubin</span><span>|</span><a href="#36763440">root</a><span>|</span><a href="#36763789">parent</a><span>|</span><a href="#36763533">next</a><span>|</span><label class="collapse" for="c-36763926">[-]</label><label class="expand" for="c-36763926">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Missing from here is context switches.</i><p>Exactly. From <i>rsc</i>&#x27;s previous post[1]:<p><i>&gt; On my laptop, a C thread switch takes a few microseconds. A channel operation and goroutine switch is an order of magnitude cheaper: a couple hundred nanoseconds. An optimized coroutine system can reduce the cost to tens of nanoseconds or less.</i><p>[1]: &lt;<a href="https:&#x2F;&#x2F;research.swtch.com&#x2F;pcdata" rel="nofollow noreferrer">https:&#x2F;&#x2F;research.swtch.com&#x2F;pcdata</a>&gt;</div><br/><div id="36765531" class="c"><input type="checkbox" id="c-36765531" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#36763440">root</a><span>|</span><a href="#36763926">parent</a><span>|</span><a href="#36763533">next</a><span>|</span><label class="collapse" for="c-36765531">[-]</label><label class="expand" for="c-36765531">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I 100% understand wanting to optimize this for something like generators if we imagine them as first-class constructs. But they’re not at all a replacement for channels – they would be an addition, or specialization. I’ve never seen real world Go code that has needed it but maybe this will change with generics. It’s worth keeping an eye on, at least.<p>Channels otoh are very versatile: everything from spsc to mpmc with buffering and starvation protections, fast cancelation and notifications, etc etc. They’re not perfect, but it’s a helluva bang-for-the-buck for a single primitive. Literally all you have to do for performance is add buffering and coalesce “units of work”, and you’re good to go.</div><br/></div></div></div></div></div></div><div id="36763533" class="c"><input type="checkbox" id="c-36763533" checked=""/><div class="controls bullet"><span class="by">vaastav</span><span>|</span><a href="#36763440">root</a><span>|</span><a href="#36763488">parent</a><span>|</span><a href="#36763789">prev</a><span>|</span><a href="#36763850">next</a><span>|</span><label class="collapse" for="c-36763533">[-]</label><label class="expand" for="c-36763533">[6 more]</label></div><br/><div class="children"><div class="content">Sure but that&#x27;s what the implementation of the coro in this post uses under the hood. Not sure how this is any better wrt overheads.</div><br/><div id="36763580" class="c"><input type="checkbox" id="c-36763580" checked=""/><div class="controls bullet"><span class="by">geodel</span><span>|</span><a href="#36763440">root</a><span>|</span><a href="#36763533">parent</a><span>|</span><a href="#36763604">next</a><span>|</span><label class="collapse" for="c-36763580">[-]</label><label class="expand" for="c-36763580">[3 more]</label></div><br/><div class="children"><div class="content">Where did you get this &#x27;..it uses same under the hood&#x27;? The article clearly says:<p><i>..Next I added a direct coroutine switch to the runtime, avoiding channels entirely. That cuts the coroutine switch to three atomic compare-and-swaps (one in the coroutine data structure, one for the scheduler status of the blocking coroutine, and one for the scheduler status of the resuming coroutine), which I believe is optimal given the safety invariants that must be maintained. That implementation takes 20ns per switch, or 40ns per pulled value. This is about 10X faster than the original channel implementation. </i></div><br/><div id="36763649" class="c"><input type="checkbox" id="c-36763649" checked=""/><div class="controls bullet"><span class="by">vaastav</span><span>|</span><a href="#36763440">root</a><span>|</span><a href="#36763580">parent</a><span>|</span><a href="#36763604">next</a><span>|</span><label class="collapse" for="c-36763649">[-]</label><label class="expand" for="c-36763649">[2 more]</label></div><br/><div class="children"><div class="content">The runtime switch was buried in the last paragraph of the article. All of the code was using goroutines and channels....</div><br/><div id="36763707" class="c"><input type="checkbox" id="c-36763707" checked=""/><div class="controls bullet"><span class="by">geodel</span><span>|</span><a href="#36763440">root</a><span>|</span><a href="#36763649">parent</a><span>|</span><a href="#36763604">next</a><span>|</span><label class="collapse" for="c-36763707">[-]</label><label class="expand" for="c-36763707">[1 more]</label></div><br/><div class="children"><div class="content">It does mention in an earlier section:<p><i>... That means the definition of coroutines should be possible to implement and understand in terms of ordinary Go code. Later, I will argue for an optimized implementation provided directly by the runtime,..</i></div><br/></div></div></div></div></div></div><div id="36763604" class="c"><input type="checkbox" id="c-36763604" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#36763440">root</a><span>|</span><a href="#36763533">parent</a><span>|</span><a href="#36763580">prev</a><span>|</span><a href="#36763850">next</a><span>|</span><label class="collapse" for="c-36763604">[-]</label><label class="expand" for="c-36763604">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Not sure how this is any better wrt overheads.<p>At the end he implements an experimental runtime mechanism that permits a goroutine to explicitly switch execution to another goroutine rather than using the generic channel scheduling plumbing.</div><br/><div id="36763670" class="c"><input type="checkbox" id="c-36763670" checked=""/><div class="controls bullet"><span class="by">vaastav</span><span>|</span><a href="#36763440">root</a><span>|</span><a href="#36763604">parent</a><span>|</span><a href="#36763850">next</a><span>|</span><label class="collapse" for="c-36763670">[-]</label><label class="expand" for="c-36763670">[1 more]</label></div><br/><div class="children"><div class="content">Its in the last paragraph of the article...Very easy to miss given the code uses goroutines and channels.</div><br/></div></div></div></div></div></div><div id="36763850" class="c"><input type="checkbox" id="c-36763850" checked=""/><div class="controls bullet"><span class="by">ikiris</span><span>|</span><a href="#36763440">root</a><span>|</span><a href="#36763488">parent</a><span>|</span><a href="#36763533">prev</a><span>|</span><a href="#36766803">next</a><span>|</span><label class="collapse" for="c-36763850">[-]</label><label class="expand" for="c-36763850">[1 more]</label></div><br/><div class="children"><div class="content">see also <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;discussions&#x2F;54245">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;discussions&#x2F;54245</a></div><br/></div></div></div></div><div id="36766803" class="c"><input type="checkbox" id="c-36766803" checked=""/><div class="controls bullet"><span class="by">hgsgm</span><span>|</span><a href="#36763440">parent</a><span>|</span><a href="#36763488">prev</a><span>|</span><a href="#36763748">next</a><span>|</span><label class="collapse" for="c-36766803">[-]</label><label class="expand" for="c-36766803">[1 more]</label></div><br/><div class="children"><div class="content">This is covered in the article.</div><br/></div></div></div></div><div id="36763748" class="c"><input type="checkbox" id="c-36763748" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#36763440">prev</a><span>|</span><a href="#36764928">next</a><span>|</span><label class="collapse" for="c-36763748">[-]</label><label class="expand" for="c-36763748">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not 100% sure this is the case, but I believe the context of this goes something like this. As Go has added generics, there are proposals to add generic data structures like a Set. Generics solve almost every problem with that, but there is one conspicuous issue that remains for a data structure: You can iterate over a slice or a map with the &quot;range&quot; keyword, and that yields special iteration behavior, but there is no practical way to do that with a general data structure, if you consider constructing an intermediate map or slice to be an insufficient solution. Go is generally performance-sensitive enough that it is.<p>The natural solution to this is some sort of iterator, as in Python or other languages. (Contra frequent accusations to the contrary, the Go community is aware of other language&#x27;s efforts.)<p>So this has opened the can of worms of trying to create an iteration standard for Go.<p>Go has something that has almost all the semantics we want right now. You can also &quot;range&quot; over a channel. This consumes one value at a time from the channel and provides it to the iteration, exactly as you&#x27;d expect, and the iteration terminates when the channel is closed. It just has one problem, which is that it involves a full goroutine and a synchronized channel send operation for each loop of the iteration. As I said in another comment, if what is being iterated on is something huge like a full web page fetch, this is actually fine, but no concurrency primitive can keep up with the efficiency of incrementing an integer, a single instruction which may literally take an amortized fraction of a cycle on a modern processor. With generics you can even relatively implement filter, map, etc. on this iterator... but adding a goroutine and synchronized commit for each such element of a pipeline is just crazy.<p>I believe the underlying question in this post is, can we use standard Go mechanisms to implement the coroutines without creating a new language construct, then use the compiler under the hood to convert it to an efficient execution? Basically, can this problem be solved with compiler optimizations rather than a new language construct? From this point of view, the payload of this article is really only that very last paragraph; the entire rest of the article is just orientation. If so, then Go can have coroutine efficiency with the standard language constructs that already exist. Perhaps some code that is using this pattern goroutine already might speed up too &quot;for free&quot;.<p>The concerns people have about this complexifying Go, the entire point of this operation is to suck the entire problem into the compiler with 0 changes to the spec. Not complexifying Go with a formal iteration standard is the entire point of this operation. If one wishes to complain, the correct complaint is the exact opposite one, that Go is not &quot;simply&quot; &quot;just&quot; implementing iterators as a first class construct just like all the other languages.<p>Also, in the interests of not posting a full new post, note that in general I shy away from the term &quot;coroutine&quot; because a coroutine is what this article describes, exactly, and nothing less. To those posting &quot;isn&#x27;t a goroutine already a coroutine?&quot;, the answer is, no, and in fact almost nothing called a coroutine by programmers nowadays actually is. The term got simplified down to where it just means thread or generator as Python uses the term, depending on the programming community you&#x27;re looking at, but in that context we don&#x27;t need to use the term &quot;coroutine&quot; that way, because we already <i>have</i> the word &quot;thread&quot; or &quot;generator&quot;. This is what &quot;real&quot; coroutines are, and while I won&#x27;t grammatically proscribe to you what you can and can not say, I will reiterate that I <i>personally</i> tend to avoid the term because the conflation between the sloppy programmer use and the more precise academic&#x2F;compiler use is just confusing in almost all cases.</div><br/><div id="36764115" class="c"><input type="checkbox" id="c-36764115" checked=""/><div class="controls bullet"><span class="by">adrusi</span><span>|</span><a href="#36763748">parent</a><span>|</span><a href="#36764928">next</a><span>|</span><label class="collapse" for="c-36764115">[-]</label><label class="expand" for="c-36764115">[1 more]</label></div><br/><div class="children"><div class="content">A goroutine really is implemented as a coroutine though. It&#x27;s just that without this runtime optimization, there hasn&#x27;t been a way to interact with them without letting a multithreaded scheduler manage their execution.<p>I don&#x27;t remember where I came across this, but many years ago I saw python-style generators termed &quot;semi-coroutines&quot; which I&#x27;m a fan of. Python (frustratingly) doesn&#x27;t implement them this way, but the beauty of generators is that by limiting the scope where execution can be suspended to the highest-level stack frame, you can statically determine how much memory is needed for the (semi-)coroutine, so it doesn&#x27;t require a single allocation.<p>Zig takes that a step farther by considering recursive functions second-class, which lets the compiler keep track of the maximum stack depth of any function,  and thereby allow you to allocate a stack frame for any non-recursive function inside of another stack frame, enabling zero-allocation full coroutines, as long as the function isn&#x27;t recursive.<p>That would... probably be overkill for Go, since marginal allocations are very cheap, and you&#x27;re already paying the runtime cost for dynamic stack size, so the initial allocation can be tiny.<p>I would <i>love</i> to see full proper coroutine support make it to Go, freeing users of the overhead of the multithreaded scheduler on the occasions where coroutine patterns work best. I remember back in 2012 or so, looking at examples of Go code that showed off goroutine&#x27;s utility as control flow primitives even when parallelism wasn&#x27;t desired and being disappointed that those patterns would likely be rare on account of runtime overhead, and sure enough I hardly ever see them.</div><br/></div></div></div></div><div id="36764928" class="c"><input type="checkbox" id="c-36764928" checked=""/><div class="controls bullet"><span class="by">xwowsersx</span><span>|</span><a href="#36763748">prev</a><span>|</span><a href="#36763415">next</a><span>|</span><label class="collapse" for="c-36764928">[-]</label><label class="expand" for="c-36764928">[4 more]</label></div><br/><div class="children"><div class="content">Somewhat on topic given that OP brought up coroutines in Python: what resources have folks used to understand Python&#x27;s asyncio story in depth? I&#x27;m just now finally understanding how to use stuff, but it was through a combination of the official documentation, the books &quot;Using Asyncio in Python&quot; and &quot;Expert Python Programming&quot;, none of which were particularly good. Normally I&#x27;d rely just on the official docs, but the docs have created much confusion, it seems, because there&#x27;s a lot in them that are useful more so for library&#x2F;framework developers than for users. So, I&#x27;m just wondering if anyone has great resources for really gaining a strong understanding of Python&#x27;s asyncio or how else you might have gone about gaining proficiency to the point where you felt comfortable using asyncio in real projects.</div><br/><div id="36765812" class="c"><input type="checkbox" id="c-36765812" checked=""/><div class="controls bullet"><span class="by">dingxiong</span><span>|</span><a href="#36764928">parent</a><span>|</span><a href="#36764979">next</a><span>|</span><label class="collapse" for="c-36765812">[-]</label><label class="expand" for="c-36765812">[2 more]</label></div><br/><div class="children"><div class="content">This blog helps me a lot about the motivation and underlying mechanism of python  asyncio <a href="https:&#x2F;&#x2F;tenthousandmeters.com&#x2F;blog&#x2F;python-behind-the-scenes-12-how-asyncawait-works-in-python&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;tenthousandmeters.com&#x2F;blog&#x2F;python-behind-the-scenes-...</a></div><br/><div id="36766780" class="c"><input type="checkbox" id="c-36766780" checked=""/><div class="controls bullet"><span class="by">xwowsersx</span><span>|</span><a href="#36764928">root</a><span>|</span><a href="#36765812">parent</a><span>|</span><a href="#36764979">next</a><span>|</span><label class="collapse" for="c-36766780">[-]</label><label class="expand" for="c-36766780">[1 more]</label></div><br/><div class="children"><div class="content">Thanks a lot, I&#x27;ll check that out.</div><br/></div></div></div></div><div id="36764979" class="c"><input type="checkbox" id="c-36764979" checked=""/><div class="controls bullet"><span class="by">manifoldgeo</span><span>|</span><a href="#36764928">parent</a><span>|</span><a href="#36765812">prev</a><span>|</span><a href="#36763415">next</a><span>|</span><label class="collapse" for="c-36764979">[-]</label><label class="expand" for="c-36764979">[1 more]</label></div><br/><div class="children"><div class="content">I read the same books you did, and I was equally unsatisfied afterwards. The &quot;Using Asyncio in Python 3&quot; book was good enough to help me write some code that had to hit an API 400k times without blocking, but I never returned to asyncio after that.<p>Afterwards, I realized there was a package called aiohttp that I could&#x27;ve used, but too late.<p>I&#x27;ll be interested to see what other HN people have done.</div><br/></div></div></div></div><div id="36763415" class="c"><input type="checkbox" id="c-36763415" checked=""/><div class="controls bullet"><span class="by">HumblyTossed</span><span>|</span><a href="#36764928">prev</a><span>|</span><a href="#36767961">next</a><span>|</span><label class="collapse" for="c-36763415">[-]</label><label class="expand" for="c-36763415">[3 more]</label></div><br/><div class="children"><div class="content">what? I&#x27;m a Go newb, but isn&#x27;t this what goroutines and channels get you?</div><br/><div id="36763824" class="c"><input type="checkbox" id="c-36763824" checked=""/><div class="controls bullet"><span class="by">adrusi</span><span>|</span><a href="#36763415">parent</a><span>|</span><a href="#36768393">next</a><span>|</span><label class="collapse" for="c-36763824">[-]</label><label class="expand" for="c-36763824">[1 more]</label></div><br/><div class="children"><div class="content">This is an interface that can be implemented in terms of goroutines and channels, but can also be implemented with a lower-overhead scheduler tweak. The article shows how it could be implemented using goroutines and channels, and then reports the result of that implementation versus an optimized version that avoids synchronization overhead and scheduler latency which is unnecessary with this pattern.<p>Currently, you could use goroutines and channels to implement a nice way to provide general iteration support for user-defined data structures, but because of the overhead, people most often opt for clunkier solutions. This change would give us the best of both worlds.</div><br/></div></div><div id="36768393" class="c"><input type="checkbox" id="c-36768393" checked=""/><div class="controls bullet"><span class="by">EspressoGPT</span><span>|</span><a href="#36763415">parent</a><span>|</span><a href="#36763824">prev</a><span>|</span><a href="#36767961">next</a><span>|</span><label class="collapse" for="c-36768393">[-]</label><label class="expand" for="c-36768393">[1 more]</label></div><br/><div class="children"><div class="content">You can build this yourself using goroutines and channels, but adding &quot;native&quot; first-class support for this generator pattern would be easier to use and come with less overhead.</div><br/></div></div></div></div><div id="36767961" class="c"><input type="checkbox" id="c-36767961" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#36763415">prev</a><span>|</span><a href="#36763345">next</a><span>|</span><label class="collapse" for="c-36767961">[-]</label><label class="expand" for="c-36767961">[1 more]</label></div><br/><div class="children"><div class="content">This is a thoroughly interesting topic. Thanks for the article.<p>I haven&#x27;t thought much about iterators link to coroutines.<p>As a hobby, I am working to write about a dream programming language. I happen to be really interested in parallelism, asynchronous, coroutines, multithreading and concurrency.<p>I want:<p>* seamlessly switch between remote-thread coroutine, local thread coroutine.<p>* concurrency and parallelism and async to be easy to think about, reason about, read and program<p>* programs should be easy to parallelise and be async and concurrent<p>Go iterators seem to be local to a thread, but what if you want to distribute work across threads?<p>I&#x27;ve been thinking of scheduling recently.<p>Imagine you&#x27;re a search engine company and you want to index links between URLs. How would you solve this with coroutines?<p><pre><code>  task download-url
   for url in urls:
    download(url)

  task extract-links
   parsed = parse(document)
   return parsed

  task fetch-links
   for link in document.query(&quot;a&quot;)
    return link

  task save-data
   db.save(url, link)

</code></pre>
How would you do control flow and scheduling and parallelism and async efficiently with this code?<p>* `db.save()`, `download()` are IO intensive whereas `document.query(&quot;a&quot;)` and `parse` is CPU intensive.<p>* I want to handle plurality or multiple items trivially such as multiple URLs and multiple links.<p>* I want to keep IO and CPU in flight at all times.<p>I think I want this schedule:<p><a href="https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;1983701&#x2F;254083968-b46485c8-fe5f-43ea-b840-d0d63dab4a51.PNG" rel="nofollow noreferrer">https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;1983701&#x2F;254083968-...</a><p>I have a toy 1:M:L 1 scheduler thread:M kernel threads:N lightweight threads lightweight scheduler in C, Rust and Java<p><a href="https:&#x2F;&#x2F;github.com&#x2F;samsquire&#x2F;preemptible-thread">https:&#x2F;&#x2F;github.com&#x2F;samsquire&#x2F;preemptible-thread</a><p>This lets me switch between tasks and preempt them from user space without assistance at descheduling time.<p>I have a simplistic async&#x2F;await state machine thread pool in Java. My scheduling algorithm is very simple.<p>I want things like backpressure, circuit breakers, rate limiting, load shedding, rate adjustment, queuing.</div><br/></div></div><div id="36763345" class="c"><input type="checkbox" id="c-36763345" checked=""/><div class="controls bullet"><span class="by">RcouF1uZ4gsC</span><span>|</span><a href="#36767961">prev</a><span>|</span><a href="#36764681">next</a><span>|</span><label class="collapse" for="c-36763345">[-]</label><label class="expand" for="c-36763345">[4 more]</label></div><br/><div class="children"><div class="content">I don’t think Coroutines would fit in with Go. There is a huge emphasis on simplicity. Coroutines add a massive amount of complexity. In addition, goroutines provide the best parts of Coroutines - cheap, easy to use, non-blocking operations - without a lot of the pain pints such as “coloring” or functions and issues with using things like mutexes.<p>Just the question of whether one should use a goroutine or a coroutine adds complexity.</div><br/><div id="36764367" class="c"><input type="checkbox" id="c-36764367" checked=""/><div class="controls bullet"><span class="by">badrequest</span><span>|</span><a href="#36763345">parent</a><span>|</span><a href="#36764412">next</a><span>|</span><label class="collapse" for="c-36764367">[-]</label><label class="expand" for="c-36764367">[2 more]</label></div><br/><div class="children"><div class="content">There are plenty of complicated things in Go, IMHO where it shines best is judiciously providing incredibly nice interfaces atop the complicated things.</div><br/><div id="36768613" class="c"><input type="checkbox" id="c-36768613" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#36763345">root</a><span>|</span><a href="#36764367">parent</a><span>|</span><a href="#36764412">next</a><span>|</span><label class="collapse" for="c-36768613">[-]</label><label class="expand" for="c-36768613">[1 more]</label></div><br/><div class="children"><div class="content">Having coded in go professionally, I disagree.  Go abstractions leak in weird and unexpected ways that are surprisingly different to it&#x27;s C&#x2F;C++&#x2F;Java predecessors.<p>Goroutines were kind of the raison detre&#x27; for using go.  But using them wasn&#x27;t simple, and instead often goroutines brought their own issues.  See here:<p><a href="https:&#x2F;&#x2F;songlh.github.io&#x2F;paper&#x2F;go-study.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;songlh.github.io&#x2F;paper&#x2F;go-study.pdf</a><p>Often a programming language takes a first guess at the problems they want to solve, and often get them wrong.  C++ is probably the most notable language in this category here.<p>That said, I do appreciate an attempt to improve programming languages even if it undermines the primary feature of the language itself.</div><br/></div></div></div></div><div id="36764412" class="c"><input type="checkbox" id="c-36764412" checked=""/><div class="controls bullet"><span class="by">talideon</span><span>|</span><a href="#36763345">parent</a><span>|</span><a href="#36764367">prev</a><span>|</span><a href="#36764681">next</a><span>|</span><label class="collapse" for="c-36764412">[-]</label><label class="expand" for="c-36764412">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no colouring here. These are synchronous coroutines.</div><br/></div></div></div></div><div id="36764681" class="c"><input type="checkbox" id="c-36764681" checked=""/><div class="controls bullet"><span class="by">VWWHFSfQ</span><span>|</span><a href="#36763345">prev</a><span>|</span><a href="#36768304">next</a><span>|</span><label class="collapse" for="c-36764681">[-]</label><label class="expand" for="c-36764681">[9 more]</label></div><br/><div class="children"><div class="content">Aside:<p>Lua is an absolute work of art.  Everything about the tiny language, how it works, and even all the little peculiarities, just makes sense.</div><br/><div id="36766749" class="c"><input type="checkbox" id="c-36766749" checked=""/><div class="controls bullet"><span class="by">cakoose</span><span>|</span><a href="#36764681">parent</a><span>|</span><a href="#36765772">next</a><span>|</span><label class="collapse" for="c-36766749">[-]</label><label class="expand" for="c-36766749">[1 more]</label></div><br/><div class="children"><div class="content">One core Lua thing that I think is an ugly mistake: trying to represent maps (dictionaries) and arrays using a single logical data type.<p>Most languages use different data types but with some API overlap, e.g. maps and arrays are both &quot;iterable&quot;. Lua goes too far, I think, and tries to make them the exact same, a data type they call &quot;table&quot;.<p>One side-effect is that you have some operations that only really make sense for maps or lists, but since they work on all tables, they&#x27;re defined awkwardly, e.g:<p>&gt; The length of a table t is defined to be any integer index n such that t[n] is not nil and t[n+1] is nil; moreover, if t[1] is nil, n can be zero. For a regular array, with non-nil values from 1 to a given n, its length is exactly that n, the index of its last value. If the array has &quot;holes&quot; (that is, nil values between other non-nil values), then #t can be any of the indices that directly precedes a nil value (that is, it may consider any such nil value as the end of the array).</div><br/></div></div><div id="36765772" class="c"><input type="checkbox" id="c-36765772" checked=""/><div class="controls bullet"><span class="by">dingxiong</span><span>|</span><a href="#36764681">parent</a><span>|</span><a href="#36766749">prev</a><span>|</span><a href="#36764820">next</a><span>|</span><label class="collapse" for="c-36765772">[-]</label><label class="expand" for="c-36765772">[4 more]</label></div><br/><div class="children"><div class="content">hmm. why are Lua arrays 1-index based?</div><br/><div id="36769122" class="c"><input type="checkbox" id="c-36769122" checked=""/><div class="controls bullet"><span class="by">nmz</span><span>|</span><a href="#36764681">root</a><span>|</span><a href="#36765772">parent</a><span>|</span><a href="#36765858">next</a><span>|</span><label class="collapse" for="c-36769122">[-]</label><label class="expand" for="c-36769122">[2 more]</label></div><br/><div class="children"><div class="content">Because arrays start at 1, offsets start at 0</div><br/><div id="36769192" class="c"><input type="checkbox" id="c-36769192" checked=""/><div class="controls bullet"><span class="by">defrost</span><span>|</span><a href="#36764681">root</a><span>|</span><a href="#36769122">parent</a><span>|</span><a href="#36765858">next</a><span>|</span><label class="collapse" for="c-36769192">[-]</label><label class="expand" for="c-36769192">[1 more]</label></div><br/><div class="children"><div class="content">Arrays are just a sequence of objects.<p><i>Indexes</i> (traditionally) start at 1, <i>offsets</i> (measures from base) obviously start from zero.</div><br/></div></div></div></div><div id="36765858" class="c"><input type="checkbox" id="c-36765858" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#36764681">root</a><span>|</span><a href="#36765772">parent</a><span>|</span><a href="#36769122">prev</a><span>|</span><a href="#36764820">next</a><span>|</span><label class="collapse" for="c-36765858">[-]</label><label class="expand" for="c-36765858">[1 more]</label></div><br/><div class="children"><div class="content">good enough for Rome</div><br/></div></div></div></div></div></div><div id="36768304" class="c"><input type="checkbox" id="c-36768304" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#36764681">prev</a><span>|</span><a href="#36765848">next</a><span>|</span><label class="collapse" for="c-36768304">[-]</label><label class="expand" for="c-36768304">[1 more]</label></div><br/><div class="children"><div class="content">i&#x27;ve been thinking about a closely related feature in a different context: adding block arguments, as in smalltalk or ruby or especially lobster, to a language more like c, with static types and stack allocation<p>i think this would be favorable for (among other things) clu-like iterators and imgui libraries, where you often want to do something like<p><pre><code>    submenu(&quot;&amp;Edit&quot;) {
        command(&quot;&amp;Cut&quot;) { clip_cut(getSelection()); }
        ...
    }
</code></pre>
this is especially useful in a context where you&#x27;re heap-allocating sparingly or not at all, because the subroutine taking the block argument can stack-allocate some resource, pass it to the block, and deallocate it once the block returns; python context managers and win32 paint messages are two cases where people commonly do this sort of thing, but things like save-excursion, with-output-file, transactional memory, and gsave&#x2F;grestore also provide motivation<p>the conventional way to do this is to package up the block into a closure, then use a full-fledged function invocation to invoke it, using a calling convention that supports closures.  but i suspect a more relaxed and efficient approach is to use an asymmetric coroutine calling convention, in which the callee yields back control to its caller at the entry point to the block, and the block then resumes the callee when it finishes.  so instead of merely dividing registers into callee-saved and call-clobbered, as subroutine calling conventions do, we would divide them into callee-saved upon return but upon yield containing callee values the block must have restored upon resumption; caller coroutine context registers, which are callee-saved upon return and also on yield; and call-clobbered. you also need in many cases a way for the block to safely force an early exit from the callee<p>this allows the caller&#x27;s local variables to be in registers its blocks can use without further ado, or at least indexed off of such a register, while allowing the yield and resume operations to be, in many cases, just a single machine instruction.  and it does not require heap allocation<p>as an example of taking this to the point of absurdity, here&#x27;s an untested subroutine for iterating over a nul-terminated string passed in r0 with a block passed in r1, using a hypothetical coroutine convention which passes at least r4 through from its caller to its blocks<p><pre><code>    itersz: push {r6, r7, r8, lr}
            mov  r7, r0
            mov  r6, r1
    1:      ldrb r0, [r7], #1
            cbz  r0, 1f
            blx  r1
            b    1b
    1:      pop  {r6, r7, r8, pc}
</code></pre>
and here is another untested subroutine which uses it to calculate a string hash<p><pre><code>    hashsz: push {r4, r5, r9, lr}
            movs r4, #53
            adr  r1, 1f
            blx  itersz
            mov  r0, r4
            pop  {r4, r5, r9, pc}
    1:      eor  r4, r0, r4, ror #27
            bx   lr
</code></pre>
even in this case where both the iteration and the visitor block are utterly trivial, the runtime overhead per item (compared to putting them in the same subroutine) is evidently extremely modest; my estimate is 7 cycles per byte rather than 4 cycles per byte on in-order hardware with simple branch prediction, so, on the order of 1 ns on the hardware russ used as his reference. for anything more complex the overhead should be insignificant<p>it&#x27;s less general than the mechanism russ proposes here (it doesn&#x27;t solve the celebrated samefringe problem), but it&#x27;s also an order of magnitude more efficient, because the yield and resume operations are less work than a subroutine call, though still more work than, say, decrementing a register and jumping if nonzero</div><br/></div></div><div id="36765848" class="c"><input type="checkbox" id="c-36765848" checked=""/><div class="controls bullet"><span class="by">pmarreck</span><span>|</span><a href="#36768304">prev</a><span>|</span><a href="#36764791">next</a><span>|</span><label class="collapse" for="c-36765848">[-]</label><label class="expand" for="c-36765848">[1 more]</label></div><br/><div class="children"><div class="content">As a point of comparison, here&#x27;s my demo from a recent presentation of firing up 1 million (1,000,000) Elixir (BEAM VM) threads, sending them all a &quot;Hello!&quot; message, and then each thread waits a random amount of time between 0 and 2 seconds to send a message back of &quot;Process &lt;their number&gt; received message &lt;themessage&gt;!&quot;<p>At the same time, I am running the Erlang observer beside it to watch what happens to the CPU and memory consumption and how quickly it recovers&#x2F;cleans up the garbage.<p>The biggest bottleneck here is the terminal&#x27;s ability to keep up, but the observer seems to reflect what&#x27;s happening accurately.<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=yxyYKnashR0">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=yxyYKnashR0</a><p>The code I used: <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;pmarreck&#x2F;4cc8f2f55a561ebce2012085a3a631f0" rel="nofollow noreferrer">https:&#x2F;&#x2F;gist.github.com&#x2F;pmarreck&#x2F;4cc8f2f55a561ebce2012085a3a...</a><p>These features have been built into Erlang (and thus Elixir) since the 1980&#x27;s. I&#x27;m sure many of you have heard of the Actor model and&#x2F;or Erlang&#x27;s &quot;legendary&quot; implementation of it, but I don&#x27;t know how many have actually seen it in action with monitoring kit running.<p>I think it would be great for Go if it offered language-level support like this, but given the extremely resource-efficient implementation (both in spawning and runtime consumption) of threads on the BEAM VM, coupled with the ease of concurrency which comes directly from only permitting immutable values, I don&#x27;t think it will ever be matched.</div><br/></div></div><div id="36765630" class="c"><input type="checkbox" id="c-36765630" checked=""/><div class="controls bullet"><span class="by">pierrebai</span><span>|</span><a href="#36764791">prev</a><span>|</span><a href="#36763938">next</a><span>|</span><label class="collapse" for="c-36765630">[-]</label><label class="expand" for="c-36765630">[1 more]</label></div><br/><div class="children"><div class="content">The examples given prompt me to say: if all you have is Rube-Goldberg hammer, everything looks like an Escheresque nail.<p>Sieving primes by turning functions into coroutines, parsing text by yielding characters, all with unnatural functions and state management... that;s an improvement over what?</div><br/></div></div><div id="36763938" class="c"><input type="checkbox" id="c-36763938" checked=""/><div class="controls bullet"><span class="by">ketchupdebugger</span><span>|</span><a href="#36765630">prev</a><span>|</span><a href="#36765823">next</a><span>|</span><label class="collapse" for="c-36763938">[-]</label><label class="expand" for="c-36763938">[12 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure why author is advocating for single threaded patterns in a multithreaded environment. Not sure why he&#x27;s trying to limit himself like this. The magic of goroutines is that you can use all of your cores easily not just one. Python and Lua has no choice.</div><br/><div id="36763993" class="c"><input type="checkbox" id="c-36763993" checked=""/><div class="controls bullet"><span class="by">yakubin</span><span>|</span><a href="#36763938">parent</a><span>|</span><a href="#36765823">next</a><span>|</span><label class="collapse" for="c-36763993">[-]</label><label class="expand" for="c-36763993">[11 more]</label></div><br/><div class="children"><div class="content">Coroutines are a control-flow mechanism. They&#x27;re a single-threaded pattern in as much as for loops are a single-threaded pattern. Ability to write multithreaded programs does not exclude the need for good single-threaded tools.</div><br/><div id="36764684" class="c"><input type="checkbox" id="c-36764684" checked=""/><div class="controls bullet"><span class="by">ketchupdebugger</span><span>|</span><a href="#36763938">root</a><span>|</span><a href="#36763993">parent</a><span>|</span><a href="#36765823">next</a><span>|</span><label class="collapse" for="c-36764684">[-]</label><label class="expand" for="c-36764684">[10 more]</label></div><br/><div class="children"><div class="content">Looking at python&#x27;s asyncio coroutine library, they are just mocking multithreading with asyncio.gather. Since coroutines can be executed in any order they are not really control-flow mechanisms. The selling point of coroutines over traditional threads is its lightweight but its moot since goroutines has similar memory cost to coroutines. The only real benefit is that coroutines are non blocking while goroutines may be blocked. There is no real benefit of having python&#x27;s coroutine in go since goroutines does the same but better.</div><br/><div id="36765499" class="c"><input type="checkbox" id="c-36765499" checked=""/><div class="controls bullet"><span class="by">ackfoobar</span><span>|</span><a href="#36763938">root</a><span>|</span><a href="#36764684">parent</a><span>|</span><a href="#36764814">next</a><span>|</span><label class="collapse" for="c-36765499">[-]</label><label class="expand" for="c-36765499">[7 more]</label></div><br/><div class="children"><div class="content">The concept of &quot;coroutines&quot; is as much about control flow as &quot;subroutines&quot; (function calls and return statements).<p>But when you have a construct that has their own call stacks, it&#x27;s a relatively small step to implement lightweight threads with it.<p>Since doing concurrency happens much more often than any other smart use of coroutines, many people conflate the two.<p>I sometimes see this confusion in discussions about Kotlin&#x27;s coroutines. An example of using coroutines that is not about concurrency:
<a href="https:&#x2F;&#x2F;kotlinlang.org&#x2F;api&#x2F;latest&#x2F;jvm&#x2F;stdlib&#x2F;kotlin.sequences&#x2F;sequence.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;kotlinlang.org&#x2F;api&#x2F;latest&#x2F;jvm&#x2F;stdlib&#x2F;kotlin.sequence...</a></div><br/><div id="36767584" class="c"><input type="checkbox" id="c-36767584" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#36763938">root</a><span>|</span><a href="#36765499">parent</a><span>|</span><a href="#36768200">next</a><span>|</span><label class="collapse" for="c-36767584">[-]</label><label class="expand" for="c-36767584">[4 more]</label></div><br/><div class="children"><div class="content">Kotlin&#x27;s sequence pre-dates co-routines. Mostly what either of those do is just a bit of syntactic sugar on top of call back mechanisms. One of the nice things with Kotlin is the ability to extend existing APIs via extension functions. Which is something the co-routines library uses extensively to be able to provide co-routine implementations on top of existing frameworks on the JVM, in javascript, and in native environments. Same APIs. Same code. Different underlying implementations. I actively use this in some of my multi platform libraries that I use on JVM and in the browser.<p>The key concept with Kotlin&#x27;s co-routines is not having to choose between reactive, green threads, or real threads but treating all of those in the same way with a robust set of abstractions. I use co-routines in the browser on top of existing javascript frameworks that return promises. I use them on the JVM with reactive frameworks like flux. And I also use them with some thread pools. Once Loom reaches LTS (next year, I think), I&#x27;ll probably be configuring some Loom capable co-routine dispatchers as well.<p>The debate regarding co-routines vs. go-routines seems like it is similar. I think Go can learn a thing or two from Kotlin&#x27;s co-routines. After all it is mostly built as a library on top of a single language feature: the suspend keyword. I get that not everybody likes colored functions. But then having a lot of leaky abstractions and related complexity on top of go routines is maybe also not ideal.</div><br/><div id="36767695" class="c"><input type="checkbox" id="c-36767695" checked=""/><div class="controls bullet"><span class="by">ackfoobar</span><span>|</span><a href="#36763938">root</a><span>|</span><a href="#36767584">parent</a><span>|</span><a href="#36768200">next</a><span>|</span><label class="collapse" for="c-36767695">[-]</label><label class="expand" for="c-36767695">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Kotlin&#x27;s sequence pre-dates co-routines.<p>You misunderstood. The `Sequence` type does predate coroutines. But I meant the `sequence` builder function, which takes a block of suspending code to create a `Sequence`.<p>The in-order traversal in the article can be translated to Kotlin:<p><pre><code>    fun walk(t: Tree?): Sequence&lt;Int&gt; = sequence {
        if (t != null) {
            yieldAll(walk(t.left))
            yield(t.value)
            yieldAll(walk(t.right))
        }
    }
</code></pre>
As I have noted above, this is a use of coroutines that has nothing to do with concurrency.</div><br/><div id="36768442" class="c"><input type="checkbox" id="c-36768442" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#36763938">root</a><span>|</span><a href="#36767695">parent</a><span>|</span><a href="#36768200">next</a><span>|</span><label class="collapse" for="c-36768442">[-]</label><label class="expand" for="c-36768442">[2 more]</label></div><br/><div class="children"><div class="content">Sequences actually were part of Kotlin 1.0. Co-routines were added later.</div><br/><div id="36768730" class="c"><input type="checkbox" id="c-36768730" checked=""/><div class="controls bullet"><span class="by">ackfoobar</span><span>|</span><a href="#36763938">root</a><span>|</span><a href="#36768442">parent</a><span>|</span><a href="#36768200">next</a><span>|</span><label class="collapse" for="c-36768730">[-]</label><label class="expand" for="c-36768730">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Sequences actually were part of Kotlin 1.0.<p>But the <i>`sequence` builder function</i> was not. In fact it depends on coroutines.<p>Could you read my reply before repeating?</div><br/></div></div></div></div></div></div></div></div><div id="36768200" class="c"><input type="checkbox" id="c-36768200" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#36763938">root</a><span>|</span><a href="#36765499">parent</a><span>|</span><a href="#36767584">prev</a><span>|</span><a href="#36764814">next</a><span>|</span><label class="collapse" for="c-36768200">[-]</label><label class="expand" for="c-36768200">[2 more]</label></div><br/><div class="children"><div class="content">In fact python had general coroutines first in yield, which is mostly used for iteration (“generators”) and state machines.<p>Some frameworks (e.g. twisted) did use them for concurrency, and the core team originally planned something similar, however the ergonomics were not what they wanted (especially when mixing coroutines-for-concurrency and coroutines-for-iteration), so they went for a more specialised design.</div><br/><div id="36768618" class="c"><input type="checkbox" id="c-36768618" checked=""/><div class="controls bullet"><span class="by">ackfoobar</span><span>|</span><a href="#36763938">root</a><span>|</span><a href="#36768200">parent</a><span>|</span><a href="#36764814">next</a><span>|</span><label class="collapse" for="c-36768618">[-]</label><label class="expand" for="c-36768618">[1 more]</label></div><br/><div class="children"><div class="content">&gt; did use them for concurrency<p>&gt; went for a more specialised design<p>My impression is that JS evolved similarly - (ab)using generator for concurrency, then specialized async-await as a language feature.</div><br/></div></div></div></div></div></div><div id="36764814" class="c"><input type="checkbox" id="c-36764814" checked=""/><div class="controls bullet"><span class="by">yakubin</span><span>|</span><a href="#36763938">root</a><span>|</span><a href="#36764684">parent</a><span>|</span><a href="#36765499">prev</a><span>|</span><a href="#36764919">next</a><span>|</span><label class="collapse" for="c-36764814">[-]</label><label class="expand" for="c-36764814">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know about Python, but this description of coroutines, the general concept, doesn&#x27;t seem accurate to me. They most definitely cannot be executed in any order. They also have nothing to do with multithreading whatsoever. Lua has the most honest-to-god implementation of coroutines I know of, so I&#x27;d suggest looking at that. I&#x27;ve seen the word &quot;coroutines&quot; used in some weird way suggesting multithreading, which probably means Python used them to fake multithreading, but the idea originally has nothing to do with it. The idea actually started out as a way to better structure an assembly program in 1958: &lt;<a href="http:&#x2F;&#x2F;melconway.com&#x2F;Home&#x2F;pdf&#x2F;compiler.pdf" rel="nofollow noreferrer">http:&#x2F;&#x2F;melconway.com&#x2F;Home&#x2F;pdf&#x2F;compiler.pdf</a>&gt;.</div><br/></div></div><div id="36764919" class="c"><input type="checkbox" id="c-36764919" checked=""/><div class="controls bullet"><span class="by">maxk42</span><span>|</span><a href="#36763938">root</a><span>|</span><a href="#36764684">parent</a><span>|</span><a href="#36764814">prev</a><span>|</span><a href="#36765823">next</a><span>|</span><label class="collapse" for="c-36764919">[-]</label><label class="expand" for="c-36764919">[1 more]</label></div><br/><div class="children"><div class="content">Goroutines are non-blocking.  Channels may not always be, however.</div><br/></div></div></div></div></div></div></div></div><div id="36765823" class="c"><input type="checkbox" id="c-36765823" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#36763938">prev</a><span>|</span><label class="collapse" for="c-36765823">[-]</label><label class="expand" for="c-36765823">[1 more]</label></div><br/><div class="children"><div class="content">Reasoning about and following the control flow of the proposed code hurts me inside.  If Go adds function coloring via (e.g. python&#x27;s async and&#x2F;or yield concepts), I&#x27;m out, because I don&#x27;t want to use this, much less encounter it in the form of a bug in some library.<p>Java and C++ are largely inferior for my typical purposes, but at the end of the day they work fine and are stable in terms of direction, and don&#x27;t tend to repeatedly bloat the language over pedantry.  If you want top-notch performance, there&#x27;s already C, C++, and Rust.<p>I am not a fan of the function coloring shit in Python and Javascript.<p>I don&#x27;t want the kitchen sink!</div><br/></div></div></div></div></div></div></div></body></html>