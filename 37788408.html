<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1696669263483" as="style"/><link rel="stylesheet" href="styles.css?v=1696669263483"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://nibblestew.blogspot.com/2023/10/could-we-make-c-arrays-memory.html">Could we make C arrays memory safe? Probably not, but let&#x27;s try</a>Â <span class="domain">(<a href="https://nibblestew.blogspot.com">nibblestew.blogspot.com</a>)</span></div><div class="subtext"><span>ingve</span> | <span>43 comments</span></div><br/><div><div id="37800148" class="c"><input type="checkbox" id="c-37800148" checked=""/><div class="controls bullet"><span class="by">Uptrenda</span><span>|</span><a href="#37798809">next</a><span>|</span><label class="collapse" for="c-37800148">[-]</label><label class="expand" for="c-37800148">[3 more]</label></div><br/><div class="children"><div class="content">&gt;Cnt + f &#x27;rust&#x27;
&gt;&#x27;this has roughly the same ... rust borrow...<p>Yep, knew this post would be from a Rust zealot. &#x27;&#x27;&quot;`memory safety&#x27;&#x27;&quot;` is not the point of C and never has been. C is a simple language used to model the low-level machine details in a more accessible way. Trying to wrap it with Rust abstractions would not be simple.<p>No one who values what C is wants to see it turned into the nightmare monstrosity of a Rust program. Rust has some of the ugliest programs anyone has ever written. Programs filled with &#x27;&#x27;&quot;`unsafe&#x27;&#x27;&quot;... horrible macro templating... and Escher stairways that make every task feel like an Apollo mission.<p>You already have one horrible language. You can leave C alone.</div><br/><div id="37800179" class="c"><input type="checkbox" id="c-37800179" checked=""/><div class="controls bullet"><span class="by">hurril</span><span>|</span><a href="#37800148">parent</a><span>|</span><a href="#37800175">next</a><span>|</span><label class="collapse" for="c-37800179">[-]</label><label class="expand" for="c-37800179">[1 more]</label></div><br/><div class="children"><div class="content">This post, more than anything, comes across as you being a C zealot.</div><br/></div></div><div id="37800175" class="c"><input type="checkbox" id="c-37800175" checked=""/><div class="controls bullet"><span class="by">keyle</span><span>|</span><a href="#37800148">parent</a><span>|</span><a href="#37800179">prev</a><span>|</span><a href="#37798809">next</a><span>|</span><label class="collapse" for="c-37800175">[-]</label><label class="expand" for="c-37800175">[1 more]</label></div><br/><div class="children"><div class="content">Ahah, while I&#x27;ve done both C and Rust, I agree but I think you&#x27;re a bit harsh.<p>I like to say that Rust reads like a beautiful dialect of Klingon.<p>If you read out loud a rust program with a Klingon accent and bang the desk with your fist at every lifetime, it will sound quite natural.</div><br/></div></div></div></div><div id="37798809" class="c"><input type="checkbox" id="c-37798809" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#37800148">prev</a><span>|</span><a href="#37795355">next</a><span>|</span><label class="collapse" for="c-37798809">[-]</label><label class="expand" for="c-37798809">[3 more]</label></div><br/><div class="children"><div class="content">Been there, done that, in 2012. The array syntax can be more C-like and interfaces can be backwards-compatible.[1] Many people have been down this road. Selling it is harder than doing it.<p>[1] <a href="http:&#x2F;&#x2F;animats.com&#x2F;papers&#x2F;languages&#x2F;safearraysforc43.pdf" rel="nofollow noreferrer">http:&#x2F;&#x2F;animats.com&#x2F;papers&#x2F;languages&#x2F;safearraysforc43.pdf</a></div><br/><div id="37799186" class="c"><input type="checkbox" id="c-37799186" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#37798809">parent</a><span>|</span><a href="#37795355">next</a><span>|</span><label class="collapse" for="c-37799186">[-]</label><label class="expand" for="c-37799186">[2 more]</label></div><br/><div class="children"><div class="content">Ah, thanks. I didn&#x27;t know this proposal. I am trying to push similar things.<p>The main obstacle are people coming from MSVC or C++ not knowing variably modified types and people being convinced that VLAs are always bad.  This then leads to many bad attempts at fixing the problem instead of simply using arrays which know their run-time length.  While we still miss a bit of compiler support (I am working on it), this already helps today: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;4a45xq5hr" rel="nofollow noreferrer">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;4a45xq5hr</a><p>(Update: Of course, the use of references in the proposal above and the motivation is a bit obscure. In any case, VM-types will not be optional in C23 anymore. And usage and interesting is going up.)</div><br/><div id="37800017" class="c"><input type="checkbox" id="c-37800017" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37798809">root</a><span>|</span><a href="#37799186">parent</a><span>|</span><a href="#37795355">next</a><span>|</span><label class="collapse" for="c-37800017">[-]</label><label class="expand" for="c-37800017">[1 more]</label></div><br/><div class="children"><div class="content">Even Dennis tried back in the day, but WG14 wasn&#x27;t interested in his proposal, and by then it wasn&#x27;t his language any longer anyway.<p>So will WG14 finally care about C&#x27;s safety?</div><br/></div></div></div></div></div></div><div id="37795355" class="c"><input type="checkbox" id="c-37795355" checked=""/><div class="controls bullet"><span class="by">almatabata</span><span>|</span><a href="#37798809">prev</a><span>|</span><a href="#37798602">next</a><span>|</span><label class="collapse" for="c-37795355">[-]</label><label class="expand" for="c-37795355">[2 more]</label></div><br/><div class="children"><div class="content">Similar proposal by Walter Bright as well:
<a href="https:&#x2F;&#x2F;www.digitalmars.com&#x2F;articles&#x2F;C-biggest-mistake.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.digitalmars.com&#x2F;articles&#x2F;C-biggest-mistake.html</a><p>This got proposed in 2009 so i do not see things changing any time soon.</div><br/><div id="37799333" class="c"><input type="checkbox" id="c-37799333" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#37795355">parent</a><span>|</span><a href="#37798602">next</a><span>|</span><label class="collapse" for="c-37799333">[-]</label><label class="expand" for="c-37799333">[1 more]</label></div><br/><div class="children"><div class="content">We made variably modified types mandatory in C23. Compiler support for bounds checking is improving (via UBSan). Static analysis is improving (a bit). Flexible array members can now be secured using length information provided by an attribute. So yes, things are moving in the right direction.  For the version after C23 I am relatively sure we will see a bounded pointer type.</div><br/></div></div></div></div><div id="37798602" class="c"><input type="checkbox" id="c-37798602" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#37795355">prev</a><span>|</span><a href="#37798734">next</a><span>|</span><label class="collapse" for="c-37798602">[-]</label><label class="expand" for="c-37798602">[10 more]</label></div><br/><div class="children"><div class="content">The real blocker is that the various solutions are almost certainly never ABI-compatible with existing code, and for most people it&#x27;s unrealistic to recompile the world (and even if you can forbid inline asm elsewhere, libc is nasty). (edit: I suppose WASM is sort of forcing that though, but unfortunately it didn&#x27;t take the opportunity to allow dynamically fixing this)<p>A solution <i>is</i> mostly possible with a segmented allocator, which is quite reasonable on 64-bit platforms (32-bit allocation ID, 32-bit index within the allocation).<p>But keep in mind that &quot;buffer overflow within a struct&quot; is often considered a <i>feature</i>.<p>I think the best approach is &quot;design a new, &#x27;safe&#x27; language that compiles to reasonable C code, and make it easy to port to that new language incrementally&quot;.</div><br/><div id="37799444" class="c"><input type="checkbox" id="c-37799444" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#37798602">parent</a><span>|</span><a href="#37799270">next</a><span>|</span><label class="collapse" for="c-37799444">[-]</label><label class="expand" for="c-37799444">[7 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;buffer overflow within a struct&quot; is often considered a feature.<p>That&#x27;s lying to the compiler, because there&#x27;s no way to say what you meant.<p>That&#x27;s why I proposed the syntax<p><pre><code>    typedef struct msgitem {
        const size_t len;
        char itemvalue[len];
    };
    struct msgitem firstmsg = { 100, 0 }; &#x2F;&#x2F; empty msgitem, size 100
</code></pre>
The last item of a struct could be a variable sized array. That&#x27;s sound,
and enough for things such as network packets. It&#x27;s important to avoid bikeshedding.</div><br/><div id="37799470" class="c"><input type="checkbox" id="c-37799470" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#37798602">root</a><span>|</span><a href="#37799444">parent</a><span>|</span><a href="#37799454">next</a><span>|</span><label class="collapse" for="c-37799470">[-]</label><label class="expand" for="c-37799470">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;buffer overflow within a struct&quot; is used a lot when you have built a &quot;header&quot; struct that you are just pinning to the start of the some record and the bottom of the struct has a line like:<p><pre><code>      char data[0];
</code></pre>
The purpose is to give you a handle on the remainder of the data even though you don&#x27;t know the size beforehand.<p>Technically this is not valid under strict C, but it&#x27;s also incredibly common.</div><br/></div></div><div id="37799454" class="c"><input type="checkbox" id="c-37799454" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#37798602">root</a><span>|</span><a href="#37799444">parent</a><span>|</span><a href="#37799470">prev</a><span>|</span><a href="#37799270">next</a><span>|</span><label class="collapse" for="c-37799454">[-]</label><label class="expand" for="c-37799454">[5 more]</label></div><br/><div class="children"><div class="content">What do you do when the length isn&#x27;t a field in the same struct?</div><br/><div id="37799642" class="c"><input type="checkbox" id="c-37799642" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#37798602">root</a><span>|</span><a href="#37799454">parent</a><span>|</span><a href="#37799270">next</a><span>|</span><label class="collapse" for="c-37799642">[-]</label><label class="expand" for="c-37799642">[4 more]</label></div><br/><div class="children"><div class="content">There must be an expression which can be evaluated to determine the length of the array, and which can thus be used for checking. Without that, the code has little chance of working, since something had better define the size of that array.</div><br/><div id="37799668" class="c"><input type="checkbox" id="c-37799668" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#37798602">root</a><span>|</span><a href="#37799642">parent</a><span>|</span><a href="#37799270">next</a><span>|</span><label class="collapse" for="c-37799668">[-]</label><label class="expand" for="c-37799668">[3 more]</label></div><br/><div class="children"><div class="content">I mean the expression doesn&#x27;t have to come from the same struct, though. It could be provided somewhere else.</div><br/><div id="37799889" class="c"><input type="checkbox" id="c-37799889" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#37798602">root</a><span>|</span><a href="#37799668">parent</a><span>|</span><a href="#37799270">next</a><span>|</span><label class="collapse" for="c-37799889">[-]</label><label class="expand" for="c-37799889">[2 more]</label></div><br/><div class="children"><div class="content">If the somewhere else can&#x27;t be located in a straightforward way, I&#x27;d say just change the code.</div><br/><div id="37799914" class="c"><input type="checkbox" id="c-37799914" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#37798602">root</a><span>|</span><a href="#37799889">parent</a><span>|</span><a href="#37799270">next</a><span>|</span><label class="collapse" for="c-37799914">[-]</label><label class="expand" for="c-37799914">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If the somewhere else can&#x27;t be located in a straightforward way<p>It might very well be straightforward to obtain, just not located in that struct itself.<p>&gt; I&#x27;d say just change the code.<p>And if the code isn&#x27;t available to you to change?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37799270" class="c"><input type="checkbox" id="c-37799270" checked=""/><div class="controls bullet"><span class="by">raverbashing</span><span>|</span><a href="#37798602">parent</a><span>|</span><a href="#37799444">prev</a><span>|</span><a href="#37798773">next</a><span>|</span><label class="collapse" for="c-37799270">[-]</label><label class="expand" for="c-37799270">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But keep in mind that &quot;buffer overflow within a struct&quot; is often considered a feature.<p>Yes, one of those &quot;features&quot; designed to work around limitations of the language<p>C is &quot;simple&quot; in the same way a chainsaw without guards or brakes is &quot;simpler&quot; than one with those attachments</div><br/></div></div><div id="37798773" class="c"><input type="checkbox" id="c-37798773" checked=""/><div class="controls bullet"><span class="by">mlindner</span><span>|</span><a href="#37798602">parent</a><span>|</span><a href="#37799270">prev</a><span>|</span><a href="#37798734">next</a><span>|</span><label class="collapse" for="c-37798773">[-]</label><label class="expand" for="c-37798773">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But keep in mind that &quot;buffer overflow within a struct&quot; is often considered a feature.<p>Yes this is used rampantly in any kind of code that&#x27;s running in basically all of the world&#x27;s network appliances that do packet processing.<p>I&#x27;d even say it&#x27;s considered &quot;best practice&quot; by most C programmers.</div><br/></div></div></div></div><div id="37798734" class="c"><input type="checkbox" id="c-37798734" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#37798602">prev</a><span>|</span><a href="#37799156">next</a><span>|</span><label class="collapse" for="c-37798734">[-]</label><label class="expand" for="c-37798734">[3 more]</label></div><br/><div class="children"><div class="content">Apple is trying something very similar to this:<p><a href="https:&#x2F;&#x2F;discourse.llvm.org&#x2F;t&#x2F;rfc-enforcing-bounds-safety-in-c-fbounds-safety" rel="nofollow noreferrer">https:&#x2F;&#x2F;discourse.llvm.org&#x2F;t&#x2F;rfc-enforcing-bounds-safety-in-...</a><p>Supposedly it&#x27;s already in use: &quot;The -fbounds-safety extension has been adopted on millions of lines of production C code and proven to work in a consumer operating system setting.&quot;</div><br/><div id="37798897" class="c"><input type="checkbox" id="c-37798897" checked=""/><div class="controls bullet"><span class="by">88913527</span><span>|</span><a href="#37798734">parent</a><span>|</span><a href="#37799156">next</a><span>|</span><label class="collapse" for="c-37798897">[-]</label><label class="expand" for="c-37798897">[2 more]</label></div><br/><div class="children"><div class="content">Is there a reason discussion around C is phrased like this? My reaction to that quote is, &quot;yeah it could possibly have some issues we&#x27;re not really sure of, but it seems reasonably battle-tested too&quot;. It evokes a bit of mixed signal messaging, to me at least.</div><br/><div id="37800035" class="c"><input type="checkbox" id="c-37800035" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37798734">root</a><span>|</span><a href="#37798897">parent</a><span>|</span><a href="#37799156">next</a><span>|</span><label class="collapse" for="c-37800035">[-]</label><label class="expand" for="c-37800035">[1 more]</label></div><br/><div class="children"><div class="content">Yes, ISO and WG14.<p>It is only C if it lands on the standard, otherwise it is yet another compiler specific language extension, that portable code cannot rely on.</div><br/></div></div></div></div></div></div><div id="37799156" class="c"><input type="checkbox" id="c-37799156" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#37798734">prev</a><span>|</span><a href="#37799140">next</a><span>|</span><label class="collapse" for="c-37799156">[-]</label><label class="expand" for="c-37799156">[3 more]</label></div><br/><div class="children"><div class="content">Just use array properly and you get run-time bounds checking:
<a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;4a45xq5hr" rel="nofollow noreferrer">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;4a45xq5hr</a><p>(yes, a bit more compiler support is necessary to make this safe. I posted a patch to GCC, let&#x27;s see)</div><br/><div id="37799462" class="c"><input type="checkbox" id="c-37799462" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37799156">parent</a><span>|</span><a href="#37799140">next</a><span>|</span><label class="collapse" for="c-37799462">[-]</label><label class="expand" for="c-37799462">[2 more]</label></div><br/><div class="children"><div class="content">TIL ...<p>I never knew that you got runtime bounds-checking with VLAs.<p>Do you have a link that explains this snippet in more detail? Why&#x2F;how does it work?<p>It doesn&#x27;t appear to work with non-VLAs though.</div><br/><div id="37799540" class="c"><input type="checkbox" id="c-37799540" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#37799156">root</a><span>|</span><a href="#37799462">parent</a><span>|</span><a href="#37799140">next</a><span>|</span><label class="collapse" for="c-37799540">[-]</label><label class="expand" for="c-37799540">[1 more]</label></div><br/><div class="children"><div class="content">It works because the type (char (<i>buf)[n]) knows the dynamic size &#x27;n&#x27;. So the compiler can simply add the bounds check to an array access (</i>buf)[i] if instructed to do so.<p>If you replace the sizes with constants it also works: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;sKPW6zT87" rel="nofollow noreferrer">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;sKPW6zT87</a><p>The safety story is not complete though: If you pass the wrong size to &#x27;foo&#x27; this is not detected (this is easy to add to compilers and I submitted a patch to GCC which would do this): <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;T8844e1z8" rel="nofollow noreferrer">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;T8844e1z8</a><p>(ASAN still catches the problem in this case, but ASAN does not work consistently and has a high run-time overhead.)</div><br/></div></div></div></div></div></div><div id="37799140" class="c"><input type="checkbox" id="c-37799140" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#37799156">prev</a><span>|</span><a href="#37798616">next</a><span>|</span><label class="collapse" for="c-37799140">[-]</label><label class="expand" for="c-37799140">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get this: why using both the annotation and the boundary checks? Once I annotate the function&#x27;s parameters, the compiler can safely assume what the annotations state. Of course then it must check that the condition is guaranteed at caller side. Just like you don&#x27;t have to check that index &gt;= 0 because it&#x27;s declared as unsigned, but it the caller&#x27;s duty to not call the function with -1, for example.</div><br/><div id="37799362" class="c"><input type="checkbox" id="c-37799362" checked=""/><div class="controls bullet"><span class="by">olliej</span><span>|</span><a href="#37799140">parent</a><span>|</span><a href="#37798616">next</a><span>|</span><label class="collapse" for="c-37799362">[-]</label><label class="expand" for="c-37799362">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure what you&#x27;re asking?<p>The annotations say &quot;the bound of the pointer&#x2F;array p is expression X&quot;, but if I subsequently do for (int i.....) { p[i]++; } you have to perform a bounds check unless you can prove that i never exceeds the expression given by the bounds.<p>e.g. (using the implemented and used in the real world bounds safety extension in clang[1])<p><pre><code>    void f1(int *ps __counted_by(N), int N) {
        for (int j = 0; j &lt; N; j++) ps[j]++;
    }

    void f2(int *ps __counted_by(N), int N) {
        for (int j = 0; j &lt; 10; j++) ps[j]++;
    }
</code></pre>
In the function f1 the compiler can in principle prove that the bounds checks aren&#x27;t needed, but in f2 it cannot, and so failing to perform a bounds check would lead to unsafe code.<p>Making the bounds of a pointer explicit does not mean that you no longer need bounds checks, it just means that now you know what the bounds are, so you can most enforce those bounds. Then as an implementation detail you optimise the unnecessary checks out. The enforcement aspect is required for correctness, if you cannot prove at compile time that a pointer operation is in bounds a bounds check is mandatory.<p>[1] <a href="https:&#x2F;&#x2F;discourse.llvm.org&#x2F;t&#x2F;rfc-enforcing-bounds-safety-in-c-fbounds-safety&#x2F;70854" rel="nofollow noreferrer">https:&#x2F;&#x2F;discourse.llvm.org&#x2F;t&#x2F;rfc-enforcing-bounds-safety-in-...</a></div><br/></div></div></div></div><div id="37798616" class="c"><input type="checkbox" id="c-37798616" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#37799140">prev</a><span>|</span><a href="#37799745">next</a><span>|</span><label class="collapse" for="c-37798616">[-]</label><label class="expand" for="c-37798616">[7 more]</label></div><br/><div class="children"><div class="content">I think one should look at failure oblivious computing.<p><a href="https:&#x2F;&#x2F;dspace.mit.edu&#x2F;handle&#x2F;1721.1&#x2F;7505" rel="nofollow noreferrer">https:&#x2F;&#x2F;dspace.mit.edu&#x2F;handle&#x2F;1721.1&#x2F;7505</a></div><br/><div id="37798693" class="c"><input type="checkbox" id="c-37798693" checked=""/><div class="controls bullet"><span class="by">grotorea</span><span>|</span><a href="#37798616">parent</a><span>|</span><a href="#37799685">next</a><span>|</span><label class="collapse" for="c-37798693">[-]</label><label class="expand" for="c-37798693">[5 more]</label></div><br/><div class="children"><div class="content">The robustness principle applied to memory? Like when the browser adds the missing closing HTML tags instead of telling the dev to fix their code? We sure we want that?</div><br/><div id="37798722" class="c"><input type="checkbox" id="c-37798722" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#37798616">root</a><span>|</span><a href="#37798693">parent</a><span>|</span><a href="#37799399">next</a><span>|</span><label class="collapse" for="c-37798722">[-]</label><label class="expand" for="c-37798722">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t necessarily disagree, but...is this worse than what we already have? My argument against this sort of this for a language like C is that &quot;do what you think I mean instead of what I say&quot; might not actually result in what I _actually_ mean if the compiler guesses wrong, but undefined behavior isn&#x27;t generally going to do what I want either, so I&#x27;m not sure this would be any worse.</div><br/><div id="37799036" class="c"><input type="checkbox" id="c-37799036" checked=""/><div class="controls bullet"><span class="by">zdragnar</span><span>|</span><a href="#37798616">root</a><span>|</span><a href="#37798722">parent</a><span>|</span><a href="#37799399">next</a><span>|</span><label class="collapse" for="c-37799036">[-]</label><label class="expand" for="c-37799036">[1 more]</label></div><br/><div class="children"><div class="content">Some people depend on undefined behavior, but there&#x27;s generally not much sympathy for it, because it is in the name.<p>On the other hand, many people have depended on interpretations of intent.<p>Changing the behavior of one is much easier for the community to swallow than the other.<p>An easy example is how early versions of IE failed to correctly implement the box model for sizing elements. For backwards compatibility reasons, IE6 and on would revert to the old, incorrect behavior if parsing the html document put it into &#x27;quirks mode&#x27;, and later on this behavior was added as an optional CSS box-sizing property.<p><a href="https:&#x2F;&#x2F;wiki.edunitas.com&#x2F;IT&#x2F;en&#x2F;114-10&#x2F;Internet-Explorer-box-model-bug_19539_eduNitas.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;wiki.edunitas.com&#x2F;IT&#x2F;en&#x2F;114-10&#x2F;Internet-Explorer-box...</a></div><br/></div></div></div></div><div id="37799399" class="c"><input type="checkbox" id="c-37799399" checked=""/><div class="controls bullet"><span class="by">olliej</span><span>|</span><a href="#37798616">root</a><span>|</span><a href="#37798693">parent</a><span>|</span><a href="#37798722">prev</a><span>|</span><a href="#37799685">next</a><span>|</span><label class="collapse" for="c-37799399">[-]</label><label class="expand" for="c-37799399">[2 more]</label></div><br/><div class="children"><div class="content">Not every html tag <i>has</i> a closing tag. &quot;&lt;br &#x2F;&gt;&quot; parsing is supported in html5 as recognizing self closing xml tags is necessary due to people publishing xhtml with an html mime type. But to be clear it&#x27;s incorrect: &lt;br&gt;...&lt;&#x2F;br&gt; is incorrect as &lt;br&gt; is a self closing tag, so the closing tag itself is erroneous.<p>In terms of validation: html5 has a specified parsing algorithm, you can validate html against it. That validation is not xml validation. Again, because html is not xml.<p>There is a very clear specification about how html tags are parsed, trying to reason about html as if it is xml is just as (if not more) incorrect than trying to reason about C as if it were C++. e.g.<p><pre><code>    void f();
</code></pre>
Is a different type in C than it is in C++, but if you do this you can&#x27;t turn around and complain that C and C++ see it as having a different type when the syntax has different meanings.</div><br/><div id="37800185" class="c"><input type="checkbox" id="c-37800185" checked=""/><div class="controls bullet"><span class="by">the_why_of_y</span><span>|</span><a href="#37798616">root</a><span>|</span><a href="#37799399">parent</a><span>|</span><a href="#37799685">next</a><span>|</span><label class="collapse" for="c-37800185">[-]</label><label class="expand" for="c-37800185">[1 more]</label></div><br/><div class="children"><div class="content">The reason why people served XHTML as text&#x2F;html was that Microsoft Internet Explorer didn&#x27;t recognize application&#x2F;xhtml+xml.<p><a href="https:&#x2F;&#x2F;hixie.ch&#x2F;advocacy&#x2F;xhtml" rel="nofollow noreferrer">https:&#x2F;&#x2F;hixie.ch&#x2F;advocacy&#x2F;xhtml</a>
<a href="https:&#x2F;&#x2F;www.w3.org&#x2F;2003&#x2F;01&#x2F;xhtml-mimetype&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.w3.org&#x2F;2003&#x2F;01&#x2F;xhtml-mimetype&#x2F;</a></div><br/></div></div></div></div></div></div><div id="37799685" class="c"><input type="checkbox" id="c-37799685" checked=""/><div class="controls bullet"><span class="by">Quekid5</span><span>|</span><a href="#37798616">parent</a><span>|</span><a href="#37798693">prev</a><span>|</span><a href="#37799745">next</a><span>|</span><label class="collapse" for="c-37799685">[-]</label><label class="expand" for="c-37799685">[1 more]</label></div><br/><div class="children"><div class="content">That seems like it would just be giving attackers a <i>different</i> Weird Machine to target. It doesn&#x27;t fundamentally change the wrongness.</div><br/></div></div></div></div><div id="37799745" class="c"><input type="checkbox" id="c-37799745" checked=""/><div class="controls bullet"><span class="by">stkdump</span><span>|</span><a href="#37798616">prev</a><span>|</span><label class="collapse" for="c-37799745">[-]</label><label class="expand" for="c-37799745">[9 more]</label></div><br/><div class="children"><div class="content">The modern insistence on (absolute) memory safety feels like another symptom of regression. It is like going back to insisting you can and should be absolutely safe from HIV by making certain lifestyle choices. In the &#x27;80s we knew that the answer was being safer, not being safe.<p>I am all for making C and C++ safer by adding mitigations for the most common security relevant bugs. Either on language level, or on tooling level or on OS level or on CPU level. Or a combination of them. But since making a language absolutely memory safe doesn&#x27;t make it automatically impossible to have bugs at all (even security relevant bugs), we should consider everything a trade-off.</div><br/><div id="37800045" class="c"><input type="checkbox" id="c-37800045" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37799745">parent</a><span>|</span><a href="#37799818">next</a><span>|</span><label class="collapse" for="c-37800045">[-]</label><label class="expand" for="c-37800045">[1 more]</label></div><br/><div class="children"><div class="content">It isn&#x27;t modern, UNIX folks decided to ignore what was being done outside Bell Labs.<p>Had UNIX not been free beer, history would have been quite different for C and C++.</div><br/></div></div><div id="37799818" class="c"><input type="checkbox" id="c-37799818" checked=""/><div class="controls bullet"><span class="by">hurril</span><span>|</span><a href="#37799745">parent</a><span>|</span><a href="#37800045">prev</a><span>|</span><a href="#37799838">next</a><span>|</span><label class="collapse" for="c-37799818">[-]</label><label class="expand" for="c-37799818">[1 more]</label></div><br/><div class="children"><div class="content">This is a silly argument. Making a language _memory safe_ protects against one class of bugs and that has merit in and of itself. The fact that there are more classes does not negate the value of that. To borrow(lol!) your own analogy here: it makes $language Safer. Not safe.</div><br/></div></div><div id="37799838" class="c"><input type="checkbox" id="c-37799838" checked=""/><div class="controls bullet"><span class="by">hurril</span><span>|</span><a href="#37799745">parent</a><span>|</span><a href="#37799818">prev</a><span>|</span><a href="#37799814">next</a><span>|</span><label class="collapse" for="c-37799838">[-]</label><label class="expand" for="c-37799838">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m new to properly native languages, but having worked with Rust for 6 months, I&#x27;ve yet to encounter a single crash that wasn&#x27;t on part of my error handling.<p>I _love_ C and I&#x27;ve written one C program every year for the last decade or two. I generally write something really stupid, but there&#x27;s going to be crashes that &quot;prints the stack pants.&quot; As in: I&#x27;ll fudge up returning the stack from a function, basically.<p>This proves nothing, of course. But Rust won&#x27;t even let me fudge things up that way. This means that I have more time to spend fixing those other classes of bugs and that is the win!</div><br/><div id="37799892" class="c"><input type="checkbox" id="c-37799892" checked=""/><div class="controls bullet"><span class="by">stkdump</span><span>|</span><a href="#37799745">root</a><span>|</span><a href="#37799838">parent</a><span>|</span><a href="#37799814">next</a><span>|</span><label class="collapse" for="c-37799892">[-]</label><label class="expand" for="c-37799892">[2 more]</label></div><br/><div class="children"><div class="content">I have been full time in C++ development for &gt;15 years. I can count the number of times I had memory correctness issues that weren&#x27;t discovered and fixed trivially on one hand, all of them very early in my career. As your adage, of course mine doesn&#x27;t prove anything.</div><br/><div id="37800093" class="c"><input type="checkbox" id="c-37800093" checked=""/><div class="controls bullet"><span class="by">lpapez</span><span>|</span><a href="#37799745">root</a><span>|</span><a href="#37799892">parent</a><span>|</span><a href="#37799814">next</a><span>|</span><label class="collapse" for="c-37800093">[-]</label><label class="expand" for="c-37800093">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t want to sound like I&#x27;m downplaying your carreer, but what kinds of projects did you work on for 15 years to have an experience this positive?<p>For instance I find it incredible that you never had to debug and workaround a third party vendor DLL that you didn&#x27;t have source for but that was leaking memory like crazy. This is the just one example of something that can be &quot;fixed trivially&quot; as you don&#x27;t have source to modify, and is extremely common in some fields (i.e. embedded)</div><br/></div></div></div></div></div></div><div id="37799814" class="c"><input type="checkbox" id="c-37799814" checked=""/><div class="controls bullet"><span class="by">dwnvotee</span><span>|</span><a href="#37799745">parent</a><span>|</span><a href="#37799838">prev</a><span>|</span><a href="#37799822">next</a><span>|</span><label class="collapse" for="c-37799814">[-]</label><label class="expand" for="c-37799814">[1 more]</label></div><br/><div class="children"><div class="content">Yup, keep the zero-days comin</div><br/></div></div><div id="37799822" class="c"><input type="checkbox" id="c-37799822" checked=""/><div class="controls bullet"><span class="by">_dain_</span><span>|</span><a href="#37799745">parent</a><span>|</span><a href="#37799814">prev</a><span>|</span><label class="collapse" for="c-37799822">[-]</label><label class="expand" for="c-37799822">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt;It is like going back to insisting you can and should be absolutely safe from HIV by making certain lifestyle choices. In the &#x27;80s we knew that the answer was being safer, not being safe.</i><p>This is a singularly bad analogy. HIV used to be a death sentence, but now we have effective treatments and prophylactics.<p>What&#x27;s the PrEP equivalent for buffer overflows? There isn&#x27;t one.</div><br/><div id="37799866" class="c"><input type="checkbox" id="c-37799866" checked=""/><div class="controls bullet"><span class="by">stkdump</span><span>|</span><a href="#37799745">root</a><span>|</span><a href="#37799822">parent</a><span>|</span><label class="collapse" for="c-37799866">[-]</label><label class="expand" for="c-37799866">[1 more]</label></div><br/><div class="children"><div class="content">Oh, there are lots of PrEP equivalents. For example NX. Or virtual memory more in general. Or static analysis. Etc etc. If you think the modern ecosystem is as memory bug prone as it was in the 80s, you are being incredibly naive.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>