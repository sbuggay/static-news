<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1705741252715" as="style"/><link rel="stylesheet" href="styles.css?v=1705741252715"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.chybby.com/posts/building-a-usb-snes-controller">Building a USB SNES Controller</a>Â <span class="domain">(<a href="https://blog.chybby.com">blog.chybby.com</a>)</span></div><div class="subtext"><span>chybby</span> | <span>98 comments</span></div><br/><div><div id="39065690" class="c"><input type="checkbox" id="c-39065690" checked=""/><div class="controls bullet"><span class="by">pipes</span><span>|</span><a href="#39060594">next</a><span>|</span><label class="collapse" for="c-39065690">[-]</label><label class="expand" for="c-39065690">[1 more]</label></div><br/><div class="children"><div class="content">Not sure if this has been mentioned already:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;MickGyver&#x2F;DaemonBite-Retro-Controllers-USB">https:&#x2F;&#x2F;github.com&#x2F;MickGyver&#x2F;DaemonBite-Retro-Controllers-US...</a><p>It&#x27;s how to build your own demon bite adapters using Arduino, for various console. These are super low lag.<p>If you Google demon bite you can find various sites selling premade adapters.<p>These are really popular with mister fpga users:<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;MiSTer" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;MiSTer</a><p>This is a bit of a rabbit hole, the mister is the best retro related thing I&#x27;ve bought &#x2F; built.<p>Here&#x27;s a useful listing of various usb adapters and their latency:<p><a href="https:&#x2F;&#x2F;rpubs.com&#x2F;misteraddons&#x2F;inputlatency" rel="nofollow">https:&#x2F;&#x2F;rpubs.com&#x2F;misteraddons&#x2F;inputlatency</a></div><br/></div></div><div id="39060594" class="c"><input type="checkbox" id="c-39060594" checked=""/><div class="controls bullet"><span class="by">allenu</span><span>|</span><a href="#39065690">prev</a><span>|</span><a href="#39056337">next</a><span>|</span><label class="collapse" for="c-39060594">[-]</label><label class="expand" for="c-39060594">[7 more]</label></div><br/><div class="children"><div class="content">Controllers are surprisingly super easy to work with and a good gateway to some basic electronics hacking.<p>I&#x27;ve actually gone the opposite direction from this post. I have a Neo Geo arcade board (JAMMA) and it has plugs for Neo Geo controllers (as in the controllers for the console version of the Neo Geo). I wanted to use the Neo Geo without plugging it into an arcade cabinet, so I got a &quot;Supergun&quot; board to play it on an RGB monitor. However, I didn&#x27;t have a controller for it.<p>I noticed that there was an emulator-based &quot;Neo Geo X&quot; system out in the wild and you could purchase a controller accessory on its own, so I got one, not realizing it was purely a USB controller in the shape of the original Neo Geo ones, but no problem. I bought a Neo Geo controller cable and just desoldered the button to USB connections inside the controller and connected them directly to the Neo Geo controller cable. Worked like a charm!</div><br/><div id="39060716" class="c"><input type="checkbox" id="c-39060716" checked=""/><div class="controls bullet"><span class="by">vikingerik</span><span>|</span><a href="#39060594">parent</a><span>|</span><a href="#39064133">next</a><span>|</span><label class="collapse" for="c-39060716">[-]</label><label class="expand" for="c-39060716">[4 more]</label></div><br/><div class="children"><div class="content">And I&#x27;ll add my controller hacking as well:<p><a href="https:&#x2F;&#x2F;imgur.com&#x2F;a&#x2F;Mu43dqg" rel="nofollow">https:&#x2F;&#x2F;imgur.com&#x2F;a&#x2F;Mu43dqg</a><p>As a poor college student, I home-built a dance pad for Dance Dance Revolution, out of wood and foil and by soldering the connections into a controller.  Worked perfectly!</div><br/><div id="39061439" class="c"><input type="checkbox" id="c-39061439" checked=""/><div class="controls bullet"><span class="by">rahimnathwani</span><span>|</span><a href="#39060594">root</a><span>|</span><a href="#39060716">parent</a><span>|</span><a href="#39060766">next</a><span>|</span><label class="collapse" for="c-39061439">[-]</label><label class="expand" for="c-39061439">[2 more]</label></div><br/><div class="children"><div class="content">I love this.<p>It probably worked better than a cheap &#x27;soft&#x27; pad.</div><br/><div id="39063438" class="c"><input type="checkbox" id="c-39063438" checked=""/><div class="controls bullet"><span class="by">RockRobotRock</span><span>|</span><a href="#39060594">root</a><span>|</span><a href="#39061439">parent</a><span>|</span><a href="#39060766">next</a><span>|</span><label class="collapse" for="c-39063438">[-]</label><label class="expand" for="c-39063438">[1 more]</label></div><br/><div class="children"><div class="content">Yes! Soft pads are the worst.</div><br/></div></div></div></div><div id="39060766" class="c"><input type="checkbox" id="c-39060766" checked=""/><div class="controls bullet"><span class="by">allenu</span><span>|</span><a href="#39060594">root</a><span>|</span><a href="#39060716">parent</a><span>|</span><a href="#39061439">prev</a><span>|</span><a href="#39064133">next</a><span>|</span><label class="collapse" for="c-39060766">[-]</label><label class="expand" for="c-39060766">[1 more]</label></div><br/><div class="children"><div class="content">Well done and good job using what looks like a cheap controller <i>and</i> aluminum foil to keep costs down. :)</div><br/></div></div></div></div><div id="39064133" class="c"><input type="checkbox" id="c-39064133" checked=""/><div class="controls bullet"><span class="by">qiqitori</span><span>|</span><a href="#39060594">parent</a><span>|</span><a href="#39060716">prev</a><span>|</span><a href="#39061309">next</a><span>|</span><label class="collapse" for="c-39064133">[-]</label><label class="expand" for="c-39064133">[1 more]</label></div><br/><div class="children"><div class="content">A while ago I was a little into controller hardware hacking and did almost the same thing but for an MSX! Even wrote a blog entry, but unfortunately in Japanese (with pictures though):
<a href="https:&#x2F;&#x2F;blog.qiqitori.com&#x2F;2022&#x2F;09&#x2F;%E6%9D%90%E6%96%99%E8%B2%BB220%E5%86%86%E3%81%A7msx%E7%94%A8%E3%81%AE%E3%82%B8%E3%83%A7%E3%82%A4%E3%83%91%E3%83%83%E3%83%89%E3%82%92%E3%82%B2%E3%83%83%E3%83%88%EF%BC%9F&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.qiqitori.com&#x2F;2022&#x2F;09&#x2F;%E6%9D%90%E6%96%99%E8%B2%B...</a><p>And one year later I also used a Raspberry Pi Pico to convert a USB controller&#x27;s signals to MSX: <a href="https:&#x2F;&#x2F;blog.qiqitori.com&#x2F;2023&#x2F;09&#x2F;using-a-usb-hid-game-controller-on-the-msx-using-a-raspberry-pi-pico&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.qiqitori.com&#x2F;2023&#x2F;09&#x2F;using-a-usb-hid-game-contr...</a><p>(And later, USB controller to Nintendo Switch, <a href="https:&#x2F;&#x2F;blog.qiqitori.com&#x2F;2023&#x2F;09&#x2F;playing-on-the-nintendo-switch-with-a-generic-usb-hid-controller-specifically-a-fake-ps3-controller&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.qiqitori.com&#x2F;2023&#x2F;09&#x2F;playing-on-the-nintendo-sw...</a>)</div><br/></div></div><div id="39061309" class="c"><input type="checkbox" id="c-39061309" checked=""/><div class="controls bullet"><span class="by">ansible</span><span>|</span><a href="#39060594">parent</a><span>|</span><a href="#39064133">prev</a><span>|</span><a href="#39056337">next</a><span>|</span><label class="collapse" for="c-39061309">[-]</label><label class="expand" for="c-39061309">[1 more]</label></div><br/><div class="children"><div class="content">Yes. I got my start, back in the day, following along a magazine article on modifying an Atari 2600 joystick for use with the Tandy Color computer. Worked fairly well too, though I ended up modifying my Galaxian arcade game clone to work with it.</div><br/></div></div></div></div><div id="39056337" class="c"><input type="checkbox" id="c-39056337" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#39060594">prev</a><span>|</span><a href="#39056991">next</a><span>|</span><label class="collapse" for="c-39056337">[-]</label><label class="expand" for="c-39056337">[8 more]</label></div><br/><div class="children"><div class="content">Looking at the described protocol it seems the SNES controller uses a simple 16-bit parallel-in-serial-out shift register - and a quick Google confirmed that.<p>This means the timing is almost certainly quite loose, and there&#x27;s a pretty decent chance you might even be able to poll it as the 1kHz &quot;needed&quot; for &quot;serious&quot; gaming. And it&#x27;d be pretty trivial to offload the readout to the MCU&#x27;s SPI peripheral.</div><br/><div id="39056881" class="c"><input type="checkbox" id="c-39056881" checked=""/><div class="controls bullet"><span class="by">toasteros</span><span>|</span><a href="#39056337">parent</a><span>|</span><a href="#39064606">next</a><span>|</span><label class="collapse" for="c-39056881">[-]</label><label class="expand" for="c-39056881">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s extremely loose! Using a custom PCB to connect the controller over RJ45 to a custom Pi hat I wrote some code to simply display the button presses on screen, to test the functionality of the controller (we are modifying hundreds). I had to play around a lot with the timings to match up the response of the program with the speed of my finger pushing a button, else the program would return &quot;you pushed B&quot; a dozen times on a single push.<p>I do wonder how much original SNES devs had to consider similar scenarios.</div><br/><div id="39057149" class="c"><input type="checkbox" id="c-39057149" checked=""/><div class="controls bullet"><span class="by">65a</span><span>|</span><a href="#39056337">root</a><span>|</span><a href="#39056881">parent</a><span>|</span><a href="#39059570">next</a><span>|</span><label class="collapse" for="c-39057149">[-]</label><label class="expand" for="c-39057149">[3 more]</label></div><br/><div class="children"><div class="content">The physical switches may actually bounce, so you might need some debounce logic, if it wasn&#x27;t the shift register glitching out. It&#x27;s pretty common for buttons to need this, often seen in keyboard firmware as well for similar reasons, the physical mechanism actually will oscillate a bit between states.</div><br/><div id="39059618" class="c"><input type="checkbox" id="c-39059618" checked=""/><div class="controls bullet"><span class="by">snitty</span><span>|</span><a href="#39056337">root</a><span>|</span><a href="#39057149">parent</a><span>|</span><a href="#39059570">next</a><span>|</span><label class="collapse" for="c-39059618">[-]</label><label class="expand" for="c-39059618">[2 more]</label></div><br/><div class="children"><div class="content">The way the NES and SNES work is that once per frame you read from the memory address mapped to the shift register to get all the bits out, one at a time. For certain inputs you only care if it&#x27;s pressed now. Others you compare to previous state to see if it changed.<p>Bounce could, theoretically, cause an input to be read as a non-input if it just bounced at exactly the wrong time, but it won&#x27;t cause multiple inputs, as it&#x27;s only polled every 1&#x2F;60th of a second.</div><br/><div id="39063554" class="c"><input type="checkbox" id="c-39063554" checked=""/><div class="controls bullet"><span class="by">65a</span><span>|</span><a href="#39056337">root</a><span>|</span><a href="#39059618">parent</a><span>|</span><a href="#39059570">next</a><span>|</span><label class="collapse" for="c-39063554">[-]</label><label class="expand" for="c-39063554">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it sounds like SNES implements debounce by just scanning slowly, but if you  want to feed USB reports at maximum (or above maximum) specification, you will  want to check the state more frequently, and you&#x27;ll need an alternate mitigation for switch bounce.</div><br/></div></div></div></div></div></div><div id="39059570" class="c"><input type="checkbox" id="c-39059570" checked=""/><div class="controls bullet"><span class="by">snitty</span><span>|</span><a href="#39056337">root</a><span>|</span><a href="#39056881">parent</a><span>|</span><a href="#39057149">prev</a><span>|</span><a href="#39064606">next</a><span>|</span><label class="collapse" for="c-39059570">[-]</label><label class="expand" for="c-39059570">[1 more]</label></div><br/><div class="children"><div class="content">Were you checking to see if the button state changed between reads? Or were you reading a 1 as &quot;down&quot; regardless of whether the previous read was &quot;up&quot;?</div><br/></div></div></div></div><div id="39064606" class="c"><input type="checkbox" id="c-39064606" checked=""/><div class="controls bullet"><span class="by">chybby</span><span>|</span><a href="#39056337">parent</a><span>|</span><a href="#39056881">prev</a><span>|</span><a href="#39057120">next</a><span>|</span><label class="collapse" for="c-39064606">[-]</label><label class="expand" for="c-39064606">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for teaching me about SPI, I might have a play around and see if I can get that working.</div><br/></div></div><div id="39057120" class="c"><input type="checkbox" id="c-39057120" checked=""/><div class="controls bullet"><span class="by">65a</span><span>|</span><a href="#39056337">parent</a><span>|</span><a href="#39064606">prev</a><span>|</span><a href="#39056991">next</a><span>|</span><label class="collapse" for="c-39057120">[-]</label><label class="expand" for="c-39057120">[1 more]</label></div><br/><div class="children"><div class="content">I converted a DOS-era joystick like this, and the shift registers inside were stable at higher speeds, I don&#x27;t remember needing to care about the timing much. I may have just run the clock in a for-loop during the polling loop.</div><br/></div></div></div></div><div id="39056991" class="c"><input type="checkbox" id="c-39056991" checked=""/><div class="controls bullet"><span class="by">xg15</span><span>|</span><a href="#39056337">prev</a><span>|</span><a href="#39057226">next</a><span>|</span><label class="collapse" for="c-39056991">[-]</label><label class="expand" for="c-39056991">[4 more]</label></div><br/><div class="children"><div class="content">This is really cool!<p>One thing I&#x27;m wondering is how the SNES implemented its Multitap support[1] with such a simple &quot;wire protocol&quot;. Could it be that the two missing wires and&#x2F;or 4 unused slots in the polling cycle are used for some kind of adressing scheme when a multitap is plugged in?<p><a href="https:&#x2F;&#x2F;nintendo.fandom.com&#x2F;wiki&#x2F;Super_Multitap" rel="nofollow">https:&#x2F;&#x2F;nintendo.fandom.com&#x2F;wiki&#x2F;Super_Multitap</a></div><br/><div id="39057435" class="c"><input type="checkbox" id="c-39057435" checked=""/><div class="controls bullet"><span class="by">ooterness</span><span>|</span><a href="#39056991">parent</a><span>|</span><a href="#39065215">next</a><span>|</span><label class="collapse" for="c-39057435">[-]</label><label class="expand" for="c-39057435">[1 more]</label></div><br/><div class="children"><div class="content">RGMX has a video series on a <i>lot</i> of the low-level SNES functions. If you&#x27;ve ever wanted to know how Mode-7 works, it&#x27;s great.<p>The video below goes over the controllers, Super Scope, mouse, etc. A brief discussion of the multi-tap starts around 16:00. You are correct that it leverages the spare pins.<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=2Dw7NFm1ZfY" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=2Dw7NFm1ZfY</a></div><br/></div></div><div id="39065215" class="c"><input type="checkbox" id="c-39065215" checked=""/><div class="controls bullet"><span class="by">dougg3</span><span>|</span><a href="#39056991">parent</a><span>|</span><a href="#39057435">prev</a><span>|</span><a href="#39057595">next</a><span>|</span><label class="collapse" for="c-39065215">[-]</label><label class="expand" for="c-39065215">[1 more]</label></div><br/><div class="children"><div class="content">The schematics for the multitap are out there in the SNES developer manual [1]. I actually made one on a breadboard for fun [2] and eventually turned it into a PCB. It&#x27;s a pretty simple circuit with an analog mux and some tri-state buffers.<p>[1] <a href="https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;SNESDevManual&#x2F;book2&#x2F;page&#x2F;n385&#x2F;mode&#x2F;2up" rel="nofollow">https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;SNESDevManual&#x2F;book2&#x2F;page&#x2F;n385&#x2F;mo...</a><p>[2] <a href="https:&#x2F;&#x2F;www.downtowndougbrown.com&#x2F;2013&#x2F;04&#x2F;homebrew-snes-4-player-multitap-adapter&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.downtowndougbrown.com&#x2F;2013&#x2F;04&#x2F;homebrew-snes-4-pl...</a></div><br/></div></div><div id="39057595" class="c"><input type="checkbox" id="c-39057595" checked=""/><div class="controls bullet"><span class="by">wharvle</span><span>|</span><a href="#39056991">parent</a><span>|</span><a href="#39065215">prev</a><span>|</span><a href="#39057226">next</a><span>|</span><label class="collapse" for="c-39057595">[-]</label><label class="expand" for="c-39057595">[1 more]</label></div><br/><div class="children"><div class="content">The NES also had âmultitapsâ. One model was wired (the âFour Scoreâ), the other was wireless (battery powered; the âSatelliteâ) with an IR receiver unit that plugged into both controller ports.<p>The IR wireless one was, in my experience (it was the only one I had) far less janky and failure-prone than one might suppose. Actually worked quite well.</div><br/></div></div></div></div><div id="39057226" class="c"><input type="checkbox" id="c-39057226" checked=""/><div class="controls bullet"><span class="by">patrickpkt</span><span>|</span><a href="#39056991">prev</a><span>|</span><a href="#39065218">next</a><span>|</span><label class="collapse" for="c-39057226">[-]</label><label class="expand" for="c-39057226">[1 more]</label></div><br/><div class="children"><div class="content">The Daemonbite project (<a href="https:&#x2F;&#x2F;github.com&#x2F;MickGyver&#x2F;DaemonBite-Retro-Controllers-USB">https:&#x2F;&#x2F;github.com&#x2F;MickGyver&#x2F;DaemonBite-Retro-Controllers-US...</a>) does essentially the same thing, but works like a normal USB controller from the perspective of the host.  I&#x27;ve used one with a MiSTer FPGA setup and it&#x27;s almost indistinguishable from a native SNES controller in terms of response.  For my build, I cut a cheap controller extension cord in half, avoiding the need to actually modify the controller itself.</div><br/></div></div><div id="39065218" class="c"><input type="checkbox" id="c-39065218" checked=""/><div class="controls bullet"><span class="by">MarioMan</span><span>|</span><a href="#39057226">prev</a><span>|</span><a href="#39062061">next</a><span>|</span><label class="collapse" for="c-39065218">[-]</label><label class="expand" for="c-39065218">[1 more]</label></div><br/><div class="children"><div class="content">I prefer a nondestructive approach. I set up an ATTINY85 clone to serve as a DIY USB adapter. Just solder a controller extension cable to the microcontroller to donate the right port, and you have everything you need. You have enough GPIO pins and the requisite 5v logic to make it a great fit. Mine was made for NES controllers, but it uses the same shift logic as the SNES controller, just with fewer buttons.</div><br/></div></div><div id="39062061" class="c"><input type="checkbox" id="c-39062061" checked=""/><div class="controls bullet"><span class="by">makapuf</span><span>|</span><a href="#39065218">prev</a><span>|</span><a href="#39055669">next</a><span>|</span><label class="collapse" for="c-39062061">[-]</label><label class="expand" for="c-39062061">[2 more]</label></div><br/><div class="children"><div class="content">I think the project is cool, but since a usb snes controller is, what 5$ on ebay (or more to have quality one), I find it too bad that you damage a working, vintage real snes controller that there will be less and less of.</div><br/><div id="39064528" class="c"><input type="checkbox" id="c-39064528" checked=""/><div class="controls bullet"><span class="by">chybby</span><span>|</span><a href="#39062061">parent</a><span>|</span><a href="#39055669">next</a><span>|</span><label class="collapse" for="c-39064528">[-]</label><label class="expand" for="c-39064528">[1 more]</label></div><br/><div class="children"><div class="content">The way I saw it, I&#x27;d rather have a memento of the past that I can actually use than one that will sit around in a drawer.</div><br/></div></div></div></div><div id="39055669" class="c"><input type="checkbox" id="c-39055669" checked=""/><div class="controls bullet"><span class="by">kilpikaarna</span><span>|</span><a href="#39062061">prev</a><span>|</span><a href="#39056041">next</a><span>|</span><label class="collapse" for="c-39055669">[-]</label><label class="expand" for="c-39055669">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve tried building an arcade stick in the past by having the Arduino emulate a keyboard and doing standard Arduino lib digitalRead of the buttons and sending keypresses (for MAME) over USB. It worked, but the lag was terrible. I wonder if this fares any better.<p>In any case, if you can handle the wait, you can get a knockoff SNES USB pad from China for a few bucks. The plastic will feel way off, but you can probably swap over the shell from your original pad with little effort.  And you&#x27;ll get fresh rubber button pads, rather than 30 year old spongy ones, as a bonus. :)</div><br/><div id="39056323" class="c"><input type="checkbox" id="c-39056323" checked=""/><div class="controls bullet"><span class="by">frameset</span><span>|</span><a href="#39055669">parent</a><span>|</span><a href="#39056041">next</a><span>|</span><label class="collapse" for="c-39056323">[-]</label><label class="expand" for="c-39056323">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re making a home made arcade stick, check out the GP2040-CE project - <a href="https:&#x2F;&#x2F;github.com&#x2F;OpenStickCommunity&#x2F;GP2040-CE">https:&#x2F;&#x2F;github.com&#x2F;OpenStickCommunity&#x2F;GP2040-CE</a><p>It&#x27;s got low latency and good compatibility for a bunch of platforms. Even some compatibility for PS4.</div><br/></div></div></div></div><div id="39056041" class="c"><input type="checkbox" id="c-39056041" checked=""/><div class="controls bullet"><span class="by">Grazester</span><span>|</span><a href="#39055669">prev</a><span>|</span><a href="#39056610">next</a><span>|</span><label class="collapse" for="c-39056041">[-]</label><label class="expand" for="c-39056041">[1 more]</label></div><br/><div class="children"><div class="content">Before the existence of Blue Retro or any commerically available adapter,  I wanted to use Playstation 4 Dual Shock wireless controllers with my Sega Saturn as an analog controller. I used the Arduino USB Shield Adapter since that supported wireless Dual Shock controller and all I needed to handle was the Saturn side of things with emulating a controller protocol so the Saturn things it had a 3D controller plugged into it.<p>This was my introduction to Arduino programming, bitmasks and direct port manipulation. I have changed the recently to not use direct port manipulation since it really isn&#x27;t need for the Saturn and I wanted to make the code more portable.<p>I have since made a wireless for the official 3D controllers for the Saturn with no noticeable latency. Something it seems is still taking others a while to figure out it. I am not doing anything fancy so I don&#x27;t know how they can&#x27;t figure that out yet. They are using Blue Retro though where as I am just using an nRF24L01. So maybe the Blue Retro is adding some unnecessary over head. This i have not released the source for though.</div><br/></div></div><div id="39056610" class="c"><input type="checkbox" id="c-39056610" checked=""/><div class="controls bullet"><span class="by">jareklupinski</span><span>|</span><a href="#39056041">prev</a><span>|</span><a href="#39055480">next</a><span>|</span><label class="collapse" for="c-39056610">[-]</label><label class="expand" for="c-39056610">[2 more]</label></div><br/><div class="children"><div class="content">my very first electronics projects were classic controller to USB conversions. I remember struggling with PIC after just wrapping my head around BASIC Stamps, and trying to follow raphnet tutorials <a href="https:&#x2F;&#x2F;www.raphnet.net&#x2F;electronique&#x2F;multiuse_tiny1&#x2F;index_en.php" rel="nofollow">https:&#x2F;&#x2F;www.raphnet.net&#x2F;electronique&#x2F;multiuse_tiny1&#x2F;index_en...</a><p>going to show this article when people ask &#x27;how do i get started with a fun electronics project&#x27; :)</div><br/><div id="39064558" class="c"><input type="checkbox" id="c-39064558" checked=""/><div class="controls bullet"><span class="by">chybby</span><span>|</span><a href="#39056610">parent</a><span>|</span><a href="#39055480">next</a><span>|</span><label class="collapse" for="c-39064558">[-]</label><label class="expand" for="c-39064558">[1 more]</label></div><br/><div class="children"><div class="content">Thank you! Glad you liked it :)</div><br/></div></div></div></div><div id="39055480" class="c"><input type="checkbox" id="c-39055480" checked=""/><div class="controls bullet"><span class="by">candiddevmike</span><span>|</span><a href="#39056610">prev</a><span>|</span><a href="#39056105">next</a><span>|</span><label class="collapse" for="c-39055480">[-]</label><label class="expand" for="c-39055480">[1 more]</label></div><br/><div class="children"><div class="content">Title should say converting a SNES controller to USB.  I was thinking there would be 3D printing involved.</div><br/></div></div><div id="39056105" class="c"><input type="checkbox" id="c-39056105" checked=""/><div class="controls bullet"><span class="by">spintin</span><span>|</span><a href="#39055480">prev</a><span>|</span><a href="#39061866">next</a><span>|</span><label class="collapse" for="c-39056105">[-]</label><label class="expand" for="c-39056105">[2 more]</label></div><br/><div class="children"><div class="content">When Toys&#x27;r Us folded in EU I bough a ton of NES Mini&#x2F;Classic I2C controllers, paired with <a href="https:&#x2F;&#x2F;www.raphnet-tech.com&#x2F;products&#x2F;wusbmote_1player_adapter_v3&#x2F;index.php" rel="nofollow">https:&#x2F;&#x2F;www.raphnet-tech.com&#x2F;products&#x2F;wusbmote_1player_adapt...</a> you have the same thing but brand new.<p>Too bad all controllers are sold out.</div><br/><div id="39056184" class="c"><input type="checkbox" id="c-39056184" checked=""/><div class="controls bullet"><span class="by">bonzini</span><span>|</span><a href="#39056105">parent</a><span>|</span><a href="#39061866">next</a><span>|</span><label class="collapse" for="c-39056184">[-]</label><label class="expand" for="c-39056184">[1 more]</label></div><br/><div class="children"><div class="content">I did the same but went for an ESP-8266 to connect over WiFi (using UDP).<p><a href="https:&#x2F;&#x2F;github.com&#x2F;bonzini&#x2F;wcc">https:&#x2F;&#x2F;github.com&#x2F;bonzini&#x2F;wcc</a> contains both the Arduino sketch and the client that runs under Linux to present a virtual input device.</div><br/></div></div></div></div><div id="39061866" class="c"><input type="checkbox" id="c-39061866" checked=""/><div class="controls bullet"><span class="by">kalium-xyz</span><span>|</span><a href="#39056105">prev</a><span>|</span><a href="#39056896">next</a><span>|</span><label class="collapse" for="c-39061866">[-]</label><label class="expand" for="c-39061866">[1 more]</label></div><br/><div class="children"><div class="content">Ive done this with the attiny85 based digisparks for various controllers. Can recommend. It has very little IO though which can be an issue</div><br/></div></div><div id="39056896" class="c"><input type="checkbox" id="c-39056896" checked=""/><div class="controls bullet"><span class="by">mfonda</span><span>|</span><a href="#39061866">prev</a><span>|</span><a href="#39055606">next</a><span>|</span><label class="collapse" for="c-39056896">[-]</label><label class="expand" for="c-39056896">[1 more]</label></div><br/><div class="children"><div class="content">This brings back memories. The first (and only) hardware project I&#x27;ve ever done is building a 4-controller multitap that connected via parallel port. It ended up working really well--lots of fun playing games on snes9x with friends.</div><br/></div></div><div id="39055606" class="c"><input type="checkbox" id="c-39055606" checked=""/><div class="controls bullet"><span class="by">snerbles</span><span>|</span><a href="#39056896">prev</a><span>|</span><a href="#39056164">next</a><span>|</span><label class="collapse" for="c-39055606">[-]</label><label class="expand" for="c-39055606">[1 more]</label></div><br/><div class="children"><div class="content">This reminds me, years back I picked up an NTT Data Super Famicom Controller [0] with the idea of adapting it to USB. An off-the shelf USB converter only handled the standard SNES&#x2F;SFC buttons and completely ignored the number pad. At the time few resources even mentioned the existence of this thing, so I put it on the shelf and promptly forgot about it for other projects.<p>[0] <a href="https:&#x2F;&#x2F;www.raphnet.net&#x2F;divers&#x2F;ntt_data_sfc_controller&#x2F;index_en.php" rel="nofollow">https:&#x2F;&#x2F;www.raphnet.net&#x2F;divers&#x2F;ntt_data_sfc_controller&#x2F;index...</a></div><br/></div></div><div id="39056164" class="c"><input type="checkbox" id="c-39056164" checked=""/><div class="controls bullet"><span class="by">amenghra</span><span>|</span><a href="#39055606">prev</a><span>|</span><a href="#39056292">next</a><span>|</span><label class="collapse" for="c-39056164">[-]</label><label class="expand" for="c-39056164">[1 more]</label></div><br/><div class="children"><div class="content">You could put all the logic in the USB connector and then not have to modify the shell.<p>See eg the OMG cable: <a href="https:&#x2F;&#x2F;mg.lol&#x2F;blog&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mg.lol&#x2F;blog&#x2F;</a></div><br/></div></div><div id="39056292" class="c"><input type="checkbox" id="c-39056292" checked=""/><div class="controls bullet"><span class="by">MarkusWandel</span><span>|</span><a href="#39056164">prev</a><span>|</span><a href="#39055557">next</a><span>|</span><label class="collapse" for="c-39056292">[-]</label><label class="expand" for="c-39056292">[1 more]</label></div><br/><div class="children"><div class="content">I did something similar by cutting down the PCB of a standard Microsoft game controller and wiring it into an old Wico Command Control joystick (the only thing I kept when I gave away all my C64 stuff - before it became collectible).<p><a href="https:&#x2F;&#x2F;wandel.ca&#x2F;pic.cgi?49ceb103" rel="nofollow">https:&#x2F;&#x2F;wandel.ca&#x2F;pic.cgi?49ceb103</a><p>Totally authentic for playing old C64 games in an emulator.  But these days, I&#x27;d leave the joystick alone and just use an Arduino to do a DB9 to USB translator.</div><br/></div></div><div id="39055557" class="c"><input type="checkbox" id="c-39055557" checked=""/><div class="controls bullet"><span class="by">nkozyra</span><span>|</span><a href="#39056292">prev</a><span>|</span><a href="#39057025">next</a><span>|</span><label class="collapse" for="c-39055557">[-]</label><label class="expand" for="c-39055557">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m fairly novice with Arduino and interfacing with buttons&#x2F;pots but I thought delays &#x2F; loop interrupts were discouraged versus a reset-able counter variable?</div><br/><div id="39055639" class="c"><input type="checkbox" id="c-39055639" checked=""/><div class="controls bullet"><span class="by">Goz3rr</span><span>|</span><a href="#39055557">parent</a><span>|</span><a href="#39057025">next</a><span>|</span><label class="collapse" for="c-39055639">[-]</label><label class="expand" for="c-39055639">[1 more]</label></div><br/><div class="children"><div class="content">They are if you have anything else that needs to be done at the same time. I would say they&#x27;re fine if you have nothing else to do while waiting, or you need microsecond delays to generate a signal like in this case.</div><br/></div></div></div></div><div id="39057025" class="c"><input type="checkbox" id="c-39057025" checked=""/><div class="controls bullet"><span class="by">hellweaver666</span><span>|</span><a href="#39055557">prev</a><span>|</span><a href="#39056892">next</a><span>|</span><label class="collapse" for="c-39057025">[-]</label><label class="expand" for="c-39057025">[3 more]</label></div><br/><div class="children"><div class="content">I once modified a SNES controller and put a whole Raspberry Pi Zero, battery and boost&#x2F;charger board inside for a portable retropie setup.</div><br/><div id="39057548" class="c"><input type="checkbox" id="c-39057548" checked=""/><div class="controls bullet"><span class="by">wayvey</span><span>|</span><a href="#39057025">parent</a><span>|</span><a href="#39056892">next</a><span>|</span><label class="collapse" for="c-39057548">[-]</label><label class="expand" for="c-39057548">[2 more]</label></div><br/><div class="children"><div class="content">Wow, that would be incredible! Did you document the project at all? I&#x27;d love to know more and maybe attempt something similar.</div><br/><div id="39059045" class="c"><input type="checkbox" id="c-39059045" checked=""/><div class="controls bullet"><span class="by">hellweaver666</span><span>|</span><a href="#39057025">root</a><span>|</span><a href="#39057548">parent</a><span>|</span><a href="#39056892">next</a><span>|</span><label class="collapse" for="c-39059045">[-]</label><label class="expand" for="c-39059045">[1 more]</label></div><br/><div class="children"><div class="content">I just followed this guide. Itâs pretty straightforward! <a href="https:&#x2F;&#x2F;hackaday.io&#x2F;project&#x2F;16288&#x2F;instructions" rel="nofollow">https:&#x2F;&#x2F;hackaday.io&#x2F;project&#x2F;16288&#x2F;instructions</a></div><br/></div></div></div></div></div></div><div id="39056892" class="c"><input type="checkbox" id="c-39056892" checked=""/><div class="controls bullet"><span class="by">r0bbbo</span><span>|</span><a href="#39057025">prev</a><span>|</span><a href="#39055578">next</a><span>|</span><label class="collapse" for="c-39056892">[-]</label><label class="expand" for="c-39056892">[5 more]</label></div><br/><div class="children"><div class="content">Are there any implications of the polling rate not quite aligning as the original controller would&#x27;ve?</div><br/><div id="39060433" class="c"><input type="checkbox" id="c-39060433" checked=""/><div class="controls bullet"><span class="by">armada651</span><span>|</span><a href="#39056892">parent</a><span>|</span><a href="#39059880">next</a><span>|</span><label class="collapse" for="c-39060433">[-]</label><label class="expand" for="c-39060433">[2 more]</label></div><br/><div class="children"><div class="content">Yeah I too wondered why the author would target 60Hz at all. The fact that the SNES controller is polled at 60Hz is simply a consequence of the game reading the input at that rate. As mentioned in the other comment in this setup the polling of the controller is not in sync with the game reading the input at all. Thus even if you target a polling rate of 60Hz perfectly you&#x27;d actually have worse input latency than the original hardware.<p>It would be much better to target 120Hz or higher to reduce input latency and bring it as close to the original hardware as possible by ensuring there is always an up-to-date input state ready for the game to read.</div><br/><div id="39064457" class="c"><input type="checkbox" id="c-39064457" checked=""/><div class="controls bullet"><span class="by">chybby</span><span>|</span><a href="#39056892">root</a><span>|</span><a href="#39060433">parent</a><span>|</span><a href="#39059880">next</a><span>|</span><label class="collapse" for="c-39064457">[-]</label><label class="expand" for="c-39064457">[1 more]</label></div><br/><div class="children"><div class="content">I had a feeling the polling rate was probably to do with the frame rate of the SNES rather than some requirement of the controller. I&#x27;ll try out a higher polling rate and see what happens.</div><br/></div></div></div></div><div id="39059880" class="c"><input type="checkbox" id="c-39059880" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#39056892">parent</a><span>|</span><a href="#39060433">prev</a><span>|</span><a href="#39055578">next</a><span>|</span><label class="collapse" for="c-39059880">[-]</label><label class="expand" for="c-39059880">[2 more]</label></div><br/><div class="children"><div class="content">If for the sake of argument we are plugging this into an SNES emulator running at 60Hz, then the stack between the USB gamepad and the emulator already has to handle that the gamepad is not rigidly synced to the emulated SNES and will presumably take every input from the gamepad and use it as the emulated input to the SNES next time it asks, unless a new one comes in first.<p>At slightly faster than 60Hz, the net effect will be that the delay between input and having an effect on the SNES will wander about 1&#x2F;60th of a second over time, as the sync varies, and every once in a while a particular input will be overwritten before it makes it into the emulator. It may be very difficult to perceive this, though, due to other delays already built into such a set up. On a real SNES, it would be right on the edge of perception anyhow.<p>Being very close to the poll rate but not quite there is probably near the theoretically worst case. It would probably be much better to poll at 240+Hz, cutting the latency between input to a consistent 1&#x2F;4ish of a frame. However, I doubt this improvement could be &quot;felt&quot; by very many people at all.</div><br/></div></div></div></div><div id="39055578" class="c"><input type="checkbox" id="c-39055578" checked=""/><div class="controls bullet"><span class="by">drzaiusx11</span><span>|</span><a href="#39056892">prev</a><span>|</span><a href="#39057647">next</a><span>|</span><label class="collapse" for="c-39055578">[-]</label><label class="expand" for="c-39055578">[2 more]</label></div><br/><div class="children"><div class="content">Great write-up. Next logical step is adding Bluetooth support so you can use it on the Switch:
<a href="https:&#x2F;&#x2F;www.instructables.com&#x2F;DIY-ESP32-Bluetooth-GamePad-for-Android-PlayStatio&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.instructables.com&#x2F;DIY-ESP32-Bluetooth-GamePad-fo...</a></div><br/><div id="39055644" class="c"><input type="checkbox" id="c-39055644" checked=""/><div class="controls bullet"><span class="by">snerbles</span><span>|</span><a href="#39055578">parent</a><span>|</span><a href="#39057647">next</a><span>|</span><label class="collapse" for="c-39055644">[-]</label><label class="expand" for="c-39055644">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t forget that these controllers operate at 5V logic and the ESP32 at 3.3V. Supposedly the ESP32 can tolerate 5V inputs [0], but it&#x27;s probably best to put a level shifter between the two.</div><br/></div></div></div></div><div id="39057647" class="c"><input type="checkbox" id="c-39057647" checked=""/><div class="controls bullet"><span class="by">daneel_w</span><span>|</span><a href="#39055578">prev</a><span>|</span><a href="#39056767">next</a><span>|</span><label class="collapse" for="c-39057647">[-]</label><label class="expand" for="c-39057647">[1 more]</label></div><br/><div class="children"><div class="content">These, as well as NES dittos, were all over eBay and AliExpress for $3 a piece some 10 years ago. Probably still are. I&#x27;ve got one of each, just to get the right feeling when playing Zelda 1 and Pocky &amp; Rocky on emulators.</div><br/></div></div><div id="39056767" class="c"><input type="checkbox" id="c-39056767" checked=""/><div class="controls bullet"><span class="by">itslennysfault</span><span>|</span><a href="#39057647">prev</a><span>|</span><a href="#39057013">next</a><span>|</span><label class="collapse" for="c-39056767">[-]</label><label class="expand" for="c-39056767">[2 more]</label></div><br/><div class="children"><div class="content">This is AWESOME. I set out to do exactly this like a decade ago and couldn&#x27;t figure out how. I still have the two SNES controllers in my electronics box and dozens of Arduinos. Looks like I&#x27;ll be making some USB SNES controllers this weekend.</div><br/><div id="39064538" class="c"><input type="checkbox" id="c-39064538" checked=""/><div class="controls bullet"><span class="by">chybby</span><span>|</span><a href="#39056767">parent</a><span>|</span><a href="#39057013">next</a><span>|</span><label class="collapse" for="c-39064538">[-]</label><label class="expand" for="c-39064538">[1 more]</label></div><br/><div class="children"><div class="content">Have fun!</div><br/></div></div></div></div><div id="39057013" class="c"><input type="checkbox" id="c-39057013" checked=""/><div class="controls bullet"><span class="by">hellweaver666</span><span>|</span><a href="#39056767">prev</a><span>|</span><a href="#39060585">next</a><span>|</span><label class="collapse" for="c-39057013">[-]</label><label class="expand" for="c-39057013">[1 more]</label></div><br/><div class="children"><div class="content">I bet you could build something like this with a Seeeduino Xiao (or Adafruit QTPY) to get a smaller footprint inside the case and not need to modify the plastic.</div><br/></div></div><div id="39060585" class="c"><input type="checkbox" id="c-39060585" checked=""/><div class="controls bullet"><span class="by">jdelman</span><span>|</span><a href="#39057013">prev</a><span>|</span><a href="#39057190">next</a><span>|</span><label class="collapse" for="c-39060585">[-]</label><label class="expand" for="c-39060585">[5 more]</label></div><br/><div class="children"><div class="content">Is Arduino real-time? I.e. is a 6 millisecond delay guaranteed to actually be 6 milliseconds?</div><br/><div id="39060936" class="c"><input type="checkbox" id="c-39060936" checked=""/><div class="controls bullet"><span class="by">mcpherrinm</span><span>|</span><a href="#39060585">parent</a><span>|</span><a href="#39062836">next</a><span>|</span><label class="collapse" for="c-39060936">[-]</label><label class="expand" for="c-39060936">[1 more]</label></div><br/><div class="children"><div class="content">The Arduino is a single-threaded microcontroller running a single code loop, plus interrupts.<p>delayMicroseconds is a busy-wait loop, so is relatively precise (to within a few instruction&#x27;s execution time.<p>However, interrupts can happen during that sleep, and the time spent handling interrupts won&#x27;t be accounted for properly.<p>It isn&#x27;t a real real-time system, but for a project like this, it&#x27;ll be good enough.</div><br/></div></div><div id="39062836" class="c"><input type="checkbox" id="c-39062836" checked=""/><div class="controls bullet"><span class="by">vvoid</span><span>|</span><a href="#39060585">parent</a><span>|</span><a href="#39060936">prev</a><span>|</span><a href="#39060918">next</a><span>|</span><label class="collapse" for="c-39062836">[-]</label><label class="expand" for="c-39062836">[2 more]</label></div><br/><div class="children"><div class="content">Yes, it is real time, but due to interrupts you have to manage critical sections with cli() and sei() and your time base is a 16.000 MHz crystal.<p>Most instructions for ATmega and ATtiny execute in 1 clock cycle so writing deterministic, time-critical code is straightforward.</div><br/><div id="39064504" class="c"><input type="checkbox" id="c-39064504" checked=""/><div class="controls bullet"><span class="by">chybby</span><span>|</span><a href="#39060585">root</a><span>|</span><a href="#39062836">parent</a><span>|</span><a href="#39060918">next</a><span>|</span><label class="collapse" for="c-39064504">[-]</label><label class="expand" for="c-39064504">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the tip to turn off interrupts when working with precise timing!</div><br/></div></div></div></div><div id="39060918" class="c"><input type="checkbox" id="c-39060918" checked=""/><div class="controls bullet"><span class="by">AYoung010</span><span>|</span><a href="#39060585">parent</a><span>|</span><a href="#39062836">prev</a><span>|</span><a href="#39057190">next</a><span>|</span><label class="collapse" for="c-39060918">[-]</label><label class="expand" for="c-39060918">[1 more]</label></div><br/><div class="children"><div class="content">Largely, yes. Arduino code runs on bare metal, and delays simply block execution so they should be accurate with some constant overhead.</div><br/></div></div></div></div><div id="39057190" class="c"><input type="checkbox" id="c-39057190" checked=""/><div class="controls bullet"><span class="by">hackan</span><span>|</span><a href="#39060585">prev</a><span>|</span><a href="#39057934">next</a><span>|</span><label class="collapse" for="c-39057190">[-]</label><label class="expand" for="c-39057190">[2 more]</label></div><br/><div class="children"><div class="content">I built a gamepad port snes adapter a decade ago, 10&#x2F;10 would do this :ok_hand:</div><br/><div id="39057210" class="c"><input type="checkbox" id="c-39057210" checked=""/><div class="controls bullet"><span class="by">rrr_oh_man</span><span>|</span><a href="#39057190">parent</a><span>|</span><a href="#39057934">next</a><span>|</span><label class="collapse" for="c-39057210">[-]</label><label class="expand" for="c-39057210">[1 more]</label></div><br/><div class="children"><div class="content">:thumbs_up:</div><br/></div></div></div></div><div id="39055355" class="c"><input type="checkbox" id="c-39055355" checked=""/><div class="controls bullet"><span class="by">onli</span><span>|</span><a href="#39057934">prev</a><span>|</span><a href="#39055743">next</a><span>|</span><label class="collapse" for="c-39055355">[-]</label><label class="expand" for="c-39055355">[19 more]</label></div><br/><div class="children"><div class="content">Of course completely awesome to make a modification like this.<p>However, if you yourself want a USB SNES controller, consider buying one instead. 8BitDo offers them with the SN 30 Pro - the quality is good, they work with the Nintendo Switch or PC (including Linux), they have the additional buttons needed for modern games, there is a wired and a wireless version and the newer variant has afaik a replaceable battery (unlike the first).<p><i>Edit:</i> I was probably wrong about the replaceable battery, that was the 8BitDo Pro 2. Which might indeed be the better choice. Looks less like a SNES controller, but at least still has the correct button labels and core layout, see <a href="https:&#x2F;&#x2F;www.8bitdo.com&#x2F;pro2&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.8bitdo.com&#x2F;pro2&#x2F;</a></div><br/><div id="39055509" class="c"><input type="checkbox" id="c-39055509" checked=""/><div class="controls bullet"><span class="by">edwcross</span><span>|</span><a href="#39055355">parent</a><span>|</span><a href="#39057279">next</a><span>|</span><label class="collapse" for="c-39055509">[-]</label><label class="expand" for="c-39055509">[7 more]</label></div><br/><div class="children"><div class="content">I did try different 8BitDo controllers, and one issue with them is the &quot;multi-mode&quot;: in order to make them work with Android&#x2F;iOS&#x2F;Windows&#x2F;whatever, you need to press some key <i>before</i> connecting them, to change the way the OS recognizes the input. Which is a deal-breaker for small children, and prevents keeping things simple (e.g. &quot;remember to disconnect and reconnect the USB before turning the power on&quot;, e.g. when using a Raspberry Pi-based console emulator). For wireless controllers, it&#x27;s even worse (extra Bluetooth mode). If only they had mechanical switches to select this behavior... You may need to keep the instructions booklet with it, just to remember which keys must be pressed before turning it on, to see which mode will be activated. The controller in TFA is more useful in this scenario, since it will always behave in the same way.</div><br/><div id="39055794" class="c"><input type="checkbox" id="c-39055794" checked=""/><div class="controls bullet"><span class="by">stickmangallows</span><span>|</span><a href="#39055355">root</a><span>|</span><a href="#39055509">parent</a><span>|</span><a href="#39055838">next</a><span>|</span><label class="collapse" for="c-39055794">[-]</label><label class="expand" for="c-39055794">[1 more]</label></div><br/><div class="children"><div class="content">The ones I have (SF30&#x2F;SN30) remember which mode they&#x27;re in so I just press the start button and it connects to my Switch. Then if I change it to bluetooth, it&#x27;s the same for my Steam link until I switch it back. Plus there&#x27;s a sticker on the back that gives the combos to change modes (Y+Start=Switch, X+Start=Bluetooth, etc). Some models, like the Lite 2, do have that physical mode switch.</div><br/></div></div><div id="39055838" class="c"><input type="checkbox" id="c-39055838" checked=""/><div class="controls bullet"><span class="by">wingmanjd</span><span>|</span><a href="#39055355">root</a><span>|</span><a href="#39055509">parent</a><span>|</span><a href="#39055794">prev</a><span>|</span><a href="#39055568">next</a><span>|</span><label class="collapse" for="c-39055838">[-]</label><label class="expand" for="c-39055838">[1 more]</label></div><br/><div class="children"><div class="content">I have four of the bluetooth SN30&#x27;s for couch co-op games on my SteamDeck. I agree that if I switched between devices often (like my son&#x27;s switch) I&#x27;d need a lookup table for the power-on chording. Mine have the key combinations printed onto the label on the back.<p>Fwiw, the ones I have remember their last pairing setup, so I only need to power them back on via the &quot;Start&quot; button.</div><br/></div></div><div id="39055568" class="c"><input type="checkbox" id="c-39055568" checked=""/><div class="controls bullet"><span class="by">onli</span><span>|</span><a href="#39055355">root</a><span>|</span><a href="#39055509">parent</a><span>|</span><a href="#39055838">prev</a><span>|</span><a href="#39060658">next</a><span>|</span><label class="collapse" for="c-39055568">[-]</label><label class="expand" for="c-39055568">[3 more]</label></div><br/><div class="children"><div class="content">Completely agree. I even had that situation myself - I misremembered how the mode switch&#x2F;bluetooth pairing mode worked and was not able to connect my controller to a switch, thinking it was broken, until I realized what had happened. A small toggle switch really would be much easier.<p>Still think it&#x27;s worth it, also to not destroy an original one. On the other hand, better to modify it like this than to throw it away of course...</div><br/><div id="39056561" class="c"><input type="checkbox" id="c-39056561" checked=""/><div class="controls bullet"><span class="by">JamesSwift</span><span>|</span><a href="#39055355">root</a><span>|</span><a href="#39055568">parent</a><span>|</span><a href="#39060658">next</a><span>|</span><label class="collapse" for="c-39056561">[-]</label><label class="expand" for="c-39056561">[2 more]</label></div><br/><div class="children"><div class="content">The new version does actually use a switch instead of the magic button combination. Agreed on the previous version being annoying. Had many kid debugging sessions when they accidentally switched the mode and âbrokeâ it.</div><br/><div id="39057024" class="c"><input type="checkbox" id="c-39057024" checked=""/><div class="controls bullet"><span class="by">65a</span><span>|</span><a href="#39055355">root</a><span>|</span><a href="#39056561">parent</a><span>|</span><a href="#39060658">next</a><span>|</span><label class="collapse" for="c-39057024">[-]</label><label class="expand" for="c-39057024">[1 more]</label></div><br/><div class="children"><div class="content">Wireless ones have a switch, the wired ones all have the &quot;maybe you have to hold a letter depending on the game, kernel version and OS&quot; problem.</div><br/></div></div></div></div></div></div></div></div><div id="39057279" class="c"><input type="checkbox" id="c-39057279" checked=""/><div class="controls bullet"><span class="by">patrickpkt</span><span>|</span><a href="#39055355">parent</a><span>|</span><a href="#39055509">prev</a><span>|</span><a href="#39056886">next</a><span>|</span><label class="collapse" for="c-39057279">[-]</label><label class="expand" for="c-39057279">[2 more]</label></div><br/><div class="children"><div class="content">I speed run Zelda 2, though using an SNES controller.  My experience with 8BitDo controllers is that they&#x27;re stiffer than OEM, especially with the d-pad arrow keys.  If you can use the analog inputs, they&#x27;re great -- I use a Pro 2 with my Switch all the time.  The d-pad, though, is a deal-breaker for classic gaming.  iBuffalo used to make a controller that really did feel like OEM, but they&#x27;ve been out of the business for a few years.</div><br/><div id="39059169" class="c"><input type="checkbox" id="c-39059169" checked=""/><div class="controls bullet"><span class="by">bondant</span><span>|</span><a href="#39055355">root</a><span>|</span><a href="#39057279">parent</a><span>|</span><a href="#39056886">next</a><span>|</span><label class="collapse" for="c-39059169">[-]</label><label class="expand" for="c-39059169">[1 more]</label></div><br/><div class="children"><div class="content">Can only recommend the iBuffalo SNES controller too, I have two of them and they are quite good. Didn&#x27;t know the brand stopped making them, it&#x27;s a pity.</div><br/></div></div></div></div><div id="39056886" class="c"><input type="checkbox" id="c-39056886" checked=""/><div class="controls bullet"><span class="by">Lutzb</span><span>|</span><a href="#39055355">parent</a><span>|</span><a href="#39057279">prev</a><span>|</span><a href="#39056555">next</a><span>|</span><label class="collapse" for="c-39056886">[-]</label><label class="expand" for="c-39056886">[1 more]</label></div><br/><div class="children"><div class="content">There is also the 8BitDo Mod Kit for SNES&#x2F;SFC Classic Edition Controller which allows to convert original SNES controllers to bluetooth. <a href="https:&#x2F;&#x2F;shop.8bitdo.com&#x2F;products&#x2F;8bitdo-mod-kit-for-snes-sfc-classic-edition-controller-new-edition" rel="nofollow">https:&#x2F;&#x2F;shop.8bitdo.com&#x2F;products&#x2F;8bitdo-mod-kit-for-snes-sfc...</a></div><br/></div></div><div id="39056555" class="c"><input type="checkbox" id="c-39056555" checked=""/><div class="controls bullet"><span class="by">erremerre</span><span>|</span><a href="#39055355">parent</a><span>|</span><a href="#39056886">prev</a><span>|</span><a href="#39055522">next</a><span>|</span><label class="collapse" for="c-39056555">[-]</label><label class="expand" for="c-39056555">[2 more]</label></div><br/><div class="children"><div class="content">Maybe if you want to play super mario, the 8bitdo sn30pro works.<p>But it has a huge problem of false diagonals, making is absolutely worthless to play tetris, or any fighting game that requires precise control. If you need precise controls, avoid this model.</div><br/><div id="39056700" class="c"><input type="checkbox" id="c-39056700" checked=""/><div class="controls bullet"><span class="by">onli</span><span>|</span><a href="#39055355">root</a><span>|</span><a href="#39056555">parent</a><span>|</span><a href="#39055522">next</a><span>|</span><label class="collapse" for="c-39056700">[-]</label><label class="expand" for="c-39056700">[1 more]</label></div><br/><div class="children"><div class="content">I have the SF30 Pro since a few years now and there might have been different revisions, but I definitely did not observe that. And I played through Hollow Knight with it, so I doubt that the controls are imprecise - I would not have had succeeded. Granted though, neither tried Tetris nor a classical fighting game.</div><br/></div></div></div></div><div id="39055522" class="c"><input type="checkbox" id="c-39055522" checked=""/><div class="controls bullet"><span class="by">ludocode</span><span>|</span><a href="#39055355">parent</a><span>|</span><a href="#39056555">prev</a><span>|</span><a href="#39057162">next</a><span>|</span><label class="collapse" for="c-39055522">[-]</label><label class="expand" for="c-39055522">[2 more]</label></div><br/><div class="children"><div class="content">8BitDo makes great controllers. I have an SN30 Pro, a Zero 2 and a pair of Ultimate Cs. All of them have been used extensively and they are all excellent quality.<p>On the other hand I&#x27;ve had back luck with generic NES and SNES knockoff USB controllers. The quality is much worse than the originals especially in the D-Pad. It seems nobody but 8BitDo can get this right.<p>If you stick with 8BitDo you&#x27;ll have great quality but they don&#x27;t necessarily match the form factor of the originals. I can see why OP would want to convert a real one.</div><br/><div id="39055607" class="c"><input type="checkbox" id="c-39055607" checked=""/><div class="controls bullet"><span class="by">onli</span><span>|</span><a href="#39055355">root</a><span>|</span><a href="#39055522">parent</a><span>|</span><a href="#39057162">next</a><span>|</span><label class="collapse" for="c-39055607">[-]</label><label class="expand" for="c-39055607">[1 more]</label></div><br/><div class="children"><div class="content">The form factor is really close though. Ignoring the added buttons, which is completely possible while gaming, it does not feel much different. <a href="https:&#x2F;&#x2F;www.onli-blogging.de&#x2F;uploads&#x2F;sf30pro.jpg" rel="nofollow">https:&#x2F;&#x2F;www.onli-blogging.de&#x2F;uploads&#x2F;sf30pro.jpg</a> for an example picture :)</div><br/></div></div></div></div><div id="39057162" class="c"><input type="checkbox" id="c-39057162" checked=""/><div class="controls bullet"><span class="by">jbverschoor</span><span>|</span><a href="#39055355">parent</a><span>|</span><a href="#39055522">prev</a><span>|</span><a href="#39057009">next</a><span>|</span><label class="collapse" for="c-39057162">[-]</label><label class="expand" for="c-39057162">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not the same...  It&#x27;s like buying a non-nintendo controller in the past. They simply don&#x27;t feel and respond the same</div><br/></div></div><div id="39057009" class="c"><input type="checkbox" id="c-39057009" checked=""/><div class="controls bullet"><span class="by">65a</span><span>|</span><a href="#39055355">parent</a><span>|</span><a href="#39057162">prev</a><span>|</span><a href="#39057115">next</a><span>|</span><label class="collapse" for="c-39057009">[-]</label><label class="expand" for="c-39057009">[1 more]</label></div><br/><div class="children"><div class="content">I wish they would have proper Linux and fwupd support, which they seem to have dropped.</div><br/></div></div><div id="39057115" class="c"><input type="checkbox" id="c-39057115" checked=""/><div class="controls bullet"><span class="by">mikepurvis</span><span>|</span><a href="#39055355">parent</a><span>|</span><a href="#39057009">prev</a><span>|</span><a href="#39058582">next</a><span>|</span><label class="collapse" for="c-39057115">[-]</label><label class="expand" for="c-39057115">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m using the 8BitDo wireless pads on my Switch and am very happy with themâ vastly more comfortable than joycons, but a fraction of the price of the official pro controller.</div><br/></div></div></div></div><div id="39055743" class="c"><input type="checkbox" id="c-39055743" checked=""/><div class="controls bullet"><span class="by">lopis</span><span>|</span><a href="#39055355">prev</a><span>|</span><a href="#39055749">next</a><span>|</span><label class="collapse" for="c-39055743">[-]</label><label class="expand" for="c-39055743">[8 more]</label></div><br/><div class="children"><div class="content">Reminds me of that meme that says<p>&gt; Look What They Need to Mimic a Fraction of Our Power!<p>That tiny arduino has a 16Mhz chip, while the NES main CPU ran at 1.66 MHz. Just a funny fact :)</div><br/><div id="39056887" class="c"><input type="checkbox" id="c-39056887" checked=""/><div class="controls bullet"><span class="by">raldi</span><span>|</span><a href="#39055743">parent</a><span>|</span><a href="#39056804">next</a><span>|</span><label class="collapse" for="c-39056887">[-]</label><label class="expand" for="c-39056887">[2 more]</label></div><br/><div class="children"><div class="content">In that case, youâll love tom7âs Reverse Emulation video:
<a href="https:&#x2F;&#x2F;youtube.com&#x2F;watch?v=ar9WRwCiSr0" rel="nofollow">https:&#x2F;&#x2F;youtube.com&#x2F;watch?v=ar9WRwCiSr0</a></div><br/><div id="39057306" class="c"><input type="checkbox" id="c-39057306" checked=""/><div class="controls bullet"><span class="by">lopis</span><span>|</span><a href="#39055743">root</a><span>|</span><a href="#39056887">parent</a><span>|</span><a href="#39056804">next</a><span>|</span><label class="collapse" for="c-39057306">[-]</label><label class="expand" for="c-39057306">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re totally right. I loved it, thanks!</div><br/></div></div></div></div><div id="39056804" class="c"><input type="checkbox" id="c-39056804" checked=""/><div class="controls bullet"><span class="by">cybrox</span><span>|</span><a href="#39055743">parent</a><span>|</span><a href="#39056887">prev</a><span>|</span><a href="#39057547">next</a><span>|</span><label class="collapse" for="c-39056804">[-]</label><label class="expand" for="c-39056804">[2 more]</label></div><br/><div class="children"><div class="content">I once designed a custom PCB that fits inside the original NES four score case.
You can connect 4 NES controllers to it and the inputs were sent to a Raspberry Pi via UDP (so no wire between couch table and TV was needed).<p>I think my PCB had more parts for its simple power supply than all 4 NES controllers combined.<p>These things are an absolute masterpiece of simplicity!</div><br/><div id="39056835" class="c"><input type="checkbox" id="c-39056835" checked=""/><div class="controls bullet"><span class="by">toasteros</span><span>|</span><a href="#39055743">root</a><span>|</span><a href="#39056804">parent</a><span>|</span><a href="#39057547">next</a><span>|</span><label class="collapse" for="c-39056835">[-]</label><label class="expand" for="c-39056835">[1 more]</label></div><br/><div class="children"><div class="content">My coworker has done a similar thing, designing a PCB that allows us to connect the SNES controller over RJ45 to a custom Pi hat. We have students writing bare metal code for it!</div><br/></div></div></div></div><div id="39057547" class="c"><input type="checkbox" id="c-39057547" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#39055743">parent</a><span>|</span><a href="#39056804">prev</a><span>|</span><a href="#39057445">next</a><span>|</span><label class="collapse" for="c-39057547">[-]</label><label class="expand" for="c-39057547">[1 more]</label></div><br/><div class="children"><div class="content">That 16MHz of processing power is doing a pretty magical thing, though. It&#x27;s encapsulating what is basically a serial bus, into a <i>universal</i> serial bus â i.e. it&#x27;s making it so that:<p>â¢ you can plug this controller into any USB host, and the host can probe the device and discover that it&#x27;s got a USB HID gamepad device<p>â¢ the SNES buttons get mapped onto standard USB HID event codes (HID Usage IDs), such that you could have a SNES controller plugged into one USB port and a Sega Saturn controller plugged into another USB port on the same computer, and they&#x27;d both be using a common language for events like &quot;D-Pad Up button pressed&quot;, such that a framework like DirectInput or SDL can understand that out of the box. The SNES just uses the same 16 bits of input register no matter what&#x27;s plugged in (gamepad, mouse, super scope, etc) â with games either <i>assuming</i> a specific static input device type and thus parsing those 16 bits in terms of that; <i>or</i> telling you to have a gamepad on P1 and whatever on P2, and then asking you on startup what type of thing you&#x27;ve got plugged into P2.<p>â¢ And â not so applicable to the SNES â but with USB, you can also have <i>more than one</i> of any given HID Usage ID reported by the same device. A gamepad with two analogue sticks <i>can</i>â  just report analogue data for X&#x2F;Y&#x2F;Z-axis Usage IDs twice.<p>â¢ You can also have as many USB HID gamepads plugged into the same host machine at the same time as you likeâ . Even USB 1.1 is a very fast bus compared to the SNES&#x27;s input polling rate; tons of HID reports will &quot;fit&quot; down the pipe as packets. The SNES, meanwhile, fundamentally only supported four input devices at once, because the hardware had exactly 64 bits mapped starting at $4218, representing the 16-bit readouts from polling of up to four input devices. And even then, if you wanted all four inputs to be polled, then you&#x27;d only be getting input for devices 1+3 refreshed on even frames, and 2+4 polled on odd frames.<p>â¢ You can have tons of other things â more data-intensive things! â plugged into the USB bus at the same time as the gamepad, and it&#x27;ll still work just fine, because USB HID reports are given high QoS by USB host controllers and hubs. The SNES needs a separate bus for the cartridge, but on a PC the equivalent of a &quot;cartridge&quot; (an eGPU + eFPGA + NVMe, let&#x27;s say?) could be connected to a USB4 dock, that your gamepad is also plugged into â and a single USB cable will take all that into your computer.<p>â¢ You can hotplug USB devices, without confusing either the client input device or the running program on the host. Both sides of a USB link (well, assuming the client retains power when unplugged) have knowledge of the connection lifecycle state. &quot;Device unplugged&quot; or &quot;device plugged in&quot; or even &quot;a new, second device plugged in&quot; are just like any other gamepad events, that your game can have a handler for. Meanwhile on the SNES, both input ports are just <i>assumed</i> to be populated at all times â and are therefore electrically liveâ¡ and receiving a polling clock at all times. The distinction between there being 1&#x2F;2&#x2F;3&#x2F;4 input devices connected, has to be made manually, by the game asking. There&#x27;s no way for the game to know that a device was plugged&#x2F;unplugged.<p>---<p>â  Consumer OSes mostly don&#x27;t like this â but that&#x27;s because consumer OSes are dumb, and have <i>to this day</i> never surfaced a high-level &quot;gamepad API&quot; that actually exposes the full extensibility of USB HID reporting.<p>A high-level API that was actually designed to reflect the HID spec, would have an input-event report be a dictionary where the keys are usage IDs and the values are <i>arrays</i> of sensor readouts. Or a stream of polymorphic Usage-ID-keyed sensor-readout records. And either way, each report would at the very least identify <i>which</i> USB device it&#x27;s coming from, so that you can tell apart reports from two identical controllers.<p>But instead, what most gamedevs get from using industry &quot;best practices&quot; when writing an app-game using e.g. DirectInput or SDL for input, is an API that&#x27;s <i>even more naive than the SNES joypad input registers</i> â it assumes that there&#x27;s exactly <i>one</i> gamepad, and that it&#x27;s reporting exactly <i>one</i> of each HID Usage ID. (And even worse with XInput, which assumes a fixed set of Usage IDs corresponding to &quot;what an XBox controller has!&quot;)<p>As such, most USB HID gamepads sold to consumers for use with PCs, in practice, don&#x27;t take real advantage of what USB HID gamepads <i>can in theory</i> report.<p>USB HID gamepads made to be used in proprietary ecosystems, on the other hand â think &quot;the Nintendo Switch Pro controller&quot; or &quot;the input board on an arcade machine&quot; â are free to be designed to actually use USB HID correctly. Which is why such devices usually need special drivers on PCs. They&#x27;re not speaking a brain-damaged wire protocol; rather, they&#x27;re living in the present and taking full advantage of USB HID features... while consumer OSes are still stuck in the past, unable to cope. :)<p>This is also why so many systems like emulators that support these proprietary input devices â or games complex enough, that they expect USB HID devices that are <i>themselves</i> complex enough to only be possible if using the spec the modern way (think, uh, this thing: <a href="https:&#x2F;&#x2F;www.amazon.ca&#x2F;Logitech-Saitek-Vehicle-Panel-945-000031&#x2F;dp&#x2F;B01M1B2MJX" rel="nofollow">https:&#x2F;&#x2F;www.amazon.ca&#x2F;Logitech-Saitek-Vehicle-Panel-945-0000...</a>) â just skip the high-level gamepad-input-handling frameworks, and just register to listen to USB HID events directly. Because that&#x27;s the only level at which they&#x27;ll receive the information they actually care about, without the OS first mangling it into incomprehensibility.<p>â¡ I <i>believe</i> polling for the input ports get zeroes rather than garbage if the ports aren&#x27;t connected â but this is likely more for hardware protection than anything else, with pulldown resistors on the read path to prevent you from shorting out the input pins by unplugging while the console is on. Nintendo at least learned the lesson of the PS&#x2F;2 bus.)</div><br/></div></div><div id="39057445" class="c"><input type="checkbox" id="c-39057445" checked=""/><div class="controls bullet"><span class="by">tenebrisalietum</span><span>|</span><a href="#39055743">parent</a><span>|</span><a href="#39057547">prev</a><span>|</span><a href="#39058589">next</a><span>|</span><label class="collapse" for="c-39057445">[-]</label><label class="expand" for="c-39057445">[1 more]</label></div><br/><div class="children"><div class="content">SNES can go up to a whopping 3.58Mhz (NTSC clock, not sure if exactly the same for PAL) but I believe due to some bus&#x2F;architecture weirdness slows down to 1.79Mhz (which is what the NTSC NES runs at) when reading the controllers.<p>Now the SuperFX chip, in Star Fox, ran at 10Mhz.  Later versions like the one in Doom on SNES went up to 21Mhz.</div><br/></div></div></div></div><div id="39055749" class="c"><input type="checkbox" id="c-39055749" checked=""/><div class="controls bullet"><span class="by">al_borland</span><span>|</span><a href="#39055743">prev</a><span>|</span><label class="collapse" for="c-39055749">[-]</label><label class="expand" for="c-39055749">[9 more]</label></div><br/><div class="children"><div class="content">RetroUSB has adapters for those not looking for a project. I bought one of their NES adapters years ago.<p><a href="https:&#x2F;&#x2F;www.retrousb.com&#x2F;product_info.php?cPath=21&amp;products_id=29&amp;osCsid=90fc7700767cca713d0850d4621efc93" rel="nofollow">https:&#x2F;&#x2F;www.retrousb.com&#x2F;product_info.php?cPath=21&amp;products_...</a></div><br/><div id="39057506" class="c"><input type="checkbox" id="c-39057506" checked=""/><div class="controls bullet"><span class="by">TillE</span><span>|</span><a href="#39055749">parent</a><span>|</span><a href="#39056036">next</a><span>|</span><label class="collapse" for="c-39057506">[-]</label><label class="expand" for="c-39057506">[1 more]</label></div><br/><div class="children"><div class="content">Raphnet adapters (designed by one guy in Canada) are the most popular option among serious speedrunners, if you want minimum latency.<p>Their equivalent product is currently out of stock:
<a href="https:&#x2F;&#x2F;www.raphnet-tech.com&#x2F;products&#x2F;snes2usb_1player_adapter_v2&#x2F;index.php" rel="nofollow">https:&#x2F;&#x2F;www.raphnet-tech.com&#x2F;products&#x2F;snes2usb_1player_adapt...</a></div><br/></div></div><div id="39056036" class="c"><input type="checkbox" id="c-39056036" checked=""/><div class="controls bullet"><span class="by">micheljansen</span><span>|</span><a href="#39055749">parent</a><span>|</span><a href="#39057506">prev</a><span>|</span><a href="#39058274">next</a><span>|</span><label class="collapse" for="c-39056036">[-]</label><label class="expand" for="c-39056036">[5 more]</label></div><br/><div class="children"><div class="content">Kind of amazing that you can get a whole controller (including buttons etc.) for a fraction of the cost of an adapter. Probably a less authentic experience though:
<a href="https:&#x2F;&#x2F;www.aliexpress.com&#x2F;item&#x2F;1005005998083106.html" rel="nofollow">https:&#x2F;&#x2F;www.aliexpress.com&#x2F;item&#x2F;1005005998083106.html</a></div><br/><div id="39056327" class="c"><input type="checkbox" id="c-39056327" checked=""/><div class="controls bullet"><span class="by">creesch</span><span>|</span><a href="#39055749">root</a><span>|</span><a href="#39056036">parent</a><span>|</span><a href="#39059300">next</a><span>|</span><label class="collapse" for="c-39056327">[-]</label><label class="expand" for="c-39056327">[3 more]</label></div><br/><div class="children"><div class="content">Controllers that cheap generally are made of terrible creeky plastic, mushy buttons and generally poor assembly.<p>You can get decent retro styled USB controllers, but they will be a bit more expensive than this one.</div><br/><div id="39056495" class="c"><input type="checkbox" id="c-39056495" checked=""/><div class="controls bullet"><span class="by">TheCleric</span><span>|</span><a href="#39055749">root</a><span>|</span><a href="#39056327">parent</a><span>|</span><a href="#39059300">next</a><span>|</span><label class="collapse" for="c-39056495">[-]</label><label class="expand" for="c-39056495">[2 more]</label></div><br/><div class="children"><div class="content">Yeah I love the 8bitdo ones. But they&#x27;re not inexpensive.</div><br/><div id="39056592" class="c"><input type="checkbox" id="c-39056592" checked=""/><div class="controls bullet"><span class="by">JamesSwift</span><span>|</span><a href="#39055749">root</a><span>|</span><a href="#39056495">parent</a><span>|</span><a href="#39059300">next</a><span>|</span><label class="collapse" for="c-39056592">[-]</label><label class="expand" for="c-39056592">[1 more]</label></div><br/><div class="children"><div class="content">People are always surprised that the controllers are the largest line item when building a retropie. You really want quality though, they make a big difference in that the dpads and the thumb sticks are both good.</div><br/></div></div></div></div></div></div><div id="39059300" class="c"><input type="checkbox" id="c-39059300" checked=""/><div class="controls bullet"><span class="by">al_borland</span><span>|</span><a href="#39055749">root</a><span>|</span><a href="#39056036">parent</a><span>|</span><a href="#39056327">prev</a><span>|</span><a href="#39058274">next</a><span>|</span><label class="collapse" for="c-39059300">[-]</label><label class="expand" for="c-39059300">[1 more]</label></div><br/><div class="children"><div class="content">I picked up my NES controllers at Goodwill. Super cheap and the real thing.</div><br/></div></div></div></div><div id="39058274" class="c"><input type="checkbox" id="c-39058274" checked=""/><div class="controls bullet"><span class="by">kevinsync</span><span>|</span><a href="#39055749">parent</a><span>|</span><a href="#39056036">prev</a><span>|</span><a href="#39058595">next</a><span>|</span><label class="collapse" for="c-39058274">[-]</label><label class="expand" for="c-39058274">[1 more]</label></div><br/><div class="children"><div class="content">I just got a RetroUSB Genesis adapter to use a 22-year-old Asciiware Power Clutch SG I had rotting in the basement for some JavaScript Gamepad API experiments. The adapter works great, feels good to breathe new life into an ancient peripheral!</div><br/></div></div></div></div></div></div></div></div></div></body></html>