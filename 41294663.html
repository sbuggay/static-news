<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1724490066257" as="style"/><link rel="stylesheet" href="styles.css?v=1724490066257"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/gruhn/typescript-sudoku">Playing Sudoku in TypeScript while the type checker highlights mistakes</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>mjcurl</span> | <span>69 comments</span></div><br/><div><div id="41330774" class="c"><input type="checkbox" id="c-41330774" checked=""/><div class="controls bullet"><span class="by">a_wild_dandan</span><span>|</span><a href="#41330629">next</a><span>|</span><label class="collapse" for="c-41330774">[-]</label><label class="expand" for="c-41330774">[59 more]</label></div><br/><div class="children"><div class="content">Using TypeScript for the entire stack feels like a superpower. The type system is incredible. V8 is fast. The frameworks are phenomenal (Next.js, Material UI, etc). The ecosystem is enormous, with packages for <i>everything</i>. The unified codebases save gobs of duplicate code (e.g. ferrying data betwixt client&#x2F;server). I&#x27;m not surprised that such an expressive system can play Sudoku!</div><br/><div id="41331186" class="c"><input type="checkbox" id="c-41331186" checked=""/><div class="controls bullet"><span class="by">leononame</span><span>|</span><a href="#41330774">parent</a><span>|</span><a href="#41332847">next</a><span>|</span><label class="collapse" for="c-41331186">[-]</label><label class="expand" for="c-41331186">[41 more]</label></div><br/><div class="children"><div class="content">For me, it&#x27;s the opposite. The type system is decent, but it&#x27;s generics can get extremely out of hand, it&#x27;s not sound, and I run into weird type errors with libraries more often than not.<p>Having no integer types (ok, this isn&#x27;t something typescript could just implement) other than BigInt is another big one for me.<p>That you can just do `as unknown as T` is an endless source of pain and sometimes it doesn&#x27;t help that JS just does whatever it wants with type coercion. I&#x27;ve seen React libraries with number inputs that actually returned string values in their callbacks, but you wouldn&#x27;t notice this until you tried doing addition and ended up with concatenation. Have fun finding out where your number turned into a string.<p>The number of times I&#x27;ve read `... does not exist on type undefined` reaches trauma-inducing levels.<p>TypeScript is as good as it can get for being a superset of JS. But it&#x27;s not a language I have fun writing stuff in (and I even fear it on the backend). It has its place, and it&#x27;s definitely a decent language, but I would choose something else for frontend if I could, and wouldn&#x27;t use it on the backend at all. I somehow don&#x27;t trust it. I know people write amazing software with it, but YMMV I guess.</div><br/><div id="41332832" class="c"><input type="checkbox" id="c-41332832" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41331186">parent</a><span>|</span><a href="#41331793">next</a><span>|</span><label class="collapse" for="c-41332832">[-]</label><label class="expand" for="c-41332832">[6 more]</label></div><br/><div class="children"><div class="content">&gt; it&#x27;s not sound<p>This comes up in every one of these threads and I always wonder: do you actually experience problems with soundness in your regular coding? (Aside from `as unknown`, which as others have noted just means you need a linter to stop the bad practices.)<p>It feels like such a theoretical issue to me, and I&#x27;ve yet to see anyone cite an example of where it came up in production code. The complaint comes off as being more a general sense of ickiness than a practical concern.</div><br/><div id="41334342" class="c"><input type="checkbox" id="c-41334342" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41332832">parent</a><span>|</span><a href="#41335235">next</a><span>|</span><label class="collapse" for="c-41334342">[-]</label><label class="expand" for="c-41334342">[4 more]</label></div><br/><div class="children"><div class="content">yes, all the time. It&#x27;s more of an issue of no runtime type safety, which makes it a poor choice for many backend projects. There are workarounds, but it&#x27;s silly when there are many better alternatives.</div><br/><div id="41334443" class="c"><input type="checkbox" id="c-41334443" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41334342">parent</a><span>|</span><a href="#41335235">next</a><span>|</span><label class="collapse" for="c-41334443">[-]</label><label class="expand" for="c-41334443">[3 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s more of an issue of no runtime type safety...<p>This is a completely orthogonal question to soundness.</div><br/><div id="41336351" class="c"><input type="checkbox" id="c-41336351" checked=""/><div class="controls bullet"><span class="by">leononame</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41334443">parent</a><span>|</span><a href="#41335235">next</a><span>|</span><label class="collapse" for="c-41336351">[-]</label><label class="expand" for="c-41336351">[2 more]</label></div><br/><div class="children"><div class="content">In this case, not really. TypeScript can&#x27;t be sound because there is zero runtime type safety in JS. That you are able to do `as unknown as T` makes TypeScript unsound, but it&#x27;s also an escape hatch often needed to interact with JavaScript&#x27;s dynamic typing.</div><br/><div id="41336459" class="c"><input type="checkbox" id="c-41336459" checked=""/><div class="controls bullet"><span class="by">ffsm8</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41336351">parent</a><span>|</span><a href="#41335235">next</a><span>|</span><label class="collapse" for="c-41336459">[-]</label><label class="expand" for="c-41336459">[1 more]</label></div><br/><div class="children"><div class="content">&gt; an escape hatch often needed<p>The only time you need that is in tests.<p>Otherwise you&#x27;re better off using guards then blindly casting</div><br/></div></div></div></div></div></div></div></div><div id="41335235" class="c"><input type="checkbox" id="c-41335235" checked=""/><div class="controls bullet"><span class="by">giraffe_lady</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41332832">parent</a><span>|</span><a href="#41334342">prev</a><span>|</span><a href="#41331793">next</a><span>|</span><label class="collapse" for="c-41335235">[-]</label><label class="expand" for="c-41335235">[1 more]</label></div><br/><div class="children"><div class="content">Soundness is a <i>constraint</i> more than a feature. Having it limits what is possible in the language, forcing you into a smaller set of available solutions.<p>So for me it&#x27;s not about running into unsound types regularly but how much complexity is possible and needs to be carved away to get at a working idea because of it. In TS I spend relatively a lot of time thinking about and tweaking minute mechanics of the types as I code. Where by comparison in ocaml (or more relevantly rescript) I just declare some straightforward type constructors up front and everything else is inferred as I go. When I get the logic complete I can go back and formalize the signatures.<p>Because of the unsoundness (I think? I&#x27;m not a type systems expert) TS&#x27;s inference isn&#x27;t as good, and you lose this practical distinction between type and logic. And more subtly and subjectively, you lose the <i>temporal</i> distinction. Nothing comes first: you have to work it all out at once, solving the type problems as you construct the logic, holding both models as you work through the details.</div><br/></div></div></div></div><div id="41331793" class="c"><input type="checkbox" id="c-41331793" checked=""/><div class="controls bullet"><span class="by">a_wild_dandan</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41331186">parent</a><span>|</span><a href="#41332832">prev</a><span>|</span><a href="#41331235">next</a><span>|</span><label class="collapse" for="c-41331793">[-]</label><label class="expand" for="c-41331793">[15 more]</label></div><br/><div class="children"><div class="content">You&#x27;re blaming TypeScript for self-inflicted wounds.<p>Don&#x27;t blame the type system that you banished (with `as unknown as T`) for not catching you; or for some React library having bugs, e.g. an incorrect interface; for not defining types and Pikachu-facing when types are `undefined`. These traumas are fixed <i>by using</i> TypeScript, not ignoring it.</div><br/><div id="41331834" class="c"><input type="checkbox" id="c-41331834" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41331793">parent</a><span>|</span><a href="#41332716">next</a><span>|</span><label class="collapse" for="c-41331834">[-]</label><label class="expand" for="c-41331834">[10 more]</label></div><br/><div class="children"><div class="content">These issues don&#x27;t exist in languages that aren&#x27;t built on a marsh.<p>More specifically though, I feel like the way javascript libraries with types work is often painful to use and that&#x27;s why people use TS&#x27;s escape hatches, whereas the same thing doesn&#x27;t happen in languages where everything is built on types from the get go.<p>The same friction is true for example of using C libraries from other languages.</div><br/><div id="41335864" class="c"><input type="checkbox" id="c-41335864" checked=""/><div class="controls bullet"><span class="by">Too</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41331834">parent</a><span>|</span><a href="#41332734">next</a><span>|</span><label class="collapse" for="c-41335864">[-]</label><label class="expand" for="c-41335864">[3 more]</label></div><br/><div class="children"><div class="content">The rest of the world is an equally muddy marsh. C++: static_cast, C: void-pointers and unions, java&#x2F;c#: casting back from (object) or IAbstractWidget.<p>If anything, typescript has the most expressive, accurate and powerful type system of the lot, letting you be a lot more precise in your generics and then get the exact type back in your callback, rather than some abstract IWidget that needs to be cast back to the more concrete class. The structural typing also makes it much easier to be lax and let the type engine deduce correctness, rather than manually casting things around.</div><br/><div id="41336381" class="c"><input type="checkbox" id="c-41336381" checked=""/><div class="controls bullet"><span class="by">leononame</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41335864">parent</a><span>|</span><a href="#41332734">next</a><span>|</span><label class="collapse" for="c-41336381">[-]</label><label class="expand" for="c-41336381">[2 more]</label></div><br/><div class="children"><div class="content">C is famously unsafe. But in Java&#x2F;C#, you do have runtime type safety. You can&#x27;t just cast something to something else and call it a day. In the worst case, you&#x27;ll get an exception telling you that this does not work. In TypeScript, the &quot;cast&quot; succeeds, but then 200 lines later, you get some weird runtime error like &quot;does not exist on type undefined&quot; which doesn&#x27;t tell you at all what the source of the error is.<p>In TypeScript, a variable can have a different runtime type from its declared type entirely, that&#x27;s just not true for many other languages</div><br/><div id="41336659" class="c"><input type="checkbox" id="c-41336659" checked=""/><div class="controls bullet"><span class="by">trashburger</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41336381">parent</a><span>|</span><a href="#41332734">next</a><span>|</span><label class="collapse" for="c-41336659">[-]</label><label class="expand" for="c-41336659">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure about the CLR, but the JVM has no type safety whatsoever. Java the <i>language</i> does, but all of that goes away once you are in the JVM bytecode.</div><br/></div></div></div></div></div></div><div id="41332734" class="c"><input type="checkbox" id="c-41332734" checked=""/><div class="controls bullet"><span class="by">rty32</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41331834">parent</a><span>|</span><a href="#41335864">prev</a><span>|</span><a href="#41334125">next</a><span>|</span><label class="collapse" for="c-41332734">[-]</label><label class="expand" for="c-41332734">[4 more]</label></div><br/><div class="children"><div class="content">&quot;don&#x27;t exist in languages that aren&#x27;t built on a marsh&quot;<p>Sure. Last time I checked, JavaScript is the language that actually powers the web. If you can get a language that isn&#x27;t built on a marsh along with all the libraries to run the web, I&#x27;ll switch in a second.<p>In other words, the criticism is simply irrelevant. If it works, it works. We don&#x27;t talk about technologies that don&#x27;t exist.</div><br/><div id="41333324" class="c"><input type="checkbox" id="c-41333324" checked=""/><div class="controls bullet"><span class="by">skitter</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41332734">parent</a><span>|</span><a href="#41333936">next</a><span>|</span><label class="collapse" for="c-41333324">[-]</label><label class="expand" for="c-41333324">[1 more]</label></div><br/><div class="children"><div class="content">We do in fact talk about technologies that don&#x27;t exist. Creating new technologies would be rather difficult otherwise.</div><br/></div></div><div id="41333936" class="c"><input type="checkbox" id="c-41333936" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41332734">parent</a><span>|</span><a href="#41333324">prev</a><span>|</span><a href="#41334125">next</a><span>|</span><label class="collapse" for="c-41333936">[-]</label><label class="expand" for="c-41333936">[2 more]</label></div><br/><div class="children"><div class="content">When they don&#x27;t have to interface with JS apis (e.g., for the DOM) this is true for libraries in other languages built for WASM.</div><br/><div id="41334731" class="c"><input type="checkbox" id="c-41334731" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41333936">parent</a><span>|</span><a href="#41334125">next</a><span>|</span><label class="collapse" for="c-41334731">[-]</label><label class="expand" for="c-41334731">[1 more]</label></div><br/><div class="children"><div class="content">Not run <i>on</i> the web, &quot;to run the web&quot;. Maybe someday WASM will be complete enough to actually <i>run the web</i>, but JavaScript is what we have right now and it&#x27;s done a pretty okay job so far.</div><br/></div></div></div></div></div></div><div id="41334125" class="c"><input type="checkbox" id="c-41334125" checked=""/><div class="controls bullet"><span class="by">golergka</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41331834">parent</a><span>|</span><a href="#41332734">prev</a><span>|</span><a href="#41332716">next</a><span>|</span><label class="collapse" for="c-41334125">[-]</label><label class="expand" for="c-41334125">[2 more]</label></div><br/><div class="children"><div class="content">&gt; These issues don&#x27;t exist in languages that aren&#x27;t built on a marsh.<p>Unsafe casts exist in almost any GCed strongly typed language. You can unsafe things even in Rust, if you want to. Author of this code has deliberately made a choice to circumvent language&#x27;s limitation and forgo it&#x27;s guarantees. We have been doing it since undefined behaviour in C, how is that Typescript&#x27;s fault?</div><br/><div id="41335108" class="c"><input type="checkbox" id="c-41335108" checked=""/><div class="controls bullet"><span class="by">LudwigNagasena</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41334125">parent</a><span>|</span><a href="#41332716">next</a><span>|</span><label class="collapse" for="c-41335108">[-]</label><label class="expand" for="c-41335108">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Unsafe casts exist in almost any GCed strongly typed language.<p>Well, and not GCed languages too. There are even weakly typed associative arrays.<p><pre><code>  std::map&lt;std::string, std::any&gt;</code></pre></div><br/></div></div></div></div></div></div><div id="41332716" class="c"><input type="checkbox" id="c-41332716" checked=""/><div class="controls bullet"><span class="by">leononame</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41331793">parent</a><span>|</span><a href="#41331834">prev</a><span>|</span><a href="#41333264">next</a><span>|</span><label class="collapse" for="c-41332716">[-]</label><label class="expand" for="c-41332716">[3 more]</label></div><br/><div class="children"><div class="content">Well, the reality of the situation still is that there are libraries with incorrect or low quality typings that blow up in your face. Me using TypeScript will not make that library better, but this problem is still the daily reality of using TypeScript. It&#x27;s not the fault of TS, but still a pain you encounter when working with it.<p>I haven&#x27;t worked with a language where you can statically cast invalid types that easily since C, a language not exactly famously known for its safety.<p>There&#x27;s a reason `as unknown as T` exists, and it&#x27;s JavaScript&#x27;s highly dynamic nature and absence of runtime types (ignoring classes and primitives). It&#x27;s an escape hatch that is needed sometimes. Sure, within your own codebase everything will be fine if you forbid its use, but every library call is an API boundary that you potentially have to check types for. That&#x27;s just not great DX</div><br/><div id="41333236" class="c"><input type="checkbox" id="c-41333236" checked=""/><div class="controls bullet"><span class="by">iainmerrick</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41332716">parent</a><span>|</span><a href="#41333264">next</a><span>|</span><label class="collapse" for="c-41333236">[-]</label><label class="expand" for="c-41333236">[2 more]</label></div><br/><div class="children"><div class="content"><i>I haven&#x27;t worked with a language where you can statically cast invalid types that easily since C, a language not exactly famously known for its safety.</i><p>But it’s not the same situation at all, is it? If you make an invalid cast in C, your program will crash or behave in bizarre ways.<p>If you make an invalid cast in TS, that doesn’t affect the JS code at all. The results will be consistent and perfectly well-defined. (It probably won’t do what you wanted, of course, but you can’t have everything.)<p>TS is much more like Java than it is like C (but with a much nicer type system than either).</div><br/><div id="41336395" class="c"><input type="checkbox" id="c-41336395" checked=""/><div class="controls bullet"><span class="by">leononame</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41333236">parent</a><span>|</span><a href="#41333264">next</a><span>|</span><label class="collapse" for="c-41336395">[-]</label><label class="expand" for="c-41336395">[1 more]</label></div><br/><div class="children"><div class="content">Meh, in Java (afaik) you&#x27;ll get exceptions when you cast incorrectly. In JS and C, it just gets allowed and you get some runtime error later on and have to make your way back to find your incorrect cast.</div><br/></div></div></div></div></div></div><div id="41333264" class="c"><input type="checkbox" id="c-41333264" checked=""/><div class="controls bullet"><span class="by">iainmerrick</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41331793">parent</a><span>|</span><a href="#41332716">prev</a><span>|</span><a href="#41331235">next</a><span>|</span><label class="collapse" for="c-41333264">[-]</label><label class="expand" for="c-41333264">[1 more]</label></div><br/><div class="children"><div class="content">Totally! I really wonder what these libraries people are complaining about that have such bad type definitions. In my experience TS definitions on the average NPM package are generally fairly decent.</div><br/></div></div></div></div><div id="41331235" class="c"><input type="checkbox" id="c-41331235" checked=""/><div class="controls bullet"><span class="by">carderne</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41331186">parent</a><span>|</span><a href="#41331793">prev</a><span>|</span><a href="#41331349">next</a><span>|</span><label class="collapse" for="c-41331235">[-]</label><label class="expand" for="c-41331235">[11 more]</label></div><br/><div class="children"><div class="content">I tend to agree with you but for problem like this one:<p>&gt; That you can just do `as unknown as T` is an endless source of pain<p>You should be using strict typingcheck&#x2F;linting rules somewhere in your pipeline to make these illegal (or at least carefully scrutinised and documented).</div><br/><div id="41331539" class="c"><input type="checkbox" id="c-41331539" checked=""/><div class="controls bullet"><span class="by">leononame</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41331235">parent</a><span>|</span><a href="#41331398">next</a><span>|</span><label class="collapse" for="c-41331539">[-]</label><label class="expand" for="c-41331539">[5 more]</label></div><br/><div class="children"><div class="content">Sure, I agree in general, but I&#x27;ve found that:<p>1. If someone is willing to do `as unknown as T`, they&#x27;re probably also just as willing to do `&#x2F;&#x2F; @ts-ignore`.
2. It&#x27;s not only your own code, it&#x27;s the libraries you use as well. Typings can often be slightly incorrect and you have to work around that occasionally.</div><br/><div id="41333032" class="c"><input type="checkbox" id="c-41333032" checked=""/><div class="controls bullet"><span class="by">cdaringe</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41331539">parent</a><span>|</span><a href="#41333888">next</a><span>|</span><label class="collapse" for="c-41333032">[-]</label><label class="expand" for="c-41333032">[1 more]</label></div><br/><div class="children"><div class="content">Popular libraries tend to get type hygiene issues ironed out rather quickly for 90% of the API surface area. For this reason, i find that lib selection from npm is much easier these days. The heuristic is simple:<p>1) has types? 2) has (large) download count? 3) has docs?<p>After that it’s generally smooth sailing. Of course this doesnt at all apply to the application codebase being applied to, but one of the parent&#x2F;sibling remarks emphasized “madness” and i seek to smooth that over.<p>Noisy? Yes.
Madness? Nah.</div><br/></div></div><div id="41333888" class="c"><input type="checkbox" id="c-41333888" checked=""/><div class="controls bullet"><span class="by">tshaddox</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41331539">parent</a><span>|</span><a href="#41333032">prev</a><span>|</span><a href="#41332839">next</a><span>|</span><label class="collapse" for="c-41333888">[-]</label><label class="expand" for="c-41333888">[1 more]</label></div><br/><div class="children"><div class="content">Then fail builds on @ts-ignore.<p>&quot;But the bad dev will just open up your build config and remove that restriction.&quot;<p>Okay fine. At some point you gotta establish a floor on the insolence of your teammates.</div><br/></div></div><div id="41332839" class="c"><input type="checkbox" id="c-41332839" checked=""/><div class="controls bullet"><span class="by">mynameisvlad</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41331539">parent</a><span>|</span><a href="#41333888">prev</a><span>|</span><a href="#41333235">next</a><span>|</span><label class="collapse" for="c-41332839">[-]</label><label class="expand" for="c-41332839">[1 more]</label></div><br/><div class="children"><div class="content">For #1, this is literally what PRs are for. Someone might be willing to do it, but it should be stopped before merge. If it isn’t, you have bigger problems to solve than type coercion.<p>For #2, if it’s open source you’re welcome to change the source or its typings.</div><br/></div></div><div id="41333235" class="c"><input type="checkbox" id="c-41333235" checked=""/><div class="controls bullet"><span class="by">nox101</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41331539">parent</a><span>|</span><a href="#41332839">prev</a><span>|</span><a href="#41331398">next</a><span>|</span><label class="collapse" for="c-41333235">[-]</label><label class="expand" for="c-41333235">[1 more]</label></div><br/><div class="children"><div class="content">You can also turn off all warnings in C and C++ (and C#?). That&#x27;s not a flaw in the language it&#x27;s a flaw in code bases and programmers that turn them off.</div><br/></div></div></div></div><div id="41331398" class="c"><input type="checkbox" id="c-41331398" checked=""/><div class="controls bullet"><span class="by">ridiculous_leke</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41331235">parent</a><span>|</span><a href="#41331539">prev</a><span>|</span><a href="#41331349">next</a><span>|</span><label class="collapse" for="c-41331398">[-]</label><label class="expand" for="c-41331398">[5 more]</label></div><br/><div class="children"><div class="content">Those rules should be enabled by default.</div><br/><div id="41331963" class="c"><input type="checkbox" id="c-41331963" checked=""/><div class="controls bullet"><span class="by">moritzwarhier</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41331398">parent</a><span>|</span><a href="#41331349">next</a><span>|</span><label class="collapse" for="c-41331963">[-]</label><label class="expand" for="c-41331963">[4 more]</label></div><br/><div class="children"><div class="content">ESLint rules that require type information (not just stripping types) are prohibitively expensive for larger code bases.<p>As far as I know, there isn&#x27;t any kind of tsconfig rule to disallow this (please correct me if I&#x27;m missing something here!). So unless you&#x27;re using tools I don&#x27;t know about, this is kind of a mandatory last bastion of &quot;any&quot;.<p>You can disallow any, enable the strictest possible null&#x2F;undefined checks (including noUncheckedIndexedAccess).
And there&#x27;s also the assertion TS check that normally prevents erroneous type assertions.<p>But &quot;as unknown as MyType&quot; is not preventable by means of tsc, as far as I know. Unless there&#x27;s an option I don&#x27;t know do disable this kind of assertion (or even all assertions).</div><br/><div id="41333298" class="c"><input type="checkbox" id="c-41333298" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41331963">parent</a><span>|</span><a href="#41335519">next</a><span>|</span><label class="collapse" for="c-41333298">[-]</label><label class="expand" for="c-41333298">[2 more]</label></div><br/><div class="children"><div class="content">How large is too large and what counts as prohibitive? We&#x27;re using lints with types on over a million lines of TypeScript and the lints are instant inside of the editors. They take a good 10 minutes to run in CI across the whole project, but that&#x27;s shorter than the tests which are running in parallel.</div><br/><div id="41335118" class="c"><input type="checkbox" id="c-41335118" checked=""/><div class="controls bullet"><span class="by">RussianCow</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41333298">parent</a><span>|</span><a href="#41335519">next</a><span>|</span><label class="collapse" for="c-41335118">[-]</label><label class="expand" for="c-41335118">[1 more]</label></div><br/><div class="children"><div class="content">I think it depends on your code and dependencies. At work, the time between making a change in our codebase (which is much smaller than a million LOC) to having ESLint update itself in the IDE can take 5+ seconds, depending on what you changed. But we also use some pretty over-engineered, generic-heavy dependencies across our entire codebase.</div><br/></div></div></div></div><div id="41335519" class="c"><input type="checkbox" id="c-41335519" checked=""/><div class="controls bullet"><span class="by">space_crab</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41331963">parent</a><span>|</span><a href="#41333298">prev</a><span>|</span><a href="#41331349">next</a><span>|</span><label class="collapse" for="c-41335519">[-]</label><label class="expand" for="c-41335519">[1 more]</label></div><br/><div class="children"><div class="content">lint-staged on pre-commit and full lint in CI solves this problem very well.</div><br/></div></div></div></div></div></div></div></div><div id="41331349" class="c"><input type="checkbox" id="c-41331349" checked=""/><div class="controls bullet"><span class="by">tarruda</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41331186">parent</a><span>|</span><a href="#41331235">prev</a><span>|</span><a href="#41333944">next</a><span>|</span><label class="collapse" for="c-41331349">[-]</label><label class="expand" for="c-41331349">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Having no integer types (ok, this isn&#x27;t something typescript could just implement) other than BigInt is another big one for me.<p>Is that a performance thing? I believe JavaScript VMs can specialize&#x2F;optimize Numbers and BigInts that only contain valid 32 int values.</div><br/><div id="41331610" class="c"><input type="checkbox" id="c-41331610" checked=""/><div class="controls bullet"><span class="by">leononame</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41331349">parent</a><span>|</span><a href="#41333944">next</a><span>|</span><label class="collapse" for="c-41331610">[-]</label><label class="expand" for="c-41331610">[6 more]</label></div><br/><div class="children"><div class="content">None of these are performance concerns. Modern JS engines are plenty fast for most of my use cases.<p>It irks me that I can&#x27;t trust it to be an integer within a given range. Especially with Number, I often have the sensation that the type system just doesn&#x27;t have my back. Sure, I can be careful and make sure it&#x27;s always an integer, I&#x27;ve got 53 bits of integer precision which is plenty. But I&#x27;ve shot myself in the foot too many times, and I hust don&#x27;t trust it to be an integer even if I know it is.<p>As for BigInt, I default to it by now and I&#x27;ve not found my performance noticeably worse. But it irks me that I can get a number that&#x27;s out of range of an actual int32 or int64, especially when doing databases. Will I get tto that point? Probably not, but it&#x27;s a potential error waiting to be overlooked that could be so easily solved if JS had int32&#x2F;int64 data types.</div><br/><div id="41332222" class="c"><input type="checkbox" id="c-41332222" checked=""/><div class="controls bullet"><span class="by">mewpmewp2</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41331610">parent</a><span>|</span><a href="#41333909">next</a><span>|</span><label class="collapse" for="c-41332222">[-]</label><label class="expand" for="c-41332222">[4 more]</label></div><br/><div class="children"><div class="content">Do you have any more specific examples where it has caused a problem not having int type specifically?<p>I can&#x27;t really remember having a problem with it myself, but maybe your usecases are different.</div><br/><div id="41332539" class="c"><input type="checkbox" id="c-41332539" checked=""/><div class="controls bullet"><span class="by">throwanem</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41332222">parent</a><span>|</span><a href="#41332553">next</a><span>|</span><label class="collapse" for="c-41332539">[-]</label><label class="expand" for="c-41332539">[1 more]</label></div><br/><div class="children"><div class="content">Sound currency arithmetic is a lot harder when you have to constantly watch out for the accidental introduction of a fractional part that the type system can&#x27;t warn you about, and that can never be safe with IEEE 754 floats. (This doesn&#x27;t just bite in and near finance: go use floating-point math to compute sales tax, you&#x27;ll find out soon enough what I mean.)<p>Bigints solve that problem, but can&#x27;t be natively represented by JSON, so there tends to be a lot of resistance to their use.</div><br/></div></div><div id="41332553" class="c"><input type="checkbox" id="c-41332553" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41332222">parent</a><span>|</span><a href="#41332539">prev</a><span>|</span><a href="#41332511">next</a><span>|</span><label class="collapse" for="c-41332553">[-]</label><label class="expand" for="c-41332553">[1 more]</label></div><br/><div class="children"><div class="content">I’m converting a billing system from js to ts right now.<p>Looking for a therapist.</div><br/></div></div><div id="41332511" class="c"><input type="checkbox" id="c-41332511" checked=""/><div class="controls bullet"><span class="by">leononame</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41332222">parent</a><span>|</span><a href="#41332553">prev</a><span>|</span><a href="#41333909">next</a><span>|</span><label class="collapse" for="c-41332511">[-]</label><label class="expand" for="c-41332511">[1 more]</label></div><br/><div class="children"><div class="content">Not really. In my parent comment I tried to make clear that it&#x27;s not a limitation for me in real-world scenarios I encounter, but still something I feel like being a potential class of problems that could be so easily solved.<p>When I really needed dedicated integer types of a specific size, e.g. for encoding&#x2F;decoding some binary data, so far I&#x27;ve been successful using something like Uint8Array</div><br/></div></div></div></div><div id="41333909" class="c"><input type="checkbox" id="c-41333909" checked=""/><div class="controls bullet"><span class="by">tshaddox</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41331610">parent</a><span>|</span><a href="#41332222">prev</a><span>|</span><a href="#41333944">next</a><span>|</span><label class="collapse" for="c-41333909">[-]</label><label class="expand" for="c-41333909">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Especially with Number, I often have the sensation that the type system just doesn&#x27;t have my back.<p>That&#x27;s sounding dangerously close to dependent types, which are awesome but barely exist in any programming languages, let alone mainstream general purpose programming languages.<p>You could do this with a branded type. The downside will be ergonomics, since you can&#x27;t safely use e.g. the normal arithmetic operators on these restricted integer types.</div><br/></div></div></div></div></div></div><div id="41333944" class="c"><input type="checkbox" id="c-41333944" checked=""/><div class="controls bullet"><span class="by">tills13</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41331186">parent</a><span>|</span><a href="#41331349">prev</a><span>|</span><a href="#41332847">next</a><span>|</span><label class="collapse" for="c-41333944">[-]</label><label class="expand" for="c-41333944">[1 more]</label></div><br/><div class="children"><div class="content">&gt; That you can just do `as unknown as T`<p>I mean, yeah... if you&#x27;re using escape hatches all the time I can see why you are having a bad time.</div><br/></div></div></div></div><div id="41332847" class="c"><input type="checkbox" id="c-41332847" checked=""/><div class="controls bullet"><span class="by">SonOfLilit</span><span>|</span><a href="#41330774">parent</a><span>|</span><a href="#41331186">prev</a><span>|</span><a href="#41336439">next</a><span>|</span><label class="collapse" for="c-41332847">[-]</label><label class="expand" for="c-41332847">[4 more]</label></div><br/><div class="children"><div class="content">While TypeScript seems to be a nice language, it&#x27;s ecosystem is the JS ecosystem and it is <i>madness</i>.<p>Major versions of some common library breaking backwards compatibility released every week mean you need to run as fast as you can just to stay in place.<p>Public opinion can&#x27;t be relied upon. The most popular ORM library just recently added support for native JOINs, and this wasn&#x27;t common knowledge (I almost used it before at had them!). The most decent ORM as chosen by some coworkers very experienced with the ecosystem still doesn&#x27;t support subqueries (well, there&#x27;s an escape hatch for writing them in raw SQL...). Some marketer-turned-programmer created hundreds of useless packages (like, a separate package per ansi color) that all require each other, and they are popular enough that if you&#x27;ll run npm ls in your real world project you will find that you depend on them.<p>Having professionally used cargo, pip, even cabal, npm feels like the eternal september of open source packages.</div><br/><div id="41333142" class="c"><input type="checkbox" id="c-41333142" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41332847">parent</a><span>|</span><a href="#41333023">next</a><span>|</span><label class="collapse" for="c-41333142">[-]</label><label class="expand" for="c-41333142">[1 more]</label></div><br/><div class="children"><div class="content">Most of the madness that you&#x27;re describing there isn&#x27;t inherent in the JavaScript ecosystem, it&#x27;s more to do with undisciplined development practices that might be more likely to be enabled by JavaScript&#x27;s flexibility but are by no means required in order to participate.<p>Don&#x27;t use libraries that aren&#x27;t stable. Aggressively trim dependencies. Lock versions and upgrade intentionally. Ideally, use a company registry to cache what you actually want to be using.<p>Every ecosystem has its problems, and JS+NPM&#x27;s are largely that it&#x27;s too good at making everything too easy, leading to an abundance of naive developers building in a naive way.<p>On the whole I&#x27;ll take that over the unnecessary barriers in other ecosystems (don&#x27;t get me started on pip...), but it definitely requires some discipline to navigate safely.</div><br/></div></div><div id="41333023" class="c"><input type="checkbox" id="c-41333023" checked=""/><div class="controls bullet"><span class="by">yieldcrv</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41332847">parent</a><span>|</span><a href="#41333142">prev</a><span>|</span><a href="#41336439">next</a><span>|</span><label class="collapse" for="c-41333023">[-]</label><label class="expand" for="c-41333023">[2 more]</label></div><br/><div class="children"><div class="content">yeah this part is pretty bad<p>you can get lucky and reach a nirvana state where all your dependencies function well in a new project, but 6 months later its a disaster like ah you need to upgrade node, but ah your transpiler requires the older version of node, but ah the semantic versioning was not followed by your type definition addendum library and now there were autoupdated breaking changes, ah your project only worked with a locked package file and if you re-install any package the wrong way everything breaks in incomprehensible ways!<p>I know my way around it though, so yay big bucks and quick deployment of greenfield projects</div><br/><div id="41333299" class="c"><input type="checkbox" id="c-41333299" checked=""/><div class="controls bullet"><span class="by">space_crab</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41333023">parent</a><span>|</span><a href="#41336439">next</a><span>|</span><label class="collapse" for="c-41333299">[-]</label><label class="expand" for="c-41333299">[1 more]</label></div><br/><div class="children"><div class="content">I know this isn’t realistic for many many scenarios, but if you can help it there is a sweet spot where you dedicate ~30 minutes to merge weekly dependabot updates and you don’t run into this problem.</div><br/></div></div></div></div></div></div><div id="41336439" class="c"><input type="checkbox" id="c-41336439" checked=""/><div class="controls bullet"><span class="by">afavour</span><span>|</span><a href="#41330774">parent</a><span>|</span><a href="#41332847">prev</a><span>|</span><a href="#41336229">next</a><span>|</span><label class="collapse" for="c-41336439">[-]</label><label class="expand" for="c-41336439">[2 more]</label></div><br/><div class="children"><div class="content">I agree about TypeScript as a language but I’m very burnt out on the various JS frameworks. They’re all so bulky and heavy. I like feeling as though I’m close to the end product and the average React codebase is a pile of abstractions trying to push you away from the underlying APIs.</div><br/><div id="41336614" class="c"><input type="checkbox" id="c-41336614" checked=""/><div class="controls bullet"><span class="by">sureglymop</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41336439">parent</a><span>|</span><a href="#41336229">next</a><span>|</span><label class="collapse" for="c-41336614">[-]</label><label class="expand" for="c-41336614">[1 more]</label></div><br/><div class="children"><div class="content">I agree with you. If I develop for the browser, I&#x27;d like to use browser APIs. If those browser APIs are too complex for me to use without abstractions, that&#x27;s another problem in itself that has to be addressed separately.</div><br/></div></div></div></div><div id="41336229" class="c"><input type="checkbox" id="c-41336229" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41330774">parent</a><span>|</span><a href="#41336439">prev</a><span>|</span><a href="#41336179">next</a><span>|</span><label class="collapse" for="c-41336229">[-]</label><label class="expand" for="c-41336229">[2 more]</label></div><br/><div class="children"><div class="content">Only when those types actually could be used by runtimes, to catch up the the various JVM and CLR implementations.<p>There is no more juice left to squeeze in JavaScript, as it stands, beyond heroic efforts.<p>I rather stay with JVM and CLR languages, and only reach out to the node ecosystem, when SaaS products leave me no choice in regards to SDK support.<p>If Typescript is to never leave the role of being a linter, and a down version translator, eventually we have to ask ourselves when is Typescript done, instead of being an intellectual exercise for the sake of it.</div><br/><div id="41336253" class="c"><input type="checkbox" id="c-41336253" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41336229">parent</a><span>|</span><a href="#41336179">next</a><span>|</span><label class="collapse" for="c-41336253">[-]</label><label class="expand" for="c-41336253">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Only when those types actually could be used by runtimes<p>&#x27;pjmlp you do know how Java does generics right?</div><br/></div></div></div></div><div id="41336179" class="c"><input type="checkbox" id="c-41336179" checked=""/><div class="controls bullet"><span class="by">rpmisms</span><span>|</span><a href="#41330774">parent</a><span>|</span><a href="#41336229">prev</a><span>|</span><a href="#41333524">next</a><span>|</span><label class="collapse" for="c-41336179">[-]</label><label class="expand" for="c-41336179">[1 more]</label></div><br/><div class="children"><div class="content">I would have agreed with you once upon a time, but I&#x27;m building a project in Laravel right now. You want superpowers? Do a week&#x27;s worth of fullstack JS in an afternoon with Laravel.</div><br/></div></div><div id="41333524" class="c"><input type="checkbox" id="c-41333524" checked=""/><div class="controls bullet"><span class="by">__jonas</span><span>|</span><a href="#41330774">parent</a><span>|</span><a href="#41336179">prev</a><span>|</span><a href="#41336066">next</a><span>|</span><label class="collapse" for="c-41333524">[-]</label><label class="expand" for="c-41333524">[1 more]</label></div><br/><div class="children"><div class="content">I had this thought with a personal project but I got lost in a nightmare of configuration between typescript, node, the browser, my bundler etc.<p>Maybe it’s a better time with a framework like Next, which I assume comes with the client &#x2F; server code sharing part preconfigured, bun looked promising as well to simplify the development setup. But I ended up switching to another language for my backend and I feel pretty good about it.</div><br/></div></div><div id="41336066" class="c"><input type="checkbox" id="c-41336066" checked=""/><div class="controls bullet"><span class="by">beezlewax</span><span>|</span><a href="#41330774">parent</a><span>|</span><a href="#41333524">prev</a><span>|</span><a href="#41330854">next</a><span>|</span><label class="collapse" for="c-41336066">[-]</label><label class="expand" for="c-41336066">[1 more]</label></div><br/><div class="children"><div class="content">Betwixt? Hello thePrimagen</div><br/></div></div><div id="41330854" class="c"><input type="checkbox" id="c-41330854" checked=""/><div class="controls bullet"><span class="by">sva_</span><span>|</span><a href="#41330774">parent</a><span>|</span><a href="#41336066">prev</a><span>|</span><a href="#41331416">next</a><span>|</span><label class="collapse" for="c-41330854">[-]</label><label class="expand" for="c-41330854">[2 more]</label></div><br/><div class="children"><div class="content">&gt; with packages for everything<p>Which can quickly turn into a crutch if you&#x27;re not wise about it</div><br/><div id="41331169" class="c"><input type="checkbox" id="c-41331169" checked=""/><div class="controls bullet"><span class="by">brigadier132</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41330854">parent</a><span>|</span><a href="#41331416">next</a><span>|</span><label class="collapse" for="c-41331169">[-]</label><label class="expand" for="c-41331169">[1 more]</label></div><br/><div class="children"><div class="content">One thing I do when I see a dependency I want to use is get its github and paste it in this site:<p><a href="https:&#x2F;&#x2F;codetabs.com&#x2F;count-loc&#x2F;count-loc-online.html" rel="nofollow">https:&#x2F;&#x2F;codetabs.com&#x2F;count-loc&#x2F;count-loc-online.html</a><p>Depending on the # of lines of code and how many people use it actively I decide between just<p>* forking it and using the fork as a dependency<p>* copying the parts i need from it<p>* or just using it as a dependency<p>Either way, the dependencies existing is just a boon. Even if you don&#x27;t want to depend on it directly you can use the existing work as a guide and implement something yourself.</div><br/></div></div></div></div><div id="41331416" class="c"><input type="checkbox" id="c-41331416" checked=""/><div class="controls bullet"><span class="by">harha_</span><span>|</span><a href="#41330774">parent</a><span>|</span><a href="#41330854">prev</a><span>|</span><a href="#41330629">next</a><span>|</span><label class="collapse" for="c-41331416">[-]</label><label class="expand" for="c-41331416">[4 more]</label></div><br/><div class="children"><div class="content">TypeScript is overly complicated and for what? Compile-time &quot;safety&quot;. It&#x27;s better than plain JavaScript, though whatever library I pull as a dependency and peek inside the TypeScript&lt;&gt;JavaScript interface glue, I always find horrors beyond my comprehension.</div><br/><div id="41333016" class="c"><input type="checkbox" id="c-41333016" checked=""/><div class="controls bullet"><span class="by">xamuel</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41331416">parent</a><span>|</span><a href="#41332872">next</a><span>|</span><label class="collapse" for="c-41333016">[-]</label><label class="expand" for="c-41333016">[1 more]</label></div><br/><div class="children"><div class="content">Compile error messages in a classical typed language: &quot;Error: Object of type &#x27;StructA&#x27; cannot be assigned to variable of type &#x27;StructB&#x27;&quot;<p>Compile error messages in TypeScript when you use a library like React: &quot;Error: Cannot reconcile &lt;5 pages of arcane gibberish&gt; with &lt;5 pages of different arcane gibberish&gt;&quot;</div><br/></div></div><div id="41332872" class="c"><input type="checkbox" id="c-41332872" checked=""/><div class="controls bullet"><span class="by">mynameisvlad</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41331416">parent</a><span>|</span><a href="#41333016">prev</a><span>|</span><a href="#41330629">next</a><span>|</span><label class="collapse" for="c-41332872">[-]</label><label class="expand" for="c-41332872">[2 more]</label></div><br/><div class="children"><div class="content">&gt; the TypeScript&lt;&gt;JavaScript interface glue<p>… the typing file? That’s literally the only thing that’s different and if the original codebase was written in TS then is literally the types they defined.</div><br/><div id="41333496" class="c"><input type="checkbox" id="c-41333496" checked=""/><div class="controls bullet"><span class="by">harha_</span><span>|</span><a href="#41330774">root</a><span>|</span><a href="#41332872">parent</a><span>|</span><a href="#41330629">next</a><span>|</span><label class="collapse" for="c-41333496">[-]</label><label class="expand" for="c-41333496">[1 more]</label></div><br/><div class="children"><div class="content">Well either the typing glue or the library itself if it&#x27;s written in TypeScript. My point was: the types are too damn complicated. Way too complicated for what they achieve. Almost always.</div><br/></div></div></div></div></div></div></div></div><div id="41330629" class="c"><input type="checkbox" id="c-41330629" checked=""/><div class="controls bullet"><span class="by">davidsgk</span><span>|</span><a href="#41330774">prev</a><span>|</span><a href="#41330966">next</a><span>|</span><label class="collapse" for="c-41330629">[-]</label><label class="expand" for="c-41330629">[1 more]</label></div><br/><div class="children"><div class="content">An amazing (if a bit flowery) read that highlights more arcane stuff you can do with the TS type system: <a href="https:&#x2F;&#x2F;www.richard-towers.com&#x2F;2023&#x2F;03&#x2F;11&#x2F;typescripting-the-technical-interview.html" rel="nofollow">https:&#x2F;&#x2F;www.richard-towers.com&#x2F;2023&#x2F;03&#x2F;11&#x2F;typescripting-the-...</a></div><br/></div></div><div id="41330966" class="c"><input type="checkbox" id="c-41330966" checked=""/><div class="controls bullet"><span class="by">samwillis</span><span>|</span><a href="#41330629">prev</a><span>|</span><a href="#41335215">next</a><span>|</span><label class="collapse" for="c-41330966">[-]</label><label class="expand" for="c-41330966">[1 more]</label></div><br/><div class="children"><div class="content">This is super cool, love these sort of projects.<p>It&#x27;s crazy what you can achieve with typescript types, what about inferring sql query results types from a raw sql query string: <a href="https:&#x2F;&#x2F;github.com&#x2F;nikeee&#x2F;sequelts">https:&#x2F;&#x2F;github.com&#x2F;nikeee&#x2F;sequelts</a></div><br/></div></div><div id="41335215" class="c"><input type="checkbox" id="c-41335215" checked=""/><div class="controls bullet"><span class="by">peeters</span><span>|</span><a href="#41330966">prev</a><span>|</span><a href="#41332763">next</a><span>|</span><label class="collapse" for="c-41335215">[-]</label><label class="expand" for="c-41335215">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This is not about implementing a Sudoku solver<p>If you can capture validity of the game state in the type system, a sufficiently advanced IDE with autocomplete&#x2F;intellisense could actually already be a naive solver, since they will tend to treat contextual autocomplete as a form of constraint satisfiability problem, which is a sufficient approach to solve easy Sudokus.<p>In other words, throw this into Webstorm, put your cursor in an empty cell that currently has only one possible answer, and hit ctrl-space, and I would expect it to automatically fill in the answer for you.</div><br/></div></div><div id="41332763" class="c"><input type="checkbox" id="c-41332763" checked=""/><div class="controls bullet"><span class="by">prologist11</span><span>|</span><a href="#41335215">prev</a><span>|</span><a href="#41330461">next</a><span>|</span><label class="collapse" for="c-41332763">[-]</label><label class="expand" for="c-41332763">[1 more]</label></div><br/><div class="children"><div class="content">Any sufficiently advanced type system is indistinguishable from Prolog.</div><br/></div></div><div id="41330461" class="c"><input type="checkbox" id="c-41330461" checked=""/><div class="controls bullet"><span class="by">paradite</span><span>|</span><a href="#41332763">prev</a><span>|</span><label class="collapse" for="c-41330461">[-]</label><label class="expand" for="c-41330461">[5 more]</label></div><br/><div class="children"><div class="content">Ok can we reduce sudoku to something Turing complete and hence prove TypeScript is Turing complete?</div><br/><div id="41330552" class="c"><input type="checkbox" id="c-41330552" checked=""/><div class="controls bullet"><span class="by">itishappy</span><span>|</span><a href="#41330461">parent</a><span>|</span><a href="#41332287">next</a><span>|</span><label class="collapse" for="c-41330552">[-]</label><label class="expand" for="c-41330552">[3 more]</label></div><br/><div class="children"><div class="content">Issue #14833 - TypeScripts Type System is Turing Complete<p><a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;issues&#x2F;14833">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;issues&#x2F;14833</a></div><br/><div id="41331214" class="c"><input type="checkbox" id="c-41331214" checked=""/><div class="controls bullet"><span class="by">brap</span><span>|</span><a href="#41330461">root</a><span>|</span><a href="#41330552">parent</a><span>|</span><a href="#41332287">next</a><span>|</span><label class="collapse" for="c-41331214">[-]</label><label class="expand" for="c-41331214">[2 more]</label></div><br/><div class="children"><div class="content">Does this mean that some types never get resolved? How does the type checker handle that?</div><br/><div id="41331734" class="c"><input type="checkbox" id="c-41331734" checked=""/><div class="controls bullet"><span class="by">anamexis</span><span>|</span><a href="#41330461">root</a><span>|</span><a href="#41331214">parent</a><span>|</span><a href="#41332287">next</a><span>|</span><label class="collapse" for="c-41331734">[-]</label><label class="expand" for="c-41331734">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, the link gives an example of such an infinitely recursive type:<p><pre><code>    type Foo&lt;T extends &quot;true&quot;, B&gt; = { &quot;true&quot;: Foo&lt;T, Foo&lt;T, B&gt;&gt; }[T];
    let f: Foo&lt;&quot;true&quot;, {}&gt; = null!;

</code></pre>
As for how it&#x27;s handled, it yields the error &quot;Type instantiation is excessively deep and possibly infinite. [2589]&quot; I&#x27;m not sure what the max stack depth is, though.</div><br/></div></div></div></div></div></div><div id="41332287" class="c"><input type="checkbox" id="c-41332287" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#41330461">parent</a><span>|</span><a href="#41330552">prev</a><span>|</span><label class="collapse" for="c-41332287">[-]</label><label class="expand" for="c-41332287">[1 more]</label></div><br/><div class="children"><div class="content">Checking a sudoku board always terminates, so no.</div><br/></div></div></div></div></div></div></div></div></div></body></html>