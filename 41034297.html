<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1721898068683" as="style"/><link rel="stylesheet" href="styles.css?v=1721898068683"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://d-star.ai/solving-the-out-of-context-chunk-problem-for-rag">Solving the out-of-context chunk problem for RAG</a>Â <span class="domain">(<a href="https://d-star.ai">d-star.ai</a>)</span></div><div class="subtext"><span>zmccormick7</span> | <span>84 comments</span></div><br/><div><div id="41057738" class="c"><input type="checkbox" id="c-41057738" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#41056346">next</a><span>|</span><label class="collapse" for="c-41057738">[-]</label><label class="expand" for="c-41057738">[16 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve found the best approach is to start with traditional full text search. Get it to a point where manual human searches are useful - Especially for users who don&#x27;t have a stake in the development of an AI solution. <i>Then</i>, look at building a RAG-style solution around the FTS.<p>I never could get much beyond the basic search piece. I don&#x27;t see how mixing in a black box AI model with probabilistic outcomes could add any value without having this working first.</div><br/><div id="41058008" class="c"><input type="checkbox" id="c-41058008" checked=""/><div class="controls bullet"><span class="by">petercooper</span><span>|</span><a href="#41057738">parent</a><span>|</span><a href="#41061631">next</a><span>|</span><label class="collapse" for="c-41058008">[-]</label><label class="expand" for="c-41058008">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right, and it&#x27;s also possible to still use LLMs and vector search in such a system, but instead you use them to enrich the <i>queries</i> made to traditional, pre-existing knowledge bases and search systems. Arguably you could call this &quot;generative assisted retrieval&quot; or GAR.. sadly I didn&#x27;t coin the term, there&#x27;s a paper about it ;-) <a href="https:&#x2F;&#x2F;aclanthology.org&#x2F;2021.acl-long.316&#x2F;" rel="nofollow">https:&#x2F;&#x2F;aclanthology.org&#x2F;2021.acl-long.316&#x2F;</a></div><br/></div></div><div id="41061631" class="c"><input type="checkbox" id="c-41061631" checked=""/><div class="controls bullet"><span class="by">zby</span><span>|</span><a href="#41057738">parent</a><span>|</span><a href="#41058008">prev</a><span>|</span><a href="#41058099">next</a><span>|</span><label class="collapse" for="c-41061631">[-]</label><label class="expand" for="c-41061631">[2 more]</label></div><br/><div class="children"><div class="content">Traditional FTS returns the whole document - people take over from that point and  locate the interesting content there. The problem with RAG is that it does not follow that procedure - it tries to find the interesting chunk in one step. Even though since ReAct we know that LLMs could follow the same procedure as humans.<p>But we need an iterative RAG anyway: <a href="https:&#x2F;&#x2F;zzbbyy.substack.com&#x2F;p&#x2F;why-iterative-thinking-is-crucial" rel="nofollow">https:&#x2F;&#x2F;zzbbyy.substack.com&#x2F;p&#x2F;why-iterative-thinking-is-cruc...</a></div><br/><div id="41065261" class="c"><input type="checkbox" id="c-41065261" checked=""/><div class="controls bullet"><span class="by">mediaman</span><span>|</span><a href="#41057738">root</a><span>|</span><a href="#41061631">parent</a><span>|</span><a href="#41058099">next</a><span>|</span><label class="collapse" for="c-41065261">[-]</label><label class="expand" for="c-41065261">[1 more]</label></div><br/><div class="children"><div class="content">For my application we do a land-and-expand strategy, where we use a mix of BM25 and semantic search to find a chunk, but before showing it to the LLM we then expand to include everything on that page.<p>It works pretty well. It might benefit from including some material on the page prior and after, but it mostly solves the &quot;isolated chunk&quot; problem.</div><br/></div></div></div></div><div id="41058099" class="c"><input type="checkbox" id="c-41058099" checked=""/><div class="controls bullet"><span class="by">alexmolas</span><span>|</span><a href="#41057738">parent</a><span>|</span><a href="#41061631">prev</a><span>|</span><a href="#41057895">next</a><span>|</span><label class="collapse" for="c-41058099">[-]</label><label class="expand" for="c-41058099">[1 more]</label></div><br/><div class="children"><div class="content">But with FTS you don&#x27;t solve the &quot;out-of-context chunk problem&quot;. You&#x27;ll still miss relevant chunks with FTS. You still can apply the approach proposed in the post to FTS, but instead of using similarity you could use BM25.</div><br/></div></div><div id="41057895" class="c"><input type="checkbox" id="c-41057895" checked=""/><div class="controls bullet"><span class="by">k__</span><span>|</span><a href="#41057738">parent</a><span>|</span><a href="#41058099">prev</a><span>|</span><a href="#41056346">next</a><span>|</span><label class="collapse" for="c-41057895">[-]</label><label class="expand" for="c-41057895">[11 more]</label></div><br/><div class="children"><div class="content">I always wondered why a RAG index has to be a vector DB.<p>If the model understands text&#x2F;code and can generate text&#x2F;code it should be able to talk to OpenSearch no problem.</div><br/><div id="41057957" class="c"><input type="checkbox" id="c-41057957" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#41057738">root</a><span>|</span><a href="#41057895">parent</a><span>|</span><a href="#41058940">next</a><span>|</span><label class="collapse" for="c-41057957">[-]</label><label class="expand" for="c-41057957">[7 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t have to be a vector DB - and in fact I&#x27;m seeing increasing skepticism that embedding vector DBs are the best way to implement RAG.<p>A full-text search index using BM25 or similar may actually work a lot better for many RAG applications.<p>I wrote up some notes on building FTS-based RAG here: <a href="https:&#x2F;&#x2F;simonwillison.net&#x2F;2024&#x2F;Jun&#x2F;21&#x2F;search-based-rag&#x2F;" rel="nofollow">https:&#x2F;&#x2F;simonwillison.net&#x2F;2024&#x2F;Jun&#x2F;21&#x2F;search-based-rag&#x2F;</a></div><br/><div id="41058679" class="c"><input type="checkbox" id="c-41058679" checked=""/><div class="controls bullet"><span class="by">rcarmo</span><span>|</span><a href="#41057738">root</a><span>|</span><a href="#41057957">parent</a><span>|</span><a href="#41059527">next</a><span>|</span><label class="collapse" for="c-41058679">[-]</label><label class="expand" for="c-41058679">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using SQLite FTS (which is essentially BM25) and it works so well I haven&#x27;t really bothered with vector databases, or Postgres, or anything else yet. Maybe when my corpus exceeds 2GB...</div><br/></div></div><div id="41059527" class="c"><input type="checkbox" id="c-41059527" checked=""/><div class="controls bullet"><span class="by">niam</span><span>|</span><a href="#41057738">root</a><span>|</span><a href="#41057957">parent</a><span>|</span><a href="#41058679">prev</a><span>|</span><a href="#41059357">next</a><span>|</span><label class="collapse" for="c-41059527">[-]</label><label class="expand" for="c-41059527">[4 more]</label></div><br/><div class="children"><div class="content">What are the arguments for embedded vector DBs being suboptimal in RAG, out of curiosity?</div><br/><div id="41059755" class="c"><input type="checkbox" id="c-41059755" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#41057738">root</a><span>|</span><a href="#41059527">parent</a><span>|</span><a href="#41059357">next</a><span>|</span><label class="collapse" for="c-41059755">[-]</label><label class="expand" for="c-41059755">[3 more]</label></div><br/><div class="children"><div class="content">The biggest one is that it&#x27;s hard to get &quot;zero matches&quot; from an embeddings database. You get back all results ordered by distance from the user&#x27;s query, but it will really scrape the bottom of the barrel if there aren&#x27;t any great matches - which can lead to bugs like this one:  <a href="https:&#x2F;&#x2F;simonwillison.net&#x2F;2024&#x2F;Jun&#x2F;6&#x2F;accidental-prompt-injection&#x2F;#embeddings-risk" rel="nofollow">https:&#x2F;&#x2F;simonwillison.net&#x2F;2024&#x2F;Jun&#x2F;6&#x2F;accidental-prompt-injec...</a><p>The other problem is that embeddings search can miss things that a direct keyword match would have caught. If you have key terms that are specific to your corpus - product names for example - there&#x27;s a risk that a vector match might not score those as highly as BM25 would have so you may miss the most relevant documents.<p>Finally, embeddings are much more black box and hard to debug and reason about. We have decades of experience tweaking and debugging and improving BM25-style FTS search - the whole field of &quot;Information Retrieval&quot;. Throwing that all away in favour of weird new embedding vectors is suboptimal.</div><br/><div id="41065077" class="c"><input type="checkbox" id="c-41065077" checked=""/><div class="controls bullet"><span class="by">kgeist</span><span>|</span><a href="#41057738">root</a><span>|</span><a href="#41059755">parent</a><span>|</span><a href="#41059357">next</a><span>|</span><label class="collapse" for="c-41065077">[-]</label><label class="expand" for="c-41065077">[2 more]</label></div><br/><div class="children"><div class="content">&gt;but because embeddings search orders by similarity score it will ALWAYS return results, really scraping the bottom of the barrel if it has to<p>Why not have a similarity threshold? Say, if the distance is below 0.7, do not accept the search result.</div><br/><div id="41065315" class="c"><input type="checkbox" id="c-41065315" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#41057738">root</a><span>|</span><a href="#41065077">parent</a><span>|</span><a href="#41059357">next</a><span>|</span><label class="collapse" for="c-41065315">[-]</label><label class="expand" for="c-41065315">[1 more]</label></div><br/><div class="children"><div class="content">It turns out picking that threshold is extremely difficult - I&#x27;ve tried! The value seems to differ for different searches, so picking eg 0.7 as a fixed value isn&#x27;t actually as useful as you would expect.</div><br/></div></div></div></div></div></div></div></div><div id="41059357" class="c"><input type="checkbox" id="c-41059357" checked=""/><div class="controls bullet"><span class="by">ianbutler</span><span>|</span><a href="#41057738">root</a><span>|</span><a href="#41057957">parent</a><span>|</span><a href="#41059527">prev</a><span>|</span><a href="#41058940">next</a><span>|</span><label class="collapse" for="c-41059357">[-]</label><label class="expand" for="c-41059357">[1 more]</label></div><br/><div class="children"><div class="content">In 2019 I was using vector search to narrow the search space within 100s of millions of documents and then do full text search on the top 10k or so docs.<p>That seems like a better stacking of the technologies even now</div><br/></div></div></div></div><div id="41058940" class="c"><input type="checkbox" id="c-41058940" checked=""/><div class="controls bullet"><span class="by">verdverm</span><span>|</span><a href="#41057738">root</a><span>|</span><a href="#41057895">parent</a><span>|</span><a href="#41057957">prev</a><span>|</span><a href="#41063517">next</a><span>|</span><label class="collapse" for="c-41058940">[-]</label><label class="expand" for="c-41058940">[1 more]</label></div><br/><div class="children"><div class="content">You can view RAG as a bigger word2vec. The canonical example being &quot;king - man + woman = queen&quot;. Words, or now chunks, have geometric distribution, cluster, and relationships... on semantic levels<p>What is happening is that text is being embedded into a different space, and that format is an array of floats (a point in the embedding space). When we do retrieval, we embed the query and then find other points close to that query. The reason for Vector DB is (1) to optimize for this use-case, we have many specialized data stores &#x2F; indexes (redis, elastic, dolt, RDBMS) (2) often to be memory based for faster retrieval. PgVector will be interesting to watch. I personally use Qdrant<p>Full-text search will never be able to do some of the things that are possible in the embedding space. The most capable systems will use both techniques</div><br/></div></div><div id="41063517" class="c"><input type="checkbox" id="c-41063517" checked=""/><div class="controls bullet"><span class="by">benreesman</span><span>|</span><a href="#41057738">root</a><span>|</span><a href="#41057895">parent</a><span>|</span><a href="#41058940">prev</a><span>|</span><a href="#41057955">next</a><span>|</span><label class="collapse" for="c-41063517">[-]</label><label class="expand" for="c-41063517">[1 more]</label></div><br/><div class="children"><div class="content">Inner product similarity in an embedding space is often a very valuable feature in a ranker, and the effort&#x2F;wow ratio at the prototype phase is good, but the idea that itâs the only pillar of an IR stack is SaaS marketing copy.<p>Vector DBs are cool, you want one handy (particularly for recommender tasks). I recommend FAISS as a solid baseline all these years later. If youâre on modern x86_64 then SVS is pretty shit hot.<p>A search engine that <i>only</i> uses a vector DB is a PoC.<p>For folks who want to go deeper on the topic, Lars basically invented the modern ânews feedâ, which looks a lot like a production RAG system would [1].<p>1. <a href="https:&#x2F;&#x2F;youtu.be&#x2F;BuE3DIJGWOw" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;BuE3DIJGWOw</a></div><br/></div></div><div id="41057955" class="c"><input type="checkbox" id="c-41057955" checked=""/><div class="controls bullet"><span class="by">te_chris</span><span>|</span><a href="#41057738">root</a><span>|</span><a href="#41057895">parent</a><span>|</span><a href="#41063517">prev</a><span>|</span><a href="#41056346">next</a><span>|</span><label class="collapse" for="c-41057955">[-]</label><label class="expand" for="c-41057955">[1 more]</label></div><br/><div class="children"><div class="content">Honestly you clocked the secret: it doesnât.<p>It makes sense for the hype, though. As we got LLMâs we also got wayyyy better embedding models, but theyâre not dependencies.</div><br/></div></div></div></div></div></div><div id="41056346" class="c"><input type="checkbox" id="c-41056346" checked=""/><div class="controls bullet"><span class="by">siquick</span><span>|</span><a href="#41057738">prev</a><span>|</span><a href="#41055608">next</a><span>|</span><label class="collapse" for="c-41056346">[-]</label><label class="expand" for="c-41056346">[8 more]</label></div><br/><div class="children"><div class="content">I canât imagine any serious RAG application is not doing this - adding a contextual title, summary, keywords, and questions to the metadata of each chunk is a pretty low effort&#x2F;high return implementation.</div><br/><div id="41057937" class="c"><input type="checkbox" id="c-41057937" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#41056346">parent</a><span>|</span><a href="#41057796">next</a><span>|</span><label class="collapse" for="c-41057937">[-]</label><label class="expand" for="c-41057937">[2 more]</label></div><br/><div class="children"><div class="content">&gt; adding a contextual title, summary, keywords, and questions<p>That&#x27;s interesting; do you then transform the question-as-prompt before embedding it at runtime, so that it &quot;asks for&quot; that metadata to be in the response? Because otherwise, it would seem to me that you&#x27;re just making it harder for the prompt vector and the document vectors to match.<p>(I guess, if it&#x27;s <i>equally</i> harder in all cases, then that might be fine. But if some of your documents have few tags or no title or something, they might be unfairly advantaged in a vector-distance-ranked search, because the formats of the documents more closely resemble the response format the question was expecting...)</div><br/><div id="41064418" class="c"><input type="checkbox" id="c-41064418" checked=""/><div class="controls bullet"><span class="by">nostrebored</span><span>|</span><a href="#41056346">root</a><span>|</span><a href="#41057937">parent</a><span>|</span><a href="#41057796">next</a><span>|</span><label class="collapse" for="c-41064418">[-]</label><label class="expand" for="c-41064418">[1 more]</label></div><br/><div class="children"><div class="content">You can also train query awareness into the embedding model. This avoids LLMs rewriting questions poorly and lets you embed questions the way your customers actually ask them.<p>For an example with multimodal:
<a href="https:&#x2F;&#x2F;www.marqo.ai&#x2F;blog&#x2F;generalized-contrastive-learning-for-multi-modal-retrieval-and-ranking" rel="nofollow">https:&#x2F;&#x2F;www.marqo.ai&#x2F;blog&#x2F;generalized-contrastive-learning-f...</a><p>But the same approach works with text.</div><br/></div></div></div></div><div id="41057796" class="c"><input type="checkbox" id="c-41057796" checked=""/><div class="controls bullet"><span class="by">J_Shelby_J</span><span>|</span><a href="#41056346">parent</a><span>|</span><a href="#41057937">prev</a><span>|</span><a href="#41056792">next</a><span>|</span><label class="collapse" for="c-41057796">[-]</label><label class="expand" for="c-41057796">[2 more]</label></div><br/><div class="children"><div class="content">How do you generate keywords in a low effort way for each chunk?<p>Asking an LLM is low effort to do, but its not efficient nor guaranteed to be correct.</div><br/><div id="41057835" class="c"><input type="checkbox" id="c-41057835" checked=""/><div class="controls bullet"><span class="by">kkzz99</span><span>|</span><a href="#41056346">root</a><span>|</span><a href="#41057796">parent</a><span>|</span><a href="#41056792">next</a><span>|</span><label class="collapse" for="c-41057835">[-]</label><label class="expand" for="c-41057835">[1 more]</label></div><br/><div class="children"><div class="content">If the economical case justifies it you can use a cheap or lower end model to generate the meta information. Considering how cheap gpt-4o-mini is, seems pretty plausible to do that.<p>At my startup we also got pretty good results using 7B&#x2F;8B models to generate meta information about chunks&#x2F;parts of text.</div><br/></div></div></div></div><div id="41056792" class="c"><input type="checkbox" id="c-41056792" checked=""/><div class="controls bullet"><span class="by">visarga</span><span>|</span><a href="#41056346">parent</a><span>|</span><a href="#41057796">prev</a><span>|</span><a href="#41057468">next</a><span>|</span><label class="collapse" for="c-41056792">[-]</label><label class="expand" for="c-41056792">[2 more]</label></div><br/><div class="children"><div class="content">Text embeds don&#x27;t capture inferred data, like &quot;second letter of this text&quot; does not embed close to &quot;e&quot;. LLM chain of thought is required to deduce the meaning more completely.</div><br/><div id="41058033" class="c"><input type="checkbox" id="c-41058033" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#41056346">root</a><span>|</span><a href="#41056792">parent</a><span>|</span><a href="#41057468">next</a><span>|</span><label class="collapse" for="c-41058033">[-]</label><label class="expand" for="c-41058033">[1 more]</label></div><br/><div class="children"><div class="content">Given current SOTA, no, they donât.<p>But thereâs no reason why they <i>couldnât</i> â just capture the vectors of some of the earlier hidden layers during the RAG encoderâs inference run, and append these intermediate vectors to the final embedding vector of the output layer to become the vectors you throw into your vector DB. (And then do the same at runtime for embedding your query prompts.)<p>Probably youâd want to bias those internal-layer vectors, giving them an increasingly-high âartificial distanceâ coefficient for increasingly-early layers â so that a document closely matching in token space or word space or syntax-node space improves its retrieval rank a <i>bit</i>, but not nearly as much as if the document were a close match in concept space. (But maybe do something nonlinear instead of multiplication here â you might want <i>near-identical</i> token-wise or syntax-wise matches to show up despite different meanings, depending on your use-case.)<p>Come to think, you could probably build a pretty good source-code search RAG off of this approach.<p>(Also, it should hopefully be obvious here that if you fine-tuned an encoder-decoder LLM to label matches based on criteria where some of those criteria are only available in earlier layers, then youâd be training pass-through vector dimensions into the intermediate layers of the encoder â such that using such an encoder on its own for RAG embedding should produce the same effect as capturing + weighting the intermediate layers of a non-fine-tuned LLM.)</div><br/></div></div></div></div><div id="41057468" class="c"><input type="checkbox" id="c-41057468" checked=""/><div class="controls bullet"><span class="by">samx18</span><span>|</span><a href="#41056346">parent</a><span>|</span><a href="#41056792">prev</a><span>|</span><a href="#41055608">next</a><span>|</span><label class="collapse" for="c-41057468">[-]</label><label class="expand" for="c-41057468">[1 more]</label></div><br/><div class="children"><div class="content">I agree, most production RAG systems have been doing this since last year</div><br/></div></div></div></div><div id="41055608" class="c"><input type="checkbox" id="c-41055608" checked=""/><div class="controls bullet"><span class="by">Satam</span><span>|</span><a href="#41056346">prev</a><span>|</span><a href="#41064783">next</a><span>|</span><label class="collapse" for="c-41055608">[-]</label><label class="expand" for="c-41055608">[30 more]</label></div><br/><div class="children"><div class="content">RAG feels hacky to me. Weâre coming up with these pseudo-technical solutions to help but really they should be solved at the level of the model by researchers. Until this is solved natively, the attempts will be hacky duct-taped solutions.</div><br/><div id="41057160" class="c"><input type="checkbox" id="c-41057160" checked=""/><div class="controls bullet"><span class="by">l72</span><span>|</span><a href="#41055608">parent</a><span>|</span><a href="#41055988">next</a><span>|</span><label class="collapse" for="c-41057160">[-]</label><label class="expand" for="c-41057160">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve described it this way to my colleagues:<p>RAG is a bit like having a pretty smart person take an open book test on a subject they are not an expert in. If your book has a good chapter layout and index, you probably do an ok job trying to find relevant information, quickly read it, and try to come up with an answer. But your not going to be able to test for a deep understanding of the material. This person is going to struggle if each chapter&#x2F;concept builds on the previous concept, as you can&#x27;t just look up something in Chapter 10 and be able to understand it without understanding Chapter 1-9.<p>Fine-tuning is a bit more like having someone go off and do a phd and specialize in a specific area. They get a much deeper understanding for the problem space and can conceptualize at a different level.</div><br/><div id="41064799" class="c"><input type="checkbox" id="c-41064799" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#41055608">root</a><span>|</span><a href="#41057160">parent</a><span>|</span><a href="#41055988">next</a><span>|</span><label class="collapse" for="c-41064799">[-]</label><label class="expand" for="c-41064799">[4 more]</label></div><br/><div class="children"><div class="content">What you said about RAG makes sense, but my understanding is that fine-tuning is actually not very good at getting deeper understanding out of LLMs. It&#x27;s more useful for teaching general instructions like output format rather than teaching deep concepts like a new domain of science.</div><br/><div id="41065334" class="c"><input type="checkbox" id="c-41065334" checked=""/><div class="controls bullet"><span class="by">bashfulpup</span><span>|</span><a href="#41055608">root</a><span>|</span><a href="#41064799">parent</a><span>|</span><a href="#41055988">next</a><span>|</span><label class="collapse" for="c-41065334">[-]</label><label class="expand" for="c-41065334">[3 more]</label></div><br/><div class="children"><div class="content">This is true if you don&#x27;t know what you&#x27;re doing, so it is good advice for the vast majority.<p>Fine tuning is just training. You can completely change the model if you want make learn anything you want.<p>But there are MANY challenges in doing so.</div><br/><div id="41065404" class="c"><input type="checkbox" id="c-41065404" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#41055608">root</a><span>|</span><a href="#41065334">parent</a><span>|</span><a href="#41055988">next</a><span>|</span><label class="collapse" for="c-41065404">[-]</label><label class="expand" for="c-41065404">[2 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t true either, because if you don&#x27;t have access to the original data set, the model will overfit on your fine tuning data set and (in the extreme cases) lose its ability to even do basic reasoning.</div><br/><div id="41065645" class="c"><input type="checkbox" id="c-41065645" checked=""/><div class="controls bullet"><span class="by">bashfulpup</span><span>|</span><a href="#41055608">root</a><span>|</span><a href="#41065404">parent</a><span>|</span><a href="#41055988">next</a><span>|</span><label class="collapse" for="c-41065645">[-]</label><label class="expand" for="c-41065645">[1 more]</label></div><br/><div class="children"><div class="content">Again, that&#x27;s why I said it is challenging.<p>I regularly do fine tuning on a model with fine results and little damage to the base functionality.<p>It is possible, but it&#x27;s too complex for the majority of users. It requires a lot of work per dataset you want trained on.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41055988" class="c"><input type="checkbox" id="c-41055988" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#41055608">parent</a><span>|</span><a href="#41057160">prev</a><span>|</span><a href="#41055650">next</a><span>|</span><label class="collapse" for="c-41055988">[-]</label><label class="expand" for="c-41055988">[12 more]</label></div><br/><div class="children"><div class="content">That&#x27;s so vague I can&#x27;t tell what you&#x27;re suggesting. What specifically do you think needs solving at the model level? What should work differently?</div><br/><div id="41056415" class="c"><input type="checkbox" id="c-41056415" checked=""/><div class="controls bullet"><span class="by">Satam</span><span>|</span><a href="#41055608">root</a><span>|</span><a href="#41055988">parent</a><span>|</span><a href="#41056424">next</a><span>|</span><label class="collapse" for="c-41056415">[-]</label><label class="expand" for="c-41056415">[10 more]</label></div><br/><div class="children"><div class="content">Thereâs probably lack of cpabalities on multiple fronts. RAG might have the right general idea but currently the retrieval seems to be too seperated from the model itself. I donât know how our brains do it, but retrieval looks to be more integrated there.<p>Models currently also have no way to update themselves with new info besides us putting data into their context window. They donât learn after the initial training. It seems if they could, say, read documentation and internalize it, the need for RAG or even large context windows would decrease. Humans somehow are able to build understanding of extensive topics with what feels to be a much shorter  context-window.</div><br/><div id="41056822" class="c"><input type="checkbox" id="c-41056822" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#41055608">root</a><span>|</span><a href="#41056415">parent</a><span>|</span><a href="#41057493">next</a><span>|</span><label class="collapse" for="c-41056822">[-]</label><label class="expand" for="c-41056822">[4 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t forget the importance of data privacy. Updating a model with fresh information makes that information available to ALL users of that model. This often isn&#x27;t what you want - you can run RAG against a user&#x27;s private email to answer just their queries, without making that email &quot;baked in&quot; to the model.</div><br/><div id="41056858" class="c"><input type="checkbox" id="c-41056858" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#41055608">root</a><span>|</span><a href="#41056822">parent</a><span>|</span><a href="#41057493">next</a><span>|</span><label class="collapse" for="c-41056858">[-]</label><label class="expand" for="c-41056858">[3 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need to update the whole model for everyone. Fine tuning exists and is even available as a service in openai. The updates are only visible in the specific models you see.</div><br/><div id="41056972" class="c"><input type="checkbox" id="c-41056972" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#41055608">root</a><span>|</span><a href="#41056858">parent</a><span>|</span><a href="#41057493">next</a><span>|</span><label class="collapse" for="c-41056972">[-]</label><label class="expand" for="c-41056972">[2 more]</label></div><br/><div class="children"><div class="content">Maintaining a fine-tuned model for every one of your users - even with techniques like LoRA - sounds complicated and expensive to me!</div><br/><div id="41060479" class="c"><input type="checkbox" id="c-41060479" checked=""/><div class="controls bullet"><span class="by">lowdest</span><span>|</span><a href="#41055608">root</a><span>|</span><a href="#41056972">parent</a><span>|</span><a href="#41057493">next</a><span>|</span><label class="collapse" for="c-41060479">[-]</label><label class="expand" for="c-41060479">[1 more]</label></div><br/><div class="children"><div class="content">It is, but it&#x27;s also not that bad. A copy of the weights is X GB of cloud storage, which can be stored as a diff if it helps, and added compute time for loading a custom model and unloading for the next customer. It&#x27;s not free, but it&#x27;s an approachable cost for a premium service.</div><br/></div></div></div></div></div></div></div></div><div id="41057493" class="c"><input type="checkbox" id="c-41057493" checked=""/><div class="controls bullet"><span class="by">michalwarda</span><span>|</span><a href="#41055608">root</a><span>|</span><a href="#41056415">parent</a><span>|</span><a href="#41056822">prev</a><span>|</span><a href="#41057665">next</a><span>|</span><label class="collapse" for="c-41057493">[-]</label><label class="expand" for="c-41057493">[3 more]</label></div><br/><div class="children"><div class="content">I guess it&#x27;s because people are not using tools enough yet. In my tests giving LLM access to tools for retrieval works much better then trying to guess what the RAG would need to answer. ie. LLM decides if it has all of the necessary information to answer the question. If not, let it search for it. If it still fails than let it search more :D</div><br/><div id="41058553" class="c"><input type="checkbox" id="c-41058553" checked=""/><div class="controls bullet"><span class="by">zmccormick7</span><span>|</span><a href="#41055608">root</a><span>|</span><a href="#41057493">parent</a><span>|</span><a href="#41057665">next</a><span>|</span><label class="collapse" for="c-41058553">[-]</label><label class="expand" for="c-41058553">[2 more]</label></div><br/><div class="children"><div class="content">Agreed. Retrieval performance is very dependent on the quality of the search queries. Letting the LLM generate the search queries is much more reliable than just embedding the user input. Also, no retrieval system is going to return everything needed on the first try, so using a multi-step agent approach to retrieving information is the only way I&#x27;ve found to get extremely high accuracy.</div><br/><div id="41064436" class="c"><input type="checkbox" id="c-41064436" checked=""/><div class="controls bullet"><span class="by">nostrebored</span><span>|</span><a href="#41055608">root</a><span>|</span><a href="#41058553">parent</a><span>|</span><a href="#41057665">next</a><span>|</span><label class="collapse" for="c-41064436">[-]</label><label class="expand" for="c-41064436">[1 more]</label></div><br/><div class="children"><div class="content">The queries you see and the resulting user interaction should be trained into the embedding model.<p>This is a foundational problem that requires your data. The way you search Etsy is different than the way you search Amazon. The queries these systems see are different and so are the desired results.<p>Trying to solve the problem with pretrained models is not currently realistic.</div><br/></div></div></div></div></div></div><div id="41057665" class="c"><input type="checkbox" id="c-41057665" checked=""/><div class="controls bullet"><span class="by">mewpmewp2</span><span>|</span><a href="#41055608">root</a><span>|</span><a href="#41056415">parent</a><span>|</span><a href="#41057493">prev</a><span>|</span><a href="#41057280">next</a><span>|</span><label class="collapse" for="c-41057665">[-]</label><label class="expand" for="c-41057665">[1 more]</label></div><br/><div class="children"><div class="content">Our brains aren&#x27;t even doing it also. We can&#x27;t memorise all the things in the World. For us a library&#x2F;Google Search is what RAG is for an LLM.</div><br/></div></div><div id="41057280" class="c"><input type="checkbox" id="c-41057280" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#41055608">root</a><span>|</span><a href="#41056415">parent</a><span>|</span><a href="#41057665">prev</a><span>|</span><a href="#41056424">next</a><span>|</span><label class="collapse" for="c-41057280">[-]</label><label class="expand" for="c-41057280">[1 more]</label></div><br/><div class="children"><div class="content">I can answer questions off the cuff based on the weights of the neural network in my head.  If I really wanted to get the right answers I would do &quot;RAG&quot; in the sense of looking up answers on the web or at the library and summarizing them.<p>For instance I have a policy that I try hard not to say anything like &quot;most people think that...&quot; without providing links because I work at an archive of public opinion data and if it gets out that one of our people was spouting false information about our domain, even if we weren&#x27;t advertising the affiliation, that would look bad.</div><br/></div></div></div></div><div id="41056424" class="c"><input type="checkbox" id="c-41056424" checked=""/><div class="controls bullet"><span class="by">emrah</span><span>|</span><a href="#41055608">root</a><span>|</span><a href="#41055988">parent</a><span>|</span><a href="#41056415">prev</a><span>|</span><a href="#41055650">next</a><span>|</span><label class="collapse" for="c-41056424">[-]</label><label class="expand" for="c-41056424">[1 more]</label></div><br/><div class="children"><div class="content">I think he is saying we should be making fine-tuning or otherwise similar model altering methods easier rather than messing with bolt-on solutions like RAG<p>Those are being worked on and RAG is the ducktape solution until they become available</div><br/></div></div></div></div><div id="41055650" class="c"><input type="checkbox" id="c-41055650" checked=""/><div class="controls bullet"><span class="by">repeekad</span><span>|</span><a href="#41055608">parent</a><span>|</span><a href="#41055988">prev</a><span>|</span><a href="#41057620">next</a><span>|</span><label class="collapse" for="c-41055650">[-]</label><label class="expand" for="c-41055650">[6 more]</label></div><br/><div class="children"><div class="content">What about fresh data like an extremely relevant news headline that was published 10 minutes ago? Private data that I donât want stored offsite but am okay trusting an enterprise no log api? Providing realtime context to LLMs isnât âhackyâ, model intelligence and RAG can complement each other and make advancements in tandem</div><br/><div id="41055703" class="c"><input type="checkbox" id="c-41055703" checked=""/><div class="controls bullet"><span class="by">jstummbillig</span><span>|</span><a href="#41055608">root</a><span>|</span><a href="#41055650">parent</a><span>|</span><a href="#41057534">next</a><span>|</span><label class="collapse" for="c-41055703">[-]</label><label class="expand" for="c-41055703">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think the parents idea was to bake all information into the model, just that current RAG feels cumbersome to use (but then again, so do most things AI right now) and information access should be intrinsic part of the model.</div><br/><div id="41056193" class="c"><input type="checkbox" id="c-41056193" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41055608">root</a><span>|</span><a href="#41055703">parent</a><span>|</span><a href="#41055774">prev</a><span>|</span><a href="#41057534">next</a><span>|</span><label class="collapse" for="c-41056193">[-]</label><label class="expand" for="c-41056193">[1 more]</label></div><br/><div class="children"><div class="content">Is there a specific shortcoming of the model that could be improved, or are we simply seeking better APIs?</div><br/></div></div></div></div><div id="41057534" class="c"><input type="checkbox" id="c-41057534" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#41055608">root</a><span>|</span><a href="#41055650">parent</a><span>|</span><a href="#41055703">prev</a><span>|</span><a href="#41057620">next</a><span>|</span><label class="collapse" for="c-41057534">[-]</label><label class="expand" for="c-41057534">[2 more]</label></div><br/><div class="children"><div class="content">One of my favorite cases is sports chat.  I&#x27;d expect ChatGPT to be able to talk about sports legends but not be able to talk about a game that happened last weekend.  Copilot usually does a good job because it can look up the game on Bing and them summarize but the other day i asked it &quot;What happened last week in the NFL&quot; and it told me about a Buffalo Bills game from last year (did it know I was in the Bills geography?)<p>Some kind of incremental fine tuning is probably necessary to keep a model like ChatGPT up to date but I can&#x27;t picture it happening each time something happens in the news.</div><br/><div id="41059290" class="c"><input type="checkbox" id="c-41059290" checked=""/><div class="controls bullet"><span class="by">ec109685</span><span>|</span><a href="#41055608">root</a><span>|</span><a href="#41057534">parent</a><span>|</span><a href="#41057620">next</a><span>|</span><label class="collapse" for="c-41059290">[-]</label><label class="expand" for="c-41059290">[1 more]</label></div><br/><div class="children"><div class="content">For the current game, it seems solvable by providing it the Boxscore and the radio commentary as context, perhaps with some additional data derived from recent games and news.<p>I think youâd get a close approximation of speaking with someone who was watching the game with you.</div><br/></div></div></div></div></div></div><div id="41057620" class="c"><input type="checkbox" id="c-41057620" checked=""/><div class="controls bullet"><span class="by">williamtrask</span><span>|</span><a href="#41055608">parent</a><span>|</span><a href="#41055650">prev</a><span>|</span><a href="#41061707">next</a><span>|</span><label class="collapse" for="c-41057620">[-]</label><label class="expand" for="c-41057620">[1 more]</label></div><br/><div class="children"><div class="content">Fwiw, I used to think this way too but LLMs are more RAG-like internally than we initially realised. Attention is all you need ~= RAG is a big attention mechanism. Models have reverse curse, memorisation issues etc. I personally think of LLMs as a kind of decomposed RAG. Check out DeepMindâs RETRO paper for an even closer integration.</div><br/></div></div><div id="41061707" class="c"><input type="checkbox" id="c-41061707" checked=""/><div class="controls bullet"><span class="by">zby</span><span>|</span><a href="#41055608">parent</a><span>|</span><a href="#41057620">prev</a><span>|</span><a href="#41056556">next</a><span>|</span><label class="collapse" for="c-41061707">[-]</label><label class="expand" for="c-41061707">[2 more]</label></div><br/><div class="children"><div class="content">I guess you can imagine an LLM that contains all information there is - but it would have to be at least as big as all information there is or it would have to hallucinate. And also you  Not to mention that it seems that you would also require it to learn everything immediately. I don&#x27;t see any realistic way to reach that goal.<p>To reach their potential LLMs need to know how to use external sources.<p>Update: After some more thinking - if you required it to know information about itself - then this would lead to some paradox - I am sure.</div><br/><div id="41065318" class="c"><input type="checkbox" id="c-41065318" checked=""/><div class="controls bullet"><span class="by">bashfulpup</span><span>|</span><a href="#41055608">root</a><span>|</span><a href="#41061707">parent</a><span>|</span><a href="#41056556">next</a><span>|</span><label class="collapse" for="c-41065318">[-]</label><label class="expand" for="c-41065318">[1 more]</label></div><br/><div class="children"><div class="content">A CL agent is next generation AI.<p>When CL is properly implemented in an LLM agent format, most of these systems vanish.</div><br/></div></div></div></div><div id="41056556" class="c"><input type="checkbox" id="c-41056556" checked=""/><div class="controls bullet"><span class="by">ac1spkrbox</span><span>|</span><a href="#41055608">parent</a><span>|</span><a href="#41061707">prev</a><span>|</span><a href="#41057756">next</a><span>|</span><label class="collapse" for="c-41056556">[-]</label><label class="expand" for="c-41056556">[2 more]</label></div><br/><div class="children"><div class="content">The set of techniques for retrieval is immature, but it&#x27;s important to note that just relying on model context or few-shot prompting has many drawbacks. Perhaps the most important is that retrieval as a task should not rely on generative outputs.</div><br/><div id="41056947" class="c"><input type="checkbox" id="c-41056947" checked=""/><div class="controls bullet"><span class="by">danielbln</span><span>|</span><a href="#41055608">root</a><span>|</span><a href="#41056556">parent</a><span>|</span><a href="#41057756">next</a><span>|</span><label class="collapse" for="c-41056947">[-]</label><label class="expand" for="c-41056947">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also subject to significantly more hallucination when the knowledge is baked into the model, vs being injected into the context at runtime.</div><br/></div></div></div></div><div id="41057756" class="c"><input type="checkbox" id="c-41057756" checked=""/><div class="controls bullet"><span class="by">jejeyyy77</span><span>|</span><a href="#41055608">parent</a><span>|</span><a href="#41056556">prev</a><span>|</span><a href="#41064783">next</a><span>|</span><label class="collapse" for="c-41057756">[-]</label><label class="expand" for="c-41057756">[1 more]</label></div><br/><div class="children"><div class="content">The biggest problem with RAG is that the bottleneck for your product is now the RAG (i.e, results are only as good as what your vector store sends to the LLM). This is a step backwards.<p>Source: built a few products using RAG+LLM products.</div><br/></div></div></div></div><div id="41064783" class="c"><input type="checkbox" id="c-41064783" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#41055608">prev</a><span>|</span><a href="#41065127">next</a><span>|</span><label class="collapse" for="c-41064783">[-]</label><label class="expand" for="c-41064783">[1 more]</label></div><br/><div class="children"><div class="content">An interesting paper that was recently published that talks about a different approach: Human-like Episodic Memory for Infinite Context LLMs &lt;<a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2407.09450" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2407.09450</a>&gt;<p>This wasn&#x27;t focused on RAG, but there seems to be a lot of crossover to me. Using the LLM to make &quot;episodes&quot; is a similar problem to chunking, and letting the LLM decide the boundary might also yield good results.</div><br/></div></div><div id="41065127" class="c"><input type="checkbox" id="c-41065127" checked=""/><div class="controls bullet"><span class="by">iAkashPaul</span><span>|</span><a href="#41064783">prev</a><span>|</span><a href="#41055670">next</a><span>|</span><label class="collapse" for="c-41065127">[-]</label><label class="expand" for="c-41065127">[1 more]</label></div><br/><div class="children"><div class="content">One quick way to improve results greatly is to ask questions with 2&#x2F;3 chunks &amp; in the lookup for these chunks mention the IDs of the other chunks, qdrant allows for easy metadata addition. So just generate a synthetic question bank &amp; then do vSearch against the same instead of hoping for the chunks to match up with user questions.</div><br/></div></div><div id="41055670" class="c"><input type="checkbox" id="c-41055670" checked=""/><div class="controls bullet"><span class="by">CharlieDigital</span><span>|</span><a href="#41065127">prev</a><span>|</span><a href="#41058152">next</a><span>|</span><label class="collapse" for="c-41055670">[-]</label><label class="expand" for="c-41055670">[13 more]</label></div><br/><div class="children"><div class="content">The easiest solution to this is to stuff the heading into the chunk.  The heading is hierarchical navigation within the sections of the document.<p>I found Azure Document Intelligence specifically with the Layout Model to be fantastic for this because it can identify headers.  All the better if you write a parser for the output JSON to track depth and stuff multiple headers from the path into the chunk.</div><br/><div id="41056404" class="c"><input type="checkbox" id="c-41056404" checked=""/><div class="controls bullet"><span class="by">lmeyerov</span><span>|</span><a href="#41055670">parent</a><span>|</span><a href="#41059478">next</a><span>|</span><label class="collapse" for="c-41056404">[-]</label><label class="expand" for="c-41056404">[8 more]</label></div><br/><div class="children"><div class="content">So subtle! The article is on doing that, which is something we are doing a lot on right now... though it seems to snatch defeat from the jaws of victory:<p>If we think about what this is about, it is basically entity augmentation &amp; lexical linking &#x2F; citations.<p>Ex: A patient document may be all about patient id 123. That won&#x27;t be spelled out in every paragraph, but by carrying along the patient ID (semantic entity) and the document (citation), the combined model gets access to them. A naive one-shot retrieval over a naive chunked vector index would want it at the text&#x2F;embedding, while a smarter one also in the entry metadata. And as others write, this helps move reasoning from the symbolic domain to the semantic domain, so less of a hack.<p>We are working on some fun &#x27;pure-vector&#x27; graph RAG work here to tackle production problems around scale, quality, &amp; always-on scenarios like alerting - happy to chat!</div><br/><div id="41057273" class="c"><input type="checkbox" id="c-41057273" checked=""/><div class="controls bullet"><span class="by">CharlieDigital</span><span>|</span><a href="#41055670">root</a><span>|</span><a href="#41056404">parent</a><span>|</span><a href="#41056611">next</a><span>|</span><label class="collapse" for="c-41057273">[-]</label><label class="expand" for="c-41057273">[6 more]</label></div><br/><div class="children"><div class="content">Also working with GRAG (via Neo4j) and I&#x27;m somewhat skeptical that for most cases where a natural hierarchical structure already exists that graph will significantly exceed RAG with the hierarchical structure.<p>A better solution I had thought about its &quot;local RAG&quot;.  I came across this while processing embeddings from chunks parsed from Azure Document Intelligence JSON.  The realization is that relevant topics are often localized within a document. Even across a corpus of documents, relevant passages are localized.<p>Because the chunks are processed sequentially, one needs only to keep track o the sequence number of the chunk.  Assume that the embedding matches with a chunk <i>n</i>, then it would follow that the most important context are the chunks localized at <i>n - m</i> and <i>n + p</i>.  So find the top <i>x</i> chunks via hybrid embedding + full text match and expand outwards from each of the chunks to grab the chunks around it.<p>While a chunk may represent just a few sentences of a larger block of text, this strategy will grab possibly the whole section or page of text localized around the chunk with the highest match.</div><br/><div id="41057451" class="c"><input type="checkbox" id="c-41057451" checked=""/><div class="controls bullet"><span class="by">michalwarda</span><span>|</span><a href="#41055670">root</a><span>|</span><a href="#41057273">parent</a><span>|</span><a href="#41056611">next</a><span>|</span><label class="collapse" for="c-41057451">[-]</label><label class="expand" for="c-41057451">[5 more]</label></div><br/><div class="children"><div class="content">This works until relevant information is colocated. 
Sometimes though, for example in financial documents, important parts reference each other through keywords etc. That&#x27;s why you can always try and retrieve not only positionally related chunks but also semantically related ones.<p>Go for chunk n, n - m, n + p and n&#x27; where n&#x27; are closest chunks to n semantically.<p>Moreover you can give this traversal possibility to your LLM to use itself as a tool or w&#x2F;e whenever it is missing crucial information to answer the question. Thanks to that you don&#x27;t always retrieve thousands of tokens even when not needed.</div><br/><div id="41057653" class="c"><input type="checkbox" id="c-41057653" checked=""/><div class="controls bullet"><span class="by">CharlieDigital</span><span>|</span><a href="#41055670">root</a><span>|</span><a href="#41057451">parent</a><span>|</span><a href="#41056611">next</a><span>|</span><label class="collapse" for="c-41057653">[-]</label><label class="expand" for="c-41057653">[4 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    &gt; positionally related chunks but also semantically related ones
</code></pre>
That&#x27;s why the entry point would still be an embedding search; it&#x27;s just that instead of using the first 20 embedding hits, you take the first 5 and if the reference is &quot;semantically adjacent&quot; to the entry concept, we would expect that some of the first few chunks would capture it in most cases.<p>I think where GRAG yields more relevancy is when the referenced content is <i>not</i> semantically similar nor even semantically adjacent to the entry concept but is semantically similar to some sub fragment of a matched chunk.  Depending on the corpus, this can either be common (no familiarity with financial documents) or rare.  I&#x27;ve primarily worked with clinical trial protocols and at least in that space, the concepts are what I would consider &quot;snowflake-shaped&quot; in that it branches out pretty cleanly and rarely cross-references (because it is more common that it repeats the relevant reference).<p>All that said, I think that as a matter of practicality, most teams will probably get much bigger yield with much less effort doing local expansion based on matching for semantic similarity first since it addresses two core problems with embeddings (text chunk size vs embedding accuracy, relevancy or embeddings matched below a given threshold).  Experiment with GRAG depending on the type of questions you&#x27;re trying to answer and the nature of the underlying content.  Don&#x27;t get me wrong; I&#x27;m not saying GRAG has <i>no</i> benefit, but that most teams can explore other ways of using RAG before trying GRAG.</div><br/><div id="41057933" class="c"><input type="checkbox" id="c-41057933" checked=""/><div class="controls bullet"><span class="by">lmeyerov</span><span>|</span><a href="#41055670">root</a><span>|</span><a href="#41057653">parent</a><span>|</span><a href="#41056611">next</a><span>|</span><label class="collapse" for="c-41057933">[-]</label><label class="expand" for="c-41057933">[3 more]</label></div><br/><div class="children"><div class="content">Neo4j graph rag is typically not graph rag in the AI sense  &#x2F; MSR Graph RAG paper sense, but KG or lexical extraction &amp; embedding, and some retrieval time hope of the neighborhood being ok<p>GRAG in the direction of the MSR paper adds some important areas:<p>- summary indexes that can be lexical (document hierarchy) or not (topic, patient ID, etc), esp via careful entity extraction &amp; linking<p>- domain-optimized summarization  templates, both automated &amp; manual<p>- + as mentioned, wider context around these at retrieval<p>- introducing a more generalized framework for handling different kinds of concept relations, summary indexing, and retrieval around these<p>Ex: The same patient over time &amp; docz, and seperately, similar kinds  of patients across documents<p>Note that I&#x27;m not actually a big fan of how the MSR paper indirects the work through KG extraction, as that exits the semantic domain, and we don&#x27;t do it that way<p>Fundamentally, that both moves away from paltry retrieval result sets that are small&#x2F;gaps&#x2F;etc, and enables cleaner input to the runtime query<p>I agree it is a quick win if quality can be low and you have low budget&#x2F;time. Like combine a few out of the box index types and do rank retrieval. But a lot of the power gets lost. We are working on infra (+ OSSing it) because that is an unfortunate and unnecessary state of affairs. Right now llamaindex&#x2F;langchain and raw vector DBs feel like adhoc and unprincipled ways to build these pipelines in a software engineering and AI perspective, so from an investment side, moving away from hacks and to more semantic,  composable, &amp; scalable pipelines is important IMO.</div><br/><div id="41058067" class="c"><input type="checkbox" id="c-41058067" checked=""/><div class="controls bullet"><span class="by">CharlieDigital</span><span>|</span><a href="#41055670">root</a><span>|</span><a href="#41057933">parent</a><span>|</span><a href="#41056611">next</a><span>|</span><label class="collapse" for="c-41058067">[-]</label><label class="expand" for="c-41058067">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    &gt; Neo4j graph rag is typically not graph rag
</code></pre>
I would mildly disagree with this; Neo4j just serves as an underlying storage mechanism much like Postgres+pgvector could be the underlying storage mechanism for embedding-only RAG.  How one extracts entities and connects them in the graph happens a layer above the storage layer of Neo4j (though Neo4j can also do this internally).  Neo4j is not magic; the application layer and data modelling still has to define which entities and how they are connected.<p>But why Neo4j? Neo4j has some nice amenities for building GRAG on top of.  In particular, it has packages to support community partitioning including Leiden[0] (also used by Microsoft&#x27;s GraphRAG[1]) and Louvain[2] as well as several other community detection algorithms.  The built-in support for node embeddings[3] as well as external AI APIs[4] make the DX -- in so far as building the underlying storage for complex retrieval -- quite good, IMO.<p>The approach that we are taking is that we are importing a corpus of information into Neo4j and performing ETL on the way in to create additional relationships; effectively connecting individual chunks by some related &quot;facet&quot;.  Then we plan to run community detection over it to identify communities of interest and use a combination of communities, locality, and embedding match to retrieve chunks.<p>I just started exploring it over the past week and I would say that if your team is going to end up doing some more complex GRAG, then Neo4j feels like it has the right tooling to be the underlying storage layer and you <i>could</i> even feasibly implement other parts of your workflow in there as well, but entity extraction and such feels like it belongs one layer up in the application layer.  Most notably, having direct query access to the underlying graph with a graph query language (Cypher) means that you will have more control and different ways to experiment with retrieval.  However; as I mentioned, I would encourage most teams to be more clever with embedding RAG before adding more infrastructure like Neo4j.<p>[0] <a href="https:&#x2F;&#x2F;neo4j.com&#x2F;docs&#x2F;graph-data-science&#x2F;current&#x2F;algorithms&#x2F;leiden&#x2F;" rel="nofollow">https:&#x2F;&#x2F;neo4j.com&#x2F;docs&#x2F;graph-data-science&#x2F;current&#x2F;algorithms...</a><p>[1] <a href="https:&#x2F;&#x2F;microsoft.github.io&#x2F;graphrag&#x2F;" rel="nofollow">https:&#x2F;&#x2F;microsoft.github.io&#x2F;graphrag&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;neo4j.com&#x2F;docs&#x2F;graph-data-science&#x2F;current&#x2F;algorithms&#x2F;louvain&#x2F;" rel="nofollow">https:&#x2F;&#x2F;neo4j.com&#x2F;docs&#x2F;graph-data-science&#x2F;current&#x2F;algorithms...</a><p>[3] <a href="https:&#x2F;&#x2F;neo4j.com&#x2F;docs&#x2F;graph-data-science&#x2F;current&#x2F;machine-learning&#x2F;node-embeddings&#x2F;" rel="nofollow">https:&#x2F;&#x2F;neo4j.com&#x2F;docs&#x2F;graph-data-science&#x2F;current&#x2F;machine-le...</a><p>[4] <a href="https:&#x2F;&#x2F;neo4j.com&#x2F;labs&#x2F;apoc&#x2F;5&#x2F;ml&#x2F;openai&#x2F;" rel="nofollow">https:&#x2F;&#x2F;neo4j.com&#x2F;labs&#x2F;apoc&#x2F;5&#x2F;ml&#x2F;openai&#x2F;</a></div><br/><div id="41059421" class="c"><input type="checkbox" id="c-41059421" checked=""/><div class="controls bullet"><span class="by">lmeyerov</span><span>|</span><a href="#41055670">root</a><span>|</span><a href="#41058067">parent</a><span>|</span><a href="#41056611">next</a><span>|</span><label class="collapse" for="c-41059421">[-]</label><label class="expand" for="c-41059421">[1 more]</label></div><br/><div class="children"><div class="content">We generally stick with using neo4j&#x2F;neptune&#x2F;etc for more operational OLTP graph queries, basically large-scale managed storage for small neighborhood lookups. As soon as the task becomes more compute-tier AI workloads, like LLM summary indexing of 1M tweets or 10K documents, we prefer to use GPU-based compute stacks &amp; external APIs with more fidelity. Think pipelines combining bulk embeddings, rich enrichment &amp; wrangling, GNNs, community detection, etc. We only dump into DBs at the end. Speedups are generally in the 2-100X territory with even cheapo GPUs, so this ends up a big deal for both development + production. Likewise, continuous update flows end up being awkward in these environments vs full compute-tier ones, even ignoring the GPU aspect.<p>Separately, we&#x27;re still unsure about vector search inside vs outside the graph DB during retrieval, both in the graph RAG scenario and the more general intelligence work domains. I&#x27;m more optimistic there for keeping in these graph DB, especially for small cases (&lt; 10M node+edges) we do in notebooks.<p>And agreed, it&#x27;s unfortunate neo4j uses graph RAG to market a variety of mostly bad quality solutions and conflate it with graph db storage, and the MSR researchers used it for a more specific and more notable technique (in AI circles) that doesn&#x27;t need a graph DB and IMO, fundamentally, not even a KG. It&#x27;s especially confusing that both groups are &#x27;winning&#x27; on the term... in different circles.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41059478" class="c"><input type="checkbox" id="c-41059478" checked=""/><div class="controls bullet"><span class="by">ec109685</span><span>|</span><a href="#41055670">parent</a><span>|</span><a href="#41056404">prev</a><span>|</span><a href="#41055847">next</a><span>|</span><label class="collapse" for="c-41059478">[-]</label><label class="expand" for="c-41059478">[2 more]</label></div><br/><div class="children"><div class="content">Would it be better to go all the way and completely rewrite the source material in a way more suitable for retrieval? To some extent these headers are a step in that direction, but youâre still at the mercy of the chunk of text being suitable to answer the question.<p>Instead, completely transforming the text into a dense set of denormalized ânotesâ that cover every concept present in the text seems like it would be easier to mine for answers to user questions.<p>Essentially, it would be like taking comprehensive notes from a book and handing them to a friend who didnât take the class for a test. What would they need to be effective?<p>Longer term, the sequence would likely be âget questionâ, hand it to research assistant who has full access to source material and can run a variety of AI &#x2F; retrieval strategies to customize the notes, and then hand those notes back for answers. By spending more time on the note gathering step, it will be more likely the LLM will be able to answer the question.</div><br/><div id="41062850" class="c"><input type="checkbox" id="c-41062850" checked=""/><div class="controls bullet"><span class="by">CharlieDigital</span><span>|</span><a href="#41055670">root</a><span>|</span><a href="#41059478">parent</a><span>|</span><a href="#41055847">next</a><span>|</span><label class="collapse" for="c-41062850">[-]</label><label class="expand" for="c-41062850">[1 more]</label></div><br/><div class="children"><div class="content">For a large corpus, this would be quite expensive in terms of time and storage space.  My experience is that embeddings work pretty well around 144-160 tokens (pure trial and error) with clinical trial protocols.  I am certain that this value will be different by domain and document types.<p>If you generate and then &quot;stuff&quot; more text into this, my hunch is that accuracy drops off as the token count increases and it becomes &quot;muddy&quot;.  GRAG or even normal RAG can solve this to an extent because -- as you propose -- you can generate a congruent &quot;note&quot; and then embed that and link them together.<p>I&#x27;d propose something more flexible: expand on the input query instead and basically multiplex it to the related topics and ideas instead and perform cheap embedding search using more than 1 input vector.</div><br/></div></div></div></div><div id="41055847" class="c"><input type="checkbox" id="c-41055847" checked=""/><div class="controls bullet"><span class="by">williamcotton</span><span>|</span><a href="#41055670">parent</a><span>|</span><a href="#41059478">prev</a><span>|</span><a href="#41058152">next</a><span>|</span><label class="collapse" for="c-41055847">[-]</label><label class="expand" for="c-41055847">[2 more]</label></div><br/><div class="children"><div class="content"><i>Contextual chunk headers<p>The idea here is to add in higher-level context to the chunk by prepending a chunk header. This chunk header could be as simple as just the document title, or it could use a combination of document title, a concise document summary, and the full hierarchy of section and sub-section titles.</i><p>That is from the article. Is this different from your suggested approach?</div><br/><div id="41057223" class="c"><input type="checkbox" id="c-41057223" checked=""/><div class="controls bullet"><span class="by">CharlieDigital</span><span>|</span><a href="#41055670">root</a><span>|</span><a href="#41055847">parent</a><span>|</span><a href="#41058152">next</a><span>|</span><label class="collapse" for="c-41057223">[-]</label><label class="expand" for="c-41057223">[1 more]</label></div><br/><div class="children"><div class="content">No, but this is also not really a novel solution.</div><br/></div></div></div></div></div></div><div id="41058152" class="c"><input type="checkbox" id="c-41058152" checked=""/><div class="controls bullet"><span class="by">ankit219</span><span>|</span><a href="#41055670">prev</a><span>|</span><a href="#41055832">next</a><span>|</span><label class="collapse" for="c-41058152">[-]</label><label class="expand" for="c-41058152">[2 more]</label></div><br/><div class="children"><div class="content">As is typical with any RAG strategy&#x2F;algorithm, the implicit thing is it works on a specific dataset. Then, it solves a very specific use case. The thing is, if you have a dataset and a use case, you can have a very custom algorithm which would work wonders in terms of output you need. There need not be anything generic.<p>My instinct at this point is, these algos look attractive because we are constrained to giving a user a wow moment where they upload something and get to chat with the doc&#x2F;dataset within minutes. As attractive as that is, it is a distinct second priority to building a system that works 99% of the time, even if takes a day or two to set up. You get a feel of the data, have a feel of type of questions that may be asked, and create an algo that works for a specific type of dataset-usecase combo (assuming any more data you add in this system would be similar and work pretty well). There is no silver bullet that we seem to be searching for.</div><br/><div id="41058457" class="c"><input type="checkbox" id="c-41058457" checked=""/><div class="controls bullet"><span class="by">cl42</span><span>|</span><a href="#41058152">parent</a><span>|</span><a href="#41055832">next</a><span>|</span><label class="collapse" for="c-41058457">[-]</label><label class="expand" for="c-41058457">[1 more]</label></div><br/><div class="children"><div class="content">100% agree with you. I&#x27;ve built a # of RAG systems and find that simple Q&amp;A-style use cases actually do fine with traditional chunking approaches.<p>... and then you have situations where people ask complex questions with multiple logical steps, or knowledge gathering requirements, and using some sort of hierarchical RAG strategy works better.<p>I think a lot of solutions (including this post) abstract to building knowledge graphs of some sort... But knowledge graphs still require an ontology associated to the problem you&#x27;re solving and will fail outside of those domains.</div><br/></div></div></div></div><div id="41055832" class="c"><input type="checkbox" id="c-41055832" checked=""/><div class="controls bullet"><span class="by">aster0id</span><span>|</span><a href="#41058152">prev</a><span>|</span><a href="#41062463">next</a><span>|</span><label class="collapse" for="c-41055832">[-]</label><label class="expand" for="c-41055832">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;d like to see more evaluation data. There are 100s of RAG strategies, most of them only work on specific types of queries.</div><br/><div id="41056423" class="c"><input type="checkbox" id="c-41056423" checked=""/><div class="controls bullet"><span class="by">gillesjacobs</span><span>|</span><a href="#41055832">parent</a><span>|</span><a href="#41057131">next</a><span>|</span><label class="collapse" for="c-41056423">[-]</label><label class="expand" for="c-41056423">[4 more]</label></div><br/><div class="children"><div class="content">Yeah exactly, existing benchmark datasets available are underutilized (eg KILT, Natural questions, etc.).<p>But it is only natural that different QA use cases require different strategies. I built 3 production RAG systems &#x2F; virtual assistant now, and 4 that didn&#x27;t make it past PoC and what advanced techniques works really depends on document type, text content and genre, use case, source knowledgebase structure and metadata to exploit etc.<p>Current go-to is semantic similarity chunking (with overlap) + title or question generation &gt; retriever with fusion on bienc vector sim + classic bm25 + condensed question reformulated QA agent. If you don&#x27;t get some decent results with that setup there is no hope.<p>For every project we start the creation of a use-case eval set immediately in parallel with the actual RAG agent, but sometimes the client doesn&#x27;t think this is priority. We convinced them all it&#x27;s highly important though, because it is.<p>Having an evaluation set is doubly important in GenAI projects: a generative system will do unexpected things and an objective measure is needed. Your client will run into weird behaviour when testing and they will get hung up on a 1-in-100 undesirable generation.</div><br/><div id="41058811" class="c"><input type="checkbox" id="c-41058811" checked=""/><div class="controls bullet"><span class="by">drittich</span><span>|</span><a href="#41055832">root</a><span>|</span><a href="#41056423">parent</a><span>|</span><a href="#41057131">next</a><span>|</span><label class="collapse" for="c-41058811">[-]</label><label class="expand" for="c-41058811">[3 more]</label></div><br/><div class="children"><div class="content">How do you weight results between vector search and bm25? Do you fall back to bm25 when vector similarity is below a threshold, or maybe you tweak the weights by hand for each data set?</div><br/><div id="41059313" class="c"><input type="checkbox" id="c-41059313" checked=""/><div class="controls bullet"><span class="by">gillesjacobs</span><span>|</span><a href="#41055832">root</a><span>|</span><a href="#41058811">parent</a><span>|</span><a href="#41057131">next</a><span>|</span><label class="collapse" for="c-41059313">[-]</label><label class="expand" for="c-41059313">[2 more]</label></div><br/><div class="children"><div class="content">The algorithm I use to get a final ranking from multiple rankings is called &quot;reciprocal ranked fusion&quot;. I use the implementation described here: <a href="https:&#x2F;&#x2F;docs.llamaindex.ai&#x2F;en&#x2F;stable&#x2F;examples&#x2F;low_level&#x2F;fusion_retriever&#x2F;#step-3-perform-fusion" rel="nofollow">https:&#x2F;&#x2F;docs.llamaindex.ai&#x2F;en&#x2F;stable&#x2F;examples&#x2F;low_level&#x2F;fusi...</a><p>Which is the implementation from the original paper.</div><br/><div id="41059778" class="c"><input type="checkbox" id="c-41059778" checked=""/><div class="controls bullet"><span class="by">drittich</span><span>|</span><a href="#41055832">root</a><span>|</span><a href="#41059313">parent</a><span>|</span><a href="#41057131">next</a><span>|</span><label class="collapse" for="c-41059778">[-]</label><label class="expand" for="c-41059778">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, much appreciated!</div><br/></div></div></div></div></div></div></div></div><div id="41057131" class="c"><input type="checkbox" id="c-41057131" checked=""/><div class="controls bullet"><span class="by">SkyPuncher</span><span>|</span><a href="#41055832">parent</a><span>|</span><a href="#41056423">prev</a><span>|</span><a href="#41062463">next</a><span>|</span><label class="collapse" for="c-41057131">[-]</label><label class="expand" for="c-41057131">[2 more]</label></div><br/><div class="children"><div class="content">RAG is akin to âsearch engineâ.<p>Itâs such a broad term that itâs essentially useless. Nearly anyone doing anything interesting with LLMs is doing RAG.</div><br/><div id="41057192" class="c"><input type="checkbox" id="c-41057192" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#41055832">root</a><span>|</span><a href="#41057131">parent</a><span>|</span><a href="#41062463">next</a><span>|</span><label class="collapse" for="c-41057192">[-]</label><label class="expand" for="c-41057192">[1 more]</label></div><br/><div class="children"><div class="content">The definition for RAG that works for me is that you perform some form of &quot;retrieval&quot; (could be full-text search, could be vector search, could be some combination of the two or even another technique like a regular expression search) and you then include the results of that retrieval in the context.<p>I think it&#x27;s a useful term.</div><br/></div></div></div></div></div></div><div id="41062463" class="c"><input type="checkbox" id="c-41062463" checked=""/><div class="controls bullet"><span class="by">Sharlin</span><span>|</span><a href="#41055832">prev</a><span>|</span><a href="#41056493">next</a><span>|</span><label class="collapse" for="c-41062463">[-]</label><label class="expand" for="c-41062463">[1 more]</label></div><br/><div class="children"><div class="content">âAn Outside Context Problem was the sort of thing most civilisations encountered just once, and which they tended to encounter rather in the same way a sentence encountered a full stop.â<p><a href="https:&#x2F;&#x2F;www.goodreads.com&#x2F;quotes&#x2F;9605621-an-outside-context-problem-was-the-sort-of-thing-most" rel="nofollow">https:&#x2F;&#x2F;www.goodreads.com&#x2F;quotes&#x2F;9605621-an-outside-context-...</a><p>(Sorry, I just <i>had</i> to post this quote because it was the first thing that came to my mind when I saw the title, and I&#x27;ve been re-reading Banks lately.)</div><br/></div></div><div id="41056493" class="c"><input type="checkbox" id="c-41056493" checked=""/><div class="controls bullet"><span class="by">gillesjacobs</span><span>|</span><a href="#41062463">prev</a><span>|</span><a href="#41064853">next</a><span>|</span><label class="collapse" for="c-41056493">[-]</label><label class="expand" for="c-41056493">[1 more]</label></div><br/><div class="children"><div class="content">I really want to see some evaluation benchmark comparisons on in-chunk augmentation approaches like this (and question, title, header-generation) and the hybrid retrieval approach where you match at multiple levels: first retrieve&#x2F;filter on a higher-level summary, title or header, then match the related chunks.<p>The pure vector approach of in-chunk text augmentation is much simpler of course, but my hypothesis is that the resulting vector will cause too much false positives in retrieval.<p>In my experience retrieval precision is most commonly the problem not recall with vector similarity. This method will indeed improve recall for out-of-context chunks, but for me recall has not been a problem very often.</div><br/></div></div><div id="41064853" class="c"><input type="checkbox" id="c-41064853" checked=""/><div class="controls bullet"><span class="by">brhsagain</span><span>|</span><a href="#41056493">prev</a><span>|</span><a href="#41062742">next</a><span>|</span><label class="collapse" for="c-41064853">[-]</label><label class="expand" for="c-41064853">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never seen so many epicycles in my life...</div><br/></div></div><div id="41062742" class="c"><input type="checkbox" id="c-41062742" checked=""/><div class="controls bullet"><span class="by">unixhero</span><span>|</span><a href="#41064853">prev</a><span>|</span><a href="#41058159">next</a><span>|</span><label class="collapse" for="c-41062742">[-]</label><label class="expand" for="c-41062742">[1 more]</label></div><br/><div class="children"><div class="content">I have identified a painpoint where my RAGs are insufficiently answering what I already had with a long tail DAG in production.</div><br/></div></div><div id="41058159" class="c"><input type="checkbox" id="c-41058159" checked=""/><div class="controls bullet"><span class="by">oshams</span><span>|</span><a href="#41062742">prev</a><span>|</span><label class="collapse" for="c-41058159">[-]</label><label class="expand" for="c-41058159">[1 more]</label></div><br/><div class="children"><div class="content">Have you considered this approach? Worked well for us: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40998497">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40998497</a></div><br/></div></div></div></div></div></div></div></body></html>