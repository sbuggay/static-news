<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1720515672650" as="style"/><link rel="stylesheet" href="styles.css?v=1720515672650"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://pretalx.com/devconf-cz-2024/talk/W3AVCT/">No more boot loader: Please use the kernel instead</a> <span class="domain">(<a href="https://pretalx.com">pretalx.com</a>)</span></div><div class="subtext"><span>zdw</span> | <span>201 comments</span></div><br/><div><div id="40908918" class="c"><input type="checkbox" id="c-40908918" checked=""/><div class="controls bullet"><span class="by">alerighi</span><span>|</span><a href="#40908266">next</a><span>|</span><label class="collapse" for="c-40908918">[-]</label><label class="expand" for="c-40908918">[72 more]</label></div><br/><div class="children"><div class="content">It&#x27;s something you can do since a lot of years. I used to do so 10 years ago, when I&#x27;ve got the first motherboard with UEFI. But is it useful? It saves a minimal time in the boot sequence, but at what cost?<p>The bootloader (being it grub, or something more simple as systemd-boot) is useful to me for a couple of reasons:<p>- it allows to dual-boot with Windows easily: motherboard boot menu is often not easy to access, you need to perform some key combination in a short window, also modern bootloader save the last boot option such that if Windows reboots for an update Linux does not start<p>- it allows to edit the cmdline of the kernel to recover a system that does not boot, e.g. start in single user mode. That can really save your day if you don&#x27;t have on hand an USB stick and another PC to flash it<p>- it allows you to choose between multiple kernels and initrd images easily, again for recovery purposes<p>- it has a voice for entering the UEFI setup menu: in most modern systems again entering the UEFI with a keyboard combination is unnecessarily difficult and has a too short timeout<p>- it allows you to boot any other EFI application, such as memtest, or efi shell. Most UEFI firmwares doesn&#x27;t have a menu to do so.</div><br/><div id="40909611" class="c"><input type="checkbox" id="c-40909611" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#40908918">parent</a><span>|</span><a href="#40913670">next</a><span>|</span><label class="collapse" for="c-40909611">[-]</label><label class="expand" for="c-40909611">[24 more]</label></div><br/><div class="children"><div class="content">If I&#x27;m understanding correctly, it might help to point out that in spite of the title they <i>are</i> proposing a bootloader, which can still let you modify the cmdline, boot to other OSs, etc. It&#x27;s just that the bootloader is itself using the Linux kernel so it can do things like read all Linux filesystems for &quot;free&quot; without having to rewrite filesystem drivers.</div><br/><div id="40910668" class="c"><input type="checkbox" id="c-40910668" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40909611">parent</a><span>|</span><a href="#40910168">next</a><span>|</span><label class="collapse" for="c-40910668">[-]</label><label class="expand" for="c-40910668">[11 more]</label></div><br/><div class="children"><div class="content">you seem to be saying that they are using two separate kernels, one for the bootloader and one for the final boot target<p>the title text says &#x27;Loaded by the EFI stub on UEFI, and packed into a unified kernel image (UKI), the kernel, initramfs, and kernel command line, contain everything they need to reach the final boot target&#x27; which sounds like they&#x27;re not talking about using two separate kernels, one for the bootloader and one for the final boot target, but rather only one single kernel.  possibly that is not the case because the actual information is hidden in a video i haven&#x27;t watched<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40909165">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40909165</a> seems to confirm that they are indeed not saying what you thought<p>edit: they&#x27;re proposing both configurations</div><br/><div id="40910796" class="c"><input type="checkbox" id="c-40910796" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40910668">parent</a><span>|</span><a href="#40913646">next</a><span>|</span><label class="collapse" for="c-40910796">[-]</label><label class="expand" for="c-40910796">[3 more]</label></div><br/><div class="children"><div class="content">I watched the video.  They have two different configurations, one where there’s only one kernel, one where there are indeed two separate kernels with one kexec’ing to the other.</div><br/><div id="40911035" class="c"><input type="checkbox" id="c-40911035" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40910796">parent</a><span>|</span><a href="#40913646">next</a><span>|</span><label class="collapse" for="c-40911035">[-]</label><label class="expand" for="c-40911035">[2 more]</label></div><br/><div class="children"><div class="content">thank you for your sacrifice and for the resulting correction to my error</div><br/></div></div></div></div><div id="40913646" class="c"><input type="checkbox" id="c-40913646" checked=""/><div class="controls bullet"><span class="by">thom</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40910668">parent</a><span>|</span><a href="#40910796">prev</a><span>|</span><a href="#40910762">next</a><span>|</span><label class="collapse" for="c-40913646">[-]</label><label class="expand" for="c-40913646">[1 more]</label></div><br/><div class="children"><div class="content">To be clear: the win here is that there&#x27;s no longer duplicated (or worse - less capable and outdated) code to do the same things in both the bootloader and the kernel, however the two versions of that code might be deployed.</div><br/></div></div><div id="40910762" class="c"><input type="checkbox" id="c-40910762" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40910668">parent</a><span>|</span><a href="#40913646">prev</a><span>|</span><a href="#40910993">next</a><span>|</span><label class="collapse" for="c-40910762">[-]</label><label class="expand" for="c-40910762">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>It&#x27;s just that the bootloader is itself using the Linux kernel</i><p>This sentence does not say &quot;the bootloader is itself another, separate, Linux kernel&quot;, so I&#x27;m not seeing him saying what you&#x27;re saying he seems to be saying.</div><br/></div></div><div id="40910993" class="c"><input type="checkbox" id="c-40910993" checked=""/><div class="controls bullet"><span class="by">nmstoker</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40910668">parent</a><span>|</span><a href="#40910762">prev</a><span>|</span><a href="#40910168">next</a><span>|</span><label class="collapse" for="c-40910993">[-]</label><label class="expand" for="c-40910993">[5 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; you seem to be saying that they are using two separate kernels, one for the bootloader and one for the final boot target<p>This doesn&#x27;t make sense. There&#x27;s nothing in the post you responded to which could realistically be interpreted as making that point. And there haven&#x27;t been any edits, which might have explained your confusion.</div><br/><div id="40911469" class="c"><input type="checkbox" id="c-40911469" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40910993">parent</a><span>|</span><a href="#40910168">next</a><span>|</span><label class="collapse" for="c-40911469">[-]</label><label class="expand" for="c-40911469">[4 more]</label></div><br/><div class="children"><div class="content">the comment says &#x27;they are proposing a bootloader, which can still let you modify the cmdline, (...) the bootloader is itself using the Linux kernel&#x27;<p>possibly you don&#x27;t know this, but in order to run a kernel with a modified command line, the bootloader-kernel would need to run a second kernel, for example using kexec; linux doesn&#x27;t have a useful way to modify the command line of the running kernel.  that&#x27;s why i interpreted the comment as saying that they are proposing using two separate kernels.  in <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40910796">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40910796</a> comex clarifies that they are in fact proposing using two separate kernels; the reason i was confused is that that&#x27;s not the only configuration they&#x27;re proposing</div><br/><div id="40911580" class="c"><input type="checkbox" id="c-40911580" checked=""/><div class="controls bullet"><span class="by">nmstoker</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40911469">parent</a><span>|</span><a href="#40910168">next</a><span>|</span><label class="collapse" for="c-40911580">[-]</label><label class="expand" for="c-40911580">[3 more]</label></div><br/><div class="children"><div class="content">What I know or don&#x27;t know is irrelevant, because what matters is that your statement rests of bringing in external knowledge&#x2F;assumptions, so it&#x27;s clearly not what the commenter is saying (alone).</div><br/><div id="40911721" class="c"><input type="checkbox" id="c-40911721" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40911580">parent</a><span>|</span><a href="#40911718">next</a><span>|</span><label class="collapse" for="c-40911721">[-]</label><label class="expand" for="c-40911721">[1 more]</label></div><br/><div class="children"><div class="content">Using external knowledge to interpret the meaning of sentences is how every communication works.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40910168" class="c"><input type="checkbox" id="c-40910168" checked=""/><div class="controls bullet"><span class="by">garaetjjte</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40909611">parent</a><span>|</span><a href="#40910668">prev</a><span>|</span><a href="#40912452">next</a><span>|</span><label class="collapse" for="c-40910168">[-]</label><label class="expand" for="c-40910168">[11 more]</label></div><br/><div class="children"><div class="content">It could kexec other kernels but probably won&#x27;t be able to jump to other OS bootloaders after it already called ExitBootServices.</div><br/><div id="40910272" class="c"><input type="checkbox" id="c-40910272" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40910168">parent</a><span>|</span><a href="#40910218">next</a><span>|</span><label class="collapse" for="c-40910272">[-]</label><label class="expand" for="c-40910272">[4 more]</label></div><br/><div class="children"><div class="content">The sibling comments who think you need to jump back to EFI to solve this, are thinking in layer-ossified terms. This is Redhat proposing this, and they&#x27;re perfectly confident in upstreaming kernel patches to make this happen.<p>I would assume that in their proposed solution, the kernel would have logic to check for a CMDLINE flag (or rather, lack of any CMDLINE flags!) to indicate that it&#x27;s operating in bootloader mode; and if decides that it is, then it never calls ExitBootServices. All the EFI stuff stays mapped for the whole lifetime of the kernel.<p>(Also, given that they call this a &quot;unified kernel image&quot;, I presume that in the case where the kernel decides to boot <i>the same kernel image that&#x27;s already loaded in memory as the bootloader</i>, then nothing like a kexec needs to occur — rather, <i>that&#x27;s</i> the point at which the kernel calls ExitBootServices (basically to say &quot;I&#x27;m done with caring about being able to potentially boot into something else now&quot;), and transitions from &quot;phase 1 initramfs for running bootload-time logic&quot;  into &quot;phase 2 initramfs to bootstrap a multi-user userland.&quot;)</div><br/><div id="40910389" class="c"><input type="checkbox" id="c-40910389" checked=""/><div class="controls bullet"><span class="by">garaetjjte</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40910272">parent</a><span>|</span><a href="#40910218">next</a><span>|</span><label class="collapse" for="c-40910389">[-]</label><label class="expand" for="c-40910389">[3 more]</label></div><br/><div class="children"><div class="content">&gt;and if decides that it is, then it never calls ExitBootServices<p>That&#x27;s unlikely, I think that would mean you cannot use native drivers, at which point you&#x27;re just writing another bootloader. I suspect they only planning to kexec into target kernel, not chainloading other EFI bootloaders.</div><br/><div id="40913384" class="c"><input type="checkbox" id="c-40913384" checked=""/><div class="controls bullet"><span class="by">drewdevault</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40910389">parent</a><span>|</span><a href="#40910728">next</a><span>|</span><label class="collapse" for="c-40913384">[-]</label><label class="expand" for="c-40913384">[1 more]</label></div><br/><div class="children"><div class="content">Something that hasn&#x27;t been addressed by comments here yet is that you could implement EFI boot services in the Linux kernel and essentially turn Linux into a firmware interface. Though note that I generally shy away from any attempts to make the kernel into a really fat bootloader.</div><br/></div></div><div id="40910728" class="c"><input type="checkbox" id="c-40910728" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40910389">parent</a><span>|</span><a href="#40913384">prev</a><span>|</span><a href="#40910218">next</a><span>|</span><label class="collapse" for="c-40910728">[-]</label><label class="expand" for="c-40910728">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right (as I saw another comment cite the primary-source for); but I&#x27;m still curious now, whether there&#x27;d be a way to pull this off.<p>&gt; I think that would mean you cannot use native drivers<p>Yes, that&#x27;s right.<p>&gt; at which point you&#x27;re just writing another bootloader<p>But that&#x27;s not <i>necessarily</i> true.<p>Even if you could only use EFI boot+runtime services until you call ExitBootServices, in theory, an OS kernel <i>could</i> have a HAL for which many different pieces of hardware have an &quot;EFI boot services driver&quot; as well as a native driver; and where the active driver for a given piece of discovered hardware could be hotswapped &quot;under&quot; the HAL abstraction, atomically, without live HAL-intermediated kernel handles going bad — as long as the kernel includes a driver-to-driver state-translation function for the two implementations.<p>So you could &quot;bring up&quot; a kernel and userland while riding on EFI boot services; and then the kernel would snap its fingers at some critical point, and it&#x27;d suddenly all be native drivers.<p>Of course, Linux is not architected in a way that even comes close to allowing something like this. (Windows might be, maybe?)<p>---<p>I think a more interesting idea, though, would come from slightly extending the UEFI spec. Imagine two calls: <i>PauseBootServices</i> and <i>ResumeBootServices</i>.<p>PauseBootServices would stop all management of devices by the EFI (so, as with ExitBootServices, you&#x27;d have to be ready to take over such management) — but crucially, it would leave all the stuff that EFI had discovered+computed+mapped into memory during early boot, mapped into memory (and these pages would be read-only and would be locked at ring-negative-3 or something, so the kernel wouldn&#x27;t have permission to unmap them.)<p>If this existed, then at any time (even in the middle of running a multi-user OS!), the running kernel that had previously called PauseBootServices, could call ResumeBootServices — basically &quot;relinquishing back&quot; control over the hardware to EFI.<p>EFI would then go about reinitializing all hardware <i>other than</i> the CPU and memory, taking over the CPU for a while the same way peripheral bring-up logic does at early boot. But when it&#x27;s done with getting all the peripherals into known-good states, it would then return control to the caller[1] of ResumeBootServices, with the kernel now having transitioned <i>into</i> being an EFI app again.<p>[1] ...through a vector of the caller&#x27;s choice. To get those drivers back into being EFI boot services drivers before the kernel tries using them again, naturally.<p>It&#x27;s a dumb idea, mostly useless, thoroughly impractical to implement given how ossified EFI already is — but it&#x27;d &quot;work&quot; ;)</div><br/></div></div></div></div></div></div><div id="40910218" class="c"><input type="checkbox" id="c-40910218" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40910168">parent</a><span>|</span><a href="#40910272">prev</a><span>|</span><a href="#40910198">next</a><span>|</span><label class="collapse" for="c-40910218">[-]</label><label class="expand" for="c-40910218">[2 more]</label></div><br/><div class="children"><div class="content">This is being discussed more extensively in other comment threads but it sounds like maybe there&#x27;s a way for it to just reboot but set a flag so the firmware boots into a different .efi next time (once).</div><br/><div id="40913462" class="c"><input type="checkbox" id="c-40913462" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40910218">parent</a><span>|</span><a href="#40910198">next</a><span>|</span><label class="collapse" for="c-40913462">[-]</label><label class="expand" for="c-40913462">[1 more]</label></div><br/><div class="children"><div class="content">You can set BootNext variable to number of BootXXX variable you want to use once for next boot.</div><br/></div></div></div></div><div id="40910198" class="c"><input type="checkbox" id="c-40910198" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40910168">parent</a><span>|</span><a href="#40910218">prev</a><span>|</span><a href="#40912452">next</a><span>|</span><label class="collapse" for="c-40910198">[-]</label><label class="expand" for="c-40910198">[4 more]</label></div><br/><div class="children"><div class="content">Theoretically, couldn&#x27;t it just write to a &quot;boot this image next time&quot; field (is the legacy MBR area available?) and trigger a reboot?</div><br/><div id="40910407" class="c"><input type="checkbox" id="c-40910407" checked=""/><div class="controls bullet"><span class="by">adtac</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40910198">parent</a><span>|</span><a href="#40910421">next</a><span>|</span><label class="collapse" for="c-40910407">[-]</label><label class="expand" for="c-40910407">[2 more]</label></div><br/><div class="children"><div class="content">The target image would need to reset that field so that a second reboot puts you back into the bootloader because otherwise you&#x27;ll be stuck booting that image forever.</div><br/><div id="40911313" class="c"><input type="checkbox" id="c-40911313" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40910407">parent</a><span>|</span><a href="#40910421">next</a><span>|</span><label class="collapse" for="c-40911313">[-]</label><label class="expand" for="c-40911313">[1 more]</label></div><br/><div class="children"><div class="content">The image doesn&#x27;t need to do it, that&#x27;s how UEFI bootnext works: the firmware resets the flag before it loads the image.</div><br/></div></div></div></div><div id="40910421" class="c"><input type="checkbox" id="c-40910421" checked=""/><div class="controls bullet"><span class="by">garaetjjte</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40910198">parent</a><span>|</span><a href="#40910407">prev</a><span>|</span><a href="#40912452">next</a><span>|</span><label class="collapse" for="c-40910421">[-]</label><label class="expand" for="c-40910421">[1 more]</label></div><br/><div class="children"><div class="content">Well you could change default boot entry in efivars, but if you&#x27;re relying on firmware for that why not use firmware provided boot menu anyway?</div><br/></div></div></div></div></div></div><div id="40912452" class="c"><input type="checkbox" id="c-40912452" checked=""/><div class="controls bullet"><span class="by">cool_beanz</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40909611">parent</a><span>|</span><a href="#40910168">prev</a><span>|</span><a href="#40913670">next</a><span>|</span><label class="collapse" for="c-40912452">[-]</label><label class="expand" for="c-40912452">[1 more]</label></div><br/><div class="children"><div class="content">You can have command line parameters baked into the EFISTUB.
I also have two kernels, so there&#x27;s two UKIs on &#x2F;efi, and I have both added as separate boot options in BIOS.</div><br/></div></div></div></div><div id="40913670" class="c"><input type="checkbox" id="c-40913670" checked=""/><div class="controls bullet"><span class="by">prmoustache</span><span>|</span><a href="#40908918">parent</a><span>|</span><a href="#40909611">prev</a><span>|</span><a href="#40913636">next</a><span>|</span><label class="collapse" for="c-40913670">[-]</label><label class="expand" for="c-40913670">[4 more]</label></div><br/><div class="children"><div class="content">&gt; - it allows to dual-boot with Windows easily: motherboard boot menu is often not easy to access, you need to perform some key combination in a short window, also modern bootloader save the last boot option such that if Windows reboots for an update Linux does not start<p>Do people really dual boot a lot in 2024? It was a good use case when virtualization was slow but decades after the CPU started shipping with virtualization extensions there is virtually zero overhead in using VM nowadays and it is much more convenient than rebooting and losing all your open applications just to start one on another OS.<p>&gt; - it allows you to boot any other EFI application, such as memtest, or efi shell. Most UEFI firmwares doesn&#x27;t have a menu to do so.<p>How many times in a decade are you running memtest?<p>Getting to UEFI firmware or booting another OS&#x2F;drive is just a matter of holding one key on my thinkpad. I would just simply not buy and bad hardware that doesn&#x27;t allow me to do that. Vote with you wallet damit.<p>I would also argue that you can perfectly have grub sitting alongside a direct boot to kernel in an UEFI setup. There are many other bootloaders than grub and users are still free to use them instead of what the distro is shipping. UEFI basically allows you to have as many bootloader as you have space on that small fat partition.</div><br/><div id="40913863" class="c"><input type="checkbox" id="c-40913863" checked=""/><div class="controls bullet"><span class="by">zik</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40913670">parent</a><span>|</span><a href="#40913720">next</a><span>|</span><label class="collapse" for="c-40913863">[-]</label><label class="expand" for="c-40913863">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Do people really dual boot a lot in 2024?<p>Yes. I work on Linux and play most games on Windows. Playing games on a VM is... pretty terrible.</div><br/></div></div><div id="40913720" class="c"><input type="checkbox" id="c-40913720" checked=""/><div class="controls bullet"><span class="by">messe</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40913670">parent</a><span>|</span><a href="#40913863">prev</a><span>|</span><a href="#40913636">next</a><span>|</span><label class="collapse" for="c-40913720">[-]</label><label class="expand" for="c-40913720">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Do people really dual boot a lot in 2024?<p>Yes, there are still use cases for it.<p>The state of GPU virtualisation, for example, is a spectrum from doesn&#x27;t exist&#x2F;sucks to only affordable for enterprise customers.<p>So unless you have a second graphics card to do pass through with, if you want to use your GPU under both OSes then you almost always have to dual boot (yes, there are other options like running Linux headless, but it&#x27;s not even remotely easier to set up than dual boot)</div><br/><div id="40913864" class="c"><input type="checkbox" id="c-40913864" checked=""/><div class="controls bullet"><span class="by">prmoustache</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40913720">parent</a><span>|</span><a href="#40913636">next</a><span>|</span><label class="collapse" for="c-40913864">[-]</label><label class="expand" for="c-40913864">[1 more]</label></div><br/><div class="children"><div class="content">Most mainboards comes with an integrated gpu though? If you use that one for the host OS, it is easy to pass the discrete through no?</div><br/></div></div></div></div></div></div><div id="40913636" class="c"><input type="checkbox" id="c-40913636" checked=""/><div class="controls bullet"><span class="by">account42</span><span>|</span><a href="#40908918">parent</a><span>|</span><a href="#40913670">prev</a><span>|</span><a href="#40909010">next</a><span>|</span><label class="collapse" for="c-40913636">[-]</label><label class="expand" for="c-40913636">[3 more]</label></div><br/><div class="children"><div class="content">&gt; it allows to dual-boot with Windows easily: motherboard boot menu is often not easy to access, you need to perform some key combination in a short window<p>Hardly a problem in my experience - just hold down the key while booting.<p>And dual booting is rarely needed anyway and generally just a pita. Just always boot into your preferred OS and virtualize the other one when you really need it.<p>&gt; also modern bootloader save the last boot option such that if Windows reboots for an update Linux does not start<p>You can change the EFI boot entries including priority from the OS, e.g. via efibootmgr under Linux. Should be easy to setup each OS to make itself the default on boot if that&#x27;s really what you want.<p>&gt; it allows to edit the cmdline of the kernel to recover a system that does not boot, e.g. start in single user mode. That can really save your day if you don&#x27;t have on hand an USB stick and another PC to flash it<p>All motherboards I have used had an EFI shell that you can use to run EFI programs such as the Linux kernel with efistub with whatever command-line options you want.<p>&gt; it allows you to choose between multiple kernels and initrd images easily, again for recovery purposes<p>EFI can have many boot entries too.<p>&gt; it has a voice for entering the UEFI setup menu<p>What does &quot;a voice&quot; here mean? Or you meant &quot;a choice&quot;? Either way, same as with the boot menu you can just hold down the key while booting IME.<p>&gt; it allows you to boot any other EFI application, such as memtest, or efi shell. Most UEFI firmwares doesn&#x27;t have a menu to do so.<p>In my the EFI shell has always been accessible without a bootloader.</div><br/><div id="40913657" class="c"><input type="checkbox" id="c-40913657" checked=""/><div class="controls bullet"><span class="by">littlecranky67</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40913636">parent</a><span>|</span><a href="#40913665">next</a><span>|</span><label class="collapse" for="c-40913657">[-]</label><label class="expand" for="c-40913657">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And dual booting is rarely needed anyway and generally just a pita. Just always boot into your preferred OS and virtualize the other one when you really need it.<p>I&#x27;ve been dual-booting linux since the kernel 2.2.x era and being able to do it was a major driver to migrate away from windows. It is super important for onboarding of new users that can&#x27;t yet get rid of windows fully - mostly because of gaming (yes proton is nice, but anything competive that uses anti-cheat won&#x27;t work yet is the majority share of gaming). And that is the reason I still boot into Windows on my dual-boot machine: Gaming. For me that windows is just a glorified bootloader into GoG or Steam, yet desperately needed and virtualization won&#x27;t solve anything here.</div><br/></div></div><div id="40913665" class="c"><input type="checkbox" id="c-40913665" checked=""/><div class="controls bullet"><span class="by">myworkinisgood</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40913636">parent</a><span>|</span><a href="#40913657">prev</a><span>|</span><a href="#40909010">next</a><span>|</span><label class="collapse" for="c-40913665">[-]</label><label class="expand" for="c-40913665">[1 more]</label></div><br/><div class="children"><div class="content">I have experience with two different laptops:
1. Dell enterprise laptops generally have a robust EFI system which allows for all kinds of `.efi` files to boot on `vfat` partitions. Dell laptops also have a good firmware setup for stuff like mokutils to work so that people can use measured boot with their own version of linux. They also work extremely well with self-encrypting nvme drives.
2. HP consumer laptops which are the worst of lot and essentially prevent you from doing anything apart from stock configurations, almost like on purpose. 
3. All other laptops which have various levels of incompetence but seems pretty harmless.<p>For all laptops apart from Dell, Grub is the bootloader that EFI could never be.</div><br/></div></div></div></div><div id="40909010" class="c"><input type="checkbox" id="c-40909010" checked=""/><div class="controls bullet"><span class="by">ec109685</span><span>|</span><a href="#40908918">parent</a><span>|</span><a href="#40913636">prev</a><span>|</span><a href="#40909865">next</a><span>|</span><label class="collapse" for="c-40909010">[-]</label><label class="expand" for="c-40909010">[7 more]</label></div><br/><div class="children"><div class="content">Just because the boot loader is using Linux, it doesn’t prevent an alternative OS from being booted into, so there is nothing fundamentally stopping all of grub’s features from working in this new scheme.</div><br/><div id="40909165" class="c"><input type="checkbox" id="c-40909165" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40909010">parent</a><span>|</span><a href="#40909865">next</a><span>|</span><label class="collapse" for="c-40909165">[-]</label><label class="expand" for="c-40909165">[6 more]</label></div><br/><div class="children"><div class="content">It is a bit more complex, though. Quoting &quot;nmbl: we don’t need a bootloader&quot; from last month[1]:<p>&gt; - <i>Possibility to chainload from Linux while using Secure &#x2F; Trusted boot</i>: Dual-booting, although not supported on RHEL, is important for Fedora. While there are attempts to kexec any PE binary, our plan is to set BootNext and then reset, which will preserve the chain of trust that originates in firmware, while not interfering with other bootloaders.<p>It could be seen as an advantage to do chainloading by setting BootNext and resetting. I <i>think</i> Windows even does this now. However, it certainly is a different approach with more moving parts (e.g. the firmware has to not interfere or do anything stupid, harder than you&#x27;d hope) and it&#x27;s definitely slower. It&#x27;d be ideal if both options were on the table (being able to `kexec` arbitrary UEFI PE binaries) but I can&#x27;t imagine kexec&#x27;ing random UEFI binaries will ever be ideal. It took long enough to really feel like kexec&#x27;ing other Linux kernels was somewhat reliable.<p>[1]: <a href="https:&#x2F;&#x2F;fizuxchyk.wordpress.com&#x2F;2024&#x2F;06&#x2F;13&#x2F;nmbl-we-dont-need-a-bootloader&#x2F;" rel="nofollow">https:&#x2F;&#x2F;fizuxchyk.wordpress.com&#x2F;2024&#x2F;06&#x2F;13&#x2F;nmbl-we-dont-need...</a></div><br/><div id="40909695" class="c"><input type="checkbox" id="c-40909695" checked=""/><div class="controls bullet"><span class="by">bityard</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40909165">parent</a><span>|</span><a href="#40909865">next</a><span>|</span><label class="collapse" for="c-40909695">[-]</label><label class="expand" for="c-40909695">[5 more]</label></div><br/><div class="children"><div class="content">Let&#x27;s say I have a dual-boot system with two totally independent OSes, Systems A and B. It is powered down. I want to boot into System B but the EFI is configured to boot into System A by default.<p>Am I correct in understanding that the offered solution here is to first boot into System A, find some well-hidden EFI configuration utility (which varies from OS to OS, if it even exists), and then tell EFI to boot into System B on the next reboot?<p>If so, that&#x27;s a pretty terrible experience.</div><br/><div id="40910280" class="c"><input type="checkbox" id="c-40910280" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40909695">parent</a><span>|</span><a href="#40910036">next</a><span>|</span><label class="collapse" for="c-40910280">[-]</label><label class="expand" for="c-40910280">[3 more]</label></div><br/><div class="children"><div class="content">Sort of, except it&#x27;s automated.<p>Basically, System A&#x27;s kernel boots. But, instead of immediately loading the System A userland, it loads a boot menu of systems that it reads from UEFI NVRAM and presents it to the user. So you select System B from the list, the menu sets BootNext in NVRAM and issues a reboot.<p>In practice, the main UX difference is that it takes a bit longer and you&#x27;ll see the UEFI vendor splash screen again after selecting the boot option.<p>I&#x27;m not a user of Windows anymore but I seem to recall Windows doing something quite similar, where it had a boot menu that felt suspiciously like it was inside of Windows, and to <i>actually</i> change the boot target, it had to reboot.</div><br/><div id="40910352" class="c"><input type="checkbox" id="c-40910352" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40910280">parent</a><span>|</span><a href="#40910036">next</a><span>|</span><label class="collapse" for="c-40910352">[-]</label><label class="expand" for="c-40910352">[2 more]</label></div><br/><div class="children"><div class="content">&gt; instead of immediately loading the System A userland<p>I mean, it kind of <i>is</i> loading the System A userland. At least the initramfs of it. AFAICT in the proposal the bootloader would now be a regular userland program living in the initramfs.<p>I get the impression that the eventual goal would be to make this bootloader program into the &quot;init(8) but for the initramfs phase of boot&quot; — i.e. rather than there being a tool like update-grub that calls mkinitramfs, feeding it a shell-script GRUB generated (which then becomes the &#x2F;init of the initramfs); instead, there&#x27;d be a tooling package you&#x27;d install that&#x27;s related to the kernel itself, where you call e.g. kernel-update(8) and <i>that</i> would call mkinitramfs — and the &#x2F;init shoved inside it would be this bootloader. This bootloader would then be running for the whole initramfs phase of boot, &quot;owning&quot; the whole bootstrap process.<p>What the architecture is at that point, I&#x27;m less clear on. I think either way, this initramfs userland, through this bootloader program, will now handle both the cases of &quot;acting like a bootloader&quot; and &quot;acting like the rest of initramfs-based boot up to pivot-root.&quot; That could mean one monolithic binary, or an init daemon and a hierarchy of services (systemd: now in your bootloader), or just a pile of shell scripts like GRUB gives you, just now written by Redhat.</div><br/><div id="40910477" class="c"><input type="checkbox" id="c-40910477" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40910352">parent</a><span>|</span><a href="#40910036">next</a><span>|</span><label class="collapse" for="c-40910477">[-]</label><label class="expand" for="c-40910477">[1 more]</label></div><br/><div class="children"><div class="content">Yes of course. I really mean to say, before&#x2F;instead of pivoting to the OS root. It sounds like this will synergize well with the UKI effort too, at least from a Secure Boot perspective.</div><br/></div></div></div></div></div></div><div id="40910036" class="c"><input type="checkbox" id="c-40910036" checked=""/><div class="controls bullet"><span class="by">superb_dev</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40909695">parent</a><span>|</span><a href="#40910280">prev</a><span>|</span><a href="#40909865">next</a><span>|</span><label class="collapse" for="c-40910036">[-]</label><label class="expand" for="c-40910036">[1 more]</label></div><br/><div class="children"><div class="content">Presumably nmbl would show you a menu to select the which OS start if you’re dual booting. You wouldn’t have to manually set some UEFI variable</div><br/></div></div></div></div></div></div></div></div><div id="40909865" class="c"><input type="checkbox" id="c-40909865" checked=""/><div class="controls bullet"><span class="by">1vuio0pswjnm7</span><span>|</span><a href="#40908918">parent</a><span>|</span><a href="#40909010">prev</a><span>|</span><a href="#40909338">next</a><span>|</span><label class="collapse" for="c-40909865">[-]</label><label class="expand" for="c-40909865">[4 more]</label></div><br/><div class="children"><div class="content">As much as I generally detest indirection, for me a bootloader is a necessity; I need the flexibity to boot different OS kernels.  AFAIK, UEFI offers no such flexibility.  NetBSD&#x27;s bootloader is best for me.  UEFI seems like an OS unto itself.  A command line, some utilties and network connectivity (UNIX-like textmode environment) is, with few exceptions, 100% of what I need from a computer.  To me, UEFI seems potentially quite useful.  But not as a replacement for a bootloader.</div><br/><div id="40912522" class="c"><input type="checkbox" id="c-40912522" checked=""/><div class="controls bullet"><span class="by">cool_beanz</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40909865">parent</a><span>|</span><a href="#40910250">next</a><span>|</span><label class="collapse" for="c-40912522">[-]</label><label class="expand" for="c-40912522">[2 more]</label></div><br/><div class="children"><div class="content">&gt;I need the flexibity to boot different OS kernels. AFAIK, UEFI offers no such flexibility.<p>Yes it does, I use it with two kernels, just have different entry for each stub in UEFI. Whenever I want to boot the non-default kernel I just hit F11 (for BIOS boot menu, on my motherboard) and choose the boot option. You just need to add the boot options in UEFI, pointing to the corresponding EFI files. They also have the kernel command line parameters baked into them and you can set your desired ones (silent boot whatever).</div><br/><div id="40913469" class="c"><input type="checkbox" id="c-40913469" checked=""/><div class="controls bullet"><span class="by">1vuio0pswjnm7</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40912522">parent</a><span>|</span><a href="#40910250">next</a><span>|</span><label class="collapse" for="c-40913469">[-]</label><label class="expand" for="c-40913469">[1 more]</label></div><br/><div class="children"><div class="content">Thank you.</div><br/></div></div></div></div><div id="40910250" class="c"><input type="checkbox" id="c-40910250" checked=""/><div class="controls bullet"><span class="by">sholladay</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40909865">parent</a><span>|</span><a href="#40912522">prev</a><span>|</span><a href="#40909338">next</a><span>|</span><label class="collapse" for="c-40910250">[-]</label><label class="expand" for="c-40910250">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I need the flexibity to boot different OS kernels. AFAIK, UEFI offers no such flexibility.<p>Isn’t this how Apple’s Bootcamp works (at least on Intel based Macs)?</div><br/></div></div></div></div><div id="40909338" class="c"><input type="checkbox" id="c-40909338" checked=""/><div class="controls bullet"><span class="by">throwway120385</span><span>|</span><a href="#40908918">parent</a><span>|</span><a href="#40909865">prev</a><span>|</span><a href="#40913232">next</a><span>|</span><label class="collapse" for="c-40909338">[-]</label><label class="expand" for="c-40909338">[3 more]</label></div><br/><div class="children"><div class="content">If you embed an x86 system somewhere then you might find yourself not wanting to use GRUB because you don&#x27;t want to display any boot options anywhere other than the Linux kernel. The EFI stub is really handy for this use case. And on platforms where UBoot is common UBoot supports EFI which makes GRUB superfluous in those cases.<p>Many of the Linux systems I support don&#x27;t have displays and EFI is supported through UBoot. In those cases you&#x27;re using a character-based console of some sort like RS232.<p>A lot of those GRUB options could also be solved by embedding a simple pre-boot system in an initial ramdisk to display options, which maintains all of the advantages of not using GRUB and also gives you the ability to make your boot selection. The only thing GRUB is doing here is allowing you to select which kernel to chain-load, and you can probably do the same thing in initramfs too through some kind of kernel API that is disabled after pivot root.</div><br/><div id="40909713" class="c"><input type="checkbox" id="c-40909713" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40909338">parent</a><span>|</span><a href="#40912503">next</a><span>|</span><label class="collapse" for="c-40909713">[-]</label><label class="expand" for="c-40909713">[1 more]</label></div><br/><div class="children"><div class="content">I must admit that on U-Boot platforms, I use U-Boot EFI to load grub-efi, so that I can have a non-terrible bootloader…</div><br/></div></div><div id="40912503" class="c"><input type="checkbox" id="c-40912503" checked=""/><div class="controls bullet"><span class="by">cool_beanz</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40909338">parent</a><span>|</span><a href="#40909713">prev</a><span>|</span><a href="#40913232">next</a><span>|</span><label class="collapse" for="c-40912503">[-]</label><label class="expand" for="c-40912503">[1 more]</label></div><br/><div class="children"><div class="content">I just have two kernels with two boot options in BIOS. I just hit F11 at boot time and choose a BIOS boot option for either kernel. Of-course, you need to add the entries in UEFI, either from UEFI shell either with some tool (efibootmgr).
This scheme also supports secure booting and silent booting. The stubs are signed after being generated.</div><br/></div></div></div></div><div id="40913232" class="c"><input type="checkbox" id="c-40913232" checked=""/><div class="controls bullet"><span class="by">herewulf</span><span>|</span><a href="#40908918">parent</a><span>|</span><a href="#40909338">prev</a><span>|</span><a href="#40909918">next</a><span>|</span><label class="collapse" for="c-40913232">[-]</label><label class="expand" for="c-40913232">[1 more]</label></div><br/><div class="children"><div class="content">It allows you to enter your passphrase to unlock your Linux LUKS partition before you even get a menu to chainload Windows.<p>At least this is what an Arch Linux derivative (Artix) system of mine does, amusingly. It sort of gives an observer the impression that it&#x27;s an encrypted Windows system on boot.</div><br/></div></div><div id="40909918" class="c"><input type="checkbox" id="c-40909918" checked=""/><div class="controls bullet"><span class="by">ziml77</span><span>|</span><a href="#40908918">parent</a><span>|</span><a href="#40913232">prev</a><span>|</span><a href="#40909425">next</a><span>|</span><label class="collapse" for="c-40909918">[-]</label><label class="expand" for="c-40909918">[3 more]</label></div><br/><div class="children"><div class="content">Does Windows not ensure that the UEFI boots back into Windows when it does an auto-reboot for updates? There&#x27;s a UEFI variable called BootNext which Windows already knows how to use since the advanced startup options must be setting it to allow rebooting directly to the UEFI settings.<p>Given that Windows tries to restore open windows to make it look like it didn&#x27;t even reboot, I&#x27;m surprised they wouldn&#x27;t make sure that the reboot actually goes back into Windows.</div><br/><div id="40913576" class="c"><input type="checkbox" id="c-40913576" checked=""/><div class="controls bullet"><span class="by">ale42</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40909918">parent</a><span>|</span><a href="#40910030">next</a><span>|</span><label class="collapse" for="c-40913576">[-]</label><label class="expand" for="c-40913576">[1 more]</label></div><br/><div class="children"><div class="content">No, it doesn&#x27;t. Even a sysprepped image of Windows (which thus runs Setup to install drivers and finalize the installation) doesn&#x27;t change the boot order on UEFI machines. I think just the installer does this when you first install Windows.</div><br/></div></div><div id="40910030" class="c"><input type="checkbox" id="c-40910030" checked=""/><div class="controls bullet"><span class="by">joe5150</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40909918">parent</a><span>|</span><a href="#40913576">prev</a><span>|</span><a href="#40909425">next</a><span>|</span><label class="collapse" for="c-40910030">[-]</label><label class="expand" for="c-40910030">[1 more]</label></div><br/><div class="children"><div class="content">Not in my experience. For my typical dual boot situation where Grub is installed as the bootloader, I have to update the Grub settings like so to allow Windows updates to go smoothly:<p><pre><code>  GRUB_DEFAULT=saved
  GRUB_SAVEDEFAULT=true</code></pre></div><br/></div></div></div></div><div id="40909425" class="c"><input type="checkbox" id="c-40909425" checked=""/><div class="controls bullet"><span class="by">Denvercoder9</span><span>|</span><a href="#40908918">parent</a><span>|</span><a href="#40909918">prev</a><span>|</span><a href="#40910583">next</a><span>|</span><label class="collapse" for="c-40909425">[-]</label><label class="expand" for="c-40909425">[14 more]</label></div><br/><div class="children"><div class="content">What kind of machines are people using that entering the UEFI boot menu is difficult? On all three of mine I just press F10 during the first 5 or seconds the vendor logo shows, and I end up in a nice menu where I could select Windows, other kernels, memtest, or the EFI shell or setup.</div><br/><div id="40909452" class="c"><input type="checkbox" id="c-40909452" checked=""/><div class="controls bullet"><span class="by">mjg59</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40909425">parent</a><span>|</span><a href="#40909598">next</a><span>|</span><label class="collapse" for="c-40909452">[-]</label><label class="expand" for="c-40909452">[5 more]</label></div><br/><div class="children"><div class="content">One easy way to meet Microsoft&#x27;s boot time requirements is to skip input device enumeration, so there&#x27;s a lot of machines meeting the Windows sticker requirements where entering the firmware either requires a bunch of failed boots or getting far enough into the boot process that you can be offered an opportunity to reboot into the setup menu.</div><br/><div id="40909682" class="c"><input type="checkbox" id="c-40909682" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40909452">parent</a><span>|</span><a href="#40913739">next</a><span>|</span><label class="collapse" for="c-40909682">[-]</label><label class="expand" for="c-40909682">[1 more]</label></div><br/><div class="children"><div class="content">I have a system where you need to <i>hold down power</i> when turning on the PC to get out of &quot;Quick Boot&quot; mode, and get the ability to get to the bios screen.  It&#x27;s a Sandy-Bridge-era Intel motherboard.</div><br/></div></div><div id="40913739" class="c"><input type="checkbox" id="c-40913739" checked=""/><div class="controls bullet"><span class="by">account42</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40909452">parent</a><span>|</span><a href="#40909682">prev</a><span>|</span><a href="#40909592">next</a><span>|</span><label class="collapse" for="c-40913739">[-]</label><label class="expand" for="c-40913739">[1 more]</label></div><br/><div class="children"><div class="content">How many of these don&#x27;t have a setting to turn quick boot off?</div><br/></div></div><div id="40909592" class="c"><input type="checkbox" id="c-40909592" checked=""/><div class="controls bullet"><span class="by">Denvercoder9</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40909452">parent</a><span>|</span><a href="#40913739">prev</a><span>|</span><a href="#40909598">next</a><span>|</span><label class="collapse" for="c-40909592">[-]</label><label class="expand" for="c-40909592">[2 more]</label></div><br/><div class="children"><div class="content">Huh, today I learned. I&#x27;ll consider myself lucky I didn&#x27;t come across one of these machines yet.</div><br/><div id="40910351" class="c"><input type="checkbox" id="c-40910351" checked=""/><div class="controls bullet"><span class="by">Sakos</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40909592">parent</a><span>|</span><a href="#40909598">next</a><span>|</span><label class="collapse" for="c-40910351">[-]</label><label class="expand" for="c-40910351">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve encountered way too many of these and I hate them with all my being.</div><br/></div></div></div></div></div></div><div id="40909598" class="c"><input type="checkbox" id="c-40909598" checked=""/><div class="controls bullet"><span class="by">pavon</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40909425">parent</a><span>|</span><a href="#40909452">prev</a><span>|</span><a href="#40909689">next</a><span>|</span><label class="collapse" for="c-40909598">[-]</label><label class="expand" for="c-40909598">[4 more]</label></div><br/><div class="children"><div class="content">I was working on my Dad&#x27;s Dell laptop this weekend, and no matter how quickly I spammed the correct key (F12 in this case) it would miss it and continue to a full boot about 3&#x2F;4 times. I never figured out if it is just picky about timing, or if it had different types of reboots where some of them entering BIOS wasn&#x27;t even an option.</div><br/><div id="40910321" class="c"><input type="checkbox" id="c-40910321" checked=""/><div class="controls bullet"><span class="by">LH9000</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40909598">parent</a><span>|</span><a href="#40909633">next</a><span>|</span><label class="collapse" for="c-40910321">[-]</label><label class="expand" for="c-40910321">[2 more]</label></div><br/><div class="children"><div class="content">I start tapping as soon as the screen blanks, probably twice a second. I find this to be best for all BIOS&#x2F;UEFI interfaces.</div><br/><div id="40913569" class="c"><input type="checkbox" id="c-40913569" checked=""/><div class="controls bullet"><span class="by">vrighter</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40910321">parent</a><span>|</span><a href="#40909633">next</a><span>|</span><label class="collapse" for="c-40913569">[-]</label><label class="expand" for="c-40913569">[1 more]</label></div><br/><div class="children"><div class="content">Mine has a large delay between when the keypress is registered and the menu actually shows up. But, the window for pressing the key itself is quite short. Also, if you spam the key too quickly, it will hang indefinitely instead of entering the menu necessitating a hard-reboot. Good times.</div><br/></div></div></div></div><div id="40909633" class="c"><input type="checkbox" id="c-40909633" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40909598">parent</a><span>|</span><a href="#40910321">prev</a><span>|</span><a href="#40909689">next</a><span>|</span><label class="collapse" for="c-40909633">[-]</label><label class="expand" for="c-40909633">[1 more]</label></div><br/><div class="children"><div class="content">Newer Dell laptops have a BIOS option to artificially delay the boot process by a configurable number of seconds to give you more time to enter the menu. Which should be proof enough that the default time window is an issue.</div><br/></div></div></div></div><div id="40909689" class="c"><input type="checkbox" id="c-40909689" checked=""/><div class="controls bullet"><span class="by">spockz</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40909425">parent</a><span>|</span><a href="#40909598">prev</a><span>|</span><a href="#40909913">next</a><span>|</span><label class="collapse" for="c-40909689">[-]</label><label class="expand" for="c-40909689">[1 more]</label></div><br/><div class="children"><div class="content">On my last two uefi boards, if I press F12 or F8 too soon after power on it either stalls the boot, or it makes it restart. When the latter happens, I’m always too careful in pressing it causing me to miss the window of opportunity and booting right to the OS. Entering the bios or choosing the boot drive regularly takes me 3 tries. (Gigabyte with Intel and Asus with AMD.)</div><br/></div></div><div id="40909913" class="c"><input type="checkbox" id="c-40909913" checked=""/><div class="controls bullet"><span class="by">Am4TIfIsER0ppos</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40909425">parent</a><span>|</span><a href="#40909689">prev</a><span>|</span><a href="#40910583">next</a><span>|</span><label class="collapse" for="c-40909913">[-]</label><label class="expand" for="c-40909913">[3 more]</label></div><br/><div class="children"><div class="content">Grub is the same everywhere.  Motherboard bios&#x2F;uefi is not.  It isn&#x27;t F10 for me.</div><br/><div id="40912762" class="c"><input type="checkbox" id="c-40912762" checked=""/><div class="controls bullet"><span class="by">8n4vidtmkvmk</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40909913">parent</a><span>|</span><a href="#40910583">next</a><span>|</span><label class="collapse" for="c-40912762">[-]</label><label class="expand" for="c-40912762">[2 more]</label></div><br/><div class="children"><div class="content">How many computers are you operating though? Maybe you&#x27;ll have to reboot a couple times until you figure out the proper key but then you&#x27;ll know it. And if you forget it, you clearly aren&#x27;t doing this often enough for it to be a problem either</div><br/><div id="40913566" class="c"><input type="checkbox" id="c-40913566" checked=""/><div class="controls bullet"><span class="by">ale42</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40912762">parent</a><span>|</span><a href="#40910583">next</a><span>|</span><label class="collapse" for="c-40913566">[-]</label><label class="expand" for="c-40913566">[1 more]</label></div><br/><div class="children"><div class="content">It really depends on users. Personally... ~100? Servers, clients, dual-boot configurations, lost machines with PXE boot, various brands and BIOS versions, some even still boot in legacy mode because their UEFI support is bad (like PXE boot doesn&#x27;t work as well as it should, and as well as it does in &quot;BIOS&quot; mode). So having GRUB on basically all these machines, I&#x27;m very happy.<p>If I could do the same with something that is as small in terms of footprint, and is as flexible as GRUB is (we also PXE-boot into GRUB loaded from the network, both in BIOS and UEFI mode), then I&#x27;m interested.</div><br/></div></div></div></div></div></div></div></div><div id="40910583" class="c"><input type="checkbox" id="c-40910583" checked=""/><div class="controls bullet"><span class="by">radium3d</span><span>|</span><a href="#40908918">parent</a><span>|</span><a href="#40909425">prev</a><span>|</span><a href="#40911522">next</a><span>|</span><label class="collapse" for="c-40910583">[-]</label><label class="expand" for="c-40910583">[1 more]</label></div><br/><div class="children"><div class="content">I dual boot Win&#x2F;Arch easily with EFISTUB setup. It&#x27;s super quick to boot to a usb stick of arch if I need to edit anything with the configuration in an &quot;emergency&quot; situation as well. <a href="https:&#x2F;&#x2F;wiki.archlinux.org&#x2F;title&#x2F;EFISTUB" rel="nofollow">https:&#x2F;&#x2F;wiki.archlinux.org&#x2F;title&#x2F;EFISTUB</a></div><br/></div></div><div id="40911522" class="c"><input type="checkbox" id="c-40911522" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40908918">parent</a><span>|</span><a href="#40910583">prev</a><span>|</span><a href="#40909036">next</a><span>|</span><label class="collapse" for="c-40911522">[-]</label><label class="expand" for="c-40911522">[1 more]</label></div><br/><div class="children"><div class="content">You left out the most important reason I went back to using grub: some motherboards have dodgy UEFI support, and having an extra layer of indirection seems to be more robust sometime for some reason.</div><br/></div></div><div id="40909036" class="c"><input type="checkbox" id="c-40909036" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#40908918">parent</a><span>|</span><a href="#40911522">prev</a><span>|</span><a href="#40909637">next</a><span>|</span><label class="collapse" for="c-40909036">[-]</label><label class="expand" for="c-40909036">[2 more]</label></div><br/><div class="children"><div class="content">rEFInd is the magic tool here.<p>Personally I still use GRUB for all of the reasons you stated above. But rEFInd + kernel gets you pretty close.</div><br/><div id="40913604" class="c"><input type="checkbox" id="c-40913604" checked=""/><div class="controls bullet"><span class="by">zekica</span><span>|</span><a href="#40908918">root</a><span>|</span><a href="#40909036">parent</a><span>|</span><a href="#40909637">next</a><span>|</span><label class="collapse" for="c-40913604">[-]</label><label class="expand" for="c-40913604">[1 more]</label></div><br/><div class="children"><div class="content">rEFInd is great! I wish they just updated the default theme to something nicer.</div><br/></div></div></div></div><div id="40909637" class="c"><input type="checkbox" id="c-40909637" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#40908918">parent</a><span>|</span><a href="#40909036">prev</a><span>|</span><a href="#40909857">next</a><span>|</span><label class="collapse" for="c-40909637">[-]</label><label class="expand" for="c-40909637">[1 more]</label></div><br/><div class="children"><div class="content">&gt; - it allows to edit the cmdline of the kernel to recover a system that does not boot, e.g. start in single user mode. That can really save your day if you don&#x27;t have on hand an USB stick and another PC to flash it<p>You can use the UEFI shell for this.  It&#x27;s kind of a replacement for the old MS-DOG command line.</div><br/></div></div><div id="40909857" class="c"><input type="checkbox" id="c-40909857" checked=""/><div class="controls bullet"><span class="by">Dalewyn</span><span>|</span><a href="#40908918">parent</a><span>|</span><a href="#40909637">prev</a><span>|</span><a href="#40910228">next</a><span>|</span><label class="collapse" for="c-40909857">[-]</label><label class="expand" for="c-40909857">[1 more]</label></div><br/><div class="children"><div class="content">&gt;it allows to dual-boot with Windows easily<p>Windows Boot Manager can chainload into any arbitrary bit of code if you point it where it needs to hand off.<p>It&#x27;s a feature that goes back to Windows NT (NTLDR) supporting dual boot for Windows 9x, but it can be repurposed to boot anything you would like so long as it can execute on its own merit.<p>eg: Boot into Windows Boot Manager and, instead of booting Windows, it can hand off control to GRUB or systemd-boot to boot Linux.</div><br/></div></div><div id="40910228" class="c"><input type="checkbox" id="c-40910228" checked=""/><div class="controls bullet"><span class="by">29athrowaway</span><span>|</span><a href="#40908918">parent</a><span>|</span><a href="#40909857">prev</a><span>|</span><a href="#40912940">next</a><span>|</span><label class="collapse" for="c-40910228">[-]</label><label class="expand" for="c-40910228">[1 more]</label></div><br/><div class="children"><div class="content">I need a bootloader that automatically deletes Windows partitions upon detection.<p>And is also themed like XBill.</div><br/></div></div><div id="40912940" class="c"><input type="checkbox" id="c-40912940" checked=""/><div class="controls bullet"><span class="by">Timber-6539</span><span>|</span><a href="#40908918">parent</a><span>|</span><a href="#40910228">prev</a><span>|</span><a href="#40908266">next</a><span>|</span><label class="collapse" for="c-40912940">[-]</label><label class="expand" for="c-40912940">[1 more]</label></div><br/><div class="children"><div class="content">&gt; - it allows to edit the cmdline of the kernel to recover a system that does not boot, e.g. start in single user mode. That can really save your day if you don&#x27;t have on hand an USB stick and another PC to flash it<p>This is an indication of bad admin choice. The kernel defaults should not corrupt the boot process and if you add further experimental flags for testing you ought to have a recovery mechanism in place beforehand.</div><br/></div></div></div></div><div id="40908266" class="c"><input type="checkbox" id="c-40908266" checked=""/><div class="controls bullet"><span class="by">drewg123</span><span>|</span><a href="#40908918">prev</a><span>|</span><a href="#40909881">next</a><span>|</span><label class="collapse" for="c-40908266">[-]</label><label class="expand" for="c-40908266">[52 more]</label></div><br/><div class="children"><div class="content">I personally think they&#x27;re moving in the wrong direction.  I&#x27;d rather have &quot;NMIRFS&quot; (no more initramfs).  Eg, a smarter bootloader that understands all bootable filesystems and cooperates with the kernel to pre-load modules needed for boot and obviates the need for initramfs.<p>FreeBSD&#x27;s loader does this, and its so much easier to deal with.  Eg, it understands ZFS, and can pre-load storage driver modules and zfs.ko for the kernel, so that the kernel has everything it needs to boot up.  It also understands module dependencies, and will preload all modules that are needed for a module you specify (similar to modprobe).</div><br/><div id="40908475" class="c"><input type="checkbox" id="c-40908475" checked=""/><div class="controls bullet"><span class="by">aaronmdjones</span><span>|</span><a href="#40908266">parent</a><span>|</span><a href="#40913797">next</a><span>|</span><label class="collapse" for="c-40908475">[-]</label><label class="expand" for="c-40908475">[3 more]</label></div><br/><div class="children"><div class="content">As other sibling comments have explained, an initramfs is usually optional for booting Linux.<p>If you build the drivers for your storage media and filesystem into the kernel (not as a module), and the filesystem is visible to the kernel without any userland setup required beforehand (e.g. the filesystem is not in an LVM volume, not on an MD-RAID array, not encrypted), it is fully capable of mounting the real root filesystem and booting init directly from it.<p>The only point of consideration is that it doesn&#x27;t understand filesystem UUIDs or labels (this is part of libuuid which is used by userland tools like mount and blkid), so you have to specify <i>partition</i> UUIDs or labels instead (if you want to use UUIDs or labels). For GPT disks, this is natively available (e.g. root=PARTUUID=4F68BCE3-E8CD-4DB1-96E7-FBCAF984B709 or root=PARTLABEL=Root). For MS-DOS disks, this is emulated for UUIDs only by using the disk ID and partition number (e.g. root=PARTUUID=11223344-02).<p>You can also specify the device name directly (e.g. root=&#x2F;dev&#x2F;sda2) or the major:minor directly (e.g. root=08:02), but this is prone to enumeration order upset. If you can guarantee that this is the only disk it will ever see, or that it will always see that disk first, this is often the most simple approach, but these days I use GPT partition UUIDs.</div><br/><div id="40909336" class="c"><input type="checkbox" id="c-40909336" checked=""/><div class="controls bullet"><span class="by">mlyle</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40908475">parent</a><span>|</span><a href="#40913724">next</a><span>|</span><label class="collapse" for="c-40909336">[-]</label><label class="expand" for="c-40909336">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I think he realizes it&#x27;s optional for booting Linux.<p>In practice, we have generic kernels which require a lot of stuff in modules for real user systems running on distributions.  Instead, though, we could have a loader which doesn&#x27;t require this big relatively-opaque blob and instead loads the modules necessary at boot time (and does any necessary selection of critical boot devices).  i.e. like FreeBSD does.<p>There&#x27;s advantages each way.  You can do fancier things with an initramfs than you ever could do in the loader.  On the other hand, you can change what&#x27;s happening during boot (e.g. loading different drivers) without a lot of ancillary tooling to recover a system.</div><br/></div></div><div id="40913724" class="c"><input type="checkbox" id="c-40913724" checked=""/><div class="controls bullet"><span class="by">the_duke</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40908475">parent</a><span>|</span><a href="#40909336">prev</a><span>|</span><a href="#40913797">next</a><span>|</span><label class="collapse" for="c-40913724">[-]</label><label class="expand" for="c-40913724">[1 more]</label></div><br/><div class="children"><div class="content">I think you just reinforced the parents point.</div><br/></div></div></div></div><div id="40913797" class="c"><input type="checkbox" id="c-40913797" checked=""/><div class="controls bullet"><span class="by">dexen</span><span>|</span><a href="#40908266">parent</a><span>|</span><a href="#40908475">prev</a><span>|</span><a href="#40908340">next</a><span>|</span><label class="collapse" for="c-40913797">[-]</label><label class="expand" for="c-40913797">[1 more]</label></div><br/><div class="children"><div class="content">Seconding this.<p>Having lucked into using Lilo and no initramfs for several years now, I&#x27;m very happy with robustness and straightforwardness of the solution.<p>In contrast, on the rare occasion I&#x27;ve dealt with somebody elses&#x27; GRUB and initramfs setups, they turn out brittle and complex.</div><br/></div></div><div id="40908340" class="c"><input type="checkbox" id="c-40908340" checked=""/><div class="controls bullet"><span class="by">ta8645</span><span>|</span><a href="#40908266">parent</a><span>|</span><a href="#40913797">prev</a><span>|</span><a href="#40909060">next</a><span>|</span><label class="collapse" for="c-40908340">[-]</label><label class="expand" for="c-40908340">[27 more]</label></div><br/><div class="children"><div class="content">The Linux kernel does not require an initramfs.  You can build a kernel with everything compiled in; with no modules needed at all.  Initramfs is used for generic kernels where you don&#x27;t know beforehand which features will be required.  This allows you to avoid wasting RAM on features you don&#x27;t use.  But it is optional.</div><br/><div id="40909320" class="c"><input type="checkbox" id="c-40909320" checked=""/><div class="controls bullet"><span class="by">drewg123</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40908340">parent</a><span>|</span><a href="#40909593">next</a><span>|</span><label class="collapse" for="c-40909320">[-]</label><label class="expand" for="c-40909320">[14 more]</label></div><br/><div class="children"><div class="content">I realize that.  But every distro I&#x27;ve used uses an initramfs, so unless you want to build your own kernels, you&#x27;re stuck with it, and the painfully slow initramfs updates when you update packages, and dkms (or similar) updates the initramfs with the newer version of your out-of-tree modules.</div><br/><div id="40909470" class="c"><input type="checkbox" id="c-40909470" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40909320">parent</a><span>|</span><a href="#40911447">next</a><span>|</span><label class="collapse" for="c-40909470">[-]</label><label class="expand" for="c-40909470">[12 more]</label></div><br/><div class="children"><div class="content">Given the reason why &quot;out-of-tree modules&quot; exist, there&#x27;s really no way to eliminate initramfs or something like it entirely in the general case. It might be possible to speed up the process of building the image (as long as the results are not &quot;redistributed&quot;), but this is a licensing and legal problem, not a technical one. FreeBSD is under a much more permissive non-copyleft license and so can legally bundle things that Linux cannot.</div><br/><div id="40913221" class="c"><input type="checkbox" id="c-40913221" checked=""/><div class="controls bullet"><span class="by">FeepingCreature</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40909470">parent</a><span>|</span><a href="#40911755">next</a><span>|</span><label class="collapse" for="c-40913221">[-]</label><label class="expand" for="c-40913221">[1 more]</label></div><br/><div class="children"><div class="content">You could probably build a &quot;virtual initramfs&quot;:<p>- linux tells the bootloader what folder the modules live<p>- bootloader just puts them all in memory<p>- linux just picks what it needs.<p>That&#x27;s all the initramfs is anyways. The point is there&#x27;s no reason to prebuild an image from inside Linux, you can just have grub assemble a simple fs on the fly.</div><br/></div></div><div id="40911755" class="c"><input type="checkbox" id="c-40911755" checked=""/><div class="controls bullet"><span class="by">nwallin</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40909470">parent</a><span>|</span><a href="#40913221">prev</a><span>|</span><a href="#40909729">next</a><span>|</span><label class="collapse" for="c-40911755">[-]</label><label class="expand" for="c-40911755">[1 more]</label></div><br/><div class="children"><div class="content">initramfs can be eliminated if no kernel modules are required to boot the system. In practice, this means drivers for the motherboard, drivers for the block storage system, and the filesystem have to be compiled in as opposed to being modules. Certain &#x27;interesting&#x27; disk schemes that require userspace configuration tools aren&#x27;t possible, including LVM2, dmraid, disk encryption, &#x2F;etc&#x2F;fstab has to hardcode the physical path, and probably a dozen other things I can&#x27;t think of. If you want to do PXE boot over wifi and you have out of tree wifi drivers I don&#x27;t think that would work, though tbh PXE over wifi sounds insane.</div><br/></div></div><div id="40909729" class="c"><input type="checkbox" id="c-40909729" checked=""/><div class="controls bullet"><span class="by">medstrom</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40909470">parent</a><span>|</span><a href="#40911755">prev</a><span>|</span><a href="#40911447">next</a><span>|</span><label class="collapse" for="c-40909729">[-]</label><label class="expand" for="c-40909729">[9 more]</label></div><br/><div class="children"><div class="content">You&#x27;re talking about something like ZFS, and I get that they can&#x27;t just compile it in, but a distro can still ship the module, if I&#x27;m not mistaken.<p>...But to load it at boot time it absolutely must be done through an initramfs. Is that right?</div><br/><div id="40910044" class="c"><input type="checkbox" id="c-40910044" checked=""/><div class="controls bullet"><span class="by">aaronmdjones</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40909729">parent</a><span>|</span><a href="#40911478">next</a><span>|</span><label class="collapse" for="c-40910044">[-]</label><label class="expand" for="c-40910044">[7 more]</label></div><br/><div class="children"><div class="content">&gt; But to load it at boot time it absolutely must be done through an initramfs. Is that right?<p>Yes, because it cannot be part of the kernel image, or it would be illegal (a violation of the GPL license) to distribute that kernel. Therefore, it must be a module, and that module has to live somewhere and be loaded by something. If root is on ZFS, this must therefore live in an initramfs and be loaded by it so that the initramfs can mount the real root filesystem on the kernel&#x27;s behalf.</div><br/><div id="40913562" class="c"><input type="checkbox" id="c-40913562" checked=""/><div class="controls bullet"><span class="by">prmoustache</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40910044">parent</a><span>|</span><a href="#40910870">next</a><span>|</span><label class="collapse" for="c-40913562">[-]</label><label class="expand" for="c-40913562">[2 more]</label></div><br/><div class="children"><div class="content">The distro could automatize the compilation of the kernel with ZFS on the user machine. In that case no license is violated as the kernel image is not distributed with ZFS.<p>That would probably make updates a lot less slower than having zfs shipped in an initramfs though.</div><br/><div id="40913809" class="c"><input type="checkbox" id="c-40913809" checked=""/><div class="controls bullet"><span class="by">account42</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40913562">parent</a><span>|</span><a href="#40910870">next</a><span>|</span><label class="collapse" for="c-40913809">[-]</label><label class="expand" for="c-40913809">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t really have to be slower as all that would be needed to do on installation is the final linking step. Linking prebuilt objects into a prepared kernel image shouldn&#x27;t be inherently slower than assembling modules into an initramfs.</div><br/></div></div></div></div><div id="40910870" class="c"><input type="checkbox" id="c-40910870" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40910044">parent</a><span>|</span><a href="#40913562">prev</a><span>|</span><a href="#40910473">next</a><span>|</span><label class="collapse" for="c-40910870">[-]</label><label class="expand" for="c-40910870">[1 more]</label></div><br/><div class="children"><div class="content">One could have the equivalent of DKMS build the modules into the kernel image instead of building the initramfs. I don&#x27;t know how much practical overhead there is to the initramfs and pivot_root dance, but it feels far uglier than it should need to be to just load some modules.</div><br/></div></div><div id="40910473" class="c"><input type="checkbox" id="c-40910473" checked=""/><div class="controls bullet"><span class="by">megous</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40910044">parent</a><span>|</span><a href="#40910870">prev</a><span>|</span><a href="#40911478">next</a><span>|</span><label class="collapse" for="c-40910473">[-]</label><label class="expand" for="c-40910473">[3 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t have to be a module if you&#x27;re building the kernel for yourself. No violation in that.</div><br/><div id="40910594" class="c"><input type="checkbox" id="c-40910594" checked=""/><div class="controls bullet"><span class="by">aaronmdjones</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40910473">parent</a><span>|</span><a href="#40910536">prev</a><span>|</span><a href="#40911478">next</a><span>|</span><label class="collapse" for="c-40910594">[-]</label><label class="expand" for="c-40910594">[1 more]</label></div><br/><div class="children"><div class="content">GP was talking about distribution kernels.</div><br/></div></div></div></div></div></div><div id="40911478" class="c"><input type="checkbox" id="c-40911478" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40909729">parent</a><span>|</span><a href="#40910044">prev</a><span>|</span><a href="#40911447">next</a><span>|</span><label class="collapse" for="c-40911478">[-]</label><label class="expand" for="c-40911478">[1 more]</label></div><br/><div class="children"><div class="content">Yes, as this is the closest equivalent to &quot;dynamic linking&quot; that can happen at boot time.</div><br/></div></div></div></div></div></div><div id="40911447" class="c"><input type="checkbox" id="c-40911447" checked=""/><div class="controls bullet"><span class="by">markhahn</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40909320">parent</a><span>|</span><a href="#40909470">prev</a><span>|</span><a href="#40909593">next</a><span>|</span><label class="collapse" for="c-40911447">[-]</label><label class="expand" for="c-40911447">[1 more]</label></div><br/><div class="children"><div class="content">why would initramfs updates be slow?  do you mean that most initramfses are large?  how much time are we talking about?</div><br/></div></div></div></div><div id="40909593" class="c"><input type="checkbox" id="c-40909593" checked=""/><div class="controls bullet"><span class="by">linsomniac</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40908340">parent</a><span>|</span><a href="#40909320">prev</a><span>|</span><a href="#40908820">next</a><span>|</span><label class="collapse" for="c-40909593">[-]</label><label class="expand" for="c-40909593">[7 more]</label></div><br/><div class="children"><div class="content">Is anyone really wanting to get back into the business of building their own kernels?  I started using Linux heavily in &#x27;92, and I&#x27;ve built a lot of kernels, and am quite happy to not be building them anymore.</div><br/><div id="40913830" class="c"><input type="checkbox" id="c-40913830" checked=""/><div class="controls bullet"><span class="by">account42</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40909593">parent</a><span>|</span><a href="#40913587">next</a><span>|</span><label class="collapse" for="c-40913830">[-]</label><label class="expand" for="c-40913830">[1 more]</label></div><br/><div class="children"><div class="content">I never stopped. What&#x27;s so bad about building your own kernel?</div><br/></div></div><div id="40913587" class="c"><input type="checkbox" id="c-40913587" checked=""/><div class="controls bullet"><span class="by">prmoustache</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40909593">parent</a><span>|</span><a href="#40913830">prev</a><span>|</span><a href="#40910017">next</a><span>|</span><label class="collapse" for="c-40913587">[-]</label><label class="expand" for="c-40913587">[1 more]</label></div><br/><div class="children"><div class="content">kernel compilation is easily automated. I don&#x27;t want to do that and like the initramfs approach mostly because I like the fact I can take a hard drive out of a computer and boot the system on another one in case of a hardware failure.<p>That is a lot faster than recovering from a backup.</div><br/></div></div><div id="40910017" class="c"><input type="checkbox" id="c-40910017" checked=""/><div class="controls bullet"><span class="by">ssl-3</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40909593">parent</a><span>|</span><a href="#40913587">prev</a><span>|</span><a href="#40910904">next</a><span>|</span><label class="collapse" for="c-40910017">[-]</label><label class="expand" for="c-40910017">[1 more]</label></div><br/><div class="children"><div class="content">I kind of liked compiling my own kernels.  I felt I was better-connected to the state of things, and it was fun to see it all evolve from the vantage point of &quot;make menuconfig&quot;.<p>But initramfs isn&#x27;t so bad, and it allows things like ZFS root to have a modicum of smoothness and integration.</div><br/></div></div><div id="40910904" class="c"><input type="checkbox" id="c-40910904" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40909593">parent</a><span>|</span><a href="#40910017">prev</a><span>|</span><a href="#40911559">next</a><span>|</span><label class="collapse" for="c-40910904">[-]</label><label class="expand" for="c-40910904">[1 more]</label></div><br/><div class="children"><div class="content">I build my own kernel. I did invest some time to select the right configuration, but now it&#x27;s just a question of copying over the old .config and running &quot;make&quot;. What&#x27;s annoying about that?</div><br/></div></div><div id="40911559" class="c"><input type="checkbox" id="c-40911559" checked=""/><div class="controls bullet"><span class="by">adamomada</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40909593">parent</a><span>|</span><a href="#40910904">prev</a><span>|</span><a href="#40910452">next</a><span>|</span><label class="collapse" for="c-40911559">[-]</label><label class="expand" for="c-40911559">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.funtoo.org&#x2F;Support_Matrix#Kernels" rel="nofollow">https:&#x2F;&#x2F;www.funtoo.org&#x2F;Support_Matrix#Kernels</a></div><br/></div></div><div id="40910452" class="c"><input type="checkbox" id="c-40910452" checked=""/><div class="controls bullet"><span class="by">megous</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40909593">parent</a><span>|</span><a href="#40911559">prev</a><span>|</span><a href="#40908820">next</a><span>|</span><label class="collapse" for="c-40910452">[-]</label><label class="expand" for="c-40910452">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s easy (2-3 commands), takes like a minute on a modern machine with trimmed down kernel configuration, and you can customize the kernel to your liking (write&#x2F;patch drivers, embed firmware blobs, fix things that are broken or missing). What&#x27;s to hate? :)<p>Though I only do it for my ARM based devices currently.<p>And if you&#x27;re not throwing away build artifacts after each build, then getting stable updates is just a `git pull` and incremental make, which is usually very quick.</div><br/></div></div></div></div><div id="40908820" class="c"><input type="checkbox" id="c-40908820" checked=""/><div class="controls bullet"><span class="by">jolmg</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40908340">parent</a><span>|</span><a href="#40909593">prev</a><span>|</span><a href="#40909657">next</a><span>|</span><label class="collapse" for="c-40908820">[-]</label><label class="expand" for="c-40908820">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Initramfs is used for generic kernels where you don&#x27;t know beforehand which features will be required.<p>And also for e.g. cases where you&#x27;ve got some custom stack of block devices that you need to set up before the root FS and other devices can be mounted. It&#x27;s not just about loading kernel modules.</div><br/></div></div><div id="40909657" class="c"><input type="checkbox" id="c-40909657" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40908340">parent</a><span>|</span><a href="#40908820">prev</a><span>|</span><a href="#40908438">next</a><span>|</span><label class="collapse" for="c-40909657">[-]</label><label class="expand" for="c-40909657">[3 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the reason it doesn&#x27;t load those modules from the regular filesystem? That&#x27;s what FreeBSD does, and seems to work well enough?</div><br/><div id="40910438" class="c"><input type="checkbox" id="c-40910438" checked=""/><div class="controls bullet"><span class="by">ta8645</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40909657">parent</a><span>|</span><a href="#40908438">next</a><span>|</span><label class="collapse" for="c-40910438">[-]</label><label class="expand" for="c-40910438">[2 more]</label></div><br/><div class="children"><div class="content">Because there are a lot of different types of filesystems supported.  And you&#x27;d have to compile them all into the kernel.  Which of course you can do, that is supported by the build system today.  But Distros typically prefer to keep their kernels small, and not waste the RAM that would be taken up by compiling it all into the kernel.</div><br/><div id="40912933" class="c"><input type="checkbox" id="c-40912933" checked=""/><div class="controls bullet"><span class="by">mixmastamyk</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40910438">parent</a><span>|</span><a href="#40908438">next</a><span>|</span><label class="collapse" for="c-40912933">[-]</label><label class="expand" for="c-40912933">[1 more]</label></div><br/><div class="children"><div class="content">It must already have vfat and the ESP, so why not just copy a basic set of modules to a subfolder there?</div><br/></div></div></div></div></div></div><div id="40908438" class="c"><input type="checkbox" id="c-40908438" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40908340">parent</a><span>|</span><a href="#40909657">prev</a><span>|</span><a href="#40909060">next</a><span>|</span><label class="collapse" for="c-40908438">[-]</label><label class="expand" for="c-40908438">[1 more]</label></div><br/><div class="children"><div class="content">I think the idea is, since modules map to device ids statically, bootloader could have enough information to read them from the filestem one by one.<p>I don’t see the point of doing so however.</div><br/></div></div></div></div><div id="40909060" class="c"><input type="checkbox" id="c-40909060" checked=""/><div class="controls bullet"><span class="by">mjg59</span><span>|</span><a href="#40908266">parent</a><span>|</span><a href="#40908340">prev</a><span>|</span><a href="#40908579">next</a><span>|</span><label class="collapse" for="c-40909060">[-]</label><label class="expand" for="c-40909060">[1 more]</label></div><br/><div class="children"><div class="content">This requires a bunch of additional logic in the bootloader (eg, providing disk encryption keys), and since you&#x27;re not doing this in a fully-featured OS environment (as you are in the initramfs case) it&#x27;s going to be hard providing a consistent experience through the entire boot process. Having the pre-boot environment be a (slightly) cut-down version of the actual OS means all your tooling can be shared between the two environments.</div><br/></div></div><div id="40908579" class="c"><input type="checkbox" id="c-40908579" checked=""/><div class="controls bullet"><span class="by">zdw</span><span>|</span><a href="#40908266">parent</a><span>|</span><a href="#40909060">prev</a><span>|</span><a href="#40908385">next</a><span>|</span><label class="collapse" for="c-40908579">[-]</label><label class="expand" for="c-40908579">[10 more]</label></div><br/><div class="children"><div class="content">FWIW, Grub has a read-only ZFS implementation to allow booting: <a href="https:&#x2F;&#x2F;git.savannah.gnu.org&#x2F;cgit&#x2F;grub.git&#x2F;tree&#x2F;include&#x2F;grub&#x2F;zfs" rel="nofollow">https:&#x2F;&#x2F;git.savannah.gnu.org&#x2F;cgit&#x2F;grub.git&#x2F;tree&#x2F;include&#x2F;grub...</a></div><br/><div id="40908694" class="c"><input type="checkbox" id="c-40908694" checked=""/><div class="controls bullet"><span class="by">nubinetwork</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40908579">parent</a><span>|</span><a href="#40910855">next</a><span>|</span><label class="collapse" for="c-40908694">[-]</label><label class="expand" for="c-40908694">[7 more]</label></div><br/><div class="children"><div class="content">Grub uses an ancient version of zfs code, it&#x27;s tied to Oracle&#x27;s zfs and they refuse to update it to current openzfs.</div><br/><div id="40909478" class="c"><input type="checkbox" id="c-40909478" checked=""/><div class="controls bullet"><span class="by">UnlockedSecrets</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40908694">parent</a><span>|</span><a href="#40909539">next</a><span>|</span><label class="collapse" for="c-40909478">[-]</label><label class="expand" for="c-40909478">[3 more]</label></div><br/><div class="children"><div class="content">Are there any instances of features being utilized that the old version of the code is unable to cope with well enough to be able to boot the system?</div><br/><div id="40909546" class="c"><input type="checkbox" id="c-40909546" checked=""/><div class="controls bullet"><span class="by">upon_drumhead</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40909478">parent</a><span>|</span><a href="#40910350">next</a><span>|</span><label class="collapse" for="c-40909546">[-]</label><label class="expand" for="c-40909546">[1 more]</label></div><br/><div class="children"><div class="content">Native ZFS encryption is the major one I&#x27;m aware of</div><br/></div></div><div id="40910350" class="c"><input type="checkbox" id="c-40910350" checked=""/><div class="controls bullet"><span class="by">nubinetwork</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40909478">parent</a><span>|</span><a href="#40909546">prev</a><span>|</span><a href="#40909539">next</a><span>|</span><label class="collapse" for="c-40910350">[-]</label><label class="expand" for="c-40910350">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;openzfs&#x2F;zfs&#x2F;tree&#x2F;master&#x2F;cmd&#x2F;zpool&#x2F;compatibility.d">https:&#x2F;&#x2F;github.com&#x2F;openzfs&#x2F;zfs&#x2F;tree&#x2F;master&#x2F;cmd&#x2F;zpool&#x2F;compati...</a></div><br/></div></div></div></div><div id="40909539" class="c"><input type="checkbox" id="c-40909539" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40908694">parent</a><span>|</span><a href="#40909478">prev</a><span>|</span><a href="#40909629">next</a><span>|</span><label class="collapse" for="c-40909539">[-]</label><label class="expand" for="c-40909539">[2 more]</label></div><br/><div class="children"><div class="content">Refuse, or legally can&#x27;t? Oracle doesn&#x27;t own the copyrights on commits made after illumos forked from the corpse of opensolaris.</div><br/><div id="40910809" class="c"><input type="checkbox" id="c-40910809" checked=""/><div class="controls bullet"><span class="by">nubinetwork</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40909539">parent</a><span>|</span><a href="#40909629">next</a><span>|</span><label class="collapse" for="c-40910809">[-]</label><label class="expand" for="c-40910809">[1 more]</label></div><br/><div class="children"><div class="content">A little of both.  Everyone know about Linus&#x27; refusal to touch CDDL code, but grub isn&#x27;t the kernel.<p>There have been several attempts to add features to the grub zfs code over the years, but there are several maintainers of grub who happen to be employees of Oracle, and typically the attempts go nowhere.<p>I personally can&#x27;t recommend using grub anymore.  The whole &quot;just make 2 pools&quot; solution is unacceptable, and until Oracle stops gatekeeping, their code becomes more obsolete in my eyes.</div><br/></div></div></div></div><div id="40909629" class="c"><input type="checkbox" id="c-40909629" checked=""/><div class="controls bullet"><span class="by">dizhn</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40908694">parent</a><span>|</span><a href="#40909539">prev</a><span>|</span><a href="#40910855">next</a><span>|</span><label class="collapse" for="c-40909629">[-]</label><label class="expand" for="c-40909629">[1 more]</label></div><br/><div class="children"><div class="content">Yeah update your zfs file system to gain new features and bam, you can&#x27;t boot no more.</div><br/></div></div></div></div><div id="40910855" class="c"><input type="checkbox" id="c-40910855" checked=""/><div class="controls bullet"><span class="by">E39M5S62</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40908579">parent</a><span>|</span><a href="#40908694">prev</a><span>|</span><a href="#40908385">next</a><span>|</span><label class="collapse" for="c-40910855">[-]</label><label class="expand" for="c-40910855">[2 more]</label></div><br/><div class="children"><div class="content">Ditch grub and use Linux to boot Linux on ZFS - <a href="https:&#x2F;&#x2F;docs.zfsbootmenu.org&#x2F;en&#x2F;v2.3.x&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.zfsbootmenu.org&#x2F;en&#x2F;v2.3.x&#x2F;</a> .</div><br/><div id="40913643" class="c"><input type="checkbox" id="c-40913643" checked=""/><div class="controls bullet"><span class="by">prmoustache</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40910855">parent</a><span>|</span><a href="#40908385">next</a><span>|</span><label class="collapse" for="c-40913643">[-]</label><label class="expand" for="c-40913643">[1 more]</label></div><br/><div class="children"><div class="content">Didn&#x27;t knew that one, thanks for that.</div><br/></div></div></div></div></div></div><div id="40908385" class="c"><input type="checkbox" id="c-40908385" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#40908266">parent</a><span>|</span><a href="#40908579">prev</a><span>|</span><a href="#40909994">next</a><span>|</span><label class="collapse" for="c-40908385">[-]</label><label class="expand" for="c-40908385">[1 more]</label></div><br/><div class="children"><div class="content">Linux has multiple choices for filesystems for root, even if you only count the most popular ones. And on top of that they could be encrypted by LUKS. Duplicating all that into the bootloader is what GRUB does, and poorly. Putting the kernel into the ESP is much better in that regard.</div><br/></div></div><div id="40909994" class="c"><input type="checkbox" id="c-40909994" checked=""/><div class="controls bullet"><span class="by">zauguin</span><span>|</span><a href="#40908266">parent</a><span>|</span><a href="#40908385">prev</a><span>|</span><a href="#40910349">next</a><span>|</span><label class="collapse" for="c-40909994">[-]</label><label class="expand" for="c-40909994">[1 more]</label></div><br/><div class="children"><div class="content">This is a step in that direction. What they are proposing is not so much &quot;no bootloader&quot; but using a small Linux as bootloader. I&#x27;m using a similar setup for some time and it gives some of these advantages. Especially you get support for all relevant filesystems (you can support everything Linux supports because it <i>is</i> Linux), it can dynamically build a minimal initramfs with only the needed drivers if you want to and understands module dependencies (e.g. it can just dump the list of modules it uses itself) and is generally much more flexible.</div><br/></div></div><div id="40910349" class="c"><input type="checkbox" id="c-40910349" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#40908266">parent</a><span>|</span><a href="#40909994">prev</a><span>|</span><a href="#40908359">next</a><span>|</span><label class="collapse" for="c-40910349">[-]</label><label class="expand" for="c-40910349">[1 more]</label></div><br/><div class="children"><div class="content">Does FreeBSD&#x27;s loader share code with the kernel? It does seem like a lot of duplication of systems to make it work in comparison to just using the same code.</div><br/></div></div><div id="40908359" class="c"><input type="checkbox" id="c-40908359" checked=""/><div class="controls bullet"><span class="by">Aurornis</span><span>|</span><a href="#40908266">parent</a><span>|</span><a href="#40910349">prev</a><span>|</span><a href="#40908429">next</a><span>|</span><label class="collapse" for="c-40908359">[-]</label><label class="expand" for="c-40908359">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  I&#x27;d rather have &quot;NMIRFS&quot; (no more initramfs).<p>In many cases, you don&#x27;t need initramfs. I rarely use one in embedded systems.</div><br/><div id="40908733" class="c"><input type="checkbox" id="c-40908733" checked=""/><div class="controls bullet"><span class="by">fullstop</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40908359">parent</a><span>|</span><a href="#40908429">next</a><span>|</span><label class="collapse" for="c-40908733">[-]</label><label class="expand" for="c-40908733">[1 more]</label></div><br/><div class="children"><div class="content">I use them in embedded systems because they allow me to mount encrypted volumes without exposing the keys.</div><br/></div></div></div></div><div id="40908429" class="c"><input type="checkbox" id="c-40908429" checked=""/><div class="controls bullet"><span class="by">m463</span><span>|</span><a href="#40908266">parent</a><span>|</span><a href="#40908359">prev</a><span>|</span><a href="#40910442">next</a><span>|</span><label class="collapse" for="c-40908429">[-]</label><label class="expand" for="c-40908429">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I personally think they&#x27;re moving in the wrong direction<p>the other direction is to put everything in systemd.  :)</div><br/><div id="40911465" class="c"><input type="checkbox" id="c-40911465" checked=""/><div class="controls bullet"><span class="by">markhahn</span><span>|</span><a href="#40908266">root</a><span>|</span><a href="#40908429">parent</a><span>|</span><a href="#40910442">next</a><span>|</span><label class="collapse" for="c-40911465">[-]</label><label class="expand" for="c-40911465">[1 more]</label></div><br/><div class="children"><div class="content">bad thing to joke about.</div><br/></div></div></div></div><div id="40910442" class="c"><input type="checkbox" id="c-40910442" checked=""/><div class="controls bullet"><span class="by">fooker</span><span>|</span><a href="#40908266">parent</a><span>|</span><a href="#40908429">prev</a><span>|</span><a href="#40909161">next</a><span>|</span><label class="collapse" for="c-40910442">[-]</label><label class="expand" for="c-40910442">[1 more]</label></div><br/><div class="children"><div class="content">The more smartness you put here, the more it makes life difficult for non-standard operating systems.<p>And if this bit is closed source, and something doesn&#x27;t work, you don&#x27;t have a recourse.</div><br/></div></div><div id="40909161" class="c"><input type="checkbox" id="c-40909161" checked=""/><div class="controls bullet"><span class="by">sim7c00</span><span>|</span><a href="#40908266">parent</a><span>|</span><a href="#40910442">prev</a><span>|</span><a href="#40909881">next</a><span>|</span><label class="collapse" for="c-40909161">[-]</label><label class="expand" for="c-40909161">[1 more]</label></div><br/><div class="children"><div class="content">this exactly. freebsd&#x27;s loader is one of the only sane ones ive seen. grub is an amazing piece of software but its really a mess to work with.</div><br/></div></div></div></div><div id="40909881" class="c"><input type="checkbox" id="c-40909881" checked=""/><div class="controls bullet"><span class="by">mjg59</span><span>|</span><a href="#40908266">prev</a><span>|</span><a href="#40908544">next</a><span>|</span><label class="collapse" for="c-40909881">[-]</label><label class="expand" for="c-40909881">[6 more]</label></div><br/><div class="children"><div class="content">A lot of the commentary here is based on misunderstandings of the capabilities and constraints of a UEFI environment and what the actual goals of this project are, and I think miss the mark to a large degree. Lennart&#x27;s written some more explicit criticism at <a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;981149&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;981149&#x2F;</a> and I think that&#x27;s a much more interesting set of concerns.</div><br/><div id="40911467" class="c"><input type="checkbox" id="c-40911467" checked=""/><div class="controls bullet"><span class="by">cycomanic</span><span>|</span><a href="#40909881">parent</a><span>|</span><a href="#40911383">next</a><span>|</span><label class="collapse" for="c-40911467">[-]</label><label class="expand" for="c-40911467">[1 more]</label></div><br/><div class="children"><div class="content">I have to say I find Lennart&#x27;s arguments quite unconvincing. As another person said, the vast majority of people just want default boot to the most recent kernel (which this proposal could do well).<p>But then when it comes to the other points, yes I want to be able to reliably boot into other systems, but both systemd-boot and grub are notoriously bad at detecting other systems on disks (both use install-time detection IIRC). The only one which does a reasonable job is rEFInd. But even more a kernel with appropriate drivers could even add kernels&#x2F;systems on usb disks to the selections (why do I have to go to the UEFI selection to boot from USB).<p>The next thing he completely ignores is booting into zfs or btrfs snapshots, which is not possible using systemd-boot AFAIK, and again would be much nicer to do with a kernel.</div><br/></div></div><div id="40911383" class="c"><input type="checkbox" id="c-40911383" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#40909881">parent</a><span>|</span><a href="#40911467">prev</a><span>|</span><a href="#40913551">next</a><span>|</span><label class="collapse" for="c-40911383">[-]</label><label class="expand" for="c-40911383">[1 more]</label></div><br/><div class="children"><div class="content">I feel like that post misses the biggest one that pulls people to GRUB: complicated boot sources and procedures. Filesystems that UEFI doesn&#x27;t understand, more complex network boot sources, all that kind of complex messiness that GRUB enables and others don&#x27;t. Now, whether those are good idea or not is a different question, but I think this is a good concept for a full replacement for GRUB, as opposed to the existing replacements which already cover the 90% case pretty well. (And I think it&#x27;s got a case for handling the other cases OK: from the sounds of it they plan to lean on UEFI and A&#x2F;B image to handle fallback, and it&#x27;ll basically just work as a direct UEFI boot in the common case)</div><br/></div></div><div id="40913551" class="c"><input type="checkbox" id="c-40913551" checked=""/><div class="controls bullet"><span class="by">kasabali</span><span>|</span><a href="#40909881">parent</a><span>|</span><a href="#40911383">prev</a><span>|</span><a href="#40908544">next</a><span>|</span><label class="collapse" for="c-40913551">[-]</label><label class="expand" for="c-40913551">[3 more]</label></div><br/><div class="children"><div class="content">&gt; completely useless if you care about Measured Boot<p>I stopped reading there. All these engineers who help build and defend this draconian crap should be forced to used only an iPad for the rest of their lives.</div><br/><div id="40913574" class="c"><input type="checkbox" id="c-40913574" checked=""/><div class="controls bullet"><span class="by">mjg59</span><span>|</span><a href="#40909881">root</a><span>|</span><a href="#40913551">parent</a><span>|</span><a href="#40913565">next</a><span>|</span><label class="collapse" for="c-40913574">[-]</label><label class="expand" for="c-40913574">[1 more]</label></div><br/><div class="children"><div class="content">Measured boot is, in itself, under user control - you can seal whatever secrets you want to any specific state and they&#x27;ll only be accessible in that situation. This has obvious benefits in terms of being able to (for instance) tie disk encryption keys to a known boot state and so avoid needing to type in a decryption phrase while still preventing anyone from being able to simply modify your boot process to obtain that secret. The largest risk around this is from remote attestation, and that&#x27;s simply not something where the infrastructure exists for anyone to implement any kind of user restriction (and also it&#x27;s trivial to circumvent by simply tying any remote attestation to a TPM that&#x27;s not present at boot time and so can be programmed as necessary - it&#x27;s just not good at being useful DRM)</div><br/></div></div><div id="40913565" class="c"><input type="checkbox" id="c-40913565" checked=""/><div class="controls bullet"><span class="by">tpoacher</span><span>|</span><a href="#40909881">root</a><span>|</span><a href="#40913551">parent</a><span>|</span><a href="#40913574">prev</a><span>|</span><a href="#40908544">next</a><span>|</span><label class="collapse" for="c-40913565">[-]</label><label class="expand" for="c-40913565">[1 more]</label></div><br/><div class="children"><div class="content">Of all the horrible punishments you could have envisioned, you went full-on &quot;I have no mouth and I must scream&quot; there...</div><br/></div></div></div></div></div></div><div id="40908544" class="c"><input type="checkbox" id="c-40908544" checked=""/><div class="controls bullet"><span class="by">saltcured</span><span>|</span><a href="#40909881">prev</a><span>|</span><a href="#40912428">next</a><span>|</span><label class="collapse" for="c-40908544">[-]</label><label class="expand" for="c-40908544">[1 more]</label></div><br/><div class="children"><div class="content">This reminds me of MILO for booting Linux on some (?) DEC Alpha systems back in the 90s.  I don&#x27;t remember much about the actual firmware anymore. Much like today with UEFI, the system had some low-level UI and built-in drivers to support diagnostics, disk and network booting, etc.<p>MILO could be installed as a boot entry in the firmware-level boot menu. MILO was a sort of stripped down Linux kernel that used its drivers to find and load the real kernel, ending with a kexec to hand over the system.<p>No matter how you slice it, I think you&#x27;ll always come around to wanting this sort of intermediate bootloader that has a different software maintenance lifecycle from the actual kernel. It is a fine idea to reuse the same codebase and get all the breadth of drivers and capabilities, but you want the bootloader to have a very &quot;stability&quot; focused release cycle so it is highly repeatable.<p>And, I think you want a data-driven, menu&#x2F;config layer to make it easy to add new kernels and allow rollback to prior kernels at runtime. I hope we don&#x27;t see people eventually trying to push Android-style UX onto regular Linux computers, i.e. where the bootloader is mostly hidden and the kernel treated as if it is firmware, with at most some A&#x2F;B boot selection option.</div><br/></div></div><div id="40912428" class="c"><input type="checkbox" id="c-40912428" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#40908544">prev</a><span>|</span><a href="#40908784">next</a><span>|</span><label class="collapse" for="c-40912428">[-]</label><label class="expand" for="c-40912428">[1 more]</label></div><br/><div class="children"><div class="content">Does anyone still remember when you could just dd the Linux kernel to a floppy and it would be its own bootloader?<p><a href="https:&#x2F;&#x2F;yosemitefoothills.com&#x2F;LinuxBoot&#x2F;BD-1Disk.htm" rel="nofollow">https:&#x2F;&#x2F;yosemitefoothills.com&#x2F;LinuxBoot&#x2F;BD-1Disk.htm</a><p>Here&#x27;s some more documentation on this:
<a href="https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;Documentation&#x2F;x86&#x2F;boot.txt" rel="nofollow">https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;Documentation&#x2F;x86&#x2F;boot.txt</a><p>What&#x27;s old is new again... except 100x more complex and likely more than necessary.</div><br/></div></div><div id="40908784" class="c"><input type="checkbox" id="c-40908784" checked=""/><div class="controls bullet"><span class="by">samsartor</span><span>|</span><a href="#40912428">prev</a><span>|</span><a href="#40908460">next</a><span>|</span><label class="collapse" for="c-40908784">[-]</label><label class="expand" for="c-40908784">[3 more]</label></div><br/><div class="children"><div class="content">My previous laptop was a Chromebook running Linux+Coreboot. Unfortunately the usual Tianocore UEFI BIOS people use had some bugs in the nvme and keyboard drivers, which I gave up fixing or working around (at the time). Obviously Linux had working drivers because that&#x27;s all ChromeOS is, so we setup a minimal Linux install as the Coreboot payload in the firmware flash, and I wrote a little Rust TUI to mount all visible partitions and kexec anything that looked like a kernel image. It worked like a charm and had all kinds of cool features, like wifi and a proper terminal for debugging in the BIOS! Based on that experience I don&#x27;t see any reason why we don&#x27;t just use Linux direct instead for everything. Why duplicate all the drivers?<p>The code is here although it hasn&#x27;t been touched it years: <a href="https:&#x2F;&#x2F;gitlab.com&#x2F;samsartor&#x2F;alamode-boot" rel="nofollow">https:&#x2F;&#x2F;gitlab.com&#x2F;samsartor&#x2F;alamode-boot</a></div><br/><div id="40910087" class="c"><input type="checkbox" id="c-40910087" checked=""/><div class="controls bullet"><span class="by">jmb99</span><span>|</span><a href="#40908784">parent</a><span>|</span><a href="#40908460">next</a><span>|</span><label class="collapse" for="c-40910087">[-]</label><label class="expand" for="c-40910087">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t see any reason why we don&#x27;t just use Linux direct instead for everything.<p>Because that would only allow you to boot Linux kernels. One of the benefits of bootloaders is the ability to boot other OSs. You can’t kexec windows.</div><br/><div id="40911331" class="c"><input type="checkbox" id="c-40911331" checked=""/><div class="controls bullet"><span class="by">benstoltz</span><span>|</span><a href="#40908784">root</a><span>|</span><a href="#40910087">parent</a><span>|</span><a href="#40908460">next</a><span>|</span><label class="collapse" for="c-40911331">[-]</label><label class="expand" for="c-40911331">[1 more]</label></div><br/><div class="children"><div class="content">You can kexec Windows: <a href="https:&#x2F;&#x2F;www.platformsecuritysummit.com&#x2F;2019&#x2F;speaker&#x2F;koch&#x2F;PSEC2019-LinuxBoot-Chris-Koch.pdf" rel="nofollow">https:&#x2F;&#x2F;www.platformsecuritysummit.com&#x2F;2019&#x2F;speaker&#x2F;koch&#x2F;PSE...</a></div><br/></div></div></div></div></div></div><div id="40908460" class="c"><input type="checkbox" id="c-40908460" checked=""/><div class="controls bullet"><span class="by">linuxrebe1</span><span>|</span><a href="#40908784">prev</a><span>|</span><a href="#40909380">next</a><span>|</span><label class="collapse" for="c-40908460">[-]</label><label class="expand" for="c-40908460">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious if they&#x27;re proposal will be capable of handling multi-os boots. I know grub can, I can have Linux and windows and possibly even a third OS if I want. I am concerned that red hats solution the well-intended, may be rather myopic, and be commercial only. What I failed to understand, is what problem this solves for systems that I probably only reboot once or twice a year. (Given that it only works with Linux only systems)</div><br/><div id="40908587" class="c"><input type="checkbox" id="c-40908587" checked=""/><div class="controls bullet"><span class="by">FredFS456</span><span>|</span><a href="#40908460">parent</a><span>|</span><a href="#40908616">next</a><span>|</span><label class="collapse" for="c-40908587">[-]</label><label class="expand" for="c-40908587">[1 more]</label></div><br/><div class="children"><div class="content">You can switch OS&#x27;s using the UEFI menu instead. It&#x27;s not always convenient, depending on your UEFI implementation, however.</div><br/></div></div><div id="40908616" class="c"><input type="checkbox" id="c-40908616" checked=""/><div class="controls bullet"><span class="by">ack_complete</span><span>|</span><a href="#40908460">parent</a><span>|</span><a href="#40908587">prev</a><span>|</span><a href="#40909380">next</a><span>|</span><label class="collapse" for="c-40908616">[-]</label><label class="expand" for="c-40908616">[4 more]</label></div><br/><div class="children"><div class="content">Yeah, look at Windows 10 if you want to see how this can be done poorly. Its boot menu works by booting Windows 10 first and then restarting the computer if you choose another OS. This includes going all the way through POST again. Took something like two minutes end-to-end to get to Windows 7.</div><br/><div id="40909193" class="c"><input type="checkbox" id="c-40909193" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#40908460">root</a><span>|</span><a href="#40908616">parent</a><span>|</span><a href="#40909380">next</a><span>|</span><label class="collapse" for="c-40909193">[-]</label><label class="expand" for="c-40909193">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure I experienced the same with the Windows boot loader so maybe that behavior was something case specific instead of intended?</div><br/><div id="40913639" class="c"><input type="checkbox" id="c-40913639" checked=""/><div class="controls bullet"><span class="by">kasabali</span><span>|</span><a href="#40908460">root</a><span>|</span><a href="#40909193">parent</a><span>|</span><a href="#40911997">next</a><span>|</span><label class="collapse" for="c-40913639">[-]</label><label class="expand" for="c-40913639">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the default behavior</div><br/></div></div><div id="40911997" class="c"><input type="checkbox" id="c-40911997" checked=""/><div class="controls bullet"><span class="by">ack_complete</span><span>|</span><a href="#40908460">root</a><span>|</span><a href="#40909193">parent</a><span>|</span><a href="#40913639">prev</a><span>|</span><a href="#40909380">next</a><span>|</span><label class="collapse" for="c-40911997">[-]</label><label class="expand" for="c-40911997">[1 more]</label></div><br/><div class="children"><div class="content">Not sure, there might have been a fast path if you were booting to another Windows 10 install. The old legacy Windows Boot Manager also doesn&#x27;t have the issue since it&#x27;s much simpler and it executes in faux text mode before the OS boots.</div><br/></div></div></div></div></div></div></div></div><div id="40909380" class="c"><input type="checkbox" id="c-40909380" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40908460">prev</a><span>|</span><a href="#40912235">next</a><span>|</span><label class="collapse" for="c-40909380">[-]</label><label class="expand" for="c-40909380">[11 more]</label></div><br/><div class="children"><div class="content">I really like the idea and the approach. I’m a little concerned however about the compatibility issues with kexec. For example, here’s what Arch says about the NVidia module:<p>&gt; The graphics driver needs to be unloaded before a kexec, or the next kernel will not be able to gain exclusive control of the device. This is difficult to achieve manually because any programs which need exclusive control over the GPU (Xorg, display managers) must not be running. Below is an example systemd service that will unload the KMS driver right before kexec, which requires that you use systemctl kexec.<p>It also talks about ACPI issues and there was a question in the presentation although it was unintelligible. More generally, I could imagine more back and forward compat issues that wouldn’t arise from a simpler bootloader that is only initializing a very constrained amount of hardware whereas the kernel will try to boot the full HW twice. I hope they figure out how to make it work, but I suspect they’ll run into pretty significant challenges running this on real “legacy” HW until this is in the ecosystem enough that HW vendors will support it better. A bonus would be that kexec will become better supported and more robust over time if there’s broader adoption.<p>I also wonder if there’s any back&#x2F;forward compat issues kexec between very different kernel versions, but I’m guessing the kexec mechanism was intentionally designed to support that as best as it can.<p><a href="https:&#x2F;&#x2F;wiki.archlinux.org&#x2F;title&#x2F;Kexec" rel="nofollow">https:&#x2F;&#x2F;wiki.archlinux.org&#x2F;title&#x2F;Kexec</a></div><br/><div id="40909501" class="c"><input type="checkbox" id="c-40909501" checked=""/><div class="controls bullet"><span class="by">mjg59</span><span>|</span><a href="#40909380">parent</a><span>|</span><a href="#40912235">next</a><span>|</span><label class="collapse" for="c-40909501">[-]</label><label class="expand" for="c-40909501">[10 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no reason to load things like the nvidia driver if all you want to do is offer a choice to kexec into another kernel, which makes things easier - you can continue just using the display environment the firmware set up.</div><br/><div id="40909594" class="c"><input type="checkbox" id="c-40909594" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#40909380">root</a><span>|</span><a href="#40909501">parent</a><span>|</span><a href="#40911017">next</a><span>|</span><label class="collapse" for="c-40909594">[-]</label><label class="expand" for="c-40909594">[1 more]</label></div><br/><div class="children"><div class="content">This is true on &quot;IBM compatible&quot; x86 PCs and will continue to be for the foreseeable future, but it&#x27;s not the case on all platforms. Some of them require graphics drivers to show anything at all, even simple text.</div><br/></div></div><div id="40911017" class="c"><input type="checkbox" id="c-40911017" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#40909380">root</a><span>|</span><a href="#40909501">parent</a><span>|</span><a href="#40909594">prev</a><span>|</span><a href="#40909528">next</a><span>|</span><label class="collapse" for="c-40911017">[-]</label><label class="expand" for="c-40911017">[1 more]</label></div><br/><div class="children"><div class="content">you bet though that as soon as the grub types are forced into userspace they&#x27;re going to want to do fancy userspace things, like give me a fancy framebuffer driver and the ability to push a shader into the gpu to animate while the second kernel stage boots, etc etc.<p>the more rope given here, the more will be taken, a rich programming environment of a whole kernel will I&#x27;m sure raise temptation to new levels of stuff here, and the natural progression from the shader framebuffer is hand-off to the next kernel stage so it can keep the animation going until wayland starts or whatever. maybe i&#x27;m paranoid.</div><br/></div></div><div id="40909528" class="c"><input type="checkbox" id="c-40909528" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40909380">root</a><span>|</span><a href="#40909501">parent</a><span>|</span><a href="#40911017">prev</a><span>|</span><a href="#40912235">next</a><span>|</span><label class="collapse" for="c-40909528">[-]</label><label class="expand" for="c-40909528">[7 more]</label></div><br/><div class="children"><div class="content">I think you’re missing the broader point I was trying to make by hyperfocusing on 1 example of an issue that can arise from kexec and is solvable in a number of ways. Ultimately the critique raised in the video about focusing on the VM and not trying this on real HW yet is a very real one and is the single hardest problem here I suspect, so punting on it can’t go on for too long.</div><br/><div id="40909585" class="c"><input type="checkbox" id="c-40909585" checked=""/><div class="controls bullet"><span class="by">mjg59</span><span>|</span><a href="#40909380">root</a><span>|</span><a href="#40909528">parent</a><span>|</span><a href="#40912235">next</a><span>|</span><label class="collapse" for="c-40909585">[-]</label><label class="expand" for="c-40909585">[6 more]</label></div><br/><div class="children"><div class="content">My broader point is that the majority of kexec issues are associated with the difficulty in quiescing the hardware, and there&#x27;s simply no need to load the majority of drivers before offering this option which constrains the problem significantly.</div><br/><div id="40909667" class="c"><input type="checkbox" id="c-40909667" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40909380">root</a><span>|</span><a href="#40909585">parent</a><span>|</span><a href="#40912235">next</a><span>|</span><label class="collapse" for="c-40909667">[-]</label><label class="expand" for="c-40909667">[5 more]</label></div><br/><div class="children"><div class="content">Does the kernel actually support doing that? The pitch is that they already have all the pieces and don’t need to do any kernel work to enable this.</div><br/><div id="40912791" class="c"><input type="checkbox" id="c-40912791" checked=""/><div class="controls bullet"><span class="by">ssl-3</span><span>|</span><a href="#40909380">root</a><span>|</span><a href="#40909667">parent</a><span>|</span><a href="#40909694">next</a><span>|</span><label class="collapse" for="c-40912791">[-]</label><label class="expand" for="c-40912791">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m more-or-less just a dumb user in these matters, but I&#x27;ve been using Linux to boot Linux with my semi-elaborate desktop rig because that&#x27;s how ZFSBootMenu[0] do.  Keeping [fairly] quiet about unnecessary hardware (like nVidia drivers) during this bootloader phase seems to be doing the trick for me.<p>Or, at least:  I certainly didn&#x27;t have to do anything to the kernel for it to work.  I&#x27;m just running whatever Void Linux is rolling with right now.<p>[0]: <a href="https:&#x2F;&#x2F;docs.zfsbootmenu.org&#x2F;en&#x2F;v2.3.x&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.zfsbootmenu.org&#x2F;en&#x2F;v2.3.x&#x2F;</a></div><br/></div></div><div id="40909694" class="c"><input type="checkbox" id="c-40909694" checked=""/><div class="controls bullet"><span class="by">mjg59</span><span>|</span><a href="#40909380">root</a><span>|</span><a href="#40909667">parent</a><span>|</span><a href="#40912791">prev</a><span>|</span><a href="#40912235">next</a><span>|</span><label class="collapse" for="c-40909694">[-]</label><label class="expand" for="c-40909694">[3 more]</label></div><br/><div class="children"><div class="content">Module loading is handled by udev, so udev merely needs to support enumerating a subset of the hardware to (eg) ensure input devices are available.</div><br/><div id="40910076" class="c"><input type="checkbox" id="c-40910076" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40909380">root</a><span>|</span><a href="#40909694">parent</a><span>|</span><a href="#40912235">next</a><span>|</span><label class="collapse" for="c-40910076">[-]</label><label class="expand" for="c-40910076">[2 more]</label></div><br/><div class="children"><div class="content">Again, I think you’re thinking I’m saying which I’m not. I’m not saying it’s impossible. I’m suggesting the scope of work may be harder than they pitched which is that they have all the pieces and don’t really need to do much other than some packaging &amp; some EFI integration. UDEV changes and kernel patches (more than the trivial 2 they have right now) would prove that the idea requires more work than anticipated.</div><br/><div id="40910186" class="c"><input type="checkbox" id="c-40910186" checked=""/><div class="controls bullet"><span class="by">mjg59</span><span>|</span><a href="#40909380">root</a><span>|</span><a href="#40910076">parent</a><span>|</span><a href="#40912235">next</a><span>|</span><label class="collapse" for="c-40910186">[-]</label><label class="expand" for="c-40910186">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see any need for kernel patches, and the udev policy is just config rather than code as far as I can tell. Bringing kexec into this is certainly more complicated than not using kexec, but I wouldn&#x27;t expect (and I do have some familiarity of working with kexec) this to be a lot of engineering work.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40912235" class="c"><input type="checkbox" id="c-40912235" checked=""/><div class="controls bullet"><span class="by">gorgoiler</span><span>|</span><a href="#40909380">prev</a><span>|</span><a href="#40913561">next</a><span>|</span><label class="collapse" for="c-40912235">[-]</label><label class="expand" for="c-40912235">[3 more]</label></div><br/><div class="children"><div class="content">It’s a pity we aren’t really there yet with boot loading.  In 2024 if I install an OS it places a boot loader in my EFI System Partition but in a way that still feels only partially complete.<p>What I want is for each OS to install its loader in a unique directory to that OS instance, not unique to the OS vendor.  Multiple Debians etc will argue over who controls &#x2F;debian.  You also have to bless UEFI with magic NVRAM variables when it could just scan my EFI System Partitions for any file named “loader” and present that as a boot option.<p>Perhaps I should just chain from UEFI to something smarter that skips the UEFI-standard and does this smarter thing instead?  Debianised GRUB tries to be smart at update-grub time in order to detect OSs but it would be neater if the loader did it.<p>Edit: In fact I see this is exactly the goal of rEFInd <a href="https:&#x2F;&#x2F;www.rodsbooks.com&#x2F;refind&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.rodsbooks.com&#x2F;refind&#x2F;</a> …in particular it laments how “EFI implementations should provide boot managers [but] are often so poor as to be useless” so it tries to do a better job for you.  I’ll give it a go.</div><br/><div id="40913776" class="c"><input type="checkbox" id="c-40913776" checked=""/><div class="controls bullet"><span class="by">pabs3</span><span>|</span><a href="#40912235">parent</a><span>|</span><a href="#40913415">next</a><span>|</span><label class="collapse" for="c-40913776">[-]</label><label class="expand" for="c-40913776">[1 more]</label></div><br/><div class="children"><div class="content">Theres the removable media path:<p><a href="https:&#x2F;&#x2F;wiki.debian.org&#x2F;UEFI#Booting_from_removable_media" rel="nofollow">https:&#x2F;&#x2F;wiki.debian.org&#x2F;UEFI#Booting_from_removable_media</a>
<a href="https:&#x2F;&#x2F;wiki.debian.org&#x2F;UEFI#Force_grub-efi_installation_to_the_removable_media_path" rel="nofollow">https:&#x2F;&#x2F;wiki.debian.org&#x2F;UEFI#Force_grub-efi_installation_to_...</a></div><br/></div></div><div id="40913415" class="c"><input type="checkbox" id="c-40913415" checked=""/><div class="controls bullet"><span class="by">juped</span><span>|</span><a href="#40912235">parent</a><span>|</span><a href="#40913776">prev</a><span>|</span><a href="#40913561">next</a><span>|</span><label class="collapse" for="c-40913415">[-]</label><label class="expand" for="c-40913415">[1 more]</label></div><br/><div class="children"><div class="content">refind will scan all your partitions for EFI bootable things; if you have two ext4 partitions each with a Debian on them, and each has a Linux kernel in &#x2F;boot, it&#x27;ll locate them both and you can boot either. Which sounds like what you want.</div><br/></div></div></div></div><div id="40913561" class="c"><input type="checkbox" id="c-40913561" checked=""/><div class="controls bullet"><span class="by">eqvinox</span><span>|</span><a href="#40912235">prev</a><span>|</span><a href="#40908791">next</a><span>|</span><label class="collapse" for="c-40913561">[-]</label><label class="expand" for="c-40913561">[1 more]</label></div><br/><div class="children"><div class="content">relevant comments from Hector Martin over on Mastodon at <a href="https:&#x2F;&#x2F;social.treehouse.systems&#x2F;@marcan&#x2F;112754303893998372" rel="nofollow">https:&#x2F;&#x2F;social.treehouse.systems&#x2F;@marcan&#x2F;112754303893998372</a><p>&gt; Reminder that not all platforms support or, indeed, <i>can</i> support kexec() sanely at all. Like ours. kexec() requires the ability to reset all peripheral state and that is <i>impossible</i> on Apple Silicon because firmware is loaded by earlier boot stages and cannot be re-loaded later to the reset state without a full system reboot.</div><br/></div></div><div id="40908791" class="c"><input type="checkbox" id="c-40908791" checked=""/><div class="controls bullet"><span class="by">201984</span><span>|</span><a href="#40913561">prev</a><span>|</span><a href="#40911000">next</a><span>|</span><label class="collapse" for="c-40908791">[-]</label><label class="expand" for="c-40908791">[8 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the point of using this over plain EFISTUB? I use it with Arch, and whenever I want to boot to Windows, I just use the BIOS menu. I don&#x27;t see what benefit a Linux-based bootloader provides.</div><br/><div id="40909680" class="c"><input type="checkbox" id="c-40909680" checked=""/><div class="controls bullet"><span class="by">Delk</span><span>|</span><a href="#40908791">parent</a><span>|</span><a href="#40908959">next</a><span>|</span><label class="collapse" for="c-40909680">[-]</label><label class="expand" for="c-40909680">[1 more]</label></div><br/><div class="children"><div class="content">Entering the BIOS menu takes several seconds on my ThinkPad, and getting to the EFI boot menu from there takes a few more. That&#x27;s after hitting the key during the correct time during the boot process, which sometimes takes guessing.<p>In principle, the EFI multiboot mechanism should be the way to handle basic multiboot options. It would of course be nicer and cleaner from a design perspective not to have redundant mechanisms on top of each other. In practice, though, using the EFI boot menu can be clumsy. The real solution would be for it to not be clumsy but it doesn&#x27;t look like we&#x27;re necessarily there.</div><br/></div></div><div id="40908959" class="c"><input type="checkbox" id="c-40908959" checked=""/><div class="controls bullet"><span class="by">pzmarzly</span><span>|</span><a href="#40908791">parent</a><span>|</span><a href="#40909680">prev</a><span>|</span><a href="#40908852">next</a><span>|</span><label class="collapse" for="c-40908959">[-]</label><label class="expand" for="c-40908959">[4 more]</label></div><br/><div class="children"><div class="content">EFISTUB requires recompiling the kernel every time initramfs, microcode or commandline change, no? That would get annoying pretty quickly on desktop PCs, which are not that fast with recompiling, and would need to do all of this quite often, e.g. on nvidia driver updates.</div><br/><div id="40909024" class="c"><input type="checkbox" id="c-40909024" checked=""/><div class="controls bullet"><span class="by">201984</span><span>|</span><a href="#40908791">root</a><span>|</span><a href="#40908959">parent</a><span>|</span><a href="#40911785">next</a><span>|</span><label class="collapse" for="c-40909024">[-]</label><label class="expand" for="c-40909024">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never once had to recompile the kernel on my laptop for any reason. The kernel command line is set in the bios entry, which is somewhat tedious to change, but that&#x27;s just an efibootmgr command. Initramfs gets rebuilt by pacman on larger updates, but that would happen no matter what bootloader I use.</div><br/><div id="40909138" class="c"><input type="checkbox" id="c-40909138" checked=""/><div class="controls bullet"><span class="by">mjg59</span><span>|</span><a href="#40908791">root</a><span>|</span><a href="#40909024">parent</a><span>|</span><a href="#40911785">next</a><span>|</span><label class="collapse" for="c-40909138">[-]</label><label class="expand" for="c-40909138">[1 more]</label></div><br/><div class="children"><div class="content">Vendor support for the command line coming from the EFI boot entry is of variable quality. If it works for you that&#x27;s great, but unfortunately there&#x27;s a bunch of boards in the wild where it doesn&#x27;t. It&#x27;s not a great solution for general purpose distributions as a result.</div><br/></div></div></div></div><div id="40911785" class="c"><input type="checkbox" id="c-40911785" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#40908791">root</a><span>|</span><a href="#40908959">parent</a><span>|</span><a href="#40909024">prev</a><span>|</span><a href="#40908852">next</a><span>|</span><label class="collapse" for="c-40911785">[-]</label><label class="expand" for="c-40911785">[1 more]</label></div><br/><div class="children"><div class="content">The command line can be part of the UEFI boot entry depending on your particular firmware.<p>I think I can recompile the Linux kernel in around 15 minutes, but I have a 12400F. And 15 minutes is still 60 times longer than most people are willing to wait.</div><br/></div></div></div></div><div id="40908852" class="c"><input type="checkbox" id="c-40908852" checked=""/><div class="controls bullet"><span class="by">_ache_</span><span>|</span><a href="#40908791">parent</a><span>|</span><a href="#40908959">prev</a><span>|</span><a href="#40909149">next</a><span>|</span><label class="collapse" for="c-40908852">[-]</label><label class="expand" for="c-40908852">[1 more]</label></div><br/><div class="children"><div class="content">I do the same. The only advantage I can think of is editing kernel boot option on boot.</div><br/></div></div><div id="40909149" class="c"><input type="checkbox" id="c-40909149" checked=""/><div class="controls bullet"><span class="by">mjg59</span><span>|</span><a href="#40908791">parent</a><span>|</span><a href="#40908852">prev</a><span>|</span><a href="#40911000">next</a><span>|</span><label class="collapse" for="c-40909149">[-]</label><label class="expand" for="c-40909149">[1 more]</label></div><br/><div class="children"><div class="content">UKIs provide mechanisms for adding additional sidecar modules which can extend the initramfs, provide additional command line modifications, and so on.</div><br/></div></div></div></div><div id="40911000" class="c"><input type="checkbox" id="c-40911000" checked=""/><div class="controls bullet"><span class="by">E39M5S62</span><span>|</span><a href="#40908791">prev</a><span>|</span><a href="#40913595">next</a><span>|</span><label class="collapse" for="c-40911000">[-]</label><label class="expand" for="c-40911000">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s nice to see more people embracing the capabilities of UEFI and Linux. ZFSBootMenu has been shipping an EFI application (really, a UKI masquerading as one) for almost four years now - <a href="https:&#x2F;&#x2F;docs.zfsbootmenu.org&#x2F;en&#x2F;v2.3.x&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.zfsbootmenu.org&#x2F;en&#x2F;v2.3.x&#x2F;</a> . The neat part is that the first stage kernel boots in roughly 1.5 to 2 seconds. It&#x27;s not really appreciably slower than other boot methods while at the same time exposing a substantial amount of pre-boot functionality.</div><br/></div></div><div id="40913595" class="c"><input type="checkbox" id="c-40913595" checked=""/><div class="controls bullet"><span class="by">account42</span><span>|</span><a href="#40911000">prev</a><span>|</span><a href="#40910091">next</a><span>|</span><label class="collapse" for="c-40913595">[-]</label><label class="expand" for="c-40913595">[2 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t used GRUB since my first EFI system. The EFI itself is already a bootloader after all, why would you need another one, especially one as bloated as the new GRUB.</div><br/><div id="40913603" class="c"><input type="checkbox" id="c-40913603" checked=""/><div class="controls bullet"><span class="by">itvision</span><span>|</span><a href="#40913595">parent</a><span>|</span><a href="#40910091">next</a><span>|</span><label class="collapse" for="c-40913603">[-]</label><label class="expand" for="c-40913603">[1 more]</label></div><br/><div class="children"><div class="content">To pass kernel parameters? How would you do that without a bootloader?</div><br/></div></div></div></div><div id="40910091" class="c"><input type="checkbox" id="c-40910091" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#40913595">prev</a><span>|</span><a href="#40909571">next</a><span>|</span><label class="collapse" for="c-40910091">[-]</label><label class="expand" for="c-40910091">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve thought about something like this before, but I have so many questions on just the basic premise...<p>First: Linux could <i>already</i> be booted directly from the UEFI manager. You don&#x27;t need GRUB at all. So why a new scheme - why weren&#x27;t they just doing that?<p>Second (and third, etc.): If I have multiple Linux installations along with a Windows installation, wouldn&#x27;t this mean one of them now has to be the one acting as the boot loader? Could it load the other one regardless of what distro it is, without requiring e.g. an extra reboot? And wouldn&#x27;t this mean they would no longer be on equal footing, since one of them would now become the &quot;primary&quot; one when booting? Would its kernel have to be on the UEFI partition...?</div><br/><div id="40910394" class="c"><input type="checkbox" id="c-40910394" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#40910091">parent</a><span>|</span><a href="#40909571">next</a><span>|</span><label class="collapse" for="c-40910394">[-]</label><label class="expand" for="c-40910394">[3 more]</label></div><br/><div class="children"><div class="content">Booting linux directly just boots you into that install. It doesn&#x27;t give you a boot menu or any of the other functionality GRUB provides. This project is basically proposing building that in a small initramfs userland instead (which has the advantage of requiring much less effort and code duplication). It&#x27;s functionally very similar to GRUB, including with regard to your last point: generally speaking at the moment one OS needs to be managing the boot menu, and when they fight over it things go badly (see the status quo where Windows will occasionally just insert itself as the default after an update). UEFI could in principle have fixed this, but the inconsistent implementation between vendors makes it an unreliable option for OS developers.<p>(And in principle this system could load other linux distros assuming there was some co-ordination in how to do so. Windows is more difficult, as is interaction with secure boot)</div><br/><div id="40910450" class="c"><input type="checkbox" id="c-40910450" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#40910091">root</a><span>|</span><a href="#40910394">parent</a><span>|</span><a href="#40909571">next</a><span>|</span><label class="collapse" for="c-40910450">[-]</label><label class="expand" for="c-40910450">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Booting linux directly just boots you into that install. It doesn&#x27;t give you a boot menu or any of the other functionality GRUB provides. This project is basically proposing building that in a small initramfs userland instead<p>I indeed understood that part, but their motivation for this was <i>security</i>. If you want security, you <i>should</i> want to boot directly into the kernel. And if you&#x27;re the occasional user who has multiple OSes installed in parallel... you can just add more kernels from your dual-boot installs directly to the UEFI screen; there&#x27;s really no need to go through any form of intermediate stage, whether kernel-based or boot-loader-based.<p>What I&#x27;m trying to say is: as cool as this is from a technical standpoint, I just don&#x27;t understand the root of the premise or motivation here whose optimal solution is this approach. Whom is RedHat trying to please with this? The small fraction of users who dual-boot Linux, or the rest of the users who just have a single install? And what problem are they actually trying to solve -- security, performance, or something else? Because the optimal solution to the first two doesn&#x27;t feel like this one, unless they&#x27;re targeting a niche use case I&#x27;m not seeing? e.g., do they have lots of enterprise users that boot off a network, but whom would rather have a local Linux install whose <i>sole job</i> is to boot that...?</div><br/><div id="40911027" class="c"><input type="checkbox" id="c-40911027" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#40910091">root</a><span>|</span><a href="#40910450">parent</a><span>|</span><a href="#40909571">next</a><span>|</span><label class="collapse" for="c-40911027">[-]</label><label class="expand" for="c-40911027">[1 more]</label></div><br/><div class="children"><div class="content">They have to cater to a pretty wide set of users, and deal with a wide array of hardware and scenarios. UEFI, especially whatever random implementations of UEFI their users have, can&#x27;t cover all of it. Addressing those needs currently requires something like GRUB (or a customised initramfs, which would be my preferred solution, but it requires more know-how), but GRUB effectively has to duplicate a large subset of the work that the kernel does, and inevitably (if only due to lack of resources), does so poorly, hence their argument that this is good for security: it&#x27;s better than the status quo of GRUB. Indeed, if you have a UEFI firmware and it supports your use case, and it&#x27;s well implemented, then this project is of no extra use (though it seems designed to just get out of the way in that situation and more or less just boot directly), but Red Hat&#x27;s userbase does not entirely consist of people who are in that situation.</div><br/></div></div></div></div></div></div></div></div><div id="40909571" class="c"><input type="checkbox" id="c-40909571" checked=""/><div class="controls bullet"><span class="by">Aissen</span><span>|</span><a href="#40910091">prev</a><span>|</span><a href="#40909022">next</a><span>|</span><label class="collapse" for="c-40909571">[-]</label><label class="expand" for="c-40909571">[1 more]</label></div><br/><div class="children"><div class="content">Considering distros serious about booting are effectively shipping grub forks with tens (debian) to over a hundred (ubuntu) to hundreds (fedora) of patches on top, it might be time to invest a bit more into Open Source early-stage booting. I&#x27;m doubtful that efistub + UKIs will solve all the problems, but I&#x27;m cautiously optimistic. Wait and see!</div><br/></div></div><div id="40909022" class="c"><input type="checkbox" id="c-40909022" checked=""/><div class="controls bullet"><span class="by">cbarrick</span><span>|</span><a href="#40909571">prev</a><span>|</span><a href="#40913599">next</a><span>|</span><label class="collapse" for="c-40909022">[-]</label><label class="expand" for="c-40909022">[1 more]</label></div><br/><div class="children"><div class="content">I developed a tool for managing EFI boot entries for my personal use.<p>I&#x27;ve been meaning to get it ready to release publicly. It&#x27;s mostly there, just a bit manual to install.<p><a href="https:&#x2F;&#x2F;efiboot.cbarrick.dev" rel="nofollow">https:&#x2F;&#x2F;efiboot.cbarrick.dev</a></div><br/></div></div><div id="40913599" class="c"><input type="checkbox" id="c-40913599" checked=""/><div class="controls bullet"><span class="by">itvision</span><span>|</span><a href="#40909022">prev</a><span>|</span><a href="#40909670">next</a><span>|</span><label class="collapse" for="c-40913599">[-]</label><label class="expand" for="c-40913599">[2 more]</label></div><br/><div class="children"><div class="content">Is the motherboard&#x27;s NVRAM supposed to be written to so often?<p>I&#x27;m not sure about that.</div><br/><div id="40913622" class="c"><input type="checkbox" id="c-40913622" checked=""/><div class="controls bullet"><span class="by">eqvinox</span><span>|</span><a href="#40913599">parent</a><span>|</span><a href="#40909670">next</a><span>|</span><label class="collapse" for="c-40913622">[-]</label><label class="expand" for="c-40913622">[1 more]</label></div><br/><div class="children"><div class="content">It originally used to be actual RAM with a battery backup.  These days it&#x27;s generally NOR flash (because it&#x27;s small enough for savings from using NAND to not apply, and the complexity of NAND instead raising the cost).  NOR has quite high write cycle tolerance&#x2F;limits.</div><br/></div></div></div></div><div id="40909670" class="c"><input type="checkbox" id="c-40909670" checked=""/><div class="controls bullet"><span class="by">benstoltz</span><span>|</span><a href="#40913599">prev</a><span>|</span><a href="#40910815">next</a><span>|</span><label class="collapse" for="c-40909670">[-]</label><label class="expand" for="c-40909670">[1 more]</label></div><br/><div class="children"><div class="content">One can trade run-time flexibility for size, speed, and small attack surface.<p>Taken to the limit, Oxide Computer boots using the [Pico Host Boot Loader](<a href="https:&#x2F;&#x2F;github.com&#x2F;oxidecomputer&#x2F;phbl">https:&#x2F;&#x2F;github.com&#x2F;oxidecomputer&#x2F;phbl</a>) which is probably not suitable for your personal system where you would want to boot many OS images from many devices on many different mainboards using very similar or modular boot flash images.<p>Phbl transfers control to a partial Unix image, also in the boot flash, which brings in the rest of the OS from a well-known boot device. There is no UEFI, CoreBoot, PXE boot etc. The AMD PSP code does run, but that&#x27;s the only early external blob in the boot path. This does mean that the OS has to understand its hardware, there is minimal &quot;free&quot; initialization.</div><br/></div></div><div id="40910815" class="c"><input type="checkbox" id="c-40910815" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#40909670">prev</a><span>|</span><a href="#40911723">next</a><span>|</span><label class="collapse" for="c-40910815">[-]</label><label class="expand" for="c-40910815">[4 more]</label></div><br/><div class="children"><div class="content">An EFI stub that sets up multi-boot, kernel and initrd then jumps into it is pretty simple.<p>I don&#x27;t know why people really need to keep putting huge intermediate loaders in every default boot path.<p>If you want to boot more than one OS, yes you need one of these, but if you don&#x27;t then there&#x27;s no need for yet another OS instance in the boot path. The mid-stage should be extremely small and simple.<p>There&#x27;s been so much crying over the size of UEFI, well now there&#x27;s an arbitrarily versioned and maintained entire Linux in there too? Mostly just to avoid some ugly UEFI APIs and a slightly different programming environment? Yuck.</div><br/><div id="40910954" class="c"><input type="checkbox" id="c-40910954" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#40910815">parent</a><span>|</span><a href="#40912190">next</a><span>|</span><label class="collapse" for="c-40910954">[-]</label><label class="expand" for="c-40910954">[2 more]</label></div><br/><div class="children"><div class="content">To state this slightly differently:<p>GRUB has a terrible security story, a key point in the posted presentation. GRUB is huge and has design traps which contribute to regular developer mistakes.<p>Any huge solution here will suffer the same problem, the larger it is the more likely the problem is.<p>You don&#x27;t really need much to do work here, a UEFI program can walk through the directories in the ESP and make choices, and perform assertions, so keep your A&#x2F;B&#x2F;R kernel and ramfs objects in there (as UKIs, as separate files, whatever). It can make a choice and boot the thing.<p>If you want user choice you could put menus into that program too, but you don&#x27;t need them for most users, so leave them out, that&#x27;s a ton of deps gone.<p>A basic program to do this isn&#x27;t more than 1000 lines, it&#x27;ll be low on maintenance and exceptionally low on critical flaws.<p>It&#x27;s not hard writing even fairly complex things for EFI, here&#x27;s Fuchsia&#x27;s UEFI stage which is designed for development and has far more features (fastboot, mdns discovery, etc) than most of these things need. It&#x27;s still tiny compared to the grub stuff: <a href="https:&#x2F;&#x2F;fuchsia.googlesource.com&#x2F;fuchsia&#x2F;+&#x2F;refs&#x2F;heads&#x2F;main&#x2F;src&#x2F;firmware&#x2F;gigaboot&#x2F;" rel="nofollow">https:&#x2F;&#x2F;fuchsia.googlesource.com&#x2F;fuchsia&#x2F;+&#x2F;refs&#x2F;heads&#x2F;main&#x2F;s...</a></div><br/><div id="40911739" class="c"><input type="checkbox" id="c-40911739" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#40910815">root</a><span>|</span><a href="#40910954">parent</a><span>|</span><a href="#40912190">next</a><span>|</span><label class="collapse" for="c-40911739">[-]</label><label class="expand" for="c-40911739">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d say grub is crap, let&#x27;s switch to das u-boot, which is not.</div><br/></div></div></div></div><div id="40912190" class="c"><input type="checkbox" id="c-40912190" checked=""/><div class="controls bullet"><span class="by">juped</span><span>|</span><a href="#40910815">parent</a><span>|</span><a href="#40910954">prev</a><span>|</span><a href="#40911723">next</a><span>|</span><label class="collapse" for="c-40912190">[-]</label><label class="expand" for="c-40912190">[1 more]</label></div><br/><div class="children"><div class="content">&gt;If you want to boot more than one OS, yes you need one of these<p>Nope, you only need refind (a fancy menu, not a bootloader at all), and only then because of how impoverished the vendor&#x27;s boot menu always is; if your configuration is simple enough you could just use that despite it sucking.</div><br/></div></div></div></div><div id="40911723" class="c"><input type="checkbox" id="c-40911723" checked=""/><div class="controls bullet"><span class="by">joveian</span><span>|</span><a href="#40910815">prev</a><span>|</span><a href="#40912388">next</a><span>|</span><label class="collapse" for="c-40911723">[-]</label><label class="expand" for="c-40911723">[1 more]</label></div><br/><div class="children"><div class="content">This link that has been posted a couple of times is a much better source for those of us who aren&#x27;t going to watch a video:<p><a href="https:&#x2F;&#x2F;fizuxchyk.wordpress.com&#x2F;2024&#x2F;06&#x2F;13&#x2F;nmbl-we-dont-need-a-bootloader&#x2F;" rel="nofollow">https:&#x2F;&#x2F;fizuxchyk.wordpress.com&#x2F;2024&#x2F;06&#x2F;13&#x2F;nmbl-we-dont-need...</a></div><br/></div></div><div id="40912388" class="c"><input type="checkbox" id="c-40912388" checked=""/><div class="controls bullet"><span class="by">egberts1</span><span>|</span><a href="#40911723">prev</a><span>|</span><a href="#40912143">next</a><span>|</span><label class="collapse" for="c-40912388">[-]</label><label class="expand" for="c-40912388">[6 more]</label></div><br/><div class="children"><div class="content">I prefer my bootloader (be that it may, GRUB, lilo, or even BusyBox) because thosr image will go away once the kernel is started.<p>Nothing for hacker to see and analyze the bootloader, assuming you did not load a driver to the NVRAM&#x2F;Flash&#x2F;UEFI&#x2F;EFI.<p>Nice security compartment alization.<p>Redhat is smothering this easential security abstraction of 1st stage loader: not a good security model.</div><br/><div id="40912431" class="c"><input type="checkbox" id="c-40912431" checked=""/><div class="controls bullet"><span class="by">TheDong</span><span>|</span><a href="#40912388">parent</a><span>|</span><a href="#40912443">next</a><span>|</span><label class="collapse" for="c-40912431">[-]</label><label class="expand" for="c-40912431">[4 more]</label></div><br/><div class="children"><div class="content">Can you explain more what security vector you&#x27;re talking about here, because I just don&#x27;t see it?<p>Like, as far as I can tell, grub or whatever is a bundle of filesystem and device drivers, with enough info to then execute a kernel.<p>Linux also is a bundle of filesystem and device drivers, but better tested ones I think.<p>To me, it seems like using the kernel&#x27;s filesystem drivers, which you have to use already anyway once you&#x27;ve booted, means you have to trust fewer total implementations of these drivers, so it seems more secure.<p>What attack or threat vector are you trying to talk about here?</div><br/><div id="40913091" class="c"><input type="checkbox" id="c-40913091" checked=""/><div class="controls bullet"><span class="by">egberts1</span><span>|</span><a href="#40912388">root</a><span>|</span><a href="#40912431">parent</a><span>|</span><a href="#40912443">next</a><span>|</span><label class="collapse" for="c-40913091">[-]</label><label class="expand" for="c-40913091">[3 more]</label></div><br/><div class="children"><div class="content">It is the same security abstraction where you don’t allow support for network socket in process ID 1.<p>(Looking at you, systemd.)<p>You don’t allow access to the bootloader from any kernel, thereby afford a relative security in starting 2nd stage (kernels). One abstraction is that TPM, et. al., can lockstep assurances on each stage. At a minimum, you have a bootloader, in case of SNAFU&#x2F;FOOBAR.<p>Bricking (or worse, malicious kernel) seems more a possibility with upcoming Redhat design.</div><br/><div id="40913346" class="c"><input type="checkbox" id="c-40913346" checked=""/><div class="controls bullet"><span class="by">TheDong</span><span>|</span><a href="#40912388">root</a><span>|</span><a href="#40913091">parent</a><span>|</span><a href="#40912443">next</a><span>|</span><label class="collapse" for="c-40913346">[-]</label><label class="expand" for="c-40913346">[2 more]</label></div><br/><div class="children"><div class="content">Sorry, I still don&#x27;t follow.<p>&gt; You don’t allow access to the bootloader from any kernel, thereby afford a relative security in starting 2nd stage<p>You install and update the bootloader and its configuration from your running linux system.<p>In this new world, you would also update the kernel from your running linux system. That&#x27;s the same, right? To update the kernel, you need to update bootloader configuration anyway, so it&#x27;s obviously required that the running system can at least update the kernel, and that&#x27;s true either way.<p>&gt; Bricking (or worse, malicious kernel) seems more a possibility with upcoming Redhat design.<p>If your kernel is malicious, it&#x27;s game over whether or not you&#x27;re using grub, right? Like, that doesn&#x27;t seem like a new threat model.<p>I don&#x27;t really care about bricking because, frankly, I&#x27;ve made my system unbootable via grub bugs more often than I have through kernel bugs, and the kernel developers seem to take these bugs more seriously, so I feel like bricking is a possibility with either design, but less likely without grub.<p>Either way, I need to have a liveusb off to the side to fix these issues.</div><br/><div id="40913497" class="c"><input type="checkbox" id="c-40913497" checked=""/><div class="controls bullet"><span class="by">egberts1</span><span>|</span><a href="#40912388">root</a><span>|</span><a href="#40913346">parent</a><span>|</span><a href="#40912443">next</a><span>|</span><label class="collapse" for="c-40913497">[-]</label><label class="expand" for="c-40913497">[1 more]</label></div><br/><div class="children"><div class="content">&#x2F;boot should never be mounted.</div><br/></div></div></div></div></div></div></div></div><div id="40912443" class="c"><input type="checkbox" id="c-40912443" checked=""/><div class="controls bullet"><span class="by">cool_beanz</span><span>|</span><a href="#40912388">parent</a><span>|</span><a href="#40912431">prev</a><span>|</span><a href="#40912143">next</a><span>|</span><label class="collapse" for="c-40912443">[-]</label><label class="expand" for="c-40912443">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s kernel command line parameters that can clean it up without a bootloader.</div><br/></div></div></div></div><div id="40912143" class="c"><input type="checkbox" id="c-40912143" checked=""/><div class="controls bullet"><span class="by">pmorici</span><span>|</span><a href="#40912388">prev</a><span>|</span><a href="#40913594">next</a><span>|</span><label class="collapse" for="c-40912143">[-]</label><label class="expand" for="c-40912143">[1 more]</label></div><br/><div class="children"><div class="content">Does anyone have any tips for debugging EFI_STUB kernels when they fail to boot?  I&#x27;ve run into BIOS before that I can&#x27;t get EFI_STUB to work on but grub works fine and I&#x27;m not sure why or even how to go about getting any debug info since the bios&#x2F;firmware is a block box.  Is the only option to get in touch for the motherboard vendor and how they care to look into it?  It&#x27;s rare but happens.</div><br/></div></div><div id="40913594" class="c"><input type="checkbox" id="c-40913594" checked=""/><div class="controls bullet"><span class="by">ale42</span><span>|</span><a href="#40912143">prev</a><span>|</span><a href="#40912145">next</a><span>|</span><label class="collapse" for="c-40913594">[-]</label><label class="expand" for="c-40913594">[1 more]</label></div><br/><div class="children"><div class="content">See also this project: <a href="https:&#x2F;&#x2F;github.com&#x2F;zhovner&#x2F;OneFileLinux">https:&#x2F;&#x2F;github.com&#x2F;zhovner&#x2F;OneFileLinux</a><p>Not a bootloader, but a single-file, very light Linux image that can be loaded directly as an .EFI file. Not useful as an actual OS for daily use, but can have specialized uses (I used it to network boot a whole room of PCs to a Linux showing a slideshow on the framebuffer).</div><br/></div></div><div id="40912145" class="c"><input type="checkbox" id="c-40912145" checked=""/><div class="controls bullet"><span class="by">mmphosis</span><span>|</span><a href="#40913594">prev</a><span>|</span><a href="#40910537">next</a><span>|</span><label class="collapse" for="c-40912145">[-]</label><label class="expand" for="c-40912145">[2 more]</label></div><br/><div class="children"><div class="content">A removable physical key: a programmable ROM.<p>I have programmed the ROM to instantaneously copy my ROM to RAM and run. The entire system is running instantly as soon as I power on. There is absolutely nothing else.<p>Because everything else is a big mess:<p><i>Intel ME</i>, BIOS, UEFI, <i>kernels are signed by companies with Microsoft&#x27;s blessing</i>, EFI, FAT, TPM, anything with the word &quot;Secure&quot; in it, ...</div><br/><div id="40912725" class="c"><input type="checkbox" id="c-40912725" checked=""/><div class="controls bullet"><span class="by">katzenversteher</span><span>|</span><a href="#40912145">parent</a><span>|</span><a href="#40910537">next</a><span>|</span><label class="collapse" for="c-40912725">[-]</label><label class="expand" for="c-40912725">[1 more]</label></div><br/><div class="children"><div class="content">Please elaborate. What kind of key are you using? What are you booting? On which architecture &#x2F; machine?</div><br/></div></div></div></div><div id="40910537" class="c"><input type="checkbox" id="c-40910537" checked=""/><div class="controls bullet"><span class="by">JoeAltmaier</span><span>|</span><a href="#40912145">prev</a><span>|</span><a href="#40910532">next</a><span>|</span><label class="collapse" for="c-40910537">[-]</label><label class="expand" for="c-40910537">[2 more]</label></div><br/><div class="children"><div class="content">Not sure why loaders are a separate beast any more.<p>In the bad old days, ROMs had very limited space. Lots of bootloader packages got invented, tiny things that knew just enough about ROM and the filesystem to get the &#x27;real&#x27; code loaded, maybe un-zipped, maybe unencrypted. Later, some network-boot options which were handy.<p>Today? The boot flash is huge (compared to ROMs). You can put an entire OS in there! In fact, nowadays the bootloader is often a flash partition right next to other OS images.<p>I assert, there&#x27;s nothing that a bootloader can do that an entire OS e.g. Linux image can&#x27;t do. Just build a linux image, put a boot-script in there to allow network-boot or reboot-from-another-partition. And be done with it - no more u-boot, no more obscure bootloaders with limited drivers and options.<p>The day of the bootloader is over.</div><br/><div id="40910791" class="c"><input type="checkbox" id="c-40910791" checked=""/><div class="controls bullet"><span class="by">nickelpro</span><span>|</span><a href="#40910537">parent</a><span>|</span><a href="#40910532">next</a><span>|</span><label class="collapse" for="c-40910791">[-]</label><label class="expand" for="c-40910791">[1 more]</label></div><br/><div class="children"><div class="content">The reason is very simple, you only get to call ExitBootServices() once (absent hacks that hook the function).<p>If you want to be able to do anything prior to calling ExitBootServices(), such as choose what EFI application you want to use and options you want to pass it, you need a service built to provide you that interface which itself does not call ExitBootServices().<p>The name of that service is the bootloader.</div><br/></div></div></div></div><div id="40910532" class="c"><input type="checkbox" id="c-40910532" checked=""/><div class="controls bullet"><span class="by">hackernudes</span><span>|</span><a href="#40910537">prev</a><span>|</span><a href="#40912677">next</a><span>|</span><label class="collapse" for="c-40910532">[-]</label><label class="expand" for="c-40910532">[1 more]</label></div><br/><div class="children"><div class="content">In the &quot;what do we have so far?&quot; slide they explain there are currently two variants of NMBL, one that does a switch_root (like a normal initramfs) and one that does kexec (to boot into a new kernel). It presents a menu for the user to select what to boot. It also will allow rolling back to the old version when boot fails.<p>I see some other comments in this thread about hypothetically supporting booting other UEFI targets and some ideas on how that would be implemented.<p>There is a question in the video about chainloading around 27 minutes -- <a href="https:&#x2F;&#x2F;youtu.be&#x2F;ywrSDLp926M?t=1640" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;ywrSDLp926M?t=1640</a> but the answer isn&#x27;t clear to me - &quot;setting FE variables&quot;. Is that frontend? firmware environment?</div><br/></div></div><div id="40912677" class="c"><input type="checkbox" id="c-40912677" checked=""/><div class="controls bullet"><span class="by">retrochameleon</span><span>|</span><a href="#40910532">prev</a><span>|</span><a href="#40910526">next</a><span>|</span><label class="collapse" for="c-40912677">[-]</label><label class="expand" for="c-40912677">[1 more]</label></div><br/><div class="children"><div class="content">I use zfsbootmenu. It allows me to boot multiple OSes from different data sets, make and rollback snapshots, and even directly boot from a snapshot. It also has a minimal shell for zfs tasks.</div><br/></div></div><div id="40910526" class="c"><input type="checkbox" id="c-40910526" checked=""/><div class="controls bullet"><span class="by">kevinoid</span><span>|</span><a href="#40912677">prev</a><span>|</span><a href="#40912688">next</a><span>|</span><label class="collapse" for="c-40910526">[-]</label><label class="expand" for="c-40910526">[2 more]</label></div><br/><div class="children"><div class="content">This approach sounds similar to Petitboot &lt;<a href="http:&#x2F;&#x2F;www.kernel.org&#x2F;pub&#x2F;linux&#x2F;kernel&#x2F;people&#x2F;geoff&#x2F;petitboot&#x2F;petitboot.html" rel="nofollow">http:&#x2F;&#x2F;www.kernel.org&#x2F;pub&#x2F;linux&#x2F;kernel&#x2F;people&#x2F;geoff&#x2F;petitboo...</a>&gt; which is a kexec-based bootloader that I used on the Playstation 3 many years ago.  Apparently it now targets many other systems and there is a (dead?) fork for Coreboot &lt;<a href="https:&#x2F;&#x2F;github.com&#x2F;ArthurHeymans&#x2F;petitboot_for_coreboot">https:&#x2F;&#x2F;github.com&#x2F;ArthurHeymans&#x2F;petitboot_for_coreboot</a>&gt;.</div><br/><div id="40910546" class="c"><input type="checkbox" id="c-40910546" checked=""/><div class="controls bullet"><span class="by">hackernudes</span><span>|</span><a href="#40910526">parent</a><span>|</span><a href="#40912688">next</a><span>|</span><label class="collapse" for="c-40910546">[-]</label><label class="expand" for="c-40910546">[1 more]</label></div><br/><div class="children"><div class="content">The Q&amp;A mentions this[1] and says Petitboot requires two kernels (one minimal one + one normal one). NMBL just uses one single kernel for both steps.<p>[1] around 23m20s <a href="https:&#x2F;&#x2F;youtu.be&#x2F;ywrSDLp926M?t=1400" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;ywrSDLp926M?t=1400</a></div><br/></div></div></div></div><div id="40912688" class="c"><input type="checkbox" id="c-40912688" checked=""/><div class="controls bullet"><span class="by">bfung</span><span>|</span><a href="#40910526">prev</a><span>|</span><a href="#40908488">next</a><span>|</span><label class="collapse" for="c-40912688">[-]</label><label class="expand" for="c-40912688">[1 more]</label></div><br/><div class="children"><div class="content">Yo Dawg, I herd you like bootloaders, so I put a bootloader in your kernel so you can boot w&#x2F;a kernel while you boot a kernel.</div><br/></div></div><div id="40908488" class="c"><input type="checkbox" id="c-40908488" checked=""/><div class="controls bullet"><span class="by">Shorel</span><span>|</span><a href="#40912688">prev</a><span>|</span><label class="collapse" for="c-40908488">[-]</label><label class="expand" for="c-40908488">[2 more]</label></div><br/><div class="children"><div class="content">Kudos to the developers involved in this functionality.<p>Faster boot times and more secure installations are always advantageous. I&#x27;m all rooting for this development.<p>I&#x27;ve been wondering for a while why grub is still used, given that its basic architecture is outdated.</div><br/><div id="40908840" class="c"><input type="checkbox" id="c-40908840" checked=""/><div class="controls bullet"><span class="by">shadowgovt</span><span>|</span><a href="#40908488">parent</a><span>|</span><label class="collapse" for="c-40908840">[-]</label><label class="expand" for="c-40908840">[1 more]</label></div><br/><div class="children"><div class="content">I believe the two main reasons are<p>- inertia (don&#x27;t rewrite something if it works; who <i>really</i> wants to own responsibility for testing this thing on all architectures GRUB currently supports?)<p>- multi-OS boot scenarios (I assume this new system will support that, but (a) I don&#x27;t know for sure and (b) I don&#x27;t <i>really</i> want to boot all the way into Linux just to throw Linux away and boot something else...)</div><br/></div></div></div></div></div></div></div></div></div></body></html>