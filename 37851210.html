<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1697101265565" as="style"/><link rel="stylesheet" href="styles.css?v=1697101265565"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/microsoft/snmalloc">Snmalloc: A Message Passing Allocator</a>Â <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>akyuu</span> | <span>21 comments</span></div><br/><div><div id="37854011" class="c"><input type="checkbox" id="c-37854011" checked=""/><div class="controls bullet"><span class="by">sakras</span><span>|</span><a href="#37852323">next</a><span>|</span><label class="collapse" for="c-37854011">[-]</label><label class="expand" for="c-37854011">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m messing around with implementing a parallel runtime system right now^, and I also had to implement a shared-nothing allocator. I ended up making each thread have a Chase-Lev Deque of 2MB pages. If you want to allocate a page, you do the usual pop-or-try-to-steal thing, and if that doesn&#x27;t work, THEN you do the mmap to get another 2MB page. I was going to benchmark it and write a post about it, but I never got around to it. Glad shared-nothing allocation seems to be a problem worth solving.<p>^ actually it&#x27;s basically implemented. I model-checked it with TLA+ and found a bug that I haven&#x27;t fixed yet. Next up I&#x27;m writing a query engine on it.</div><br/><div id="37854879" class="c"><input type="checkbox" id="c-37854879" checked=""/><div class="controls bullet"><span class="by">yvdriess</span><span>|</span><a href="#37854011">parent</a><span>|</span><a href="#37854223">next</a><span>|</span><label class="collapse" for="c-37854879">[-]</label><label class="expand" for="c-37854879">[1 more]</label></div><br/><div class="children"><div class="content">FYI Cray developed an interesting allocator for scaling to a massive amount of threads <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;1122971.1122999" rel="nofollow noreferrer">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;1122971.1122999</a></div><br/></div></div><div id="37854223" class="c"><input type="checkbox" id="c-37854223" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#37854011">parent</a><span>|</span><a href="#37854879">prev</a><span>|</span><a href="#37852323">next</a><span>|</span><label class="collapse" for="c-37854223">[-]</label><label class="expand" for="c-37854223">[1 more]</label></div><br/><div class="children"><div class="content">This is very interesting!<p>I am especially interested in how you share memory between threads in your parallel runtime - what thread safety approach do you use?<p>I&#x27;ve been thinking about static memory as permanent regions that are permanent fixtures and the program flows through them and there must be backpressure when buffers get full.<p>I just wrote a nonblocking multithreaded barrier with a lock free algorithm.</div><br/></div></div></div></div><div id="37852323" class="c"><input type="checkbox" id="c-37852323" checked=""/><div class="controls bullet"><span class="by">chrisaycock</span><span>|</span><a href="#37854011">prev</a><span>|</span><a href="#37852019">next</a><span>|</span><label class="collapse" for="c-37852323">[-]</label><label class="expand" for="c-37852323">[2 more]</label></div><br/><div class="children"><div class="content">According to this FAQ, snmalloc was designed for the Verona language:<p><a href="https:&#x2F;&#x2F;microsoft.github.io&#x2F;verona&#x2F;faq.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;microsoft.github.io&#x2F;verona&#x2F;faq.html</a><p>Unfortunately, I cannot find any significant code samples for Verona on the website or in the GitHub repo. There are a few types defined in a pretty low-level way:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;verona&#x2F;tree&#x2F;master&#x2F;std&#x2F;builtin">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;verona&#x2F;tree&#x2F;master&#x2F;std&#x2F;builtin</a></div><br/><div id="37853837" class="c"><input type="checkbox" id="c-37853837" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#37852323">parent</a><span>|</span><a href="#37852019">next</a><span>|</span><label class="collapse" for="c-37853837">[-]</label><label class="expand" for="c-37853837">[1 more]</label></div><br/><div class="children"><div class="content">Wikipedia has a code sample, no idea where it came from.</div><br/></div></div></div></div><div id="37852019" class="c"><input type="checkbox" id="c-37852019" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#37852323">prev</a><span>|</span><a href="#37852067">next</a><span>|</span><label class="collapse" for="c-37852019">[-]</label><label class="expand" for="c-37852019">[7 more]</label></div><br/><div class="children"><div class="content">The real question is: how does this deal with freeing allocations from a thread that <i>exited</i>?<p>The implications of thread lifetime seems to be one of the biggest differences between existing allocators.</div><br/><div id="37854454" class="c"><input type="checkbox" id="c-37854454" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37852019">parent</a><span>|</span><a href="#37852569">next</a><span>|</span><label class="collapse" for="c-37854454">[-]</label><label class="expand" for="c-37854454">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The real question is: how does this deal with freeing allocations from a thread that exited?<p>I assume that they don&#x27;t release the allocator assigned to a thread when a thread exits, unless that allocator is holding a list of zero allocations.<p>That sounds like the easiest part of all of this, TBH: A <i>single</i> extra line of code that, after performing an actual deallocation (as opposed to sending a message to perform the deallocation), the allocator checks that it has non-zero allocations, and that the thread still exists, otherwise it deletes itself.</div><br/></div></div><div id="37852569" class="c"><input type="checkbox" id="c-37852569" checked=""/><div class="controls bullet"><span class="by">gavinhoward</span><span>|</span><a href="#37852019">parent</a><span>|</span><a href="#37854454">prev</a><span>|</span><a href="#37852921">next</a><span>|</span><label class="collapse" for="c-37852569">[-]</label><label class="expand" for="c-37852569">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not a contributor to snmalloc or affiliated in any way.<p>I&#x27;m going to reimplement snmalloc in C for my own code.<p>I&#x27;m going to avoid that problem by using structured concurrency. Under my system, threads only get data from threads that are ancestors. (There will be a way of getting data from a non-ancestor, but it will effectively keep the allocating thread alive until the using thread is done.)<p>The reason I&#x27;m going to use snmalloc is <i>because</i> of structured concurrency; it&#x27;s like it was <i>designed</i> for structured concurrency.</div><br/></div></div><div id="37852921" class="c"><input type="checkbox" id="c-37852921" checked=""/><div class="controls bullet"><span class="by">netcoyote</span><span>|</span><a href="#37852019">parent</a><span>|</span><a href="#37852569">prev</a><span>|</span><a href="#37852067">next</a><span>|</span><label class="collapse" for="c-37852921">[-]</label><label class="expand" for="c-37852921">[4 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t all thread implementations leak unfreed memory when a thread exits?<p>I mean, how would the thread know that the memory needs to be freed? It cannot know that the application hasn&#x27;t ROT13 encoded the pointer, passed it to another thread, and that thread plans to use the memory.</div><br/><div id="37854416" class="c"><input type="checkbox" id="c-37854416" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37852019">root</a><span>|</span><a href="#37852921">parent</a><span>|</span><a href="#37852969">next</a><span>|</span><label class="collapse" for="c-37854416">[-]</label><label class="expand" for="c-37854416">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Don&#x27;t all thread implementations leak unfreed memory when a thread exits?<p>I&#x27;m a bit slow this morning - I don&#x27;t understand what this is supposed to mean.<p>To me, it&#x27;s like saying <i>&quot;don&#x27;t all functions leak unfreed memory when a function returns&quot;</i> - it&#x27;s true, but so what? It&#x27;s always been true.<p>&gt; I mean, how would the thread know that the memory needs to be freed? It cannot know that the application hasn&#x27;t ROT13 encoded the pointer, passed it to another thread, and that thread plans to use the memory.<p>As I understand it, they are using multiple allocators (maybe 1 allocator per thread?), and they store metadata (such as ownership information of the allocated block) during the allocation.<p>With 1 allocator per thread, each allocation by an allocator maps to a single thread. When a block is to be freed, the allocator for the thread checks the ownership information, and if it is not the owner of that block, sends a request to the thread that <i>is</i> the owner of that block.<p>This means that even if the thread allocated a block, and let it get used by multiple other threads, they can all call `free` on that block, and the original thread will simply get all the free requests (I assume it will ignore requests for freeing blocks that are already freed).<p>It all depends on extra metadata stored during allocation, that describes the ownership information of that block.<p>(Happy to be corrected about any&#x2F;all of the above)</div><br/></div></div><div id="37852969" class="c"><input type="checkbox" id="c-37852969" checked=""/><div class="controls bullet"><span class="by">lights0123</span><span>|</span><a href="#37852019">root</a><span>|</span><a href="#37852921">parent</a><span>|</span><a href="#37854416">prev</a><span>|</span><a href="#37853847">next</a><span>|</span><label class="collapse" for="c-37852969">[-]</label><label class="expand" for="c-37852969">[1 more]</label></div><br/><div class="children"><div class="content">The memory could be freed from another thread with a classical allocatorâbut this one passes it back to the allocating thread, leaving the question <i>what happens to it</i>?</div><br/></div></div></div></div></div></div><div id="37851792" class="c"><input type="checkbox" id="c-37851792" checked=""/><div class="controls bullet"><span class="by">alberth</span><span>|</span><a href="#37852067">prev</a><span>|</span><a href="#37851864">next</a><span>|</span><label class="collapse" for="c-37851792">[-]</label><label class="expand" for="c-37851792">[1 more]</label></div><br/><div class="children"><div class="content">Iâve always wondered if DragonflyBSD would uniquely benefit from snmalloc, given that itâs a message-passing based kernel.</div><br/></div></div><div id="37851864" class="c"><input type="checkbox" id="c-37851864" checked=""/><div class="controls bullet"><span class="by">ridiculous_fish</span><span>|</span><a href="#37851792">prev</a><span>|</span><a href="#37851700">next</a><span>|</span><label class="collapse" for="c-37851864">[-]</label><label class="expand" for="c-37851864">[3 more]</label></div><br/><div class="children"><div class="content">There&#x27;s lots more details about the design in this PDF: <a href="https:&#x2F;&#x2F;alex.shamis.au&#x2F;files&#x2F;snmalloc-A-Message-Passing-Allocator.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;alex.shamis.au&#x2F;files&#x2F;snmalloc-A-Message-Passing-Allo...</a></div><br/><div id="37852388" class="c"><input type="checkbox" id="c-37852388" checked=""/><div class="controls bullet"><span class="by">Varriount</span><span>|</span><a href="#37851864">parent</a><span>|</span><a href="#37851700">next</a><span>|</span><label class="collapse" for="c-37852388">[-]</label><label class="expand" for="c-37852388">[2 more]</label></div><br/><div class="children"><div class="content">I found this design decision rather odd:<p><pre><code>  Allocators may send messages to any other allocator. In a naÃ¯ve implementation each allocator would keep a queue of batched messages for each other allocator. The number of queues would then either be the dynamically known number of existing threads, or the statically known maximal number of possible threads. The former would require allocation of a dynamically sized structure when handling remote deallocation and slow enqueueing, while the latter would lead to significant wasted space and hard-coded limits. Instead, we adapted ideas from radix trees. Allocators keep a fixed 2k size array of buckets of pending messages, where k in our implementation is 6. Batched messages are inserted into the bucket which corresponds to their destinationâs address, modulo the number of buckets. Dispatch of messages takes place by sending all the messages from the same bucket to one allocator, which then responds to those messages for which it is the final destination, and forwards the rest, again according to their destination allocator address, but now shifted right by k bits.
</code></pre>
I would think that the overhead of message passing would mean that minimization of the number of messages sent. I wonder how well this technique scales.</div><br/><div id="37854055" class="c"><input type="checkbox" id="c-37854055" checked=""/><div class="controls bullet"><span class="by">jlebar</span><span>|</span><a href="#37851864">root</a><span>|</span><a href="#37852388">parent</a><span>|</span><a href="#37851700">next</a><span>|</span><label class="collapse" for="c-37854055">[-]</label><label class="expand" for="c-37854055">[1 more]</label></div><br/><div class="children"><div class="content">Reminds me of this network routing technique: Send a packet to a random node, and then have that node forward it to its final destination.<p>Sounds dumb but actually it&#x27;s useful sometimes?  I dunno, IANA networking person.<p>A Scheme for Fast Parallel Communication <a href="https:&#x2F;&#x2F;ldhulipala.github.io&#x2F;readings&#x2F;ValiantPermutationRouting.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;ldhulipala.github.io&#x2F;readings&#x2F;ValiantPermutationRout...</a></div><br/></div></div></div></div></div></div><div id="37851700" class="c"><input type="checkbox" id="c-37851700" checked=""/><div class="controls bullet"><span class="by">Snawoot</span><span>|</span><a href="#37851864">prev</a><span>|</span><label class="collapse" for="c-37851700">[-]</label><label class="expand" for="c-37851700">[3 more]</label></div><br/><div class="children"><div class="content">Are there any benchmarks?</div><br/><div id="37851721" class="c"><input type="checkbox" id="c-37851721" checked=""/><div class="controls bullet"><span class="by">akyuu</span><span>|</span><a href="#37851700">parent</a><span>|</span><label class="collapse" for="c-37851721">[-]</label><label class="expand" for="c-37851721">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;snmalloc&#x2F;blob&#x2F;main&#x2F;docs&#x2F;security&#x2F;README.md">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;snmalloc&#x2F;blob&#x2F;main&#x2F;docs&#x2F;securit...</a></div><br/><div id="37853811" class="c"><input type="checkbox" id="c-37853811" checked=""/><div class="controls bullet"><span class="by">jcrites</span><span>|</span><a href="#37851700">root</a><span>|</span><a href="#37851721">parent</a><span>|</span><label class="collapse" for="c-37853811">[-]</label><label class="expand" for="c-37853811">[1 more]</label></div><br/><div class="children"><div class="content">While reviewing that doc, I also came across this. Seems very interesting -- I did not know this was possible:<p>&gt; Some architectures, such as CHERI (including Arm&#x27;s Morello), explicitly consider pointer provenance and bounds in addition to their target addresses. Adding these considerations to the architecture enables software to constrain uses of particular pointers in ways that are not available with traditional protection mechanisms. For example, while code may have a pointer that spans its entire C stack, it may construct a pointer that authorizes access only to a particular stack allocation (e.g., a buffer) and use this latter pointer while copying data. Even if an attacker is able to control the length of the copy, the bounds imposed upon pointers involved can ensure that an overflow is impossible. (On the other hand, if the attacker can influence both the bounds and the copy length, an overflow may still be possible; in practice, however, the two concerns are often sufficiently separated.) For malloc() in particular, it is enormously beneficial to be able to impose bounds on returned pointers: it becomes impossible for allocator clients to use a pointer from malloc() to access adjacent allocations!<p><a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;snmalloc&#x2F;blob&#x2F;main&#x2F;docs&#x2F;StrictProvenance.md">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;snmalloc&#x2F;blob&#x2F;main&#x2F;docs&#x2F;StrictP...</a><p>I wonder to what extent moving bounds checks into hardware provides the potential for efficient memory safety.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>