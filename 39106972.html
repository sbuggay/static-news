<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1706086859910" as="style"/><link rel="stylesheet" href="styles.css?v=1706086859910"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://sourcegraph.com/blog/slow-to-simd">From slow to SIMD: A Go optimization story</a>Â <span class="domain">(<a href="https://sourcegraph.com">sourcegraph.com</a>)</span></div><div class="subtext"><span>rbanffy</span> | <span>93 comments</span></div><br/><div><div id="39114787" class="c"><input type="checkbox" id="c-39114787" checked=""/><div class="controls bullet"><span class="by">devjam</span><span>|</span><a href="#39110594">next</a><span>|</span><label class="collapse" for="c-39114787">[-]</label><label class="expand" for="c-39114787">[2 more]</label></div><br/><div class="children"><div class="content">The author used:<p><pre><code>    sum := float32(0)
</code></pre>
Over Go&#x27;s zero-value default initialization e.g.<p><pre><code>    var sum float32
</code></pre>
A nit stylistically but wondering if there was a good reason to do so?</div><br/><div id="39114829" class="c"><input type="checkbox" id="c-39114829" checked=""/><div class="controls bullet"><span class="by">meheleventyone</span><span>|</span><a href="#39114787">parent</a><span>|</span><a href="#39110594">next</a><span>|</span><label class="collapse" for="c-39114829">[-]</label><label class="expand" for="c-39114829">[1 more]</label></div><br/><div class="children"><div class="content">One advantage is that it makes the value explicit so anyone reading the code irregardless of their familiarity with Go will know it will be zero.</div><br/></div></div></div></div><div id="39110594" class="c"><input type="checkbox" id="c-39110594" checked=""/><div class="controls bullet"><span class="by">Thaliana</span><span>|</span><a href="#39114787">prev</a><span>|</span><a href="#39114881">next</a><span>|</span><label class="collapse" for="c-39110594">[-]</label><label class="expand" for="c-39110594">[10 more]</label></div><br/><div class="children"><div class="content">&gt; why is it significant that we slice like a[i:i+4:i+4] rather than just a[i:i+4]?<p>Well I had never seen that &quot;full slice&quot; expression syntax before. It turns out that it&#x27;s important because it controls the capacity of the new slice. The capacity of the new slice is now i+4 - i.<p>So by using the full slice expression you get a slice of length 4 and capacity 4. Without doing this the capacity would be equal to the capacity of the original slice.<p>I suppose that by controlling the capacity that you eliminate the bounds check.</div><br/><div id="39112735" class="c"><input type="checkbox" id="c-39112735" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39110594">parent</a><span>|</span><a href="#39111861">next</a><span>|</span><label class="collapse" for="c-39112735">[-]</label><label class="expand" for="c-39112735">[6 more]</label></div><br/><div class="children"><div class="content">In my testing [1] that doesn&#x27;t eliminate bound checks. Instead, it avoids a computation of otherwise unused `cap(a[i:i+4]) = len(a) - i` value if my reading is correct.<p>[1] <a href="https:&#x2F;&#x2F;go.godbolt.org&#x2F;z&#x2F;63n6hTGGq" rel="nofollow">https:&#x2F;&#x2F;go.godbolt.org&#x2F;z&#x2F;63n6hTGGq</a> (original) vs. <a href="https:&#x2F;&#x2F;go.godbolt.org&#x2F;z&#x2F;YYPrzjxP5" rel="nofollow">https:&#x2F;&#x2F;go.godbolt.org&#x2F;z&#x2F;YYPrzjxP5</a> (capacity not limited)<p>&gt; Well I had never seen that &quot;full slice&quot; expression syntax before.<p>Go&#x27;s notion of capacity is somewhat pragmatic but at the same time confusing as well. I learned the hard way that the excess capacity is <i>always</i> available for the sake of optimization:<p><pre><code>    a := []int{1, 2, 3, 4, 5}
    lo, hi := a[:2], a[2:]
    lo = append(lo, 6, 7, 8)      &#x2F;&#x2F; Oops, it tries to reuse `lo[2:5]`!
    fmt.Printf(&quot;%v %v\n&quot;, lo, hi) &#x2F;&#x2F; Prints `[1 2 6 7 8] [6 7 8]`
</code></pre>
While I do understand the rationale, it is too unintuitive because there is no indication of the excess capacity in this code. I would prefer `a[x:y]` to be a shorthand for `a[x:y:y]` instead. The `a[x:y:len(a)]` case is of course useful though, so maybe a different shorthand like `a[x:y:$]` can be added.</div><br/><div id="39114665" class="c"><input type="checkbox" id="c-39114665" checked=""/><div class="controls bullet"><span class="by">beautron</span><span>|</span><a href="#39110594">root</a><span>|</span><a href="#39112735">parent</a><span>|</span><a href="#39114286">next</a><span>|</span><label class="collapse" for="c-39114665">[-]</label><label class="expand" for="c-39114665">[4 more]</label></div><br/><div class="children"><div class="content">I think slices are wonderfully intuitive... if you&#x27;ve worked with C.<p>Slices encapsulate an ubiquitous C pattern, where you pass to a function: a pointer (to an initial array element), and a length or capacity (sometimes both). This pattern is directly encapsulated by Go&#x27;s slices, which can be thought of as something like:<p><pre><code>  type Slice struct {
      Ptr *Elem
      Len int
      Cap int
  }
</code></pre>
I <i>love</i> Go&#x27;s slice syntax. It&#x27;s the right piece of syntactic sugar. It removes tedium and room-for-mistakes from this prevalent C pattern. It lets me work as precisely with memory as I do in C, yet everything is simpler, lighter, and breezier.<p>For example, I&#x27;m making a game in Go. I don&#x27;t want to be allocating memory throughout the game (which can cause frame drops), so instead I allocate giant arrays of memory on launch. Then I use slices to partition this memory as needed.<p>Some of these arrays get their elements re-accumulated at some interval (every level, or every frame, etc.). And so it works nicely to first set them to zero length:<p><pre><code>  myMem = myMem[:0]
</code></pre>
Notice that the myMem slice now has zero length, but still points to its same underlying array. Then I perform the accumulation:<p><pre><code>  for ... {
      myMem = append(myMem, elem)
  }
</code></pre>
Again, I don&#x27;t want to be allocating in general, so I care very much that append continues to use myMem&#x27;s preexisting capacity.<p>All this is to say, I don&#x27;t see slices as being the way they are for the &quot;sake of optimization.&quot; Rather I see them as an ideal tool for working with, referring to, and partitioning memory.</div><br/><div id="39114742" class="c"><input type="checkbox" id="c-39114742" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39110594">root</a><span>|</span><a href="#39114665">parent</a><span>|</span><a href="#39114286">next</a><span>|</span><label class="collapse" for="c-39114742">[-]</label><label class="expand" for="c-39114742">[3 more]</label></div><br/><div class="children"><div class="content">C doesn&#x27;t have any slicing operator like Go&#x27;s `a[x:y]`, which is the main problem I want to point out. Slice itself is just a natural construction.</div><br/><div id="39114947" class="c"><input type="checkbox" id="c-39114947" checked=""/><div class="controls bullet"><span class="by">beautron</span><span>|</span><a href="#39110594">root</a><span>|</span><a href="#39114742">parent</a><span>|</span><a href="#39114286">next</a><span>|</span><label class="collapse" for="c-39114947">[-]</label><label class="expand" for="c-39114947">[2 more]</label></div><br/><div class="children"><div class="content">Yes, I&#x27;m saying Go&#x27;s slice operator (and slice type, and related functions) grew out of experience from the way arrays are used in C.<p>To me, this becomes obvious if you read <i>The Practice of Programming</i> by Kernighan and Pike, the latter of which was a co-designer of Go. If you read the book, which was written well before Go, and pay attention to how it uses C arrays, you can almost <i>feel</i> Go slices emerging. The slice syntax perfectly encapsulates the C array bookkeeping.</div><br/><div id="39115056" class="c"><input type="checkbox" id="c-39115056" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39110594">root</a><span>|</span><a href="#39114947">parent</a><span>|</span><a href="#39114286">next</a><span>|</span><label class="collapse" for="c-39115056">[-]</label><label class="expand" for="c-39115056">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure how it can be possible. In my experience the notion of three-part slices does exist in C but only implicitly. For example,<p><pre><code>    size_t trim_end(const char *p, size_t len) {
        while (len &gt; 0) {
            if (p[len - 1] != &#x27; &#x27;) break;
            --len;
        }
        return len;
    }
</code></pre>
Conceptually this function accepts a slice `(p, len, cap)` and returns a slice `(p, len2, cap)` where `len2 &lt;= len` and the capacity never changes. But the actual argument doesn&#x27;t have `cap`, and the return argument doesn&#x27;t have `p`. Everything is implicit and it&#x27;s typical for C programmers to fully document and follow such implicits. Go&#x27;s slice operator can&#x27;t come out of such implicit practices in my opinion.<p>In comparison, your claim only makes sense when the following was somehow normal:<p><pre><code>    struct slice { const char *p; size_t len, cap; };
    struct slice trim_end(const struct slice *s) {
        struct slice out = *s;
        while (out.len &gt; 0) {
            if (out.p[out.len - 1] != &#x27; &#x27;) break;
            out = subslice(out, 0, out.len - 1);
        }
        return out;
    }
</code></pre>
Note that a hypothetical `subslice` function call maps perfectly to a Go code `out[0:len(out)-1]`, and my complaint will equally apply: there should be two clearly named variants of `subslice` that may or may not keep the capacity. But I hardly saw such construction in C.</div><br/></div></div></div></div></div></div></div></div><div id="39114286" class="c"><input type="checkbox" id="c-39114286" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#39110594">root</a><span>|</span><a href="#39112735">parent</a><span>|</span><a href="#39114665">prev</a><span>|</span><a href="#39111861">next</a><span>|</span><label class="collapse" for="c-39114286">[-]</label><label class="expand" for="c-39114286">[1 more]</label></div><br/><div class="children"><div class="content">This like most issues with slices stem directly from them pulling double duty as vectors.<p>Capacity being conserved by slicing is important to the âslice tricksâ of removing items, I assume.</div><br/></div></div></div></div><div id="39111861" class="c"><input type="checkbox" id="c-39111861" checked=""/><div class="controls bullet"><span class="by">ok_dad</span><span>|</span><a href="#39110594">parent</a><span>|</span><a href="#39112735">prev</a><span>|</span><a href="#39111835">next</a><span>|</span><label class="collapse" for="c-39111861">[-]</label><label class="expand" for="c-39111861">[1 more]</label></div><br/><div class="children"><div class="content">Youâre also never increasing the size of those slices right? So itâs better memory wise by a bit and maybe faster? I last used Go a while ago, but I recall the capacity was the length of the underlying array? Internally it may even reuse the same arrays for slices maybe, since theyâre not changing size each loop iteration.<p>Edit: weird, this was supposed to be an update to a previous comment I made, but this is a different comment now</div><br/></div></div><div id="39111835" class="c"><input type="checkbox" id="c-39111835" checked=""/><div class="controls bullet"><span class="by">ok_dad</span><span>|</span><a href="#39110594">parent</a><span>|</span><a href="#39111861">prev</a><span>|</span><a href="#39114881">next</a><span>|</span><label class="collapse" for="c-39111835">[-]</label><label class="expand" for="c-39111835">[2 more]</label></div><br/><div class="children"><div class="content">Youâre also never increasing the size of those slices right? So itâs better memory wise by a bit and maybe faster? I last used Go a while ago, but I recall the capacity was the length of the underlying array?<p>Edit2: (Iâm throttled and I canât post a new comment I guess? Makes me feel like my voice was stolen! I guess Iâm not wanted around HN.)<p>Thanks for the correction, I would delete my comment but I found a bug in HN while updating it so Iâll preserve my stupidity here in duplicate for now.</div><br/><div id="39111927" class="c"><input type="checkbox" id="c-39111927" checked=""/><div class="controls bullet"><span class="by">costco</span><span>|</span><a href="#39110594">root</a><span>|</span><a href="#39111835">parent</a><span>|</span><a href="#39114881">next</a><span>|</span><label class="collapse" for="c-39111927">[-]</label><label class="expand" for="c-39111927">[1 more]</label></div><br/><div class="children"><div class="content">There is no copying of memory going on, the a[i: i+4] or a[i: i+4: i+4] slice references the same underlying data as in a.</div><br/></div></div></div></div></div></div><div id="39114881" class="c"><input type="checkbox" id="c-39114881" checked=""/><div class="controls bullet"><span class="by">chmike</span><span>|</span><a href="#39110594">prev</a><span>|</span><a href="#39114200">next</a><span>|</span><label class="collapse" for="c-39114881">[-]</label><label class="expand" for="c-39114881">[1 more]</label></div><br/><div class="children"><div class="content">I would have tried parallelism just by curiosity. Split and spread the computation over multiple cores. If you have n cores you could get close to a factor n increase minus the cost of spreading the data and combining the results. That&#x27;s an easy optimization right out of the box with go (no assembly required).</div><br/></div></div><div id="39114200" class="c"><input type="checkbox" id="c-39114200" checked=""/><div class="controls bullet"><span class="by">kldx</span><span>|</span><a href="#39114881">prev</a><span>|</span><a href="#39108830">next</a><span>|</span><label class="collapse" for="c-39114200">[-]</label><label class="expand" for="c-39114200">[1 more]</label></div><br/><div class="children"><div class="content">This is a task where Halide <a href="https:&#x2F;&#x2F;halide-lang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;halide-lang.org&#x2F;</a> could really shine! It disconnects logic from scheduling (unrolling, vectorizing, tiling, caching intermediates etc), so every step the author describes in the article is a tunable in halide. halide doesn&#x27;t appear to have bindings for golang so calling C++ from go might be the only viable option.<p>Edit: the author has valid points against FFI here <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39110692">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39110692</a></div><br/></div></div><div id="39108830" class="c"><input type="checkbox" id="c-39108830" checked=""/><div class="controls bullet"><span class="by">carbocation</span><span>|</span><a href="#39114200">prev</a><span>|</span><a href="#39108255">next</a><span>|</span><label class="collapse" for="c-39108830">[-]</label><label class="expand" for="c-39108830">[3 more]</label></div><br/><div class="children"><div class="content">I wonder whether avo could have been useful here?[1] I mention it because it came up the last time we were talking about AVX operations in go.[2, 3]<p>1 = <a href="https:&#x2F;&#x2F;github.com&#x2F;mmcloughlin&#x2F;avo">https:&#x2F;&#x2F;github.com&#x2F;mmcloughlin&#x2F;avo</a><p>2 = <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34465297">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34465297</a><p>3 = <a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;golang&#x2F;comments&#x2F;10hmh07&#x2F;how_to_use_avx512_in_golang&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;golang&#x2F;comments&#x2F;10hmh07&#x2F;how_to_use_...</a></div><br/><div id="39109150" class="c"><input type="checkbox" id="c-39109150" checked=""/><div class="controls bullet"><span class="by">camdencheek</span><span>|</span><a href="#39108830">parent</a><span>|</span><a href="#39108255">next</a><span>|</span><label class="collapse" for="c-39109150">[-]</label><label class="expand" for="c-39109150">[2 more]</label></div><br/><div class="children"><div class="content">I did consider Avo! I even went as far as to implement a version using Avo since it has a nice dot product example I could use as a starting point. But ultimately, for as small as these functions are, I felt that Avo was an unnecessary extra layer to grok. Additionally, it&#x27;s x86-only, and I knew in advance I&#x27;d want to implement an ARM version as well since we also do some embeddings stuff locally.<p>If I were to ever take this further and add loop unrolling or something, I&#x27;d absolutely reach for Avo</div><br/><div id="39111208" class="c"><input type="checkbox" id="c-39111208" checked=""/><div class="controls bullet"><span class="by">carbocation</span><span>|</span><a href="#39108830">root</a><span>|</span><a href="#39109150">parent</a><span>|</span><a href="#39108255">next</a><span>|</span><label class="collapse" for="c-39111208">[-]</label><label class="expand" for="c-39111208">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for sharing, that is a very interesting coda to the story!</div><br/></div></div></div></div></div></div><div id="39108255" class="c"><input type="checkbox" id="c-39108255" checked=""/><div class="controls bullet"><span class="by">declan_roberts</span><span>|</span><a href="#39108830">prev</a><span>|</span><a href="#39109646">next</a><span>|</span><label class="collapse" for="c-39108255">[-]</label><label class="expand" for="c-39108255">[1 more]</label></div><br/><div class="children"><div class="content">I appreciate that thereâs so many engineers out there that <i>love</i> to make these kinds of improvements. I need them! Iâm a high-level person focused mostly on the product, and we would never have a good product without these smart people.<p>Keep up the good work!</div><br/></div></div><div id="39109646" class="c"><input type="checkbox" id="c-39109646" checked=""/><div class="controls bullet"><span class="by">malkia</span><span>|</span><a href="#39108255">prev</a><span>|</span><a href="#39109439">next</a><span>|</span><label class="collapse" for="c-39109646">[-]</label><label class="expand" for="c-39109646">[1 more]</label></div><br/><div class="children"><div class="content">I learned yesterday about GoLang&#x27;s assembler <a href="https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;asm" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;asm</a> - after browsing how arrow is implemented for different languages (my experience is mainly C&#x2F;C++) - <a href="https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;arrow&#x2F;tree&#x2F;main&#x2F;go&#x2F;arrow&#x2F;math">https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;arrow&#x2F;tree&#x2F;main&#x2F;go&#x2F;arrow&#x2F;math</a> - there are bunch of .S (&quot;asm&quot; files) and I&#x27;m still not able to comprehend how these work exactly (I guess it&#x27;ll take more reading) - it seems very peculiar.<p>The last time I&#x27;ve used inlined assembly was back in Turbo&#x2F;Borland Pascal, then bit in Visual Studio (32-bit), until they got disabled. Then did very little gcc with their more strict specification (while the former you had to know how the ABI worked, the latter too - but it was specced out).<p>Anyway - I wasn&#x27;t expecting to find this in &quot;Go&quot; :) But I guess you can always start with .go code then produce assembly (-S) then optimize it, or find&#x2F;hire someone to do it.</div><br/></div></div><div id="39109439" class="c"><input type="checkbox" id="c-39109439" checked=""/><div class="controls bullet"><span class="by">miki123211</span><span>|</span><a href="#39109646">prev</a><span>|</span><a href="#39110612">next</a><span>|</span><label class="collapse" for="c-39109439">[-]</label><label class="expand" for="c-39109439">[31 more]</label></div><br/><div class="children"><div class="content">I wonder how well a simple C for loop with -O3 and maybe -march would do here.<p>From my brief forays into reading (mostly AARCH64) assembly, it looks like C compilers can detect these kinds of patterns now and just convert them all to SIMD by themselves, with no work from the programmer. Even at -O2, converting an index-based loop into one based on start and end pointers is not unusual. Go doesn&#x27;t seem to do this, the assembly output by the Go compiler looks much closer to the actual code than what you get from C.<p>Rust iterators would also be fun to benchmark here, they&#x27;re supposed to be as fast as plain old loops, and they&#x27;re probably optimized to omit bounds checks entirely.</div><br/><div id="39110094" class="c"><input type="checkbox" id="c-39110094" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#39109439">parent</a><span>|</span><a href="#39109651">next</a><span>|</span><label class="collapse" for="c-39110094">[-]</label><label class="expand" for="c-39110094">[23 more]</label></div><br/><div class="children"><div class="content">&gt; Rust iterators would also be fun to benchmark here<p>I started to write this out, and then thought &quot;you know what given how common this is, I bet I could even just google it&quot; and thought that would be more interesting, as it makes it feel more &quot;real world.&quot; The first result I got is what I would have written: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;30422958&#x2F;24817" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;30422958&#x2F;24817</a><p>Here&#x27;s a godbolt with three different outputs: one at -O, one at -O3, and one at -03 and -march=native<p><a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;6xf9M1cf3" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;6xf9M1cf3</a><p>Eyeballing it comments:<p>Looks like 2 and 3 both provide extremely similar if not identical output.<p>Adding the native flag ends up generating slightly different codegen, I am not at the level to be able to simply look at that and know how meaningful the difference is.<p>It does appear to have eliminated the bounds check entirely, and it&#x27;s using xmm registers.<p>I am pleasantly surprised at this output because zip in particular can sometimes hinder optimizations, but rustc did a great job here.<p>----------------------<p>For fun, I figured &quot;why not also try as direct of the original Go as possible.&quot; The only trick here is that Rust doesn&#x27;t really do the c-style for loop the way Go does, so I tried to translate what I saw as the spirit of the example: compare the two lengths and use the minimum for the loop length.<p>Here it is: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;cTcddc8Gs" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;cTcddc8Gs</a><p>... literally the same. I am very surprised at this outcome. It makes me wonder if LLVM has some sort of idiom recognition for dot product specifically.<p>EDIT: looks like it does not currently, see the comment at line 28 and 29: <a href="https:&#x2F;&#x2F;llvm.org&#x2F;doxygen&#x2F;LoopIdiomRecognize_8cpp_source.html" rel="nofollow">https:&#x2F;&#x2F;llvm.org&#x2F;doxygen&#x2F;LoopIdiomRecognize_8cpp_source.html</a></div><br/><div id="39110280" class="c"><input type="checkbox" id="c-39110280" checked=""/><div class="controls bullet"><span class="by">camel-cdr</span><span>|</span><a href="#39109439">root</a><span>|</span><a href="#39110094">parent</a><span>|</span><a href="#39109651">next</a><span>|</span><label class="collapse" for="c-39110280">[-]</label><label class="expand" for="c-39110280">[22 more]</label></div><br/><div class="children"><div class="content">Those aren&#x27;t vectorized at all, just unrolled. vmulss&#x2F;vaddss just multiply&#x2F;add the single-precision floating-point in the vector register.<p>With clang you get basically the same codegen, although it uses fused multiply adds.<p>The problem is that you need to enable -ffast-math, otherwise the compiler can&#x27;t change the order of floating point operations, and thus not vectorize.<p>With clang that works wonderfully and it gives us a lovely four times unrolled AVX2 fused multiply add loop, but enabling it in rust doesn&#x27;t seem to work: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;G4Enf59Kb" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;G4Enf59Kb</a><p>Edit: from what I can tell this is still an open issue??? <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;21690">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;21690</a><p>Edit: relevant SO post: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;76055058&#x2F;why-cant-the-rust-compiler-auto-vectorize-this-fp-dot-product-implementation" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;76055058&#x2F;why-cant-the-ru...</a>
Apparently you need to use `#![feature(core_intrinsics)]`, `std::intrinsics::fadd_fast` and `std::intrinsics::fmul_fast`.</div><br/><div id="39110505" class="c"><input type="checkbox" id="c-39110505" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#39109439">root</a><span>|</span><a href="#39110280">parent</a><span>|</span><a href="#39110572">next</a><span>|</span><label class="collapse" for="c-39110505">[-]</label><label class="expand" for="c-39110505">[3 more]</label></div><br/><div class="children"><div class="content">Ahh yes, thank you.<p>Rust doesn&#x27;t have a -ffast-math flag, though it is interesting that you passed it directly to llvm. I am kinda glad that escape hatch doesn&#x27;t work, to be honest.<p>There are currently unstable intrinsics that let you do this, and you seemingly get close to clang codegen with them: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;EEW79Gbxv" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;EEW79Gbxv</a><p>The thread tracking this discusses another attempt at a flag to enable this by turning on the CPU feature directly, but that doesn&#x27;t seem to affect codegen in this case. <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;21690">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;21690</a><p>It would be nice to get these intrinsics stabilized, at least.<p>EDIT: oops you figured this out while I was writing it, haha.</div><br/><div id="39110903" class="c"><input type="checkbox" id="c-39110903" checked=""/><div class="controls bullet"><span class="by">cbm-vic-20</span><span>|</span><a href="#39109439">root</a><span>|</span><a href="#39110505">parent</a><span>|</span><a href="#39110572">next</a><span>|</span><label class="collapse" for="c-39110903">[-]</label><label class="expand" for="c-39110903">[2 more]</label></div><br/><div class="children"><div class="content">Even without a -ffast-math flag, the current stable Rust compiler will vectorize loops on integer types.<p><a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;KjErzacfv" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;KjErzacfv</a><p>Edit: ...and I now realize who I responded to, I&#x27;m sure you already know this. :)</div><br/><div id="39111591" class="c"><input type="checkbox" id="c-39111591" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#39109439">root</a><span>|</span><a href="#39110903">parent</a><span>|</span><a href="#39110572">next</a><span>|</span><label class="collapse" for="c-39111591">[-]</label><label class="expand" for="c-39111591">[1 more]</label></div><br/><div class="children"><div class="content">Loops on floats are fine, its just reduction operations that hit the issue with the associativity assumption for floats leading to UB. You can trick it by making f32x16 types like the wide crate does or if you use nightly simba can do it with const generic expressions.</div><br/></div></div></div></div></div></div><div id="39110572" class="c"><input type="checkbox" id="c-39110572" checked=""/><div class="controls bullet"><span class="by">nemothekid</span><span>|</span><a href="#39109439">root</a><span>|</span><a href="#39110280">parent</a><span>|</span><a href="#39110505">prev</a><span>|</span><a href="#39111027">next</a><span>|</span><label class="collapse" for="c-39110572">[-]</label><label class="expand" for="c-39110572">[17 more]</label></div><br/><div class="children"><div class="content">It was just last week I was reading a comment that made it seem like you shouldn&#x27;t really use -ffast-math[0], but here looks like a non-rare reason why you would want to enable it.<p>What is correct idiom here? It feels if this sort of thing really matters to you, you should have the know how to handroll a couple lines of ASM. I want to say this is rare, but I had a project a couple years ago where I needed to handroll some vectorized instructions on a raspberry pi.<p>[0] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39013277">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39013277</a></div><br/><div id="39110894" class="c"><input type="checkbox" id="c-39110894" checked=""/><div class="controls bullet"><span class="by">sevagh</span><span>|</span><a href="#39109439">root</a><span>|</span><a href="#39110572">parent</a><span>|</span><a href="#39111438">next</a><span>|</span><label class="collapse" for="c-39110894">[-]</label><label class="expand" for="c-39110894">[3 more]</label></div><br/><div class="children"><div class="content">Definitely don&#x27;t take an HN comment as a serious suggestion. Enable fast-math for your code, run your objective evaluation that&#x27;s suitable for your domain, and if it passes the test, enjoy the added speed.<p>FWIW I have oodles of numerical C++ code where fast-math doesn&#x27;t change the output.</div><br/><div id="39112829" class="c"><input type="checkbox" id="c-39112829" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39109439">root</a><span>|</span><a href="#39110894">parent</a><span>|</span><a href="#39113759">next</a><span>|</span><label class="collapse" for="c-39112829">[-]</label><label class="expand" for="c-39112829">[1 more]</label></div><br/><div class="children"><div class="content">For a very long time `-funsafe-math-optimizations` (and thus `-ffast-math`) had been infectious [1], so a responsible library should <i>never</i> have used `-ffast-math` anyway.<p>You are right in that the final binary is free to turn `-ffast-math` on if you can verify that everything went okay. But almost no one would actually verify that. It&#x27;s like an advice that you shouldn&#x27;t write your own crypto code---it&#x27;s fine if you know what you are doing, but almost no one does, so the advice is technically false but still worthwhile.<p>[1] <a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;bugzilla&#x2F;show_bug.cgi?id=55522" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;bugzilla&#x2F;show_bug.cgi?id=55522</a> (GCC), <a href="https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;issues&#x2F;57589">https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;issues&#x2F;57589</a> (LLVM)</div><br/></div></div><div id="39113759" class="c"><input type="checkbox" id="c-39113759" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#39109439">root</a><span>|</span><a href="#39110894">parent</a><span>|</span><a href="#39112829">prev</a><span>|</span><a href="#39111438">next</a><span>|</span><label class="collapse" for="c-39113759">[-]</label><label class="expand" for="c-39113759">[1 more]</label></div><br/><div class="children"><div class="content">That sounds like trying to run a program to check if it has underground behavior.  How do you make a test that&#x27;s comprehensive and future-compiler-safe?</div><br/></div></div></div></div><div id="39111438" class="c"><input type="checkbox" id="c-39111438" checked=""/><div class="controls bullet"><span class="by">jkafjanvnfaf</span><span>|</span><a href="#39109439">root</a><span>|</span><a href="#39110572">parent</a><span>|</span><a href="#39110894">prev</a><span>|</span><a href="#39110759">next</a><span>|</span><label class="collapse" for="c-39111438">[-]</label><label class="expand" for="c-39111438">[1 more]</label></div><br/><div class="children"><div class="content">The usual technique is to keep a 4-element array of sums (so sum[j] is the sum of all terms of the form a[4*i + j] * b[4*i + j]), and then take the total at the very end. This allows for the use of vectorization even with strict IEEE-compliance.<p>Generally, I would recommend against -ffast-math mostly because it enables -ffinite-math-only and that one can <i>really</i> blow up in your face. Most other flags (like -funsafe-math-operations) aren&#x27;t that bad from an accuracy standpoint. Obviously you should not turn them on for code that you have actually tuned to minimize error, but in other cases they barely ever degrade the results.</div><br/></div></div><div id="39110759" class="c"><input type="checkbox" id="c-39110759" checked=""/><div class="controls bullet"><span class="by">camel-cdr</span><span>|</span><a href="#39109439">root</a><span>|</span><a href="#39110572">parent</a><span>|</span><a href="#39111438">prev</a><span>|</span><a href="#39110669">next</a><span>|</span><label class="collapse" for="c-39110759">[-]</label><label class="expand" for="c-39110759">[6 more]</label></div><br/><div class="children"><div class="content">Imo the best solution would be special &quot;fast&quot; floating-point types, that have less strict requirements.<p>I personal almost always use -ffast-math by default in my C programs that care about performance, because I almost never care enough about the loss in accuracy. The only case I remember needing it was when doing some random number distribution tests where I cared about subnormals, and got confused for a second because they didn&#x27;t seem to exist (-ffast-math disables them on x86).</div><br/><div id="39112912" class="c"><input type="checkbox" id="c-39112912" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39109439">root</a><span>|</span><a href="#39110759">parent</a><span>|</span><a href="#39110669">next</a><span>|</span><label class="collapse" for="c-39112912">[-]</label><label class="expand" for="c-39112912">[5 more]</label></div><br/><div class="children"><div class="content">That or a scoped optimization directive. GCC does allow `__attribute__((optimize(&quot;-ffast-math&quot;)))` as a function-wide attribute, but Clang doesn&#x27;t seem to have an equivalent and the standard syntax `[[gcc::optimize(&quot;-ffast-math&quot;)]]` doesn&#x27;t seem to work as well. In any case, such optimization should be visible from the code in my opinion.</div><br/><div id="39114230" class="c"><input type="checkbox" id="c-39114230" checked=""/><div class="controls bullet"><span class="by">lorenzored</span><span>|</span><a href="#39109439">root</a><span>|</span><a href="#39112912">parent</a><span>|</span><a href="#39110669">next</a><span>|</span><label class="collapse" for="c-39114230">[-]</label><label class="expand" for="c-39114230">[4 more]</label></div><br/><div class="children"><div class="content">The problem is that it takes a single piece of code compiled with -ffast-math to break everything, it&#x27;s simply not worth it</div><br/><div id="39114364" class="c"><input type="checkbox" id="c-39114364" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#39109439">root</a><span>|</span><a href="#39114230">parent</a><span>|</span><a href="#39110669">next</a><span>|</span><label class="collapse" for="c-39114364">[-]</label><label class="expand" for="c-39114364">[3 more]</label></div><br/><div class="children"><div class="content">GP seems to be saying that you can flag individual functions in GCC, thereby avoiding this issue: only flagged functions would be compiled with fast math semantics.</div><br/><div id="39114433" class="c"><input type="checkbox" id="c-39114433" checked=""/><div class="controls bullet"><span class="by">lorenzored</span><span>|</span><a href="#39109439">root</a><span>|</span><a href="#39114364">parent</a><span>|</span><a href="#39110669">next</a><span>|</span><label class="collapse" for="c-39114433">[-]</label><label class="expand" for="c-39114433">[2 more]</label></div><br/><div class="children"><div class="content">This only work if it&#x27;s a leaf function that will throw away the result. If you feed the result of your --fast-math function into other working code you risk breaking it.</div><br/><div id="39114705" class="c"><input type="checkbox" id="c-39114705" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39109439">root</a><span>|</span><a href="#39114433">parent</a><span>|</span><a href="#39110669">next</a><span>|</span><label class="collapse" for="c-39114705">[-]</label><label class="expand" for="c-39114705">[1 more]</label></div><br/><div class="children"><div class="content">`-ffast-math` is fully local, asides from GCC&#x27;s unexpected `crtfastmath.o` linkage which <i>is</i> global.<p>Functions with `-ffast-math` enabled still return fp values via usual registers and in usual formats. If some function `f` is expected to return -1.0 to 1.0 for particluar inputs, `-ffast-math` can only make it to return 1.001 or NaN instead. If another function without `-ffast-math` expects and doesn&#x27;t verify f&#x27;s return value, it will surely misbehave, but only because the original analysis of f no longer holds.<p>`-ffast-math` the compiler option is bad because this effect is <i>not</i> evident from the code. Anything visible in the code should be okay.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39110669" class="c"><input type="checkbox" id="c-39110669" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#39109439">root</a><span>|</span><a href="#39110572">parent</a><span>|</span><a href="#39110759">prev</a><span>|</span><a href="#39111439">next</a><span>|</span><label class="collapse" for="c-39110669">[-]</label><label class="expand" for="c-39110669">[1 more]</label></div><br/><div class="children"><div class="content">The right path forward for Rust here in my opinion is to do the same thing as is done for math operations like saturating: stabilize a function or method that performs the operation with this semantic, and then build thin wrappers on top to make using them more convenient.</div><br/></div></div><div id="39111439" class="c"><input type="checkbox" id="c-39111439" checked=""/><div class="controls bullet"><span class="by">miki123211</span><span>|</span><a href="#39109439">root</a><span>|</span><a href="#39110572">parent</a><span>|</span><a href="#39110669">prev</a><span>|</span><a href="#39111644">next</a><span>|</span><label class="collapse" for="c-39111439">[-]</label><label class="expand" for="c-39111439">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you should have the know how to handroll a couple lines of ASM<p>For what architecture? What if this code is in a library that your users might want to run on Intel (both 32 and 64 bit), ARM, Risc V and s390x? Even if you learn assembly for all of these, how are you going to get access to an S390X IBM mainframe to test your code? What if a new architecture[1] gets popular in the next couple of years, and you won&#x27;t have access to a CPU to test on?<p>Leaving this work to a compiler or architecture-independent functions &#x2F; macros that use intrinsics under the hood frees you from having to think about all of that. As long as whatever the user is running on has decent compiler support, your code is going to work and be fast, even years later.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Loongson" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Loongson</a></div><br/></div></div><div id="39111644" class="c"><input type="checkbox" id="c-39111644" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#39109439">root</a><span>|</span><a href="#39110572">parent</a><span>|</span><a href="#39111439">prev</a><span>|</span><a href="#39111225">next</a><span>|</span><label class="collapse" for="c-39111644">[-]</label><label class="expand" for="c-39111644">[1 more]</label></div><br/><div class="children"><div class="content">You can write it like this to get the compiler to generate SIMD: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;ohvoEb7er" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;ohvoEb7er</a><p>It&#x27;s certainly not perfect though (in particular the final reduction&#x2F;remainder handling).<p>Unfortunately Rust doesn&#x27;t have a proper optimizing float type. I really wish there was a type FastF32 or something similar which may be optimized using the usual transformation rules of algebra (e.g. associative property, distributive property, x + y - y = x, etc).<p>There is fadd_fast and co, but those are UB on NaN&#x2F;infinite input.</div><br/></div></div><div id="39111225" class="c"><input type="checkbox" id="c-39111225" checked=""/><div class="controls bullet"><span class="by">the8472</span><span>|</span><a href="#39109439">root</a><span>|</span><a href="#39110572">parent</a><span>|</span><a href="#39111644">prev</a><span>|</span><a href="#39111306">next</a><span>|</span><label class="collapse" for="c-39111225">[-]</label><label class="expand" for="c-39111225">[2 more]</label></div><br/><div class="children"><div class="content">Usually one wants a subset of the thing that -ffast-math does, e.g. -fassociative-math. And only within some limited scope.</div><br/><div id="39111317" class="c"><input type="checkbox" id="c-39111317" checked=""/><div class="controls bullet"><span class="by">camel-cdr</span><span>|</span><a href="#39109439">root</a><span>|</span><a href="#39111225">parent</a><span>|</span><a href="#39111306">next</a><span>|</span><label class="collapse" for="c-39111317">[-]</label><label class="expand" for="c-39111317">[1 more]</label></div><br/><div class="children"><div class="content">I played around with the example a bit, the minimum for vectorization seems to be  -fassociative-math -fno-signed-zeros. The gcc docs say -fassociative-math requries -fno-signed-zeros and -fno-trapping-math though.<p>I suppose -fassociative-math -fno-signed-zeros -fno-trapping-math -freciprocal-math will get you most of the way there, and maybe an -ffinite-math-only when appropriate.</div><br/></div></div></div></div></div></div><div id="39111027" class="c"><input type="checkbox" id="c-39111027" checked=""/><div class="controls bullet"><span class="by">sroussey</span><span>|</span><a href="#39109439">root</a><span>|</span><a href="#39110280">parent</a><span>|</span><a href="#39110572">prev</a><span>|</span><a href="#39109651">next</a><span>|</span><label class="collapse" for="c-39111027">[-]</label><label class="expand" for="c-39111027">[1 more]</label></div><br/><div class="children"><div class="content">fast-math changes even libraries not compiled with it, so buyer beware.</div><br/></div></div></div></div></div></div><div id="39109651" class="c"><input type="checkbox" id="c-39109651" checked=""/><div class="controls bullet"><span class="by">mratsim</span><span>|</span><a href="#39109439">parent</a><span>|</span><a href="#39110094">prev</a><span>|</span><a href="#39110612">next</a><span>|</span><label class="collapse" for="c-39109651">[-]</label><label class="expand" for="c-39109651">[7 more]</label></div><br/><div class="children"><div class="content">It depends.<p>You need 2~3 accumulators to saturate instruction-level parallelism with a parallel sum reduction. But the compiler won&#x27;t do it because it only creates those when the operation is associative, i.e. (a+b)+c = a+(b+c), which is true for integers but not for floats.<p>There is an escape hatch in -ffast-math.<p>I have extensive benches on this here: <a href="https:&#x2F;&#x2F;github.com&#x2F;mratsim&#x2F;laser&#x2F;blob&#x2F;master&#x2F;benchmarks%2Ffp_reduction_latency%2Freduction_bench.nim#L336">https:&#x2F;&#x2F;github.com&#x2F;mratsim&#x2F;laser&#x2F;blob&#x2F;master&#x2F;benchmarks%2Ffp...</a></div><br/><div id="39111291" class="c"><input type="checkbox" id="c-39111291" checked=""/><div class="controls bullet"><span class="by">menaerus</span><span>|</span><a href="#39109439">root</a><span>|</span><a href="#39109651">parent</a><span>|</span><a href="#39113049">next</a><span>|</span><label class="collapse" for="c-39111291">[-]</label><label class="expand" for="c-39111291">[3 more]</label></div><br/><div class="children"><div class="content">In my experience, compilers rarely know how to make use of ILP even in some for what you would expect to be the &quot;simple&quot; cases. Handwriting the SIMD, at least in my case, almost always proved to be several times faster than the auto-vectorized code generated by the compiler.</div><br/><div id="39112061" class="c"><input type="checkbox" id="c-39112061" checked=""/><div class="controls bullet"><span class="by">mratsim</span><span>|</span><a href="#39109439">root</a><span>|</span><a href="#39111291">parent</a><span>|</span><a href="#39113049">next</a><span>|</span><label class="collapse" for="c-39112061">[-]</label><label class="expand" for="c-39112061">[2 more]</label></div><br/><div class="children"><div class="content">They do reorder instructions. I think the SIMD part has more to do with loop analysis than ILP.<p>It&#x27;s quite telling that there is a #pragma omp simd to hint to a compiler to rewrite the loop.<p>Now I wonder what&#x27;s the state of polyhedral compilers. It&#x27;s been many years. And given the AI, LLMs hype they could really shine.</div><br/><div id="39114984" class="c"><input type="checkbox" id="c-39114984" checked=""/><div class="controls bullet"><span class="by">menaerus</span><span>|</span><a href="#39109439">root</a><span>|</span><a href="#39112061">parent</a><span>|</span><a href="#39113049">next</a><span>|</span><label class="collapse" for="c-39114984">[-]</label><label class="expand" for="c-39114984">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think the SIMD part has more to do with loop analysis than ILP.<p>If you know how to rewrite the algorithm in such a way so that it makes close-to-ideal utilization of CPU ports through your SIMD then it is practically impossible to beat it. And I haven&#x27;t seen a compiler (GCC, clang) doing such a thing or at least not in the instances I had written. I&#x27;ve measured substantial improvements from such and similar utilization of CPU-level microarchitectural details. So perhaps I don&#x27;t think it&#x27;s the loop analysis only but I do think it&#x27;s practically an impossible task for the compiler. Perhaps with the AI ...</div><br/></div></div></div></div></div></div><div id="39113049" class="c"><input type="checkbox" id="c-39113049" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39109439">root</a><span>|</span><a href="#39109651">parent</a><span>|</span><a href="#39111291">prev</a><span>|</span><a href="#39110612">next</a><span>|</span><label class="collapse" for="c-39113049">[-]</label><label class="expand" for="c-39113049">[3 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t necessarily need `-ffast-math` if you are willing to tweak your code a bit, since you can just introduce accumulators by yourself. Such optimizer-friendly code is not hard to write if you know basic principles.</div><br/><div id="39114464" class="c"><input type="checkbox" id="c-39114464" checked=""/><div class="controls bullet"><span class="by">mratsim</span><span>|</span><a href="#39109439">root</a><span>|</span><a href="#39113049">parent</a><span>|</span><a href="#39110612">next</a><span>|</span><label class="collapse" for="c-39114464">[-]</label><label class="expand" for="c-39114464">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what I&#x27;m saying though. Either youbdo the accumulators yourself, or you need a compiler escape hatch.</div><br/><div id="39114662" class="c"><input type="checkbox" id="c-39114662" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39109439">root</a><span>|</span><a href="#39114464">parent</a><span>|</span><a href="#39110612">next</a><span>|</span><label class="collapse" for="c-39114662">[-]</label><label class="expand" for="c-39114662">[1 more]</label></div><br/><div class="children"><div class="content">I mean, you don&#x27;t need SIMD to put accumulators.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39110612" class="c"><input type="checkbox" id="c-39110612" checked=""/><div class="controls bullet"><span class="by">jeremycw</span><span>|</span><a href="#39109439">prev</a><span>|</span><a href="#39111087">next</a><span>|</span><label class="collapse" for="c-39110612">[-]</label><label class="expand" for="c-39110612">[4 more]</label></div><br/><div class="children"><div class="content">The overhead of cgo seems like it would not be an issue if you could pass in an array of vectors and moved the outer loop into the procedure instead of calling the procedure for each vector. This may only be viable if there is a low overhead way to pass arrays back and forth between go and C. I&#x27;m no expert but a quick google makes me think this is possible.<p>I get that hand rolling assembly is fun but as a theoretical future maintainer I would much prefer C to ASM.</div><br/><div id="39110692" class="c"><input type="checkbox" id="c-39110692" checked=""/><div class="controls bullet"><span class="by">camdencheek</span><span>|</span><a href="#39110612">parent</a><span>|</span><a href="#39111087">next</a><span>|</span><label class="collapse" for="c-39110692">[-]</label><label class="expand" for="c-39110692">[3 more]</label></div><br/><div class="children"><div class="content">Definitely possible! However, I prefer to avoid cgo wherever possible for more than just the overhead.<p>In my experience:<p>- It complicates builds by requiring a C toolchain<p>- It makes single, static binaries more difficult<p>- It makes portability more difficult (not that assembly is portable though)<p>- It causes difficult-to-debug issues (I recently ran into an issue where MacOS signing changed, causing all my cgo binaries to be killed on startup)<p>- Debuggers don&#x27;t work across Cgo boundaries (they do with go ASM!)<p>I think Dave Cheney said it best: <a href="https:&#x2F;&#x2F;dave.cheney.net&#x2F;2016&#x2F;01&#x2F;18&#x2F;cgo-is-not-go" rel="nofollow">https:&#x2F;&#x2F;dave.cheney.net&#x2F;2016&#x2F;01&#x2F;18&#x2F;cgo-is-not-go</a></div><br/><div id="39114322" class="c"><input type="checkbox" id="c-39114322" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39110612">root</a><span>|</span><a href="#39110692">parent</a><span>|</span><a href="#39111087">next</a><span>|</span><label class="collapse" for="c-39114322">[-]</label><label class="expand" for="c-39114322">[2 more]</label></div><br/><div class="children"><div class="content">The whole &quot;cgo is not Go&quot; bashing is a kind of joke, maybe if Go 2 ever comes to light, one of the first breaking changes should be to remove cgo.<p>There, beautiful Go code from that point onwards.</div><br/><div id="39114770" class="c"><input type="checkbox" id="c-39114770" checked=""/><div class="controls bullet"><span class="by">beautron</span><span>|</span><a href="#39110612">root</a><span>|</span><a href="#39114322">parent</a><span>|</span><a href="#39111087">next</a><span>|</span><label class="collapse" for="c-39114770">[-]</label><label class="expand" for="c-39114770">[1 more]</label></div><br/><div class="children"><div class="content">Dear Lord, no! I depend on cgo for my game!<p>What&#x27;s more, I have no complaints about cgo. It hasn&#x27;t been a performance problem at all (my game runs smoothly at 240hz). And the interface for binding to C is quite simple and nice to work with (I made my own bindings to SDL2, OpenGL, and Steamworks).<p>Cgo did make cross-compiling trickier to set up, but I managed to do it with a fair amount of elbow grease (Windows and MacOS builds on my Linux desktop).</div><br/></div></div></div></div></div></div></div></div><div id="39111087" class="c"><input type="checkbox" id="c-39111087" checked=""/><div class="controls bullet"><span class="by">sroussey</span><span>|</span><a href="#39110612">prev</a><span>|</span><a href="#39109882">next</a><span>|</span><label class="collapse" for="c-39111087">[-]</label><label class="expand" for="c-39111087">[3 more]</label></div><br/><div class="children"><div class="content">For other languages (including nodejs&#x2F;bun&#x2F;rust&#x2F;python etc) you can have a look at SimSIMD which I have contributed to this year (made recompiled binaries for nodejs&#x2F;bun part of the build process for x86_64 and arm64 on Mac and Linux, x86 and x86_64 on windows).<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;ashvardanian&#x2F;SimSIMD">https:&#x2F;&#x2F;github.com&#x2F;ashvardanian&#x2F;SimSIMD</a></div><br/><div id="39112995" class="c"><input type="checkbox" id="c-39112995" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39111087">parent</a><span>|</span><a href="#39109882">next</a><span>|</span><label class="collapse" for="c-39112995">[-]</label><label class="expand" for="c-39112995">[2 more]</label></div><br/><div class="children"><div class="content">I think SimSIMD doesn&#x27;t have a Rust port yet. Given it&#x27;s a relatively small and self-contained library, a source-to-source translation might be a better choice for Rust!</div><br/><div id="39113014" class="c"><input type="checkbox" id="c-39113014" checked=""/><div class="controls bullet"><span class="by">sroussey</span><span>|</span><a href="#39111087">root</a><span>|</span><a href="#39112995">parent</a><span>|</span><a href="#39109882">next</a><span>|</span><label class="collapse" for="c-39113014">[-]</label><label class="expand" for="c-39113014">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, it is all in the C header file. I thought it did rust, but instead it has something for go! OP should check it out.</div><br/></div></div></div></div></div></div><div id="39109882" class="c"><input type="checkbox" id="c-39109882" checked=""/><div class="controls bullet"><span class="by">blobbers</span><span>|</span><a href="#39111087">prev</a><span>|</span><a href="#39112725">next</a><span>|</span><label class="collapse" for="c-39109882">[-]</label><label class="expand" for="c-39109882">[3 more]</label></div><br/><div class="children"><div class="content">This is the type of optimization we used to see in embedded hardware constrained environments.<p>Nowadays, even on most embedded platforms resources are so abundant and applications are HORIZONTALLY scaled that it seems to feel like nobody bothers with VERTICAL scaling.<p>The thing about multiplication is it is commutative; an 8x improvement in performance of a single node means you need 8x less nodes! What a fun way to cut down your AWS bill and send your SaaS company to profitability.</div><br/><div id="39109923" class="c"><input type="checkbox" id="c-39109923" checked=""/><div class="controls bullet"><span class="by">whatshisface</span><span>|</span><a href="#39109882">parent</a><span>|</span><a href="#39112725">next</a><span>|</span><label class="collapse" for="c-39109923">[-]</label><label class="expand" for="c-39109923">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know the truth about it, but what people say is that most unprofitable SaaS startups are the way they are because they&#x27;re making <i>no money at all</i>, not that their costs are higher than their 2x-one-developer&#x27;s-compensation revenues.</div><br/><div id="39110216" class="c"><input type="checkbox" id="c-39110216" checked=""/><div class="controls bullet"><span class="by">__loam</span><span>|</span><a href="#39109882">root</a><span>|</span><a href="#39109923">parent</a><span>|</span><a href="#39112725">next</a><span>|</span><label class="collapse" for="c-39110216">[-]</label><label class="expand" for="c-39110216">[1 more]</label></div><br/><div class="children"><div class="content">I think there&#x27;s plenty of sass companies out there that are subsidizing what their customers are paying them with vc cash. I&#x27;ve been at 2 sass companies where infrastructure optimization was starting to be a real concern. If your unit economics are in the red and additional customers cost you money, you need to optimize somehow.</div><br/></div></div></div></div></div></div><div id="39112725" class="c"><input type="checkbox" id="c-39112725" checked=""/><div class="controls bullet"><span class="by">bastawhiz</span><span>|</span><a href="#39109882">prev</a><span>|</span><a href="#39111938">next</a><span>|</span><label class="collapse" for="c-39112725">[-]</label><label class="expand" for="c-39112725">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In our unrolled code, the dependencies between multiply instructions are removed, enabling the CPU to take more advantage of pipelining. This increases our throughput by 37% compared to our naive implementation.<p>Can this 37% truly be attributed to loop unrolling? One really notable difference is the loop only compares against len(a) instead of both len(a) and len(b) in the unrolled version. I don&#x27;t know enough about Go to know whether the compiler can optimize the comparison away, but in some other languages it would be significant.<p>&gt; Also, getting my hands dirty with some assembly sounds fun, so that&#x27;s what I&#x27;m going to do.<p>I&#x27;d have loved to see the comparison between the asm that the compiler was generating and the bespoke asm written here. I&#x27;d bet that simply gussying up the generated asm results in a pretty sizable improvement (but obviously less impressive than by switching to SIMD).</div><br/></div></div><div id="39111938" class="c"><input type="checkbox" id="c-39111938" checked=""/><div class="controls bullet"><span class="by">huac</span><span>|</span><a href="#39112725">prev</a><span>|</span><a href="#39109597">next</a><span>|</span><label class="collapse" for="c-39111938">[-]</label><label class="expand" for="c-39111938">[1 more]</label></div><br/><div class="children"><div class="content">I did a similar optimization via <a href="https:&#x2F;&#x2F;github.com&#x2F;viterin&#x2F;vek">https:&#x2F;&#x2F;github.com&#x2F;viterin&#x2F;vek</a> as the SIMD version. Some somewhat unscientific calculations showed a 10x improvement staying in float32: <a href="https:&#x2F;&#x2F;github.com&#x2F;stillmatic&#x2F;gollum&#x2F;blob&#x2F;07a9aa35d2517af8cfa36d0ee61736010ad91b58&#x2F;math_test.go#L124">https:&#x2F;&#x2F;github.com&#x2F;stillmatic&#x2F;gollum&#x2F;blob&#x2F;07a9aa35d2517af8cf...</a> (comparable to the 9x improvement in article using SIMD + int8)<p>TBH my takeaway was that it was more useful to use smaller vectors as a representation</div><br/></div></div><div id="39109597" class="c"><input type="checkbox" id="c-39109597" checked=""/><div class="controls bullet"><span class="by">mkhnews</span><span>|</span><a href="#39111938">prev</a><span>|</span><a href="#39113035">next</a><span>|</span><label class="collapse" for="c-39109597">[-]</label><label class="expand" for="c-39109597">[1 more]</label></div><br/><div class="children"><div class="content">Great stuff.
We used to do this sort of opt for dot, axpy, gemm, etc. in the BLAS and LAPACK libs a long time ago.</div><br/></div></div><div id="39113035" class="c"><input type="checkbox" id="c-39113035" checked=""/><div class="controls bullet"><span class="by">ken47</span><span>|</span><a href="#39109597">prev</a><span>|</span><a href="#39112715">next</a><span>|</span><label class="collapse" for="c-39113035">[-]</label><label class="expand" for="c-39113035">[3 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t Go quite the suboptimal language for performing linear algebra operations?</div><br/><div id="39114328" class="c"><input type="checkbox" id="c-39114328" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39113035">parent</a><span>|</span><a href="#39113079">next</a><span>|</span><label class="collapse" for="c-39114328">[-]</label><label class="expand" for="c-39114328">[1 more]</label></div><br/><div class="children"><div class="content">Not only linear algebra operations, had it not been for Docker and K8s successes...</div><br/></div></div><div id="39113079" class="c"><input type="checkbox" id="c-39113079" checked=""/><div class="controls bullet"><span class="by">camdencheek</span><span>|</span><a href="#39113035">parent</a><span>|</span><a href="#39114328">prev</a><span>|</span><a href="#39112715">next</a><span>|</span><label class="collapse" for="c-39113079">[-]</label><label class="expand" for="c-39113079">[1 more]</label></div><br/><div class="children"><div class="content">From the mouth of this post&#x27;s author: yes.</div><br/></div></div></div></div><div id="39112715" class="c"><input type="checkbox" id="c-39112715" checked=""/><div class="controls bullet"><span class="by">M911T</span><span>|</span><a href="#39113035">prev</a><span>|</span><a href="#39111990">next</a><span>|</span><label class="collapse" for="c-39112715">[-]</label><label class="expand" for="c-39112715">[1 more]</label></div><br/><div class="children"><div class="content">Offtopic, but I noticed that this website uses the SF Mono font on their code blocks, is that fine? And no, I don&#x27;t work for Apple (or anytone, for that matter), I just checked because I&#x27;m searching for a (preferably FOSS) free font that looks like SF Mono.</div><br/></div></div><div id="39111990" class="c"><input type="checkbox" id="c-39111990" checked=""/><div class="controls bullet"><span class="by">snitty</span><span>|</span><a href="#39112715">prev</a><span>|</span><a href="#39109578">next</a><span>|</span><label class="collapse" for="c-39111990">[-]</label><label class="expand" for="c-39111990">[4 more]</label></div><br/><div class="children"><div class="content">Is the best way to write AVX2&#x2F;512 code really just smushing some assembly into your Go&#x2F;C&#x2F;C++?</div><br/><div id="39113076" class="c"><input type="checkbox" id="c-39113076" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39111990">parent</a><span>|</span><a href="#39112579">next</a><span>|</span><label class="collapse" for="c-39113076">[-]</label><label class="expand" for="c-39113076">[1 more]</label></div><br/><div class="children"><div class="content">C++ users can enjoy Highway [1].<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;highway&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;highway&#x2F;</a></div><br/></div></div><div id="39112579" class="c"><input type="checkbox" id="c-39112579" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#39111990">parent</a><span>|</span><a href="#39113076">prev</a><span>|</span><a href="#39109578">next</a><span>|</span><label class="collapse" for="c-39112579">[-]</label><label class="expand" for="c-39112579">[2 more]</label></div><br/><div class="children"><div class="content">In C or C++ you can use the functions in immintrin.h instead.</div><br/><div id="39114333" class="c"><input type="checkbox" id="c-39114333" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39111990">root</a><span>|</span><a href="#39112579">parent</a><span>|</span><a href="#39109578">next</a><span>|</span><label class="collapse" for="c-39114333">[-]</label><label class="expand" for="c-39114333">[1 more]</label></div><br/><div class="children"><div class="content">I am quite sure aCC and xlC don&#x27;t have them.</div><br/></div></div></div></div></div></div><div id="39109578" class="c"><input type="checkbox" id="c-39109578" checked=""/><div class="controls bullet"><span class="by">zeehio</span><span>|</span><a href="#39111990">prev</a><span>|</span><a href="#39108461">next</a><span>|</span><label class="collapse" for="c-39109578">[-]</label><label class="expand" for="c-39109578">[4 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t there a BLAS equivalent in go that could help here?</div><br/><div id="39110093" class="c"><input type="checkbox" id="c-39110093" checked=""/><div class="controls bullet"><span class="by">camdencheek</span><span>|</span><a href="#39109578">parent</a><span>|</span><a href="#39108461">next</a><span>|</span><label class="collapse" for="c-39110093">[-]</label><label class="expand" for="c-39110093">[3 more]</label></div><br/><div class="children"><div class="content">Copying in a response to a similar question on Reddit:<p>I should really add some discussion around BLAS in particular, which has an good implementation[0] of the float32 dot product that outperforms any of the float32 implementations in the blog post. I&#x27;m getting ~1.9m vecs&#x2F;s on my benchmarking rig.<p>However, that BLAS became unusable for us as soon as we switched to quantized vectors because there is no int8 implementation of the dot product in BLAS (though I&#x27;d love to be proven wrong)<p>[0]: <a href="https:&#x2F;&#x2F;pkg.go.dev&#x2F;gonum.org&#x2F;v1&#x2F;gonum@v0.14.0&#x2F;blas&#x2F;blas32#Dot" rel="nofollow">https:&#x2F;&#x2F;pkg.go.dev&#x2F;gonum.org&#x2F;v1&#x2F;gonum@v0.14.0&#x2F;blas&#x2F;blas32#Do...</a></div><br/><div id="39110378" class="c"><input type="checkbox" id="c-39110378" checked=""/><div class="controls bullet"><span class="by">mkhnews</span><span>|</span><a href="#39109578">root</a><span>|</span><a href="#39110093">parent</a><span>|</span><a href="#39108461">next</a><span>|</span><label class="collapse" for="c-39110378">[-]</label><label class="expand" for="c-39110378">[2 more]</label></div><br/><div class="children"><div class="content">OpenBLAS with INTERFACE64=1 ??</div><br/><div id="39110494" class="c"><input type="checkbox" id="c-39110494" checked=""/><div class="controls bullet"><span class="by">camdencheek</span><span>|</span><a href="#39109578">root</a><span>|</span><a href="#39110378">parent</a><span>|</span><a href="#39108461">next</a><span>|</span><label class="collapse" for="c-39110494">[-]</label><label class="expand" for="c-39110494">[1 more]</label></div><br/><div class="children"><div class="content">AFAICT, that still doesn&#x27;t support 8-bit integer dot product? (To clarify, I was using int8 to mean 8-bit integer, not 8-byte)</div><br/></div></div></div></div></div></div></div></div><div id="39108461" class="c"><input type="checkbox" id="c-39108461" checked=""/><div class="controls bullet"><span class="by">koala_man</span><span>|</span><a href="#39109578">prev</a><span>|</span><label class="collapse" for="c-39108461">[-]</label><label class="expand" for="c-39108461">[17 more]</label></div><br/><div class="children"><div class="content">TIL that the Go compiler still does not have autovectorization.</div><br/><div id="39108825" class="c"><input type="checkbox" id="c-39108825" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#39108461">parent</a><span>|</span><a href="#39108789">next</a><span>|</span><label class="collapse" for="c-39108825">[-]</label><label class="expand" for="c-39108825">[4 more]</label></div><br/><div class="children"><div class="content">Is it really worth the trouble if you&#x27;re not building on top of something like LLVM which already has a vectorizer? We&#x27;re still waiting for the mythical sufficiently-smart-vectorizer, even the better ones are still extremely brittle, and any serious high-performance work still does explicit SIMD rather than trying to coax the vectorizer into cooperating.<p>I&#x27;d rather see new languages focus on making better explicit SIMD abstractions a la Intels ISPC, rather than writing yet another magic vectorizer that only actually works in trivial cases.</div><br/><div id="39109336" class="c"><input type="checkbox" id="c-39109336" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#39108461">root</a><span>|</span><a href="#39108825">parent</a><span>|</span><a href="#39109916">next</a><span>|</span><label class="collapse" for="c-39109336">[-]</label><label class="expand" for="c-39109336">[1 more]</label></div><br/><div class="children"><div class="content">any of the polyhedral frameworks is reasonably good at splitting loop nests into parallelizable ones.<p>Then it&#x27;s just a codegen problem.<p>But yes, ultimately, the user needs to be aware of how the language works, what is parallelizable and what isn&#x27;t, and of the cost of the operations that they ask their computer to execute.</div><br/></div></div><div id="39109916" class="c"><input type="checkbox" id="c-39109916" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#39108461">root</a><span>|</span><a href="#39108825">parent</a><span>|</span><a href="#39109336">prev</a><span>|</span><a href="#39108789">next</a><span>|</span><label class="collapse" for="c-39109916">[-]</label><label class="expand" for="c-39109916">[2 more]</label></div><br/><div class="children"><div class="content">C# is doing that :)<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;api&#x2F;system.runtime.intrinsics?view=net-8.0" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;api&#x2F;system.runtime....</a><p>Examples of usage:<p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;U8String&#x2F;U8String&#x2F;blob&#x2F;main&#x2F;Sources&#x2F;U8String&#x2F;Shared&#x2F;U8Searching.cs#L489-L551">https:&#x2F;&#x2F;github.com&#x2F;U8String&#x2F;U8String&#x2F;blob&#x2F;main&#x2F;Sources&#x2F;U8Str...</a><p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;nietras&#x2F;1brc.cs&#x2F;blob&#x2F;main&#x2F;src&#x2F;Brc&#x2F;BrcAccumulator.cs#L49-L116">https:&#x2F;&#x2F;github.com&#x2F;nietras&#x2F;1brc.cs&#x2F;blob&#x2F;main&#x2F;src&#x2F;Brc&#x2F;BrcAccu...</a><p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;runtime&#x2F;blob&#x2F;main&#x2F;src&#x2F;libraries&#x2F;System.Private.CoreLib&#x2F;src&#x2F;System&#x2F;Buffers&#x2F;Text&#x2F;Base64Encoder.cs#L241-L310">https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;runtime&#x2F;blob&#x2F;main&#x2F;src&#x2F;libraries&#x2F;Sy...</a><p>(and many more if you search github for the uses of Vector128&#x2F;256&lt;byte&gt; and the like!)</div><br/><div id="39114341" class="c"><input type="checkbox" id="c-39114341" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39108461">root</a><span>|</span><a href="#39109916">parent</a><span>|</span><a href="#39108789">next</a><span>|</span><label class="collapse" for="c-39114341">[-]</label><label class="expand" for="c-39114341">[1 more]</label></div><br/><div class="children"><div class="content">Java as well, unfortunelly it will be kept around as preview until Valhala arrives (if ever).</div><br/></div></div></div></div></div></div><div id="39108789" class="c"><input type="checkbox" id="c-39108789" checked=""/><div class="controls bullet"><span class="by">hoten</span><span>|</span><a href="#39108461">parent</a><span>|</span><a href="#39108825">prev</a><span>|</span><a href="#39111249">next</a><span>|</span><label class="collapse" for="c-39108789">[-]</label><label class="expand" for="c-39108789">[1 more]</label></div><br/><div class="children"><div class="content">Maybe a hidden blessing. Just ran into a nasty MSVC auto vectorization bug. Apparently it&#x27;s hard to get right.<p><a href="https:&#x2F;&#x2F;developercommunity.visualstudio.com&#x2F;t&#x2F;Bad-codegen-during-auto-vectorization-a&#x2F;10563619" rel="nofollow">https:&#x2F;&#x2F;developercommunity.visualstudio.com&#x2F;t&#x2F;Bad-codegen-du...</a></div><br/></div></div><div id="39111249" class="c"><input type="checkbox" id="c-39111249" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#39108461">parent</a><span>|</span><a href="#39108789">prev</a><span>|</span><a href="#39108629">next</a><span>|</span><label class="collapse" for="c-39111249">[-]</label><label class="expand" for="c-39111249">[2 more]</label></div><br/><div class="children"><div class="content">I never do this kind of work so I canât say. But if I did, Iâd imagine I want more control. I mean, perf improvements are welcome to all code, but if I <i>need</i> a piece of code to have a specific optimization Iâd rather opt-in <i>through</i> language constructs, so that the compiler (or other tooling) can tell me when it breaks. A well designed API with adapters from and to regular code would be better, no?<p>For instance, imagine I have auto-perf something and I check (manually mind you) the asm and all is good. Then someone changes the algorithm slightly, or another engineer adds a layer of indirection for some unrelated purpose, or maybe the compiler updates its code paths which misses some cases that were previously supported. And the optimization goes away silently.</div><br/><div id="39113899" class="c"><input type="checkbox" id="c-39113899" checked=""/><div class="controls bullet"><span class="by">koala_man</span><span>|</span><a href="#39108461">root</a><span>|</span><a href="#39111249">parent</a><span>|</span><a href="#39108629">next</a><span>|</span><label class="collapse" for="c-39113899">[-]</label><label class="expand" for="c-39113899">[1 more]</label></div><br/><div class="children"><div class="content">Do you have the same view of other compiler optimizations? Would you prefer if the compiler never unrolled a loop so that you can write it out manually when you need it?</div><br/></div></div></div></div><div id="39108629" class="c"><input type="checkbox" id="c-39108629" checked=""/><div class="controls bullet"><span class="by">mcronce</span><span>|</span><a href="#39108461">parent</a><span>|</span><a href="#39111249">prev</a><span>|</span><a href="#39109868">next</a><span>|</span><label class="collapse" for="c-39108629">[-]</label><label class="expand" for="c-39108629">[2 more]</label></div><br/><div class="children"><div class="content">They still don&#x27;t have a register-based calling convention on architectures other than x86-64, right?  Or is that information out of date?</div><br/><div id="39108729" class="c"><input type="checkbox" id="c-39108729" checked=""/><div class="controls bullet"><span class="by">mseepgood</span><span>|</span><a href="#39108461">root</a><span>|</span><a href="#39108629">parent</a><span>|</span><a href="#39109868">next</a><span>|</span><label class="collapse" for="c-39108729">[-]</label><label class="expand" for="c-39108729">[1 more]</label></div><br/><div class="children"><div class="content">That information is out of date: ARM64, PPC, RISC-V
<a href="https:&#x2F;&#x2F;go.dev&#x2F;src&#x2F;cmd&#x2F;compile&#x2F;abi-internal" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;src&#x2F;cmd&#x2F;compile&#x2F;abi-internal</a></div><br/></div></div></div></div><div id="39109868" class="c"><input type="checkbox" id="c-39109868" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#39108461">parent</a><span>|</span><a href="#39108629">prev</a><span>|</span><a href="#39110319">next</a><span>|</span><label class="collapse" for="c-39109868">[-]</label><label class="expand" for="c-39109868">[5 more]</label></div><br/><div class="children"><div class="content">Even manual vectorization is pain...writing ASM, really?<p>Rust has unstable portable SIMD and a few third-party crates, C++ has that as well, C# has <i>stable</i> portable SIMD and a small out of box BLAS-like library to help with most common tasks (like SoftMax, Magnitude and etc. on top of spans of floats over writing manually), hell it even exercises PackedSIMD when ran in a browser. And now Java is getting Panama vectors some time in the future (though the question of codegen quality stands open given planned changes to unsafe API).<p>Go among these is uniquely disadvantaged. And if that&#x27;s not enough, you may want to visit 1Brc&#x27;s challenge discussions and see that Go <i>struggles</i> to get anywhere close to 2s mark with both C# and C++ blazing past it:<p><a href="https:&#x2F;&#x2F;hotforknowledge.com&#x2F;2024&#x2F;01&#x2F;13&#x2F;1brc-in-dotnet-among-fastest-on-linux-my-optimization-journey&#x2F;#results-table" rel="nofollow">https:&#x2F;&#x2F;hotforknowledge.com&#x2F;2024&#x2F;01&#x2F;13&#x2F;1brc-in-dotnet-among-...</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;gunnarmorling&#x2F;1brc&#x2F;discussions&#x2F;67">https:&#x2F;&#x2F;github.com&#x2F;gunnarmorling&#x2F;1brc&#x2F;discussions&#x2F;67</a></div><br/><div id="39112601" class="c"><input type="checkbox" id="c-39112601" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#39108461">root</a><span>|</span><a href="#39109868">parent</a><span>|</span><a href="#39112281">next</a><span>|</span><label class="collapse" for="c-39112601">[-]</label><label class="expand" for="c-39112601">[2 more]</label></div><br/><div class="children"><div class="content">Panama vectors are extremely disappointing. ByteVector.rearrange in particular takes like 10ns and is the only available way to implement vpshufb, an instruction that takes 1 cycle. Operations like andnot don&#x27;t just use the andnot instruction. Converting a 32-wide vector that the type system thinks is a mask into a vector uses a blend instead of using 0 instructions. Fixed rearranges like packus are missing. Arithmetic operations that are not simple lane-wise operations like maddubs are missing. aesenc is missing. Non-temporal stores and non-temporal prefetches are missing (there is a non-temporal load instruction but apparently it doesn&#x27;t do anything differently from a normal load, so if you want to move data to L1d skipping other caches you have to use the prefetch).</div><br/><div id="39114350" class="c"><input type="checkbox" id="c-39114350" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39108461">root</a><span>|</span><a href="#39112601">parent</a><span>|</span><a href="#39112281">next</a><span>|</span><label class="collapse" for="c-39114350">[-]</label><label class="expand" for="c-39114350">[1 more]</label></div><br/><div class="children"><div class="content">Panama vectors are still in preview anyway.</div><br/></div></div></div></div><div id="39112281" class="c"><input type="checkbox" id="c-39112281" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#39108461">root</a><span>|</span><a href="#39109868">parent</a><span>|</span><a href="#39112601">prev</a><span>|</span><a href="#39110319">next</a><span>|</span><label class="collapse" for="c-39112281">[-]</label><label class="expand" for="c-39112281">[2 more]</label></div><br/><div class="children"><div class="content">5sec for simple and readable code: <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;corlinp&#x2F;176a97c58099bca36bcd5679e68f9708" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;corlinp&#x2F;176a97c58099bca36bcd5679e68f...</a><p>Have you seen the 2sec code from c#?</div><br/><div id="39112860" class="c"><input type="checkbox" id="c-39112860" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#39108461">root</a><span>|</span><a href="#39112281">parent</a><span>|</span><a href="#39110319">next</a><span>|</span><label class="collapse" for="c-39112860">[-]</label><label class="expand" for="c-39112860">[1 more]</label></div><br/><div class="children"><div class="content">These numbers aren&#x27;t comparable. This golang solution is likely much more than 2.5x slower if you run them on the same hardware.</div><br/></div></div></div></div></div></div><div id="39110319" class="c"><input type="checkbox" id="c-39110319" checked=""/><div class="controls bullet"><span class="by">icholy</span><span>|</span><a href="#39108461">parent</a><span>|</span><a href="#39109868">prev</a><span>|</span><a href="#39111358">next</a><span>|</span><label class="collapse" for="c-39110319">[-]</label><label class="expand" for="c-39110319">[1 more]</label></div><br/><div class="children"><div class="content">Last time I checked, it didn&#x27;t even unroll loops.</div><br/></div></div></div></div></div></div></div></div></div></body></html>