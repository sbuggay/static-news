<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1735722057169" as="style"/><link rel="stylesheet" href="styles.css?v=1735722057169"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://unity.com/blog/engine-platform/debugging-memory-debugging-memory-corruption-who-wrote-2-into-my-stack-who-the-hell">Debugging memory corruption: who the hell writes &quot;2&quot; into my stack? (2016)</a> <span class="domain">(<a href="https://unity.com">unity.com</a>)</span></div><div class="subtext"><span>pierremenard</span> | <span>153 comments</span></div><br/><div><div id="42559499" class="c"><input type="checkbox" id="c-42559499" checked=""/><div class="controls bullet"><span class="by">dahart</span><span>|</span><a href="#42559083">next</a><span>|</span><label class="collapse" for="c-42559499">[-]</label><label class="expand" for="c-42559499">[9 more]</label></div><br/><div class="children"><div class="content">It’s been more than a decade since I worked in games, but for my entire games career, any and all use of C++ exceptions was strictly disallowed due to other horror stories. I was still bit in a very similar way by someone’s C++ copy constructor trickery - a crash that only happened in a release build after playing the game for a while, with a stack corruption. Like the author, for me this was one of the hardest bugs I ever had to track down, and I ended up writing a tiny release mode debugger that logged call stacks in order to do it. Once I was able to catch the corruption (after several days of debugging during a crunch weekend), someone on my team noticed the stomp values looked like floating point numbers, and pretty quickly we figured out it was coming from the matrix class trying to be too clever with it’s reference counting IIRC. There’d been a team of around a dozen people trying to track this down during overtime, so it suddenly hit me once we fixed it that someone’s cute idea that took maybe 10 seconds to write cost several tens of thousands of dollars to fix.</div><br/><div id="42560376" class="c"><input type="checkbox" id="c-42560376" checked=""/><div class="controls bullet"><span class="by">intelVISA</span><span>|</span><a href="#42559499">parent</a><span>|</span><a href="#42560296">next</a><span>|</span><label class="collapse" for="c-42560376">[-]</label><label class="expand" for="c-42560376">[3 more]</label></div><br/><div class="children"><div class="content">Clever code is always expensive, either you&#x27;re paying for somebody smart to work at their cognitive peak which is less productive for them than &#x27;simpler&#x27; code, or more likely you&#x27;ll instead pay multiples more down the line for someone&#x27;s hubris.<p>I think this is the rare direction that more langs should follow Rust in that &#x27;clever&#x27; code can be more easily quarantined for scrutiny via unsafe.</div><br/><div id="42561552" class="c"><input type="checkbox" id="c-42561552" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42559499">root</a><span>|</span><a href="#42560376">parent</a><span>|</span><a href="#42562800">next</a><span>|</span><label class="collapse" for="c-42561552">[-]</label><label class="expand" for="c-42561552">[1 more]</label></div><br/><div class="children"><div class="content">The time when people see this the clearest is during an outage. You’re in a stressful situation and it’s being made worse and longer by clever code. Do you see now why maybe clever code isn’t a good idea?<p>Cortisol actually reduces the effectiveness of working memory. Write your code like someone looking at it is already having a bad day, because not only are odds very good they will be, but that’s the costliest time for them to be looking at it. Probability x consequences.</div><br/></div></div></div></div><div id="42560296" class="c"><input type="checkbox" id="c-42560296" checked=""/><div class="controls bullet"><span class="by">ziml77</span><span>|</span><a href="#42559499">parent</a><span>|</span><a href="#42560376">prev</a><span>|</span><a href="#42561529">next</a><span>|</span><label class="collapse" for="c-42560296">[-]</label><label class="expand" for="c-42560296">[4 more]</label></div><br/><div class="children"><div class="content">This could still happen without exceptions though, right? The flow is more explicit without exceptions, but returning an error code up the stack would have the same effect of causing the memory that select() is referencing to possibly be used for a different purpose when it writes its result.</div><br/><div id="42560362" class="c"><input type="checkbox" id="c-42560362" checked=""/><div class="controls bullet"><span class="by">mark_undoio</span><span>|</span><a href="#42559499">root</a><span>|</span><a href="#42560296">parent</a><span>|</span><a href="#42561194">next</a><span>|</span><label class="collapse" for="c-42560362">[-]</label><label class="expand" for="c-42560362">[1 more]</label></div><br/><div class="children"><div class="content">My reading is that the problem was specifically that they were injecting an exception to recover control from the C library back to their code.<p>It seems like the select() was within its rights to have passed a stack allocated buffer to be written asynchronously by the kernel since it, presumably, knew it couldn&#x27;t encounter any exceptions.  But injecting one has broken that assumption.<p>If the select() implementation had returned normally with an error or was expecting then I&#x27;d assume this wouldn&#x27;t have happened.</div><br/></div></div><div id="42561194" class="c"><input type="checkbox" id="c-42561194" checked=""/><div class="controls bullet"><span class="by">tom_</span><span>|</span><a href="#42559499">root</a><span>|</span><a href="#42560296">parent</a><span>|</span><a href="#42560362">prev</a><span>|</span><a href="#42561529">next</a><span>|</span><label class="collapse" for="c-42561194">[-]</label><label class="expand" for="c-42561194">[2 more]</label></div><br/><div class="children"><div class="content">There are no error returns from an APC? The return type is void and the system expects the routine (whatever it is) to return: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;api&#x2F;winnt&#x2F;nc-winnt-papcfunc" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;api&#x2F;winnt&#x2F;nc...</a> - whichever call put the process in the alertable wait state then ends up returning early. This is a little bit like the Win32 analogue of POSIX signal handlers and EINTR, I suppose.</div><br/><div id="42562885" class="c"><input type="checkbox" id="c-42562885" checked=""/><div class="controls bullet"><span class="by">ziml77</span><span>|</span><a href="#42559499">root</a><span>|</span><a href="#42561194">parent</a><span>|</span><a href="#42561529">next</a><span>|</span><label class="collapse" for="c-42562885">[-]</label><label class="expand" for="c-42562885">[1 more]</label></div><br/><div class="children"><div class="content">Oh I see my confusion. I misunderstood how the APC fit in. Now it makes sense why specifically an exception was problematic.</div><br/></div></div></div></div></div></div><div id="42561529" class="c"><input type="checkbox" id="c-42561529" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42559499">parent</a><span>|</span><a href="#42560296">prev</a><span>|</span><a href="#42559083">next</a><span>|</span><label class="collapse" for="c-42561529">[-]</label><label class="expand" for="c-42561529">[1 more]</label></div><br/><div class="children"><div class="content">I appreciate the notion of Grug Brained development but at the end of the day it’s just a slightly sardonic restatement of Kernighan’s Law, which is easier to get people to buy into in negotiations.<p>Grug brain is maybe good for 1:1 interactions or over coffee with the people you vent to or are vented to.</div><br/></div></div></div></div><div id="42559083" class="c"><input type="checkbox" id="c-42559083" checked=""/><div class="controls bullet"><span class="by">bjornsing</span><span>|</span><a href="#42559499">prev</a><span>|</span><a href="#42561112">next</a><span>|</span><label class="collapse" for="c-42559083">[-]</label><label class="expand" for="c-42559083">[2 more]</label></div><br/><div class="children"><div class="content">Back in the day I used to consult for Sony Ericsson. We had like 5000 engineers writing C code that ran as a single executable in a single address space(!). Memory corruption was rampant. So rampant in fact that when we finally got an MMU it took months before we could turn it on in release builds, because there were so many memory corruption bugs even in the released product. The software just wouldn’t work unless it could overwrite memory here and there.</div><br/><div id="42559604" class="c"><input type="checkbox" id="c-42559604" checked=""/><div class="controls bullet"><span class="by">farmdve</span><span>|</span><a href="#42559083">parent</a><span>|</span><a href="#42561112">next</a><span>|</span><label class="collapse" for="c-42559604">[-]</label><label class="expand" for="c-42559604">[1 more]</label></div><br/><div class="children"><div class="content">I remember back in the day of the Sony Satio U1, the last Symbian v5 phone, the software was horrendous(screen tearing, random OS freezes) and later, the phone abandoned. I think it was afterwards that Sony and Ericsson split?</div><br/></div></div></div></div><div id="42561112" class="c"><input type="checkbox" id="c-42561112" checked=""/><div class="controls bullet"><span class="by">jacinda</span><span>|</span><a href="#42559083">prev</a><span>|</span><a href="#42558466">next</a><span>|</span><label class="collapse" for="c-42561112">[-]</label><label class="expand" for="c-42561112">[6 more]</label></div><br/><div class="children"><div class="content">Related (and hilarious): <a href="https:&#x2F;&#x2F;scholar.harvard.edu&#x2F;files&#x2F;mickens&#x2F;files&#x2F;thenightwatch.pdf" rel="nofollow">https:&#x2F;&#x2F;scholar.harvard.edu&#x2F;files&#x2F;mickens&#x2F;files&#x2F;thenightwatc...</a><p>&gt; What is despair? I have known it—hear my song. Despair is
when you’re debugging a kernel driver and you look at a memory dump and you see that a pointer has a value of 7. THERE IS
NO HARDWARE ARCHITECTURE THAT IS ALIGNED ON
7. Furthermore, 7 IS TOO SMALL AND ONLY EVIL CODE
WOULD TRY TO ACCESS SMALL NUMBER MEMORY.
Misaligned, small-number memory accesses have stolen
decades from my life.<p>All James Mickens&#x27; USENIX articles are fun (for a very specific subset of computer scientist - the kind that would comment on this thread). <a href="https:&#x2F;&#x2F;mickens.seas.harvard.edu&#x2F;wisdom-james-mickens" rel="nofollow">https:&#x2F;&#x2F;mickens.seas.harvard.edu&#x2F;wisdom-james-mickens</a></div><br/><div id="42561588" class="c"><input type="checkbox" id="c-42561588" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42561112">parent</a><span>|</span><a href="#42562046">next</a><span>|</span><label class="collapse" for="c-42561588">[-]</label><label class="expand" for="c-42561588">[3 more]</label></div><br/><div class="children"><div class="content">I don’t know if it’s still a thing but there used to be debugging tools that would put a page of memory marked as either read only or unreadable in front of every malloc call so that any pointer arithmetic with a math error would trigger a page fault which could be debugged. It worked in apps that didn’t use too much of total memory or too many fine grained allocations. I mean obviously turning every 8 byte pointer into a whole memory page could consume all of memory very quickly. But in front of arrays or large data structures that could work.</div><br/><div id="42563852" class="c"><input type="checkbox" id="c-42563852" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#42561112">root</a><span>|</span><a href="#42561588">parent</a><span>|</span><a href="#42562046">next</a><span>|</span><label class="collapse" for="c-42563852">[-]</label><label class="expand" for="c-42563852">[2 more]</label></div><br/><div class="children"><div class="content">In this case the write bypassed page protections</div><br/><div id="42564185" class="c"><input type="checkbox" id="c-42564185" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#42561112">root</a><span>|</span><a href="#42563852">parent</a><span>|</span><a href="#42562046">next</a><span>|</span><label class="collapse" for="c-42564185">[-]</label><label class="expand" for="c-42564185">[1 more]</label></div><br/><div class="children"><div class="content">It shouldn&#x27;t bypass page protections, that would be a kernel bug. And quite a bit harder to achieve too, since the kernel would still be using the same virtual address mapping as user space there.</div><br/></div></div></div></div></div></div><div id="42562046" class="c"><input type="checkbox" id="c-42562046" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#42561112">parent</a><span>|</span><a href="#42561588">prev</a><span>|</span><a href="#42558466">next</a><span>|</span><label class="collapse" for="c-42562046">[-]</label><label class="expand" for="c-42562046">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand. Pointers aren&#x27;t numbers, and can only be compared when inside a common array. What is small number memory?<p>:-)</div><br/><div id="42562463" class="c"><input type="checkbox" id="c-42562463" checked=""/><div class="controls bullet"><span class="by">MobiusHorizons</span><span>|</span><a href="#42561112">root</a><span>|</span><a href="#42562046">parent</a><span>|</span><a href="#42558466">next</a><span>|</span><label class="collapse" for="c-42562463">[-]</label><label class="expand" for="c-42562463">[1 more]</label></div><br/><div class="children"><div class="content">I realize you are probably referring to UB in c&#x2F;c++, but of course in hardware memory addresses are numbers. And when debugging, it’s really the hardware version of events that matters, since the compiler has already done whatever optimizations it wants.</div><br/></div></div></div></div></div></div><div id="42558466" class="c"><input type="checkbox" id="c-42558466" checked=""/><div class="controls bullet"><span class="by">alexvitkov</span><span>|</span><a href="#42561112">prev</a><span>|</span><a href="#42561575">next</a><span>|</span><label class="collapse" for="c-42558466">[-]</label><label class="expand" for="c-42558466">[5 more]</label></div><br/><div class="children"><div class="content">&gt; The project was quite big (although far from the largest ones); it took 40 minutes to build on my machine.<p>A bit tangential, but I&#x27;ve been crying about the insane Unity project build times for years now, and about how they&#x27;ve taken zero steps to fix them and are instead trying their hardest to sell you cloud builds. Glad to see them having to suffer through what they&#x27;re inflicting on us for once!<p>Regardless, very good writeup, and yet another reason to never ever under any conditions use exceptions.</div><br/><div id="42564684" class="c"><input type="checkbox" id="c-42564684" checked=""/><div class="controls bullet"><span class="by">voidUpdate</span><span>|</span><a href="#42558466">parent</a><span>|</span><a href="#42560047">next</a><span>|</span><label class="collapse" for="c-42564684">[-]</label><label class="expand" for="c-42564684">[1 more]</label></div><br/><div class="children"><div class="content">hey, at least its not unreal, where when you build it sits there compiling tens of thousands of shaders</div><br/></div></div><div id="42560047" class="c"><input type="checkbox" id="c-42560047" checked=""/><div class="controls bullet"><span class="by">yard2010</span><span>|</span><a href="#42558466">parent</a><span>|</span><a href="#42564684">prev</a><span>|</span><a href="#42559993">next</a><span>|</span><label class="collapse" for="c-42560047">[-]</label><label class="expand" for="c-42560047">[1 more]</label></div><br/><div class="children"><div class="content">This poor human being doesn&#x27;t deserve to pay the price for the shitty middle management actions though :(</div><br/></div></div><div id="42559993" class="c"><input type="checkbox" id="c-42559993" checked=""/><div class="controls bullet"><span class="by">noitpmeder</span><span>|</span><a href="#42558466">parent</a><span>|</span><a href="#42560047">prev</a><span>|</span><a href="#42561575">next</a><span>|</span><label class="collapse" for="c-42559993">[-]</label><label class="expand" for="c-42559993">[2 more]</label></div><br/><div class="children"><div class="content">Would a ccache or similar help alleviate the pain?</div><br/></div></div></div></div><div id="42561575" class="c"><input type="checkbox" id="c-42561575" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#42558466">prev</a><span>|</span><a href="#42564601">next</a><span>|</span><label class="collapse" for="c-42561575">[-]</label><label class="expand" for="c-42561575">[6 more]</label></div><br/><div class="children"><div class="content">This kind of error is a right of passage with WIN32 programming. For example, to do nontrivial i&#x2F;o on Windows you have to create an OVERLAPPED object and give it to ReadFile() and WriteFile() which will return a pending status code, and write back to your OVERLAPPED object once the i&#x2F;o has completed. Usually it makes the most sense to put that object on the stack. So if you return from your function without making sure WIN32 is done with that object, you&#x27;re going to end up with bugs like this one. You have to call GetOverlappedResult() to do that. That means no throwing or returning until you do. Even if you call CancelIoEx() beforehand, you still need to call the result function. When you mix all that up with your WaitForMultipleObjects() call, it ends up being a whole lot of if statements you could easily get wrong if the ritual isn&#x27;t burned into your brain.<p>UNIX system calls never do this. The kernel won&#x27;t keep references to pointers you pass them and write to them later. It just isn&#x27;t in the DNA. The only exceptions I can think of would be clone(), which is abstracted by the POSIX threads runtime, and Windows-inspired non-standard event i&#x2F;o system calls like epoll.</div><br/><div id="42561680" class="c"><input type="checkbox" id="c-42561680" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#42561575">parent</a><span>|</span><a href="#42564601">next</a><span>|</span><label class="collapse" for="c-42561680">[-]</label><label class="expand" for="c-42561680">[5 more]</label></div><br/><div class="children"><div class="content">&gt; UNIX system calls never do this. The kernel won&#x27;t keep references to pointers you pass them and write to them later. It just isn&#x27;t in the DNA. The only exceptions I can think of would be clone(), which is abstracted by the POSIX threads runtime, and Windows-inspired non-standard system calls like epoll.<p>I mean, this is because the UNIX model was based on readiness rather than completion. Which is slower. Hence the newer I&#x2F;O models.</div><br/><div id="42562375" class="c"><input type="checkbox" id="c-42562375" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#42561575">root</a><span>|</span><a href="#42561680">parent</a><span>|</span><a href="#42562133">next</a><span>|</span><label class="collapse" for="c-42562375">[-]</label><label class="expand" for="c-42562375">[1 more]</label></div><br/><div class="children"><div class="content">There are evented I&#x2F;O APIs for Unix, though anything other than select(2) and poll(2) is non-standard, and while some do let you use pointer-sized user cookies to identify the events I&#x27;ve never seen a case where a programmer used a stack address as a cookie.  I <i>have</i> seen cases where the address used as the cookie was freed before the event registration was deleted, or before it fired, leading to use-after-free bugs.</div><br/></div></div><div id="42562133" class="c"><input type="checkbox" id="c-42562133" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#42561575">root</a><span>|</span><a href="#42561680">parent</a><span>|</span><a href="#42562375">prev</a><span>|</span><a href="#42564601">next</a><span>|</span><label class="collapse" for="c-42562133">[-]</label><label class="expand" for="c-42562133">[3 more]</label></div><br/><div class="children"><div class="content">System calls take 10x longer on Windows than they do on UNIX.<p>That&#x27;s what i&#x2F;o completion ports are working around.<p>They solve a problem UNIX doesn&#x27;t have.</div><br/><div id="42563603" class="c"><input type="checkbox" id="c-42563603" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#42561575">root</a><span>|</span><a href="#42562133">parent</a><span>|</span><a href="#42563855">next</a><span>|</span><label class="collapse" for="c-42563603">[-]</label><label class="expand" for="c-42563603">[1 more]</label></div><br/><div class="children"><div class="content">No, IOCP is not a workaround for syscall overhead. In fact this performance hit has nothing to do with syscall overhead. The overhead is O(1). The penalty of the readiness design is O(n). Because if the system can&#x27;t copy into your n-byte buffer in the background, then you gotta block for O(n) time to memcpy it yourself.</div><br/></div></div><div id="42563855" class="c"><input type="checkbox" id="c-42563855" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#42561575">root</a><span>|</span><a href="#42562133">parent</a><span>|</span><a href="#42563603">prev</a><span>|</span><a href="#42564601">next</a><span>|</span><label class="collapse" for="c-42563855">[-]</label><label class="expand" for="c-42563855">[1 more]</label></div><br/><div class="children"><div class="content">You do realize io_uring exists for a reason, right?</div><br/></div></div></div></div></div></div></div></div><div id="42560596" class="c"><input type="checkbox" id="c-42560596" checked=""/><div class="controls bullet"><span class="by">rectang</span><span>|</span><a href="#42564601">prev</a><span>|</span><a href="#42558203">next</a><span>|</span><label class="collapse" for="c-42560596">[-]</label><label class="expand" for="c-42560596">[21 more]</label></div><br/><div class="children"><div class="content">After trying and failing over several days to track down a squirrely segfault in a C project about 15 years ago, I taught myself Valgrind in order to debug the issue.<p>Valgrind flagged an &quot;invalid write&quot;, which I eventually hunted down as a fencepost error in a dependency which overwrote their allocated stack array by one byte.  I recall that it wrote &quot;1&quot; rather than &quot;2&quot;, though, haha.<p>&gt; <i>Lesson learnt, folks: do not throw exceptions out of asynchronous procedures if you’re inside a system call!</i><p>The author&#x27;s debugging skills are impressive and significantly better than mine, but I find this an unsatisfying takeaway.  I yearn for a systemic approach to either prevent such issues altogether or to make them less difficult to troubleshoot.  The general solution is to move away from C&#x2F;C++ to memory safe languages whenever possible, but such choices are of course not always realistic.<p>With my project, I started running most of the test suite under Valgrind periodically.  That took took half an hour to finish rather than a few seconds, but it caught many similar memory corruption issues over the next few years.</div><br/><div id="42561500" class="c"><input type="checkbox" id="c-42561500" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#42560596">parent</a><span>|</span><a href="#42561318">next</a><span>|</span><label class="collapse" for="c-42561500">[-]</label><label class="expand" for="c-42561500">[11 more]</label></div><br/><div class="children"><div class="content">No the solution isn&#x27;t to rewrite it in Rust. The solution is to have the option of compiling your C&#x2F;C++ program with memory safety whenever things go loopy. ASAN, MSAN, and UBSAN are one great way to do that. Another up and coming solution that promises even more memory safety is Fil-C which is being made by Epic Games. <a href="https:&#x2F;&#x2F;github.com&#x2F;pizlonator&#x2F;llvm-project-deluge&#x2F;blob&#x2F;deluge&#x2F;Manifesto.md">https:&#x2F;&#x2F;github.com&#x2F;pizlonator&#x2F;llvm-project-deluge&#x2F;blob&#x2F;delug...</a></div><br/><div id="42562110" class="c"><input type="checkbox" id="c-42562110" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#42560596">root</a><span>|</span><a href="#42561500">parent</a><span>|</span><a href="#42561591">next</a><span>|</span><label class="collapse" for="c-42562110">[-]</label><label class="expand" for="c-42562110">[3 more]</label></div><br/><div class="children"><div class="content">Ubsan is fantastic, but ASAN and the rest have serious caveats. They&#x27;re not suitable for production use and they have a tendency to break in mysterious, intermittent ways. For example, Ubuntu 24.04 unknowingly broke Clang &lt;=15ish when it increased mmap_rnd_bits. ASAN on Windows will actually check if you have ASLR enabled, disable it, and restart at entry. They interact in fun ways with LD_PRELOAD too.</div><br/><div id="42562980" class="c"><input type="checkbox" id="c-42562980" checked=""/><div class="controls bullet"><span class="by">james_promoted</span><span>|</span><a href="#42560596">root</a><span>|</span><a href="#42562110">parent</a><span>|</span><a href="#42561591">next</a><span>|</span><label class="collapse" for="c-42562980">[-]</label><label class="expand" for="c-42562980">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m on Clang 19 and still have a bunch of those sysctl commands sitting around.</div><br/><div id="42563134" class="c"><input type="checkbox" id="c-42563134" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#42560596">root</a><span>|</span><a href="#42562980">parent</a><span>|</span><a href="#42561591">next</a><span>|</span><label class="collapse" for="c-42563134">[-]</label><label class="expand" for="c-42563134">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not in a position to look up exactly when it was merged, but I&#x27;m pretty confident that shouldn&#x27;t be needed anymore. The entry point on 19 should do the same restart juggling it does on Windows if the environment isn&#x27;t correct for some other reason. I can double check later if you want to provide details.<p>I encountered the issue when our (not Ubuntu, not 24.04) LTS upstream backported security fixes that included the mmap changes without updating universe to include a clang version with the fixes. Any developers diligent enough to update and run sanitisers locally started seeing intermittent crashes.</div><br/></div></div></div></div></div></div><div id="42561591" class="c"><input type="checkbox" id="c-42561591" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42560596">root</a><span>|</span><a href="#42561500">parent</a><span>|</span><a href="#42562110">prev</a><span>|</span><a href="#42563867">next</a><span>|</span><label class="collapse" for="c-42561591">[-]</label><label class="expand" for="c-42561591">[6 more]</label></div><br/><div class="children"><div class="content">The solution is usually not to do a rewrite, but I think for greenfield projects we should stop using C or C++ unless there is a compelling reason to do so. Memory-safe systems languages are available today; IMO it&#x27;s professionally irresponsible to not use them, without a good reason.<p>MSAN, ASAN, and UBSAN are great tools that have saved me a lot of time and headaches, but they don&#x27;t catch everything that the compiler of a memory safe language can, at least not today.</div><br/><div id="42561760" class="c"><input type="checkbox" id="c-42561760" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#42560596">root</a><span>|</span><a href="#42561591">parent</a><span>|</span><a href="#42563867">next</a><span>|</span><label class="collapse" for="c-42561760">[-]</label><label class="expand" for="c-42561760">[5 more]</label></div><br/><div class="children"><div class="content">Rust isn&#x27;t standardized. Last time I checked, everyone who uses it depends on its nightly build. Their toolchain is enormous and isn&#x27;t vendorable. The binaries it builds are quite large. Programs take a very long time to compile. You need to depend on web servers to do your development and use lots of third party libraries maintained by people you&#x27;ve never heard of, because Rust adopted NodeJS&#x27; quadratic dependency model. Choosing Rust will greatly limit your audience if you&#x27;re doing an open source project, since your users need to install Rust to build your program, and there are many platforms Rust doesn&#x27;t support.<p>Rust programs use unsafe a lot in practice. One of the greatest difficulties I&#x27;ve had in supporting Rust with Cosmopolitan Libc is that Rust libraries all try to be clever by using raw assembly system calls rather than using libc. So our Rust binaries will break mysteriously when I run them on other OSes. Everyone who does AI or scientific computing with Rust, if you profile their programs, I guarantee you 99% of the time it&#x27;s going to be inside C&#x2F;C++ code. If better C&#x2F;C++ tools can give us memory safety, then how much difference does it really make if it&#x27;s baked into the language syntax. Rust can&#x27;t prove everything at compile time.<p>Some of the Rust programs I&#x27;ve used like Alacrity will runtime panic all the time. Because the language doesn&#x27;t actually save you. What saves you is smart people spending 5+ years hammering out all the bugs. That&#x27;s why old tools we depend on every day like GNU programs never crash and their memory bugs are rare enough to be newsworthy. The Rust community has a reputation for toxic behavior that raises questions about its the reliability of its governance. Rust evangelizes its ideas by attacking other languages and socially ostracizing the developers who use them. Software development is the process of manipulating memory, so do you really want to be relinquishing control over your memory to these kinds of people?</div><br/><div id="42562315" class="c"><input type="checkbox" id="c-42562315" checked=""/><div class="controls bullet"><span class="by">fc417fc802</span><span>|</span><a href="#42560596">root</a><span>|</span><a href="#42561760">parent</a><span>|</span><a href="#42563869">next</a><span>|</span><label class="collapse" for="c-42562315">[-]</label><label class="expand" for="c-42562315">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Not standardized.<p>&gt; Dependency soup.<p>Exactly why I don&#x27;t use it. I don&#x27;t really feel like including the source for the entire toolchain as part of my project and building it all myself. At least if I write standards conforming C++ there are multiple compiler implementations that can all handle it. I also have a reasonable expectation that a few decades from now I will be able to `apt get somecompiler` and the code will still just work (aside from any API changes at the OS level, for which compatibility shims will almost certainly exist).<p>If I can&#x27;t build something starting from a repo in a network isolated environment then I want absolutely nothing to do with it. (Emscripten I am looking at you. I will not be downloading sketchy binary blobs from cloud storage to &quot;build from source&quot; that is not a source build that is binary distribution you liars.)</div><br/></div></div><div id="42563869" class="c"><input type="checkbox" id="c-42563869" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#42560596">root</a><span>|</span><a href="#42561760">parent</a><span>|</span><a href="#42562315">prev</a><span>|</span><a href="#42563588">next</a><span>|</span><label class="collapse" for="c-42563869">[-]</label><label class="expand" for="c-42563869">[2 more]</label></div><br/><div class="children"><div class="content">&gt; One of the greatest difficulties I&#x27;ve had in supporting Rust with Cosmopolitan Libc is that Rust libraries all try to be clever by using raw assembly system calls rather than using libc.<p>I’m sorry, this is coming from Justine “the magic syscall numbers are my god given right to use” Tunney?</div><br/><div id="42563949" class="c"><input type="checkbox" id="c-42563949" checked=""/><div class="controls bullet"><span class="by">fc417fc802</span><span>|</span><a href="#42560596">root</a><span>|</span><a href="#42563869">parent</a><span>|</span><a href="#42563588">next</a><span>|</span><label class="collapse" for="c-42563949">[-]</label><label class="expand" for="c-42563949">[1 more]</label></div><br/><div class="children"><div class="content">Seems like it depends entirely on context. I&#x27;d expect code which intends to be portable to use some sort of dynamically linked wrapper, even if that wrapper isn&#x27;t libc.</div><br/></div></div></div></div><div id="42563588" class="c"><input type="checkbox" id="c-42563588" checked=""/><div class="controls bullet"><span class="by">vvanders</span><span>|</span><a href="#42560596">root</a><span>|</span><a href="#42561760">parent</a><span>|</span><a href="#42563869">prev</a><span>|</span><a href="#42563867">next</a><span>|</span><label class="collapse" for="c-42563588">[-]</label><label class="expand" for="c-42563588">[1 more]</label></div><br/><div class="children"><div class="content">You may want to refresh your familiarity with Rust, I haven&#x27;t touched nightly in ages and much of what you mention doesn&#x27;t really resonate with what I&#x27;ve seen in practice. Not saying the language doesn&#x27;t have issues and things that aren&#x27;t frustrating but in my experience unless you&#x27;re going to go to the nines in testing&#x2F;validation&#x2F;etc (which is the first thing that&#x27;s cut when schedules&#x2F;etc are in peril) I&#x27;ve seen Rust code scale better than C++ ever did.<p>More tools in the C&#x2F;C++ realm are always welcome but I&#x27;ve yet to see more than 50% of projects I&#x27;ve worked on be able to successfully use ASAN(assuming you&#x27;ve got the time to burn to configure them and all their dependencies properly). I&#x27;ve used ASAN, CBMC and other tools to good effect but find Rust more productive overall.</div><br/></div></div></div></div></div></div><div id="42563867" class="c"><input type="checkbox" id="c-42563867" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#42560596">root</a><span>|</span><a href="#42561500">parent</a><span>|</span><a href="#42561591">prev</a><span>|</span><a href="#42561318">next</a><span>|</span><label class="collapse" for="c-42563867">[-]</label><label class="expand" for="c-42563867">[1 more]</label></div><br/><div class="children"><div class="content">None of those sanitizers provide full memory safety for C&#x2F;C++.</div><br/></div></div></div></div><div id="42561318" class="c"><input type="checkbox" id="c-42561318" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42560596">parent</a><span>|</span><a href="#42561500">prev</a><span>|</span><a href="#42562229">next</a><span>|</span><label class="collapse" for="c-42561318">[-]</label><label class="expand" for="c-42561318">[1 more]</label></div><br/><div class="children"><div class="content">Similar experience, spending one week debugging memory corruption issues in production back in 2000, with the customer service pinging our team every couple of hours, due to it being on an high profile customer, has been my lesson.</div><br/></div></div><div id="42562229" class="c"><input type="checkbox" id="c-42562229" checked=""/><div class="controls bullet"><span class="by">ch33zer</span><span>|</span><a href="#42560596">parent</a><span>|</span><a href="#42561318">prev</a><span>|</span><a href="#42563863">next</a><span>|</span><label class="collapse" for="c-42562229">[-]</label><label class="expand" for="c-42562229">[7 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t C++ already support everything you need here? It supports the noexcept keyword which should have been used in the interface to this syscall. That would have prevented throwing callbacks from being used at compile time. My guess is that this is a much older syscall than noexcept though.</div><br/><div id="42562358" class="c"><input type="checkbox" id="c-42562358" checked=""/><div class="controls bullet"><span class="by">masspro</span><span>|</span><a href="#42560596">root</a><span>|</span><a href="#42562229">parent</a><span>|</span><a href="#42562537">next</a><span>|</span><label class="collapse" for="c-42562358">[-]</label><label class="expand" for="c-42562358">[4 more]</label></div><br/><div class="children"><div class="content">noexcept doesn’t prevent any throws at compile-time, it basically just wraps the function in a `catch(...)` block that will call std::terminate, like a failed assert. IMHO it is a stupid feature for this very confusion.</div><br/><div id="42562995" class="c"><input type="checkbox" id="c-42562995" checked=""/><div class="controls bullet"><span class="by">ch33zer</span><span>|</span><a href="#42560596">root</a><span>|</span><a href="#42562358">parent</a><span>|</span><a href="#42562537">next</a><span>|</span><label class="collapse" for="c-42562995">[-]</label><label class="expand" for="c-42562995">[3 more]</label></div><br/><div class="children"><div class="content">This was true until c++17. It was changed in 17 to make noexcept part of the function type meaning a noexcept(false) function can&#x27;t be used in a context where a noexcept is needed as they&#x27;re unrelated types. I don&#x27;t know if compilers actually implement this but according to the standard it should be usable.<p><a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;noexcept_spec" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;noexcept_spec</a></div><br/><div id="42563080" class="c"><input type="checkbox" id="c-42563080" checked=""/><div class="controls bullet"><span class="by">masspro</span><span>|</span><a href="#42560596">root</a><span>|</span><a href="#42562995">parent</a><span>|</span><a href="#42562537">next</a><span>|</span><label class="collapse" for="c-42563080">[-]</label><label class="expand" for="c-42563080">[2 more]</label></div><br/><div class="children"><div class="content">Yes this helps specifically when passing functions as pointers or something like std::function (edit: or overriding methods), it will at least inform the developer that they need to add noexcept to the function declaration if they want to use it there, and <i>hopefully</i> due to that they recursively audit the function body and anything it calls for exceptions. And <i>hopefully</i> all future developers also notice the noexcept and keep up the practice. But it changes nothing about checking plain function calls. So I think adding this to the function type helps some cases but still does not move noexcept toward the behavior most people want&#x2F;expect.<p>This just feels important to point out because this feature is 15 years old and still commonly misunderstood, and each time people are wanting the same thing (actual compile-time prevention of `throw`) which it is not.<p>Edit: OK I finally just went and tried it on godbolt.org. C++17 GCC, Clang, and MSVC all give 1 warning on this code for `bar` and that&#x27;s all.<p><pre><code>  void canthrow() {
    throw 42;
  }
  
  void foo() noexcept {
    canthrow();
  }
  
  void bar() noexcept {
    throw 42;
  }</code></pre></div><br/></div></div></div></div></div></div><div id="42562537" class="c"><input type="checkbox" id="c-42562537" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#42560596">root</a><span>|</span><a href="#42562229">parent</a><span>|</span><a href="#42562358">prev</a><span>|</span><a href="#42563863">next</a><span>|</span><label class="collapse" for="c-42562537">[-]</label><label class="expand" for="c-42562537">[2 more]</label></div><br/><div class="children"><div class="content">I think the PAPCFUNC type needs to have noexcept.  Wrapping a function typedef in extern &quot;C&quot; does not make it imply noexcept IIRC.<p>It would also help if the APC docs documented that APCs must not throw.</div><br/><div id="42563017" class="c"><input type="checkbox" id="c-42563017" checked=""/><div class="controls bullet"><span class="by">ch33zer</span><span>|</span><a href="#42560596">root</a><span>|</span><a href="#42562537">parent</a><span>|</span><a href="#42563863">next</a><span>|</span><label class="collapse" for="c-42563017">[-]</label><label class="expand" for="c-42563017">[1 more]</label></div><br/><div class="children"><div class="content">This would actually be a nice change (but probably very breaking) for c interfaces called from a c++ context to be implicitly noexcept.</div><br/></div></div></div></div></div></div><div id="42563863" class="c"><input type="checkbox" id="c-42563863" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#42560596">parent</a><span>|</span><a href="#42562229">prev</a><span>|</span><a href="#42558203">next</a><span>|</span><label class="collapse" for="c-42563863">[-]</label><label class="expand" for="c-42563863">[1 more]</label></div><br/><div class="children"><div class="content">Valgrind is neat but it wouldn’t help here, unfortunately</div><br/></div></div></div></div><div id="42558203" class="c"><input type="checkbox" id="c-42558203" checked=""/><div class="controls bullet"><span class="by">mhogomchungu</span><span>|</span><a href="#42560596">prev</a><span>|</span><a href="#42562353">next</a><span>|</span><label class="collapse" for="c-42558203">[-]</label><label class="expand" for="c-42558203">[5 more]</label></div><br/><div class="children"><div class="content">Raymond Cheng faced a similar situation here: <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20240927-00&#x2F;?p=110320" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20240927-00&#x2F;?p=11...</a><p>The problem boils down to usage of stack memory after the memory is given to somebody else.</div><br/><div id="42558982" class="c"><input type="checkbox" id="c-42558982" checked=""/><div class="controls bullet"><span class="by">musjleman</span><span>|</span><a href="#42558203">parent</a><span>|</span><a href="#42562353">next</a><span>|</span><label class="collapse" for="c-42558982">[-]</label><label class="expand" for="c-42558982">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The problem boils down to usage of stack memory after the memory is given to somebody else.<p>While this isn&#x27;t incorrect in this case the problem seems to be caused by stack unwinding without the consent of lower frames rather than a willful bug where the callee forgets about the ownership.</div><br/><div id="42559178" class="c"><input type="checkbox" id="c-42559178" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#42558203">root</a><span>|</span><a href="#42558982">parent</a><span>|</span><a href="#42562542">next</a><span>|</span><label class="collapse" for="c-42559178">[-]</label><label class="expand" for="c-42559178">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it’s the consequence of throwing exceptions through exception-unaware code, which is a problem when said code needs to perform some cleanup logic before returning, like releasing resources.</div><br/></div></div><div id="42562542" class="c"><input type="checkbox" id="c-42562542" checked=""/><div class="controls bullet"><span class="by">bialpio</span><span>|</span><a href="#42558203">root</a><span>|</span><a href="#42558982">parent</a><span>|</span><a href="#42559178">prev</a><span>|</span><a href="#42562353">next</a><span>|</span><label class="collapse" for="c-42562542">[-]</label><label class="expand" for="c-42562542">[2 more]</label></div><br/><div class="children"><div class="content">WDYM? The root cause is &quot;you passed ownership to stack-based memory to the kernel and didn&#x27;t ensure it&#x27;s valid when it called you back&quot;, why would &quot;consent of lower frames&quot; matter here? Exceptions (where lower frames matter) hid the control flow here, but that&#x27;s one way to reach this situation (early return is another way, as shown by Raymond Chen&#x27;s post).</div><br/><div id="42562643" class="c"><input type="checkbox" id="c-42562643" checked=""/><div class="controls bullet"><span class="by">musjleman</span><span>|</span><a href="#42558203">root</a><span>|</span><a href="#42562542">parent</a><span>|</span><a href="#42562353">next</a><span>|</span><label class="collapse" for="c-42562643">[-]</label><label class="expand" for="c-42562643">[1 more]</label></div><br/><div class="children"><div class="content">&gt; WDYM? The root cause is &quot;you passed ownership to stack-based memory to the kernel and didn&#x27;t ensure it&#x27;s valid when it called you back&quot;, why would &quot;consent of lower frames&quot; matter here?<p>There is no &quot;called back&quot; in this case. The APC was executed by the sleep and corrupted the stack by unwinding across the C winsock code without any cleanup. It never returned.<p>The user-mode enters an &quot;alertable&quot; wait which allows an asynchronous procedure (APC) to interrupt it and execute code. Instead of returning the APC causes an exception, unwinds the stack across the APC delivery and ends up executing some random code instead of returning to the winapi code that called wait(alertable: true) in a loop. So the code that was supposed to be synchronous because of while(!completed) wait(); suddenly is broken out of the loop without actually being completed.<p>&gt; Exceptions (where lower frames matter) hid the control flow here, but that&#x27;s one way to reach this situation (early return is another way, as shown by Raymond Chen&#x27;s post).<p>This isn&#x27;t just hiding the control flow here. It&#x27;s control flow that shouldn&#x27;t have existed in the first place. It walks across the boundary of the windows APC dispatcher. Unity folks needed to go out of their way to make this &quot;work&quot; in the first place because using c++ exceptions and standard library threads this wouldn&#x27;t work.</div><br/></div></div></div></div></div></div></div></div><div id="42562353" class="c"><input type="checkbox" id="c-42562353" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#42558203">prev</a><span>|</span><a href="#42557851">next</a><span>|</span><label class="collapse" for="c-42562353">[-]</label><label class="expand" for="c-42562353">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The fix was pretty straightforward: instead of using QueueUserAPC(), we now create a loopback socket to which we send a byte any time we need to interrupt select().<p>This is an absolutely standard trick that is known as &quot;the self-pipe trick&quot;. I believe DJB created and named it.  It is used for turning APIs not based on file handles&#x2F;descriptors into events for an event loop based on file handles&#x2F;descriptors, especially for turning signals into events for select(2)&#x2F;poll(2)&#x2F;epoll&#x2F;kqueue&#x2F;...</div><br/><div id="42563375" class="c"><input type="checkbox" id="c-42563375" checked=""/><div class="controls bullet"><span class="by">ptsneves</span><span>|</span><a href="#42562353">parent</a><span>|</span><a href="#42557851">next</a><span>|</span><label class="collapse" for="c-42563375">[-]</label><label class="expand" for="c-42563375">[2 more]</label></div><br/><div class="children"><div class="content">Agree. Maybe This is obvious for devs of OSes that are file (descriptor) centric like Linux and POSIX.
Also that pattern is a bit too sweet as it can be a nice way to create condition variables or queues, the problem being one is now paying syscall overhead.</div><br/><div id="42563887" class="c"><input type="checkbox" id="c-42563887" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#42562353">root</a><span>|</span><a href="#42563375">parent</a><span>|</span><a href="#42557851">next</a><span>|</span><label class="collapse" for="c-42563887">[-]</label><label class="expand" for="c-42563887">[1 more]</label></div><br/><div class="children"><div class="content">It works with file handles too.<p>&gt; Also that pattern is a bit too sweet as it can be a nice way to create condition variables or queues, the problem being one is now paying syscall overhead.<p>Sure but you don&#x27;t need to, and even if you did, the system call overhead is probably not the hill you&#x27;re dying on, or if it is then you want io_uring or similar.</div><br/></div></div></div></div></div></div><div id="42557851" class="c"><input type="checkbox" id="c-42557851" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#42562353">prev</a><span>|</span><a href="#42559401">next</a><span>|</span><label class="collapse" for="c-42557851">[-]</label><label class="expand" for="c-42557851">[2 more]</label></div><br/><div class="children"><div class="content">Scary. I assume standard memory corruption detection tools would also have trouble finding this, as the write is coming from outside the application itself…</div><br/><div id="42559904" class="c"><input type="checkbox" id="c-42559904" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#42557851">parent</a><span>|</span><a href="#42559401">next</a><span>|</span><label class="collapse" for="c-42559904">[-]</label><label class="expand" for="c-42559904">[1 more]</label></div><br/><div class="children"><div class="content">Yeah.  Not tripping a page fault on modifying readonly (userspace) pages both makes it hard for userspace tools but also paints a pretty specific picture of where the write is coming from.<p>I&#x27;m actually not sure if Linux would handle this in the same way or what.  Plausibly it sees the same leaf page tables as user space, trips a fault, and <i>doesn&#x27;t</i> scribble the pages anyway.  Maybe Windows translates the user-provided virtual address to a physical address (or other kernel mapping that happens to have write permission) upon registration.</div><br/></div></div></div></div><div id="42559401" class="c"><input type="checkbox" id="c-42559401" checked=""/><div class="controls bullet"><span class="by">hrtk</span><span>|</span><a href="#42557851">prev</a><span>|</span><a href="#42558072">next</a><span>|</span><label class="collapse" for="c-42559401">[-]</label><label class="expand" for="c-42559401">[2 more]</label></div><br/><div class="children"><div class="content">I don’t know windows programming and this was a very interesting (nightmare-ish) post.<p>I had a few questions I asked ChatGPT to understand better:
<a href="https:&#x2F;&#x2F;chatgpt.com&#x2F;share&#x2F;677411f9-b8a0-8013-8724-8cdff8dc4d3c" rel="nofollow">https:&#x2F;&#x2F;chatgpt.com&#x2F;share&#x2F;677411f9-b8a0-8013-8724-8cdff8dc4d...</a><p>Very interesting insights about low level programming in general</div><br/><div id="42561725" class="c"><input type="checkbox" id="c-42561725" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#42559401">parent</a><span>|</span><a href="#42558072">next</a><span>|</span><label class="collapse" for="c-42561725">[-]</label><label class="expand" for="c-42561725">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a pretty good use case for ChatGPT. Do you do this often? And if so, are your results specific to debugging consistently good?</div><br/></div></div></div></div><div id="42558072" class="c"><input type="checkbox" id="c-42558072" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#42559401">prev</a><span>|</span><a href="#42560913">next</a><span>|</span><label class="collapse" for="c-42558072">[-]</label><label class="expand" for="c-42558072">[8 more]</label></div><br/><div class="children"><div class="content">Very wild bug. I feel like this is some kind of a worst-case &quot;exceptions bad&quot; lesson, but I&#x27;ve only been doing systems level programming for a couple of years so I&#x27;m probably talking out my ass.</div><br/><div id="42561061" class="c"><input type="checkbox" id="c-42561061" checked=""/><div class="controls bullet"><span class="by">wat10000</span><span>|</span><a href="#42558072">parent</a><span>|</span><a href="#42558524">next</a><span>|</span><label class="collapse" for="c-42561061">[-]</label><label class="expand" for="c-42561061">[1 more]</label></div><br/><div class="children"><div class="content">This experienced systems programmer agrees with you 100%. This is an exceptionally bad case, but even in more normal circumstances, C++ exceptions are outrageously dangerous. Correct behavior requires the cooperation of not just the thrower and catcher, but everything in between. And there are basically no guardrails to enforce that. If you throw through C++ code that hasn’t been made exception safe, it just goes. You can throw through code written in plain C, which doesn’t even <i>have</i> exceptions.<p>It’s probably feasible to use them if you draw a tight boundary around the exception-using code, use RAII without fail inside that boundary to ensure everything cleans up properly, and make sure all code that might be called from the outside has try&#x2F;catch blocks. (And, obviously, don’t trigger async calls to throw from the middle of someone else’s function!).<p>I find it a lot easier to avoid them entirely. Error handling is a little more annoying, but it’s worth it.</div><br/></div></div><div id="42558524" class="c"><input type="checkbox" id="c-42558524" checked=""/><div class="controls bullet"><span class="by">usrnm</span><span>|</span><a href="#42558072">parent</a><span>|</span><a href="#42561061">prev</a><span>|</span><a href="#42560913">next</a><span>|</span><label class="collapse" for="c-42558524">[-]</label><label class="expand" for="c-42558524">[6 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think that the lesson here is &quot;exceptions are bad&quot;, the same kind of bug can be easily made without using exceptions.</div><br/><div id="42559121" class="c"><input type="checkbox" id="c-42559121" checked=""/><div class="controls bullet"><span class="by">IX-103</span><span>|</span><a href="#42558072">root</a><span>|</span><a href="#42558524">parent</a><span>|</span><a href="#42558732">next</a><span>|</span><label class="collapse" for="c-42559121">[-]</label><label class="expand" for="c-42559121">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not so sure. The bug was that when an exception occurred while select was blocked then select did not properly clean up after itself.  But no code in select actually dealt with exceptions at all, so handling it doesn&#x27;t really make sense.<p>Without exceptions the possible control flow is entirely explicit. It would have at least been obvious that cleanup wasn&#x27;t properly handled in the select function for all cases.</div><br/><div id="42562362" class="c"><input type="checkbox" id="c-42562362" checked=""/><div class="controls bullet"><span class="by">fc417fc802</span><span>|</span><a href="#42558072">root</a><span>|</span><a href="#42559121">parent</a><span>|</span><a href="#42558732">next</a><span>|</span><label class="collapse" for="c-42562362">[-]</label><label class="expand" for="c-42562362">[1 more]</label></div><br/><div class="children"><div class="content">&gt; an exception occurred<p>An exception was effectively injected from outside of the code via low level shenanigans. That&#x27;s not &quot;exceptions bad&quot; that&#x27;s &quot;low level monkeying with program control flow can blow up in your face&quot;.</div><br/></div></div></div></div><div id="42558732" class="c"><input type="checkbox" id="c-42558732" checked=""/><div class="controls bullet"><span class="by">usrnm</span><span>|</span><a href="#42558072">root</a><span>|</span><a href="#42558524">parent</a><span>|</span><a href="#42559121">prev</a><span>|</span><a href="#42560913">next</a><span>|</span><label class="collapse" for="c-42558732">[-]</label><label class="expand" for="c-42558732">[3 more]</label></div><br/><div class="children"><div class="content">Another thing to note is that exactly the same bug can be made in Rust or go, both of which officially don&#x27;t have exceptions. They both, of course, do have exceptions and just call them a different name.</div><br/><div id="42559027" class="c"><input type="checkbox" id="c-42559027" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#42558072">root</a><span>|</span><a href="#42558732">parent</a><span>|</span><a href="#42560979">next</a><span>|</span><label class="collapse" for="c-42559027">[-]</label><label class="expand" for="c-42559027">[1 more]</label></div><br/><div class="children"><div class="content">As it happens, Rust 1.81 recently added a feature where it aborts by default when you attempt to unwind from a function with the &quot;C&quot; ABI [0], which mitigates this issue for most FFI use cases.<p>Of course, it&#x27;s not uncommon to find unsafe Rust code that misbehaves badly when something panics, which is yet another of its hazards that I wish were better documented.<p>In this case, I&#x27;d put down the lesson as &quot;exceptions in C++ are very dangerous if you&#x27;re coming out of C code&quot;, since they can cause undocumented and unexpected behavior that ultimately led to the use-after-return issue here.<p>[0] <a href="https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;2024&#x2F;09&#x2F;05&#x2F;Rust-1.81.0.html#abort-on-uncaught-panics-in-extern-c-functions" rel="nofollow">https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;2024&#x2F;09&#x2F;05&#x2F;Rust-1.81.0.html#abort...</a></div><br/></div></div><div id="42560979" class="c"><input type="checkbox" id="c-42560979" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#42558072">root</a><span>|</span><a href="#42558732">parent</a><span>|</span><a href="#42559027">prev</a><span>|</span><a href="#42560913">next</a><span>|</span><label class="collapse" for="c-42560979">[-]</label><label class="expand" for="c-42560979">[1 more]</label></div><br/><div class="children"><div class="content">Exceptions aren&#x27;t bad because of the name.  Exceptions are bad because lower stack frames unwind higher ones, without giving those frames any opportunity to do something sane with any captured resources.  Calling it panic&#x2F;recover doesn&#x27;t help anything.</div><br/></div></div></div></div></div></div></div></div><div id="42560913" class="c"><input type="checkbox" id="c-42560913" checked=""/><div class="controls bullet"><span class="by">tomsmeding</span><span>|</span><a href="#42558072">prev</a><span>|</span><a href="#42558384">next</a><span>|</span><label class="collapse" for="c-42560913">[-]</label><label class="expand" for="c-42560913">[7 more]</label></div><br/><div class="children"><div class="content">Everyone here is going on about exceptions bad, but let&#x27;s talk about QueueUserAPC(). Yeah, let&#x27;s throw an asynchronous interrupt to some other thread that might be doing, you know, anything!<p>In the Unix world we have this too, and it&#x27;s called signals, but every documentation about signals is sure to say &quot;in a signal handler, almost nothing is safe!&quot;. You aren&#x27;t supposed to call printf() in a signal handler. Throwing exceptions is unthinkable.<p>I skimmed the linked QueueUserAPC() documentation page and it says none of this. Exceptions aren&#x27;t the handgrenade here (though sure, they&#x27;re nasty) — QueueUserAPC() is.</div><br/><div id="42561105" class="c"><input type="checkbox" id="c-42561105" checked=""/><div class="controls bullet"><span class="by">Veserv</span><span>|</span><a href="#42560913">parent</a><span>|</span><a href="#42562525">next</a><span>|</span><label class="collapse" for="c-42561105">[-]</label><label class="expand" for="c-42561105">[3 more]</label></div><br/><div class="children"><div class="content">That does not seem to be correct. The documentation indicates APC [1] can only occur from a waiting&#x2F;blocking state. So, the program is in a consistent state and can only be on a few known instructions, unlike signals. As such, most functions should be safe to call.<p>This is more like select() sometimes calling a user-supplied function in addition to checking for I&#x2F;O.<p>[1] <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;sync&#x2F;asynchronous-procedure-calls" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;sync&#x2F;asynchr...</a></div><br/><div id="42562399" class="c"><input type="checkbox" id="c-42562399" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#42560913">root</a><span>|</span><a href="#42561105">parent</a><span>|</span><a href="#42561794">next</a><span>|</span><label class="collapse" for="c-42562399">[-]</label><label class="expand" for="c-42562399">[1 more]</label></div><br/><div class="children"><div class="content">They call it an &quot;alertable state&quot;, and that&#x27;s:<p>&gt; A thread enters an alertable state when it calls the SleepEx, SignalObjectAndWait, MsgWaitForMultipleObjectsEx, WaitForMultipleObjectsEx, or WaitForSingleObjectEx function.<p>So this is a lot less like Unix signals.  It only really works if the thread you&#x27;re doing the async procedure call to is one that&#x27;s likely to use those.<p>So APCs are safe enough -- a lot safer than Unix signal handlers.</div><br/></div></div><div id="42561794" class="c"><input type="checkbox" id="c-42561794" checked=""/><div class="controls bullet"><span class="by">tomsmeding</span><span>|</span><a href="#42560913">root</a><span>|</span><a href="#42561105">parent</a><span>|</span><a href="#42562399">prev</a><span>|</span><a href="#42562525">next</a><span>|</span><label class="collapse" for="c-42561794">[-]</label><label class="expand" for="c-42561794">[1 more]</label></div><br/><div class="children"><div class="content">I see, I read the docs slightly too quickly. Still, though, I would have expected a conspicuous warning about exceptions in those calls, because MS is in on C++ (so they can&#x27;t hide behind &quot;but we expected only C&quot;) and apparently(?) the APC machinery doesn&#x27;t catch and block exceptions in user code.</div><br/></div></div></div></div><div id="42562525" class="c"><input type="checkbox" id="c-42562525" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#42560913">parent</a><span>|</span><a href="#42561105">prev</a><span>|</span><a href="#42561790">next</a><span>|</span><label class="collapse" for="c-42562525">[-]</label><label class="expand" for="c-42562525">[2 more]</label></div><br/><div class="children"><div class="content">The problem is that select() is a wrapper around WaitForMultipleObjectsEx() or whatever it is that select() uses, and those functions (the ones that can call APCs because entering them enters &quot;alertable state&quot;) are extern &quot;C&quot; functions, which means they cannot throw exceptions, but here we have an APC throwing an exception, which is not allowed!<p>Now, MSFT does NOT document that APCs can&#x27;t throw, but since the functions that enter alertable states (hence which can call APCs) are extern &quot;C&quot; functions, it follows that APCs cannot throw.<p>So part of the problem here is that the PAPCFUNC function type is not noexcept, therefore the compiler can&#x27;t stop you from using a function that is not noexcept as an APC, thus APCs <i>can</i> -but must not!- throw exceptions.</div><br/><div id="42562685" class="c"><input type="checkbox" id="c-42562685" checked=""/><div class="controls bullet"><span class="by">musjleman</span><span>|</span><a href="#42560913">root</a><span>|</span><a href="#42562525">parent</a><span>|</span><a href="#42561790">next</a><span>|</span><label class="collapse" for="c-42562685">[-]</label><label class="expand" for="c-42562685">[1 more]</label></div><br/><div class="children"><div class="content">There is nothing inherently wrong with throwing an exception from an APC. Windows supports it and will unwind the stack correctly. If you wrote all the code absolutely nothing will go wrong.<p>The issue is more about the actual code that calls alertable waits not expecting exceptions that will unwind which will most likely be all of winapi code because in it exception == crash.</div><br/></div></div></div></div><div id="42561790" class="c"><input type="checkbox" id="c-42561790" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#42560913">parent</a><span>|</span><a href="#42562525">prev</a><span>|</span><a href="#42558384">next</a><span>|</span><label class="collapse" for="c-42561790">[-]</label><label class="expand" for="c-42561790">[1 more]</label></div><br/><div class="children"><div class="content">This comment has ChatGPT explain the problem which is surprisingly understandable - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42559401">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42559401</a></div><br/></div></div></div></div><div id="42558384" class="c"><input type="checkbox" id="c-42558384" checked=""/><div class="controls bullet"><span class="by">AshleysBrain</span><span>|</span><a href="#42560913">prev</a><span>|</span><a href="#42563546">next</a><span>|</span><label class="collapse" for="c-42558384">[-]</label><label class="expand" for="c-42558384">[40 more]</label></div><br/><div class="children"><div class="content">Would memory safe languages avoid these kinds of problems? It seems like a good example of a nightmare bug from memory corruption - 5 days to fix and the author alludes to it keeping them up at night is a pretty strong motivation to avoid memory unsafety IMO.</div><br/><div id="42559370" class="c"><input type="checkbox" id="c-42559370" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#42558384">parent</a><span>|</span><a href="#42558443">next</a><span>|</span><label class="collapse" for="c-42559370">[-]</label><label class="expand" for="c-42559370">[8 more]</label></div><br/><div class="children"><div class="content">Depends. The underlying issue for this bug is that the code involved crosses language boundaries (the Windows kernel and win32 libraries written in C and the application in C++). The code where the lifetime failure occurs is Windows code, not application code. However, the Windows code is correct in the context of the C language. The error is caused by an APC that calls exception-throwing C++ code, being pushed onto the waiting-in-C thread. This is a case of language-agnostic OS mechanisms conflicting with language-specific stack unwinding mechanisms.<p>This could only be made safe by the OS somehow imposing safety mechanisms on the binary level, or by wrapping all OS APIs into APIs of the safe language, where the wrappers have to take care to ensure both the guarantees implied by the language and the assumptions made by the OS APIs. (Writing the OS itself in a memory-safe language isn’t sufficient, for one because it very likely will still require some amount of “unsafe” code, and furthermore because one would still want to allow applications written in a different language, which even if it also is memory-safe, would need memory-correct wrappers&#x2F;adapters.)<p>This is similar to the distinction between memory-safe languages like Rust where the safety is established primarily on the source level, not on the binary level, and memory-safe runtimes like the CLR (.NET) and the JVM.</div><br/><div id="42560122" class="c"><input type="checkbox" id="c-42560122" checked=""/><div class="controls bullet"><span class="by">jpc0</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42559370">parent</a><span>|</span><a href="#42558443">next</a><span>|</span><label class="collapse" for="c-42560122">[-]</label><label class="expand" for="c-42560122">[7 more]</label></div><br/><div class="children"><div class="content">&gt; the Windows kernel and win32 libraries written in C and the application in C++<p>To my knowledge the kernel and win32 is in fact written in C++ and only the interface has C linkage and follows C norms.<p>So this error occurred going C++ &gt; C &gt; C++ never mind languages with different memory protection mechanisms like Rust &gt; C &gt; C++.</div><br/><div id="42564745" class="c"><input type="checkbox" id="c-42564745" checked=""/><div class="controls bullet"><span class="by">ryao</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42560122">parent</a><span>|</span><a href="#42562155">next</a><span>|</span><label class="collapse" for="c-42564745">[-]</label><label class="expand" for="c-42564745">[1 more]</label></div><br/><div class="children"><div class="content">I filed bugs against both GCC and LLVM asking for compiler warnings that would inform developers of the risk:<p><a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;bugzilla&#x2F;show_bug.cgi?id=118263" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;bugzilla&#x2F;show_bug.cgi?id=118263</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;issues&#x2F;121427">https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;issues&#x2F;121427</a></div><br/></div></div><div id="42562155" class="c"><input type="checkbox" id="c-42562155" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42560122">parent</a><span>|</span><a href="#42564745">prev</a><span>|</span><a href="#42561587">next</a><span>|</span><label class="collapse" for="c-42562155">[-]</label><label class="expand" for="c-42562155">[1 more]</label></div><br/><div class="children"><div class="content">It’s an unholy combination of C, C++, and Microsoft extensions at worst. But apart possibly from some COM-related DLLs, the spirit is clearly C, and C++ exceptions are generally not expected. (There may be use of SEH in some parts.)<p>Of course, you can write C++ without exception safety too, but “C++ as a better C” and exception-safe C++ are effectively like two different languages.</div><br/></div></div><div id="42561587" class="c"><input type="checkbox" id="c-42561587" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42560122">parent</a><span>|</span><a href="#42562155">prev</a><span>|</span><a href="#42558443">next</a><span>|</span><label class="collapse" for="c-42561587">[-]</label><label class="expand" for="c-42561587">[4 more]</label></div><br/><div class="children"><div class="content">No, the windows kernel is written in pure C.</div><br/><div id="42562548" class="c"><input type="checkbox" id="c-42562548" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42561587">parent</a><span>|</span><a href="#42558443">next</a><span>|</span><label class="collapse" for="c-42562548">[-]</label><label class="expand" for="c-42562548">[3 more]</label></div><br/><div class="children"><div class="content">I believe it&#x27;s C++, but not allowed to use exceptions.</div><br/><div id="42562629" class="c"><input type="checkbox" id="c-42562629" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42562548">parent</a><span>|</span><a href="#42558443">next</a><span>|</span><label class="collapse" for="c-42562629">[-]</label><label class="expand" for="c-42562629">[2 more]</label></div><br/><div class="children"><div class="content">We know that it&#x27;s pure C, because it leaked.</div><br/><div id="42562978" class="c"><input type="checkbox" id="c-42562978" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42562629">parent</a><span>|</span><a href="#42558443">next</a><span>|</span><label class="collapse" for="c-42562978">[-]</label><label class="expand" for="c-42562978">[1 more]</label></div><br/><div class="children"><div class="content">All of it is C?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42558443" class="c"><input type="checkbox" id="c-42558443" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#42558384">parent</a><span>|</span><a href="#42559370">prev</a><span>|</span><a href="#42559657">next</a><span>|</span><label class="collapse" for="c-42558443">[-]</label><label class="expand" for="c-42558443">[20 more]</label></div><br/><div class="children"><div class="content">No*. This is one of the bugs that traditional memory safety would not fix, because the issue crosses privilege boundaries in a way that the language can&#x27;t protect against.<p>*This could, in theory, be caught by fancy hardware strategies like capabilities. But those are somewhat more esoteric.</div><br/><div id="42558858" class="c"><input type="checkbox" id="c-42558858" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42558443">parent</a><span>|</span><a href="#42558856">next</a><span>|</span><label class="collapse" for="c-42558858">[-]</label><label class="expand" for="c-42558858">[7 more]</label></div><br/><div class="children"><div class="content">To elaborate, the problem here is that it looks like the OS API itself is fundamentally unsafe: it&#x27;s taking a pointer to a memory location and then blindly writing into it, expecting that it&#x27;s still valid without actually doing any sort of verification. You could imagine an OS providing a safe API instead (with possible performance implications depending on the exact approach used), and if your OS API was written in e.g. Rust then this unsafe version of the API would be marked as `unsafe` with the documented invariant &quot;the caller must ensure that the pointer remains valid&quot;.</div><br/><div id="42564849" class="c"><input type="checkbox" id="c-42564849" checked=""/><div class="controls bullet"><span class="by">ryao</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42558858">parent</a><span>|</span><a href="#42560095">next</a><span>|</span><label class="collapse" for="c-42564849">[-]</label><label class="expand" for="c-42564849">[1 more]</label></div><br/><div class="children"><div class="content">They passed a function that throws an exception to a C ABI function. C ABI functions cannot tolerate exceptions because C does not support stack unwinding. It might work anyway, but it is technically undefined behavior and it will only ever work when simply deallocating what is on the stack does not require any cleanup elsewhere.<p>The exception caused the stack frame to disappear before the OS kernel was done with it. Presumably, the timeout would have been properly handled had the stack not been unwound by the exception. If it had not, that would be a bug in Windows.<p>There is a conceptually simple solution to this issue, which is to have the C++ compiler issue a warning when a programmer does this. I filed bug reports against both GCC and LLVM asking for one:<p><a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;bugzilla&#x2F;show_bug.cgi?id=118263" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;bugzilla&#x2F;show_bug.cgi?id=118263</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;issues&#x2F;121427">https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;issues&#x2F;121427</a><p>That said, this issue would not happen in Rust with a callback passed to a C function because unlike C++, Rust does not have exceptions:<p><a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch09-00-error-handling.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch09-00-error-handling.html</a><p>The same issue would happen when C++ passes a callback function that can throw an exception to Rust. However, the compiler warning I proposed should protect against that, provided that programmers do not ignore it if&#x2F;once it is implemented.</div><br/></div></div><div id="42560095" class="c"><input type="checkbox" id="c-42560095" checked=""/><div class="controls bullet"><span class="by">jpc0</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42558858">parent</a><span>|</span><a href="#42564849">prev</a><span>|</span><a href="#42561104">next</a><span>|</span><label class="collapse" for="c-42560095">[-]</label><label class="expand" for="c-42560095">[3 more]</label></div><br/><div class="children"><div class="content">Seeing as rust has no stable ABI and likely never will. How would you provide the API in rust, also in golang, also in .NET, and swift, and Java, and whatever other language you add without doing exactly what Win32 does and go to C which has a stable ABI to tie into all those other languages?</div><br/><div id="42561478" class="c"><input type="checkbox" id="c-42561478" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42560095">parent</a><span>|</span><a href="#42561104">next</a><span>|</span><label class="collapse" for="c-42561478">[-]</label><label class="expand" for="c-42561478">[2 more]</label></div><br/><div class="children"><div class="content">Rust ecosystem solves that by providing packages that are thin wrappers around underlying APIs. It&#x27;s very similar to providing an .h file with extra type information, except it&#x27;s an .rs file.<p>Correctness of the Rust wrapper can&#x27;t be checked by the compiler, just like correctness of C headers is unchecked, and it just has to match the actual underlying ABI.<p>The task of making a safe API wrapper can be relatively simple, because you don&#x27;t have to take into consideration safety an application as a whole, you only need to translate requirements of individual APIs to Rust&#x27;s safety requirements, function by function. In this case you would need to be aware that the function call may unwind, so whether someone making a dedicated safe API for it would think of it or not, is only a speculation.</div><br/><div id="42561855" class="c"><input type="checkbox" id="c-42561855" checked=""/><div class="controls bullet"><span class="by">jpc0</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42561478">parent</a><span>|</span><a href="#42561104">next</a><span>|</span><label class="collapse" for="c-42561855">[-]</label><label class="expand" for="c-42561855">[1 more]</label></div><br/><div class="children"><div class="content">I seem to remember a linux kernel dev quiting and not being able to specify exactly what you say this wrapper should abide by as being a contributing factor.<p>If those specifications were written down clearly enough then this dev wouldn&#x27;t have needed to spend 5 days debugging this since he spent a significant amount of time reading the documentation to find any errors they are making that is mentioned in the documentation.<p>And don&#x27;t say that they can actually just read the rust code and check that since well, I can&#x27;t read low level rust code and how any of the annotations ca interact with each other.<p>A single line of rust code could easily need several paragraphs of written documentation so that someone not familier with what rust is specifying will actually understand what that entails.<p>This is part of why Rust is difficult, you have to nail down the specification and a small change to the specification causes broad changes to the codebase. The same might need to happen in C, but many times it doesn&#x27;t.</div><br/></div></div></div></div></div></div><div id="42561104" class="c"><input type="checkbox" id="c-42561104" checked=""/><div class="controls bullet"><span class="by">wat10000</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42558858">parent</a><span>|</span><a href="#42560095">prev</a><span>|</span><a href="#42558856">next</a><span>|</span><label class="collapse" for="c-42561104">[-]</label><label class="expand" for="c-42561104">[2 more]</label></div><br/><div class="children"><div class="content">What would this safe API look like? The only thing I can think of would be to have the kernel allocate memory in the process and return that pointer, rather than having the caller provide a buffer. Performance would be painful. Is there a faster way that preserves safety?</div><br/><div id="42561977" class="c"><input type="checkbox" id="c-42561977" checked=""/><div class="controls bullet"><span class="by">LorenPechtel</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42561104">parent</a><span>|</span><a href="#42558856">next</a><span>|</span><label class="collapse" for="c-42561977">[-]</label><label class="expand" for="c-42561977">[1 more]</label></div><br/><div class="children"><div class="content">No allocation--it returns the address of a buffer in a pool.  Of course this permits a resource leak.  It&#x27;s a problem with no real solution.</div><br/></div></div></div></div></div></div><div id="42558856" class="c"><input type="checkbox" id="c-42558856" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42558443">parent</a><span>|</span><a href="#42558858">prev</a><span>|</span><a href="#42559657">next</a><span>|</span><label class="collapse" for="c-42558856">[-]</label><label class="expand" for="c-42558856">[12 more]</label></div><br/><div class="children"><div class="content">Safe code definitely won&#x27;t have this sort of problem. Any code that could invoke a system call to scribble on arbitrary memory is by definition unsafe.</div><br/><div id="42558891" class="c"><input type="checkbox" id="c-42558891" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42558856">parent</a><span>|</span><a href="#42559657">next</a><span>|</span><label class="collapse" for="c-42558891">[-]</label><label class="expand" for="c-42558891">[11 more]</label></div><br/><div class="children"><div class="content">That&#x27;s basically all code</div><br/><div id="42558911" class="c"><input type="checkbox" id="c-42558911" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42558891">parent</a><span>|</span><a href="#42559657">next</a><span>|</span><label class="collapse" for="c-42558911">[-]</label><label class="expand" for="c-42558911">[10 more]</label></div><br/><div class="children"><div class="content">No it isn&#x27;t. You can write safe file IO in Rust despite the read and write system calls being unsafe.</div><br/><div id="42558986" class="c"><input type="checkbox" id="c-42558986" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42558911">parent</a><span>|</span><a href="#42559043">prev</a><span>|</span><a href="#42559657">next</a><span>|</span><label class="collapse" for="c-42558986">[-]</label><label class="expand" for="c-42558986">[8 more]</label></div><br/><div class="children"><div class="content">I take it you are not familiar with the classic Rust meme of opening &#x2F;proc&#x2F;self&#x2F;mem and using it to completely wreck your program?</div><br/><div id="42559119" class="c"><input type="checkbox" id="c-42559119" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42558986">parent</a><span>|</span><a href="#42559657">next</a><span>|</span><label class="collapse" for="c-42559119">[-]</label><label class="expand" for="c-42559119">[7 more]</label></div><br/><div class="children"><div class="content">That&#x27;s obviously outside the scope of the language&#x27;s safety model, and it would be quite hard to do that <i>accidentally</i>.</div><br/><div id="42559764" class="c"><input type="checkbox" id="c-42559764" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42559119">parent</a><span>|</span><a href="#42559657">next</a><span>|</span><label class="collapse" for="c-42559764">[-]</label><label class="expand" for="c-42559764">[6 more]</label></div><br/><div class="children"><div class="content">That is exactly my point, though: system calls are completely outside the scope of a language&#x27;s safety model. You can say, well &#x2F;proc&#x2F;self&#x2F;mem is stupid (it is) and our file wrappers for read and write are safe (…most languages have at least one), but the fundamental problem remains that you can&#x27;t just expect to make system calls without that being implicitly unsafe. In the extreme the syscall itself cannot be done safely, with no possible safe wrapper around it. My point is that if you are calling these Windows APIs you can&#x27;t do it safely from any language; Rust won&#x27;t magically start yelling at you that the kernel still expects you to keep the buffer alive. You can design your own wrapper around it and try to match the kernel&#x27;s requirements but you can do that in a lot of languages, and that&#x27;s kind of missing the point.</div><br/><div id="42559963" class="c"><input type="checkbox" id="c-42559963" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42559764">parent</a><span>|</span><a href="#42560215">next</a><span>|</span><label class="collapse" for="c-42559963">[-]</label><label class="expand" for="c-42559963">[1 more]</label></div><br/><div class="children"><div class="content">Right. And of course, it&#x27;s not just Windows.  For example the Linux syscall aio_read() similarly registers a user address with the kernel for later, asynchronous writing (by the kernel).  (And I&#x27;m sure you get similar lifetime issues with io_uring operations.)</div><br/></div></div><div id="42560215" class="c"><input type="checkbox" id="c-42560215" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42559764">parent</a><span>|</span><a href="#42559963">prev</a><span>|</span><a href="#42559657">next</a><span>|</span><label class="collapse" for="c-42560215">[-]</label><label class="expand" for="c-42560215">[4 more]</label></div><br/><div class="children"><div class="content">The bug was not because a system call was involved. It was a multi threaded lifetime issue which is completely withing Rust&#x27;s safety model.<p>To put it another way, you can design a safe wrapper around this in Rust, but you can&#x27;t in C++.</div><br/><div id="42560289" class="c"><input type="checkbox" id="c-42560289" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42560215">parent</a><span>|</span><a href="#42559657">next</a><span>|</span><label class="collapse" for="c-42560289">[-]</label><label class="expand" for="c-42560289">[3 more]</label></div><br/><div class="children"><div class="content">No. The kernel has no idea what your lifetimes are. There’s nothing stopping a buggy Rust implementation from handing out a pointer for the syscall (…an unsafe operation!) and then accidentally dropping the owner. To userspace there are no more references and this code is fine. The problem is the kernel doesn’t care what you think, and it has a blank check to write where it wants.</div><br/><div id="42560606" class="c"><input type="checkbox" id="c-42560606" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42560289">parent</a><span>|</span><a href="#42559657">next</a><span>|</span><label class="collapse" for="c-42560606">[-]</label><label class="expand" for="c-42560606">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s no different to FFI with any C code. There&#x27;s nothing unique to this being a kernel or a syscall. There are plenty of C libraries that behave in a similar way and can be safely wrapped with Rust by adding the lifetime requirements.</div><br/><div id="42562397" class="c"><input type="checkbox" id="c-42562397" checked=""/><div class="controls bullet"><span class="by">fc417fc802</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42560606">parent</a><span>|</span><a href="#42559657">next</a><span>|</span><label class="collapse" for="c-42562397">[-]</label><label class="expand" for="c-42562397">[1 more]</label></div><br/><div class="children"><div class="content">&gt; can be safely wrapped with Rust<p>They can&#x27;t. Rust can&#x27;t verify the safety of the called code once you cross the language boundary. Handing out the pointer is inherently unsafe.<p>In the user space FFI case at least you might be able to switch to an implementation written in the same (memory safe) language that you are already using. Not so for a syscall.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="42559657" class="c"><input type="checkbox" id="c-42559657" checked=""/><div class="controls bullet"><span class="by">muststopmyths</span><span>|</span><a href="#42558384">parent</a><span>|</span><a href="#42558443">prev</a><span>|</span><a href="#42561877">next</a><span>|</span><label class="collapse" for="c-42559657">[-]</label><label class="expand" for="c-42559657">[4 more]</label></div><br/><div class="children"><div class="content">In this specific type of Win32 API case, I can think of a way to make this safe.<p>It would involve looking at the function pointer in QueueUserAPC and making sure the function being called doesn&#x27;t mess with the stack frame being executed on.<p>This function will run in the context of the called thread, in <i>that</i> thread&#x27;s stack. NOT in the calling thread.<p>It&#x27;s a weird execution mode where you&#x27;re allowed to hijack a blocked thread and run some code in its context.<p>Don&#x27;t know enough about Rust or the like to say if that&#x27;s something that could be done in the language with attributes&#x2F;annotations for a function, but it seems plausible.</div><br/><div id="42560019" class="c"><input type="checkbox" id="c-42560019" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42559657">parent</a><span>|</span><a href="#42560003">next</a><span>|</span><label class="collapse" for="c-42560019">[-]</label><label class="expand" for="c-42560019">[2 more]</label></div><br/><div class="children"><div class="content">Perhaps simpler would be to just not unwind C++ exceptions through non-C++ stack frames and abort instead.  (You&#x27;d run into these crashes at development time, debugging them would be pretty obvious, and it&#x27;d never release like this.) This might not be viable on Windows, though, where there is a lot of both C++ and legacy C code.</div><br/><div id="42561052" class="c"><input type="checkbox" id="c-42561052" checked=""/><div class="controls bullet"><span class="by">charrondev</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42560019">parent</a><span>|</span><a href="#42560003">next</a><span>|</span><label class="collapse" for="c-42561052">[-]</label><label class="expand" for="c-42561052">[1 more]</label></div><br/><div class="children"><div class="content">As I understand this was recent stabilized in rust and is now the default behaviour.<p><a href="https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;2024&#x2F;09&#x2F;05&#x2F;Rust-1.81.0.html#abort-on-uncaught-panics-in-extern-c-functions" rel="nofollow">https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;2024&#x2F;09&#x2F;05&#x2F;Rust-1.81.0.html#abort...</a><p>You have to explicitly opt into unwinding like this now otherwise the program will abort.</div><br/></div></div></div></div><div id="42560003" class="c"><input type="checkbox" id="c-42560003" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42559657">parent</a><span>|</span><a href="#42560019">prev</a><span>|</span><a href="#42561877">next</a><span>|</span><label class="collapse" for="c-42560003">[-]</label><label class="expand" for="c-42560003">[1 more]</label></div><br/><div class="children"><div class="content">Nothing in C can prevent your function from being abnormally unwound through (whether it&#x27;s via C++ exceptions or via C longjmp()). The only real fix is &quot;don&#x27;t use C++ exceptions unless you&#x27;re 100% sure that the code in between is exception-safe (and don&#x27;t use C longjmp() at all outside of controlled scenarios)&quot;.</div><br/></div></div></div></div><div id="42561877" class="c"><input type="checkbox" id="c-42561877" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#42558384">parent</a><span>|</span><a href="#42559657">prev</a><span>|</span><a href="#42559103">next</a><span>|</span><label class="collapse" for="c-42561877">[-]</label><label class="expand" for="c-42561877">[5 more]</label></div><br/><div class="children"><div class="content">No. The problem was in the architecture of the asynchronous api w.r.t. the kernel. The last line of the article states; <i>Lesson learnt, folks: do not throw exceptions out of asynchronous procedures if you’re inside a system call!</i></div><br/><div id="42562000" class="c"><input type="checkbox" id="c-42562000" checked=""/><div class="controls bullet"><span class="by">LorenPechtel</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42561877">parent</a><span>|</span><a href="#42559103">next</a><span>|</span><label class="collapse" for="c-42562000">[-]</label><label class="expand" for="c-42562000">[4 more]</label></div><br/><div class="children"><div class="content">More generally:<p>1)  The top level of an async routine should have a handler that catches all exceptions and dies if it catches one.<p>2)  If you have a resource you have a cleanup routine for it.</div><br/><div id="42563386" class="c"><input type="checkbox" id="c-42563386" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42562000">parent</a><span>|</span><a href="#42559103">next</a><span>|</span><label class="collapse" for="c-42563386">[-]</label><label class="expand" for="c-42563386">[3 more]</label></div><br/><div class="children"><div class="content">It is even more fundamental. People are focusing wrongly on the mention of exceptions here (most obvious) but what is crucial is to understand how Async callbacks registered with a Kernel work on all OSes. The limitations&#x2F;caveats imposed on these routines (they are akin to interrupts) are given in their respective documentations and one has to be careful to understand and use them appropriately; eg. what is the stack used by these handlers? The article though detailed in the beginning sort of glosses over all this in the final paragraphs and hence we have to link the dots ourselves.</div><br/><div id="42563844" class="c"><input type="checkbox" id="c-42563844" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42563386">parent</a><span>|</span><a href="#42559103">next</a><span>|</span><label class="collapse" for="c-42563844">[-]</label><label class="expand" for="c-42563844">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not really about asynchronous callbacks or their equivalents. (In this case, the thread running it is otherwise meant to be blocked in a safe state, so that there&#x27;s none of the usual dangers of interrupting arbitrary code.) Instead, it&#x27;s about any callbacks coming out of C code, even something as trivial as qsort(). If you pass a C library your C++ callback, and your callback runs back through it with an exception, then 9 times out of 10, the C library will leak some resources at best, or reach an unstable state at worst. C just doesn&#x27;t have any portable &#x27;try&#x2F;finally&#x27; construct that can help deal with it.<p>So I&#x27;d say it&#x27;s more about the basic expectations of a function called from C, which includes a million other trivial things like &quot;don&#x27;t write beyond the bounds of buffers you&#x27;re given&quot; and &quot;don&#x27;t clobber your caller&#x27;s stack frame&quot; and &quot;don&#x27;t spawn another thread just to write to output pointers after your function returns&quot; (not that any of these is the issue here).</div><br/><div id="42564321" class="c"><input type="checkbox" id="c-42564321" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#42558384">root</a><span>|</span><a href="#42563844">parent</a><span>|</span><a href="#42559103">next</a><span>|</span><label class="collapse" for="c-42564321">[-]</label><label class="expand" for="c-42564321">[1 more]</label></div><br/><div class="children"><div class="content">No, you (and most folks here) have not understood the full picture. Only the C ABI is relevant here and not the language (C&#x2F;C++&#x2F;whatever) itself.<p>You have to know how exactly asynchronous callbacks registered with the kernel get called, how their stack frames get setup, how kernel writes to local variables within a stack frame of a user thread, how stack frames are adjusted when a blocking system call returns to user space and finally, how and when exceptions (in any language) mess up the above when they implement a different flow of control than that expected by the above &quot;async callback kernel api architecture&quot;. All of these are at play here and once you put them together you understand the scenario.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42559103" class="c"><input type="checkbox" id="c-42559103" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42558384">parent</a><span>|</span><a href="#42561877">prev</a><span>|</span><a href="#42558549">next</a><span>|</span><label class="collapse" for="c-42559103">[-]</label><label class="expand" for="c-42559103">[1 more]</label></div><br/><div class="children"><div class="content">Yes memory safe languages would absolutely help here. In Rust you would get a compile time error about the destination variable not living long enough.<p>This sort of stuff is why any productivity arguments for C++ over Rust are bullshit. Sure you spend a little more time writing lifetime annotations, but in return you avoid spending 5 days debugging one memory corruption bug.</div><br/></div></div></div></div><div id="42563546" class="c"><input type="checkbox" id="c-42563546" checked=""/><div class="controls bullet"><span class="by">explosion-s</span><span>|</span><a href="#42558384">prev</a><span>|</span><a href="#42563404">next</a><span>|</span><label class="collapse" for="c-42563546">[-]</label><label class="expand" for="c-42563546">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Somebody had been touching my sentinel’s privates - and it definitely wasn’t a friend<p>Gotta love programmers out of context</div><br/></div></div><div id="42563404" class="c"><input type="checkbox" id="c-42563404" checked=""/><div class="controls bullet"><span class="by">pantalaimon</span><span>|</span><a href="#42563546">prev</a><span>|</span><a href="#42558062">next</a><span>|</span><label class="collapse" for="c-42563404">[-]</label><label class="expand" for="c-42563404">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Jemand hatte das Gemächt meines Wächters angefasst - und es war definitiv kein Freund.<p>That auto-translation is something else</div><br/></div></div><div id="42558062" class="c"><input type="checkbox" id="c-42558062" checked=""/><div class="controls bullet"><span class="by">glandium</span><span>|</span><a href="#42563404">prev</a><span>|</span><a href="#42560942">next</a><span>|</span><label class="collapse" for="c-42558062">[-]</label><label class="expand" for="c-42558062">[11 more]</label></div><br/><div class="children"><div class="content">I wonder if Time Travel Debugging would have helped narrow it down.</div><br/><div id="42560038" class="c"><input type="checkbox" id="c-42560038" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#42558062">parent</a><span>|</span><a href="#42558136">next</a><span>|</span><label class="collapse" for="c-42560038">[-]</label><label class="expand" for="c-42560038">[8 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think any reverse debugging system can step the kernel backwards to this degree, unless they&#x27;re doing something really clever (slow) with virtual machines and snapshots.</div><br/><div id="42560280" class="c"><input type="checkbox" id="c-42560280" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#42558062">root</a><span>|</span><a href="#42560038">parent</a><span>|</span><a href="#42560559">next</a><span>|</span><label class="collapse" for="c-42560280">[-]</label><label class="expand" for="c-42560280">[6 more]</label></div><br/><div class="children"><div class="content">While not allowing stepping in the kernel, a large part of rr is indeed intercepting all things the kernel may do and re-implementing its actions, writing down all changes to memory &amp; etc it does (of course for Linux, not Windows). With which the kernel doing an asynchronous write would necessarily end up as a part of the recording stating what the kernel writes at the given point in time, which a debugger could deterministically reason about. (of course this relies on the recording system reimplementing the things accurately enough, but that&#x27;s at least possible)</div><br/><div id="42560646" class="c"><input type="checkbox" id="c-42560646" checked=""/><div class="controls bullet"><span class="by">Veserv</span><span>|</span><a href="#42558062">root</a><span>|</span><a href="#42560280">parent</a><span>|</span><a href="#42561038">next</a><span>|</span><label class="collapse" for="c-42560646">[-]</label><label class="expand" for="c-42560646">[4 more]</label></div><br/><div class="children"><div class="content">You are correct. A time travel debugging solution that supports recording the relevant system call side effects would handle this. In fact, this system call is likely just rewriting the program counter register and maybe a few others, so it would likely be very easy to support if you could hook the relevant kernel operations which may or may not be possible in Windows.<p>The replay system would also be unlikely to pose a problem. Replay systems usually just encode and replay the side effects, so there is no need to &quot;reimplement&quot; the operations. So, if you did some wacky system call, but all it did is write 0x2 to a memory location, M, you effectively just record: &quot;at time T we issued a system call that wrote 0x2 to M&quot;. Then, when you get to simulated time T in the replay, you do not reissue the wacky system call, you just write 0x2 to M and call it a day.</div><br/><div id="42561033" class="c"><input type="checkbox" id="c-42561033" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#42558062">root</a><span>|</span><a href="#42560646">parent</a><span>|</span><a href="#42561038">next</a><span>|</span><label class="collapse" for="c-42561033">[-]</label><label class="expand" for="c-42561033">[3 more]</label></div><br/><div class="children"><div class="content">This system call returned and then asynchronously wrote to memory some time later.  How does the replay system even know the write happened, without scanning all memory?  It can&#x27;t generally.  With knowledge of the specific call it could put just that address on a to-be-scanned list to wait for completion, but it still needs to periodically poll the memory.  It is far more complicated to record than a synchronous syscall.</div><br/><div id="42561449" class="c"><input type="checkbox" id="c-42561449" checked=""/><div class="controls bullet"><span class="by">Veserv</span><span>|</span><a href="#42558062">root</a><span>|</span><a href="#42561033">parent</a><span>|</span><a href="#42561038">next</a><span>|</span><label class="collapse" for="c-42561449">[-]</label><label class="expand" for="c-42561449">[2 more]</label></div><br/><div class="children"><div class="content">You hook the kernel write. That is why I said hook the relevant kernel operations.<p>The primary complexity is actually in creating a consistent timeline with respect to parallel asynchronous writes. Record-Replay systems like rr usually just serialize multithreaded execution during recording to avoid such problems. You could also do so by just serializing the executing thread and the parallel asynchronous write by stopping execution of the thread while the write occurs.<p>Again, not really sure if that would be possible in Windows, but there is nothing particularly mechanically hard about doing this. It is just a question of whether it matches the abstractions and hooks Windows uses and supports.</div><br/><div id="42561741" class="c"><input type="checkbox" id="c-42561741" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#42558062">root</a><span>|</span><a href="#42561449">parent</a><span>|</span><a href="#42561038">next</a><span>|</span><label class="collapse" for="c-42561741">[-]</label><label class="expand" for="c-42561741">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think rr hooks actual kernel writes, but rather just has hard-coded information on each syscall of how to compute what regions of memory it may modify, reading those on recording and writing on replay.<p>As such, for an asynchronous kernel write you&#x27;d want to set up the kernel to never mutate recordee memory, instead having it modify recorder-local memory, which the recorder can then copy over to the real process whenever, and get to record when it happens while at it (see <a href="https:&#x2F;&#x2F;github.com&#x2F;rr-debugger&#x2F;rr&#x2F;issues&#x2F;2613">https:&#x2F;&#x2F;github.com&#x2F;rr-debugger&#x2F;rr&#x2F;issues&#x2F;2613</a>). But such can introduce large delays, thereby changing execution characteristics (if not make things appear to happen in a different order than the kernel would, if done improperly). And you still need the recording system to have accurately implemented the forwarding of whatever edge-case of the asynchronous operation you hit.<p>And, if done as just that, you&#x27;d still hit the problem encountered in the article of it looking like unrelated code changes the memory (whereas with synchronous syscalls you&#x27;d at least see the mutation happening on a syscall instruction). So you&#x27;d want some extra injected recordee instruction(s) to present separation of recordee actions from asynchronous kernel ones. As a sibling comment notes, rr as-is doesn&#x27;t handle any asynchronous kernel write cases (though it&#x27;s certainly not entirely impossible to).</div><br/></div></div></div></div></div></div></div></div><div id="42561038" class="c"><input type="checkbox" id="c-42561038" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#42558062">root</a><span>|</span><a href="#42560280">parent</a><span>|</span><a href="#42560646">prev</a><span>|</span><a href="#42560559">next</a><span>|</span><label class="collapse" for="c-42561038">[-]</label><label class="expand" for="c-42561038">[1 more]</label></div><br/><div class="children"><div class="content">rr does not record AIO or io_uring operations today, because recording syscalls with async behavior is challenging.<p>Maybe Windows TTD records async NtDeviceIoControlFile acculately, maybe it doesn&#x27;t; I don&#x27;t know.</div><br/></div></div></div></div><div id="42560559" class="c"><input type="checkbox" id="c-42560559" checked=""/><div class="controls bullet"><span class="by">mark_undoio</span><span>|</span><a href="#42558062">root</a><span>|</span><a href="#42560038">parent</a><span>|</span><a href="#42560280">prev</a><span>|</span><a href="#42558136">next</a><span>|</span><label class="collapse" for="c-42560559">[-]</label><label class="expand" for="c-42560559">[1 more]</label></div><br/><div class="children"><div class="content">It looks like they didn&#x27;t actually need to step the kernel in the end - it just helped understand the bug (which I&#x27;d say was in user space - injecting an exception into select() and this preventing it exiting normally - even though a kernel behaviour was involved in how the bug manifested).<p>The time travel debugging available with WinDbg should be able to wind back to the point of corruption - that&#x27;d probably have taken a few days off the initial realisation that an async change to the stack was causing the problem.<p>There&#x27;d still be another reasoning step required to understand why that happened - but you would be able to step back in time e.g. to when this buffer was <i>previously</i> used on the stack to see how select () was submitting it to the kernel.<p>In fact, a data breakpoint &#x2F; watchpoint could likely have taken you back from the corruption to the previous valid use, which may have been the missing piece.</div><br/></div></div></div></div><div id="42558136" class="c"><input type="checkbox" id="c-42558136" checked=""/><div class="controls bullet"><span class="by">chris_wot</span><span>|</span><a href="#42558062">parent</a><span>|</span><a href="#42560038">prev</a><span>|</span><a href="#42560942">next</a><span>|</span><label class="collapse" for="c-42558136">[-]</label><label class="expand" for="c-42558136">[2 more]</label></div><br/><div class="children"><div class="content">How? Throwing an exception would prevent this wouldn’t it?</div><br/><div id="42558176" class="c"><input type="checkbox" id="c-42558176" checked=""/><div class="controls bullet"><span class="by">ben-schaaf</span><span>|</span><a href="#42558062">root</a><span>|</span><a href="#42558136">parent</a><span>|</span><a href="#42560942">next</a><span>|</span><label class="collapse" for="c-42558176">[-]</label><label class="expand" for="c-42558176">[1 more]</label></div><br/><div class="children"><div class="content">When the assertion on the stack sentinel was reached they could have watched the value and then reverse continued, which in theory would reveal the APC causing the issue - or at least the instruction writing the value. Not sure how well reverse debugging works on Windows though, I&#x27;m only familiar with rr.</div><br/></div></div></div></div></div></div><div id="42560942" class="c"><input type="checkbox" id="c-42560942" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#42558062">prev</a><span>|</span><a href="#42561475">next</a><span>|</span><label class="collapse" for="c-42560942">[-]</label><label class="expand" for="c-42560942">[1 more]</label></div><br/><div class="children"><div class="content">A small request: please stop using automatic translation for blog posts or documentation.<p>Especially when I still have English set as the second priority language.</div><br/></div></div><div id="42561475" class="c"><input type="checkbox" id="c-42561475" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42560942">prev</a><span>|</span><a href="#42560170">next</a><span>|</span><label class="collapse" for="c-42561475">[-]</label><label class="expand" for="c-42561475">[1 more]</label></div><br/><div class="children"><div class="content">The second piece of code I wrote for pay was a FFI around a c library, which had callbacks to send incremental data back to the caller. I didn’t understand why the documented examples would re-acquire the object handles every iteration through the loop so I dropped them. And everything seemed to work until I got to the larger problems and then I was getting mutually exclusive states in data that was marked as immutable, in some of the objects. I pulled my hair on this for days.<p>What ended up happening is that if the GC ran inside the callback then the objects the native code could see could move, and so the next block of code was smashing the heap by writing to the wrong spots. All the small inputs finished before a GC was called and looked fine but larger ones went into undefined behavior. So dumb.</div><br/></div></div><div id="42560170" class="c"><input type="checkbox" id="c-42560170" checked=""/><div class="controls bullet"><span class="by">DustinBrett</span><span>|</span><a href="#42561475">prev</a><span>|</span><a href="#42558660">next</a><span>|</span><label class="collapse" for="c-42560170">[-]</label><label class="expand" for="c-42560170">[1 more]</label></div><br/><div class="children"><div class="content">It was just a dream, there&#x27;s no such thing as 2.</div><br/></div></div><div id="42558660" class="c"><input type="checkbox" id="c-42558660" checked=""/><div class="controls bullet"><span class="by">danaris</span><span>|</span><a href="#42560170">prev</a><span>|</span><a href="#42560754">next</a><span>|</span><label class="collapse" for="c-42558660">[-]</label><label class="expand" for="c-42558660">[2 more]</label></div><br/><div class="children"><div class="content"><i>WSPSelect</i>: &#x27;Twas I who wrote &quot;2&quot; to your stack! And I would&#x27;ve gotten away with it, too, if it weren&#x27;t for that meddling kernel debugger!</div><br/><div id="42558769" class="c"><input type="checkbox" id="c-42558769" checked=""/><div class="controls bullet"><span class="by">greenbit</span><span>|</span><a href="#42558660">parent</a><span>|</span><a href="#42560754">next</a><span>|</span><label class="collapse" for="c-42558769">[-]</label><label class="expand" for="c-42558769">[1 more]</label></div><br/><div class="children"><div class="content">.. and their hardware breakpoint!</div><br/></div></div></div></div><div id="42560754" class="c"><input type="checkbox" id="c-42560754" checked=""/><div class="controls bullet"><span class="by">diekhans</span><span>|</span><a href="#42558660">prev</a><span>|</span><a href="#42558324">next</a><span>|</span><label class="collapse" for="c-42560754">[-]</label><label class="expand" for="c-42560754">[1 more]</label></div><br/><div class="children"><div class="content">Nicely written (and executed).  Worse that my worst memory corruption.</div><br/></div></div><div id="42558324" class="c"><input type="checkbox" id="c-42558324" checked=""/><div class="controls bullet"><span class="by">hun3</span><span>|</span><a href="#42560754">prev</a><span>|</span><a href="#42558032">next</a><span>|</span><label class="collapse" for="c-42558324">[-]</label><label class="expand" for="c-42558324">[2 more]</label></div><br/><div class="children"><div class="content">(2016)</div><br/><div id="42558453" class="c"><input type="checkbox" id="c-42558453" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#42558324">parent</a><span>|</span><a href="#42558032">next</a><span>|</span><label class="collapse" for="c-42558453">[-]</label><label class="expand" for="c-42558453">[1 more]</label></div><br/><div class="children"><div class="content">Added</div><br/></div></div></div></div><div id="42558032" class="c"><input type="checkbox" id="c-42558032" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#42558324">prev</a><span>|</span><a href="#42558452">next</a><span>|</span><label class="collapse" for="c-42558032">[-]</label><label class="expand" for="c-42558032">[1 more]</label></div><br/><div class="children"><div class="content">A Story for the ages. That is some hardcore debugging involving everything viz. user land, system call, kernel, disassembly etc.</div><br/></div></div><div id="42563166" class="c"><input type="checkbox" id="c-42563166" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#42558452">prev</a><span>|</span><a href="#42558367">next</a><span>|</span><label class="collapse" for="c-42563166">[-]</label><label class="expand" for="c-42563166">[1 more]</label></div><br/><div class="children"><div class="content">TLDR: Kernel wrote memory back to a pointer provided by the user-mode program, as it was supposed to do.  Unfortunately, it was a dangling pointer (Use-after-free)<p>When the Kernel does the memory write, user-mode memory debuggers don&#x27;t see it happen.</div><br/></div></div><div id="42558367" class="c"><input type="checkbox" id="c-42558367" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#42563166">prev</a><span>|</span><label class="collapse" for="c-42558367">[-]</label><label class="expand" for="c-42558367">[11 more]</label></div><br/><div class="children"><div class="content">Set a hardware breakpoint and you&#x27;ll know immediately. That&#x27;s what he eventually did, but he should have done so sooner.<p>Then obviously, cancelling an operation is always tricky business with lifetime due to asynchronicity. My approach is to always design my APIs with synchronous cancel semantics, which is sometimes tricky to implement. Many common libraries don&#x27;t do it right.</div><br/><div id="42558545" class="c"><input type="checkbox" id="c-42558545" checked=""/><div class="controls bullet"><span class="by">alexvitkov</span><span>|</span><a href="#42558367">parent</a><span>|</span><a href="#42558433">next</a><span>|</span><label class="collapse" for="c-42558545">[-]</label><label class="expand" for="c-42558545">[5 more]</label></div><br/><div class="children"><div class="content">He mentioned in the article that the corruption happens at a seemingly random spot the middle of a large buffer, and you can only have a HW breakpoint on 4 addresses in x86-64.</div><br/><div id="42558851" class="c"><input type="checkbox" id="c-42558851" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#42558367">root</a><span>|</span><a href="#42558545">parent</a><span>|</span><a href="#42558433">next</a><span>|</span><label class="collapse" for="c-42558851">[-]</label><label class="expand" for="c-42558851">[4 more]</label></div><br/><div class="children"><div class="content">Reproduce the corruption under rr. Replay the rr trace. Replay is totally deterministic, so you can just seek to the end of the trace, set a hardware breakpoint on the damaged stack location, and reverse-continue until you find the culprit.</div><br/><div id="42559251" class="c"><input type="checkbox" id="c-42559251" checked=""/><div class="controls bullet"><span class="by">zorgmonkey</span><span>|</span><a href="#42558367">root</a><span>|</span><a href="#42558851">parent</a><span>|</span><a href="#42559244">next</a><span>|</span><label class="collapse" for="c-42559251">[-]</label><label class="expand" for="c-42559251">[1 more]</label></div><br/><div class="children"><div class="content">rr is only works on Linux and the release of Windows TTD was after this blog post was published. Also the huge slowdown from time travel debuggers can sometimes make tricky bugs like this much harder to reproduce.</div><br/></div></div><div id="42559244" class="c"><input type="checkbox" id="c-42559244" checked=""/><div class="controls bullet"><span class="by">pm215</span><span>|</span><a href="#42558367">root</a><span>|</span><a href="#42558851">parent</a><span>|</span><a href="#42559251">prev</a><span>|</span><a href="#42559129">next</a><span>|</span><label class="collapse" for="c-42559244">[-]</label><label class="expand" for="c-42559244">[1 more]</label></div><br/><div class="children"><div class="content">I would certainly try with a reverse debugger if I had one, but where the repro instructions are &quot;run this big complex interactive program for 10 minutes&quot; I wouldn&#x27;t be super confident about successfully recording a repro. At least in my experience with rr the slowdown is enough to make that painful, especially if you need to do multiple &quot;chaos mode&quot; runs to get a timing sensitive bug to trigger. It might still be worth spending time trying to get a faster repro case to make reverse debug a bit more tractable.</div><br/></div></div><div id="42559129" class="c"><input type="checkbox" id="c-42559129" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42558367">root</a><span>|</span><a href="#42558851">parent</a><span>|</span><a href="#42559244">prev</a><span>|</span><a href="#42558433">next</a><span>|</span><label class="collapse" for="c-42559129">[-]</label><label class="expand" for="c-42559129">[1 more]</label></div><br/><div class="children"><div class="content">Sure let me just run `rr` on Windows...</div><br/></div></div></div></div></div></div><div id="42558433" class="c"><input type="checkbox" id="c-42558433" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#42558367">parent</a><span>|</span><a href="#42558545">prev</a><span>|</span><a href="#42558535">next</a><span>|</span><label class="collapse" for="c-42558433">[-]</label><label class="expand" for="c-42558433">[1 more]</label></div><br/><div class="children"><div class="content">Hardware breakpoints don&#x27;t work if the kernel is doing the writes, because the kernel won&#x27;t let you enable them globally so they trigger outside of your program.</div><br/></div></div><div id="42558535" class="c"><input type="checkbox" id="c-42558535" checked=""/><div class="controls bullet"><span class="by">machine_coffee</span><span>|</span><a href="#42558367">parent</a><span>|</span><a href="#42558433">prev</a><span>|</span><a href="#42558871">next</a><span>|</span><label class="collapse" for="c-42558535">[-]</label><label class="expand" for="c-42558535">[3 more]</label></div><br/><div class="children"><div class="content">Also surprised an async completion was writing to the stack. You should normally pass a heap buffer to these functions and keep it alive e.g for the lifetime of the object being watched.</div><br/><div id="42560082" class="c"><input type="checkbox" id="c-42560082" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#42558367">root</a><span>|</span><a href="#42558535">parent</a><span>|</span><a href="#42559301">next</a><span>|</span><label class="collapse" for="c-42560082">[-]</label><label class="expand" for="c-42560082">[1 more]</label></div><br/><div class="children"><div class="content">select() (written in C, a language without exceptions) is synchronous, its authors just (reasonably) did not expect an exception to be thrown in the middle of it invoking a blocking syscall.  The algorithm was correct in the absence of a language feature C simply does not have and that is relatively surprising (you don&#x27;t expect syscalls to throw in C++ either).</div><br/></div></div><div id="42559301" class="c"><input type="checkbox" id="c-42559301" checked=""/><div class="controls bullet"><span class="by">muststopmyths</span><span>|</span><a href="#42558367">root</a><span>|</span><a href="#42558535">parent</a><span>|</span><a href="#42560082">prev</a><span>|</span><a href="#42558871">next</a><span>|</span><label class="collapse" for="c-42559301">[-]</label><label class="expand" for="c-42559301">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not an async completion. The call is synchronous.<p>Windows allows some synchronous calls to be interrupted by another thread to run an APC if the called thread is in an &quot;alertable wait&quot; state.  The interrupted thread then returns to the blocking call, so the pointers in the call are expected to be valid.<p>Edit 2: I should clarify that the thread returns to the blocking call, which then exits with WAIT_IO_COMPLETION status. So you have to retry it again. but the stack context is expected to be safe.<p>APC is an &quot;Asynchronous procedure call&quot;, which is asynchronous to the calling thread in that it may or may not get run.
Edit: May or may not run a future time.<p>(<a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;sync&#x2F;asynchronous-procedure-calls" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;sync&#x2F;asynchr...</a>)<p>There are very limited things you are supposed to do in an APC, but these are poorly documented and need one to think carefully about what is happening when a thread is executing in a stack frame and you interrupt it with this horrorshow.<p>Win32 API is a plethora of footguns. For the uninitiated it can be like playing Minesweeper with code. Or like that scene in Galaxy Quest where the hammers are coming at you at random times as you try to cross a hallway.<p>A lot of it was designed by people who, I think, would call one stupid for holding it wrong.<p>I suppose it&#x27;s a relic of the late 80s and 90s when you crawled on broken glass because there was no other way to get to the other side.<p>You learn a lot of the underlying systems this way, but these days people need to get shit done and move on with their lives.<p>Us olds are left behind staring at nostalgically at our mangled feet while we yell at people to get off our lawns.</div><br/></div></div></div></div><div id="42558871" class="c"><input type="checkbox" id="c-42558871" checked=""/><div class="controls bullet"><span class="by">PhiSchle</span><span>|</span><a href="#42558367">parent</a><span>|</span><a href="#42558535">prev</a><span>|</span><label class="collapse" for="c-42558871">[-]</label><label class="expand" for="c-42558871">[1 more]</label></div><br/><div class="children"><div class="content">You state this like an obvious fact, but it is only obvious if you either heard of something like this, or you&#x27;ve been through it.<p>From that point on I am sure he knew to do that. What&#x27;s obvious to you can also just be your experience.</div><br/></div></div></div></div></div></div></div></div></div></body></html>