<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1723971667778" as="style"/><link rel="stylesheet" href="styles.css?v=1723971667778"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://kokada.capivaras.dev/blog/an-unordered-list-of-things-i-miss-in-go/">An unordered list of things I miss in Go</a> <span class="domain">(<a href="https://kokada.capivaras.dev">kokada.capivaras.dev</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>141 comments</span></div><br/><div><div id="41281061" class="c"><input type="checkbox" id="c-41281061" checked=""/><div class="controls bullet"><span class="by">kitd</span><span>|</span><a href="#41276107">next</a><span>|</span><label class="collapse" for="c-41281061">[-]</label><label class="expand" for="c-41281061">[1 more]</label></div><br/><div class="children"><div class="content">I disagree with having the ordering embedded into the map implementation. That imposes an unnecessary performance overhead to support a small subset of use cases.<p>I think what the author requires is iterating over a sorted list of keys. That is pretty easy to implement using the standard library, and imposes the performance penalty only when it is needed.</div><br/></div></div><div id="41276107" class="c"><input type="checkbox" id="c-41276107" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#41281061">prev</a><span>|</span><a href="#41277011">next</a><span>|</span><label class="collapse" for="c-41276107">[-]</label><label class="expand" for="c-41276107">[8 more]</label></div><br/><div class="children"><div class="content">&gt; While I understand the reason for this (i.e.: to avoid developers relying in a specific iteration order), I still find it weird, and I think this is something unique for Go.<p>Rust&#x27;s `HashMap` and `HashSet` also do the same with the default hasher (you can plug your own deterministic hasher though). The reason for this choice, which I think also applies to Go, is to be resistant against HashDOS attacks, which can lead to hashmap lookups becoming O(n) on average. This is especially important for maps that will contain data coming from untrusted sources, like data submitted in a GET&#x2F;POST request.<p>I do agree though that an ordered map would nicely solve the issue.</div><br/><div id="41278604" class="c"><input type="checkbox" id="c-41278604" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#41276107">parent</a><span>|</span><a href="#41280229">next</a><span>|</span><label class="collapse" for="c-41278604">[-]</label><label class="expand" for="c-41278604">[5 more]</label></div><br/><div class="children"><div class="content"><i>&gt; I do agree though that an ordered map would nicely solve the issue.</i><p>To be precise, Rust does provide an ordered map in the standard library, it&#x27;s std::collections::BTreeMap. However, iteration order is key comparison order, not insertion order.</div><br/><div id="41280370" class="c"><input type="checkbox" id="c-41280370" checked=""/><div class="controls bullet"><span class="by">yarg</span><span>|</span><a href="#41276107">root</a><span>|</span><a href="#41278604">parent</a><span>|</span><a href="#41280229">next</a><span>|</span><label class="collapse" for="c-41280370">[-]</label><label class="expand" for="c-41280370">[4 more]</label></div><br/><div class="children"><div class="content">If you want insertion order you need something like a LinkedHashMap.<p>Java&#x27;s had that forever, but it&#x27;s not really a common use case.</div><br/><div id="41280631" class="c"><input type="checkbox" id="c-41280631" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#41276107">root</a><span>|</span><a href="#41280370">parent</a><span>|</span><a href="#41280424">next</a><span>|</span><label class="collapse" for="c-41280631">[-]</label><label class="expand" for="c-41280631">[2 more]</label></div><br/><div class="children"><div class="content">I personally prefer something like Rust&#x27;s `indexmap` instead, which is basically a hash table mapping from key to an index into a `Vec` containing the values. AFAIK this is also the approach taken by C#&#x27;s Dictionary.</div><br/><div id="41280859" class="c"><input type="checkbox" id="c-41280859" checked=""/><div class="controls bullet"><span class="by">KMag</span><span>|</span><a href="#41276107">root</a><span>|</span><a href="#41280631">parent</a><span>|</span><a href="#41280424">next</a><span>|</span><label class="collapse" for="c-41280859">[-]</label><label class="expand" for="c-41280859">[1 more]</label></div><br/><div class="children"><div class="content">I believe one rewrite of Python&#x27;s dict was the first mainstream use of this sort of hash map as a default implementation.<p>I wish they provided a sort method to re-sort and re-index the vector to change the iteration order without the space overhead of creating a and sorting a separate vector&#x2F;list of keys (or key-value pairs, depending on use case.  You might want to change iteration order based on the currently held value).</div><br/></div></div></div></div><div id="41280424" class="c"><input type="checkbox" id="c-41280424" checked=""/><div class="controls bullet"><span class="by">rezaprima</span><span>|</span><a href="#41276107">root</a><span>|</span><a href="#41280370">parent</a><span>|</span><a href="#41280631">prev</a><span>|</span><a href="#41280229">next</a><span>|</span><label class="collapse" for="c-41280424">[-]</label><label class="expand" for="c-41280424">[1 more]</label></div><br/><div class="children"><div class="content">first time I know of LinkedHashMap is by reading a JSON library (Jason, iirc).</div><br/></div></div></div></div></div></div><div id="41280229" class="c"><input type="checkbox" id="c-41280229" checked=""/><div class="controls bullet"><span class="by">meling</span><span>|</span><a href="#41276107">parent</a><span>|</span><a href="#41278604">prev</a><span>|</span><a href="#41278738">next</a><span>|</span><label class="collapse" for="c-41280229">[-]</label><label class="expand" for="c-41280229">[1 more]</label></div><br/><div class="children"><div class="content">Since Go 1.23 you can do this: slices.Sorted(maps.Keys(m))</div><br/></div></div><div id="41278738" class="c"><input type="checkbox" id="c-41278738" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41276107">parent</a><span>|</span><a href="#41280229">prev</a><span>|</span><a href="#41277011">next</a><span>|</span><label class="collapse" for="c-41278738">[-]</label><label class="expand" for="c-41278738">[1 more]</label></div><br/><div class="children"><div class="content">&gt; lookups becoming O(n) on average.<p>If you&#x27;re using a central dictionary then it should be worst case O(log n),  but the price you pay for that is attacker controlled allocated memory growth.</div><br/></div></div></div></div><div id="41277011" class="c"><input type="checkbox" id="c-41277011" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#41276107">prev</a><span>|</span><a href="#41278384">next</a><span>|</span><label class="collapse" for="c-41277011">[-]</label><label class="expand" for="c-41277011">[6 more]</label></div><br/><div class="children"><div class="content">&gt;<i>While I understand the reason for this (i.e.: to avoid developers relying in a specific iteration order), I still find it weird, and I think this is something unique for Go. This decision means that even if you don&#x27;t care about a specific order, you will still need to sort the map before doing something else if you want reproducibility</i><p>Even if they didn&#x27;t randomize, unless they also explicitly guaranteed stable map order across versions, you DO need to sort the map if you want reproducibility.<p>Because if you relied on it being conveniently stable within the same Go version, with no guarantees, your program would still be broken (reproducibility wise), if they changed the hashmap implementation.</div><br/><div id="41278998" class="c"><input type="checkbox" id="c-41278998" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#41277011">parent</a><span>|</span><a href="#41279179">next</a><span>|</span><label class="collapse" for="c-41278998">[-]</label><label class="expand" for="c-41278998">[1 more]</label></div><br/><div class="children"><div class="content">There was a very insightful comment here on HN a while back; someone noted how terrible some SAP UI for travel was, because it provided a huge list of destinations in random order.<p>The insightful comment said they were sure that whoever was implementing the UI noted the list of destinations was always ordered, so never bothered to sort out themselves. And I guess the data source never guaranteed it was ordered, it was just a coincidence, and one day they stopped providing the list in-order.</div><br/></div></div><div id="41279179" class="c"><input type="checkbox" id="c-41279179" checked=""/><div class="controls bullet"><span class="by">kokada</span><span>|</span><a href="#41277011">parent</a><span>|</span><a href="#41278998">prev</a><span>|</span><a href="#41278384">next</a><span>|</span><label class="collapse" for="c-41279179">[-]</label><label class="expand" for="c-41279179">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Even if they didn&#x27;t randomize, unless they also explicitly guaranteed stable map order across versions, you DO need to sort the map if you want reproducibility.<p>Author here.<p>The particular case where this behaviour took me by surprise was when I wanted to print all available options from a toy CLI program that I wrote. I defined the options in a map (that had a function handler as a value) and didn&#x27;t care about the order at all, but at least I expected the print order to be stable.<p>So it took me by surprise when I ran the program 3 times and the order changed. First I thought I did something wrong, then I found the issue after some search.<p>Now, it can be argued that this behaviour was good because I ended up sorting the values before printing, and now they have a predictable order. But I still think this was that kind of code that I didn&#x27;t have to write (thanks to how Go works, I need to create a separate list and sort it instead; I think it is better with iterators in Go 1.23 though).<p>&gt; Because if you relied on it being conveniently stable within the same Go version, with no guarantees, your program would still be broken (reproducibility wise), if they changed the hashmap implementation.<p>Well, not in this particular case. I just wanted it to print it in a stable way between multiple runs of the program. Again, maybe this whole thing helped me write a better program. But I still feel that it is unnecessary, and would prefer to just use a orderedmap instead.</div><br/><div id="41279966" class="c"><input type="checkbox" id="c-41279966" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41277011">root</a><span>|</span><a href="#41279179">parent</a><span>|</span><a href="#41280434">next</a><span>|</span><label class="collapse" for="c-41279966">[-]</label><label class="expand" for="c-41279966">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; But I still feel that it is unnecessary</i><p>So did Go in the early days, which quickly proved to be problematic. Randomization was eventually added to try and call attention to buggy (in the typical case; yours may be an exception) code.</div><br/></div></div><div id="41280434" class="c"><input type="checkbox" id="c-41280434" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#41277011">root</a><span>|</span><a href="#41279179">parent</a><span>|</span><a href="#41279966">prev</a><span>|</span><a href="#41280680">next</a><span>|</span><label class="collapse" for="c-41280434">[-]</label><label class="expand" for="c-41280434">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I defined the options in a map (that had a function handler as a value) and didn&#x27;t care about the order at all, but at least I expected the print order to be stable.<p>But that means that you <i>did</i> care about the order. You may not have cared what it was, but you cared that it existed.<p>IOW, you relied on the order.<p>In any hashmap, it&#x27;s a given that you <i>cannot</i> rely on the order. Some languages may explicitly give you those guarantees but that is separate from the prescription for &#x27;hashmap&#x27;.</div><br/></div></div><div id="41280680" class="c"><input type="checkbox" id="c-41280680" checked=""/><div class="controls bullet"><span class="by">thcoldwine</span><span>|</span><a href="#41277011">root</a><span>|</span><a href="#41279179">parent</a><span>|</span><a href="#41280434">prev</a><span>|</span><a href="#41278384">next</a><span>|</span><label class="collapse" for="c-41280680">[-]</label><label class="expand" for="c-41280680">[1 more]</label></div><br/><div class="children"><div class="content">SQL does not guarantee the order, as well as go but we don’t complain about this in SQL :)<p>Some things needs to be accepted and I am actually glad go does randomization of the order — it makes programs more robust if the backing storage of the map will change in the future.<p>Having better data structures in stdlib will be beneficial, but we just got iterators so this will follow in 1-3 years time I believe.<p>I would prefer to not have generics in the language personally, but luckily they’re not that common in the codebases anyways.</div><br/></div></div></div></div></div></div><div id="41278384" class="c"><input type="checkbox" id="c-41278384" checked=""/><div class="controls bullet"><span class="by">garyrob</span><span>|</span><a href="#41277011">prev</a><span>|</span><a href="#41278787">next</a><span>|</span><label class="collapse" for="c-41278384">[-]</label><label class="expand" for="c-41278384">[7 more]</label></div><br/><div class="children"><div class="content">Borgo is an interesting attempt to address some of these issues. I would love it to get real traction.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;borgo-lang&#x2F;borgo">https:&#x2F;&#x2F;github.com&#x2F;borgo-lang&#x2F;borgo</a></div><br/><div id="41278580" class="c"><input type="checkbox" id="c-41278580" checked=""/><div class="controls bullet"><span class="by">0cf8612b2e1e</span><span>|</span><a href="#41278384">parent</a><span>|</span><a href="#41279826">next</a><span>|</span><label class="collapse" for="c-41278580">[-]</label><label class="expand" for="c-41278580">[2 more]</label></div><br/><div class="children"><div class="content">This looks incredible. I used to write Go, but it always felt like wearing a straight jacket. Too many missing features relative to alternatives, but this fixes a big list of my complaints.<p>I am leery to tap into a new ecosystem, but the risk in this case might not be terrible. Theoretically, you could always take the transpiled code and port to idiomatic Go if the project died.</div><br/><div id="41278740" class="c"><input type="checkbox" id="c-41278740" checked=""/><div class="controls bullet"><span class="by">garyrob</span><span>|</span><a href="#41278384">root</a><span>|</span><a href="#41278580">parent</a><span>|</span><a href="#41279826">next</a><span>|</span><label class="collapse" for="c-41278740">[-]</label><label class="expand" for="c-41278740">[1 more]</label></div><br/><div class="children"><div class="content">Yeah. That&#x27;s similar to my thoughts. But only 2 contributors and no update in 3 months. And there are a number of open issues with zero responses. I&#x27;m not in a position to contribute myself. I don&#x27;t know enough about compiling&#x2F;transpiling and I have too much on my plate already. So I can&#x27;t complain, but I&#x27;d by happy if more people joined the project and it had more activity. It&#x27;s exactly what I&#x27;m looking for.</div><br/></div></div></div></div><div id="41279826" class="c"><input type="checkbox" id="c-41279826" checked=""/><div class="controls bullet"><span class="by">nickm12</span><span>|</span><a href="#41278384">parent</a><span>|</span><a href="#41278580">prev</a><span>|</span><a href="#41279032">next</a><span>|</span><label class="collapse" for="c-41279826">[-]</label><label class="expand" for="c-41279826">[2 more]</label></div><br/><div class="children"><div class="content">It looks like Borgo is to Golang what Typescript is to Javascript. It&#x27;s kind of ridiculous that Golang would need this, but it actually makes sense to me as something you&#x27;d want to use.</div><br/><div id="41280219" class="c"><input type="checkbox" id="c-41280219" checked=""/><div class="controls bullet"><span class="by">antonvs</span><span>|</span><a href="#41278384">root</a><span>|</span><a href="#41279826">parent</a><span>|</span><a href="#41279032">next</a><span>|</span><label class="collapse" for="c-41280219">[-]</label><label class="expand" for="c-41280219">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s kind of ridiculous that Golang would need this<p>It&#x27;s because Go is a ridiculous language. People don&#x27;t want to admit this, but it was designed by people stuck in the last millennium when it comes to language design.</div><br/></div></div></div></div><div id="41279032" class="c"><input type="checkbox" id="c-41279032" checked=""/><div class="controls bullet"><span class="by">jfoudfwfayasd</span><span>|</span><a href="#41278384">parent</a><span>|</span><a href="#41279826">prev</a><span>|</span><a href="#41279813">next</a><span>|</span><label class="collapse" for="c-41279032">[-]</label><label class="expand" for="c-41279032">[1 more]</label></div><br/><div class="children"><div class="content">Go with a competent type system would be wonderful</div><br/></div></div><div id="41279813" class="c"><input type="checkbox" id="c-41279813" checked=""/><div class="controls bullet"><span class="by">qaq</span><span>|</span><a href="#41278384">parent</a><span>|</span><a href="#41279032">prev</a><span>|</span><a href="#41278787">next</a><span>|</span><label class="collapse" for="c-41279813">[-]</label><label class="expand" for="c-41279813">[1 more]</label></div><br/><div class="children"><div class="content">Was really excited when I first found it but it looks abandoned</div><br/></div></div></div></div><div id="41278787" class="c"><input type="checkbox" id="c-41278787" checked=""/><div class="controls bullet"><span class="by">akdor1154</span><span>|</span><a href="#41278384">prev</a><span>|</span><a href="#41275771">next</a><span>|</span><label class="collapse" for="c-41278787">[-]</label><label class="expand" for="c-41278787">[1 more]</label></div><br/><div class="children"><div class="content">Nillability is the biggest thing that drives me to write &#x27;unidiomatic go&#x27;: there are a few Optional libs around, they work ok.<p>I write with the following rule: if a pointer is passed, it shouldn&#x27;t be nil. If it might be nil, code it as an Optional&lt;&gt; instead.<p>Un-golike but works great.</div><br/></div></div><div id="41275771" class="c"><input type="checkbox" id="c-41275771" checked=""/><div class="controls bullet"><span class="by">donatj</span><span>|</span><a href="#41278787">prev</a><span>|</span><a href="#41275685">next</a><span>|</span><label class="collapse" for="c-41275771">[-]</label><label class="expand" for="c-41275771">[4 more]</label></div><br/><div class="children"><div class="content">The lack of default argument values initially annoyed me, but I kind of came to like it. It makes me put more thought into my function interfaces.<p>In the rare cases I do want a default it&#x27;s usually reasonable to just add a second function that calls the first with the default value.<p>I don&#x27;t end up doing this a lot, but I certainly have in a couple handful of cases. A lot of Go libraries for HTTP related activities do this with the default context. They&#x27;ll have a function that accepts a context and a function that has the default context.<p>Example<p><a href="https:&#x2F;&#x2F;github.com&#x2F;slack-go&#x2F;slack&#x2F;blob&#x2F;242df4614edb261e5f4f4a3907c979caf6b4977c&#x2F;users.go#L252">https:&#x2F;&#x2F;github.com&#x2F;slack-go&#x2F;slack&#x2F;blob&#x2F;242df4614edb261e5f4f4...</a><p>Honestly, with good naming, I think this is just generally more readable and expectable behavior only takes three lines of code.</div><br/><div id="41275862" class="c"><input type="checkbox" id="c-41275862" checked=""/><div class="controls bullet"><span class="by">wild_egg</span><span>|</span><a href="#41275771">parent</a><span>|</span><a href="#41275827">next</a><span>|</span><label class="collapse" for="c-41275862">[-]</label><label class="expand" for="c-41275862">[1 more]</label></div><br/><div class="children"><div class="content">FWIW a lot of those packages with default context wrapper functions have that as a backwards compatibility measure for code written before the context package existed. It&#x27;s almost always preferable to call the newer function with your own context instead</div><br/></div></div><div id="41275827" class="c"><input type="checkbox" id="c-41275827" checked=""/><div class="controls bullet"><span class="by">mrj</span><span>|</span><a href="#41275771">parent</a><span>|</span><a href="#41275862">prev</a><span>|</span><a href="#41275685">next</a><span>|</span><label class="collapse" for="c-41275827">[-]</label><label class="expand" for="c-41275827">[2 more]</label></div><br/><div class="children"><div class="content">Sure, one can make a new function. That&#x27;s what I do, too, but then I end up greatly missing function overloading. In the example&#x27;s case I might end up making a ReplaceAll function. It creates namespace clutter.<p>Function overloading could easily handle context with and without arguments.</div><br/><div id="41278368" class="c"><input type="checkbox" id="c-41278368" checked=""/><div class="controls bullet"><span class="by">enneff</span><span>|</span><a href="#41275771">root</a><span>|</span><a href="#41275827">parent</a><span>|</span><a href="#41275685">next</a><span>|</span><label class="collapse" for="c-41278368">[-]</label><label class="expand" for="c-41278368">[1 more]</label></div><br/><div class="children"><div class="content">I think if there are a lot of functions (or a function with a lot of arguments, common to python) you have clutter regardless. I would rather have a bunch of different names than a bunch of different functions with the same name. Having to choose names for each of the functions is a gentle push back asking “do you really need all these flavours of function or are you abstracting this in the wrong way?”</div><br/></div></div></div></div></div></div><div id="41275685" class="c"><input type="checkbox" id="c-41275685" checked=""/><div class="controls bullet"><span class="by">cempaka</span><span>|</span><a href="#41275771">prev</a><span>|</span><a href="#41279767">next</a><span>|</span><label class="collapse" for="c-41275685">[-]</label><label class="expand" for="c-41275685">[34 more]</label></div><br/><div class="children"><div class="content">&gt; <i>While I understand the reason for this (i.e.: to avoid developers relying in a specific iteration order), I still find it weird, and I think this is something unique for Go.</i><p>Haha well, fun fact, Java did this as well after a bunch of code was broken by a JDK upgrade which changed HashMap iteration order that programmers had been relying upon. Java does at least have ordered maps in the standard lib though. IMO it is a questionable decision to spend CPU resources on randomization in order to mollycoddle programmers with a flawed understanding of an API like this, but then again I&#x27;m not the one who gets the backlash when their stuff breaks.<p>Also, on the subject of nullability, while JSR305 may be considered dead, there&#x27;s still pretty active work on the Java nullability question both from the angle of tooling (<a href="https:&#x2F;&#x2F;www.infoq.com&#x2F;news&#x2F;2024&#x2F;08&#x2F;jspecify-java-nullability&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.infoq.com&#x2F;news&#x2F;2024&#x2F;08&#x2F;jspecify-java-nullability...</a>) and language design (<a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;8316779" rel="nofollow">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;8316779</a>).</div><br/><div id="41281081" class="c"><input type="checkbox" id="c-41281081" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#41275685">parent</a><span>|</span><a href="#41275744">next</a><span>|</span><label class="collapse" for="c-41281081">[-]</label><label class="expand" for="c-41281081">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s one of the things I like in Kotlin: it defaults to using ordered maps. It also has default arguments in functions, lambda functions, and of course nullable types.</div><br/></div></div><div id="41275744" class="c"><input type="checkbox" id="c-41275744" checked=""/><div class="controls bullet"><span class="by">kevindamm</span><span>|</span><a href="#41275685">parent</a><span>|</span><a href="#41281081">prev</a><span>|</span><a href="#41275993">next</a><span>|</span><label class="collapse" for="c-41275744">[-]</label><label class="expand" for="c-41275744">[1 more]</label></div><br/><div class="children"><div class="content">I was about to comment the same.  Also happened in absl (Google&#x27;s alternative to the STL template library for C++ which started its life as GTL) -- when changing the default hash function for unordered maps it led to breaking changes in both test and production code that had depended on it.<p>OrderedDict types are nice sometimes but shouldn&#x27;t be the default behavior, IMO.<p>There are good reasons for the second point (about default&#x2F;named parameters) -- any calling code is making some assumptions based on that default value so there&#x27;s a risk it can&#x27;t be changed or added to.  If you really want a default value, make a wrapper function for it.  In the example it would be a simple matter of defining ReplaceAll with three arguments that always passes -1 to Replace(...)</div><br/></div></div><div id="41275993" class="c"><input type="checkbox" id="c-41275993" checked=""/><div class="controls bullet"><span class="by">jsnell</span><span>|</span><a href="#41275685">parent</a><span>|</span><a href="#41275744">prev</a><span>|</span><a href="#41279107">next</a><span>|</span><label class="collapse" for="c-41275993">[-]</label><label class="expand" for="c-41275993">[4 more]</label></div><br/><div class="children"><div class="content">Perl has done per-run randomization of the iteration order as well for a while (more than a decade).<p><pre><code>    % repeat 5 perl -e &#x27;%h=(a =&gt; 1, b  =&gt; 2, c=&gt; 3); print for keys %h; print &quot;\n&quot;&#x27;
    bca
    cba
    bac
    bac
    bac</code></pre></div><br/></div></div><div id="41279107" class="c"><input type="checkbox" id="c-41279107" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41275685">parent</a><span>|</span><a href="#41275993">prev</a><span>|</span><a href="#41276121">next</a><span>|</span><label class="collapse" for="c-41279107">[-]</label><label class="expand" for="c-41279107">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Java did this as well after a bunch of code was broken by a JDK upgrade which changed HashMap iteration order that programmers had been relying upon.<p>This is incorrect (or I’m misunderstanding you). OpenJDK’s HashMap doesn’t use randomization, and the iteration order is thus deterministic under that implementation, although the API specification does not guarantee it. To mitigate DoS attacks, keys in the same hash bucket are stored as a balanced tree. For keys that implement <i>Comparable</i> (strings in particular), this guarantees O(n log n).</div><br/><div id="41279340" class="c"><input type="checkbox" id="c-41279340" checked=""/><div class="controls bullet"><span class="by">cempaka</span><span>|</span><a href="#41275685">root</a><span>|</span><a href="#41279107">parent</a><span>|</span><a href="#41276121">next</a><span>|</span><label class="collapse" for="c-41279340">[-]</label><label class="expand" for="c-41279340">[1 more]</label></div><br/><div class="children"><div class="content">Ah you&#x27;re right, what I had in mind was the iteration order of the immutable&#x2F;unmodifiable maps created by Collections.unmodifiableMap() or Map.of(): <a href="https:&#x2F;&#x2F;docs.oracle.com&#x2F;en&#x2F;java&#x2F;javase&#x2F;20&#x2F;core&#x2F;creating-immutable-lists-sets-and-maps.html" rel="nofollow">https:&#x2F;&#x2F;docs.oracle.com&#x2F;en&#x2F;java&#x2F;javase&#x2F;20&#x2F;core&#x2F;creating-immu...</a></div><br/></div></div></div></div><div id="41276121" class="c"><input type="checkbox" id="c-41276121" checked=""/><div class="controls bullet"><span class="by">barsonme</span><span>|</span><a href="#41275685">parent</a><span>|</span><a href="#41279107">prev</a><span>|</span><a href="#41276092">next</a><span>|</span><label class="collapse" for="c-41276121">[-]</label><label class="expand" for="c-41276121">[2 more]</label></div><br/><div class="children"><div class="content">&gt; IMO it is a questionable decision to spend CPU resources on randomization …<p>It takes about 3 ns to choose a random starting bucket, which is basically free relative to the iteration itself.</div><br/><div id="41276411" class="c"><input type="checkbox" id="c-41276411" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#41275685">root</a><span>|</span><a href="#41276121">parent</a><span>|</span><a href="#41276092">next</a><span>|</span><label class="collapse" for="c-41276411">[-]</label><label class="expand" for="c-41276411">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t the trick that the runtime picks another hash-constant every time?</div><br/></div></div></div></div><div id="41276092" class="c"><input type="checkbox" id="c-41276092" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#41275685">parent</a><span>|</span><a href="#41276121">prev</a><span>|</span><a href="#41276061">next</a><span>|</span><label class="collapse" for="c-41276092">[-]</label><label class="expand" for="c-41276092">[13 more]</label></div><br/><div class="children"><div class="content">They just added custom iterators (&quot;range over func&quot;) to the language in 1.23 but somehow missed the obvious opportunity to add e.g. maps.SortedByKeys. It&#x27;s clunky to write:<p><pre><code>    for _, k := range slices.Sorted(maps.Keys(m)) {
        v := m[k]
        _ = v &#x2F;&#x2F; do something with k and v
    }
</code></pre>
though, it&#x27;s not as bad as before:<p><pre><code>    keys := make([]string, 0, len(m))
    for k := range m {
        keys = append(keys, k)
    }
    slices.Sort(keys)
    for _, k := range keys {
        v := m[k]
        _ = v
    }</code></pre></div><br/><div id="41276263" class="c"><input type="checkbox" id="c-41276263" checked=""/><div class="controls bullet"><span class="by">38</span><span>|</span><a href="#41275685">root</a><span>|</span><a href="#41276092">parent</a><span>|</span><a href="#41276061">next</a><span>|</span><label class="collapse" for="c-41276263">[-]</label><label class="expand" for="c-41276263">[12 more]</label></div><br/><div class="children"><div class="content">&gt; maps.SortedByKeys<p>thats what you call overfitting kids</div><br/><div id="41276540" class="c"><input type="checkbox" id="c-41276540" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#41275685">root</a><span>|</span><a href="#41276263">parent</a><span>|</span><a href="#41276061">next</a><span>|</span><label class="collapse" for="c-41276540">[-]</label><label class="expand" for="c-41276540">[11 more]</label></div><br/><div class="children"><div class="content">Whatever you think the best name for it is, it&#x27;s still missing from the library.</div><br/><div id="41278159" class="c"><input type="checkbox" id="c-41278159" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#41275685">root</a><span>|</span><a href="#41276540">parent</a><span>|</span><a href="#41277019">next</a><span>|</span><label class="collapse" for="c-41278159">[-]</label><label class="expand" for="c-41278159">[8 more]</label></div><br/><div class="children"><div class="content">I think the problem with putting this into the standard library is that while Go may not be super focused on absolutely top-tier performance, it does generally try to avoid offering things that are unexpectedly slow or unexpectedly allocate large things. A sort-by-keys on the standard map would require allocating a full slice for the keys in the sort routine to do the sort, which would surprise people who expect build-in iterators to not immediately do that.<p>Plus it&#x27;s in the class of things that&#x27;s pretty easy to implement yourself now. There&#x27;s always a huge supply of &quot;but the library could just compose these two things for me&quot;. If you stick them all in things get bloated. You could literally have written it in the time it took to write the complaint. You got 80% of the way there as it is, I just tweaked your code a bit to turn it into an iterator: <a href="https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;agBGl_rT7XS" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;agBGl_rT7XS</a></div><br/><div id="41279436" class="c"><input type="checkbox" id="c-41279436" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#41275685">root</a><span>|</span><a href="#41278159">parent</a><span>|</span><a href="#41278770">next</a><span>|</span><label class="collapse" for="c-41279436">[-]</label><label class="expand" for="c-41279436">[2 more]</label></div><br/><div class="children"><div class="content">As I mentioned in another reply, this simple solution is not cache-friendly.</div><br/></div></div><div id="41278770" class="c"><input type="checkbox" id="c-41278770" checked=""/><div class="controls bullet"><span class="by">38</span><span>|</span><a href="#41275685">root</a><span>|</span><a href="#41278159">parent</a><span>|</span><a href="#41279436">prev</a><span>|</span><a href="#41277019">next</a><span>|</span><label class="collapse" for="c-41278770">[-]</label><label class="expand" for="c-41278770">[5 more]</label></div><br/><div class="children"><div class="content">its completely pointless to make this an iterator, because you have to loop the entire map to do so, which kills any benefit of using iterators</div><br/><div id="41280203" class="c"><input type="checkbox" id="c-41280203" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41275685">root</a><span>|</span><a href="#41278770">parent</a><span>|</span><a href="#41279426">next</a><span>|</span><label class="collapse" for="c-41280203">[-]</label><label class="expand" for="c-41280203">[1 more]</label></div><br/><div class="children"><div class="content">Not completely pointless. It avoids the need to retain a full copy of all the values.<p>But a good demonstration of why this kind of thing isn&#x27;t a good fit for the standard library.</div><br/></div></div><div id="41279426" class="c"><input type="checkbox" id="c-41279426" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#41275685">root</a><span>|</span><a href="#41278770">parent</a><span>|</span><a href="#41280203">prev</a><span>|</span><a href="#41277019">next</a><span>|</span><label class="collapse" for="c-41279426">[-]</label><label class="expand" for="c-41279426">[3 more]</label></div><br/><div class="children"><div class="content">And yet slices.Sorted was added which does exactly this already, but only for single-valued iterators.</div><br/><div id="41280035" class="c"><input type="checkbox" id="c-41280035" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41275685">root</a><span>|</span><a href="#41279426">parent</a><span>|</span><a href="#41280002">prev</a><span>|</span><a href="#41277019">next</a><span>|</span><label class="collapse" for="c-41280035">[-]</label><label class="expand" for="c-41280035">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; And yet slices.Sorted was added which does exactly this already</i><p>It does not. slices.Sorted <i>accepts</i> an iterator, but returns a slice.<p>Like the earlier comments point out, Go tries its best to give a reasonable idea of what kind of complexity is involved at the API level. slices.Sorted returning an iterator would mask that. By returning a slice, it makes clear that the entire collection of data needs to be first iterated over as the parent described.</div><br/></div></div></div></div></div></div></div></div><div id="41277019" class="c"><input type="checkbox" id="c-41277019" checked=""/><div class="controls bullet"><span class="by">38</span><span>|</span><a href="#41275685">root</a><span>|</span><a href="#41276540">parent</a><span>|</span><a href="#41278159">prev</a><span>|</span><a href="#41276061">next</a><span>|</span><label class="collapse" for="c-41277019">[-]</label><label class="expand" for="c-41277019">[2 more]</label></div><br/><div class="children"><div class="content">the point is you dont need it. by your own admission, it would save literally 0 lines of code from your current example. you need discipline when adding sugar otherwise you can ruin a language.</div><br/><div id="41277064" class="c"><input type="checkbox" id="c-41277064" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#41275685">root</a><span>|</span><a href="#41277019">parent</a><span>|</span><a href="#41276061">next</a><span>|</span><label class="collapse" for="c-41277064">[-]</label><label class="expand" for="c-41277064">[1 more]</label></div><br/><div class="children"><div class="content">I said no such thing.<p>First, it <i>would</i> save one line of code (v := m[k]). Second, it would also allow an optimization. When iterating a map directly, you have both the key and the value at the same time. However, since we iterate only the keys here, we then have to look up the value anew for each key. That takes extra time and, for large maps, will thrash the CPU cache.<p>So the following would be both fewer lines of code and faster:<p><pre><code>    for k, v := range maps.Sorted(m) {
        &#x2F;&#x2F; do something with k and v
    }
</code></pre>
Making common operations clear and concise is not mere sugar in my opinion. It not only improves the developer experience, it also clarifies the developer&#x27;s intent, which enables better optimizations, and allows bugs and traps to be addressed in one place, instead of languishing in far-flung places.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41276061" class="c"><input type="checkbox" id="c-41276061" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41275685">parent</a><span>|</span><a href="#41276092">prev</a><span>|</span><a href="#41275794">next</a><span>|</span><label class="collapse" for="c-41276061">[-]</label><label class="expand" for="c-41276061">[1 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t call it mollycoddling. I can understand why people make that mistake. Interfaces should be designed to reduce the chance of mistakes as much as possible, under the knowledge that people (including you!) make mistakes. They shouldn&#x27;t be designed under the assumption that people always read and understand the manual and never make mistakes.<p>That&#x27;s why we don&#x27;t do `load` and `load_safe`; we do `load` and `load_unsafe`.</div><br/></div></div><div id="41275794" class="c"><input type="checkbox" id="c-41275794" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#41275685">parent</a><span>|</span><a href="#41276061">prev</a><span>|</span><a href="#41278619">next</a><span>|</span><label class="collapse" for="c-41275794">[-]</label><label class="expand" for="c-41275794">[7 more]</label></div><br/><div class="children"><div class="content">Because it came up recently for me (triggered a starvation bug), a caution for people expecting Go to randomize everything like this:<p>Blocked channel reads and writes are unblocked in FIFO order, not random.  Mutexes are similar (afaict not quite identical, but the intent is the same).<p>Go randomizes a lot and I am <i>thrilled</i> they do that, and I knew about mutexes already, but the chan part was a surprise to me.  It&#x27;s reasonable and matches mutexes, so that&#x27;s probably for the better, but still a bit oof.</div><br/><div id="41278758" class="c"><input type="checkbox" id="c-41278758" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41275685">root</a><span>|</span><a href="#41275794">parent</a><span>|</span><a href="#41276311">next</a><span>|</span><label class="collapse" for="c-41278758">[-]</label><label class="expand" for="c-41278758">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Blocked channel reads and writes are unblocked in FIFO order, not random<p>This should be obvious since the buffer is optional.<p>&gt; but the chan part was a surprise to me<p>With multiple receivers it is effectively random _which_ receiver gets the wakeup.</div><br/><div id="41279428" class="c"><input type="checkbox" id="c-41279428" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#41275685">root</a><span>|</span><a href="#41278758">parent</a><span>|</span><a href="#41276311">next</a><span>|</span><label class="collapse" for="c-41279428">[-]</label><label class="expand" for="c-41279428">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I don&#x27;t mean <i>buffered data</i>. I mean blocked queueing operations.<p>&gt;<i>With multiple receivers it is effectively random _which_ receiver gets the wakeup.</i><p>That&#x27;s why I brought it up: no it isn&#x27;t. It&#x27;s ordered. Intentionally.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;11506">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;11506</a><p>It&#x27;s pretty easy to prove to yourself too, it only takes a couple dozen lines to write a test.  I&#x27;m not confident it&#x27;s <i>guaranteed</i> in all scenarios (mutexes are not, for example), but I&#x27;ve yet to see it do anything but perfect FIFO when not racing on starting both read and write simultaneously.<p>---<p>A <i>single</i> select statement with multiple eligible channel operations <i>is</i> random, which is part of why I expected blocked channel operations themselves to be random.  But nope.</div><br/></div></div></div></div><div id="41276311" class="c"><input type="checkbox" id="c-41276311" checked=""/><div class="controls bullet"><span class="by">hombre_fatal</span><span>|</span><a href="#41275685">root</a><span>|</span><a href="#41275794">parent</a><span>|</span><a href="#41278758">prev</a><span>|</span><a href="#41278619">next</a><span>|</span><label class="collapse" for="c-41276311">[-]</label><label class="expand" for="c-41276311">[4 more]</label></div><br/><div class="children"><div class="content">Meh, what if people rely on randomness. They should flip between random and ordered at random too.</div><br/><div id="41277922" class="c"><input type="checkbox" id="c-41277922" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#41275685">root</a><span>|</span><a href="#41276311">parent</a><span>|</span><a href="#41278769">next</a><span>|</span><label class="collapse" for="c-41277922">[-]</label><label class="expand" for="c-41277922">[1 more]</label></div><br/><div class="children"><div class="content">Well, every once in a while the random order will look like it&#x27;s ordered</div><br/></div></div><div id="41278769" class="c"><input type="checkbox" id="c-41278769" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41275685">root</a><span>|</span><a href="#41276311">parent</a><span>|</span><a href="#41277922">prev</a><span>|</span><a href="#41276445">next</a><span>|</span><label class="collapse" for="c-41278769">[-]</label><label class="expand" for="c-41278769">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Meh, what if people rely on randomness.<p>Then they are creating fragile software.  They&#x27;re always one language version upgrade away from disaster.</div><br/></div></div><div id="41276445" class="c"><input type="checkbox" id="c-41276445" checked=""/><div class="controls bullet"><span class="by">therein</span><span>|</span><a href="#41275685">root</a><span>|</span><a href="#41276311">parent</a><span>|</span><a href="#41278769">prev</a><span>|</span><a href="#41278619">next</a><span>|</span><label class="collapse" for="c-41276445">[-]</label><label class="expand" for="c-41276445">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, gotta keep the programmer on his toes. He needs to embrace non-determinism, and second guess everything.<p>In case Go developer switches to a different language, we don&#x27;t want to build bad habits. Map key iteration should be non-deterministically deterministic.</div><br/></div></div></div></div></div></div><div id="41278619" class="c"><input type="checkbox" id="c-41278619" checked=""/><div class="controls bullet"><span class="by">worik</span><span>|</span><a href="#41275685">parent</a><span>|</span><a href="#41275794">prev</a><span>|</span><a href="#41279767">next</a><span>|</span><label class="collapse" for="c-41278619">[-]</label><label class="expand" for="c-41278619">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Java does at least have ordered maps<p>Weird<p>An &quot;ordered map&quot; is not a hash table. I think they want a tree.<p>But you can get the keys and sort them.<p>I really do not see the problem<p>Use a tree if order matters, Hash if not.<p>(Since I am not a Go programmer,  maybe I missed something)</div><br/><div id="41279043" class="c"><input type="checkbox" id="c-41279043" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41275685">root</a><span>|</span><a href="#41278619">parent</a><span>|</span><a href="#41279767">next</a><span>|</span><label class="collapse" for="c-41279043">[-]</label><label class="expand" for="c-41279043">[1 more]</label></div><br/><div class="children"><div class="content">Java’s LinkedHashMap is a hash table with an additional linked-list structure on the entries that records the insertion order. The map is thus ordered by insertion order, an order that is independent from the keys.<p>A map ordered by keys is a SortedMap in Java. While ordered, LinkedHashMap is not a SortedMap. In other words, unordered &lt; ordered &lt; sorted.</div><br/></div></div></div></div></div></div><div id="41279767" class="c"><input type="checkbox" id="c-41279767" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#41275685">prev</a><span>|</span><a href="#41275668">next</a><span>|</span><label class="collapse" for="c-41279767">[-]</label><label class="expand" for="c-41279767">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve heard this several times - &quot;Go would be great if only they added &lt;my-favourite-feature&gt;&quot;...<p>Go&#x27;s philosophy is that a coherent, curated feature set is as valid an approach to language design as the C++&#x2F;Python&#x2F;... approach of adding every possible language feature.<p>In particular I doubt Go will ever add null-safety - given the above philosophy, the language&#x27;s pervasive use of &quot;zero values&quot;, and its strong commitment to backwards compatibility.</div><br/><div id="41280926" class="c"><input type="checkbox" id="c-41280926" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#41279767">parent</a><span>|</span><a href="#41280581">next</a><span>|</span><label class="collapse" for="c-41280926">[-]</label><label class="expand" for="c-41280926">[1 more]</label></div><br/><div class="children"><div class="content">I can’t see how Go feature list is any more curated or more coherent than in other languages. Seriously to me it feels like many Go features were rushed and some added despite the evidence they are a bad idea. Like, why an unused import &#x2F; unused variable is a hard error but an unused function is not? Or why for a very long time maps and channels were special by being generic but you could not use generics in your own types (that has fortunately changed). Why add nil &#x2F; default values at the time where virtually everybody knows this is a bad feature and there are better solutions established?</div><br/></div></div><div id="41280581" class="c"><input type="checkbox" id="c-41280581" checked=""/><div class="controls bullet"><span class="by">EdwardDiego</span><span>|</span><a href="#41279767">parent</a><span>|</span><a href="#41280926">prev</a><span>|</span><a href="#41275668">next</a><span>|</span><label class="collapse" for="c-41280581">[-]</label><label class="expand" for="c-41280581">[5 more]</label></div><br/><div class="children"><div class="content">How do you distinguish between a value set to zero value explicitly, and one not set?</div><br/><div id="41280777" class="c"><input type="checkbox" id="c-41280777" checked=""/><div class="controls bullet"><span class="by">kzs0</span><span>|</span><a href="#41279767">root</a><span>|</span><a href="#41280581">parent</a><span>|</span><a href="#41280626">next</a><span>|</span><label class="collapse" for="c-41280777">[-]</label><label class="expand" for="c-41280777">[1 more]</label></div><br/><div class="children"><div class="content">In the cases where this is important, you can use pointers. Go allows you to make pointers to primitives as well (making the zero value nil) so you can explicitly define those edge cases.<p>You’d be surprised how infrequently that’s actually a concern though.</div><br/></div></div><div id="41280626" class="c"><input type="checkbox" id="c-41280626" checked=""/><div class="controls bullet"><span class="by">jochem9</span><span>|</span><a href="#41279767">root</a><span>|</span><a href="#41280581">parent</a><span>|</span><a href="#41280777">prev</a><span>|</span><a href="#41275668">next</a><span>|</span><label class="collapse" for="c-41280626">[-]</label><label class="expand" for="c-41280626">[3 more]</label></div><br/><div class="children"><div class="content">There is no difference. You need to handle that based on the context you&#x27;re in.</div><br/><div id="41280636" class="c"><input type="checkbox" id="c-41280636" checked=""/><div class="controls bullet"><span class="by">EdwardDiego</span><span>|</span><a href="#41279767">root</a><span>|</span><a href="#41280626">parent</a><span>|</span><a href="#41275668">next</a><span>|</span><label class="collapse" for="c-41280636">[-]</label><label class="expand" for="c-41280636">[2 more]</label></div><br/><div class="children"><div class="content">I was wondering if there&#x27;s a pattern of using Option types or something to signal the difference.<p>I ask because I hit this issue a fair few years ago with protobuf v3, we ended up using a wrapper type pattern. Can&#x27;t recall why it was important to know at the time, but it was.</div><br/><div id="41280785" class="c"><input type="checkbox" id="c-41280785" checked=""/><div class="controls bullet"><span class="by">the_gipsy</span><span>|</span><a href="#41279767">root</a><span>|</span><a href="#41280636">parent</a><span>|</span><a href="#41275668">next</a><span>|</span><label class="collapse" for="c-41280785">[-]</label><label class="expand" for="c-41280785">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes you can abuse pointers as a (very) poor man&#x27;s Option&lt;T&gt; type.<p>But it&#x27;s turtles all the way down, you can&#x27;t distinguish between for example `null` and &quot;missing&quot; when parsing JSON.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41275668" class="c"><input type="checkbox" id="c-41275668" checked=""/><div class="controls bullet"><span class="by">seabrookmx</span><span>|</span><a href="#41279767">prev</a><span>|</span><a href="#41275893">next</a><span>|</span><label class="collapse" for="c-41275668">[-]</label><label class="expand" for="c-41275668">[4 more]</label></div><br/><div class="children"><div class="content">C# also solved the nullability problem after the fact. It integrates well with the &quot;?.&quot; operator also found in Typescript.</div><br/><div id="41275777" class="c"><input type="checkbox" id="c-41275777" checked=""/><div class="controls bullet"><span class="by">dexwiz</span><span>|</span><a href="#41275668">parent</a><span>|</span><a href="#41275855">next</a><span>|</span><label class="collapse" for="c-41275777">[-]</label><label class="expand" for="c-41275777">[2 more]</label></div><br/><div class="children"><div class="content">Optional chaining is now in vanilla JS.<p><a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Operators&#x2F;Optional_chaining" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Refe...</a></div><br/><div id="41276109" class="c"><input type="checkbox" id="c-41276109" checked=""/><div class="controls bullet"><span class="by">KronisLV</span><span>|</span><a href="#41275668">root</a><span>|</span><a href="#41275777">parent</a><span>|</span><a href="#41275855">next</a><span>|</span><label class="collapse" for="c-41276109">[-]</label><label class="expand" for="c-41276109">[1 more]</label></div><br/><div class="children"><div class="content">This is really pleasant, when combined with the nullish coalescing operator: <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Operators&#x2F;Nullish_coalescing" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Refe...</a><p><pre><code>  const isStatusValid = myStore.someObject?.isStatusValid ?? false;
</code></pre>
(e.g. if some data is not initialized along the way, or you put in some new object which just isn&#x27;t meant to have that field but some related logic needs to check for it)</div><br/></div></div></div></div><div id="41275855" class="c"><input type="checkbox" id="c-41275855" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#41275668">parent</a><span>|</span><a href="#41275777">prev</a><span>|</span><a href="#41275893">next</a><span>|</span><label class="collapse" for="c-41275855">[-]</label><label class="expand" for="c-41275855">[1 more]</label></div><br/><div class="children"><div class="content">Yup, it is Kotlin-style nullability analysis that is a default everywhere now. The last place that does not have ideal behavior is System.Text.Json, but that is fixable with a flag, maybe two, and there are edge cases where static analysis can&#x27;t see through some expressions and assumes null so you have to specify it isn&#x27;t with &#x27;!&#x27;. Nonetheless, works great with &#x27;??&#x27;, &#x27;??=&#x27; expressions, required fields&#x2F;props and pattern matching.<p>From practical standpoint, a project with Nullable: enable, WarningsAsErrors: nullable has almost never have to think about unexpected nulls again - a solved problem.</div><br/></div></div></div></div><div id="41275893" class="c"><input type="checkbox" id="c-41275893" checked=""/><div class="controls bullet"><span class="by">wild_egg</span><span>|</span><a href="#41275668">prev</a><span>|</span><a href="#41280576">next</a><span>|</span><label class="collapse" for="c-41275893">[-]</label><label class="expand" for="c-41275893">[8 more]</label></div><br/><div class="children"><div class="content">Been writing Go since 2012 and consider the status quo on all of these to be _features_. I may be in the minority there though</div><br/><div id="41276360" class="c"><input type="checkbox" id="c-41276360" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#41275893">parent</a><span>|</span><a href="#41280576">next</a><span>|</span><label class="collapse" for="c-41276360">[-]</label><label class="expand" for="c-41276360">[7 more]</label></div><br/><div class="children"><div class="content">Being unable to access struct fields a.b.c without risking a panic sucks (and which caused the panic: a.b or b.c?). There&#x27;s no remotely ergonomic solution to the problem, because there&#x27;s no nil-safe struct member operator, there&#x27;s no ternary operator, and if-statements can&#x27;t be used as expressions.<p>This wouldn&#x27;t be such a problem, since of course you can just &quot;choose&quot; to not use pointer- or interface-typed fields in &quot;your&quot; structs, but as soon as serialization, databases, or other people&#x27;s APIs are involved, you don&#x27;t have that &quot;choice&quot; anymore.<p>In the same vein, being unable to write e.g. &amp;true or &amp;&quot;foo&quot; is annoying too. If I can write &amp;struct{...} why can&#x27;t I write &amp;true?</div><br/><div id="41278074" class="c"><input type="checkbox" id="c-41278074" checked=""/><div class="controls bullet"><span class="by">isodude</span><span>|</span><a href="#41275893">root</a><span>|</span><a href="#41276360">parent</a><span>|</span><a href="#41278886">next</a><span>|</span><label class="collapse" for="c-41278074">[-]</label><label class="expand" for="c-41278074">[2 more]</label></div><br/><div class="children"><div class="content">Horrid, but this works.<p><pre><code>  &amp;([]bool{true}[0])
</code></pre>
But at least it allows me to write it without declaring a variable first.</div><br/></div></div><div id="41278886" class="c"><input type="checkbox" id="c-41278886" checked=""/><div class="controls bullet"><span class="by">postgressomethi</span><span>|</span><a href="#41275893">root</a><span>|</span><a href="#41276360">parent</a><span>|</span><a href="#41278074">prev</a><span>|</span><a href="#41276598">next</a><span>|</span><label class="collapse" for="c-41278886">[-]</label><label class="expand" for="c-41278886">[1 more]</label></div><br/><div class="children"><div class="content">I always thought there should be a two-arg overload of new, so you could write new(bool, true) or new(int, 20).  Would solve the problem without any trickery.</div><br/></div></div><div id="41276598" class="c"><input type="checkbox" id="c-41276598" checked=""/><div class="controls bullet"><span class="by">jen20</span><span>|</span><a href="#41275893">root</a><span>|</span><a href="#41276360">parent</a><span>|</span><a href="#41278886">prev</a><span>|</span><a href="#41280576">next</a><span>|</span><label class="collapse" for="c-41276598">[-]</label><label class="expand" for="c-41276598">[3 more]</label></div><br/><div class="children"><div class="content">Not being able to take a pointer to a literal is one of my pet peeves with Go - especially when using the AWS SDK, which requires pointers to literals everywhere. At least with generics, a wrapper function doesn&#x27;t require a separate function per type though, and can be simply:<p><pre><code>    package ptr

    func To[T any](v T) *T {
        return &amp;v
    }</code></pre></div><br/><div id="41276665" class="c"><input type="checkbox" id="c-41276665" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#41275893">root</a><span>|</span><a href="#41276598">parent</a><span>|</span><a href="#41280576">next</a><span>|</span><label class="collapse" for="c-41276665">[-]</label><label class="expand" for="c-41276665">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, that particular case got better with generics. It&#x27;s still more verbose to write ptr.To(true) than &amp;true though.<p>Unfortunately, there&#x27;s no generic type constraint for &quot;is an interface&quot; or even &quot;is nilable&quot; so you can&#x27;t use generics to solve nil-safety issues in general.</div><br/><div id="41279743" class="c"><input type="checkbox" id="c-41279743" checked=""/><div class="controls bullet"><span class="by">jen20</span><span>|</span><a href="#41275893">root</a><span>|</span><a href="#41276665">parent</a><span>|</span><a href="#41280576">next</a><span>|</span><label class="collapse" for="c-41279743">[-]</label><label class="expand" for="c-41279743">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, I see no reason why taking the address of a literal couldn’t be added though, that’s a cheap win.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41280576" class="c"><input type="checkbox" id="c-41280576" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#41275893">prev</a><span>|</span><a href="#41276291">next</a><span>|</span><label class="collapse" for="c-41280576">[-]</label><label class="expand" for="c-41280576">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Go isn&#x27;t different, it has map, that is Go implementation of a hash table.<p>It&#x27;s a bit nitpicky, but this always annoys me. Maps&#x2F;dictionaries are not hashtables. A hashtable is one of the structures you can use to implement a map. A hashtable stores arbitrary items, not key-value associations, and can be used to quickly retrieve an item knowing its hash. If you want to implement a map using a hashtable, you need to also define a type that wraps a key-value pair and handles hashing and equality by only comparing the key.<p>Also, maps can be implemented with other underlying data structures as well. Java&#x27;s standard library even offers a built-in TreeMap, which uses a red-black tree to store the pairs instead of HashMap&#x27;s hashtable.</div><br/></div></div><div id="41276291" class="c"><input type="checkbox" id="c-41276291" checked=""/><div class="controls bullet"><span class="by">moomin</span><span>|</span><a href="#41280576">prev</a><span>|</span><a href="#41280600">next</a><span>|</span><label class="collapse" for="c-41276291">[-]</label><label class="expand" for="c-41276291">[2 more]</label></div><br/><div class="children"><div class="content">I am constantly criticising the C# community for not looking at other languages enough, but in this case it cuts both ways: C# has every feature mentioned here. Including a pretty good model for nullable.</div><br/><div id="41278061" class="c"><input type="checkbox" id="c-41278061" checked=""/><div class="controls bullet"><span class="by">Quothling</span><span>|</span><a href="#41276291">parent</a><span>|</span><a href="#41280600">next</a><span>|</span><label class="collapse" for="c-41278061">[-]</label><label class="expand" for="c-41278061">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think having nullables can be called a feature as such. It adds complexity to your code and it directly goes against Go&#x27;s philosophy of explicit error handling and simple types. Of course it&#x27;s completely opinion based but I think having people handle errors directly instead of dealing with them through exceptions and checks makes for much more predictable code. I&#x27;m also not sure I really see the difference that GP does. I think that in a lot of code you&#x27;re going to do a lot of null checks anyway, maybe even more than how often you&#x27;ll check if your pointers are nil, but at least with Go you&#x27;re not risking missing one.<p>Maybe the Go engineers didn&#x27;t think about nullables, but I think there is a good chance they simply decided against them for various reasons.</div><br/></div></div></div></div><div id="41280600" class="c"><input type="checkbox" id="c-41280600" checked=""/><div class="controls bullet"><span class="by">valyala</span><span>|</span><a href="#41276291">prev</a><span>|</span><a href="#41278343">next</a><span>|</span><label class="collapse" for="c-41280600">[-]</label><label class="expand" for="c-41280600">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;d like to remove generics and iterators funcs from Go, and stop adding programming language shit to Go. <a href="https:&#x2F;&#x2F;itnext.io&#x2F;go-evolves-in-the-wrong-direction-7dfda8a1a620" rel="nofollow">https:&#x2F;&#x2F;itnext.io&#x2F;go-evolves-in-the-wrong-direction-7dfda8a1...</a></div><br/><div id="41280832" class="c"><input type="checkbox" id="c-41280832" checked=""/><div class="controls bullet"><span class="by">dawkins</span><span>|</span><a href="#41280600">parent</a><span>|</span><a href="#41280727">next</a><span>|</span><label class="collapse" for="c-41280832">[-]</label><label class="expand" for="c-41280832">[1 more]</label></div><br/><div class="children"><div class="content">I agree. The limited expressiveness in Go also worked as an advantage because of its simplicity. Additionally, as the article mentions, the lack of lambdas made the syntax less convenient. For me, it struck a good balance before generics and other features were added.</div><br/></div></div><div id="41280727" class="c"><input type="checkbox" id="c-41280727" checked=""/><div class="controls bullet"><span class="by">WesolyKubeczek</span><span>|</span><a href="#41280600">parent</a><span>|</span><a href="#41280832">prev</a><span>|</span><a href="#41278343">next</a><span>|</span><label class="collapse" for="c-41280727">[-]</label><label class="expand" for="c-41280727">[2 more]</label></div><br/><div class="children"><div class="content">You are free to not use them.</div><br/><div id="41280929" class="c"><input type="checkbox" id="c-41280929" checked=""/><div class="controls bullet"><span class="by">valyala</span><span>|</span><a href="#41280600">root</a><span>|</span><a href="#41280727">parent</a><span>|</span><a href="#41278343">next</a><span>|</span><label class="collapse" for="c-41280929">[-]</label><label class="expand" for="c-41280929">[1 more]</label></div><br/><div class="children"><div class="content">I cannot, since others will use them. So eventually I need to deal with the over-engineered overcomplicated shitty code, which uses these &quot;features&quot;.</div><br/></div></div></div></div></div></div><div id="41278343" class="c"><input type="checkbox" id="c-41278343" checked=""/><div class="controls bullet"><span class="by">solraph</span><span>|</span><a href="#41280600">prev</a><span>|</span><a href="#41277846">next</a><span>|</span><label class="collapse" for="c-41278343">[-]</label><label class="expand" for="c-41278343">[1 more]</label></div><br/><div class="children"><div class="content">I agree with most of this list, and I&#x27;d add some kind of null coalescing or ternary operator, even if it was limited to one operater per expression, and a date time handling library that doesn&#x27;t make me want to pull.my hair out.<p>There&#x27;s several things that keep me on Go, single binary, decent built in tooling, and decent speed.<p>I&#x27;ve started playing around with tinygo on Pi Pico&#x27;s, and after the dealing with getting C and C++ onto other MCUs it&#x27;s a breath of fresh air.<p>But the rough edges are very rough. At some point another language is going to come along with better syntax with the same single binary and good tooling and I&#x27;ll probably switch over as fast as possible.</div><br/></div></div><div id="41277846" class="c"><input type="checkbox" id="c-41277846" checked=""/><div class="controls bullet"><span class="by">drdaeman</span><span>|</span><a href="#41278343">prev</a><span>|</span><a href="#41275754">next</a><span>|</span><label class="collapse" for="c-41277846">[-]</label><label class="expand" for="c-41277846">[1 more]</label></div><br/><div class="children"><div class="content">Nullability is poor man&#x27;s `Maybe`&#x2F;`Optional`, and I&#x27;d love to see that at the type system level (cf. `data Maybe a = Just a | Nothing`) rather than current {sql,null}.Null* mess or whatever was proposed in <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;48702">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;48702</a>. But I doubt if that&#x27;ll ever happen.</div><br/></div></div><div id="41275754" class="c"><input type="checkbox" id="c-41275754" checked=""/><div class="controls bullet"><span class="by">materielle</span><span>|</span><a href="#41277846">prev</a><span>|</span><a href="#41279564">next</a><span>|</span><label class="collapse" for="c-41275754">[-]</label><label class="expand" for="c-41275754">[19 more]</label></div><br/><div class="children"><div class="content">Interesting, I agree with the the main idea: in general I find Go a productive language, but there’s a few rough edges.<p>The specific examples don’t ring true to me though.<p>Instead of named arguments, use the functional optional pattern.<p>An ordered map can be implemented as a slice with a get function. If you want to stamp out some code duplication, Go has generics and iterators these days.<p>What I really miss are enums. Specifically, the ability to map two value sets to each other and get a compile time error if the mapping becomes stale due to a new value.<p>And other assorted stuff. Like better nil handling, the weird time and http client libraries, nil interfaces and slices, and so on.</div><br/><div id="41276564" class="c"><input type="checkbox" id="c-41276564" checked=""/><div class="controls bullet"><span class="by">milch</span><span>|</span><a href="#41275754">parent</a><span>|</span><a href="#41276506">next</a><span>|</span><label class="collapse" for="c-41276564">[-]</label><label class="expand" for="c-41276564">[4 more]</label></div><br/><div class="children"><div class="content">The functional optional pattern thing seems fine for constructors, but I wouldn&#x27;t want to have to implement it for every single function. A lot of the times it is just about readability at the call site, e.g. (using the author&#x27;s example)<p>string.Replace(urlString, &quot; &quot;, &quot;%20&quot;, -1)<p>is less readable than<p>string.Replace(urlString, replace: &quot; &quot;, with: &quot;%20&quot;, maxReplacements: -1)<p>Of course it&#x27;s not often necessary, especially when you have a named variable<p>string.Replace(urlString, charToReplace, escapedChar, REPLACE_ALL)<p>But it can also be awkward to have to declare a variable for every arg, which is probably why python allows you to call it both ways. Plus the variable names and positional arg could not match up, which can be a source of hard to find bugs</div><br/><div id="41278993" class="c"><input type="checkbox" id="c-41278993" checked=""/><div class="controls bullet"><span class="by">cratermoon</span><span>|</span><a href="#41275754">root</a><span>|</span><a href="#41276564">parent</a><span>|</span><a href="#41278992">next</a><span>|</span><label class="collapse" for="c-41278993">[-]</label><label class="expand" for="c-41278993">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t quite get the strings.Replace example when there&#x27;s strings.ReplaceAll</div><br/><div id="41279215" class="c"><input type="checkbox" id="c-41279215" checked=""/><div class="controls bullet"><span class="by">kokada</span><span>|</span><a href="#41275754">root</a><span>|</span><a href="#41278993">parent</a><span>|</span><a href="#41278992">next</a><span>|</span><label class="collapse" for="c-41279215">[-]</label><label class="expand" for="c-41279215">[1 more]</label></div><br/><div class="children"><div class="content">Author here.<p>The fact that `strings.ReplaceAll` exists I think is a good argument for having default arguments, because I can&#x27;t think of a good reason why we need a separate function for this case.<p>But maybe it was a bad example. I remember that there is one function in `strings` that I almost always use the same value in every call I do because it is the correct value in 80% of the cases. I thought it was `strings.Replace`, but probably it is something else. If I ever remember which function it is, I will update the post.</div><br/></div></div></div></div></div></div><div id="41276506" class="c"><input type="checkbox" id="c-41276506" checked=""/><div class="controls bullet"><span class="by">xyse53</span><span>|</span><a href="#41275754">parent</a><span>|</span><a href="#41276564">prev</a><span>|</span><a href="#41279257">next</a><span>|</span><label class="collapse" for="c-41276506">[-]</label><label class="expand" for="c-41276506">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Instead of named arguments, use the functional optional pattern.<p>Options pattern is an alternative, I use it frequently, but still miss named arguments and default arguments if I&#x27;m going back and forth with Python.<p>- The options pattern is much more verbose to implement.<p>- The defaults aren&#x27;t as easily clear, they need to be documented and kept consistent.<p>- You can&#x27;t, or it&#x27;s not as easy to, make some arguments required.<p>- And, as a caller, if the API I&#x27;m using doesn&#x27;t support them, I sometimes have to rely on comments to clarify what each arg is. For example, if a function takes a bools like `func MyFunc(dryrun, inverse bool, items ...string) error { ... }`</div><br/><div id="41276613" class="c"><input type="checkbox" id="c-41276613" checked=""/><div class="controls bullet"><span class="by">mariusor</span><span>|</span><a href="#41275754">root</a><span>|</span><a href="#41276506">parent</a><span>|</span><a href="#41279257">next</a><span>|</span><label class="collapse" for="c-41276613">[-]</label><label class="expand" for="c-41276613">[1 more]</label></div><br/><div class="children"><div class="content">Also the functional options pattern usually implies that there is an object on which the functions operate. Default values for parameters is something that can apply to any function, not just initializers.<p>I wonder if parent could give us an alternative for strings.Replace using functional options.</div><br/></div></div></div></div><div id="41279257" class="c"><input type="checkbox" id="c-41279257" checked=""/><div class="controls bullet"><span class="by">kokada</span><span>|</span><a href="#41275754">parent</a><span>|</span><a href="#41276506">prev</a><span>|</span><a href="#41275822">next</a><span>|</span><label class="collapse" for="c-41279257">[-]</label><label class="expand" for="c-41279257">[1 more]</label></div><br/><div class="children"><div class="content">Author here.<p>&gt; The specific examples don’t ring true to me though.<p>And I don&#x27;t think it should. To start, the list is small because it is a work in progress, I plan to write more once I have more to talk. I didn&#x27;t expect this post to hit HN that soon, but thanks to whoever posted this here. Got some really interesting points of view. But also they are particular pet peeves of mine, and don&#x27;t necessarily reflect other people&#x27;s experiences.</div><br/></div></div><div id="41275822" class="c"><input type="checkbox" id="c-41275822" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#41275754">parent</a><span>|</span><a href="#41279257">prev</a><span>|</span><a href="#41275795">next</a><span>|</span><label class="collapse" for="c-41275822">[-]</label><label class="expand" for="c-41275822">[9 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll just throw in:<p>If you use functional options, <i>please</i> don&#x27;t implement them with closures. Closures aren&#x27;t comparable, so there&#x27;s essentially no way to build middleware that varies behavior based on those arguments.<p>Just make a `type thearg string` or whatever instead. Very similar amounts of code, similarly hidden implementation, but MUCH more usable.</div><br/><div id="41276173" class="c"><input type="checkbox" id="c-41276173" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#41275754">root</a><span>|</span><a href="#41275822">parent</a><span>|</span><a href="#41275795">next</a><span>|</span><label class="collapse" for="c-41276173">[-]</label><label class="expand" for="c-41276173">[8 more]</label></div><br/><div class="children"><div class="content">The whole point of the &quot;functional&quot; options pattern is that the option&#x27;s own identity or type doesn&#x27;t matter, only its side-effects. If you do need to examine the option itself, you&#x27;re either using the wrong pattern, or you should be using an interface with additional, self-descriptive methods instead.<p>For example, I have used an interface similar to the following for a custom HTTP client wrapper (as discussed in another thread):<p><pre><code>    type RequestOption interface {
        Priority() int8
        Name() string
        Apply(r *http.Request) error
    }
</code></pre>
The Priority method might seem like overkill, but it was useful here because there are default options for the whole client and local options on each call, which have to be merged and applied in the proper order.</div><br/><div id="41276370" class="c"><input type="checkbox" id="c-41276370" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#41275754">root</a><span>|</span><a href="#41276173">parent</a><span>|</span><a href="#41275795">next</a><span>|</span><label class="collapse" for="c-41276370">[-]</label><label class="expand" for="c-41276370">[7 more]</label></div><br/><div class="children"><div class="content">`==` is a useful side-effect, and violating it makes a type rather abnormal.</div><br/><div id="41276478" class="c"><input type="checkbox" id="c-41276478" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#41275754">root</a><span>|</span><a href="#41276370">parent</a><span>|</span><a href="#41275795">next</a><span>|</span><label class="collapse" for="c-41276478">[-]</label><label class="expand" for="c-41276478">[6 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re using the functional options pattern, and you&#x27;re trying to == or type-assert one of the options, <i>you&#x27;re</i> the one doing something abnormal.<p>Maybe it makes sense in the broader context of what you&#x27;re trying to do, but then I&#x27;d say that the functional options pattern isn&#x27;t the right fit in the first place.<p>Also, &quot;side effect&quot; in computer science has a pretty straightforward definition, and equality comparisons are not side effects.</div><br/><div id="41276597" class="c"><input type="checkbox" id="c-41276597" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#41275754">root</a><span>|</span><a href="#41276478">parent</a><span>|</span><a href="#41275795">next</a><span>|</span><label class="collapse" for="c-41276597">[-]</label><label class="expand" for="c-41276597">[5 more]</label></div><br/><div class="children"><div class="content">Side effect: agreed, but the way you used it makes no sense in that definition (arguments cannot have side effects on a function call, they&#x27;re resolved before the function is called), and the main other option in Go is to pass a struct or separate typed arguments which also has no side effects, and the only other interpretation is &quot;the side effects you can trigger in the function based on the argument&quot; which is identical in all scenarios...<p>so I figured you were using it in the more colloquial way where it&#x27;s closer &quot;observable behavior [of the argument&#x27;s type]&quot;.  Or &quot;the unintended consequences of a design decision&quot;.</div><br/><div id="41276716" class="c"><input type="checkbox" id="c-41276716" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#41275754">root</a><span>|</span><a href="#41276597">parent</a><span>|</span><a href="#41275795">next</a><span>|</span><label class="collapse" for="c-41276716">[-]</label><label class="expand" for="c-41276716">[4 more]</label></div><br/><div class="children"><div class="content">In its simplest form, a functional option is:<p><pre><code>    type Option func(ptr *T)
</code></pre>
The entire purpose of this function is to be called, and when called, to change something about the value pointed to by ptr. That seems like a classic case of side effect to me, since the function returns no value (hence it&#x27;s not a &quot;pure function&quot;) but instead mutates some state (which lives beyond the function call).<p>For example, we can make such an option like this:<p><pre><code>    func SomeOption(optionalArg string) Option {
        return func(ptr *T) {
            ptr.otherField = optionalArg
        }
    }
</code></pre>
The options would then be accepted by another function, such as:<p><pre><code>    func Example(requiredArg string, options ...Option) T {
        val := T{someField: requiredArg}
        for _, option := range options {
            option(&amp;val)
        }
        return val
    }
</code></pre>
In the body of Example, there&#x27;s no need to use == on an Option. Each Option does its thing when called, and then we move on to the next one. We would use all of these things like this:<p><pre><code>    foo := Example(&quot;someFieldVal&quot;, SomeOption(&quot;otherFieldVal&quot;))
</code></pre>
Obviously, this is a trivial example, but I think it illustrates the point that functional options are used for their side-effects. If you need to do fancier things than just unconditionally set a field, you do all of that in the option itself (either before creating the closure, or inside the body of the closure).</div><br/><div id="41277072" class="c"><input type="checkbox" id="c-41277072" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#41275754">root</a><span>|</span><a href="#41276716">parent</a><span>|</span><a href="#41275795">next</a><span>|</span><label class="collapse" for="c-41277072">[-]</label><label class="expand" for="c-41277072">[3 more]</label></div><br/><div class="children"><div class="content">You&#x27;re describing the absolute basics of functional options to someone who, by cautioning about a niche usability issue with this exact implementation, has demonstrated a solid understanding of them.</div><br/><div id="41277125" class="c"><input type="checkbox" id="c-41277125" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#41275754">root</a><span>|</span><a href="#41277072">parent</a><span>|</span><a href="#41275795">next</a><span>|</span><label class="collapse" for="c-41277125">[-]</label><label class="expand" for="c-41277125">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve re-read everything you&#x27;ve written so far, and I think we&#x27;re just in violent agreement. It would have helped if you provided some explanatory code, but the word &quot;middleware&quot; in your original post (which may have been edited in? if not, sorry, that&#x27;s on me) clarifies a lot for me.<p>If you do need to == or type-assert the options, then don&#x27;t make them functional. That seems to be what you were saying with `type thearg string` earlier. However, I think my original example with an interface illustrated another&#x2F;better way to solve the same problem: make the options self-describing.</div><br/><div id="41277238" class="c"><input type="checkbox" id="c-41277238" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#41275754">root</a><span>|</span><a href="#41277125">parent</a><span>|</span><a href="#41275795">next</a><span>|</span><label class="collapse" for="c-41277238">[-]</label><label class="expand" for="c-41277238">[1 more]</label></div><br/><div class="children"><div class="content">Sort of.<p>My issue with using closures as your functional option implementation type (i.e. &quot;functional options&quot; is &quot;call this function to get an opaque arg&quot; which does not imply that you need to use a closure, it&#x27;s just a common implementation strategy) is that <i>when a library does it</i>, it prevents anyone from writing middleware that is interested in argument equality.  Among other useful desires.<p>That&#x27;s <i>quite</i> common in my experience, and working around it on the library-user side is rather painful, as it often requires reimplementing roughly the entire API so it can be controlled.<p>The alternative is to have your return type be an opaque <i>interface</i>, which can have any implementation (including closures):<p><pre><code>    type Option {
      apply(...)  &#x2F;&#x2F; privately implementable only
                  &#x2F;&#x2F; or just have an empty `private()` or something
    }
    type someoption string
    func (s someoption) apply(...) {
      &#x2F;&#x2F; whatever is needed, it can be changed any time
    }
    func SomeOption(val string) Option {
      return someoption(val)
    }

    wrap(thing, SomeOption(&quot;arg&quot;))
</code></pre>
^ in this, the wrapper can check if options include `SomeOption(&quot;arg&quot;)` if that becomes useful for some reason.  Quite often that reason is &quot;tests&quot;, but I do keep running into other scenarios where it&#x27;d be useful too.  I&#x27;ve helped multiple people work around it by reflecting on the function&#x27;s signature, constructing the private arg type, calling the func, and comparing the mutated private apply-arg-type to a known value, but this isn&#x27;t always possible and those cases are stuck either not doing the thing they wanted, or writing tons of code to wrap the types completely.<p>Using a more concrete type also logs&#x2F;prints&#x2F;debugs usefully by default in most cases, giving you `someoption{&quot;arg&quot;}` instead of `(fntype)(&amp;0x3768dh893)`.<p>As a library author you generally cannot predict this kind of need, and using function closures is <i>by far</i> the least flexible and least-user-friendly option for your users.  So I recommend not doing that.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41275795" class="c"><input type="checkbox" id="c-41275795" checked=""/><div class="controls bullet"><span class="by">RSHEPP</span><span>|</span><a href="#41275754">parent</a><span>|</span><a href="#41275822">prev</a><span>|</span><a href="#41279564">next</a><span>|</span><label class="collapse" for="c-41275795">[-]</label><label class="expand" for="c-41275795">[2 more]</label></div><br/><div class="children"><div class="content">Oh interested in the issues with http clients you have? I think they are great to use for being right in the standard library. Only complaint I have is defaults for timeouts and such, but you make that mistake once and don&#x27;t forget.</div><br/><div id="41275879" class="c"><input type="checkbox" id="c-41275879" checked=""/><div class="controls bullet"><span class="by">materielle</span><span>|</span><a href="#41275754">root</a><span>|</span><a href="#41275795">parent</a><span>|</span><a href="#41279564">next</a><span>|</span><label class="collapse" for="c-41275879">[-]</label><label class="expand" for="c-41275879">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;blog.carlana.net&#x2F;post&#x2F;2021&#x2F;requests-golang-http-client&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.carlana.net&#x2F;post&#x2F;2021&#x2F;requests-golang-http-clie...</a><p>I don’t think that article discusses the timeout issue. So all the issues mentioned in that article, plus the timeout issue.<p>The end result is you have to explain to every Go developer that they can’t use the http client as-is.<p>Start searching for http client usages in GitHub. You’ll probably find more incorrect usages than correct ones.<p>It’s a solvable problem, you write a wrapper http client once and tell everyone to use it. But it’s a nasty foot gun to have to explain all this.</div><br/></div></div></div></div></div></div><div id="41279564" class="c"><input type="checkbox" id="c-41279564" checked=""/><div class="controls bullet"><span class="by">gregjor</span><span>|</span><a href="#41275754">prev</a><span>|</span><a href="#41279798">next</a><span>|</span><label class="collapse" for="c-41279564">[-]</label><label class="expand" for="c-41279564">[1 more]</label></div><br/><div class="children"><div class="content">I haven’t found these specific things annoying.<p>PHP has all of the features listed in the article. Not saying anyone should choose PHP over Go.</div><br/></div></div><div id="41279798" class="c"><input type="checkbox" id="c-41279798" checked=""/><div class="controls bullet"><span class="by">everybodyknows</span><span>|</span><a href="#41279564">prev</a><span>|</span><a href="#41277251">next</a><span>|</span><label class="collapse" for="c-41279798">[-]</label><label class="expand" for="c-41279798">[1 more]</label></div><br/><div class="children"><div class="content">Am I the only one who feels the absence of a slice type strictly checked by both index and content?</div><br/></div></div><div id="41277251" class="c"><input type="checkbox" id="c-41277251" checked=""/><div class="controls bullet"><span class="by">karmakaze</span><span>|</span><a href="#41279798">prev</a><span>|</span><a href="#41275718">next</a><span>|</span><label class="collapse" for="c-41277251">[-]</label><label class="expand" for="c-41277251">[3 more]</label></div><br/><div class="children"><div class="content">When I read &#x27;unordered list&#x27;, I was thinking it was more than 3 things:<p><pre><code>  - Keyword and default arguments for functions
  - Nullability (or nillability)
  - Ordered maps in standard library
</code></pre>
<i>It&#x27;s was a play on the hash map iteration.</i></div><br/><div id="41279198" class="c"><input type="checkbox" id="c-41279198" checked=""/><div class="controls bullet"><span class="by">kokada</span><span>|</span><a href="#41277251">parent</a><span>|</span><a href="#41275718">next</a><span>|</span><label class="collapse" for="c-41279198">[-]</label><label class="expand" for="c-41279198">[2 more]</label></div><br/><div class="children"><div class="content">Author here.<p>I never expected this post to get here in HN the way it was. It is definitely a work in progress, most some personal notes that I will probably add more when I use other parts in Go that bothers me.</div><br/><div id="41279288" class="c"><input type="checkbox" id="c-41279288" checked=""/><div class="controls bullet"><span class="by">kokada</span><span>|</span><a href="#41277251">root</a><span>|</span><a href="#41279198">parent</a><span>|</span><a href="#41275718">next</a><span>|</span><label class="collapse" for="c-41279288">[-]</label><label class="expand" for="c-41279288">[1 more]</label></div><br/><div class="children"><div class="content">BTW, I will confess: the orderedmap one is something that I put mostly because I know it is something that would be feasible to implement in a future version of the language and it would probably be relatively uncontroversial.<p>So I was expecting maybe someone will end up doing the work to propose and&#x2F;or implement this to Go. Who knows, maybe this will work.</div><br/></div></div></div></div></div></div><div id="41275718" class="c"><input type="checkbox" id="c-41275718" checked=""/><div class="controls bullet"><span class="by">pcwelder</span><span>|</span><a href="#41277251">prev</a><span>|</span><a href="#41277821">next</a><span>|</span><label class="collapse" for="c-41275718">[-]</label><label class="expand" for="c-41275718">[2 more]</label></div><br/><div class="children"><div class="content">I am a Python programmer with a bit of Golang experience. If it were upto me I&#x27;d absolutely do away with default function arguments in Python.<p>It is one of the rules now I live by. I don&#x27;t have to worry about leaving an argument during calling anymore.<p>I think it fits well with the pythonic mantra of explicit is better than implicit.</div><br/><div id="41276703" class="c"><input type="checkbox" id="c-41276703" checked=""/><div class="controls bullet"><span class="by">margalabargala</span><span>|</span><a href="#41275718">parent</a><span>|</span><a href="#41277821">next</a><span>|</span><label class="collapse" for="c-41276703">[-]</label><label class="expand" for="c-41276703">[1 more]</label></div><br/><div class="children"><div class="content">Default arguments being hidden&#x2F;unclear&#x2F;wrong&#x2F;hard to find&#x2F;undocumented is by far the #1 source of bugs I encounter in Python programs. It&#x27;s not even close. Probably around 70%.</div><br/></div></div></div></div><div id="41277821" class="c"><input type="checkbox" id="c-41277821" checked=""/><div class="controls bullet"><span class="by">qaq</span><span>|</span><a href="#41275718">prev</a><span>|</span><a href="#41275678">next</a><span>|</span><label class="collapse" for="c-41277821">[-]</label><label class="expand" for="c-41277821">[1 more]</label></div><br/><div class="children"><div class="content">I think this perfectly illustrates the problem the thing I would most want to see is sum types e.g. we all have some particular thing we would want to add and we can&#x27;t add em all.</div><br/></div></div><div id="41275678" class="c"><input type="checkbox" id="c-41275678" checked=""/><div class="controls bullet"><span class="by">bediger4000</span><span>|</span><a href="#41277821">prev</a><span>|</span><a href="#41279142">next</a><span>|</span><label class="collapse" for="c-41275678">[-]</label><label class="expand" for="c-41275678">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen the python ordered dict thing bite ex-python programmers over and over, in two different ways.<p>First, assuming that the keys iterate in the order they&#x27;re inserted, the cliche problem.<p>Second, marshalling JSON and unconsciously relying on the order in the JSON as hidden semantics. This makes it hard to understand the JSON as a human, as well as making what ought to be a portable format with other languages hard to reuse.<p>I&#x27;ve decided that Python is in the wrong here, not technically, but rather for encouraging humans to assume too much.</div><br/><div id="41278690" class="c"><input type="checkbox" id="c-41278690" checked=""/><div class="controls bullet"><span class="by">zarzavat</span><span>|</span><a href="#41275678">parent</a><span>|</span><a href="#41279142">next</a><span>|</span><label class="collapse" for="c-41278690">[-]</label><label class="expand" for="c-41278690">[2 more]</label></div><br/><div class="children"><div class="content">As the article says, reproducibility is important. If I have a bug on one run, I want to get that bug again on the second run. I want to be able to run the program again and again and have the same breakpoints hit in the same order with the same variables. If I run tests, I want them to give the same results each time.<p>Randomness is bugs. Adding randomness to a language is adding bugs.</div><br/><div id="41279714" class="c"><input type="checkbox" id="c-41279714" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#41275678">root</a><span>|</span><a href="#41278690">parent</a><span>|</span><a href="#41279142">next</a><span>|</span><label class="collapse" for="c-41279714">[-]</label><label class="expand" for="c-41279714">[1 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t avoid randomness and entropy, it&#x27;s just something that&#x27;s needed in too many places. For test repeatability though, whatever seeds a test run uses should be saved in order to repeat that test exactly.<p>Best of both worlds: you get to cover weird bugs that only show up when stuff is in a certain order, and you can repeat the tests exactly.</div><br/></div></div></div></div></div></div><div id="41279142" class="c"><input type="checkbox" id="c-41279142" checked=""/><div class="controls bullet"><span class="by">aaomidi</span><span>|</span><a href="#41275678">prev</a><span>|</span><a href="#41275750">next</a><span>|</span><label class="collapse" for="c-41279142">[-]</label><label class="expand" for="c-41279142">[1 more]</label></div><br/><div class="children"><div class="content">I really dislike default values because it adds one more location where a value can be different from what id expect.<p>Honestly, be explicit rather than hoping for implicit behavior.</div><br/></div></div><div id="41275750" class="c"><input type="checkbox" id="c-41275750" checked=""/><div class="controls bullet"><span class="by">BoingBoomTschak</span><span>|</span><a href="#41279142">prev</a><span>|</span><a href="#41276542">next</a><span>|</span><label class="collapse" for="c-41275750">[-]</label><label class="expand" for="c-41275750">[3 more]</label></div><br/><div class="children"><div class="content">The reason for randomized hash is most probably to mitigate DOS attacks based on users knowing which hash function is used (Go is open source, after all) and finding a way to fill a map - any map - with untouched tokens.</div><br/><div id="41275834" class="c"><input type="checkbox" id="c-41275834" checked=""/><div class="controls bullet"><span class="by">materielle</span><span>|</span><a href="#41275750">parent</a><span>|</span><a href="#41278013">next</a><span>|</span><label class="collapse" for="c-41275834">[-]</label><label class="expand" for="c-41275834">[1 more]</label></div><br/><div class="children"><div class="content">That’s definitely part of it.<p>The other half is hyrum’s law.<p>There’s a lot of situations in reasonable unordered map implementations where the elements, by chance, <i>do</i> happen to be ordered. Just due to arbitrary implementation decisions.<p>But the Go spec says that maps are unordered, and library writers want to reserve the right to change the implementation in the future.<p>So always ransoming the dict prevents code from accidentally depending on some specific map implementation detail.</div><br/></div></div><div id="41278013" class="c"><input type="checkbox" id="c-41278013" checked=""/><div class="controls bullet"><span class="by">jhgg</span><span>|</span><a href="#41275750">parent</a><span>|</span><a href="#41275834">prev</a><span>|</span><a href="#41276542">next</a><span>|</span><label class="collapse" for="c-41278013">[-]</label><label class="expand" for="c-41278013">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;go1#iteration" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;go1#iteration</a><p>&gt; The old language specification did not define the order of iteration for maps, and in practice it differed across hardware platforms. This caused tests that iterated over maps to be fragile and non-portable, with the unpleasant property that a test might always pass on one machine but break on another.<p>&gt; In Go 1, the order in which elements are visited when iterating over a map using a for range statement is defined to be unpredictable, even if the same loop is run multiple times with the same map. Code should not assume that the elements are visited in any particular order.<p>&gt; This change means that code that depends on iteration order is very likely to break early and be fixed long before it becomes a problem. Just as important, it allows the map implementation to ensure better map balancing even when programs are using range loops to select an element from a mapl.</div><br/></div></div></div></div><div id="41276542" class="c"><input type="checkbox" id="c-41276542" checked=""/><div class="controls bullet"><span class="by">knodi</span><span>|</span><a href="#41275750">prev</a><span>|</span><a href="#41276274">next</a><span>|</span><label class="collapse" for="c-41276542">[-]</label><label class="expand" for="c-41276542">[13 more]</label></div><br/><div class="children"><div class="content">&gt; Nullability (or nillability)<p>&gt; func(s *string) {<p>&gt;    &#x2F;&#x2F; s maybe nil here, better check first<p>&gt; }<p>If this happens, you don&#x27;t have proper checks before this call. Clearly an error check was missed prior to this call.</div><br/><div id="41276652" class="c"><input type="checkbox" id="c-41276652" checked=""/><div class="controls bullet"><span class="by">ninkendo</span><span>|</span><a href="#41276542">parent</a><span>|</span><a href="#41276733">next</a><span>|</span><label class="collapse" for="c-41276652">[-]</label><label class="expand" for="c-41276652">[8 more]</label></div><br/><div class="children"><div class="content">You know what&#x27;s better than having to remember to write the proper checks before the call? Having the compiler do the checks for you.<p>Code that results in a nil dereference should not be compilable, period. Any programming language that allows it is flawed.</div><br/><div id="41276747" class="c"><input type="checkbox" id="c-41276747" checked=""/><div class="controls bullet"><span class="by">mariusor</span><span>|</span><a href="#41276542">root</a><span>|</span><a href="#41276652">parent</a><span>|</span><a href="#41278158">next</a><span>|</span><label class="collapse" for="c-41276747">[-]</label><label class="expand" for="c-41276747">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Any programming language that allows it is flawed.<p>I think any language that allows that has different priorities than complete code correctness. There might even be programmers out there that would also prefer those priorities (simplicity, speed, etc) over having the compiler spend time every compilation to make sure a pointer is null or not.</div><br/><div id="41276919" class="c"><input type="checkbox" id="c-41276919" checked=""/><div class="controls bullet"><span class="by">ninkendo</span><span>|</span><a href="#41276542">root</a><span>|</span><a href="#41276747">parent</a><span>|</span><a href="#41278158">next</a><span>|</span><label class="collapse" for="c-41276919">[-]</label><label class="expand" for="c-41276919">[5 more]</label></div><br/><div class="children"><div class="content">The amount of time spent every compilation on this is negligible: a nullable type is just another type like any other. I don’t buy your argument at all.<p>It’s a clear no-brainer at this point: null references were a mistake, and any language with compile-time type checking is flawed if they’re allowed.</div><br/><div id="41280542" class="c"><input type="checkbox" id="c-41280542" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#41276542">root</a><span>|</span><a href="#41276919">parent</a><span>|</span><a href="#41277282">next</a><span>|</span><label class="collapse" for="c-41280542">[-]</label><label class="expand" for="c-41280542">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It’s a clear no-brainer at this point: null references were a mistake, and any language with compile-time type checking is flawed if they’re allowed.<p>Maybe you mean &#x27;dereferences&#x27;, not &#x27;references&#x27;, because without NULL&#x2F;null&#x2F;nil, we can&#x27;t interface to the real world which is filled with &quot;there is no value here!&quot; values.</div><br/></div></div><div id="41277282" class="c"><input type="checkbox" id="c-41277282" checked=""/><div class="controls bullet"><span class="by">mariusor</span><span>|</span><a href="#41276542">root</a><span>|</span><a href="#41276919">parent</a><span>|</span><a href="#41280542">prev</a><span>|</span><a href="#41278158">next</a><span>|</span><label class="collapse" for="c-41277282">[-]</label><label class="expand" for="c-41277282">[3 more]</label></div><br/><div class="children"><div class="content">&gt; It’s a clear no-brainer at this point<p>Of course. All compiler designers, outside a select few, are clearly wrong and have given the problem absolutely no thought.</div><br/><div id="41277399" class="c"><input type="checkbox" id="c-41277399" checked=""/><div class="controls bullet"><span class="by">ninkendo</span><span>|</span><a href="#41276542">root</a><span>|</span><a href="#41277282">parent</a><span>|</span><a href="#41278245">next</a><span>|</span><label class="collapse" for="c-41277399">[-]</label><label class="expand" for="c-41277399">[1 more]</label></div><br/><div class="children"><div class="content">I mean, the guy who is broadly considered the &quot;inventor&quot; of the null reference straight-up admits he gave it no thought:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Tony_Hoare" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Tony_Hoare</a><p>&gt; At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn&#x27;t resist the temptation to put in a null reference, simply because it was so easy to implement<p>So, it doesn&#x27;t seem unlikely at all that other languages with type systems[0] probably just carried this behavior forward because it&#x27;s how other languages worked at the time. The idea that you could have references which weren&#x27;t allowed to be null probably seemed limiting, because other languages allowed it.<p>That this was a mistake is pretty broadly accepted at this point. It&#x27;s not even a controversial statement any more.<p>[0] I&#x27;m excluding languages that don&#x27;t have type checking at compile time (or without any compile time at all), that&#x27;s a different discussion. I&#x27;m limiting the scope of my criticism to languages that (1) have a compile-time type checker but (2) opt to have that type checker <i>allow</i> null references to be used as if they&#x27;re non-null.</div><br/></div></div><div id="41278245" class="c"><input type="checkbox" id="c-41278245" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41276542">root</a><span>|</span><a href="#41277282">parent</a><span>|</span><a href="#41277399">prev</a><span>|</span><a href="#41278158">next</a><span>|</span><label class="collapse" for="c-41278245">[-]</label><label class="expand" for="c-41278245">[1 more]</label></div><br/><div class="children"><div class="content">Compiler designers don&#x27;t have a choice.  Their skill and intelligence is not evidence in either direction, because they&#x27;re not the ones adding null to the language.</div><br/></div></div></div></div></div></div></div></div><div id="41278158" class="c"><input type="checkbox" id="c-41278158" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#41276542">root</a><span>|</span><a href="#41276652">parent</a><span>|</span><a href="#41276747">prev</a><span>|</span><a href="#41276733">next</a><span>|</span><label class="collapse" for="c-41278158">[-]</label><label class="expand" for="c-41278158">[1 more]</label></div><br/><div class="children"><div class="content">I’ve ran into a few edge cases where nil was a desirable feature. But on the whole I do agree with you. Those situations I mentioned could have been solved another way if nils weren’t available. It would have been more code but it might have had the side effect of that codes behaviour being more explicit. So potential win-win.<p>This argument feels somewhat moot though. I cannot see how Go could ever reverse their nil decision because it’s so core to how interfaces work that I suspect it would end up being a massive breaking change.</div><br/></div></div></div></div><div id="41276733" class="c"><input type="checkbox" id="c-41276733" checked=""/><div class="controls bullet"><span class="by">mariusor</span><span>|</span><a href="#41276542">parent</a><span>|</span><a href="#41276652">prev</a><span>|</span><a href="#41276274">next</a><span>|</span><label class="collapse" for="c-41276733">[-]</label><label class="expand" for="c-41276733">[4 more]</label></div><br/><div class="children"><div class="content">You should check the nulls where you run the risk for panic. This is doubly true if your function is part of a library.</div><br/><div id="41278408" class="c"><input type="checkbox" id="c-41278408" checked=""/><div class="controls bullet"><span class="by">enneff</span><span>|</span><a href="#41276542">root</a><span>|</span><a href="#41276733">parent</a><span>|</span><a href="#41279745">next</a><span>|</span><label class="collapse" for="c-41278408">[-]</label><label class="expand" for="c-41278408">[1 more]</label></div><br/><div class="children"><div class="content">It depends. In this trivial case, what do you do if you find s == nil is true? You probably panic anyway. Unless you have some specific reason to panic with a different message to the default “nil pointer dereference” then there’s no point checking it.</div><br/></div></div><div id="41279745" class="c"><input type="checkbox" id="c-41279745" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#41276542">root</a><span>|</span><a href="#41276733">parent</a><span>|</span><a href="#41278408">prev</a><span>|</span><a href="#41279073">next</a><span>|</span><label class="collapse" for="c-41279745">[-]</label><label class="expand" for="c-41279745">[1 more]</label></div><br/><div class="children"><div class="content">The point is that you should check for null, then be able to represent the variable as something that can&#x27;t be null.<p>That way once you&#x27;ve checked it&#x27;s not null (somewhere you&#x27;re not forced to panic ideally), you can pass around the pointer &amp; be confident you don&#x27;t need to ever check it again.</div><br/></div></div><div id="41279073" class="c"><input type="checkbox" id="c-41279073" checked=""/><div class="controls bullet"><span class="by">jfoudfwfayasd</span><span>|</span><a href="#41276542">root</a><span>|</span><a href="#41276733">parent</a><span>|</span><a href="#41279745">prev</a><span>|</span><a href="#41276274">next</a><span>|</span><label class="collapse" for="c-41279073">[-]</label><label class="expand" for="c-41279073">[1 more]</label></div><br/><div class="children"><div class="content">Incorrect, it&#x27;s a type system flaw.</div><br/></div></div></div></div></div></div><div id="41276274" class="c"><input type="checkbox" id="c-41276274" checked=""/><div class="controls bullet"><span class="by">jmyeet</span><span>|</span><a href="#41276542">prev</a><span>|</span><label class="collapse" for="c-41276274">[-]</label><label class="expand" for="c-41276274">[4 more]</label></div><br/><div class="children"><div class="content">How is Go randomizing the map iteration order?<p>In Java, objects are responsible for their equals&#x2F;hashCode implementations. The contract they must abide by is:<p>1. If two objects are equal, they must produce the same hash code; and<p>2. If they are not equal, they may produce the same hash code.<p>So if you had a list of 10 Strings and put them in a map in Java, it&#x27;s likely you&#x27;ll get a deterministic order for iterating over them unless you added a random factor. That factor could be a random seed tied to the map that you XOR the hash code with.<p>You can&#x27;t really change the hash code itself to avoid a Hash DoS attack because you might break that contract. So how does Go (and Rust?) deal with that? Is Go adding a random seed to each hash map? If not, what is it doing?<p>As for nullability, there&#x27;s no going back once you use a type system that expresses nullability.<p>Lastly, PHP arrays are incredibly convenient, ignoring the weirdness with them being array and hash map hybrids. But th ekey aspect is that they maintain insertion order when you use them like a map. This is so often what you want. Yes, other langauges do this too (eg Java&#x27;s LinkedHashMap) but it&#x27;s (IMHO) such a useful default.</div><br/><div id="41278080" class="c"><input type="checkbox" id="c-41278080" checked=""/><div class="controls bullet"><span class="by">jhgg</span><span>|</span><a href="#41276274">parent</a><span>|</span><a href="#41278102">next</a><span>|</span><label class="collapse" for="c-41278080">[-]</label><label class="expand" for="c-41278080">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  Is Go adding a random seed to each hash map?<p>Yes: 
<a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;27093581b2828a2752a6d2711def09517eb2513b&#x2F;src&#x2F;runtime&#x2F;map_swiss.go#L311">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;27093581b2828a2752a6d2711d...</a></div><br/></div></div><div id="41278102" class="c"><input type="checkbox" id="c-41278102" checked=""/><div class="controls bullet"><span class="by">conradludgate</span><span>|</span><a href="#41276274">parent</a><span>|</span><a href="#41278080">prev</a><span>|</span><a href="#41278031">next</a><span>|</span><label class="collapse" for="c-41278102">[-]</label><label class="expand" for="c-41278102">[1 more]</label></div><br/><div class="children"><div class="content">What you do is have a &quot;family&quot; of hash functions. The random seed value chooses a new hash function. The same properties apply to each individual map&#x27;s hash function, but each map has a different hash function<p>Secondary, go map iteration starts from a random position in the hashmap. The order on subsequent iterations is the same, but rotated as a result of the random start index</div><br/></div></div><div id="41278031" class="c"><input type="checkbox" id="c-41278031" checked=""/><div class="controls bullet"><span class="by">chowells</span><span>|</span><a href="#41276274">parent</a><span>|</span><a href="#41278102">prev</a><span>|</span><label class="collapse" for="c-41278031">[-]</label><label class="expand" for="c-41278031">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t use the object hash as the key directly. You combine it with a value chosen randomly per-map using a function that works hard to erase correlations between the input object hash and the output table location.</div><br/></div></div></div></div></div></div></div></div></div></body></html>