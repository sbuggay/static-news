<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1699002059995" as="style"/><link rel="stylesheet" href="styles.css?v=1699002059995"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.w3.org/news/2023/w3c-invites-implementations-of-rdf-dataset-canonicalization/">W3C Invites Implementations of RDF Dataset Canonicalization</a> <span class="domain">(<a href="https://www.w3.org">www.w3.org</a>)</span></div><div class="subtext"><span>PaulHoule</span> | <span>17 comments</span></div><br/><div><div id="38120927" class="c"><input type="checkbox" id="c-38120927" checked=""/><div class="controls bullet"><span class="by">robto</span><span>|</span><a href="#38121492">next</a><span>|</span><label class="collapse" for="c-38120927">[-]</label><label class="expand" for="c-38120927">[3 more]</label></div><br/><div class="children"><div class="content">I worked on implementing this last summer in Clojure, is this the same URDNA2015 specification? I got all but three of the tests in the test suite working, but in the end ditched it for a java library that already had it.<p>This is really useful for signing json-ld, it goes a bit further then regular normalization schemes like JCS by allowing different arrangements of the same data graph to hash to the same thing.</div><br/><div id="38122339" class="c"><input type="checkbox" id="c-38122339" checked=""/><div class="controls bullet"><span class="by">LVB</span><span>|</span><a href="#38120927">parent</a><span>|</span><a href="#38121492">next</a><span>|</span><label class="collapse" for="c-38122339">[-]</label><label class="expand" for="c-38122339">[2 more]</label></div><br/><div class="children"><div class="content">Has JCS gotten any traction? I&#x27;ll eventually have a need for something like JSON signing and recall seeing the JCS draft and a handful of test implementations, but it seemed like really early days for it.</div><br/><div id="38124346" class="c"><input type="checkbox" id="c-38124346" checked=""/><div class="controls bullet"><span class="by">robto</span><span>|</span><a href="#38120927">root</a><span>|</span><a href="#38122339">parent</a><span>|</span><a href="#38121492">next</a><span>|</span><label class="collapse" for="c-38124346">[-]</label><label class="expand" for="c-38124346">[1 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t seen much else that&#x27;s competing in the same space, and it seems to be progressing as a standard, albeit slowly.</div><br/></div></div></div></div></div></div><div id="38121492" class="c"><input type="checkbox" id="c-38121492" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38120927">prev</a><span>|</span><a href="#38120908">next</a><span>|</span><label class="collapse" for="c-38121492">[-]</label><label class="expand" for="c-38121492">[5 more]</label></div><br/><div class="children"><div class="content">Correct me if I&#x27;m wrong, but AIUI known algorithms for graph canonicalization are NP hard. (Graph isomorphism has been found to be likely lower in complexity, but canonicalization is not the same problem as graph isomorphism).  Given blank nodes, the problem of finding a canonical form for RDF is at least as hard as graph canonicalization. So this is a non-starter for general RDF graphs, you&#x27;d have to severely restrict the use of blank nodes to make this practical and the way you do this will likely be application-dependent.</div><br/><div id="38123077" class="c"><input type="checkbox" id="c-38123077" checked=""/><div class="controls bullet"><span class="by">seabass-labrax</span><span>|</span><a href="#38121492">parent</a><span>|</span><a href="#38121708">next</a><span>|</span><label class="collapse" for="c-38123077">[-]</label><label class="expand" for="c-38123077">[1 more]</label></div><br/><div class="children"><div class="content">You are indeed correct that there are NP-hard problems associated with RDF dataset canonicalization. However, the earlier academic research by Aiden Hogen[1] describes how it&#x27;s unlikely to be a problem with real world datasets:<p><pre><code>  ...in our evaluation we demonstrate that there indeed exist difficult synthetic cases, but we also provide results over 9.9 million RDF graphs that suggest such cases occur infrequently in the real world, and that both canonical forms can be efficiently computed in all but a handful of such cases.
</code></pre>
There are experimental results for this near the end of the paper. Aiden Hogen&#x27;s algorithm isn&#x27;t identical to the one which the RDF Dataset Canonicalization specification is attempting to standardise, but I believe it would be a fair assumption to say that a majority of RDF datasets would be unproblematic, and a future test could perhaps be performed to verify this assumption. There should be lots of anecdotal and even academic results coming soon as a result of this W3C Candidate Recommendation publication.<p>In the case of malicious actors, there is a section for &#x27;Dataset Poisoning&#x27;[2] in the RDF Dataset Canonicalization specification that warns implementers to watch out for those datasets that have been designed to cause processing to grind to a halt.<p>I think I would agree with you that application-dependent datasets will be the most viable until some more research is done; indeed the majority of interest seems to come from the W3C Verifiable Credentials space with RDF data inside digital authorization documents[3], for instance as part of the proposals for a privacy-focused revision to the European Union Digital Identity Wallet.<p>[1]: <a href="https:&#x2F;&#x2F;aidanhogan.com&#x2F;docs&#x2F;rdf-canonicalisation.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;aidanhogan.com&#x2F;docs&#x2F;rdf-canonicalisation.pdf</a><p>[2]: <a href="https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;2023&#x2F;CR-rdf-canon-20231031&#x2F;#dataset-poisoning" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;2023&#x2F;CR-rdf-canon-20231031&#x2F;#dataset-po...</a><p>[3]: <a href="https:&#x2F;&#x2F;w3c.github.io&#x2F;vc-data-integrity&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;w3c.github.io&#x2F;vc-data-integrity&#x2F;</a></div><br/></div></div><div id="38121708" class="c"><input type="checkbox" id="c-38121708" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#38121492">parent</a><span>|</span><a href="#38123077">prev</a><span>|</span><a href="#38120908">next</a><span>|</span><label class="collapse" for="c-38121708">[-]</label><label class="expand" for="c-38121708">[3 more]</label></div><br/><div class="children"><div class="content">&quot;W3C RDF Dataset Canonicalization: 
A Standard RDF Dataset Canonicalization Algorithm&quot; &gt; &quot;4.3 Blank Node Identifier Issuer State&quot; 
<a href="https:&#x2F;&#x2F;w3c-ccg.github.io&#x2F;rdf-dataset-canonicalization&#x2F;spec&#x2F;#blank-node-identifier-issuer-state" rel="nofollow noreferrer">https:&#x2F;&#x2F;w3c-ccg.github.io&#x2F;rdf-dataset-canonicalization&#x2F;spec&#x2F;...</a><p>IIRC ld-signatures (-&gt; ld-proofs -&gt; Data Integrity) specified URDNA many years ago?</div><br/><div id="38122275" class="c"><input type="checkbox" id="c-38122275" checked=""/><div class="controls bullet"><span class="by">slaymaker1907</span><span>|</span><a href="#38121492">root</a><span>|</span><a href="#38121708">parent</a><span>|</span><a href="#38120908">next</a><span>|</span><label class="collapse" for="c-38122275">[-]</label><label class="expand" for="c-38122275">[2 more]</label></div><br/><div class="children"><div class="content">If you search for “isomorphism” in the doc, they state that most real world cases will have unique IDs for nodes and that make this efficient in practice and that implementations can detect if a case is difficult (likely aborting).</div><br/><div id="38124423" class="c"><input type="checkbox" id="c-38124423" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#38121492">root</a><span>|</span><a href="#38122275">parent</a><span>|</span><a href="#38120908">next</a><span>|</span><label class="collapse" for="c-38124423">[-]</label><label class="expand" for="c-38124423">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.w3.org&#x2F;wiki&#x2F;BnodeSkolemization" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.w3.org&#x2F;wiki&#x2F;BnodeSkolemization</a><p>rdf-concepts&#x2F;#section-blank-nodes: 
<a href="https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;rdf-concepts&#x2F;#section-blank-nodes" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;rdf-concepts&#x2F;#section-blank-nodes</a><p>Rdflib docs on Skolemization: <a href="https:&#x2F;&#x2F;rdflib.readthedocs.io&#x2F;en&#x2F;stable&#x2F;persisting_n3_terms.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;rdflib.readthedocs.io&#x2F;en&#x2F;stable&#x2F;persisting_n3_terms....</a> :<p>&gt; <i>Skolemization is a syntactic transformation routinely used in automatic inference systems in which existential variables are replaced by ‘new’ functions - function names not used elsewhere - applied to any enclosing universal variables. In RDF, Skolemization amounts to replacing every blank node in a graph by a ‘new’ name, i.e. a URI reference which is guaranteed to not occur anywhere else. In effect, it gives ‘arbitrary’ names to the anonymous entities whose existence was asserted by the use of blank nodes: the arbitrariness of the names ensures that nothing can be inferred that would not follow from the bare assertion of existence represented by the blank node.</i><p>SPARQL has UUID() and BNODE() functions: <a href="https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;sparql11-query&#x2F;#func-bnode" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;sparql11-query&#x2F;#func-bnode</a> :<p>&gt; <i>The BNODE function constructs a blank node that is distinct from all blank nodes in the dataset being queried and distinct from all blank nodes created by calls to this constructor for other query solutions. If the no argument form is used, every call results in a distinct blank node. If the form with a simple literal is used, every call results in distinct blank nodes for different simple literals, and the same blank node for calls with the same simple literal within expressions for one solution mapping.</i><p>Blank node: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Blank_node" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Blank_node</a></div><br/></div></div></div></div></div></div></div></div><div id="38120908" class="c"><input type="checkbox" id="c-38120908" checked=""/><div class="controls bullet"><span class="by">xamde</span><span>|</span><a href="#38121492">prev</a><span>|</span><label class="collapse" for="c-38120908">[-]</label><label class="expand" for="c-38120908">[8 more]</label></div><br/><div class="children"><div class="content">&gt; The document is primarily intended for the following audiences:<p><pre><code>    Software developers that want to implement an RDF dataset canonicalization algorithm.
    Masochists.

</code></pre>
Pick your side.</div><br/><div id="38121149" class="c"><input type="checkbox" id="c-38121149" checked=""/><div class="controls bullet"><span class="by">no_wizard</span><span>|</span><a href="#38120908">parent</a><span>|</span><a href="#38121346">next</a><span>|</span><label class="collapse" for="c-38121149">[-]</label><label class="expand" for="c-38121149">[1 more]</label></div><br/><div class="children"><div class="content">In case anyone is wondering, its really what it says:<p><a href="https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;2023&#x2F;CR-rdf-canon-20231031&#x2F;#how-to-read" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;2023&#x2F;CR-rdf-canon-20231031&#x2F;#how-to-rea...</a></div><br/></div></div><div id="38121346" class="c"><input type="checkbox" id="c-38121346" checked=""/><div class="controls bullet"><span class="by">oever</span><span>|</span><a href="#38120908">parent</a><span>|</span><a href="#38121149">prev</a><span>|</span><a href="#38122798">next</a><span>|</span><label class="collapse" for="c-38121346">[-]</label><label class="expand" for="c-38121346">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve yet to see a convincing use-case to canonicalize RDF graphs.<p>The document cites these use-cases:<p>There are different use cases where graph or dataset canonicalization are important:<p><pre><code>    Determining if one serialization is isomorphic to another.
    Digital signing of graphs (datasets) independent of serialization or format.
    Comparing two graphs (datasets) to find differences.
    Communicating change sets when remotely updating an RDF source.
</code></pre>
These are not real-world use-cases. Why would one want to sign independent of serialization or format? The real-world need is that people start signing graphs. But why would they sign some abstract format that is independent of serialization format? That supposedly independent format is a format too and will have competition soon. It&#x27;s the way of the world: fork, fork fork.<p>I&#x27;m signing my RDF graphs as bytearrays with PGP and avoid all the hassle.</div><br/><div id="38122737" class="c"><input type="checkbox" id="c-38122737" checked=""/><div class="controls bullet"><span class="by">slaymaker1907</span><span>|</span><a href="#38120908">root</a><span>|</span><a href="#38121346">parent</a><span>|</span><a href="#38123577">next</a><span>|</span><label class="collapse" for="c-38122737">[-]</label><label class="expand" for="c-38122737">[2 more]</label></div><br/><div class="children"><div class="content">I assume that serialization formats might reference this standard so that they don’t need to reinvent the wheel that is graph normalization.<p>&gt; A canonicalization algorithm is necessary, but not necessarily sufficient, to handle many of these use cases.<p>It’s kind of like how there’s a standard for structured copy of JS objects that gets used for things like the web worker spec.<p>Signing something independent of serialization might be useful since then the exact serialization format can vary. For example, maybe the data is already serialized using SQLite. I’d prefer to avoid loading the data into memory and reserializing it just to check the signature. Instead, it’d be nice to just canonicalize it and then utilize the indexing capabilities of SQLite to minimize memory usage.</div><br/><div id="38125207" class="c"><input type="checkbox" id="c-38125207" checked=""/><div class="controls bullet"><span class="by">oever</span><span>|</span><a href="#38120908">root</a><span>|</span><a href="#38122737">parent</a><span>|</span><a href="#38123577">next</a><span>|</span><label class="collapse" for="c-38125207">[-]</label><label class="expand" for="c-38125207">[1 more]</label></div><br/><div class="children"><div class="content">So the use-case is a to a very tentative optimization. This tentative optimization is achieved by introducing a very complicated algorithm that is not guaranteed to run in finite time.<p>You could also check signatures when loading the data and keep the original bytearray separately in slow&#x2F;cheap storage.<p>That way you can sign RDF graphs like you sign any bytearray and keep a simple design.</div><br/></div></div></div></div><div id="38123577" class="c"><input type="checkbox" id="c-38123577" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#38120908">root</a><span>|</span><a href="#38121346">parent</a><span>|</span><a href="#38122737">prev</a><span>|</span><a href="#38122798">next</a><span>|</span><label class="collapse" for="c-38123577">[-]</label><label class="expand" for="c-38123577">[2 more]</label></div><br/><div class="children"><div class="content">when you sign an RDP graph as a bytearray,  how do you cope with the fact that multiple bytearrays serialize the same graph?</div><br/><div id="38125188" class="c"><input type="checkbox" id="c-38125188" checked=""/><div class="controls bullet"><span class="by">oever</span><span>|</span><a href="#38120908">root</a><span>|</span><a href="#38123577">parent</a><span>|</span><a href="#38122798">next</a><span>|</span><label class="collapse" for="c-38125188">[-]</label><label class="expand" for="c-38125188">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t. Why would you want to cope with that? When does it matter that multiple bytearrays give same graph?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>