<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1722934862187" as="style"/><link rel="stylesheet" href="styles.css?v=1722934862187"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://spectrum.ieee.org/kan-neural-network">A new type of neural network is more interpretable</a> <span class="domain">(<a href="https://spectrum.ieee.org">spectrum.ieee.org</a>)</span></div><div class="subtext"><span>pseudolus</span> | <span>64 comments</span></div><br/><div><div id="41164934" class="c"><input type="checkbox" id="c-41164934" checked=""/><div class="controls bullet"><span class="by">Ameo</span><span>|</span><a href="#41163349">next</a><span>|</span><label class="collapse" for="c-41164934">[-]</label><label class="expand" for="c-41164934">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve tried out and written about[1] KANs on some small-scale modeling, comparing them to vanilla neural networks, as previously discussed here: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40855028">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40855028</a>.<p>My main finding was that KANs are very tricky to train compared to NNs. It&#x27;s usually possible to get per-parameter loss roughly on par with NNs, but it requires a lot of hyperparameter tuning and extra tricks in the KAN architecture. In comparison, vanilla NNs were much easier to train and worked well under a much broader set of conditions.<p>Some people commented that we&#x27;ve invested an incredible amount of effort into getting really good at training NNs efficiently, and many of the things in ML libraries (optimizers like Adam, for example) are designed and optimized specifically for NNs. For that reason, it&#x27;s not really a good apples-to-apples comparison.<p>I think there&#x27;s definitely potential in KANs, but they aren&#x27;t a magic bullet. I&#x27;m also a bit dubious about interpretability claims; the splines that are usually used for KANs don&#x27;t really offer much more insight to me than just analyzing the output of a neuron in a lower layer of a NN.<p>[1] <a href="https:&#x2F;&#x2F;cprimozic.net&#x2F;blog&#x2F;trying-out-kans&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cprimozic.net&#x2F;blog&#x2F;trying-out-kans&#x2F;</a></div><br/><div id="41167409" class="c"><input type="checkbox" id="c-41167409" checked=""/><div class="controls bullet"><span class="by">Lerc</span><span>|</span><a href="#41164934">parent</a><span>|</span><a href="#41167813">next</a><span>|</span><label class="collapse" for="c-41167409">[-]</label><label class="expand" for="c-41167409">[1 more]</label></div><br/><div class="children"><div class="content">This is sort of my view as well,  most of the hype and the criticisms of KANs seem to be fairly unfounded.<p>I do think they have a lot of potential, but what has been published so far does not represent a panacea.  Perhaps they will have an impact like transformers, perhaps they will only serve in a little niche.  You can&#x27;t really tell immediately how refinements will alter the usability.<p>Finding out what those refinements are and how they change things is what research is all about.   I have been quite enjoying following <a href="https:&#x2F;&#x2F;github.com&#x2F;mintisan&#x2F;awesome-kan">https:&#x2F;&#x2F;github.com&#x2F;mintisan&#x2F;awesome-kan</a> progress and seeing the variety of things being tried.   I have a few ideas of  my own I might try at sometime.<p>Between KANs and fixed activation function networks there is an entire continuum of activation function tuning available for research.<p>Buckets of simple parameter activation functions something like x<i>sigmoid(m</i>x) ( ReLU when m is large, GeLU at m=1.7,  SiLU at m=1).  This adds a small number of parameters for presumably some game<p>Single activation functions as above per neuron.<p>Multi parameterizable activation functions,  in batches, or per neuron.<p>Many parameter function approximators, in batches, or per neuron.<p>Full KANs without weights.<p>I can see some significant acclaim being awarded to the person who can calculate a unified formula for determining where additional parameters should go for the largest impact.</div><br/></div></div><div id="41167813" class="c"><input type="checkbox" id="c-41167813" checked=""/><div class="controls bullet"><span class="by">wanderingmind</span><span>|</span><a href="#41164934">parent</a><span>|</span><a href="#41167409">prev</a><span>|</span><a href="#41166013">next</a><span>|</span><label class="collapse" for="c-41167813">[-]</label><label class="expand" for="c-41167813">[1 more]</label></div><br/><div class="children"><div class="content">Really detailed work. Thank you. For those looking to jump straight to code, here is the link to codebase discussed in the blog.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;Ameobea&#x2F;kan">https:&#x2F;&#x2F;github.com&#x2F;Ameobea&#x2F;kan</a></div><br/></div></div><div id="41166013" class="c"><input type="checkbox" id="c-41166013" checked=""/><div class="controls bullet"><span class="by">smus</span><span>|</span><a href="#41164934">parent</a><span>|</span><a href="#41167813">prev</a><span>|</span><a href="#41168540">next</a><span>|</span><label class="collapse" for="c-41166013">[-]</label><label class="expand" for="c-41166013">[1 more]</label></div><br/><div class="children"><div class="content">Not just the optimizers, but the initialization schemes for neural networks have been explicitly tuned for stable training of neural nets with traditional activation functions. I&#x27;m not sure as much work has gone into intialization for KANs<p>I 100% agree with the idea that these won&#x27;t be any more interpretable and I&#x27;ve never understood the argument that they would be. Sure, if the NN was a single neuron I can see it, but as soon as you start composing these things you lose all interpretability imo</div><br/></div></div><div id="41168540" class="c"><input type="checkbox" id="c-41168540" checked=""/><div class="controls bullet"><span class="by">alexnewman</span><span>|</span><a href="#41164934">parent</a><span>|</span><a href="#41166013">prev</a><span>|</span><a href="#41163349">next</a><span>|</span><label class="collapse" for="c-41168540">[-]</label><label class="expand" for="c-41168540">[1 more]</label></div><br/><div class="children"><div class="content">I’m very happy to hear someone else say the quiet part out loud . Everyone claims nn aren’t interpretable, but that’s never been my experience . Quiet the contrary</div><br/></div></div></div></div><div id="41163349" class="c"><input type="checkbox" id="c-41163349" checked=""/><div class="controls bullet"><span class="by">thomasahle</span><span>|</span><a href="#41164934">prev</a><span>|</span><a href="#41168702">next</a><span>|</span><label class="collapse" for="c-41163349">[-]</label><label class="expand" for="c-41163349">[26 more]</label></div><br/><div class="children"><div class="content">KANs can be modeled as just another activation architecture in normal MLPs, which is of course not surprising, since they are very flexible. I made a chart of different types of architectures here: <a href="https:&#x2F;&#x2F;x.com&#x2F;thomasahle&#x2F;status&#x2F;1796902311765434694" rel="nofollow">https:&#x2F;&#x2F;x.com&#x2F;thomasahle&#x2F;status&#x2F;1796902311765434694</a><p>Curiously KANs are not very efficient when implemented with normal matrix multiplications in Pytorch, say. But with a custom cuda kernel, or using torch.compile they can be very fast: <a href="https:&#x2F;&#x2F;x.com&#x2F;thomasahle&#x2F;status&#x2F;1798408687981297844" rel="nofollow">https:&#x2F;&#x2F;x.com&#x2F;thomasahle&#x2F;status&#x2F;1798408687981297844</a></div><br/><div id="41163432" class="c"><input type="checkbox" id="c-41163432" checked=""/><div class="controls bullet"><span class="by">byteknight</span><span>|</span><a href="#41163349">parent</a><span>|</span><a href="#41163915">next</a><span>|</span><label class="collapse" for="c-41163432">[-]</label><label class="expand" for="c-41163432">[22 more]</label></div><br/><div class="children"><div class="content">Side question:<p>Can people this deep in the field read that visualization with all the formulas and actually grok what&#x27;s going on? I&#x27;m trying to understand just how far behind I am from the average math person (obviously very very very far, but quantifiable lol)</div><br/><div id="41164154" class="c"><input type="checkbox" id="c-41164154" checked=""/><div class="controls bullet"><span class="by">thomasahle</span><span>|</span><a href="#41163349">root</a><span>|</span><a href="#41163432">parent</a><span>|</span><a href="#41164202">next</a><span>|</span><label class="collapse" for="c-41164154">[-]</label><label class="expand" for="c-41164154">[5 more]</label></div><br/><div class="children"><div class="content">The tensor diagrams are not quite standard (yet). That&#x27;s why I also include more &quot;classical&quot; neural network diagrams next to them.<p>I&#x27;ve recently been working on a library for doing automatic manipulation and differentiation of tensor diagrams (<a href="https:&#x2F;&#x2F;github.com&#x2F;thomasahle&#x2F;tensorgrad">https:&#x2F;&#x2F;github.com&#x2F;thomasahle&#x2F;tensorgrad</a>), and to me they are clearly a cleaner notation.<p>For a beautiful introduction to tensor networks, see also Jordan Taylor&#x27;s blog post (<a href="https:&#x2F;&#x2F;www.lesswrong.com&#x2F;posts&#x2F;BQKKQiBmc63fwjDrj&#x2F;graphical-tensor-notation-for-interpretability" rel="nofollow">https:&#x2F;&#x2F;www.lesswrong.com&#x2F;posts&#x2F;BQKKQiBmc63fwjDrj&#x2F;graphical-...</a>)</div><br/><div id="41168811" class="c"><input type="checkbox" id="c-41168811" checked=""/><div class="controls bullet"><span class="by">cgadski</span><span>|</span><a href="#41163349">root</a><span>|</span><a href="#41164154">parent</a><span>|</span><a href="#41168828">next</a><span>|</span><label class="collapse" for="c-41168811">[-]</label><label class="expand" for="c-41168811">[1 more]</label></div><br/><div class="children"><div class="content">After learning about tensor diagrams a few months ago, they&#x27;re my default notation for tensors. I liked your chart and also Jordan Taylor&#x27;s diagram for multi-head attention.<p>Some notes for other readers seeing this for the first time:<p>My favorite property of that these diagrams is that they make it easy to re-interpret a multilinear expression as a multilinear function of any of its variables. For example, in standard matrix notation you&#x27;d write x^T A x to get a quadratic form with respect to the variable x. I think most people read this either left to right or right to left: take a matrix-vector product, and then take an inner product between vectors. Tensor notation is more like prolog: the diagram<p><pre><code>  x - A - x 
</code></pre>
involves these two indices&#x2F;variables (the lines) &quot;bound&quot; by three tensors&#x2F;relations (A and two copies of x.) That framing makes it easier to think about the expression as a function of A: it&#x27;s just the a &quot;Frobenius inner product&quot; between -A- and the tensor product -x x-. The same thing happens with the inner product between a signal and a convolution of two other signals. In standard notation it might take a little thought to remember how to differentiate &lt;x, y * z&gt; with respect to y (&lt;x, y * z&gt; = &lt;y, x * z&#x27;&gt; where x&#x27; is a time-reversal), but thinking with a tensor diagram reminds you to focus on the relation x = y + z (a 3-dimensional tensor) constraining the indices x, y and z of your three signals. All of this becomes increasingly critical when you have more indices involved. For example, how can you write the flattened matrix vec(AX + XB) as a matrix-vector product of vec(X) so we can solve the equation AX + XB = C? (Example stolen from your book.)<p>I still have to get a hold of all the rules for dealing with non-linearities (&quot;bubbles&quot;) though. I&#x27;ll have to take a look at your tensor cookbook :) I&#x27;m also sad that I can&#x27;t write tensor diagrams easily in my digital notes.<p>Tensor diagrams are algebraically the same thing as factor graphs in probability theory. (Tensors correspond to factors and indices correspond to variables.) The only difference is that factors in probability theory need to be non-negative. You can define a contraction over indices for tensors taking values in any semiring though. The max-plus semiring gives you maximum log-likelihood problems, and so on.</div><br/></div></div><div id="41168828" class="c"><input type="checkbox" id="c-41168828" checked=""/><div class="controls bullet"><span class="by">cshimmin</span><span>|</span><a href="#41163349">root</a><span>|</span><a href="#41164154">parent</a><span>|</span><a href="#41168811">prev</a><span>|</span><a href="#41166772">next</a><span>|</span><label class="collapse" for="c-41168828">[-]</label><label class="expand" for="c-41168828">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m familiar with almost all of these architectures, but not the tensor diagram notation. I can&#x27;t figure out what &quot;B&quot; is? I thought maybe it&#x27;s a bias vector, but then why does it only appear on the input data, and not on subsequent fc layers?</div><br/></div></div><div id="41166772" class="c"><input type="checkbox" id="c-41166772" checked=""/><div class="controls bullet"><span class="by">programjames</span><span>|</span><a href="#41163349">root</a><span>|</span><a href="#41164154">parent</a><span>|</span><a href="#41168828">prev</a><span>|</span><a href="#41164202">next</a><span>|</span><label class="collapse" for="c-41166772">[-]</label><label class="expand" for="c-41166772">[2 more]</label></div><br/><div class="children"><div class="content">These remind me of interaction combinators [1], which are being used in the Bend programming language [1]. I think it&#x27;d be good for the standard to also be a valid interaction net.<p>[1]: <a href="https:&#x2F;&#x2F;core.ac.uk&#x2F;download&#x2F;pdf&#x2F;81113716.pdf" rel="nofollow">https:&#x2F;&#x2F;core.ac.uk&#x2F;download&#x2F;pdf&#x2F;81113716.pdf</a><p>[2]: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40390287">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40390287</a></div><br/><div id="41168028" class="c"><input type="checkbox" id="c-41168028" checked=""/><div class="controls bullet"><span class="by">thomasahle</span><span>|</span><a href="#41163349">root</a><span>|</span><a href="#41166772">parent</a><span>|</span><a href="#41164202">next</a><span>|</span><label class="collapse" for="c-41168028">[-]</label><label class="expand" for="c-41168028">[1 more]</label></div><br/><div class="children"><div class="content">This stuff is super cool! It basically generalizes tensor diagrams to general computational graphs.<p>However, when thinking about ML architectures, I actually like that classical tensor diagrams make it harder to express non-associative architectures. E.g. RNNs are much harder to write than Transformers.</div><br/></div></div></div></div></div></div><div id="41164202" class="c"><input type="checkbox" id="c-41164202" checked=""/><div class="controls bullet"><span class="by">Krei-se</span><span>|</span><a href="#41163349">root</a><span>|</span><a href="#41163432">parent</a><span>|</span><a href="#41164154">prev</a><span>|</span><a href="#41163999">next</a><span>|</span><label class="collapse" for="c-41164202">[-]</label><label class="expand" for="c-41164202">[13 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need to be more good in math than in high school. AI is a chain of functions and you derive over those to get to the loss-function (gradient) to tell you which parameters to  change to get a better result (simplified!).<p>Now this structure of functions is different in each implementations, but the type of function is quite similar - even though a large model will combine billions of those nodes and weights. Those visualizations tell you f.e. that some models connect neurons back to ones earlier in the chain to better remember a state. But the activation function is usually a weight and threshold.<p>KAN changes the functions on the edges to more sophisticated ones than just &quot;multiply by 0.x&quot; and uses known physical formulas that you can actually explain to a human instead of the result coming from 100x different weights which tell you nothing.<p>The language models we use currently may map how your brain works, but how strong the neurons are connected and to which others does not tell you anything. Instead a computer can chain different functions like you would chain a normal work task and explain each step to you &#x2F; combine those learned routines on different tasks.<p>I am by no means an expert in this field, but i do a lot of category theory, especially for the reason that i wanted a more explainable neuron network. So take my pov with a grain of salt, but please don&#x27;t be discouraged to learn this. If you can program a little and remember some calculus you can definitely grasp these concepts after learning the vocabulary!</div><br/><div id="41165633" class="c"><input type="checkbox" id="c-41165633" checked=""/><div class="controls bullet"><span class="by">godelski</span><span>|</span><a href="#41163349">root</a><span>|</span><a href="#41164202">parent</a><span>|</span><a href="#41163999">next</a><span>|</span><label class="collapse" for="c-41165633">[-]</label><label class="expand" for="c-41165633">[12 more]</label></div><br/><div class="children"><div class="content">&gt; You don&#x27;t need to be more good in math than in high school.<p>I&#x27;m very tired of this... it needs to stop as it literally hinders ML progress<p>1) I know one (ONE) person who took multivariate calculus in high school. They did so by going to the local community college. I know zero people who took linear algebra. I just checked the listing of my old high school. Over a decade later neither multivariate calculus nor linear algebra is offered.<p>2) There&#x27;s something I like to tell my students<p><pre><code>  You don&#x27;t need math to train a good model, but you do need to know math to know why your model is wrong.
</code></pre>
I&#x27;m sure many here recognize the reference[0], but being able to make a model that performs successfully on a test set[1] is not always meaningful. For example, about a year ago I was working a very big tech firm and increased their model&#x27;s capacity on customer data by over 200% with a model that performed worse on their &quot;test set&quot;. No additional data was used, nor did I make any changes to the architecture. Figure that out without math. (note, I was able to predict poor generalization performance PRIOR to my changes and accurately predict my model&#x27;s significantly higher generalization performance)<p>3) Math isn&#x27;t just writing calculations down. That&#x27;s part of it -- a big part -- but the concepts are critical. And to truly understand those concepts, you at some point need to do these calculations. Because at the end of the day, math is a language[2].<p>4) Just because the simplified view is not mathematically intensive does not mean math isn&#x27;t important nor does it mean there isn&#x27;t extremely complex mathematics under the hood. You&#x27;re only explaining the mathematics in a simple way that is only about the updating process. There&#x27;s a lot more to ML. And this should obviously be true since we consider them &quot;black boxes&quot;[3]. A lack of interpretability is not due to an immutable law, but due to our lack of understanding of a highly complex system. Yes, maybe each action in that system is simple, but if that meant the system as a whole was simple then I welcome you to develop a TOE for physics. Emergence is useful but also a pain in the ass[4].<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;All_models_are_wrong" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;All_models_are_wrong</a><p>[1] For one, this is more accurately called a validation set. Test sets are held out. No more tuning. You&#x27;re done. This is self-referential to my point.<p>[2] If you want to fight me on this, at least demonstrate to me you have taken an abstract algebra course and understand ideals and rings. Even better if axioms and set theory. I accept other positions, but too many argue from the basis of physics without understanding the difference between a physics and physics. Just because math is the language of physics does not mean math (or even physics) is inherently an objective principle (physics is a model).<p>[3] I hate this term. They are not black, but they are opaque. Which is to say that there is _some_ transparency.<p>[4] I am using the term &quot;emergence&quot; in the way a physicist would, not what you&#x27;ve seen in an ML paper. Why? Well read point 4 again starting at footnote [3].</div><br/><div id="41166820" class="c"><input type="checkbox" id="c-41166820" checked=""/><div class="controls bullet"><span class="by">programjames</span><span>|</span><a href="#41163349">root</a><span>|</span><a href="#41165633">parent</a><span>|</span><a href="#41168227">next</a><span>|</span><label class="collapse" for="c-41166820">[-]</label><label class="expand" for="c-41166820">[5 more]</label></div><br/><div class="children"><div class="content">I know many people who did take multivariate calculus, group&#x2F;ring theory, and thermodynamics in high school, and think this should be the norm. I believe I consider &quot;high school&quot; math what most people consider &quot;undergraduate&quot;, and everything up to linear algebra goes under &quot;middle school&quot; in my mental model (ages 12-14). So, I&#x27;m probably one of those people propagating, &quot;ML math is easy, you only need a high school knowledge!&quot; but I acknowledge that&#x27;s still more than most people ever learn.</div><br/><div id="41167285" class="c"><input type="checkbox" id="c-41167285" checked=""/><div class="controls bullet"><span class="by">andrewflnr</span><span>|</span><a href="#41163349">root</a><span>|</span><a href="#41166820">parent</a><span>|</span><a href="#41168227">next</a><span>|</span><label class="collapse" for="c-41167285">[-]</label><label class="expand" for="c-41167285">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I acknowledge that&#x27;s still more than most people ever learn.<p>So you know you&#x27;re wrong as a matter of plain fact, but you&#x27;re going to continue to spout your &quot;mental model&quot; as truth anyway?<p>What are you trying to say here? It doesn&#x27;t matter much what &quot;should&quot; be high school knowledge unless you&#x27;re designing curriculum. If no one <i>actually</i> learns it in high school then a phrase like &quot;you only need high school knowledge&quot; means nothing to most people.</div><br/><div id="41168507" class="c"><input type="checkbox" id="c-41168507" checked=""/><div class="controls bullet"><span class="by">godelski</span><span>|</span><a href="#41163349">root</a><span>|</span><a href="#41167285">parent</a><span>|</span><a href="#41167973">next</a><span>|</span><label class="collapse" for="c-41168507">[-]</label><label class="expand" for="c-41168507">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  &gt; &quot;you only need high school knowledge&quot; means nothing to most people.
</code></pre>
I think people intend to use it to tell people the barrier is low. But by trivializing the difficulties of calculus (may be easy now, but was it before you learned it?), you place that barrier higher than it was before. The result is the opposite of the intent.<p>I&#x27;ll even state it now, as someone who highly advocates for learning math:<p><pre><code>  You don&#x27;t even need calculus to build good models. At most, a rudimentary understanding of algebra, but I&#x27;m not sure even that. A little programming skill, which can freely and easily be obtained, is all that is necessary to begin. So if you can read and can motivate yourself, you can build good and useful models. It might just take longer if you don&#x27;t have these yet.
</code></pre>
With that said, be cautious that you fall victim to your success. The barrier to entry may be (very) low, but it is a long way to the top. So don&#x27;t ignore the fundamentals and use your excitement and success to motivate yourself through the boring and hard parts. Unfortunately, there&#x27;s a steep curve to reap the rewards of your math knowledge (in ML. You&#x27;ll reap rewards even in daily life much sooner!). But it is well worth it. ML is only a magical black box because you have not achieved this yet (this does not mean ML becomes a white box). Not knowing what you don&#x27;t know makes it hard to progress. But I promise math will help illuminate things (e.g. understanding when and where CNNs vs transformers should be used inside architectures; how many parameters you need in hidden layers; how to make your models robust; why they fail; how to identify where they will fail before it happens; and much more. These are enormously helpful, and more if you wish to build products and not just research papers or blogs. If models are black boxes due to the composition of easily and well understood functions, I think you can probably guess how small and subtle changes can have large effects on performance. You&#x27;ll at least learn a bit about this concept (chaos) in differential equations).</div><br/></div></div><div id="41167973" class="c"><input type="checkbox" id="c-41167973" checked=""/><div class="controls bullet"><span class="by">programjames</span><span>|</span><a href="#41163349">root</a><span>|</span><a href="#41167285">parent</a><span>|</span><a href="#41168507">prev</a><span>|</span><a href="#41168227">next</a><span>|</span><label class="collapse" for="c-41167973">[-]</label><label class="expand" for="c-41167973">[2 more]</label></div><br/><div class="children"><div class="content">As I said,<p>&gt; I know many people who did take...<p>In fact, the vast majority of my friends did, so my mental model is more useful to me than one that apportions a larger cut to the rest of the population. I also find it egregious that thirteen years of schooling doesn&#x27;t get everyone to this level, so I want to hold the education system accountable by not loosening my standard.<p>&gt; If [almost] no one actually learns it in high school then a phrase like &quot;you only need high school knowledge&quot; means nothing to most people.<p>I agree that this isn&#x27;t as good at conveying information (unless the consensus changes), but that&#x27;s not all I&#x27;m trying to do.</div><br/><div id="41168325" class="c"><input type="checkbox" id="c-41168325" checked=""/><div class="controls bullet"><span class="by">godelski</span><span>|</span><a href="#41163349">root</a><span>|</span><a href="#41167973">parent</a><span>|</span><a href="#41168227">next</a><span>|</span><label class="collapse" for="c-41168325">[-]</label><label class="expand" for="c-41168325">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  &gt; so my mental model 
</code></pre>
This is the point though. If you know your mental model is wrong, you should update your model rather that perpetuate the errors. It&#x27;s okay to be wrong and no one is upset at you for being wrong (at least not me). But if you are knowingly wrong, don&#x27;t try to justify it, use the signal to help you change your model. I know it isn&#x27;t easy, but recognize that defending your bad model makes this harder. It is okay to admit fault and you&#x27;ll often be surprised how this can turn a conversation around. (FWIW, I think a lot of people struggle with this, including me. This comment is even me trying to reinforce this behavior in myself. But I think you will also be receptive because I think your intent and words diverged; I hope I can be part of that feedback signal that so many provided to me.)<p><pre><code>  &gt; so I want to hold the education system accountable
</code></pre>
So hold them accountable, not the people in these. I think you intend to blame the system, but I think if you read your message carefully, you&#x27;ll see a very reasonable interpretation is that you&#x27;re blaming the person. It is because you&#x27;re suggesting this is a level of math that everyone should know.<p>For a frame of reference the high school I went to is (currently) in the top 20% of CA and top 10% of the country. I checked their listings and while there&#x27;s a 50% participation rate in AP (they also have IB), they do not offer Linear Algebra or anything past Calc I. So I think this should help you update your model to consider what opportunities people have. I think this is especially important because we should distinguish opportunity from potential and skill. I firmly believe metrics hinder the chance of any form of meritocracy in part due to the fact that opportunity is so disproportionate (more so due to to the fact that metrics are models. And you know what they say about all models ;).<p>If we want to actually make a better society and smarter population, we should not be diminutive to people for the lack of opportunities that are out of their control. Instead I think we should recognize this and make sure that we are not the ones denying opportunities. If we talk about education, (with exception at the extreme ends) I think we can recognize that the difference between a top tier high school student and a bit below average, is not that huge. Post undergrad it certainly grows, but I don&#x27;t think it is that large either. So I&#x27;m just saying, a bit of compassion goes a long ways. Opportunity compounds, so the earlier the better. I&#x27;m fond of the phrase &quot;the harder I work, the luckier I get&quot; because your hard work does contribute to your success, but it isn&#x27;t the only factor[0]. We know &quot;advanced&quot; math, so we know nothing in real life is univariate, right? You work hard so that you may take advantage of opportunities that come your way, but the cards you are dealt are out of your control. And personally, I think we should do our best to ensure that we the dominating factor that determines outcome is due to what someone can actually control. And more importantly, we recognize how things compound (also [0]).<p>I&#x27;m not mad or angry with you. But I think you should take a second to reevaluate your model. I&#x27;m sure it has utility, but I&#x27;m sure you&#x27;re not always in a setting where it is useful (like now). If you are, at least recognize how extreme your bubble is.<p>[0] I highly suggest watching, even if you&#x27;ve seen it before. <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=3LopI4YeC4I" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=3LopI4YeC4I</a></div><br/></div></div></div></div></div></div></div></div><div id="41168227" class="c"><input type="checkbox" id="c-41168227" checked=""/><div class="controls bullet"><span class="by">Krei-se</span><span>|</span><a href="#41163349">root</a><span>|</span><a href="#41165633">parent</a><span>|</span><a href="#41166820">prev</a><span>|</span><a href="#41165964">next</a><span>|</span><label class="collapse" for="c-41168227">[-]</label><label class="expand" for="c-41168227">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see any lessons here, just rambling.</div><br/><div id="41168439" class="c"><input type="checkbox" id="c-41168439" checked=""/><div class="controls bullet"><span class="by">godelski</span><span>|</span><a href="#41163349">root</a><span>|</span><a href="#41168227">parent</a><span>|</span><a href="#41165964">next</a><span>|</span><label class="collapse" for="c-41168439">[-]</label><label class="expand" for="c-41168439">[1 more]</label></div><br/><div class="children"><div class="content">Then allow me to clarify:<p><pre><code>  - Very few high schools in America offer these classes. Even fewer people take them. The lie to yourself is not recognizing your bubble. You might think you&#x27;re encouraging others, but you&#x27;re doing the opposite. People who had those opportunities are likely not the ones that feel like ML is beyond their capabilities. 

  - While you can be successful in ML without math, this does not mean you should discourage its pursuit (just as you shouldn&#x27;t place it as a gate keeping requirement. Even Calc and LA aren&#x27;t required!). 

  -  Math is about a way of thinking and approaching problems. These skills generalize beyond the ability to solve mathematical functions. 

  - The mathematical knowledge compounds and will make your models better. This may be nonobvious, especially given your suggested background, you&#x27;ve lived with this knowledge for quite some time. But if you haven&#x27;t gone into things like statistical theory (more than ISLR), probability, metric theory, optimization, and so on, it is quite difficult to see how these help you in the same way it&#x27;s hard to see what&#x27;s on a shelf above you. It can also be difficult to explain how these help if you lack the language. But if you want to build good products (that work in the real world and not just in a demo), you&#x27;ll find this knowledge is invaluable. If you don&#x27;t understand why, let this be a signal of your overconfidence. Models aren&#x27;t worth shit if they don&#x27;t generalize (I&#x27;m not talking about AGI, I&#x27;m talking about generalizing to customer data)[0].
</code></pre>
[0] Being an ML researcher, I specifically have a horse in this race. The more half assed scam products (e.g. Rabbit, Devin, etc) that get out there, the more the public turns to believing ML is another Silicon Valley hype scam. Hype is (unfortunately) essential and allows for bootstrapping, but the game is to replace the bubble before it pops. The more you put into that bubble the more money comes, but also the more ground you have to make up, and the less time you have to do so. Success is the bubble popping without anyone noticing, not how loud it pops.</div><br/></div></div></div></div><div id="41165964" class="c"><input type="checkbox" id="c-41165964" checked=""/><div class="controls bullet"><span class="by">Onavo</span><span>|</span><a href="#41163349">root</a><span>|</span><a href="#41165633">parent</a><span>|</span><a href="#41168227">prev</a><span>|</span><a href="#41163999">next</a><span>|</span><label class="collapse" for="c-41165964">[-]</label><label class="expand" for="c-41165964">[4 more]</label></div><br/><div class="children"><div class="content">&gt; <i>1) I know one (ONE) person who took multivariate calculus in high school.</i><p>Unless you are specifically dealing with intractable Bayesian integral problems, the multivariate calculus involved in NNs are primarily differentiation, not integration. The fun problems like boundary conditions and Stokes&#x2F;Green that makes up the meat of multivariable calculus  don&#x27;t truly apply when you are dealing with differentiation only. In other words you only need the parts of calc 2&#x2F;3 that can be taught in an afternoon, not the truly difficult parts.<p>&gt; <i>I&#x27;m sure many here recognize the reference[0], but being able to make a model that performs successfully on a test set[1] is not always meaningful. (sic) ...[2] If you want to fight me on this, at least demonstrate to me you have taken an abstract algebra course and understand ideals and rings. Even better if axioms and set theory.</i><p>Doesn&#x27;t matter, if it creates value, it is sufficiently correct for all intents and purposes. Pray tell me how discrete math and abstract algebra has anything to do with day to day ML research. If you want to appeal to physics sure, plenty of Ising models, energy functions, and belief propagation in ML but you have lost all credibility bringing up discrete math.<p>Again those correlation tests you use to fact check your model are primarily linear frequentist models. Most statistics practitioners outside of graduate research will just be plugging formulas, not doing research level proofs.<p>&gt; <i>Just because the simplified view is not mathematically intensive does not mean math isn&#x27;t important nor does it mean there isn&#x27;t extremely complex mathematics under the hood. You&#x27;re only explaining the mathematics in a simple way that is only about the updating process. There&#x27;s a lot more to ML.</i><p>Are you sure? The traditional linear algebra (and similar) models never (or rarely) outperformed neural networks, except perhaps on efficiency, absent hardware acceleration and all other things being equal. A flapping bird wing is beautiful from a bioengineering point of view but the aerospace industry is powered by dumb (mostly) static airfoils. Just because something is elegant doesn&#x27;t mean it solves problems. A scaled up CNN is about as boring a NN can get, yet it beats the pants off all those traditional computer vision algorithms that I am sure contain way more &quot;discrete math and abstract algebra&quot;.<p>That being said, more knowledge is always a good thing, but I am not naive enough to believe that ML research can only be advanced by people with &quot;mathematical maturity&quot;. It&#x27;s still in the highly empirical stage where we experimentation (regardless of whether it&#x27;s guided by mathematical intuition) dominates. I have seen plenty of interesting ML results from folks who don&#x27;t know what ELBOs and KL divergences are.</div><br/><div id="41166559" class="c"><input type="checkbox" id="c-41166559" checked=""/><div class="controls bullet"><span class="by">godelski</span><span>|</span><a href="#41163349">root</a><span>|</span><a href="#41165964">parent</a><span>|</span><a href="#41163999">next</a><span>|</span><label class="collapse" for="c-41166559">[-]</label><label class="expand" for="c-41166559">[3 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  &gt; intractable Bayesian integral problems
</code></pre>
With ML, most of what we are doing is modeling intractable distributions...<p><pre><code>  &gt; the multivariate calculus involved in NNs are primarily differentiation
</code></pre>
Sure, but I&#x27;m not sure what your critique is here. This is confirming my point. Maybe I should have been clearer by adding a line that most people do not take calculus in high school. While it is offered there, these are the advance courses, and I&#x27;d be wary of being so pejorative. I know a large number of great mathematicians, computer scientists, and physicists who did not take calculus in high school. I don&#x27;t think we need to discourage anyone or needlessly make them feel dumb. I&#x27;d rather encourage more to undertake further math education and I believe the lessons learned from calculus are highly beneficial in real world every day usage, without requiring explicit formula writing (as referenced in my prior post).<p>Which as a side note, I&#x27;ve found this is an important point and one of the most difficult lessons to learn to be an effective math teacher: Once you understand something, it often seems obvious and it is easy to forget how much you struggled to get to that point. If you can remember the struggle, you will be a better teacher. I also encourage teaching as revisiting can reveal the holes in your knowledge and often overconfidence (but the problem repeats as you teach a course for a long time). Clearly this is something that Feynman recognized and lead to his famous studying technique.<p><pre><code>  &gt; Doesn&#x27;t matter, if it creates value
</code></pre>
Value is too abstract and I think you should clarify. If you need a mine, digging it with a spoon creates value. But I don&#x27;t understand your argument here and it appears to me that you also don&#x27;t agree since you later discuss traditional (presumably GLMs?) statistics models vs ML. This argument seems to suggest that both create value but one creates _more_ value. And in this sense, yes I agree that it is important to consider what has more value. After all, isn&#x27;t all of this under the broad scope of optimization? ;)<p><pre><code>  &gt; Pray tell me how discrete math and abstract algebra has anything to do with day to day ML research.
</code></pre>
Since we both answered the first part I&#x27;ll address the second. First, I&#x27;m not sure I claimed abstract algebra was necessary, but that&#x27;s a comment about if you were going to argue with me about &quot;math being a language&quot;. So miscommunication. Second off, there&#x27;s quite a lot of research on equivalent networks, gradient analysis, interpretability, and so on that does require knowledge of fields, groups, rings, sets, and I&#x27;ll even include measure theory. Like how you answered the first part, there&#x27;s a fair amount of statistics.<p><pre><code>  &gt; Most statistics practitioners outside of graduate research will just be plugging formulas
</code></pre>
And? I may be misinterpreting, but this argument suggests to me that you believe that this effort was fruitless. But I think you discount that the knowledge gained from this is what enables one to know which tools to use. Again, referencing the prior point in not needing to explicitly write equations. The knowledge gained is still valuable and I believe that through mathematics is the best way we have to teach these lessons in a generalizable manner. And personally I&#x27;d argue that it is common to use the wrong tools due to lack of nuanced understanding and one&#x27;s natural tendency to get lazy (we all do it, including me). So even if a novice could use a flow chart for analysis, I hope we both realize how often the errors will appear. And how these types of errors will __devalue__ the task.<p>I think there is also an issue with how one analyzes value and reward. We&#x27;re in a complicated enough society -- certainly a field -- that it is frequent for costs to be outsourced to others and to time. It is frequent to gain reward immediately or in the short term but have overall negative rewards in the medium to long term. It is unfortunate that these feedback signals degrade (noise) with time, but that is the reality of the world. I can even give day to day examples if you want (as well as calc), but this is long enough.<p><pre><code>  &gt; Are you sure? The traditional linear algebra (and similar) models never (or rarely) outperformed neural networks
</code></pre>
I don&#x27;t know how to address this because I&#x27;m not sure where I made this claim. Though I will say that there are plenty of problems where traditional methods do win out, where xgboost is better, and that computational costs are a factor in real world settings. But it is all about context. There&#x27;s no strictly dominating method. But I just don&#x27;t think I understand your argument because it feels non-sequitur.<p><pre><code>  &gt; A flapping bird wing...  [vs] static airfoils.
</code></pre>
I think this example better clarifies your lack of understanding in areospace engineering rather than your argument. I&#x27;m guessing you&#x27;re making this conclusion due to observation rather than from principles. There is a lot of research that goes into ornithopters, and this is not due to aesthetics. But again, context matters; there is no strictly dominating method.<p>I think miscommunication is happening on this point due to a difference in usage of &quot;elegance.&quot; If we reference MW, I believe you are using it with definition 1c while I&#x27;m using it with 1d. As in, it isn&#x27;t just aesthetics. There&#x27;s good reason nature went down this path instead of another. It&#x27;s the same reason the context matters, because all optimization problems are solved under constraints. Solution spaces are also quite large, and as we&#x27;ve referenced before, in these large intractable spaces, there&#x27;s usually no global optima. This is often even true in highly constrained problems.<p><pre><code>  &gt; more knowledge is always a good thing
</code></pre>
Glad we agree. I hope we all try to continually learn and challenge our own beliefs. I do want to ensure we recognize the parts of our positions that we agree upon and not strictly focus on the differentiation.<p><pre><code>  &gt; ML research can only be advanced by people with &quot;mathematical maturity&quot;
</code></pre>
No such claim was ever made and I will never make such a claim. Nor will I make such a claim about any field. If you think it has, I&#x27;d suggest taking a second to cool off and reread what I wrote with this context in mind. Perhaps we&#x27;ll be in much more agreement then. (specifically what I tell my students and the meaning of the referenced &quot;all models are wrong but some models are useful&quot;.) Misinterpretation has occurred. The fault can be mine, but I&#x27;m lacking the words to adequately clarify so I hope this can do so. I&#x27;m sorry to outsource the work to you, but I did try to revise and found it lacking. I think this will likely be more efficient. I do think this is miscommunication on both sides and I hope we both can try to minimize this.</div><br/><div id="41166623" class="c"><input type="checkbox" id="c-41166623" checked=""/><div class="controls bullet"><span class="by">Onavo</span><span>|</span><a href="#41163349">root</a><span>|</span><a href="#41166559">parent</a><span>|</span><a href="#41163999">next</a><span>|</span><label class="collapse" for="c-41166623">[-]</label><label class="expand" for="c-41166623">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>With ML, most of what we are doing is modeling intractable distributions...</i><p>I am aware and we specifically don&#x27;t <i>directly</i> compute those because they are intractable, hence rendering the need for low level ML practitioners to be familiar with their theoretical properties to be mostly unnecessary. MCMC exists for a reason and modern deep learning contains almost zero direct integration. There are lots of sampling but few integrals.<p>I have seen high schoolers use and implement VAEs without understanding what the <i>reparametrization trick</i> is.<p>&gt; <i>Value is too abstract and I think you should clarify</i><p>The value of LLMs and similar deep learning classifiers&#x2F;generators is self evident. If your research is only good for publishing papers, you should stay in academia. You are in no position to judge or gatekeep ML research.<p>&gt; <i>I think this example better clarifies your lack of understanding in areospace engineering rather than your argument.</i><p>I am a pilot, software engineer, and a machine learning practitioner with plenty of interdisciplinary training in other scientific fields. I assure you I am more than familiar with the basics of fluid dynamics and flight principles. Granny knows how to suck eggs, no need for the lecture.<p>&gt; <i>First, I&#x27;m not sure I claimed abstract algebra was necessary, but that&#x27;s a comment about if you were going to argue with me about &quot;math being a language&quot;</i><p>You claimed that people needed to know rings, groups and set theory to debate you on understanding ML. ̶I̶ ̶t̶h̶i̶n̶k̶ ̶y̶o̶u̶ ̶a̶r̶e̶ ̶t̶h̶e̶ ̶o̶n̶e̶ ̶w̶h̶o̶ ̶n̶e̶e̶d̶s̶ ̶t̶o̶ ̶g̶o̶ ̶b̶a̶c̶k̶ ̶t̶o̶ ̶s̶c̶h̶o̶o̶l̶ ̶a̶n̶d̶ ̶s̶t̶o̶p̶ ̶g̶a̶t̶e̶ ̶k̶e̶e̶p̶i̶n̶g̶.̶ ̶  ̶Y̶o̶u̶ ̶r̶e̶m̶i̶n̶d̶ ̶m̶e̶ ̶o̶f̶ ̶t̶h̶o̶s̶e̶ ̶f̶u̶n̶c̶t̶i̶o̶n̶a̶l̶ ̶p̶r̶o̶g̶r̶a̶m̶m̶e̶r̶s̶ ̶w̶h̶o̶ ̶w̶o̶u̶l̶d̶ ̶r̶e̶w̶r̶i̶t̶e̶ ̶n̶e̶u̶r̶a̶l̶ ̶n̶e̶t̶w̶o̶r̶k̶ ̶l̶i̶b̶r̶a̶r̶i̶e̶s̶ ̶i̶n̶ ̶H̶a̶s̶k̶e̶l̶l̶ ̶b̶e̶l̶i̶e̶v̶i̶n̶g̶ ̶c̶a̶t̶e̶g̶o̶r̶y̶ ̶t̶h̶e̶o̶r̶y̶ ̶w̶o̶u̶l̶d̶ ̶u̶n̶l̶o̶c̶k̶ ̶s̶o̶m̶e̶ ̶m̶a̶g̶i̶c̶ ̶i̶n̶s̶i̶g̶h̶t̶ ̶t̶h̶a̶t̶ ̶w̶o̶u̶l̶d̶ ̶l̶e̶a̶d̶ ̶t̶h̶e̶m̶ ̶t̶o̶w̶a̶r̶d̶s̶ ̶A̶G̶I̶.̶<p>̶I̶t̶ ̶m̶u̶s̶t̶ ̶b̶e̶ ̶n̶i̶c̶e̶ ̶u̶p̶ ̶t̶h̶e̶r̶e̶ ̶i̶n̶ ̶t̶h̶e̶ ̶i̶v̶o̶r̶y̶ ̶t̶o̶w̶e̶r̶ ̶o̶f̶ ̶a̶c̶a̶d̶e̶m̶i̶a̶.̶ I pity your students. Those who teach has a duty to encourage value creation and seeking out knowledge for its own sake, not constantly dangling a carrot in front of the student like leading a donkey. Don&#x27;t gatekeep.<p>&gt; <i>I don&#x27;t know how to address this because I&#x27;m not sure where I made this claim.</i><p>I am referring specifically to:
<i>I&#x27;m sure many here recognize the reference[0], but being able to make a model that performs successfully on a test set[1] is not always meaningful. For example, about a year ago I was working a very big tech firm and increased their model&#x27;s capacity on customer data by over 200% with a model that performed worse on their &quot;test set&quot;. No additional data was used, nor did I make any changes to the architecture. Figure that out without math. (note, I was able to predict poor generalization performance PRIOR to my changes and accurately predict my model&#x27;s significantly higher generalization performance)</i>.<p>̶T̶h̶e̶r̶e̶ ̶a̶r̶e̶ ̶m̶a̶n̶y̶ ̶w̶a̶y̶s̶ ̶t̶o̶ ̶t̶e̶s̶t̶ ̶c̶a̶u̶s̶a̶l̶i̶t̶y̶.̶ ̶T̶h̶e̶ ̶d̶a̶t̶a̶ ̶s̶c̶i̶e̶n̶c̶e̶&#x2F;̶s̶t̶a̶t̶i̶s̶t̶i̶c̶ ̶w̶a̶y̶s̶ ̶a̶r̶e̶ ̶S̶p̶e̶a̶r̶m̶a̶n̶&#x2F;̶P̶e̶a̶r̶s̶o̶n̶ ̶r̶a̶n̶k̶s̶ ̶a̶n̶d̶ ̶t̶ ̶t̶e̶s̶t̶s̶.̶ ̶T̶h̶o̶s̶e̶ ̶a̶r̶e̶ ̶g̶e̶n̶e̶r̶a̶l̶l̶y̶ ̶l̶i̶n̶e̶a̶r̶.̶
̶
̶h̶t̶t̶p̶s̶:̶&#x2F;̶&#x2F;̶l̶i̶n̶d̶e̶l̶o̶e̶v̶.̶g̶i̶t̶h̶u̶b̶.̶i̶o̶&#x2F;̶t̶e̶s̶t̶s̶-̶a̶s̶-̶l̶i̶n̶e̶a̶r̶&#x2F;̶
̶
̶A̶l̶t̶e̶r̶n̶a̶t̶i̶v̶e̶l̶y̶ ̶t̶h̶e̶r̶e̶ ̶a̶r̶e̶ ̶M̶L̶ ̶m̶e̶t̶h̶o̶d̶s̶ ̶l̶i̶k̶e̶ ̶g̶r̶a̶p̶h̶i̶c̶a̶l̶ ̶m̶o̶d̶e̶l̶s̶ ̶b̶u̶t̶ ̶I̶ ̶d̶o̶n̶&#x27;̶t̶ ̶t̶h̶i̶n̶k̶ ̶t̶h̶a̶t̶&#x27;̶s̶ ̶w̶h̶a̶t̶ ̶y̶o̶u̶ ̶a̶r̶e̶ ̶r̶e̶f̶e̶r̶r̶i̶n̶g̶ ̶t̶o̶ ̶h̶e̶r̶e̶.̶ ̶F̶o̶r̶ ̶d̶e̶e̶p̶ ̶l̶e̶a̶r̶n̶i̶n̶g̶ ̶s̶p̶e̶c̶i̶f̶i̶c̶a̶l̶l̶y̶ ̶t̶h̶e̶r̶e̶ ̶a̶r̶e̶ ̶t̶r̶i̶c̶k̶s̶ ̶w̶i̶t̶h̶ ̶s̶a̶m̶p̶l̶i̶n̶g̶ ̶t̶h̶a̶t̶ ̶y̶o̶u̶ ̶c̶a̶n̶ ̶u̶s̶e̶ ̶t̶o̶ ̶e̶y̶e̶b̶a̶l̶l̶ ̶t̶h̶i̶n̶g̶s̶,̶ ̶g̶u̶i̶d̶e̶d̶ ̶b̶y̶ ̶i̶n̶t̶u̶i̶t̶i̶o̶n̶.̶
̶
̶H̶e̶r̶e̶&#x27;̶s̶ ̶a̶ ̶g̶o̶o̶d̶ ̶r̶e̶f̶e̶r̶e̶n̶c̶e̶ ̶o̶f̶ ̶w̶h̶a̶t̶ ̶I̶ ̶m̶e̶a̶n̶:̶ ̶
̶h̶t̶t̶p̶s̶:̶&#x2F;̶&#x2F;̶m̶a̶t̶h̶e̶u̶s̶f̶a̶c̶u̶r̶e̶.̶g̶i̶t̶h̶u̶b̶.̶i̶o̶&#x2F;̶p̶y̶t̶h̶o̶n̶-̶c̶a̶u̶s̶a̶l̶i̶t̶y̶-̶h̶a̶n̶d̶b̶o̶o̶k̶&#x2F;̶l̶a̶n̶d̶i̶n̶g̶-̶p̶a̶g̶e̶.̶h̶t̶m̶l̶
̶h̶t̶t̶p̶s̶:̶&#x2F;̶&#x2F;̶a̶r̶x̶i̶v̶.̶o̶r̶g̶&#x2F;̶a̶b̶s̶&#x2F;̶2̶3̶0̶5̶.̶1̶8̶7̶9̶3̶
̶
̶A̶g̶a̶i̶n̶ ̶m̶o̶r̶e̶ ̶o̶f̶ ̶t̶h̶e̶s̶e̶ ̶a̶r̶e̶ ̶e̶m̶p̶i̶r̶i̶c̶a̶l̶ ̶c̶o̶m̶m̶o̶n̶ ̶s̶e̶n̶s̶e̶.̶
No need for mathematical maturity or any grasp of discrete mathematics.<p>&gt; <i>Maybe I should have been clearer by adding a line that most people do not take calculus in high school. While it is offered there, these are the advance courses, and I&#x27;d be wary of being so pejorative. I know a large number of great mathematicians, computer scientists, and physicists who did not take calculus in high school. I don&#x27;t think we need to discourage anyone or needlessly make them feel dumb. I&#x27;d rather encourage more to undertake further math education and I believe the lessons learned from calculus are highly beneficial in real world every day usage, without requiring explicit formula writing (as referenced in my prior post).</i><p>Okay fair you have a point. I forgot not all schools offer AP classes and advanced mathematics.<p>I believe we both share the view that education is important, but disagree on how much mathematical understanding is truly necessary to apply or advance ML. I suppose we will have to agree to disagree.</div><br/><div id="41167700" class="c"><input type="checkbox" id="c-41167700" checked=""/><div class="controls bullet"><span class="by">godelski</span><span>|</span><a href="#41163349">root</a><span>|</span><a href="#41166623">parent</a><span>|</span><a href="#41163999">next</a><span>|</span><label class="collapse" for="c-41167700">[-]</label><label class="expand" for="c-41167700">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  &gt; but disagree on how much mathematical understanding is truly necessary to apply or advance ML
</code></pre>
We do not disagree on this point. I have been explicitly clear about this and stated it several times. And this is the last instance I will do so.<p>We do disagree on one thing, but it isn&#x27;t about math, science, or ML. If you would like to have a real conversation, I would be happy to. But it is required that you respond in good faith and more carefully read what I&#x27;ve written. I expect you to respect my time as much as I&#x27;ve respected yours.<p>You should be prod of your credentials and the work you&#x27;ve accomplished. I intimately understand the hard work it takes to achieve each one of those things, but I don&#x27;t want to have a pissing contest or try to diminish yours. You should be proud of them. But if you want to take your anger out on someone, I suggest going elsewhere. HN is not the place for that and I personally will have none of it.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41163999" class="c"><input type="checkbox" id="c-41163999" checked=""/><div class="controls bullet"><span class="by">Mc91</span><span>|</span><a href="#41163349">root</a><span>|</span><a href="#41163432">parent</a><span>|</span><a href="#41164202">prev</a><span>|</span><a href="#41166656">next</a><span>|</span><label class="collapse" for="c-41163999">[-]</label><label class="expand" for="c-41163999">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not deep in the field at all, I did about four hours of Andrew Ng&#x27;s deep learning course, and have played around a little bit with Pytorch and Python (although more to install LLMs and Stable Diffusion than to do Pytorch directly, although I did that a little too).  I also did a little more reading and playing with it all, but not that much.<p>Do I understand the Python?  Somewhat.  I know a relu is a rectified linear unit, which is a type of activation function.  I have seen einsum before but forget what it is.<p>For the classical diagram I know what the nodes, edges and weights are.  I have some idea what the formulas do, but not totally.<p>I&#x27;m unfamiliar with tensor diagrams.<p>So I have very little knowledge of this field, and I have a decent grasp of some of what it means, a vague grasp on other parts, and tensor diagrams I have little to no familiarity with.</div><br/></div></div><div id="41166656" class="c"><input type="checkbox" id="c-41166656" checked=""/><div class="controls bullet"><span class="by">canjobear</span><span>|</span><a href="#41163349">root</a><span>|</span><a href="#41163432">parent</a><span>|</span><a href="#41163999">prev</a><span>|</span><a href="#41164860">next</a><span>|</span><label class="collapse" for="c-41166656">[-]</label><label class="expand" for="c-41166656">[1 more]</label></div><br/><div class="children"><div class="content">Not hard to understand. The visualization is more or less the computation graph that PyTorch builds up. And the einsum code is even clearer.<p>There’s definitely a practice effect though. I know people who aren’t used to it will have their eyes glaze over when they read einsum notation.</div><br/></div></div><div id="41164860" class="c"><input type="checkbox" id="c-41164860" checked=""/><div class="controls bullet"><span class="by">danielmarkbruce</span><span>|</span><a href="#41163349">root</a><span>|</span><a href="#41163432">parent</a><span>|</span><a href="#41166656">prev</a><span>|</span><a href="#41163915">next</a><span>|</span><label class="collapse" for="c-41164860">[-]</label><label class="expand" for="c-41164860">[1 more]</label></div><br/><div class="children"><div class="content">Yes. But it&#x27;s not difficult math in 99% of cases, it&#x27;s just notation. It may as well be written in Japanese.</div><br/></div></div></div></div><div id="41163915" class="c"><input type="checkbox" id="c-41163915" checked=""/><div class="controls bullet"><span class="by">kherud</span><span>|</span><a href="#41163349">parent</a><span>|</span><a href="#41163432">prev</a><span>|</span><a href="#41168702">next</a><span>|</span><label class="collapse" for="c-41163915">[-]</label><label class="expand" for="c-41163915">[3 more]</label></div><br/><div class="children"><div class="content">Interesting, thanks for sharing! Do you have an explanation or idea why compilation slows some architectures down?</div><br/><div id="41164073" class="c"><input type="checkbox" id="c-41164073" checked=""/><div class="controls bullet"><span class="by">thomasahle</span><span>|</span><a href="#41163349">root</a><span>|</span><a href="#41163915">parent</a><span>|</span><a href="#41168702">next</a><span>|</span><label class="collapse" for="c-41164073">[-]</label><label class="expand" for="c-41164073">[2 more]</label></div><br/><div class="children"><div class="content">Consider the function:<p><pre><code>    relu(np.outer(x, y)) @ z.
</code></pre>
This takes n^2 time and memory in the naive implementation.
But clearly, the memory could be reduced to O(n) with the right &quot;fusing&quot; of the operations.<p>KANs are similar. This is the forward code for KANs:<p><pre><code>   x = einsum(&quot;bi,oik-&gt;boik&quot;, x, w1) + b1
   x = einsum(&quot;boik,oik-&gt;bo&quot;, relu(x), w2) + b2
</code></pre>
This is the forward code for a Expansion &#x2F; Inverse Bottleneck MLPs:<p><pre><code>   x = einsum(&quot;bi,iok-&gt;bok&quot;, x, w1) + b1
   x = einsum(&quot;bok,okp-&gt;bp&quot;, relu(x), w2) + b2
</code></pre>
Both take nd^2 time, but Inverse Bottleneck only takes nd memory.
For KANs to match the memory usage, the two einsums must be fused.<p>It&#x27;s actually quite similar to flash-attention.</div><br/><div id="41165664" class="c"><input type="checkbox" id="c-41165664" checked=""/><div class="controls bullet"><span class="by">godelski</span><span>|</span><a href="#41163349">root</a><span>|</span><a href="#41164073">parent</a><span>|</span><a href="#41168702">next</a><span>|</span><label class="collapse" for="c-41165664">[-]</label><label class="expand" for="c-41165664">[1 more]</label></div><br/><div class="children"><div class="content">Which is to say, a big part is lack of optimization.<p>Personally, I think this is fine in context. Context that it is a new formulation and the difficulty and non-obviousness of optimization. Shouldn&#x27;t be expected that every researcher can recognize and solve all optimization problems.</div><br/></div></div></div></div></div></div></div></div><div id="41168702" class="c"><input type="checkbox" id="c-41168702" checked=""/><div class="controls bullet"><span class="by">noduerme</span><span>|</span><a href="#41163349">prev</a><span>|</span><a href="#41168712">next</a><span>|</span><label class="collapse" for="c-41168702">[-]</label><label class="expand" for="c-41168702">[1 more]</label></div><br/><div class="children"><div class="content">This sounds a bit like allowing each neuron&#x27;s function to perform its own symbolic regression? But at predicting physical phenomena you might get better performance per cycle from just an A-Life swarm of symbolic regression cells competing than trying to harness them as a single organism. Why do you need a NN to model what&#x27;s basically a deterministic result set, and why is that a good test?</div><br/></div></div><div id="41163259" class="c"><input type="checkbox" id="c-41163259" checked=""/><div class="controls bullet"><span class="by">yorwba</span><span>|</span><a href="#41168712">prev</a><span>|</span><a href="#41168659">next</a><span>|</span><label class="collapse" for="c-41163259">[-]</label><label class="expand" for="c-41163259">[1 more]</label></div><br/><div class="children"><div class="content">Previous discussion of Kolmogorov-Arnold networks: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40219205">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40219205</a></div><br/></div></div><div id="41168659" class="c"><input type="checkbox" id="c-41168659" checked=""/><div class="controls bullet"><span class="by">martingoodson</span><span>|</span><a href="#41163259">prev</a><span>|</span><a href="#41163006">next</a><span>|</span><label class="collapse" for="c-41168659">[-]</label><label class="expand" for="c-41168659">[1 more]</label></div><br/><div class="children"><div class="content">We hosted Ziming Liu at the London Machine Learning Meetup a few weeks ago. He gave a great talk on this fascinating work.<p>Here&#x27;s the recording <a href="https:&#x2F;&#x2F;youtu.be&#x2F;FYYZZVV5vlY?si=ReoygVJMgY9oje3p" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;FYYZZVV5vlY?si=ReoygVJMgY9oje3p</a></div><br/></div></div><div id="41163006" class="c"><input type="checkbox" id="c-41163006" checked=""/><div class="controls bullet"><span class="by">smusamashah</span><span>|</span><a href="#41168659">prev</a><span>|</span><a href="#41165814">next</a><span>|</span><label class="collapse" for="c-41163006">[-]</label><label class="expand" for="c-41163006">[14 more]</label></div><br/><div class="children"><div class="content">&gt; One downside of KANs is that they take longer per parameter to train—in part because they can’t take advantage of GPUs. But they need fewer parameters. Liu notes that even if KANs don’t replace giant CNNs and transformers for processing images and language, training time won’t be an issue at the smaller scale of many physics problems.<p>They don&#x27;t even say that it might be possible to take advantage of GPUs in future. Reads like a fundamental problem with these.</div><br/><div id="41163270" class="c"><input type="checkbox" id="c-41163270" checked=""/><div class="controls bullet"><span class="by">johnsutor</span><span>|</span><a href="#41163006">parent</a><span>|</span><a href="#41163055">next</a><span>|</span><label class="collapse" for="c-41163270">[-]</label><label class="expand" for="c-41163270">[1 more]</label></div><br/><div class="children"><div class="content">From the KAN repo itself, it appears they already have GPU support <a href="https:&#x2F;&#x2F;github.com&#x2F;KindXiaoming&#x2F;pykan&#x2F;blob&#x2F;master&#x2F;tutorials&#x2F;API_10_device.ipynb">https:&#x2F;&#x2F;github.com&#x2F;KindXiaoming&#x2F;pykan&#x2F;blob&#x2F;master&#x2F;tutorials&#x2F;...</a></div><br/></div></div><div id="41163055" class="c"><input type="checkbox" id="c-41163055" checked=""/><div class="controls bullet"><span class="by">scotty79</span><span>|</span><a href="#41163006">parent</a><span>|</span><a href="#41163270">prev</a><span>|</span><a href="#41163417">next</a><span>|</span><label class="collapse" for="c-41163055">[-]</label><label class="expand" for="c-41163055">[11 more]</label></div><br/><div class="children"><div class="content">I wonder what&#x27;s the issue ... GPUs can do very complex stuff</div><br/><div id="41163273" class="c"><input type="checkbox" id="c-41163273" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#41163006">root</a><span>|</span><a href="#41163055">parent</a><span>|</span><a href="#41163195">next</a><span>|</span><label class="collapse" for="c-41163273">[-]</label><label class="expand" for="c-41163273">[6 more]</label></div><br/><div class="children"><div class="content">A usual problem is that GPUs don&#x27;t branch on instructions efficiently. A next most likely problem is that they don&#x27;t branch on data efficiently. Ideas fundamentally requiring the former or the latter are hard to port efficiently.<p>A simple example of something hard to port to a GPU is a deep (24 lvls) binary tree with large leaf sizes (4kb). Particular trees can be optimized further, particular operations on trees might have further optimizations, and trees with nicer dimensionality might have tricks available, but solving that problem in the abstract is 32x slower on a GPU that &quot;good&quot; GPU problems. That&#x27;s not a death knell, but it cuts down substantially the constraints which would make a GPU a better fit than a CPU.<p>Instruction branching is much worse, when required. Runtime is exponential.<p>As far as KANs are concerned, the problem is more with data branching. Each spline computation requires its own set of data and is only used once. The math being done on the aggregate computations is non-negligible, but fast relative to the memory loads. You quickly enter a regime where (1) you&#x27;re bottlenecked on RAM bandwidth, and (2) for a given RAM load you can&#x27;t efficiently use the warp allocated to it.<p>You can tweak the parameters a bit to alleviate that problem (smaller splines allow you to load and parallelize a few at once, larger ones allow you to do more work at once), but it&#x27;s a big engineering challenge to fully utilize a GPU for that architecture. Your best bets are (1) observing something clever allowing you to represent the same result with different computations, and (2) a related idea, construct a different KAN-inspired algorithm with similar expressivity and more amenable to acceleration. My gut says (2) is more likely, but we&#x27;ll see.<p>More succinctly: The algorithm as written is not a good fit for the GPU primitives we have. It might be possible to bridge that gap, but that isn&#x27;t guaranteed.</div><br/><div id="41163359" class="c"><input type="checkbox" id="c-41163359" checked=""/><div class="controls bullet"><span class="by">earthnail</span><span>|</span><a href="#41163006">root</a><span>|</span><a href="#41163273">parent</a><span>|</span><a href="#41164484">next</a><span>|</span><label class="collapse" for="c-41163359">[-]</label><label class="expand" for="c-41163359">[2 more]</label></div><br/><div class="children"><div class="content">What about cards with higher memory bandwidth, like Groq’s LPUs? Would that help with data branching?</div><br/><div id="41165824" class="c"><input type="checkbox" id="c-41165824" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#41163006">root</a><span>|</span><a href="#41163359">parent</a><span>|</span><a href="#41164484">next</a><span>|</span><label class="collapse" for="c-41165824">[-]</label><label class="expand" for="c-41165824">[1 more]</label></div><br/><div class="children"><div class="content">Data branching in general, no (pulling from 32 places is still 32x as expensive in that architecture, but you might be able to load bigger chunks in each place). For a KAN, a bit (it shifts the constants involved when I was talking about smaller vs bigger splines above -- sparsity and dropout will tend to make the GPU tend toward that worst-case though). You still have the problem that you&#x27;re heavily underutilizing the GPU&#x27;s compute.</div><br/></div></div></div></div><div id="41164484" class="c"><input type="checkbox" id="c-41164484" checked=""/><div class="controls bullet"><span class="by">scotty79</span><span>|</span><a href="#41163006">root</a><span>|</span><a href="#41163273">parent</a><span>|</span><a href="#41163359">prev</a><span>|</span><a href="#41163195">next</a><span>|</span><label class="collapse" for="c-41164484">[-]</label><label class="expand" for="c-41164484">[3 more]</label></div><br/><div class="children"><div class="content">What if instead of splines there were Fourier series or something like that? Would that be easier to infer and learn on GPU if it was somehow teachable?<p>EDIT:
FourierKAN exists <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;html&#x2F;2406.01034v1" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;html&#x2F;2406.01034v1</a></div><br/><div id="41166740" class="c"><input type="checkbox" id="c-41166740" checked=""/><div class="controls bullet"><span class="by">jbay808</span><span>|</span><a href="#41163006">root</a><span>|</span><a href="#41164484">parent</a><span>|</span><a href="#41165873">next</a><span>|</span><label class="collapse" for="c-41166740">[-]</label><label class="expand" for="c-41166740">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d expect Chebyshev polynomials to be much faster and easier to work with than splines, certainly, and probably Fourier series as well. (Especially if there aren&#x27;t trig instructions in hardware, because then each sine or cosine is itself a chebyshev polynomial to evaluate).</div><br/></div></div><div id="41165873" class="c"><input type="checkbox" id="c-41165873" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#41163006">root</a><span>|</span><a href="#41164484">parent</a><span>|</span><a href="#41166740">prev</a><span>|</span><a href="#41163195">next</a><span>|</span><label class="collapse" for="c-41165873">[-]</label><label class="expand" for="c-41165873">[1 more]</label></div><br/><div class="children"><div class="content">Fourier subcomponents are definitely teachable in general. I&#x27;d expect that FourierKAN to have similar runtime to a normal KAN, only really benefitting from a GPU on datasets where you get better predictive performance than a normal KAN.</div><br/></div></div></div></div></div></div><div id="41163195" class="c"><input type="checkbox" id="c-41163195" checked=""/><div class="controls bullet"><span class="by">UncleOxidant</span><span>|</span><a href="#41163006">root</a><span>|</span><a href="#41163055">parent</a><span>|</span><a href="#41163273">prev</a><span>|</span><a href="#41163207">next</a><span>|</span><label class="collapse" for="c-41163195">[-]</label><label class="expand" for="c-41163195">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s not a lot of details there, but GPUs tend to not like code with a lot of branching. I&#x27;m guessing that&#x27;s probably the issue.</div><br/></div></div><div id="41163207" class="c"><input type="checkbox" id="c-41163207" checked=""/><div class="controls bullet"><span class="by">MattPalmer1086</span><span>|</span><a href="#41163006">root</a><span>|</span><a href="#41163055">parent</a><span>|</span><a href="#41163195">prev</a><span>|</span><a href="#41163143">next</a><span>|</span><label class="collapse" for="c-41163207">[-]</label><label class="expand" for="c-41163207">[2 more]</label></div><br/><div class="children"><div class="content">I suspect it is because they have different activation functions on each edge, rather than using the same one over lots of data.</div><br/><div id="41163501" class="c"><input type="checkbox" id="c-41163501" checked=""/><div class="controls bullet"><span class="by">XMPPwocky</span><span>|</span><a href="#41163006">root</a><span>|</span><a href="#41163207">parent</a><span>|</span><a href="#41163143">next</a><span>|</span><label class="collapse" for="c-41163501">[-]</label><label class="expand" for="c-41163501">[1 more]</label></div><br/><div class="children"><div class="content">Are the activation functions truly different, or just different parameter values to one underlying function?</div><br/></div></div></div></div><div id="41163143" class="c"><input type="checkbox" id="c-41163143" checked=""/><div class="controls bullet"><span class="by">raidicy</span><span>|</span><a href="#41163006">root</a><span>|</span><a href="#41163055">parent</a><span>|</span><a href="#41163207">prev</a><span>|</span><a href="#41163417">next</a><span>|</span><label class="collapse" for="c-41163143">[-]</label><label class="expand" for="c-41163143">[1 more]</label></div><br/><div class="children"><div class="content">From my limited understanding: No one has written GPU code for it yet.</div><br/></div></div></div></div><div id="41163417" class="c"><input type="checkbox" id="c-41163417" checked=""/><div class="controls bullet"><span class="by">nickpsecurity</span><span>|</span><a href="#41163006">parent</a><span>|</span><a href="#41163055">prev</a><span>|</span><a href="#41165814">next</a><span>|</span><label class="collapse" for="c-41163417">[-]</label><label class="expand" for="c-41163417">[1 more]</label></div><br/><div class="children"><div class="content">I’ve seen neural nets combined with decision trees. There’s a few ways to do such hybrids. One style essentially uses the accurate, GPU-trained networks to push the interpretable networks to higher accuracy.<p>Do any of you think that can be done cost-effectively with KAN’s? Especially using pre-trained, language models like LlaMa-3 to train the interpretable models?</div><br/></div></div></div></div><div id="41165814" class="c"><input type="checkbox" id="c-41165814" checked=""/><div class="controls bullet"><span class="by">asdfman123</span><span>|</span><a href="#41163006">prev</a><span>|</span><a href="#41165387">next</a><span>|</span><label class="collapse" for="c-41165814">[-]</label><label class="expand" for="c-41165814">[4 more]</label></div><br/><div class="children"><div class="content">Can someone ELIF this for me?<p>I understand how neural networks try to reduce their loss function to get the best result. But what&#x27;s actually different about the KANs?</div><br/><div id="41166798" class="c"><input type="checkbox" id="c-41166798" checked=""/><div class="controls bullet"><span class="by">svachalek</span><span>|</span><a href="#41165814">parent</a><span>|</span><a href="#41167531">next</a><span>|</span><label class="collapse" for="c-41166798">[-]</label><label class="expand" for="c-41166798">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not an ML person and am just learning from this article, but I understand a little bit about ML and the key thing I get out of it is the footnote in the diagram.<p>A regular neural network (MLP) has matrices full of floating point numbers that act as weights. A weight is a linear function y=wx, meaning if I plot the input x and output y on cartesian coordinates, it will generate a straight line. Increasing or decreasing the input also increases or decreases the output by consistent amounts. We won&#x27;t have points where increasing the output suddenly has more or less effect than the previous increase, or starts sending the output in the other direction. So we train the network by having it learn multiple layers of these weights and also connecting them with some magic glue functions that are part of the design, not something that is trained up. The end result is the output can have a complex relationship with the input by being passed through all these layers.<p>In contrast, in a KAN rather than weights (acting as linear functions) we let the network learn other kinds of functions. These are nonlinear so it&#x27;s possible that as we increase the input, the output keeps rising in an accelerating fashion, or turns around and starts decreasing. We can learn much more complex relationships between input and output, but lose some of the computational efficiency of the MLP approach (huge matrix operations are what GPUs are built for, while you need a CPU to do arbitrary math).<p>So with the KAN we end up with few but more complex &quot;neurons&quot;, made up of complex functions. And if I understand what they&#x27;re getting at here, the appeal of this is that you can inspect one of those neurons and get a clear formula that describes what it is doing, because all the complexity is distilled into a formula in the neuron. While with an MLP you have to track what is happening through multiple layers of weights and do more work to figure out how it all works.<p>Again I&#x27;m not in the space, but I imagine the functions that come out of a KAN still aren&#x27;t super intuitive formulas that look like something out of Isaac Newton&#x27;s notebooks, they&#x27;re probably full of bizarre constants and unintuitive factors that cancel each other out.</div><br/></div></div><div id="41167531" class="c"><input type="checkbox" id="c-41167531" checked=""/><div class="controls bullet"><span class="by">Lerc</span><span>|</span><a href="#41165814">parent</a><span>|</span><a href="#41166798">prev</a><span>|</span><a href="#41167990">next</a><span>|</span><label class="collapse" for="c-41167531">[-]</label><label class="expand" for="c-41167531">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure if this counts as ELIF but it&#x27;s a gross simplification<p>perceptron layer is<p>output = simple_function( sum(many_inputs*many_weights) + extra_weight_for_bias)<p>a KAN layer is<p>output = sum(fancy_functions(many_inputs))<p>but I could be wrong, it&#x27;s been a day.</div><br/></div></div><div id="41167990" class="c"><input type="checkbox" id="c-41167990" checked=""/><div class="controls bullet"><span class="by">Grimblewald</span><span>|</span><a href="#41165814">parent</a><span>|</span><a href="#41167531">prev</a><span>|</span><a href="#41165387">next</a><span>|</span><label class="collapse" for="c-41167990">[-]</label><label class="expand" for="c-41167990">[1 more]</label></div><br/><div class="children"><div class="content">a kan is, in a way, like a network of networks, each edge representing its own little network of sorts. I could be very wrong, I am still digesting the article myself, but that is my superficial take.</div><br/></div></div></div></div><div id="41165387" class="c"><input type="checkbox" id="c-41165387" checked=""/><div class="controls bullet"><span class="by">xg15</span><span>|</span><a href="#41165814">prev</a><span>|</span><a href="#41163024">next</a><span>|</span><label class="collapse" for="c-41165387">[-]</label><label class="expand" for="c-41165387">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Then they could summarize the entire KAN in an intuitive one-line function (including all the component activation functions), in some cases perfectly reconstructing the physics function that created the dataset.</i><p>The idea of KANs sounds really exciting, but just to nitpick, you could also write any traditional NN as a closed-form &quot;one line&quot; expression - the line will just become very very long. I don&#x27;t see how the expression itself would become less complex if you used splines instead of weights (even if this resulted in less neurons for the same decision boundary).</div><br/><div id="41168043" class="c"><input type="checkbox" id="c-41168043" checked=""/><div class="controls bullet"><span class="by">rsfern</span><span>|</span><a href="#41165387">parent</a><span>|</span><a href="#41163024">next</a><span>|</span><label class="collapse" for="c-41168043">[-]</label><label class="expand" for="c-41168043">[1 more]</label></div><br/><div class="children"><div class="content">In the original KAN paper, they do two things to address this: first they have some sparsity-inducing regularization, and second they have a symbolification step so that you can ideally find a compact symbolic model after learning a sparse computation graph of splines.<p>I guess in principle you could do something similar with MLPs but since MLP representations are sort of delocalized they might be harder to sparsify and symbolify</div><br/></div></div></div></div><div id="41163024" class="c"><input type="checkbox" id="c-41163024" checked=""/><div class="controls bullet"><span class="by">BenoitP</span><span>|</span><a href="#41165387">prev</a><span>|</span><a href="#41163760">next</a><span>|</span><label class="collapse" for="c-41163024">[-]</label><label class="expand" for="c-41163024">[2 more]</label></div><br/><div class="children"><div class="content">I wonder if a set of learned function (can|does) reproduce the truth tables from First Order Logic.<p>I think it&#x27;d be easy to check.<p>----<p>Anyways that&#x27;s great news for differentiability. For now &#x27;if&#x27; conditions expressed in JAX are tricky (at least for me), and are de facto an optimization barrier. If they&#x27;re learnable and already into the network, I&#x27;d say that&#x27;s a great thing.</div><br/><div id="41164728" class="c"><input type="checkbox" id="c-41164728" checked=""/><div class="controls bullet"><span class="by">zeknife</span><span>|</span><a href="#41163024">parent</a><span>|</span><a href="#41163760">next</a><span>|</span><label class="collapse" for="c-41164728">[-]</label><label class="expand" for="c-41164728">[1 more]</label></div><br/><div class="children"><div class="content">It is easy to construct an MLP that implements any basic logic function. But XOR requires at least one hidden layer.</div><br/></div></div></div></div><div id="41163760" class="c"><input type="checkbox" id="c-41163760" checked=""/><div class="controls bullet"><span class="by">jcims</span><span>|</span><a href="#41163024">prev</a><span>|</span><a href="#41164026">next</a><span>|</span><label class="collapse" for="c-41163760">[-]</label><label class="expand" for="c-41163760">[3 more]</label></div><br/><div class="children"><div class="content">I can find descriptions at one level or another (eg RNN vs CNN) but is there a deeper kingdom&#x2F;phylum&#x2F;class type taxonomy of neural network architectures that can help a layman understand how they differ and how they align, ideally with specific references to contemporary ones in use or being researched?<p>I don&#x27;t know why I&#x27;m interested because I&#x27;m not planning to actually do any work in the space, but I always struggle to understand when some new architecture is announced if it&#x27;s a fundamental shift or if it&#x27;s an optimization.</div><br/><div id="41163809" class="c"><input type="checkbox" id="c-41163809" checked=""/><div class="controls bullet"><span class="by">kens</span><span>|</span><a href="#41163760">parent</a><span>|</span><a href="#41164026">next</a><span>|</span><label class="collapse" for="c-41163809">[-]</label><label class="expand" for="c-41163809">[2 more]</label></div><br/><div class="children"><div class="content">You might find &quot;The neural network zoo&quot; helpful; it&#x27;s a chart showing the different types of neural networks, along with a brief discussion of each type: <a href="https:&#x2F;&#x2F;www.asimovinstitute.org&#x2F;neural-network-zoo&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.asimovinstitute.org&#x2F;neural-network-zoo&#x2F;</a></div><br/><div id="41163965" class="c"><input type="checkbox" id="c-41163965" checked=""/><div class="controls bullet"><span class="by">jcims</span><span>|</span><a href="#41163760">root</a><span>|</span><a href="#41163809">parent</a><span>|</span><a href="#41164026">next</a><span>|</span><label class="collapse" for="c-41163965">[-]</label><label class="expand" for="c-41163965">[1 more]</label></div><br/><div class="children"><div class="content">Perfect!!!  Thank you!</div><br/></div></div></div></div></div></div><div id="41164026" class="c"><input type="checkbox" id="c-41164026" checked=""/><div class="controls bullet"><span class="by">zygy</span><span>|</span><a href="#41163760">prev</a><span>|</span><a href="#41163267">next</a><span>|</span><label class="collapse" for="c-41164026">[-]</label><label class="expand" for="c-41164026">[2 more]</label></div><br/><div class="children"><div class="content">Naive question: what&#x27;s the intuition for how this is different from increasing the number of learnable parameters on a regular MLP?</div><br/><div id="41165974" class="c"><input type="checkbox" id="c-41165974" checked=""/><div class="controls bullet"><span class="by">slashdave</span><span>|</span><a href="#41164026">parent</a><span>|</span><a href="#41163267">next</a><span>|</span><label class="collapse" for="c-41165974">[-]</label><label class="expand" for="c-41165974">[1 more]</label></div><br/><div class="children"><div class="content">Orthogonality ensures that each weight has its own, individual importance. In a regular MLP, the weights are naturally correlated.</div><br/></div></div></div></div><div id="41163267" class="c"><input type="checkbox" id="c-41163267" checked=""/><div class="controls bullet"><span class="by">Bluestein</span><span>|</span><a href="#41164026">prev</a><span>|</span><label class="collapse" for="c-41163267">[-]</label><label class="expand" for="c-41163267">[1 more]</label></div><br/><div class="children"><div class="content">(I am wondering if there might not be a perverse incentive <i>not</i> to improve on interpretability for major incumbents ...<p>... given how, what you can &quot;see&quot; (ie. have visibility into) is something that regulatory stakeholders can ask you to exercise control over, or for oversight or information about ...<p>... whereas a &quot;black box&quot; they have trained and control - but few understand  - can perhaps give you &quot;plausible deniability&quot; of the &quot;we don&#x27;t know how it works either&quot; type.-</div><br/></div></div></div></div></div></div></div></body></html>