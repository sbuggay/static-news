<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1687251655311" as="style"/><link rel="stylesheet" href="styles.css?v=1687251655311"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://byorgey.wordpress.com/2023/06/06/dynamic-programming-in-haskell-automatic-memoization/">Dynamic programming in Haskell: automatic memoization</a> <span class="domain">(<a href="https://byorgey.wordpress.com">byorgey.wordpress.com</a>)</span></div><div class="subtext"><span>g0xA52A2A</span> | <span>12 comments</span></div><br/><div><div id="36399082" class="c"><input type="checkbox" id="c-36399082" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#36401083">next</a><span>|</span><label class="collapse" for="c-36399082">[-]</label><label class="expand" for="c-36399082">[7 more]</label></div><br/><div class="children"><div class="content">While this is a cool demo, I don&#x27;t really like it even as a Haskell enthusiast. Anything that relies on compiler&#x27;s eta reduction&#x2F;expansion rules for performance is too subtle for my taste. I&#x27;d personally argue that more explicit code could be clearer.</div><br/><div id="36399836" class="c"><input type="checkbox" id="c-36399836" checked=""/><div class="controls bullet"><span class="by">bojo</span><span>|</span><a href="#36399082">parent</a><span>|</span><a href="#36399120">next</a><span>|</span><label class="collapse" for="c-36399836">[-]</label><label class="expand" for="c-36399836">[4 more]</label></div><br/><div class="children"><div class="content">Eta reduction&#x2F;expansion has nothing to do with performance. It&#x27;s a form of point free programming that allows you to abstract out intermediate variables and use partial application instead.<p><pre><code>    f x = reverse (sort x)
</code></pre>
Becomes:<p><pre><code>    f = reverse . sort
</code></pre>
The compiler reaches the same conclusion either way.<p>Perhaps you are thinking of RULES pragmas? Which honestly you wouldn&#x27;t usually reach for unless you really need to force the compiler to optimize in a particular way that is non-trivial.</div><br/><div id="36399894" class="c"><input type="checkbox" id="c-36399894" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#36399082">root</a><span>|</span><a href="#36399836">parent</a><span>|</span><a href="#36399120">next</a><span>|</span><label class="collapse" for="c-36399894">[-]</label><label class="expand" for="c-36399894">[3 more]</label></div><br/><div class="children"><div class="content">I might have used incorrect terminology but what I meant in my previous comment is that it should be obvious when the right hand side is evaluated.<p>If a function has type declaration `f :: A -&gt; B -&gt; C` you would expect that its body only gets evaluated when two arguments are actually supplied. So evaluating the function itself using `seq` doesn&#x27;t do anything. Nor does partial application of a single argument.<p>To be absolutely clear, the expressions `seq f (putStrLn &quot;hello&quot;)` and `seq (f undefined) (putStrLn &quot;hello&quot;)` should both not evaluate anything and cause the string hello to be printed rather than raising an exception.<p>However you can make it otherwise. That breaks the user&#x27;s intuition about evaluation. Most of the time it&#x27;s not a problem at all; I just personally don&#x27;t like it and prefer to be more explicit.<p>This often occurs in cases where the above hypothetical function `f` requires an intermediate value that&#x27;s expensive to compute but only relies on the first of its two arguments. Then do you evaluate that expensive intermediate with a partial application of a single argument, or do you not? Neither is satisfactory and so this problem is best avoided.<p>In your trivial example `reverse . sort` the compiler will inline the dot operator and make it `\x -&gt; reverse (sort x)` and I have no issue there.</div><br/><div id="36401114" class="c"><input type="checkbox" id="c-36401114" checked=""/><div class="controls bullet"><span class="by">gloria_mundi</span><span>|</span><a href="#36399082">root</a><span>|</span><a href="#36399894">parent</a><span>|</span><a href="#36400982">next</a><span>|</span><label class="collapse" for="c-36401114">[-]</label><label class="expand" for="c-36401114">[1 more]</label></div><br/><div class="children"><div class="content">&gt; To be absolutely clear, the expressions `seq f (putStrLn &quot;hello&quot;)` and `seq (f undefined) (putStrLn &quot;hello&quot;)` should both not evaluate anything and cause the string hello to be printed rather than raising an exception.<p>This does actually work here, because the array is created lazily.<p>&gt; This often occurs in cases where the above hypothetical function `f` requires an intermediate value that&#x27;s expensive to compute but only relies on the first of its two arguments. Then do you evaluate that expensive intermediate with a partial application of a single argument, or do you not? Neither is satisfactory and so this problem is best avoided.<p>Computing the intermediate value with a partial application does not actually take away laziness, it only adds sharing. (At least it can be done this way.)</div><br/></div></div><div id="36400982" class="c"><input type="checkbox" id="c-36400982" checked=""/><div class="controls bullet"><span class="by">quchen</span><span>|</span><a href="#36399082">root</a><span>|</span><a href="#36399894">parent</a><span>|</span><a href="#36401114">prev</a><span>|</span><a href="#36399120">next</a><span>|</span><label class="collapse" for="c-36400982">[-]</label><label class="expand" for="c-36400982">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If a function has type declaration `f :: A -&gt; B -&gt; C` you would expect that its body only gets evaluated when two arguments are actually supplied.<p>That’s not correct, regardless of η expansion. The core of the issue is that this function really takes one argument, regardless of how in practice it is used as if it had two.<p>&gt;  the expressions `seq f (putStrLn &quot;hello&quot;)` and `seq (f undefined) (putStrLn &quot;hello&quot;)` should both not evaluate anything and cause the string hello to be printed rather than raising an exception.<p>That’s not how `seq` works, as per language report. The definition is <i>very</i> simple, and does not take into account any kinds of types (such as treating functions differently). The report demands that `seq ⊥ x = ⊥` [1], so if the first argument is ⊥, you get a crash. Whether `x` is also evaluated in this context is up to the compiler actually, but what certainly cannot happen is that a &quot;hello&quot; is printed, because that would require a non-⊥ value to be passed to the surrounding IO context, but the whole `seq` is ⊥, so that’s not possible.<p>In GHC, seq is essentially a tag that helps the strictness analyzer, and hence the optimizer.<p>There is one subtlety in GHC that makes it not respect η expansion, and that is strictness properties, namely that `seq ⊥ () = ⊥`, but `seq (\x -&gt; ⊥ x) () = ()`, were you referring to that? (In my opinion this is a violation of the Haskell Report.)<p>&gt; This often occurs in cases where the above hypothetical function `f` requires an intermediate value that&#x27;s expensive to compute but only relies on the first of its two arguments.<p>Lookup tables work that way, yes! I’m using this technique for walking a certain distance on a Bezier curve for example (Code at [2], result picture at [3]) Call that academic and I’ll show you the DIN A1 sized CNC machine I control using that logic ;-P<p>[1]: <a href="https:&#x2F;&#x2F;www.haskell.org&#x2F;onlinereport&#x2F;haskell2010&#x2F;haskellch6.html#x13-1260006.2" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.haskell.org&#x2F;onlinereport&#x2F;haskell2010&#x2F;haskellch6....</a>
[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;quchen&#x2F;generative-art&#x2F;blob&#x2F;master&#x2F;src&#x2F;Geometry&#x2F;Bezier.hs#L236">https:&#x2F;&#x2F;github.com&#x2F;quchen&#x2F;generative-art&#x2F;blob&#x2F;master&#x2F;src&#x2F;Geo...</a>
[3]: <a href="https:&#x2F;&#x2F;quchen.github.io&#x2F;generative-art&#x2F;generative-art-0.1.0.0&#x2F;Geometry-Bezier.html#v:bezierSubdivideEquidistant" rel="nofollow noreferrer">https:&#x2F;&#x2F;quchen.github.io&#x2F;generative-art&#x2F;generative-art-0.1.0...</a></div><br/></div></div></div></div></div></div><div id="36399120" class="c"><input type="checkbox" id="c-36399120" checked=""/><div class="controls bullet"><span class="by">lgas</span><span>|</span><a href="#36399082">parent</a><span>|</span><a href="#36399836">prev</a><span>|</span><a href="#36400566">next</a><span>|</span><label class="collapse" for="c-36399120">[-]</label><label class="expand" for="c-36399120">[1 more]</label></div><br/><div class="children"><div class="content">How does it rely on the compiler&#x27;s eta reduction&#x2F;expansion rules?  It doesn&#x27;t seem to from my (decidedly intermediate) point of view.</div><br/></div></div><div id="36400566" class="c"><input type="checkbox" id="c-36400566" checked=""/><div class="controls bullet"><span class="by">throwaway81523</span><span>|</span><a href="#36399082">parent</a><span>|</span><a href="#36399120">prev</a><span>|</span><a href="#36401083">next</a><span>|</span><label class="collapse" for="c-36400566">[-]</label><label class="expand" for="c-36400566">[1 more]</label></div><br/><div class="children"><div class="content">Maybe you mean using lazy evaluation as a memoization hack?  That is a well known trick in Haskell though I agree it is in some ways cringy, relying on the evaluation strategy like that.  But there are some Hackage packages that make it fairly convenient to use.  I did a naive implementation myself and benchmarked it against an explicit STRef as a cache cell.  I don&#x27;t remember the result but it wasn&#x27;t a huge (OOM+) difference iirc.  Rather than using an array as the memo cache (which means you must know its size in advance), it&#x27;s nicer to use an infinite branching tree.</div><br/></div></div></div></div><div id="36401083" class="c"><input type="checkbox" id="c-36401083" checked=""/><div class="controls bullet"><span class="by">moomin</span><span>|</span><a href="#36399082">prev</a><span>|</span><a href="#36400503">next</a><span>|</span><label class="collapse" for="c-36401083">[-]</label><label class="expand" for="c-36401083">[1 more]</label></div><br/><div class="children"><div class="content">No disrespect to the dude that I learned Haskell from, but a) he doesn’t achieve his original goal and b) the goal is much less practically useful than he implies.<p>In practice an awful lot of the functions you want to memoize a) involve continuations and b) want some way of evicting things from the cache.<p>Haskell has no end of cute tricks for doing deterministic functions, it’s just that deterministic functions are programming’s easy mode.</div><br/></div></div><div id="36400503" class="c"><input type="checkbox" id="c-36400503" checked=""/><div class="controls bullet"><span class="by">lewtds</span><span>|</span><a href="#36401083">prev</a><span>|</span><a href="#36400395">next</a><span>|</span><label class="collapse" for="c-36400503">[-]</label><label class="expand" for="c-36400503">[1 more]</label></div><br/><div class="children"><div class="content">Certain logic programming languages like SWI-Prolog [0] and Picat [1] have this built-in.<p>[0]: <a href="https:&#x2F;&#x2F;www.swi-prolog.org&#x2F;pldoc&#x2F;man?section=tabling-memoize" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.swi-prolog.org&#x2F;pldoc&#x2F;man?section=tabling-memoize</a>
[1]: <a href="http:&#x2F;&#x2F;retina.inf.ufsc.br&#x2F;picat_guide&#x2F;#x1-210001.5" rel="nofollow noreferrer">http:&#x2F;&#x2F;retina.inf.ufsc.br&#x2F;picat_guide&#x2F;#x1-210001.5</a></div><br/></div></div><div id="36400395" class="c"><input type="checkbox" id="c-36400395" checked=""/><div class="controls bullet"><span class="by">moi2388</span><span>|</span><a href="#36400503">prev</a><span>|</span><a href="#36400144">next</a><span>|</span><label class="collapse" for="c-36400395">[-]</label><label class="expand" for="c-36400395">[1 more]</label></div><br/><div class="children"><div class="content">This is great. I was just thinking about this last week.</div><br/></div></div></div></div></div></div></div></body></html>