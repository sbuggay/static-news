<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1687942852557" as="style"/><link rel="stylesheet" href="styles.css?v=1687942852557"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.youtube.com/watch?v=xFKFoGiGlXQ">Finding the best sine function for Nintendo 64 [video]</a> <span class="domain">(<a href="https://www.youtube.com">www.youtube.com</a>)</span></div><div class="subtext"><span>codetrotter</span> | <span>25 comments</span></div><br/><div><div id="36502016" class="c"><input type="checkbox" id="c-36502016" checked=""/><div class="controls bullet"><span class="by">abnercoimbre</span><span>|</span><a href="#36499775">next</a><span>|</span><label class="collapse" for="c-36502016">[-]</label><label class="expand" for="c-36502016">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s almost criminal Kaze isn&#x27;t really welcome at most tech conferences because he plays fire with Nintendo&#x27;s IP.<p>A huge audience is missing out learning to do these things themselves, so my plug is we&#x27;re running an indie conference [0] with Kaze as the featured speaker.<p>We should follow in his footsteps.<p>[0] <a href="https:&#x2F;&#x2F;handmadecities.com&#x2F;boston" rel="nofollow noreferrer">https:&#x2F;&#x2F;handmadecities.com&#x2F;boston</a></div><br/><div id="36503617" class="c"><input type="checkbox" id="c-36503617" checked=""/><div class="controls bullet"><span class="by">psychphysic</span><span>|</span><a href="#36502016">parent</a><span>|</span><a href="#36499775">next</a><span>|</span><label class="collapse" for="c-36503617">[-]</label><label class="expand" for="c-36503617">[1 more]</label></div><br/><div class="children"><div class="content">I find him a bit abrasive even though I enjoy his videos (and actually submitted this a couple days ago).<p>It&#x27;s alot of cool work, but the way he presents it to laymen is kind of annoying. Even if he had never heard of data orientated design in the original video series (where he claims to not know what its called when you organise data to improve throughput) he should by now because clearly he does huge amounts of research. (Case in point at 9:30[0] he talks about localised memory patterns as though he&#x27;s the first to come up with it).<p>Again, love his work, watch every video and even submit to HN because I think others would. But that doesn&#x27;t mean he&#x27;s not very annoying.<p>[0] <a href="https:&#x2F;&#x2F;youtu.be&#x2F;xFKFoGiGlXQ?t=570" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;xFKFoGiGlXQ?t=570</a></div><br/></div></div></div></div><div id="36499775" class="c"><input type="checkbox" id="c-36499775" checked=""/><div class="controls bullet"><span class="by">accrual</span><span>|</span><a href="#36502016">prev</a><span>|</span><a href="#36499687">next</a><span>|</span><label class="collapse" for="c-36499775">[-]</label><label class="expand" for="c-36499775">[12 more]</label></div><br/><div class="children"><div class="content">Now that SM64 has been fully reversed and can be compiled back to a bit-perfect ROM, I wonder if there would be any merit in replacing the default lookup table with Kaze&#x27;s new function(s):<p>- 200 microseconds saved<p>- 33333 microseconds per frame -&gt; 0.6% of time saved<p>- 1KB of RAM saved<p>- Looked really cool doing it (Kaze&#x27;s words &amp; I agree)</div><br/><div id="36500897" class="c"><input type="checkbox" id="c-36500897" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#36499775">parent</a><span>|</span><a href="#36500378">next</a><span>|</span><label class="collapse" for="c-36500897">[-]</label><label class="expand" for="c-36500897">[1 more]</label></div><br/><div class="children"><div class="content">Kaze has already done so, and picking the low-hanging fruit results in much greater improvements than the optimizations shown here (which frees up less than one millisecond per frame). Here&#x27;s the previous video with explanations and video demonstration of their improvements: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=t_rzYnXEQlE">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=t_rzYnXEQlE</a></div><br/></div></div><div id="36500378" class="c"><input type="checkbox" id="c-36500378" checked=""/><div class="controls bullet"><span class="by">22c</span><span>|</span><a href="#36499775">parent</a><span>|</span><a href="#36500897">prev</a><span>|</span><a href="#36500140">next</a><span>|</span><label class="collapse" for="c-36500378">[-]</label><label class="expand" for="c-36500378">[1 more]</label></div><br/><div class="children"><div class="content">Kaze has essentially been doing that for his own ROM hack, not just this improvement but a bunch of others that have enabled the game to run at a consistent 60fps.<p>I believe he&#x27;s mainly working on the ROM hack at the moment but has talked about releasing a patch to backport all the 100% SM64 compatible fixes to the main game.</div><br/></div></div><div id="36500140" class="c"><input type="checkbox" id="c-36500140" checked=""/><div class="controls bullet"><span class="by">dietrichepp</span><span>|</span><a href="#36499775">parent</a><span>|</span><a href="#36500378">prev</a><span>|</span><a href="#36500344">next</a><span>|</span><label class="collapse" for="c-36500140">[-]</label><label class="expand" for="c-36500140">[8 more]</label></div><br/><div class="children"><div class="content">The question here is whether the new, optimized SM64 implementation is CPU-bound in the first place. Games on the N64 are often limited by memory bandwidth, which is taken up by rasterization, and SM64 was something of a special case—compiled with optimizations turned off due to GCC bugs. After recompiling with optimizations enabled, and maybe after swapping in newer versions of the RSP microcode, my guess is that further improvements to CPU efficiency would have very limited returns.</div><br/><div id="36501079" class="c"><input type="checkbox" id="c-36501079" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#36499775">root</a><span>|</span><a href="#36500140">parent</a><span>|</span><a href="#36500322">next</a><span>|</span><label class="collapse" for="c-36501079">[-]</label><label class="expand" for="c-36501079">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Games on the N64 are often limited by memory bandwidth, which is taken up by rasterization<p>So a lot of that is overstated, IMO.<p>The N64 was in most cases the first system with a modern memory hierarchy game developers had come across.  From my experiments, rdram is dozens of cycles away from the CPU at least, so it&#x27;s pretty easy to be memory bound without coming close to saturating the little more than ~200MB&#x2F;sec memory bandwidth the system is capable of sustaining.  Remember too the context of the mid 90s, where the previous Nintendo console had single cycle access to main memory[0].  So you&#x27;d see crazy stuff like loop unrolling into 16KB of straight code with no branches despite the CPU only having a 16KB instruction cache, guaranteeing that you just flushed everything else.<p>Similarly the GPU seemed really hampered by it&#x27;s small FIFO at basically the ROP stage which meant that the RMW of both color and z buffers meant a lot of pipeline stalls.  I think a lot of the benefit of switching to z sort late in the system&#x27;s cycle had less to do with overall memory bandwidth, but instead the fact that you don&#x27;t have to wait on memory just to then blit out the pixel.  There&#x27;s no z to check against, so you know that yes, as soon as the pixel hits the ROP stage, the GPU can just write it to memory (assuming alpha isn&#x27;t involved).<p>And that&#x27;s not to shit of the devs in question; it wasn&#x27;t until probably the last half of the PS2 era that the industry as a whole really internalized how to approach true long tail memory hierarchies.  I certainly hadn&#x27;t despite being able to regurgitate the textbook definitions involved.<p>I guess what I&#x27;m saying: hey demo scene coders, there&#x27;s a bunch of untapped power in this system with weird hangups.  : )<p>[0] Yes, the memory system of the SNES is hard to talk about in broad strokes like this with FastROM&#x2F;SlowROM, wait states on cart mem accesses, etc, but &#x27;single cycle&#x27; is the right order of magnitude for this discussion.</div><br/><div id="36501496" class="c"><input type="checkbox" id="c-36501496" checked=""/><div class="controls bullet"><span class="by">dietrichepp</span><span>|</span><a href="#36499775">root</a><span>|</span><a href="#36501079">parent</a><span>|</span><a href="#36500322">next</a><span>|</span><label class="collapse" for="c-36501496">[-]</label><label class="expand" for="c-36501496">[4 more]</label></div><br/><div class="children"><div class="content">Maybe that’s right, memory bandwidth is not the right explanation. But the rasterization itself is still often a big bottleneck, and maybe chalking it up to fill rate limitations is more explicatory. This is based on my limited observations writing my own N64 code and trying different scenes that put different amounts of load on the RDP—varying the load on the RDP was by far the easiest way to get framerate drops. If the CPU load is relatively constant, if the RSP load is relatively constant, then explaining it as running into fill rate limitations seems like a good theory to me.<p>I’m a little skeptical that there’s “huge” untapped power in this system, given the performance of some later games like World Driver Championship (1999). There’s certainly a lot of processing power across the CPU, RSP, and RDP, but given how heterogeneous the system is, and how many weird hangups there are, I have doubts that we’re going to see something much better come out of the demoscene community. You need a lot of appetite for a long-term project in order to make something impressive on the N64, and while we have better emulators and compilers now, it’s hard to compete against someone in the 1990s who got to spend multiple years on the system full-time, with the support of a team and from the console developers.<p>There are some tricks I can imagine using, like spending more time with the RDP in single-cycle mode, or rendering just the fields to get 480i at the cost of 240p, but there are just so many thorny problems to deal with.<p>This is speaking as someone who participates both in the demoscene (I was just in Boston for @party), and N64 homebrew (you can find me on the Discord).</div><br/><div id="36502162" class="c"><input type="checkbox" id="c-36502162" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#36499775">root</a><span>|</span><a href="#36501496">parent</a><span>|</span><a href="#36500322">next</a><span>|</span><label class="collapse" for="c-36502162">[-]</label><label class="expand" for="c-36502162">[3 more]</label></div><br/><div class="children"><div class="content">In one of Kaze&#x27;s older videos <i>[1]</i>, he tracks both CPU and RCP time over various optimisations. The numbers make it pretty apparent that you can get significant RDP performance gains by reducing the amount of CPU bandwidth and&#x2F;or improving it&#x27;s access locality.<p>The N64 is a unified memory system, and memory stalls triggered by the CPU will slow RDP down.<p>The N64&#x27;s memory controller appears to be very simple. As I understand it, if one sub-component attempts to access a DRAM row that is closed (DRAM rows are 2KB long), then the entire memory controller stalls for ~100ns as the RDRAM chip closes the previous row (writing out any dirty changes) and opens the new row.<p>The controller doesn&#x27;t appear to do any reordering to optimise access patterns. If multiple components are accessing the same 1MB bank simultaneously, you can hit pathological bad cases were the entire system slows down, as the memory controller is continually stalling for 100ns at a time while the memory chips close and reopen rows.<p>Which is why some games can enable a high resolution mode when the memory expansion pack is present. They often don&#x27;t need the extra 4MB of ram, but simply being able to strategically spread their data across eight different banks instead of four banks can massively improve performance.<p><i>[1]</i> <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=t_rzYnXEQlE">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=t_rzYnXEQlE</a></div><br/><div id="36502280" class="c"><input type="checkbox" id="c-36502280" checked=""/><div class="controls bullet"><span class="by">dietrichepp</span><span>|</span><a href="#36499775">root</a><span>|</span><a href="#36502162">parent</a><span>|</span><a href="#36500322">next</a><span>|</span><label class="collapse" for="c-36502280">[-]</label><label class="expand" for="c-36502280">[2 more]</label></div><br/><div class="children"><div class="content">The bank organization is relatively well-known, so maybe you put the framebuffer in one bank, you put the zbuffer in another bank, and you have two banks left over without touching expansion memory. I mentioned World Driver Championship specifically because it runs at 640x480, and runs well, without the expansion pack.<p>Yes, memory access by the CPU will slow the RDP down. But the RDP is plenty slow even when the CPU is idle. The reason that we are seeing such improvements with SM64 is because SM64 was in such bad shape to begin with—something to be expected, given the novelty of 3D hardware in 1996 and problems with compiler bugs.</div><br/><div id="36503185" class="c"><input type="checkbox" id="c-36503185" checked=""/><div class="controls bullet"><span class="by">NovaDudely</span><span>|</span><a href="#36499775">root</a><span>|</span><a href="#36502280">parent</a><span>|</span><a href="#36500322">next</a><span>|</span><label class="collapse" for="c-36503185">[-]</label><label class="expand" for="c-36503185">[1 more]</label></div><br/><div class="children"><div class="content">Kaze explained once that a big part of performance issues was related to fill rate which I guess is part of the memory bandwidth issue. Essentially, polygon counts aren&#x27;t a huge issue provided they don&#x27;t use a large amount of screen space. While the Z-buffer will help out with larger polygons, it isn&#x27;t a silver bullet solution.<p>That said, I don&#x27;t doubt SM64 was in bad shape, this was really Nintendo&#x27;s 1st attempt at doing 3D at that scale and almost everything was experimental. But even with that, it is amazing to see just how well a lot of it works despite this. But seeing some of the later stuff released on N64, it did seem like a really tapped out resource. Mind you looking at the Portal 64 coming along, it is neat to see that folks are still trying to push it just a little bit more.<p>Back to SM64, one thing I still find really cool is when you get Mario on a rotating platform, the rotation position and angle is calculated as it should be for both location and angle. That is just slick to see on something that old.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36500322" class="c"><input type="checkbox" id="c-36500322" checked=""/><div class="controls bullet"><span class="by">nstbayless</span><span>|</span><a href="#36499775">root</a><span>|</span><a href="#36500140">parent</a><span>|</span><a href="#36501079">prev</a><span>|</span><a href="#36500386">next</a><span>|</span><label class="collapse" for="c-36500322">[-]</label><label class="expand" for="c-36500322">[1 more]</label></div><br/><div class="children"><div class="content">One of the big optimizations Kaze makes is to remove a huge lookup table, which greatly reduces cache&#x2F;memory usage.</div><br/></div></div><div id="36500386" class="c"><input type="checkbox" id="c-36500386" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#36499775">root</a><span>|</span><a href="#36500140">parent</a><span>|</span><a href="#36500322">prev</a><span>|</span><a href="#36500344">next</a><span>|</span><label class="collapse" for="c-36500386">[-]</label><label class="expand" for="c-36500386">[1 more]</label></div><br/><div class="children"><div class="content">SM64 was compiled with gcc or mipspro?</div><br/></div></div></div></div><div id="36500344" class="c"><input type="checkbox" id="c-36500344" checked=""/><div class="controls bullet"><span class="by">nstbayless</span><span>|</span><a href="#36499775">parent</a><span>|</span><a href="#36500140">prev</a><span>|</span><a href="#36499687">next</a><span>|</span><label class="collapse" for="c-36500344">[-]</label><label class="expand" for="c-36500344">[1 more]</label></div><br/><div class="children"><div class="content">Kaze has expressed intent to produce a patch for sm64 with all the optimizations he&#x27;s found after he releases his overhaul hack.</div><br/></div></div></div></div><div id="36499687" class="c"><input type="checkbox" id="c-36499687" checked=""/><div class="controls bullet"><span class="by">DigiDigiorno</span><span>|</span><a href="#36499775">prev</a><span>|</span><a href="#36502766">next</a><span>|</span><label class="collapse" for="c-36499687">[-]</label><label class="expand" for="c-36499687">[1 more]</label></div><br/><div class="children"><div class="content">I like Kaze&#x27;s content. There is something fun about how hacky and ridiculous it is to put that much effort into Super Mario 64 optimizations and brand new levels.<p>This video is more technical than the others, but I suggest checking out his other videos if the idea of Super Mario 64 development piques your interest.</div><br/></div></div><div id="36502766" class="c"><input type="checkbox" id="c-36502766" checked=""/><div class="controls bullet"><span class="by">dvh</span><span>|</span><a href="#36499687">prev</a><span>|</span><a href="#36501214">next</a><span>|</span><label class="collapse" for="c-36502766">[-]</label><label class="expand" for="c-36502766">[1 more]</label></div><br/><div class="children"><div class="content">The logical next step is creating virtual machine and brute force generate function with less then 27 instructions and see if it produces something close to sine. Let it run for few months and surely it will find something.</div><br/></div></div><div id="36501214" class="c"><input type="checkbox" id="c-36501214" checked=""/><div class="controls bullet"><span class="by">levodelellis</span><span>|</span><a href="#36502766">prev</a><span>|</span><a href="#36501128">next</a><span>|</span><label class="collapse" for="c-36501214">[-]</label><label class="expand" for="c-36501214">[1 more]</label></div><br/><div class="children"><div class="content">Fantastic video</div><br/></div></div><div id="36501128" class="c"><input type="checkbox" id="c-36501128" checked=""/><div class="controls bullet"><span class="by">nsajko</span><span>|</span><a href="#36501214">prev</a><span>|</span><label class="collapse" for="c-36501128">[-]</label><label class="expand" for="c-36501128">[7 more]</label></div><br/><div class="children"><div class="content">The video is very well produced and engaging, however (from skimming it), it seems that all the implementation methods it presents are suboptimal.<p>The N64 CPU had an FPU, so it seems obvious that the best method, from both a speed and accuracy (or whichever is deemed more important) standpoint would be the same method that&#x27;s used in all the libms in libcs like Glibc, musl or LLVM-libc, or in the standard libraries of languages like Go or Java: approximation using a polynomial. This polynomial is not derived analytically, rather it&#x27;s found using an iterative algorithm, traditionally using the Remez algorithm, but also see my WIP project here: <a href="https:&#x2F;&#x2F;gitlab.com&#x2F;nsajko&#x2F;FindMinimaxPolynomial.jl" rel="nofollow noreferrer">https:&#x2F;&#x2F;gitlab.com&#x2F;nsajko&#x2F;FindMinimaxPolynomial.jl</a>.</div><br/><div id="36501385" class="c"><input type="checkbox" id="c-36501385" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#36501128">parent</a><span>|</span><a href="#36502027">next</a><span>|</span><label class="collapse" for="c-36501385">[-]</label><label class="expand" for="c-36501385">[3 more]</label></div><br/><div class="children"><div class="content">&gt; This polynomial is not derived analytically, rather it&#x27;s found using an iterative algorithm, traditionally using the Remez algorithm, but also see my WIP project here: <a href="https:&#x2F;&#x2F;gitlab.com&#x2F;nsajko&#x2F;FindMinimaxPolynomial.jl" rel="nofollow noreferrer">https:&#x2F;&#x2F;gitlab.com&#x2F;nsajko&#x2F;FindMinimaxPolynomial.jl</a>.<p>Is this your independent attempt? Because I think RLIBM did the essentially same thing recently [1].<p>[1] <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2104.04043.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2104.04043.pdf</a></div><br/><div id="36501578" class="c"><input type="checkbox" id="c-36501578" checked=""/><div class="controls bullet"><span class="by">nsajko</span><span>|</span><a href="#36501128">root</a><span>|</span><a href="#36501385">parent</a><span>|</span><a href="#36502027">next</a><span>|</span><label class="collapse" for="c-36501578">[-]</label><label class="expand" for="c-36501578">[2 more]</label></div><br/><div class="children"><div class="content">One difference is that their approach doesn&#x27;t scale to 64-bit floats AFAIK. My code and their approach are actually quite different, with different goals, different places where they&#x27;re smart and different places where they could be improved.<p>I hope to improve my code based on their ideas when I finally read their papers, however I still have plenty of my own that I want to implement.<p>See also this thread from twenty days ago, someone asked me basically the same thing, linking an earlier paper by Lim and Nagarakatte (et al):<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36201197">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36201197</a></div><br/><div id="36502010" class="c"><input type="checkbox" id="c-36502010" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#36501128">root</a><span>|</span><a href="#36501578">parent</a><span>|</span><a href="#36502027">next</a><span>|</span><label class="collapse" for="c-36502010">[-]</label><label class="expand" for="c-36502010">[1 more]</label></div><br/><div class="children"><div class="content">Cool! I think the RLIBM approach is indeed fresh and has potentials, but I was never sure if it can be generalized to domains past binary32 when we are looking for correctly rounded results. I guess it&#x27;s a fundamental difference between RLIBM and your algorithm---you don&#x27;t guarantee correctly rounded results, right?</div><br/></div></div></div></div></div></div><div id="36502027" class="c"><input type="checkbox" id="c-36502027" checked=""/><div class="controls bullet"><span class="by">sosodev</span><span>|</span><a href="#36501128">parent</a><span>|</span><a href="#36501385">prev</a><span>|</span><a href="#36502110">next</a><span>|</span><label class="collapse" for="c-36502027">[-]</label><label class="expand" for="c-36502027">[1 more]</label></div><br/><div class="children"><div class="content">I really don&#x27;t think you can claim that the solution is suboptimal. Kaze has clearly spent a lot of time on this and has a real code to show for it. You&#x27;re just theorizing that it&#x27;s bad without providing any real evidence.</div><br/></div></div><div id="36502110" class="c"><input type="checkbox" id="c-36502110" checked=""/><div class="controls bullet"><span class="by">tyg13</span><span>|</span><a href="#36501128">parent</a><span>|</span><a href="#36502027">prev</a><span>|</span><a href="#36502453">next</a><span>|</span><label class="collapse" for="c-36502110">[-]</label><label class="expand" for="c-36502110">[1 more]</label></div><br/><div class="children"><div class="content">Polynomial approximation was used throughout the video, and minimax was one of the final methods. Timestamp is sometime around 18:00. There seemed to be numerical issues with the approximation producing sin values above 1.0.</div><br/></div></div><div id="36502453" class="c"><input type="checkbox" id="c-36502453" checked=""/><div class="controls bullet"><span class="by">thebooktocome</span><span>|</span><a href="#36501128">parent</a><span>|</span><a href="#36502110">prev</a><span>|</span><label class="collapse" for="c-36502453">[-]</label><label class="expand" for="c-36502453">[1 more]</label></div><br/><div class="children"><div class="content">By itself, Remez is not usually helpful for these kinds of low-accuracy polynomial approximations, because getting the minmax error beneath the quantization threshold is too strong a constraint. Usually one ends up doing some brute force polishing at the end to try and reduce the polynomial degree and&#x2F;or the bits necessary to represent coefficients.</div><br/></div></div></div></div></div></div></div></div></div></body></html>