<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1718787673584" as="style"/><link rel="stylesheet" href="styles.css?v=1718787673584"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a>Ask HN: Why do message queue-based architectures seem less popular now?</a> </div><div class="subtext"><span>alexhutcheson</span> | <span>136 comments</span></div><br/><div><div id="40725060" class="c"><input type="checkbox" id="c-40725060" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#40723688">next</a><span>|</span><label class="collapse" for="c-40725060">[-]</label><label class="expand" for="c-40725060">[37 more]</label></div><br/><div class="children"><div class="content">I like a lot of the answers, but something else I&#x27;d add: lots of &quot;popular&quot; architectures from the late 00s and early 2010s have fallen by the wayside because people realized &quot;You&#x27;re not Google. Your company will never be Google.&quot;<p>That is, there was a big desire around that time period to &quot;build it how the big successful companies built it.&quot; But since then, a lot of us have realized that complexity isn&#x27;t necessary for 99% of companies. When you couple that with hardware and standard databases getting much better, there are just fewer and fewer companies who need all of these &quot;scalability tricks&quot;.<p>My bar for &quot;Is there a reason we can&#x27;t just do this all in Postgres?&quot; is much, much higher than it was a decade ago.</div><br/><div id="40725691" class="c"><input type="checkbox" id="c-40725691" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#40725060">parent</a><span>|</span><a href="#40725203">next</a><span>|</span><label class="collapse" for="c-40725691">[-]</label><label class="expand" for="c-40725691">[7 more]</label></div><br/><div class="children"><div class="content">We also have much much bigger single machines available for reasonable money. So a lot of reasonable workloads can fit in one machine now that used to require a small cluster</div><br/><div id="40726291" class="c"><input type="checkbox" id="c-40726291" checked=""/><div class="controls bullet"><span class="by">bamboozled</span><span>|</span><a href="#40725060">root</a><span>|</span><a href="#40725691">parent</a><span>|</span><a href="#40725735">next</a><span>|</span><label class="collapse" for="c-40726291">[-]</label><label class="expand" for="c-40726291">[1 more]</label></div><br/><div class="children"><div class="content">What happens when the single machine fails?</div><br/></div></div><div id="40725735" class="c"><input type="checkbox" id="c-40725735" checked=""/><div class="controls bullet"><span class="by">Dalewyn</span><span>|</span><a href="#40725060">root</a><span>|</span><a href="#40725691">parent</a><span>|</span><a href="#40726291">prev</a><span>|</span><a href="#40725966">next</a><span>|</span><label class="collapse" for="c-40725735">[-]</label><label class="expand" for="c-40725735">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s kind of mind boggling just how powerful mundane desktop computers have gotten, let alone server hardware.<p>Think about it: That 20 core CPU (eg: i7 14700K) you can buy for just a couple hundred dollars today would have been supercomputer hardware costing tens or hundreds of thousands of dollars just a decade ago.</div><br/><div id="40726024" class="c"><input type="checkbox" id="c-40726024" checked=""/><div class="controls bullet"><span class="by">EVa5I7bHFq9mnYK</span><span>|</span><a href="#40725060">root</a><span>|</span><a href="#40725735">parent</a><span>|</span><a href="#40725966">next</a><span>|</span><label class="collapse" for="c-40726024">[-]</label><label class="expand" for="c-40726024">[3 more]</label></div><br/><div class="children"><div class="content">According to geekbench, an i9 4790 processor released a decade ago is ~5 times slower than i7 14700. 4790&#x27;s go for $30 at ebay, vs $300 for 14700, so price&#x2F;performance seems to be in favor of older hardware:)</div><br/><div id="40726132" class="c"><input type="checkbox" id="c-40726132" checked=""/><div class="controls bullet"><span class="by">Dalewyn</span><span>|</span><a href="#40725060">root</a><span>|</span><a href="#40726024">parent</a><span>|</span><a href="#40725966">next</a><span>|</span><label class="collapse" for="c-40726132">[-]</label><label class="expand" for="c-40726132">[2 more]</label></div><br/><div class="children"><div class="content">On the other hand, the E7-8890 v3 (the closest equivalent to a 14700K in core count at the time from a quick glance) had an MSRP of $7174.00[1].<p>So maybe I was a bit too high on the pricing earlier, but my point still stands that the computing horsepower we have such easy access to today was literal big time magic just a decade ago.<p>[1]: <a href="https:&#x2F;&#x2F;ark.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;ark&#x2F;products&#x2F;84685&#x2F;intel-xeon-processor-e7-8890-v3-45m-cache-2-50-ghz.html" rel="nofollow">https:&#x2F;&#x2F;ark.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;ark&#x2F;products&#x2F;84685&#x2F;i...</a></div><br/></div></div></div></div></div></div><div id="40725966" class="c"><input type="checkbox" id="c-40725966" checked=""/><div class="controls bullet"><span class="by">alfiedotwtf</span><span>|</span><a href="#40725060">root</a><span>|</span><a href="#40725691">parent</a><span>|</span><a href="#40725735">prev</a><span>|</span><a href="#40725203">next</a><span>|</span><label class="collapse" for="c-40725966">[-]</label><label class="expand" for="c-40725966">[1 more]</label></div><br/><div class="children"><div class="content">This! You NEEDED to scale horizontally because machines were just doing too much. I remember when our Apache boxes couldn’t even cope doing SSL so we had a hardware box doing it on ingress!</div><br/></div></div></div></div><div id="40725203" class="c"><input type="checkbox" id="c-40725203" checked=""/><div class="controls bullet"><span class="by">steve1977</span><span>|</span><a href="#40725060">parent</a><span>|</span><a href="#40725691">prev</a><span>|</span><a href="#40725112">next</a><span>|</span><label class="collapse" for="c-40725203">[-]</label><label class="expand" for="c-40725203">[21 more]</label></div><br/><div class="children"><div class="content">&gt; because people realized &quot;You&#x27;re not Google. Your company will never be Google.&quot;<p>Is that also why almost no one is using microservices and Kubernetes?</div><br/><div id="40725613" class="c"><input type="checkbox" id="c-40725613" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#40725060">root</a><span>|</span><a href="#40725203">parent</a><span>|</span><a href="#40725227">next</a><span>|</span><label class="collapse" for="c-40725613">[-]</label><label class="expand" for="c-40725613">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Is that also why almost no one is using microservices and Kubernetes?<p>I don’t know of a single 100+ sized organisation in my area which doesn’t use micro services in some form. A lot of places also use kubernetes indirectly through major cloud provider layers line Azure Container Apps.<p>Our frontend (and indeed quite a bit of our backend) lives in a NX mono-repo. As for how it actually works, however, it’s basically a lot of micro-services which are very independently maintainable. Meaning you can easily have different teams work on different parts of your ecosystem and not break things. It doesn’t necessarily deploy as what some people might consider micro services of course. But then micro services were always this abstract thing that is honestly more of a framework for management and change management than anything tech.</div><br/></div></div><div id="40725227" class="c"><input type="checkbox" id="c-40725227" checked=""/><div class="controls bullet"><span class="by">k8sToGo</span><span>|</span><a href="#40725060">root</a><span>|</span><a href="#40725203">parent</a><span>|</span><a href="#40725613">prev</a><span>|</span><a href="#40725874">next</a><span>|</span><label class="collapse" for="c-40725227">[-]</label><label class="expand" for="c-40725227">[17 more]</label></div><br/><div class="children"><div class="content">Kubernetes brings more than just being Google. In a way it’s also an ecosystem.</div><br/><div id="40725258" class="c"><input type="checkbox" id="c-40725258" checked=""/><div class="controls bullet"><span class="by">steve1977</span><span>|</span><a href="#40725060">root</a><span>|</span><a href="#40725227">parent</a><span>|</span><a href="#40725874">next</a><span>|</span><label class="collapse" for="c-40725258">[-]</label><label class="expand" for="c-40725258">[16 more]</label></div><br/><div class="children"><div class="content">That‘s nice, but the question is if you (i.e. your company) needs this ecosystem.</div><br/><div id="40725372" class="c"><input type="checkbox" id="c-40725372" checked=""/><div class="controls bullet"><span class="by">k8sToGo</span><span>|</span><a href="#40725060">root</a><span>|</span><a href="#40725258">parent</a><span>|</span><a href="#40725808">next</a><span>|</span><label class="collapse" for="c-40725372">[-]</label><label class="expand" for="c-40725372">[10 more]</label></div><br/><div class="children"><div class="content">Need no. But it’s nice especially since I have the know how.<p>Creating a new deployment is just super fast. Developers can deploy their own apps etc.<p>And then there is Helm.<p>If we only decide by “need” then most of the time we also wouldn’t need object oriented programming.</div><br/><div id="40725503" class="c"><input type="checkbox" id="c-40725503" checked=""/><div class="controls bullet"><span class="by">sofixa</span><span>|</span><a href="#40725060">root</a><span>|</span><a href="#40725372">parent</a><span>|</span><a href="#40725808">next</a><span>|</span><label class="collapse" for="c-40725503">[-]</label><label class="expand" for="c-40725503">[9 more]</label></div><br/><div class="children"><div class="content">&gt; And then there is Helm<p>Right, who doesn&#x27;t want to template hundreds of lines of code in a language that uses whitespace for logic and was never made neither for templating nor complex long documents(YAML)? What could possibly go wrong (&quot;error missing xxx at line 728, but it might be a problem elsewhere&quot;).</div><br/><div id="40726314" class="c"><input type="checkbox" id="c-40726314" checked=""/><div class="controls bullet"><span class="by">ndthrowaway</span><span>|</span><a href="#40725060">root</a><span>|</span><a href="#40725503">parent</a><span>|</span><a href="#40725684">next</a><span>|</span><label class="collapse" for="c-40726314">[-]</label><label class="expand" for="c-40726314">[1 more]</label></div><br/><div class="children"><div class="content">&quot;in a language that uses whitespace for logic&quot;<p>This argument kind of died when python became one of the most popular programming languages used.</div><br/></div></div><div id="40725684" class="c"><input type="checkbox" id="c-40725684" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#40725060">root</a><span>|</span><a href="#40725503">parent</a><span>|</span><a href="#40726314">prev</a><span>|</span><a href="#40725642">next</a><span>|</span><label class="collapse" for="c-40725684">[-]</label><label class="expand" for="c-40725684">[1 more]</label></div><br/><div class="children"><div class="content">I wonder why people don&#x27;t use fromYaml + toJson to avoid stupid errors with indent.<p>Yaml is for all intents and purposes a superset of JSON so if you render your subtree as JSON you can stick it in a Yaml file and you don&#x27;t need to care with indentation.</div><br/></div></div><div id="40725642" class="c"><input type="checkbox" id="c-40725642" checked=""/><div class="controls bullet"><span class="by">fredrb</span><span>|</span><a href="#40725060">root</a><span>|</span><a href="#40725503">parent</a><span>|</span><a href="#40725684">prev</a><span>|</span><a href="#40725636">next</a><span>|</span><label class="collapse" for="c-40725642">[-]</label><label class="expand" for="c-40725642">[1 more]</label></div><br/><div class="children"><div class="content">It’s not that bad if you need to deploy at least 3 things and for most cases it beats the alternatives. You can get away with a bootstrapped deployment yaml and a couple of services for most scenarios. What should you use instead? Vendor locked app platforms? Roll out your own deploy bash scripts?<p>Sure the full extend of Kubernetes is complicated and managing it might be a pain, but if you don’t go bonkers is not that hard to use it as a developer.</div><br/></div></div><div id="40725636" class="c"><input type="checkbox" id="c-40725636" checked=""/><div class="controls bullet"><span class="by">spoiler</span><span>|</span><a href="#40725060">root</a><span>|</span><a href="#40725503">parent</a><span>|</span><a href="#40725642">prev</a><span>|</span><a href="#40725549">next</a><span>|</span><label class="collapse" for="c-40725636">[-]</label><label class="expand" for="c-40725636">[1 more]</label></div><br/><div class="children"><div class="content">Honestly, Helm kinda sucks (for all the reasons you mentioned).<p>But Kustomize is very nice. Although, their docs could be a bit better.</div><br/></div></div><div id="40725549" class="c"><input type="checkbox" id="c-40725549" checked=""/><div class="controls bullet"><span class="by">xnickb</span><span>|</span><a href="#40725060">root</a><span>|</span><a href="#40725503">parent</a><span>|</span><a href="#40725636">prev</a><span>|</span><a href="#40725808">next</a><span>|</span><label class="collapse" for="c-40725549">[-]</label><label class="expand" for="c-40725549">[4 more]</label></div><br/><div class="children"><div class="content">But my infrastructure is code! Can&#x27;t you see how it&#x27;s all in git?</div><br/><div id="40725916" class="c"><input type="checkbox" id="c-40725916" checked=""/><div class="controls bullet"><span class="by">benterix</span><span>|</span><a href="#40725060">root</a><span>|</span><a href="#40725549">parent</a><span>|</span><a href="#40725808">next</a><span>|</span><label class="collapse" for="c-40725916">[-]</label><label class="expand" for="c-40725916">[3 more]</label></div><br/><div class="children"><div class="content">What&#x27;s wrong with having your infrastructure as code and storing it in Git?</div><br/><div id="40726308" class="c"><input type="checkbox" id="c-40726308" checked=""/><div class="controls bullet"><span class="by">sofixa</span><span>|</span><a href="#40725060">root</a><span>|</span><a href="#40725916">parent</a><span>|</span><a href="#40726301">next</a><span>|</span><label class="collapse" for="c-40726308">[-]</label><label class="expand" for="c-40726308">[1 more]</label></div><br/><div class="children"><div class="content">Nothing. Even if it&#x27;s objectively terrible (thousands of lines of templated YAML, or thousands of lines of spaghetti bash), being in Git as code is still better. At least you know what it is, how it evolved, and can start adding linting&#x2F;tests.</div><br/></div></div><div id="40726301" class="c"><input type="checkbox" id="c-40726301" checked=""/><div class="controls bullet"><span class="by">xnickb</span><span>|</span><a href="#40725060">root</a><span>|</span><a href="#40725916">parent</a><span>|</span><a href="#40726308">prev</a><span>|</span><a href="#40725808">next</a><span>|</span><label class="collapse" for="c-40726301">[-]</label><label class="expand" for="c-40726301">[1 more]</label></div><br/><div class="children"><div class="content">YAML isn&#x27;t code. Same as your reply, YAML has very little awareness of context.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40725808" class="c"><input type="checkbox" id="c-40725808" checked=""/><div class="controls bullet"><span class="by">Kirth</span><span>|</span><a href="#40725060">root</a><span>|</span><a href="#40725258">parent</a><span>|</span><a href="#40725372">prev</a><span>|</span><a href="#40725874">next</a><span>|</span><label class="collapse" for="c-40725808">[-]</label><label class="expand" for="c-40725808">[5 more]</label></div><br/><div class="children"><div class="content">Genuine question: say you have 3-4 services and a bunch of databases that make up your product, what&#x27;s the alternative to plemping them all into K8s according to you?</div><br/><div id="40726238" class="c"><input type="checkbox" id="c-40726238" checked=""/><div class="controls bullet"><span class="by">pcl</span><span>|</span><a href="#40725060">root</a><span>|</span><a href="#40725808">parent</a><span>|</span><a href="#40726028">next</a><span>|</span><label class="collapse" for="c-40726238">[-]</label><label class="expand" for="c-40726238">[1 more]</label></div><br/><div class="children"><div class="content">3-4 services and a bunch of databases?<p>Assuming there aren’t any particular scaling or performance requirements, if I were managing something like that, I would almost certainly <i>not</i> use k8s. Maybe systemd on a big box for the services?</div><br/></div></div><div id="40726028" class="c"><input type="checkbox" id="c-40726028" checked=""/><div class="controls bullet"><span class="by">Myoklov</span><span>|</span><a href="#40725060">root</a><span>|</span><a href="#40725808">parent</a><span>|</span><a href="#40726238">prev</a><span>|</span><a href="#40725881">next</a><span>|</span><label class="collapse" for="c-40726028">[-]</label><label class="expand" for="c-40726028">[1 more]</label></div><br/><div class="children"><div class="content">Using cloud platform as a service options. For example, on Azure you can deploy such system with Azure App Service (with container deployment), or Azure Container Apps (very suitable for microservices). For database, you can use Azure Database for PostgreSQL (flexible), or Azure Cosmos DB for PostgreSQL.<p>This way, Azure does most of the heavy lifting you would otherwise have to do yourself, even with managed kubernetes.</div><br/></div></div><div id="40725881" class="c"><input type="checkbox" id="c-40725881" checked=""/><div class="controls bullet"><span class="by">benterix</span><span>|</span><a href="#40725060">root</a><span>|</span><a href="#40725808">parent</a><span>|</span><a href="#40726028">prev</a><span>|</span><a href="#40725969">next</a><span>|</span><label class="collapse" for="c-40725881">[-]</label><label class="expand" for="c-40725881">[1 more]</label></div><br/><div class="children"><div class="content">If you use AWS, it&#x27;s probably easier to use ECS that takes away <i>some</i> of the complexity from you.</div><br/></div></div><div id="40725969" class="c"><input type="checkbox" id="c-40725969" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#40725060">root</a><span>|</span><a href="#40725808">parent</a><span>|</span><a href="#40725881">prev</a><span>|</span><a href="#40725874">next</a><span>|</span><label class="collapse" for="c-40725969">[-]</label><label class="expand" for="c-40725969">[1 more]</label></div><br/><div class="children"><div class="content">For personal stuff I simply run systemd services and that does scale quite a lot (as in, you can rely on it for more production services) I believe.</div><br/></div></div></div></div></div></div></div></div><div id="40725874" class="c"><input type="checkbox" id="c-40725874" checked=""/><div class="controls bullet"><span class="by">benterix</span><span>|</span><a href="#40725060">root</a><span>|</span><a href="#40725203">parent</a><span>|</span><a href="#40725227">prev</a><span>|</span><a href="#40725112">next</a><span>|</span><label class="collapse" for="c-40725874">[-]</label><label class="expand" for="c-40725874">[2 more]</label></div><br/><div class="children"><div class="content">Define &quot;no one&quot;. If you mean small shops, maybe. If you mean large organizations, I haven&#x27;t seen even one in the last 5 years that wouldn&#x27;t use them in one way or another.</div><br/><div id="40726182" class="c"><input type="checkbox" id="c-40726182" checked=""/><div class="controls bullet"><span class="by">steve1977</span><span>|</span><a href="#40725060">root</a><span>|</span><a href="#40725874">parent</a><span>|</span><a href="#40725112">next</a><span>|</span><label class="collapse" for="c-40726182">[-]</label><label class="expand" for="c-40726182">[1 more]</label></div><br/><div class="children"><div class="content">It was meant to be ironic</div><br/></div></div></div></div></div></div><div id="40725112" class="c"><input type="checkbox" id="c-40725112" checked=""/><div class="controls bullet"><span class="by">nosefrog</span><span>|</span><a href="#40725060">parent</a><span>|</span><a href="#40725203">prev</a><span>|</span><a href="#40726115">next</a><span>|</span><label class="collapse" for="c-40725112">[-]</label><label class="expand" for="c-40725112">[6 more]</label></div><br/><div class="children"><div class="content">To be fair, I worked on multiple projects removing queues at Google, so it&#x27;s more than just that.</div><br/><div id="40725324" class="c"><input type="checkbox" id="c-40725324" checked=""/><div class="controls bullet"><span class="by">keredson</span><span>|</span><a href="#40725060">root</a><span>|</span><a href="#40725112">parent</a><span>|</span><a href="#40726115">next</a><span>|</span><label class="collapse" for="c-40725324">[-]</label><label class="expand" for="c-40725324">[5 more]</label></div><br/><div class="children"><div class="content">and mandates that virtually all new projects not directly use borg&#x2F;kubernetes.</div><br/><div id="40725923" class="c"><input type="checkbox" id="c-40725923" checked=""/><div class="controls bullet"><span class="by">benterix</span><span>|</span><a href="#40725060">root</a><span>|</span><a href="#40725324">parent</a><span>|</span><a href="#40725516">next</a><span>|</span><label class="collapse" for="c-40725923">[-]</label><label class="expand" for="c-40725923">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s interesting. What&#x27;s the rationale behind that?</div><br/><div id="40726164" class="c"><input type="checkbox" id="c-40726164" checked=""/><div class="controls bullet"><span class="by">samus</span><span>|</span><a href="#40725060">root</a><span>|</span><a href="#40725923">parent</a><span>|</span><a href="#40725516">next</a><span>|</span><label class="collapse" for="c-40726164">[-]</label><label class="expand" for="c-40726164">[1 more]</label></div><br/><div class="children"><div class="content">I guess such a service gets coupled too strongly to that platform, and major engineering effort is required to deploy it the old-school way.</div><br/></div></div></div></div><div id="40725516" class="c"><input type="checkbox" id="c-40725516" checked=""/><div class="controls bullet"><span class="by">azaras</span><span>|</span><a href="#40725060">root</a><span>|</span><a href="#40725324">parent</a><span>|</span><a href="#40725923">prev</a><span>|</span><a href="#40726115">next</a><span>|</span><label class="collapse" for="c-40725516">[-]</label><label class="expand" for="c-40725516">[2 more]</label></div><br/><div class="children"><div class="content">Can you extend it? How do they deploy, and where do they deploy their projects?</div><br/></div></div></div></div></div></div><div id="40726115" class="c"><input type="checkbox" id="c-40726115" checked=""/><div class="controls bullet"><span class="by">peoplefromibiza</span><span>|</span><a href="#40725060">parent</a><span>|</span><a href="#40725112">prev</a><span>|</span><a href="#40723688">next</a><span>|</span><label class="collapse" for="c-40726115">[-]</label><label class="expand" for="c-40726115">[2 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;You&#x27;re not Google. Your company will never be Google.&quot;<p>I&#x27;m not sure people realize this now more than then. I was there back then and we surely knew we would never be Google hence we didn&#x27;t need to &quot;scale&quot; the same way they did.<p>Nowadays every project I start begins with a meeting where is presented a document describing  the architecture we are going to implement, using AWS of course, because &quot;auto-scale&quot; right?, and 9&#x2F;10 it includes CloudFront, which is a CDN and I don&#x27;t really understand why this app I am developing, which is basically an API gateway with some customization that made Ngnix slightly less than ideal (but still perfect for the job), and that averages to 5 rps needs a CDN in front of it... (or AWS or auto-scaling or AWS lambda, for that matter)</div><br/><div id="40726190" class="c"><input type="checkbox" id="c-40726190" checked=""/><div class="controls bullet"><span class="by">samus</span><span>|</span><a href="#40725060">root</a><span>|</span><a href="#40726115">parent</a><span>|</span><a href="#40723688">next</a><span>|</span><label class="collapse" for="c-40726190">[-]</label><label class="expand" for="c-40726190">[1 more]</label></div><br/><div class="children"><div class="content">The autoscaling is nice because a lot of performance issues just get resolved without much meddling by the ops team, buying time for proper optimizations should it get out of hand.<p>The disadvantage is that people don&#x27;t think hard about performance requirements anymore. Premature optimization is bad, but it&#x27;s also a warning sign if a project has no clue whatsoever how intensely the system is going to be used.</div><br/></div></div></div></div></div></div><div id="40723688" class="c"><input type="checkbox" id="c-40723688" checked=""/><div class="controls bullet"><span class="by">bigiain</span><span>|</span><a href="#40725060">prev</a><span>|</span><a href="#40725751">next</a><span>|</span><label class="collapse" for="c-40723688">[-]</label><label class="expand" for="c-40723688">[14 more]</label></div><br/><div class="children"><div class="content">My, perhaps overly cynical view, is that Message Queue architecture and blogging was all about &quot;Resume Driven Development&quot; - where almost everybody doing it was unlikely to ever need to scale past what a simple monolith could support running on a single laptop. All the same people who were building nightmare micro service disasters requiring tens of thousand of dollars a month of AWS services.<p>These days all those people who prioritise career building technical feats over solving actual business problems in pragmatic ways - they&#x27;re all hyping and blogging about AI, with similar results for the companies they (allegedly) are working for: <a href="https:&#x2F;&#x2F;www.theregister.com&#x2F;2024&#x2F;06&#x2F;12&#x2F;survey_ai_projects&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.theregister.com&#x2F;2024&#x2F;06&#x2F;12&#x2F;survey_ai_projects&#x2F;</a></div><br/><div id="40726201" class="c"><input type="checkbox" id="c-40726201" checked=""/><div class="controls bullet"><span class="by">robertlagrant</span><span>|</span><a href="#40723688">parent</a><span>|</span><a href="#40723825">next</a><span>|</span><label class="collapse" for="c-40726201">[-]</label><label class="expand" for="c-40726201">[1 more]</label></div><br/><div class="children"><div class="content">&gt; My, perhaps overly cynical view, is that Message Queue architecture and blogging was all about &quot;Resume Driven Development&quot; - where almost everybody doing it was unlikely to ever need to scale past what a simple monolith could support running on a single laptop. All the same people who were building nightmare micro service disasters requiring tens of thousand of dollars a month of AWS services.<p>Yes, that is cynical. People have been building architectures off MQ for a much longer time than microservices have been around. Lots of corporates have used JMS for a long time now.</div><br/></div></div><div id="40723825" class="c"><input type="checkbox" id="c-40723825" checked=""/><div class="controls bullet"><span class="by">abeppu</span><span>|</span><a href="#40723688">parent</a><span>|</span><a href="#40726201">prev</a><span>|</span><a href="#40725254">next</a><span>|</span><label class="collapse" for="c-40723825">[-]</label><label class="expand" for="c-40723825">[9 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure this happens. But ... most websites I load up have like a dozen things trying to gather data, whether for tracking, visitor analytics, observability, etc. Every time I view a page, multiple new unimportant messages are being sent out, and presumably processed asynchronously. Every time I order something, after I get the order confirmation page, I get an email and possibly a text message, both of which should presumably happen asynchronously, and possibly passing through the hands of more than one SaaS product en route. So given what seems to be the large volume of async messages, in varying&#x2F;spiking volumes, possibly interacting with 3rd party services which will sometimes experience outages ... I gotta expect that a bunch of these systems are solving &quot;actual business problems&quot; of separating out work that can be done later&#x2F;elsewhere, can fail and be retried without causing disruptions, etc in order to ensure the work that must happen immediately is protected.</div><br/><div id="40723870" class="c"><input type="checkbox" id="c-40723870" checked=""/><div class="controls bullet"><span class="by">silverquiet</span><span>|</span><a href="#40723688">root</a><span>|</span><a href="#40723825">parent</a><span>|</span><a href="#40723912">next</a><span>|</span><label class="collapse" for="c-40723870">[-]</label><label class="expand" for="c-40723870">[2 more]</label></div><br/><div class="children"><div class="content">Bingo - I work on the backend of a medical system and basically anything that interacts with a 3rd party gets put into a queue so our application doesn&#x27;t choke immediately when one of them has issues. We also have some uses for it within our system.<p>As far as the question, I was thinking that queues have probably just become a standard aspect of modern distributed systems; it&#x27;s considered a pretty foundational cloud service for any provider (though we just run RabbitMQ ourselves and it has worked well for us).</div><br/></div></div><div id="40723912" class="c"><input type="checkbox" id="c-40723912" checked=""/><div class="controls bullet"><span class="by">bigiain</span><span>|</span><a href="#40723688">root</a><span>|</span><a href="#40723825">parent</a><span>|</span><a href="#40723870">prev</a><span>|</span><a href="#40723900">next</a><span>|</span><label class="collapse" for="c-40723912">[-]</label><label class="expand" for="c-40723912">[3 more]</label></div><br/><div class="children"><div class="content">Tracking, visitor analytics, and observability type things are all (in general) going out to 3rd party specialist services for those things, and getting dropped into a time series database (or, for us old school gray beards, a log file) and processed later. It&#x27;s rare for the website devs to be doing anything more complex that adding in even more javascript to their pages for those, no need to message queues for that.<p>Order confirmation emails and sms messages are triggered by the order submission, and again usually sent off to a 3rd party bulk email or SMS service. Twilio or Campaign Monitor or Mailchimp will have queues and retry mechanisms, but again the website devs are just firing off an API call to some 3rd party that&#x27;s dealing with that.<p>So there are no doubt message queues being used in non-sexy 3rd party services, but those companies probably consider that kind of thing to be their &quot;secret sauce&quot; and don&#x27;t blog about it.</div><br/><div id="40725008" class="c"><input type="checkbox" id="c-40725008" checked=""/><div class="controls bullet"><span class="by">KronisLV</span><span>|</span><a href="#40723688">root</a><span>|</span><a href="#40723912">parent</a><span>|</span><a href="#40723900">next</a><span>|</span><label class="collapse" for="c-40725008">[-]</label><label class="expand" for="c-40725008">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Order confirmation emails and sms messages are triggered by the order submission, and again usually sent off to a 3rd party bulk email or SMS service. Twilio or Campaign Monitor or Mailchimp will have queues and retry mechanisms, but again the website devs are just firing off an API call to some 3rd party that&#x27;s dealing with that.<p>In my case, I need to compile templates for the e-mails to be sent, which is somewhat slow. Even if I have an in memory cache for the compiled templates that can then be quickly filled in with actual data, I don&#x27;t want to make the first user to request them after a restart&#x2F;flush wait like 4-7 extra seconds upon clicking on the confirm order button (in addition to any other 3rd party calls, checking payment status etc.).<p>Ergo, I need to carry the actual e-mail preparation logic (regardless of whether I send it myself, or use a 3rd party service) out into a separate thread. The problem then is that I most likely don&#x27;t want to create a new thread for every e-mail to be processed, so I need a queue for the requests and one or multiple worker threads. There is functionality for this in the stack I&#x27;m using so no big deal, except I can&#x27;t pass live DB entities across threads, so I also need to serialize the data before passing it off to the queue and deserialize it inside of the queue (or just pass some IDs and do DB calls within the queue).<p>Essentially I&#x27;ve created a simple queue system in the app code, since processing that data definitely shouldn&#x27;t make the user wait on it. I can see why some might also go the extra step and opt for something like RabbitMQ, since at the end of the day my queue system is likely to be way more barebones than something that&#x27;s been around for years. But until a certain point, YAGNI.</div><br/><div id="40725236" class="c"><input type="checkbox" id="c-40725236" checked=""/><div class="controls bullet"><span class="by">mewpmewp2</span><span>|</span><a href="#40723688">root</a><span>|</span><a href="#40725008">parent</a><span>|</span><a href="#40723900">next</a><span>|</span><label class="collapse" for="c-40725236">[-]</label><label class="expand" for="c-40725236">[1 more]</label></div><br/><div class="children"><div class="content">What is taking so long for compiling?<p>And what language are you using? E.g. in NodeJS you can fire of requests without having ti have a new thread or having to wait for it.</div><br/></div></div></div></div></div></div><div id="40723900" class="c"><input type="checkbox" id="c-40723900" checked=""/><div class="controls bullet"><span class="by">grugagag</span><span>|</span><a href="#40723688">root</a><span>|</span><a href="#40723825">parent</a><span>|</span><a href="#40723912">prev</a><span>|</span><a href="#40725254">next</a><span>|</span><label class="collapse" for="c-40723900">[-]</label><label class="expand" for="c-40723900">[3 more]</label></div><br/><div class="children"><div class="content">One word: scale. The services you mention above do require scale if commercial. OP argues and I somewhat agree that lots of resume driven tech was oversold and overused making things more complicated and expensive than they should have. Once tech gets more mature it’s harder do misuse and it is used where real needs arise.</div><br/><div id="40724069" class="c"><input type="checkbox" id="c-40724069" checked=""/><div class="controls bullet"><span class="by">bigiain</span><span>|</span><a href="#40723688">root</a><span>|</span><a href="#40723900">parent</a><span>|</span><a href="#40724623">next</a><span>|</span><label class="collapse" for="c-40724069">[-]</label><label class="expand" for="c-40724069">[1 more]</label></div><br/><div class="children"><div class="content">This is true, but in my opinion badly misunderstood.<p>There are a huge number of &quot;commercial&quot; things that are hitting several million dollars a month in revenue running Ruby On Rails or WordPress&#x2F;PHP. You can scale a long long way with &quot;boring technology&quot;.<p>Way too many people think that are &quot;the unicorn&quot; who&#x27;s user base is going to grow so quickly that then need billion simultaneous user scale right now - instead of realising that before they get even close to that they&#x27;ll be generating enough revenue to have an engineering team of hundreds who will have rewritten everything two or three times with more suitable architectures already.<p>If you need a billion users to turn a profit, then whether you admit it or not your business model is &quot;burn VC money until they stop giving it to us or we pivot using Doctorow&#x27;s Enshittification blog posts as a guide book&quot;. That though, is a vanishingly small percentage of all dev work. Most business models have a way too make real profits of thousands or perhaps tens or hundreds of thousands of transactions a month - and they should be rolling in profit to reinvest in future higher scale development well before they run out of fairly pedestrian &quot;boring technology&quot; platforms. Horizontally scalable Java&#x2F;PHP&#x2F;Ruby&#x2F;Node with vertically scaling databases on you cloud provider of choice is a well known and battle tested way to generate real value and cashflow in probably 99% of all businesses.</div><br/></div></div><div id="40724623" class="c"><input type="checkbox" id="c-40724623" checked=""/><div class="controls bullet"><span class="by">digger495</span><span>|</span><a href="#40723688">root</a><span>|</span><a href="#40723900">parent</a><span>|</span><a href="#40724069">prev</a><span>|</span><a href="#40725254">next</a><span>|</span><label class="collapse" for="c-40724623">[-]</label><label class="expand" for="c-40724623">[1 more]</label></div><br/><div class="children"><div class="content">&quot;MongoDB is web scale&quot;</div><br/></div></div></div></div></div></div><div id="40725254" class="c"><input type="checkbox" id="c-40725254" checked=""/><div class="controls bullet"><span class="by">onion2k</span><span>|</span><a href="#40723688">parent</a><span>|</span><a href="#40723825">prev</a><span>|</span><a href="#40725609">next</a><span>|</span><label class="collapse" for="c-40725254">[-]</label><label class="expand" for="c-40725254">[1 more]</label></div><br/><div class="children"><div class="content"><i>Anything</i> can be &#x27;resume driven design&#x27;. If someone is rewarded with a raise, promotion, or even just praise sometimes, for applying a technology to a problem without being required to prove if the technology is appropriate they&#x27;ll find a way to jam that tech into their domain regardless.<p>Sometimes that promotion is rewarded by going a different company while being able to say &quot;yes, I used X in my previous role.&quot;</div><br/></div></div><div id="40725609" class="c"><input type="checkbox" id="c-40725609" checked=""/><div class="controls bullet"><span class="by">o999</span><span>|</span><a href="#40723688">parent</a><span>|</span><a href="#40725254">prev</a><span>|</span><a href="#40724581">next</a><span>|</span><label class="collapse" for="c-40725609">[-]</label><label class="expand" for="c-40725609">[1 more]</label></div><br/><div class="children"><div class="content">I have also seen a lot of cases where engineers would use the more unnecessarily complex structure on purpose to make themselves less replaceable, as it would take longer time for newcomers to get familiar with the environment deployed.</div><br/></div></div><div id="40724581" class="c"><input type="checkbox" id="c-40724581" checked=""/><div class="controls bullet"><span class="by">erikerikson</span><span>|</span><a href="#40723688">parent</a><span>|</span><a href="#40725609">prev</a><span>|</span><a href="#40725751">next</a><span>|</span><label class="collapse" for="c-40724581">[-]</label><label class="expand" for="c-40724581">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s simply that the complexity rises and more people are employed which then create fiefdoms to simplify and deliniate responsibilities.</div><br/></div></div></div></div><div id="40725751" class="c"><input type="checkbox" id="c-40725751" checked=""/><div class="controls bullet"><span class="by">busterarm</span><span>|</span><a href="#40723688">prev</a><span>|</span><a href="#40723585">next</a><span>|</span><label class="collapse" for="c-40725751">[-]</label><label class="expand" for="c-40725751">[8 more]</label></div><br/><div class="children"><div class="content">Going to give the unpopular answer.  Queues, Streams and Pub&#x2F;Sub are poorly understood concepts by most engineers.  They don&#x27;t know when they need them, don&#x27;t know how to use them properly and choose to use them for the wrong things.  I still work with all of the above (SQS&#x2F;SNS&#x2F;RabbitMQ&#x2F;Kafka&#x2F;Google Pub&#x2F;Sub).<p>I work at a company that only hires the best and brightest engineers from the top 3-4 schools in North America and for almost every engineer here this is their first job.<p>My engineers have done crazy things like:<p>- Try to queue up tens of thousands of 100mb messages in RabbitMQ instantaneously and wonder why it blows up.<p>- Send significantly oversized messages in RabbitMQ in general despite all of the warnings saying not to do this<p>- Start new projects in 2024 on the latest RabbitMQ version and try to use classic queues<p>- Creating quorum queues without replication policies or doing literally anything to make them HA.<p>- Expose clusters on the internet with the admin user being guest&#x2F;guest.<p>- The most senior architect in the org declared a new architecture pattern, held an organization-wide meeting and demo to extol the new virtues&#x2F;pattern of ... sticking messages into a queue and then creating a backchannel so that a second consumer could process those queued messages on demand, out of order (and making it no longer a queue). And nobody except me said &quot;why are you putting messages that you need to process out of order into a queue?&quot;...and the &#x27;pattern&#x27; caught on!<p>- Use Kafka as a basic message queue<p>- Send data from a central datacenter to globally distributed datacenters with a global lock on the object and all operations on it until each target DC confirms it has received the updated object. Insist that this process is asynchronous, because the data was sent with AJAX requests.<p>As it turns out, people don&#x27;t really need to do all that great of a job and we still get by. So tools get misused, overused and underused.<p>In the places where it&#x27;s being used well, you probably just don&#x27;t hear about it.<p>Edit: I forgot to list something significant. There&#x27;s over 30 microservices in our org to every 1 engineer.  Please kill me. I would literally rather Kurt Cobain myself than work at another organization that has thousands of microservices in a gigantic monorepo.</div><br/><div id="40726312" class="c"><input type="checkbox" id="c-40726312" checked=""/><div class="controls bullet"><span class="by">bsaul</span><span>|</span><a href="#40725751">parent</a><span>|</span><a href="#40726142">next</a><span>|</span><label class="collapse" for="c-40726312">[-]</label><label class="expand" for="c-40726312">[1 more]</label></div><br/><div class="children"><div class="content">« Use kafka as a basic message queue ». Since i’m guilty of that (i use kafka as the backbone for pretty much any service 2 service communication) i wonder why you think that’s wrong</div><br/></div></div><div id="40726142" class="c"><input type="checkbox" id="c-40726142" checked=""/><div class="controls bullet"><span class="by">EVa5I7bHFq9mnYK</span><span>|</span><a href="#40725751">parent</a><span>|</span><a href="#40726312">prev</a><span>|</span><a href="#40726122">next</a><span>|</span><label class="collapse" for="c-40726142">[-]</label><label class="expand" for="c-40726142">[1 more]</label></div><br/><div class="children"><div class="content">Because JS is single threaded, and an average programmer today is too dumb to learn any language beyond JS, you must build everything into &quot;microservices&quot;.</div><br/></div></div><div id="40726122" class="c"><input type="checkbox" id="c-40726122" checked=""/><div class="controls bullet"><span class="by">spacebanana7</span><span>|</span><a href="#40725751">parent</a><span>|</span><a href="#40726142">prev</a><span>|</span><a href="#40725827">next</a><span>|</span><label class="collapse" for="c-40726122">[-]</label><label class="expand" for="c-40726122">[1 more]</label></div><br/><div class="children"><div class="content">Raw intelligence is of limited help when working in an area that requires lots of highly depreciating domain specific knowledge.<p>Relatively few graduates know their way around the Snowflake API, or the art of making an electron app not perform terribly. Even sending an email on the modern internet can require a lot of intuition and hidden knowledge.<p>&gt; There&#x27;s over 30 microservices in our org to every 1 engineer<p>I wonder if this a factor in making onboarding of new hires difficult?</div><br/></div></div><div id="40725827" class="c"><input type="checkbox" id="c-40725827" checked=""/><div class="controls bullet"><span class="by">scary-size</span><span>|</span><a href="#40725751">parent</a><span>|</span><a href="#40726122">prev</a><span>|</span><a href="#40723585">next</a><span>|</span><label class="collapse" for="c-40725827">[-]</label><label class="expand" for="c-40725827">[4 more]</label></div><br/><div class="children"><div class="content">That doesn’t sound like hiring the only „brightest“.</div><br/><div id="40725833" class="c"><input type="checkbox" id="c-40725833" checked=""/><div class="controls bullet"><span class="by">busterarm</span><span>|</span><a href="#40725751">root</a><span>|</span><a href="#40725827">parent</a><span>|</span><a href="#40723585">next</a><span>|</span><label class="collapse" for="c-40725833">[-]</label><label class="expand" for="c-40725833">[3 more]</label></div><br/><div class="children"><div class="content">But we only hire from MIT, Waterloo, CMU, etc!<p>No, truly, I feel you.  The Waterloo kids are literally cut from a different cloth though I&#x27;ll take one of them to ten of anyone else.  I feel really guilty about grabbing young grads with all that potential and putting them through this...<p>Grads aren&#x27;t expected to know anything. It&#x27;s all the early ex-google hiring that fucked us.</div><br/><div id="40725977" class="c"><input type="checkbox" id="c-40725977" checked=""/><div class="controls bullet"><span class="by">scary-size</span><span>|</span><a href="#40725751">root</a><span>|</span><a href="#40725833">parent</a><span>|</span><a href="#40723585">next</a><span>|</span><label class="collapse" for="c-40725977">[-]</label><label class="expand" for="c-40725977">[2 more]</label></div><br/><div class="children"><div class="content">Not sure how big your company is and how large your influence. But it sounds to me like your new hires would benefit from more guidance and oversight. Those mistakes shouldn’t make it production unless nobody gives a damn.</div><br/><div id="40726020" class="c"><input type="checkbox" id="c-40726020" checked=""/><div class="controls bullet"><span class="by">busterarm</span><span>|</span><a href="#40725751">root</a><span>|</span><a href="#40725977">parent</a><span>|</span><a href="#40723585">next</a><span>|</span><label class="collapse" for="c-40726020">[-]</label><label class="expand" for="c-40726020">[1 more]</label></div><br/><div class="children"><div class="content">I keep the platform systems running, so they aren&#x27;t my responsibility, but as their profession used to be mine I think the way they do things is more than a bit mad.  Had COVID not upended absolutely everything, I would have moved on years ago.  I believe I&#x27;ll be here until the industry winds change significantly.<p>I do get to slam my foot down on some things from time to time -- usually for compliance reasons. Like now when people tell me they need credentials for things so they can run their code in dev on their laptops, I tell them no and that they can use mocks for their testing like a professional.<p>Funnily the junior people expect and have no problem with this -- it&#x27;s the seasoned folks who chafe and complain.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40723585" class="c"><input type="checkbox" id="c-40723585" checked=""/><div class="controls bullet"><span class="by">tuckerconnelly</span><span>|</span><a href="#40725751">prev</a><span>|</span><a href="#40726205">next</a><span>|</span><label class="collapse" for="c-40723585">[-]</label><label class="expand" for="c-40723585">[37 more]</label></div><br/><div class="children"><div class="content">I can offer one data point. This is from purely startup-based experience (seed to Series A).<p>A while ago I moved from microservices to monolith because they were too complicated and had a lot of duplicated code. Without microservices there&#x27;s less need for a message queue.<p>For async stuff, I used RabbitMQ for one project, but it just felt...old and over-architected? And a lot of the tooling around it (celery) just wasn&#x27;t as good as the modern stuff built around redis (bullmq).<p>For multi-step, DAG-style processes, I prefer to KISS and just do that all in a single, large job if I can, or break it into a small number of jobs.<p>If I REALLY needed a DAG thing, there are tools out there that are specifically built for that (Airflow). But I hear they&#x27;re difficult to debug issues in, so would avoid at most costs.<p>I have run into scaling issues with redis, because their multi-node architectures are just ridiculously over-complicated, and so I stick with single-node. But sharding by hand is fine for me, and works well.</div><br/><div id="40724911" class="c"><input type="checkbox" id="c-40724911" checked=""/><div class="controls bullet"><span class="by">appplication</span><span>|</span><a href="#40723585">parent</a><span>|</span><a href="#40723889">next</a><span>|</span><label class="collapse" for="c-40724911">[-]</label><label class="expand" for="c-40724911">[6 more]</label></div><br/><div class="children"><div class="content">To your comment on Airflow, I’ve been around that block a few times. I’ve found Airflow (and really any orchestration) be the most manageable when it’s nearly devoid of all logic to the point of DAGs being little more than a series of function or API calls, with each of those responsible for managing state transfer to the next call (as opposed to relying on orchestration to do so).<p>For example, you need some ETL to happen every day.  Instead of having your pipeline logic inside an airflow task, you put your logic in a library, where you can test and establish boundaries for this behavior in isolation, and compose this logic portably into any system that can accept your library code. When you need to orchestrate, you just call this function inside an airflow task.<p>This has a few benefits. You now decouple, to a significant extent, your logic and state transfer from your orchestration. That means if you want to debug your DAG, you don’t need to do it in Airflow. You can take the same series of function calls and run them, for example, sequentially in a notebook and you would achieve the same effect. This also can reveal just how little logic you really need in orchestration.<p>There are some other tricks to making this work really well, such as reducing dependency injection to primatives only where possible, and focusing on decoupling logic from configuration. Some of this is pretty standard, but I’ve seen teams not have a strong philosophy on this and then struggle with maintaining clean orchestration interfaces.</div><br/><div id="40725626" class="c"><input type="checkbox" id="c-40725626" checked=""/><div class="controls bullet"><span class="by">flir</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40724911">parent</a><span>|</span><a href="#40725200">next</a><span>|</span><label class="collapse" for="c-40725626">[-]</label><label class="expand" for="c-40725626">[2 more]</label></div><br/><div class="children"><div class="content">Ok, so question (because I really like the DAG approach in principle but don&#x27;t have enough experience to have had my fingers burned yet):<p>The way you use Airflow, what advantage does it have over crontab? Or to put it another way, once you remove the pipeline logic, what&#x27;s left?</div><br/><div id="40725865" class="c"><input type="checkbox" id="c-40725865" checked=""/><div class="controls bullet"><span class="by">salomonk_mur</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40725626">parent</a><span>|</span><a href="#40725200">next</a><span>|</span><label class="collapse" for="c-40725865">[-]</label><label class="expand" for="c-40725865">[1 more]</label></div><br/><div class="children"><div class="content">Observability is a huge upside.</div><br/></div></div></div></div><div id="40725200" class="c"><input type="checkbox" id="c-40725200" checked=""/><div class="controls bullet"><span class="by">RangerScience</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40724911">parent</a><span>|</span><a href="#40725626">prev</a><span>|</span><a href="#40723889">next</a><span>|</span><label class="collapse" for="c-40725200">[-]</label><label class="expand" for="c-40725200">[3 more]</label></div><br/><div class="children"><div class="content">Helpful comment! If I could pick your brain...<p>I&#x27;m looking at a green field implementation of a task system, for human tasks - people need to do a thing, and then mark that they&#x27;ve done it, and that &quot;unlocks&quot; subsequent human tasks, and near as I can tell the overall task flow <i>is</i> a DAG.<p>I&#x27;m currently considering how (if?) to allow for complex logic about things like <i>which</i> tasks are present in the overall DAG - things like skipping a node based on some criteria (which, it occurs to me in typing this up, can benefit from your above advice, as that can just be a configured function call that returns skip&#x2F;no-skip) - and, well... thoughts? (:</div><br/><div id="40726016" class="c"><input type="checkbox" id="c-40726016" checked=""/><div class="controls bullet"><span class="by">jatcwang</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40725200">parent</a><span>|</span><a href="#40725397">next</a><span>|</span><label class="collapse" for="c-40726016">[-]</label><label class="expand" for="c-40726016">[1 more]</label></div><br/><div class="children"><div class="content">Have you looked into temporal.io? It supports dynamic workflows.</div><br/></div></div><div id="40725397" class="c"><input type="checkbox" id="c-40725397" checked=""/><div class="controls bullet"><span class="by">rich_sasha</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40725200">parent</a><span>|</span><a href="#40726016">prev</a><span>|</span><a href="#40723889">next</a><span>|</span><label class="collapse" for="c-40725397">[-]</label><label class="expand" for="c-40725397">[1 more]</label></div><br/><div class="children"><div class="content">Not GP or specifically Airflow user; but my approach is to have a fixed job graph, and unnecessary jobs immediately succeed. And indeed, jobs are external executables, with all the skip&#x2F;no skip logic executed therein.<p>If nothing else, it makes it easy to understand what actually happened and when - just look at job logs.</div><br/></div></div></div></div></div></div><div id="40723889" class="c"><input type="checkbox" id="c-40723889" checked=""/><div class="controls bullet"><span class="by">kypro</span><span>|</span><a href="#40723585">parent</a><span>|</span><a href="#40724911">prev</a><span>|</span><a href="#40726205">next</a><span>|</span><label class="collapse" for="c-40723889">[-]</label><label class="expand" for="c-40723889">[30 more]</label></div><br/><div class="children"><div class="content">In my experience monoliths don&#x27;t reduce complexity, they just shift it. The main issue with monoliths is that they don&#x27;t have clear and explicit separation of concern between domain concerns, therefore it&#x27;s very easy for your monolith codebase to devolve into a mess of highly interconnected spaghetti code with time. This is especially true if you&#x27;re building something large with a lot of developers who don&#x27;t necessarily understand all of the domain complexity of the code they&#x27;re touching.<p>Monoliths imo are better for smaller projects with a few devs, but otherwise within a few years most of the time you&#x27;ll regret building a monolith.<p>I also disagree with the duplicated code point. I don&#x27;t understand why that would be a significant problem assuming you&#x27;re using the same language and sharing packages between projects. This isn&#x27;t a problem I&#x27;ve ever had while working on microservices anyway. I&#x27;d also debate whether they&#x27;re anymore more complex than monoliths on average. My favourite thing about microservice architecture is how simple individual microservices are to understand and contribute to. The architecture and provisioning of microservices can be more complicated, but from the perspective of a developer working on a microservice it should be much simpler to work on compared to a monolith.</div><br/><div id="40724454" class="c"><input type="checkbox" id="c-40724454" checked=""/><div class="controls bullet"><span class="by">wg0</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40723889">parent</a><span>|</span><a href="#40724376">next</a><span>|</span><label class="collapse" for="c-40724454">[-]</label><label class="expand" for="c-40724454">[5 more]</label></div><br/><div class="children"><div class="content">I think lots of microservices can be replaced with a monolith which in turn can be replaced with a set of composable libraries versioned separately.<p>If anyone doubts that, this very browser used to read and write is built all the way up with dozens of libraries from compression, network, image encoding, decoding, video encoding decoding, encryption, graphics, sound and what not where each library is totally separate and sometimes was never intended to be used to build web browsers by the original authors.<p>Rest assured, most of the business (or web 2.0 systems, search, curate, recommend, surface etc kind of) systems are a lot more simpler then an A class browser.</div><br/><div id="40725419" class="c"><input type="checkbox" id="c-40725419" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40724454">parent</a><span>|</span><a href="#40724718">next</a><span>|</span><label class="collapse" for="c-40725419">[-]</label><label class="expand" for="c-40725419">[3 more]</label></div><br/><div class="children"><div class="content">If you are using Chrome, it&#x27;s also a combination of multiple well separated processes talking via RPC with each other, which is pretty similar to microservices, although the separation boundaries are more influenced by attack mitigation requirements than your typical microservice architecture would be.</div><br/><div id="40725591" class="c"><input type="checkbox" id="c-40725591" checked=""/><div class="controls bullet"><span class="by">wg0</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40725419">parent</a><span>|</span><a href="#40726073">next</a><span>|</span><label class="collapse" for="c-40725591">[-]</label><label class="expand" for="c-40725591">[1 more]</label></div><br/><div class="children"><div class="content">And even that process separation is spinning up more processes from within the same binary or build artefact. The usual fork() and CreateProcessW() etc and then wait on them.<p>Unlike in Microservices where each process is possibly a totally different language, runtime and framework spun up individually that too possibly in totally different ways.</div><br/></div></div><div id="40726073" class="c"><input type="checkbox" id="c-40726073" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40725419">parent</a><span>|</span><a href="#40725591">prev</a><span>|</span><a href="#40724718">next</a><span>|</span><label class="collapse" for="c-40726073">[-]</label><label class="expand" for="c-40726073">[1 more]</label></div><br/><div class="children"><div class="content">But that’s due to security, not for any supposed benefit of microservices. Also, both processes are from the same repo sharing code, so I wouldn’t really qualify as microservice.</div><br/></div></div></div></div></div></div><div id="40724376" class="c"><input type="checkbox" id="c-40724376" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40723889">parent</a><span>|</span><a href="#40724454">prev</a><span>|</span><a href="#40724932">next</a><span>|</span><label class="collapse" for="c-40724376">[-]</label><label class="expand" for="c-40724376">[1 more]</label></div><br/><div class="children"><div class="content">In my experience, the biggest issue with microservices is that they convert nice errors with a stack trace to network errors. Unless you also invest heavily in observability (usually using expensive tools), running and debugging monoliths generally seems easier</div><br/></div></div><div id="40724932" class="c"><input type="checkbox" id="c-40724932" checked=""/><div class="controls bullet"><span class="by">casperb</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40723889">parent</a><span>|</span><a href="#40724376">prev</a><span>|</span><a href="#40724634">next</a><span>|</span><label class="collapse" for="c-40724932">[-]</label><label class="expand" for="c-40724932">[3 more]</label></div><br/><div class="children"><div class="content">These blanked statements about monoliths are what made every junior dev think that microservices are the only solution.<p>If you cannot make a clean monolith, I have never seen any evidence that the same team can make good microservices. It is just the same crap, but distributed.<p>The last 2 years I see more and more seasoned devs who think the opposite: monoliths are better for most projects.</div><br/><div id="40725014" class="c"><input type="checkbox" id="c-40725014" checked=""/><div class="controls bullet"><span class="by">The_Colonel</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40724932">parent</a><span>|</span><a href="#40725708">next</a><span>|</span><label class="collapse" for="c-40725014">[-]</label><label class="expand" for="c-40725014">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It is just the same crap, but distributed.<p>Yes, but also - more difficult to refactor, more difficult to debug (good luck tracking a business transaction over multiple async services), slower with network overhead, lack of ACID transactions... Microservices solve problems which few projects have, but adds a huge amount of complexity.</div><br/></div></div><div id="40725708" class="c"><input type="checkbox" id="c-40725708" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40724932">parent</a><span>|</span><a href="#40725014">prev</a><span>|</span><a href="#40724634">next</a><span>|</span><label class="collapse" for="c-40725708">[-]</label><label class="expand" for="c-40725708">[1 more]</label></div><br/><div class="children"><div class="content">monoliths are the postgres of architectures - keep it simple until you really can&#x27;t, not until you think you can&#x27;t.</div><br/></div></div></div></div><div id="40724634" class="c"><input type="checkbox" id="c-40724634" checked=""/><div class="controls bullet"><span class="by">fouc</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40723889">parent</a><span>|</span><a href="#40724932">prev</a><span>|</span><a href="#40724648">next</a><span>|</span><label class="collapse" for="c-40724634">[-]</label><label class="expand" for="c-40724634">[3 more]</label></div><br/><div class="children"><div class="content">Who says monoliths don&#x27;t have clear and explicit separation of concern between domain concerns?  I think that just comes down to how the codebase is organized and how disciplined the team is, or possibly breaking out core parts into separate libraries or other similar strategies - technically it&#x27;s still a monolith.</div><br/><div id="40724819" class="c"><input type="checkbox" id="c-40724819" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40724634">parent</a><span>|</span><a href="#40724648">next</a><span>|</span><label class="collapse" for="c-40724819">[-]</label><label class="expand" for="c-40724819">[2 more]</label></div><br/><div class="children"><div class="content">Libraries are a great way to manage separation of concerns.  Any dependency you add has to be explicit.  There&#x27;s nothing stopping you from adding that dependency but you can&#x27;t just do it accidentally.<p>The graph of dependencies between components makes for explicit separation of concerns just like you would have a graph of dependencies between different network services.</div><br/><div id="40725435" class="c"><input type="checkbox" id="c-40725435" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40724819">parent</a><span>|</span><a href="#40724648">next</a><span>|</span><label class="collapse" for="c-40725435">[-]</label><label class="expand" for="c-40725435">[1 more]</label></div><br/><div class="children"><div class="content">Or you just use a language with support for clear module API boundaries (vs something like Ruby where without bolt on hacks, every piece of code can call any other in the same process).</div><br/></div></div></div></div></div></div><div id="40724648" class="c"><input type="checkbox" id="c-40724648" checked=""/><div class="controls bullet"><span class="by">btilly</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40723889">parent</a><span>|</span><a href="#40724634">prev</a><span>|</span><a href="#40725063">next</a><span>|</span><label class="collapse" for="c-40724648">[-]</label><label class="expand" for="c-40724648">[1 more]</label></div><br/><div class="children"><div class="content">The lower cost of a function call versus any microservice network call is a good performance advantage of a monolith. Monoliths also make refactoring code a lot easier. While in theory I agree about the spaghetti issue, in practice I haven&#x27;t seen much of a difference. In part because microservices seem to encourage proactive overdesigning, and then the designs don&#x27;t age well.<p>I also find monoliths a lot easier to debug. You have the whole call stack, and you get rid of a lot of potential sources of latency problems. You don&#x27;t have RPC calls that might sometimes get forgotten.<p>Given the choice, I&#x27;d choose monolith every time. Unless, of course, microservices are needed for various other reasons. (Scale, the ability to distribute, etc.)</div><br/></div></div><div id="40725063" class="c"><input type="checkbox" id="c-40725063" checked=""/><div class="controls bullet"><span class="by">dasil003</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40723889">parent</a><span>|</span><a href="#40724648">prev</a><span>|</span><a href="#40724802">next</a><span>|</span><label class="collapse" for="c-40725063">[-]</label><label class="expand" for="c-40725063">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>My favourite thing about microservice architecture is how simple individual microservices are to understand and contribute to.</i><p>Whether this is good depends on the type of changes you need to make.  Just as you mentioned maintaining modularity in a  monolith can be difficult with entropy tending to push the code to spaghetti, there is an equivalent risk in microservices where developers duplicate code or hack around things locally versus making the effort to change the interfaces between microservices where it would make sense.<p>Ultimately microservices add structure that may be useful for large enough teams, but is still overhead that has to earn its keep.</div><br/></div></div><div id="40724802" class="c"><input type="checkbox" id="c-40724802" checked=""/><div class="controls bullet"><span class="by">matrix87</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40723889">parent</a><span>|</span><a href="#40725063">prev</a><span>|</span><a href="#40724401">next</a><span>|</span><label class="collapse" for="c-40724802">[-]</label><label class="expand" for="c-40724802">[4 more]</label></div><br/><div class="children"><div class="content">Microservices also introduce the issue of maintaining schema compatibility for messages between services which usually leads to additional code in order to maintain backward compatibility<p>From a technical POV they are good for horizontally scaling different workloads which have a different resource footprint<p>From my experience, when a company decides to go the microservice route, it&#x27;s more for the sake of solving an organizational problem (e.g. making team responsibilities and oncall escalation more clear cut) than it is to solve a technical problem. Sometimes they will retroactively cite the technical benefit as the reason for using them, but it feels like more of an afterthought<p>But in all honesty: microservices are very good at solving this organizational problem. If microservice x breaks, ping line manager y who manages it. Very straightforward</div><br/><div id="40725284" class="c"><input type="checkbox" id="c-40725284" checked=""/><div class="controls bullet"><span class="by">mewpmewp2</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40724802">parent</a><span>|</span><a href="#40725268">next</a><span>|</span><label class="collapse" for="c-40725284">[-]</label><label class="expand" for="c-40725284">[1 more]</label></div><br/><div class="children"><div class="content">You could do that with code owners file in a monolith as well.</div><br/></div></div><div id="40725268" class="c"><input type="checkbox" id="c-40725268" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40724802">parent</a><span>|</span><a href="#40725284">prev</a><span>|</span><a href="#40724401">next</a><span>|</span><label class="collapse" for="c-40725268">[-]</label><label class="expand" for="c-40725268">[2 more]</label></div><br/><div class="children"><div class="content">This presupposes that there is more than one line manager.<p>I see people trying to apply micro services architectures to a web app with a single developer.<p>As in literally taking a working monolith written by one person and having that one person split it up into tiny services.<p>It’s madness.</div><br/><div id="40725722" class="c"><input type="checkbox" id="c-40725722" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40725268">parent</a><span>|</span><a href="#40724401">next</a><span>|</span><label class="collapse" for="c-40725722">[-]</label><label class="expand" for="c-40725722">[1 more]</label></div><br/><div class="children"><div class="content">If your goal is to learn kubernetes instead of developing a product, then go for it IMHO, no better way. Just make sure everyone is on board with the idea.</div><br/></div></div></div></div></div></div><div id="40724401" class="c"><input type="checkbox" id="c-40724401" checked=""/><div class="controls bullet"><span class="by">primitivesuave</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40723889">parent</a><span>|</span><a href="#40724802">prev</a><span>|</span><a href="#40724029">next</a><span>|</span><label class="collapse" for="c-40724401">[-]</label><label class="expand" for="c-40724401">[5 more]</label></div><br/><div class="children"><div class="content">Amazing this was downvoted. The comment starts with &quot;in my experience&quot; and is hardly a controversial perspective. I beg the HN community, stop disincentivizing people from respectively providing a converse opinion, lest this become yet another echo chamber of groupthink.</div><br/><div id="40725287" class="c"><input type="checkbox" id="c-40725287" checked=""/><div class="controls bullet"><span class="by">RangerScience</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40724401">parent</a><span>|</span><a href="#40724513">next</a><span>|</span><label class="collapse" for="c-40725287">[-]</label><label class="expand" for="c-40725287">[1 more]</label></div><br/><div class="children"><div class="content">It relates <i>that</i> there was experience, but not <i>what</i> that experience was - We can read and understand that they&#x27;re reporting their own experience, but that&#x27;s about it.<p>One could say &quot;In my experience, the earth is flat&quot;, but there&#x27;s not much a conversation to be had there.<p>One could say, &quot;In my experience, the earth is flat - I got in my car, went for a drive in one direction, and eventually hit a cliff at the ocean instead of finding myself back where I started&quot;. Now there&#x27;s something to talk about.<p>(To be clear: this is the internet, and a limited communication medium: I&#x27;d assume OP <i>could</i> relate details about their experience, and it&#x27;s totally reasonable that instead of taking the time to do that, they went outside and touched grass)</div><br/></div></div><div id="40724513" class="c"><input type="checkbox" id="c-40724513" checked=""/><div class="controls bullet"><span class="by">kyleyeats</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40724401">parent</a><span>|</span><a href="#40725287">prev</a><span>|</span><a href="#40724709">next</a><span>|</span><label class="collapse" for="c-40724513">[-]</label><label class="expand" for="c-40724513">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s because it didn&#x27;t loop back to queues at any point. It&#x27;s just a tangent on a tired topic.</div><br/></div></div><div id="40724709" class="c"><input type="checkbox" id="c-40724709" checked=""/><div class="controls bullet"><span class="by">snapetom</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40724401">parent</a><span>|</span><a href="#40724513">prev</a><span>|</span><a href="#40724029">next</a><span>|</span><label class="collapse" for="c-40724709">[-]</label><label class="expand" for="c-40724709">[2 more]</label></div><br/><div class="children"><div class="content">We&#x27;ve swung back and it&#x27;s trendy to hate on microservices now, so join in! &#x2F;s</div><br/><div id="40725732" class="c"><input type="checkbox" id="c-40725732" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40724709">parent</a><span>|</span><a href="#40724029">next</a><span>|</span><label class="collapse" for="c-40725732">[-]</label><label class="expand" for="c-40725732">[1 more]</label></div><br/><div class="children"><div class="content">Patiently waiting for common sense to be fashionable. Alas, sensible people are too busy to advocate on the internet.</div><br/></div></div></div></div></div></div><div id="40724029" class="c"><input type="checkbox" id="c-40724029" checked=""/><div class="controls bullet"><span class="by">tstrimple</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40723889">parent</a><span>|</span><a href="#40724401">prev</a><span>|</span><a href="#40726063">next</a><span>|</span><label class="collapse" for="c-40724029">[-]</label><label class="expand" for="c-40724029">[4 more]</label></div><br/><div class="children"><div class="content">Microservices necessarily add more complexity and overhead when compared to a monolith. Just the fact that you have to orchestrate N services instead of just pressing run on a single project demonstrates <i>some</i> of the additional complexity.</div><br/><div id="40724354" class="c"><input type="checkbox" id="c-40724354" checked=""/><div class="controls bullet"><span class="by">erulabs</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40724029">parent</a><span>|</span><a href="#40726063">next</a><span>|</span><label class="collapse" for="c-40724354">[-]</label><label class="expand" for="c-40724354">[3 more]</label></div><br/><div class="children"><div class="content">Counterpoint: a monolith usually contains a complex init system which allows multiple ways of running the codebase. Microservices can avoid at least that one complexity.</div><br/><div id="40724426" class="c"><input type="checkbox" id="c-40724426" checked=""/><div class="controls bullet"><span class="by">devoutsalsa</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40724354">parent</a><span>|</span><a href="#40725042">next</a><span>|</span><label class="collapse" for="c-40724426">[-]</label><label class="expand" for="c-40724426">[1 more]</label></div><br/><div class="children"><div class="content">Another advantage of microservices is that you can avoid the overhead of multiple services by having one really big microservice.</div><br/></div></div><div id="40725042" class="c"><input type="checkbox" id="c-40725042" checked=""/><div class="controls bullet"><span class="by">The_Colonel</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40724354">parent</a><span>|</span><a href="#40724426">prev</a><span>|</span><a href="#40726063">next</a><span>|</span><label class="collapse" for="c-40725042">[-]</label><label class="expand" for="c-40725042">[1 more]</label></div><br/><div class="children"><div class="content">You mean like profiles? Monolith can run like a front service or background worker depending on the config?<p>In a technical sense it is a complexity, but IME pales in comparison with the alternative of having to manage multiple services.<p>I actually really like this model, it&#x27;s pretty flexible. You can still have specialized server instances dedicated for certain tasks, but you have one codebase. What&#x27;s very sweet is that for local development, you just run a single application which (with all enabled profiles) can fulfill all the roles at the same time.</div><br/></div></div></div></div></div></div><div id="40726063" class="c"><input type="checkbox" id="c-40726063" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40723889">parent</a><span>|</span><a href="#40724029">prev</a><span>|</span><a href="#40725209">next</a><span>|</span><label class="collapse" for="c-40726063">[-]</label><label class="expand" for="c-40726063">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In my experience monoliths don&#x27;t reduce complexity, they just shift it<p>This is both true and false in a way. Sure, the same business logic is distributed across microservices, but a method call in a monolith can only fail in a couple of ways, while network calls are much more finicky - handling it in every case is pure added complexity in case of a microservice architecture.<p>Also, don’t forget the observability part - a mainstream language will likely have a sane debugger, profiler, a single log stream, etc. I can easily find bugs, race conditions, slow code paths in a monolith. It’s much more difficult if you have to do it in a whole environment communicating with potentially multiple instances of a single, or multiple microservices.<p>Lastly, we have programming languages to help us write correct, maintainable code! A monolith != spaghetti code. We have language tools to enforce boundaries, we have static analysis, etc. A refactor will work correctly across the whole codebase. We have nothing of this sort for microservices. You might understand a given microservice better, but does <i>anyone</i> understand the whole graph of them? Sure, monoliths might become spaghettis, but microservices can become spaghettis that are tangled with other plates of spaghettis.</div><br/></div></div><div id="40725209" class="c"><input type="checkbox" id="c-40725209" checked=""/><div class="controls bullet"><span class="by">RangerScience</span><span>|</span><a href="#40723585">root</a><span>|</span><a href="#40723889">parent</a><span>|</span><a href="#40726063">prev</a><span>|</span><a href="#40726205">next</a><span>|</span><label class="collapse" for="c-40725209">[-]</label><label class="expand" for="c-40725209">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Cleverness, like complexity, is inevitable. The trick is making sure you&#x27;re getting something worthwhile in exchange.&quot;</div><br/></div></div></div></div></div></div><div id="40726205" class="c"><input type="checkbox" id="c-40726205" checked=""/><div class="controls bullet"><span class="by">KaiserPro</span><span>|</span><a href="#40723585">prev</a><span>|</span><a href="#40726255">next</a><span>|</span><label class="collapse" for="c-40726205">[-]</label><label class="expand" for="c-40726205">[1 more]</label></div><br/><div class="children"><div class="content">I think it depends but to add some noise to the discussion:<p>People really abused kafka: <a href="https:&#x2F;&#x2F;www.confluent.io&#x2F;en-gb&#x2F;blog&#x2F;publishing-apache-kafka-new-york-times&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.confluent.io&#x2F;en-gb&#x2F;blog&#x2F;publishing-apache-kafka-...</a> like really abused it.<p>Kafka is hard to use, has lots of rough edges, doesn&#x27;t scale all that easily, and isn&#x27;t nice to use as a programmer. <i>but</i> you can make it do lots of stupid shit, like turn it into a database.<p>People tried to use message queues for synchronous stuff, or things that should be synchronous, and realised that queuing those requests is a really bad idea. I assume they went back to REST calls or something.<p>Databases are much much faster now, with both SSD, design and fucktonnes of ram. postgres isn&#x27;t really the bottleneck it once was.<p>SQS and NATS cover most of the design usecases for pure message queues (as in no half arse RPC or other feature tacked in) and just works.<p>Message queues are brilliant, I use them a lot, but only for data processing pipelines. But I only use them to pass messages, not actual data. so I might generate a million messages, but each message is &lt;2k<p>could I use a database? probably, but then I&#x27;d have to make an interface for that, and do loads of testing and junk.</div><br/></div></div><div id="40726255" class="c"><input type="checkbox" id="c-40726255" checked=""/><div class="controls bullet"><span class="by">throwaway38375</span><span>|</span><a href="#40726205">prev</a><span>|</span><a href="#40723880">next</a><span>|</span><label class="collapse" for="c-40726255">[-]</label><label class="expand" for="c-40726255">[1 more]</label></div><br/><div class="children"><div class="content">Because you can set up a rudimentary queueing system in MySQL&#x2F;PostgreSQL very quickly these days. And it scales really well for small to medium sized applications!<p>I maintain a web application with a few hundred daily users and with the following table I have never had any problems:<p>CREATE TABLE `jobs` (
  `id` BIGINT NOT NULL AUTO_INCREMENT,
  `queue` VARCHAR NOT NULL,
  `payload` JSON NOT NULL,
  `created_at` DATETIME NOT NULL,
  PRIMARY KEY `id`,
  INDEX `queue`
);<p>Using MySQL&#x27;s LOCK and UNLOCK I can ensure the same job doesn&#x27;t get picked up twice.<p>All in all, it&#x27;s a very simple solution. And simple is better!</div><br/></div></div><div id="40723880" class="c"><input type="checkbox" id="c-40723880" checked=""/><div class="controls bullet"><span class="by">democracy</span><span>|</span><a href="#40726255">prev</a><span>|</span><a href="#40724408">next</a><span>|</span><label class="collapse" for="c-40723880">[-]</label><label class="expand" for="c-40723880">[5 more]</label></div><br/><div class="children"><div class="content">I think this: &quot;* The technology just got mature enough that it&#x27;s not exciting to write about, but it&#x27;s still really widely used.&quot;<p>Messaging-based architecture is very popular</div><br/><div id="40724314" class="c"><input type="checkbox" id="c-40724314" checked=""/><div class="controls bullet"><span class="by">casper14</span><span>|</span><a href="#40723880">parent</a><span>|</span><a href="#40724070">next</a><span>|</span><label class="collapse" for="c-40724314">[-]</label><label class="expand" for="c-40724314">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. It has become a tool just like any other. Just like nobody writes about how they use virtual machines in the cloud anymore.</div><br/></div></div><div id="40724070" class="c"><input type="checkbox" id="c-40724070" checked=""/><div class="controls bullet"><span class="by">bwhaley</span><span>|</span><a href="#40723880">parent</a><span>|</span><a href="#40724314">prev</a><span>|</span><a href="#40724619">next</a><span>|</span><label class="collapse" for="c-40724070">[-]</label><label class="expand" for="c-40724070">[1 more]</label></div><br/><div class="children"><div class="content">This is the answer. I&#x27;d wager that almost every distributed system that runs at scale uses message queues in some capacity.</div><br/></div></div><div id="40724619" class="c"><input type="checkbox" id="c-40724619" checked=""/><div class="controls bullet"><span class="by">spike021</span><span>|</span><a href="#40723880">parent</a><span>|</span><a href="#40724070">prev</a><span>|</span><a href="#40724416">next</a><span>|</span><label class="collapse" for="c-40724619">[-]</label><label class="expand" for="c-40724619">[1 more]</label></div><br/><div class="children"><div class="content">I think that&#x27;s definitely part of it. Two roles ago my team was invested heavily in SQS and Kinesis. The role before that and my current role are pretty heavy with Kafka still.<p>I wouldn&#x27;t call their use super interesting, though.<p>The last role was simply because the business required as close to real time message processing as possible for billing analytics. But if I tell someone that, it&#x27;s not incredibly interesting unless I start diving into messages per second and such.</div><br/></div></div><div id="40724416" class="c"><input type="checkbox" id="c-40724416" checked=""/><div class="controls bullet"><span class="by">ipsum2</span><span>|</span><a href="#40723880">parent</a><span>|</span><a href="#40724619">prev</a><span>|</span><a href="#40724408">next</a><span>|</span><label class="collapse" for="c-40724416">[-]</label><label class="expand" for="c-40724416">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, this is the most likely reason.<p>It used to be popular to post about rewriting angular to react. Now everyone just uses react (or they write posts about rewriting react to vue or whatever the flavor of the month)</div><br/></div></div></div></div><div id="40724408" class="c"><input type="checkbox" id="c-40724408" checked=""/><div class="controls bullet"><span class="by">burutthrow1234</span><span>|</span><a href="#40723880">prev</a><span>|</span><a href="#40723651">next</a><span>|</span><label class="collapse" for="c-40724408">[-]</label><label class="expand" for="c-40724408">[1 more]</label></div><br/><div class="children"><div class="content">I think &quot;message queues&quot; have become pretty commoditized. You can buy Confluent or RedPanda or MSK as a service and never have to administer Kafka yourself.<p>Change Data Capture (CDC) has also gotten really good and mainstream. It&#x27;s relatively easy to write your data to a RDBMS and then capture the change data and propagate it to other systems. This pattern means people aren&#x27;t writing about Kafka, for instance, because the message queue is just the backbone that the CDC system uses to relay messages.<p>These architectures definitely still exist and they mostly satisfy organizational constraints - if you have a write-once, read-many queue like Kafka you&#x27;re exposing an API to other parts of the organization. A lot of companies use this pattern to shuffle data between different teams.<p>A small team owning a lot of microservices feels like resume-driven developnent. But in companies with 100+ engineers it makes sense.</div><br/></div></div><div id="40723651" class="c"><input type="checkbox" id="c-40723651" checked=""/><div class="controls bullet"><span class="by">angarg12</span><span>|</span><a href="#40724408">prev</a><span>|</span><a href="#40726094">next</a><span>|</span><label class="collapse" for="c-40723651">[-]</label><label class="expand" for="c-40723651">[1 more]</label></div><br/><div class="children"><div class="content">Queues are a tool in your distributed system toolbox. When it&#x27;s suitable it works wonderfully (typical caveats apply).<p>If your perception is indeed correct it&#x27;d attribute it to your 3rd point. People usually write blogposts about new shiny stuff.<p>I personally use queues in my design all the time, particularly to transfer data between different systems with higher decoupling. The only pain I have ever experienced was when an upstream system backfilled 7 days of data, which clogged our queues with old requests. Running normally it would have taken over 100 hours to process all the data, while massively increasing the latency of fresh data. The solution was to manually purge the queue, and manually backfill the most recent missing data.<p>Even if you need to be careful around unbound queue sizes I still believe they are a great tool.</div><br/></div></div><div id="40726094" class="c"><input type="checkbox" id="c-40726094" checked=""/><div class="controls bullet"><span class="by">liampulles</span><span>|</span><a href="#40723651">prev</a><span>|</span><a href="#40726092">next</a><span>|</span><label class="collapse" for="c-40726094">[-]</label><label class="expand" for="c-40726094">[1 more]</label></div><br/><div class="children"><div class="content">&quot;The technology just got mature enough that it&#x27;s not exciting to write about, but it&#x27;s still really widely used.&quot;<p>My money is on this. I think the simple usecase of async communication, with simple pub&#x2F;sub messaging, is hugely useful and not too hard to use.<p>We (as a Dev community) have just gotten over event sourcing, complex networks and building for unnecessary scale. I.e. we&#x27;re past the hype cycle.<p>My team uses NATS for Async pub&#x2F;sub and synchronous request&#x2F;response. It&#x27;s a command driven model and we have a huge log table with all the messages we have sent. Schemas and usage of these messages are internal to our team, and are discarded from NATS after consumption. We do at-least-once delivery and message handlers are expected to be idempotent.<p>We have had one or two issues with misconfiguration in NATS resulting in message replay or missed messages, but largely it has been very successful. And we were a 3 person dev team.<p>It&#x27;s the same thing as Kubernetes in my mind - it works well if you keep to the bare essentials and don&#x27;t try to be clever.</div><br/></div></div><div id="40726092" class="c"><input type="checkbox" id="c-40726092" checked=""/><div class="controls bullet"><span class="by">mcqueenjordan</span><span>|</span><a href="#40726094">prev</a><span>|</span><a href="#40723642">next</a><span>|</span><label class="collapse" for="c-40726092">[-]</label><label class="expand" for="c-40726092">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s a mix of:<p>1. Queues are actually used a lot, esp. at high scale, and you just don&#x27;t hear about it.<p>2. Hardware&#x2F;compute advances are outpacing user growth (e.g. 1 billion users 10 years ago was a unicorn; 1 billion users today is still a unicorn), but serving (for the sake of argument) 100 million users on a single large box is much more plausible today than 10 years ago. (These numbers are made up; keep the proportions and adjust as you see fit.)<p>3. Given (2), if you can get away with stuffing your queue into e.g. Redis or a RDBMS, you probably should. It simplifies deployment, architecture, centralizes queries across systems, etc. However, depending on your requirements for scale, reliability, failure (in)dependence, it may not be advisable. I think this is also correlated with a broader understanding that (1) if you can get away with out-of-order task processing, you should, (2) architectural simplicity was underrated in the 2010s industry-wide, (3) YAGNI.</div><br/></div></div><div id="40723642" class="c"><input type="checkbox" id="c-40723642" checked=""/><div class="controls bullet"><span class="by">rossdavidh</span><span>|</span><a href="#40726092">prev</a><span>|</span><a href="#40726121">next</a><span>|</span><label class="collapse" for="c-40723642">[-]</label><label class="expand" for="c-40723642">[2 more]</label></div><br/><div class="children"><div class="content">Message queues have moved on past the &quot;Peak of inflated expectations&quot; and past the &quot;trough of disillusinment&quot; into the &quot;slope of enlightenment&quot;, perhaps even the &quot;plateau of productivity&quot;.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Gartner_hype_cycle" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Gartner_hype_cycle</a></div><br/><div id="40724033" class="c"><input type="checkbox" id="c-40724033" checked=""/><div class="controls bullet"><span class="by">wildzzz</span><span>|</span><a href="#40723642">parent</a><span>|</span><a href="#40726121">next</a><span>|</span><label class="collapse" for="c-40724033">[-]</label><label class="expand" for="c-40724033">[1 more]</label></div><br/><div class="children"><div class="content">I used zmq to build our application used for testing new hardware. Everything comes in via serial every second so I made a basic front end for that serial bus that sends telemetry out over zmq and waits for any commands coming in using pub&#x2F;sub. The front end piece can sit forever sending out telemetry no one ever hears or I can hook up a logger, debug terminal, data plotter, or a factory test GUI that runs scripts or all at once. Dealing with com ports on windows is a huge hassle so zmq lets me abstract those annoyances away as a network socket. Other engineers can develop their own applications custom to their needs and they have. Our old application tried to shove all of this functionality into one massive python script along with trying to update a complicated Tk GUI every second with new telem. The thing was buckling under its own weight and would actually screw up the serial data coming in if you were running a heavy script in another thread. I know there are ways to turn a serial port into a network socket but I wanted something that didn&#x27;t require a server or client to be online for the other to function.</div><br/></div></div></div></div><div id="40726121" class="c"><input type="checkbox" id="c-40726121" checked=""/><div class="controls bullet"><span class="by">tichiian</span><span>|</span><a href="#40723642">prev</a><span>|</span><a href="#40725852">next</a><span>|</span><label class="collapse" for="c-40726121">[-]</label><label class="expand" for="c-40726121">[1 more]</label></div><br/><div class="children"><div class="content">The other answers around here are mostly right, but I&#x27;d like to add another one, which is right in some situations:<p>Message queues are often the wrong tool. Often you rather want something like RPC, and message queues were wrongly used as poor man&#x27;s async DIY RPC.</div><br/></div></div><div id="40725852" class="c"><input type="checkbox" id="c-40725852" checked=""/><div class="controls bullet"><span class="by">ingvar77</span><span>|</span><a href="#40726121">prev</a><span>|</span><a href="#40724429">next</a><span>|</span><label class="collapse" for="c-40725852">[-]</label><label class="expand" for="c-40725852">[1 more]</label></div><br/><div class="children"><div class="content">I am under impression people are still actively using MQs but it’s just become a commodity and not as exciting as it was. I think two major cases - you need to do something asynchronous and in specific order. 
Simple example from past project: in a workflow&#x2F;process management app (task manager on steroids) there’s a group of tasks (branch) that can be completed by multiple people in any order. When all tasks are done we have to mark the whole branch as completed and move workflow further. Many instances of the workflow are running at same time. Logic is much simpler to implement when you process all task completions within same workflow instance in order, but from different instances in parallel. It’s also much easier to provide close to realtime experience to users - when user clicks on a checkbox task is shown completed instantly as well as other effects- next task becomes active, branch shown as completed, whole workflow is shown as completed etc.</div><br/></div></div><div id="40724429" class="c"><input type="checkbox" id="c-40724429" checked=""/><div class="controls bullet"><span class="by">vishnugupta</span><span>|</span><a href="#40725852">prev</a><span>|</span><a href="#40723752">next</a><span>|</span><label class="collapse" for="c-40724429">[-]</label><label class="expand" for="c-40724429">[3 more]</label></div><br/><div class="children"><div class="content">Speaking from my own experience message queues haven’t disappeared as much as have been abstracted away. For example enqueue to SQS + poll became invoke server less process. There is a message queue in there somewhere just that it’s not as exposed.<p>Or take AWS SNS which IMO is one level of abstraction higher than SQS. It became so feature rich that it can practically replace SQS.<p>What might have disappeared is those use cases which used Queues to handle short bursts of peak traffic?<p>Also streaming has become very reliable tech so a class of usecases that used Queues as streaming pipe have migrated to the streaming proper.</div><br/><div id="40725260" class="c"><input type="checkbox" id="c-40725260" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#40724429">parent</a><span>|</span><a href="#40725409">next</a><span>|</span><label class="collapse" for="c-40725260">[-]</label><label class="expand" for="c-40725260">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There is a message queue in there somewhere just that it’s not as exposed.<p>It&#x27;s still pretty exposed.  You can set redelivery timeouts and connect a dead letter queue to lambda functions.  Even just the lambda invoke API is obviously just a funny looking endpoint for adding messages to the queue.<p>&gt; as much as have been abstracted away<p>In AWS in particular into EventBridge which further extends them with state machines.  They&#x27;ve become the very mature corner stone of many technologies.</div><br/></div></div><div id="40725409" class="c"><input type="checkbox" id="c-40725409" checked=""/><div class="controls bullet"><span class="by">1oooqooq</span><span>|</span><a href="#40724429">parent</a><span>|</span><a href="#40725260">prev</a><span>|</span><a href="#40723752">next</a><span>|</span><label class="collapse" for="c-40725409">[-]</label><label class="expand" for="c-40725409">[1 more]</label></div><br/><div class="children"><div class="content">good point. tcp was justified at some point in it&#x27;s birth a queueing component. today nobody dates to think of it as such.</div><br/></div></div></div></div><div id="40723752" class="c"><input type="checkbox" id="c-40723752" checked=""/><div class="controls bullet"><span class="by">pm90</span><span>|</span><a href="#40724429">prev</a><span>|</span><a href="#40723650">next</a><span>|</span><label class="collapse" for="c-40723752">[-]</label><label class="expand" for="c-40723752">[2 more]</label></div><br/><div class="children"><div class="content">They have become boring so there are less blogs about them.<p>Thats good. The documentation for eg RabbitMQ is much better and very helpful. People use it as a workhorse just like they use Postgres&#x2F;MySQL. There’s not much surprising behavior needed to architect around etc.<p>I love boring software.</div><br/><div id="40725872" class="c"><input type="checkbox" id="c-40725872" checked=""/><div class="controls bullet"><span class="by">okokwhatever</span><span>|</span><a href="#40723752">parent</a><span>|</span><a href="#40723650">next</a><span>|</span><label class="collapse" for="c-40725872">[-]</label><label class="expand" for="c-40725872">[1 more]</label></div><br/><div class="children"><div class="content">Agree</div><br/></div></div></div></div><div id="40723650" class="c"><input type="checkbox" id="c-40723650" checked=""/><div class="controls bullet"><span class="by">memset</span><span>|</span><a href="#40723752">prev</a><span>|</span><a href="#40724678">next</a><span>|</span><label class="collapse" for="c-40723650">[-]</label><label class="expand" for="c-40723650">[2 more]</label></div><br/><div class="children"><div class="content">It may be that lambdas (cloud functions, etc) have become more popular and supported on other platforms.<p>When you enqueue something, you eventually need to dequeue and process it. A lambda just does that in a single call. It also removes the need to run or scale a worker.<p>I think Kafka continues to be popular because it is used as a temporary data store, and there is a large ecosystem around ingesting from streams.<p>I personally use queues a lot and am building an open source SQS alternative. I wonder if an open source lambda replacement would be useful too. <a href="https:&#x2F;&#x2F;github.com&#x2F;poundifdef&#x2F;SmoothMQ">https:&#x2F;&#x2F;github.com&#x2F;poundifdef&#x2F;SmoothMQ</a></div><br/><div id="40724427" class="c"><input type="checkbox" id="c-40724427" checked=""/><div class="controls bullet"><span class="by">weitendorf</span><span>|</span><a href="#40723650">parent</a><span>|</span><a href="#40724678">next</a><span>|</span><label class="collapse" for="c-40724427">[-]</label><label class="expand" for="c-40724427">[1 more]</label></div><br/><div class="children"><div class="content">This is a big part of it IMO. When your downstream consumers can scale up and down quickly, you don’t necessarily need anything in the middle to smooth out load unless your workloads are especially spiky.<p>I think this also speaks to a related phenomenon where there are simply more tools and technologies you can buy or run “off the shelf” now. Back in the 2010s everybody was trying to roll their own super complex distributed systems. Nowadays you have a ton of options to pay for more or less polished products to handle that mess for you. No need for engineering meetups and technical blogs about tools that kinda-sorta work if you really know what you’re doing - just pay snowflake or confluent and work on other problems.</div><br/></div></div></div></div><div id="40724678" class="c"><input type="checkbox" id="c-40724678" checked=""/><div class="controls bullet"><span class="by">ilaksh</span><span>|</span><a href="#40723650">prev</a><span>|</span><a href="#40723699">next</a><span>|</span><label class="collapse" for="c-40724678">[-]</label><label class="expand" for="c-40724678">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s simple: async runtimes&#x2F;modules in JavaScript&#x2F;Node, Python (asyncio), and Rust. Those basically handle message queues for you transparently inside of a single application. You end up writing &quot;async&quot; and &quot;await&quot; all over the place, but that&#x27;s all you need to do to get your MVP out. And it will work fine until you really become popular. And then that can actually still work without external queues etc. if you can scale horizontally such as giving each tenant their own container and subdomain or something.<p>There are places where you need a queue just for basic synchronization, but you can use modules that are more convenient than external queues. And you can start testing your program without even doing that.<p>Actually async is being used a lot with Rust also, which can stretch that out to scale even farther with an individual server.<p>Without an async runtime or similar, you have to invent an internal async runtime, or use something like queues, because otherwise you are blocked waiting for IO.<p>You may still eventually end up with queues down the line if you have some large number of users, but that complexity is completely unnecessary for getting a system deployed towards the beginning.</div><br/></div></div><div id="40723699" class="c"><input type="checkbox" id="c-40723699" checked=""/><div class="controls bullet"><span class="by">mrj</span><span>|</span><a href="#40724678">prev</a><span>|</span><a href="#40725418">next</a><span>|</span><label class="collapse" for="c-40723699">[-]</label><label class="expand" for="c-40723699">[1 more]</label></div><br/><div class="children"><div class="content">People got excited about it as a pattern, but usually apps don&#x27;t have that many things that really have to go in the background. And once you do, it becomes really hard to ensure transactional safety across that boundary. Usually that&#x27;s work you want to do in a request in order to return a timely error to the client. So most jobs these days tend to be background things, pre-caching and moving bits around on cdns. But every single one of those comes with a cost and most of us don&#x27;t really want a mess of background jobs or distributed tasks.<p>I just added a RabbitMQ-based worker to replace some jobs that Temporal.io was bad at (previous devs threw everything at it, but it&#x27;s not really suited to high throughput things like email). I&#x27;d bet that Temporal took a chunk of the new greenfield apps mindshare though.</div><br/></div></div><div id="40725418" class="c"><input type="checkbox" id="c-40725418" checked=""/><div class="controls bullet"><span class="by">steve_adams_86</span><span>|</span><a href="#40723699">prev</a><span>|</span><a href="#40725995">next</a><span>|</span><label class="collapse" for="c-40725418">[-]</label><label class="expand" for="c-40725418">[1 more]</label></div><br/><div class="children"><div class="content">The only place I find the complexity of message queues worth the trouble is in the embedded world. The limited resources make messaging a sensible way to communicate across devices with a fairly agnostic perspective on what runs on the devices apart from the message queue.<p>Most of us in the desktop computing world don&#x27;t actually need the distribution, reliability features, implementation-agnostic benefits of a queue. We can integrate our code very directly if we choose to. It seems to me that many of us didn&#x27;t for a while because it was an exciting paradigm, but it rarely made sense in the places I encountered it.<p>There are certainly cases where they&#x27;re extremely useful and I wouldn&#x27;t want anything else, but again, this is typically in settings where I&#x27;m very constrained and need to talk to a lot of devices rather than when writing software for the web or desktop computers.<p>As for your last point, the Internet of Things is driven by message queues (like MQTT), so depending on the type of work you&#x27;re doing, message queues are all over the place but certainly not exciting to write about. It&#x27;s day-to-day stuff that isn&#x27;t rapidly evolving or requiring new exciting insights. It just works.</div><br/></div></div><div id="40725995" class="c"><input type="checkbox" id="c-40725995" checked=""/><div class="controls bullet"><span class="by">fxtentacle</span><span>|</span><a href="#40725418">prev</a><span>|</span><a href="#40725962">next</a><span>|</span><label class="collapse" for="c-40725995">[-]</label><label class="expand" for="c-40725995">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;re using lots of RabbitMQ queues in production. It works well, is efficient, low-maintenance and scales well up to 10k msg&#x2F;s. By all means, I&#x27;d say queues aren&#x27;t unpopular. It&#x27;s just that I&#x27;m not the kind of person to loudly shill whatever tech I&#x27;m using, so you probably won&#x27;t hear from people like me without asking.<p>And for a consulting company, a solid message-based deployment is not a good business strategy. If things just work and temporary load spikes get buffered automatically, there&#x27;s very little reason for clients to buy a maintenance retainer.</div><br/></div></div><div id="40725962" class="c"><input type="checkbox" id="c-40725962" checked=""/><div class="controls bullet"><span class="by">ingvar77</span><span>|</span><a href="#40725995">prev</a><span>|</span><a href="#40723682">next</a><span>|</span><label class="collapse" for="c-40725962">[-]</label><label class="expand" for="c-40725962">[1 more]</label></div><br/><div class="children"><div class="content">A lot of great comments about overcomplicating architectures and using unnecessary tech but also you need to consider that almost any service you can use on aws will cost you less per month than a few hrs of development time.</div><br/></div></div><div id="40723682" class="c"><input type="checkbox" id="c-40723682" checked=""/><div class="controls bullet"><span class="by">m1keil</span><span>|</span><a href="#40725962">prev</a><span>|</span><a href="#40724453">next</a><span>|</span><label class="collapse" for="c-40723682">[-]</label><label class="expand" for="c-40723682">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s all of the above.<p>In large enterprises, there is usually some sort of global message bus on top of Kafka, AWS Kinesis or similar.<p>In smaller shops, the need for dedicated message bus is over engineering and can be avoided by using the db or something like redis. It is still a message queue, just without a dedicated platform.</div><br/></div></div><div id="40724453" class="c"><input type="checkbox" id="c-40724453" checked=""/><div class="controls bullet"><span class="by">ehnto</span><span>|</span><a href="#40723682">prev</a><span>|</span><a href="#40725577">next</a><span>|</span><label class="collapse" for="c-40724453">[-]</label><label class="expand" for="c-40724453">[2 more]</label></div><br/><div class="children"><div class="content">They aren&#x27;t a general solution and don&#x27;t really add much to your average application. But there are still instances where they make a lot of sense.<p>What I would need to see required before bothering with a message queue architecture:<p>* High concurrency, atomic transactions<p>* Multiple stages of processing of a message required<p>* Traceability of process actions required<p>* Event triggers that will actually be used required<p>* Horizontal scaling actually the right choice<p>* Message queues can be the core architecture and not an add on to a Frankenstein API<p>Probably others, and yes you can achieve all of the above without message queues as the core architecture but the above is when I would think &quot;I wonder if this system should be based on async message queues&quot;.</div><br/><div id="40724804" class="c"><input type="checkbox" id="c-40724804" checked=""/><div class="controls bullet"><span class="by">phkx</span><span>|</span><a href="#40724453">parent</a><span>|</span><a href="#40725577">next</a><span>|</span><label class="collapse" for="c-40724804">[-]</label><label class="expand" for="c-40724804">[1 more]</label></div><br/><div class="children"><div class="content">Could you elaborate a little on the traceability part, please? If the different steps of a processing chain are distributed via queues, you rather have an overhead in collecting the information in a central place, I would think.</div><br/></div></div></div></div><div id="40725577" class="c"><input type="checkbox" id="c-40725577" checked=""/><div class="controls bullet"><span class="by">langsoul-com</span><span>|</span><a href="#40724453">prev</a><span>|</span><a href="#40723618">next</a><span>|</span><label class="collapse" for="c-40725577">[-]</label><label class="expand" for="c-40725577">[1 more]</label></div><br/><div class="children"><div class="content">Message based tech is less popular to talk about, not that it&#x27;s less used overall.<p>These days, with AI, vector dbs are all the rage, so everyone hops onto that train.</div><br/></div></div><div id="40723618" class="c"><input type="checkbox" id="c-40723618" checked=""/><div class="controls bullet"><span class="by">ryapric</span><span>|</span><a href="#40725577">prev</a><span>|</span><a href="#40723884">next</a><span>|</span><label class="collapse" for="c-40723618">[-]</label><label class="expand" for="c-40723618">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s very much your last theory -- used everywhere but not as interesting to tell people about as it might have been a decade ago. Queues are now Boring Technology(tm), and that&#x27;s a good thing.</div><br/></div></div><div id="40723884" class="c"><input type="checkbox" id="c-40723884" checked=""/><div class="controls bullet"><span class="by">socketcluster</span><span>|</span><a href="#40723618">prev</a><span>|</span><a href="#40725342">next</a><span>|</span><label class="collapse" for="c-40723884">[-]</label><label class="expand" for="c-40723884">[1 more]</label></div><br/><div class="children"><div class="content">I never fully understood the need for back end message queues TBH. You can just poll the database or data store every few seconds and process tasks in batches... IMO, the &#x27;real time&#x27; aspect was only ever useful for front end use cases for performance reasons since short polling every second with HTTP (with all its headers&#x2F;overheads) is prohibitively expensive. Also, HTTP long polling introduces some architectural complexity which is not worth it (e.g. sticky sessions are required when you have multiple app servers).<p>Unfortunately, moving real-time messaging complexity entirely to the back end has been the norm for a very long time. My experience is that, in general, it makes the architecture way more difficult to manage. I&#x27;ve been promoting end-to-end pub&#x2F;sub as an alternative for over a decade (see <a href="https:&#x2F;&#x2F;socketcluster.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;socketcluster.io&#x2F;</a>) but, although I&#x27;ve been getting great feedback, this approach has never managed to spread beyond a certain niche. I think it&#x27;s partly because most devs just don&#x27;t realize how much complexity is added by micromanaging message queues on the back end and figuring out which message belongs to what client socket instead of letting the clients themselves decide what channels to subscribe to directly from the front end (and the back end only focuses on access control).<p>I think part of the problem was the separation between front end and back end developer responsibilities. Back end developers like to ignore the front end as much as possible; when it comes to architecture, their thinking rarely extends beyond the API endpoint definition; gains which can be made from better integrating the back end with the front end is &#x27;not their job&#x27;. From the perspective of front-end developers, they see anything performance-related or related to &#x27;architectural simplicity&#x27; as &#x27;not their job&#x27; either... There weren&#x27;t enough full stack developers with the required insights to push for integration efficiency&#x2F;simplicity.</div><br/></div></div><div id="40725342" class="c"><input type="checkbox" id="c-40725342" checked=""/><div class="controls bullet"><span class="by">Copenjin</span><span>|</span><a href="#40723884">prev</a><span>|</span><a href="#40724934">next</a><span>|</span><label class="collapse" for="c-40725342">[-]</label><label class="expand" for="c-40725342">[1 more]</label></div><br/><div class="children"><div class="content">I really hope that people are slowly starting to understand that using kafka and turning it in a single point of failure (yes, it fails) of your architecture is not a good idea.<p>This pattern has it&#x27;s uses, but if you are using it everywhere, every time you have some sort of notifications because &quot;it&#x27;s easy&quot; or whatever, you are likely doing it wrong and you will understand this at some point and it will not be pleasant.</div><br/></div></div><div id="40724934" class="c"><input type="checkbox" id="c-40724934" checked=""/><div class="controls bullet"><span class="by">willturman</span><span>|</span><a href="#40725342">prev</a><span>|</span><a href="#40725207">next</a><span>|</span><label class="collapse" for="c-40724934">[-]</label><label class="expand" for="c-40724934">[2 more]</label></div><br/><div class="children"><div class="content">I implemented RabbitMQ based messaging queues as a mechanism to coordinate execution among discrete components of a handful of ambitious laboratory automation systems ~4-8 years ago.<p>Given a recent opportunity to rethink messaging based architectures, I chose the simplicity and flexibility of Redis to implement stack and queue based data-structures accessible across distributed nodes.<p>With even a handful of nodes, it was challenging to coordinate a messaging based system and the overhead of configuring a messaging architecture, essentially developing an ad-hoc messaging schema with each project (typically simple JSON objects), and relatively opaque infrastructure that often required advanced technical support led messaging systems to fall out of favor for me.<p>Kafka seems to be the current flavor of the day as far as messaging based systems, but I don&#x27;t think I&#x27;ll ever support a system that approaches the throughput required to even think about implementing something like Kafka in the laboratory automation space - maybe there&#x27;s a use case for high-content imaging pipelines?<p>Right now, I&#x27;d probably choose Redis for intra-system communication if absolutely necessary, then something like hitting a Zapier webhook with content in a JSON object to route information to a different platform or software context, but I&#x27;m not in a space where I&#x27;m handling Terabytes of data or millions of requests a second.</div><br/><div id="40725430" class="c"><input type="checkbox" id="c-40725430" checked=""/><div class="controls bullet"><span class="by">1oooqooq</span><span>|</span><a href="#40724934">parent</a><span>|</span><a href="#40725207">next</a><span>|</span><label class="collapse" for="c-40725430">[-]</label><label class="expand" for="c-40725430">[1 more]</label></div><br/><div class="children"><div class="content">sounds like you&#x27;re about to reinvent a queueing system on top of redis. in a very painful way.</div><br/></div></div></div></div><div id="40725207" class="c"><input type="checkbox" id="c-40725207" checked=""/><div class="controls bullet"><span class="by">aspyct</span><span>|</span><a href="#40724934">prev</a><span>|</span><label class="collapse" for="c-40725207">[-]</label><label class="expand" for="c-40725207">[3 more]</label></div><br/><div class="children"><div class="content">We have a new project (~ 6 years now) where we implemented a queue with RabbitMQ to temporarily store business events before they are stored in a database for reporting later.<p>It&#x27;s awesome!<p>It absorbs the peaks, smoothes them out, acts as a buffer for when the database is down for upgrades, and I think over all these years we only had one small issue with it.<p>10&#x2F;10 would recommend.</div><br/><div id="40725445" class="c"><input type="checkbox" id="c-40725445" checked=""/><div class="controls bullet"><span class="by">1oooqooq</span><span>|</span><a href="#40725207">parent</a><span>|</span><label class="collapse" for="c-40725445">[-]</label><label class="expand" for="c-40725445">[2 more]</label></div><br/><div class="children"><div class="content">looks like you could have had a blue&#x2F;green DB setup which would give you one less system to maintain and other benefits that a simple queue don&#x27;t provide.<p>also, what do you do when the queue is down?</div><br/><div id="40725825" class="c"><input type="checkbox" id="c-40725825" checked=""/><div class="controls bullet"><span class="by">aspyct</span><span>|</span><a href="#40725207">root</a><span>|</span><a href="#40725445">parent</a><span>|</span><label class="collapse" for="c-40725825">[-]</label><label class="expand" for="c-40725825">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think the queue has ever been down in 6 years. It certainly never was a breaking point.<p>As for the database, yes, we could do blue&#x2F;green I guess, but it&#x27;s a big database and it&#x27;s more cost effective to rely on the queue.<p>To be honest, I&#x27;m not even sure blue&#x2F;green would be an option given our constraints.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>