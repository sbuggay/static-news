<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1706691660760" as="style"/><link rel="stylesheet" href="styles.css?v=1706691660760"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://pythonspeed.com/articles/numba-profiling/">Profiling your Numba code</a>Â <span class="domain">(<a href="https://pythonspeed.com">pythonspeed.com</a>)</span></div><div class="subtext"><span>itamarst</span> | <span>22 comments</span></div><br/><div><div id="39194316" class="c"><input type="checkbox" id="c-39194316" checked=""/><div class="controls bullet"><span class="by">IshanMi</span><span>|</span><a href="#39194723">next</a><span>|</span><label class="collapse" for="c-39194316">[-]</label><label class="expand" for="c-39194316">[3 more]</label></div><br/><div class="children"><div class="content">I still remember discovering &amp; using numba for the first time in university. At the time I didn&#x27;t know any programming languages except for Python, and wasn&#x27;t super great at Python either. We had to write and run molecular simulations for our numerical methods and simulations class, and people were writing their code in C&#x2F;C++ and were blazing through it. 
I remember finding out about Numba through the High Performance Python O&#x27;Reilly book, and by just adding a single @jit decorator, my simulations were dramatically faster.<p>Amazing stuff, honestly felt like black magic at the time.</div><br/><div id="39195984" class="c"><input type="checkbox" id="c-39195984" checked=""/><div class="controls bullet"><span class="by">IanOzsvald</span><span>|</span><a href="#39194316">parent</a><span>|</span><a href="#39194723">next</a><span>|</span><label class="collapse" for="c-39195984">[-]</label><label class="expand" for="c-39195984">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s my book :-) Micha and I are working on the 3rd edition right now. Cheers!</div><br/></div></div></div></div><div id="39194723" class="c"><input type="checkbox" id="c-39194723" checked=""/><div class="controls bullet"><span class="by">eachro</span><span>|</span><a href="#39194316">prev</a><span>|</span><a href="#39197453">next</a><span>|</span><label class="collapse" for="c-39194723">[-]</label><label class="expand" for="c-39194723">[17 more]</label></div><br/><div class="children"><div class="content">Do people use numba outside of scientific computing code? feel like for most &quot;normal&quot; uses, you&#x27;d probably be fine with having your code written in numpy or pandas, so I&#x27;d love to hear what people generally use numba for outside of scientific computing.</div><br/><div id="39201549" class="c"><input type="checkbox" id="c-39201549" checked=""/><div class="controls bullet"><span class="by">montebicyclelo</span><span>|</span><a href="#39194723">parent</a><span>|</span><a href="#39196199">next</a><span>|</span><label class="collapse" for="c-39201549">[-]</label><label class="expand" for="c-39201549">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s an example here of using Numba to speed up data science code, (disclaimer, I&#x27;m the author): <a href="https:&#x2F;&#x2F;sidsite.com&#x2F;posts&#x2F;python-corrset-optimization&#x2F;" rel="nofollow">https:&#x2F;&#x2F;sidsite.com&#x2F;posts&#x2F;python-corrset-optimization&#x2F;</a><p>&gt; for most &quot;normal&quot; uses, you&#x27;d probably be fine with having your code written in numpy or pandas<p>In my experience this is the case. Occasionally though, there might be an bottleneck, and Numba can be a good way to handle it. E.g. when implementing seam carving, I found normal Python &#x2F; NumPy too slow, and same with Naive Bayes, so used Numba. (Why was I implementing these, instead of using a library? As an exercise. But I guess the takeaway is that if you want to do something more intensive, and are implementing it yourself rather than using a library, Numba can be a good option).</div><br/></div></div><div id="39196199" class="c"><input type="checkbox" id="c-39196199" checked=""/><div class="controls bullet"><span class="by">IanOzsvald</span><span>|</span><a href="#39194723">parent</a><span>|</span><a href="#39201549">prev</a><span>|</span><a href="#39200742">next</a><span>|</span><label class="collapse" for="c-39196199">[-]</label><label class="expand" for="c-39196199">[3 more]</label></div><br/><div class="children"><div class="content">Really Numba will speed up numpy and some scipy (there&#x27;s partial API coverage) and math based pure python. I think it is unlikely it&#x27;d be used away from math problems. 
As another commenter mentioned it can be used to accelerate numpy-array based Pandas (but not the newer Arrow based arrays), and again that&#x27;s for numeric work.</div><br/><div id="39199182" class="c"><input type="checkbox" id="c-39199182" checked=""/><div class="controls bullet"><span class="by">a-dub</span><span>|</span><a href="#39194723">root</a><span>|</span><a href="#39196199">parent</a><span>|</span><a href="#39200742">next</a><span>|</span><label class="collapse" for="c-39199182">[-]</label><label class="expand" for="c-39199182">[2 more]</label></div><br/><div class="children"><div class="content">numpy and scipy are largely just wrappers around native libraries that are already optimized machine code. numba is good for writing loops or doing other things you can pretty much imagine as simple C code.<p>while it is pretty cool, it&#x27;s also a bit awkward thinking about machine structures and machine types in high level python. there are some gotchas with respect to the automatic type inference.</div><br/><div id="39201057" class="c"><input type="checkbox" id="c-39201057" checked=""/><div class="controls bullet"><span class="by">IanOzsvald</span><span>|</span><a href="#39194723">root</a><span>|</span><a href="#39199182">parent</a><span>|</span><a href="#39200742">next</a><span>|</span><label class="collapse" for="c-39201057">[-]</label><label class="expand" for="c-39201057">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t forget that a sequence of numpy operations will likely each allocate their own temporary memory. Numba can often fuse these together, so although the implementation behind numpy is compiled C you end up with fewer memory allocations and less memory pressure, so you still get your results even faster. Numba also offers the OpenMP parallel tools too.
I have a nice sequence of simulations in my Higher Performance Python course going from raw python through numpy then to Numba showing how this all comes together.
Just try having a function with a=np.fn1(x); b=np.fn2(a); c=np.fn3(b) etc and compile it with @jit and you should get a performance impact. Maybe you can also turn on the OpenMP parallelizer too.</div><br/></div></div></div></div></div></div><div id="39200742" class="c"><input type="checkbox" id="c-39200742" checked=""/><div class="controls bullet"><span class="by">__mharrison__</span><span>|</span><a href="#39194723">parent</a><span>|</span><a href="#39196199">prev</a><span>|</span><a href="#39197234">next</a><span>|</span><label class="collapse" for="c-39200742">[-]</label><label class="expand" for="c-39200742">[1 more]</label></div><br/><div class="children"><div class="content">I have a section on speeding up pandas code in Effective Pandas 2. It discuss using NumPy, Cython, and Numba to make pandas faster. In general, numba is magic and makes (decorated) pure Python run fast!</div><br/></div></div><div id="39197234" class="c"><input type="checkbox" id="c-39197234" checked=""/><div class="controls bullet"><span class="by">Kaijo</span><span>|</span><a href="#39194723">parent</a><span>|</span><a href="#39200742">prev</a><span>|</span><a href="#39199686">next</a><span>|</span><label class="collapse" for="c-39197234">[-]</label><label class="expand" for="c-39197234">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen numba used in a few addons for Blender 3D. Speeding up reaction-diffusion simulations on meshes, things like that. Scientific computing for artistic purposes!</div><br/></div></div><div id="39199686" class="c"><input type="checkbox" id="c-39199686" checked=""/><div class="controls bullet"><span class="by">bbstats</span><span>|</span><a href="#39194723">parent</a><span>|</span><a href="#39197234">prev</a><span>|</span><a href="#39195138">next</a><span>|</span><label class="collapse" for="c-39199686">[-]</label><label class="expand" for="c-39199686">[1 more]</label></div><br/><div class="children"><div class="content">If you must use a for loop on a data transformation (e.g. any recursive calculation), numba is way faster than most alternatives.</div><br/></div></div><div id="39195138" class="c"><input type="checkbox" id="c-39195138" checked=""/><div class="controls bullet"><span class="by">itamarst</span><span>|</span><a href="#39194723">parent</a><span>|</span><a href="#39199686">prev</a><span>|</span><a href="#39197455">next</a><span>|</span><label class="collapse" for="c-39195138">[-]</label><label class="expand" for="c-39195138">[1 more]</label></div><br/><div class="children"><div class="content">You can use Numba to speed up some Pandas calculations: <a href="https:&#x2F;&#x2F;pandas.pydata.org&#x2F;docs&#x2F;user_guide&#x2F;enhancingperf.html#numba-jit-compilation" rel="nofollow">https:&#x2F;&#x2F;pandas.pydata.org&#x2F;docs&#x2F;user_guide&#x2F;enhancingperf.html...</a></div><br/></div></div><div id="39197455" class="c"><input type="checkbox" id="c-39197455" checked=""/><div class="controls bullet"><span class="by">goriloser</span><span>|</span><a href="#39194723">parent</a><span>|</span><a href="#39195138">prev</a><span>|</span><a href="#39197386">next</a><span>|</span><label class="collapse" for="c-39197455">[-]</label><label class="expand" for="c-39197455">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes you just need a plain old &quot;for&quot; over your pandas dataframe, to do a more complicated aggregation (variable window size, conditionals, ...)<p>You can try twisting numpy&#x2F;pandas into a solution, but it might be much simpler to just write a dumb numba function which will be easier to maintain since the logic will be very clear.</div><br/></div></div><div id="39197386" class="c"><input type="checkbox" id="c-39197386" checked=""/><div class="controls bullet"><span class="by">dheera</span><span>|</span><a href="#39194723">parent</a><span>|</span><a href="#39197455">prev</a><span>|</span><a href="#39197223">next</a><span>|</span><label class="collapse" for="c-39197386">[-]</label><label class="expand" for="c-39197386">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used numba numerous times to get stuff done for robotics work. C++ is just a shitshow of a mess right now with 5 billion new unnecessary features yet the real inconveniences (like even the very existence of header files that massively violate DRY) haven&#x27;t been addressed at all. I can&#x27;t wait till Rust gains more adoption and ecosystem.</div><br/><div id="39200631" class="c"><input type="checkbox" id="c-39200631" checked=""/><div class="controls bullet"><span class="by">sobellian</span><span>|</span><a href="#39194723">root</a><span>|</span><a href="#39197386">parent</a><span>|</span><a href="#39198728">next</a><span>|</span><label class="collapse" for="c-39200631">[-]</label><label class="expand" for="c-39200631">[1 more]</label></div><br/><div class="children"><div class="content">I want to like Rust, but I find myself fighting the language so much - and not because of the lifetimes. Off the top of my head:<p>- <i>Yes</i> you get const generics, but <i>no</i> you do not get const generic expressions<p>- <i>Yes</i> you can provide impls for traits, but <i>no</i> you cannot impl a foreign trait for a foreign type<p>- Macros cover these gaps in meta-programming, but macro code is really painful to read&#x2F;write<p>- If you want to write one tiny little proc macro, you need a whole. new. crate. So I usually write ugly, convoluted &quot;declarative&quot; macros instead of what would properly be a proc macro<p>- Last time I wrote a Rust macro that generated a <i>lot</i> of code, the intellisense in VS Code stopped giving hints for functions in the macro output. Breaking intellisense is very painful<p>- <i>Yes</i> const fns exist, but <i>no</i> you cannot use iterators or for loops in them. AFAICT a lot of library authors just don&#x27;t go through the trouble of defining const fns. I was bit by this when I tried to make a const array using the ndarray library. Instead you have to go through the whole song and dance with OnceCell.<p>- Speaking of which, OnceCell feels like a downgrade compared with static initialization in C++. You get more soundness, but also much more verbosity<p>There are very good reasons for many of these restrictions, but still. I fear doing anything too fancy because I&#x27;ve come to expect that the language will yank away the football at the last second.<p>PS. Not a language shortcoming, but - do <i>not</i> just write out idiomatic vector math expressions as you might do with Eigen like:<p>```
let a = b + c + d + e;
```<p>IIRC Eigen can be smart enough to only allocate one result vector for this expression. Rust numeric libraries, on the other hand, will allocate many unnecessary temporaries. You need to be thinking much more imperatively to get similar performance:<p>```
let mut a = b + c;
a += d; a += e;
```</div><br/></div></div><div id="39198728" class="c"><input type="checkbox" id="c-39198728" checked=""/><div class="controls bullet"><span class="by">abdullahkhalids</span><span>|</span><a href="#39194723">root</a><span>|</span><a href="#39197386">parent</a><span>|</span><a href="#39200631">prev</a><span>|</span><a href="#39197223">next</a><span>|</span><label class="collapse" for="c-39198728">[-]</label><label class="expand" for="c-39198728">[1 more]</label></div><br/><div class="children"><div class="content">I learned Rust over the last year, to write some scientific simulations. Since, you can just call C++ libraries from Rust with minimal overhead, there is no real reason to not write in Rust.<p>Also, if you want a Python interface for your library, PyO3 allows you to call Rust from Python naturally. It definitely needs better documentation, but otherwise its quite good.</div><br/></div></div></div></div><div id="39197223" class="c"><input type="checkbox" id="c-39197223" checked=""/><div class="controls bullet"><span class="by">bionhoward</span><span>|</span><a href="#39194723">parent</a><span>|</span><a href="#39197386">prev</a><span>|</span><a href="#39197453">next</a><span>|</span><label class="collapse" for="c-39197223">[-]</label><label class="expand" for="c-39197223">[4 more]</label></div><br/><div class="children"><div class="content">algotrading</div><br/><div id="39197396" class="c"><input type="checkbox" id="c-39197396" checked=""/><div class="controls bullet"><span class="by">tripplyons</span><span>|</span><a href="#39194723">root</a><span>|</span><a href="#39197223">parent</a><span>|</span><a href="#39197453">next</a><span>|</span><label class="collapse" for="c-39197396">[-]</label><label class="expand" for="c-39197396">[3 more]</label></div><br/><div class="children"><div class="content">If your trading strategy cares about this level of speed, you shouldn&#x27;t be using Python.</div><br/><div id="39197499" class="c"><input type="checkbox" id="c-39197499" checked=""/><div class="controls bullet"><span class="by">goriloser</span><span>|</span><a href="#39194723">root</a><span>|</span><a href="#39197396">parent</a><span>|</span><a href="#39197453">next</a><span>|</span><label class="collapse" for="c-39197499">[-]</label><label class="expand" for="c-39197499">[2 more]</label></div><br/><div class="children"><div class="content">Algotrading has two parts - analyzing data to find strategies and executing the strategies.<p>Numba is for the first part, where you might need to process billions of messages to extract signals.</div><br/><div id="39197568" class="c"><input type="checkbox" id="c-39197568" checked=""/><div class="controls bullet"><span class="by">tripplyons</span><span>|</span><a href="#39194723">root</a><span>|</span><a href="#39197499">parent</a><span>|</span><a href="#39197453">next</a><span>|</span><label class="collapse" for="c-39197568">[-]</label><label class="expand" for="c-39197568">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the clarification. That would make more sense.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39197453" class="c"><input type="checkbox" id="c-39197453" checked=""/><div class="controls bullet"><span class="by">tripplyons</span><span>|</span><a href="#39194723">prev</a><span>|</span><label class="collapse" for="c-39197453">[-]</label><label class="expand" for="c-39197453">[1 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t realize Numba supported CUDA:<p><a href="https:&#x2F;&#x2F;numba.readthedocs.io&#x2F;en&#x2F;stable&#x2F;cuda&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;numba.readthedocs.io&#x2F;en&#x2F;stable&#x2F;cuda&#x2F;index.html</a></div><br/></div></div></div></div></div></div></div></body></html>