<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1723798872370" as="style"/><link rel="stylesheet" href="styles.css?v=1723798872370"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://medium.com/@zakharenko/how-does-it-feel-to-test-a-compiler-fa1ff5d86065">How does it feel to test a compiler?</a> <span class="domain">(<a href="https://medium.com">medium.com</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>36 comments</span></div><br/><div><div id="41261467" class="c"><input type="checkbox" id="c-41261467" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#41264381">next</a><span>|</span><label class="collapse" for="c-41261467">[-]</label><label class="expand" for="c-41261467">[23 more]</label></div><br/><div class="children"><div class="content">Jetbrains have a really solid testing team.<p>Lots of places have a two tier system where the real developers write the code and those who don&#x27;t make the cut test the code, with pay delta and an aspiration of being promoted out of testing.<p>Other places have a mandatory stint in testing for new developments as a way to get some headcount on the task.<p>Jetbrains don&#x27;t do that. Or at least they didn&#x27;t sometime before covid when I met a bunch of their test devs at a conference. The developers mostly doing testing were equals to those mostly doing product work. Possibly with a more extreme bias towards case analysis.<p>I don&#x27;t think it&#x27;s a coincidence that jetbrains treat their test team as peers to the others and that their software seems to mostly not fall over in the field.</div><br/><div id="41264553" class="c"><input type="checkbox" id="c-41264553" checked=""/><div class="controls bullet"><span class="by">high_na_euv</span><span>|</span><a href="#41261467">parent</a><span>|</span><a href="#41261717">next</a><span>|</span><label class="collapse" for="c-41264553">[-]</label><label class="expand" for="c-41264553">[1 more]</label></div><br/><div class="children"><div class="content">Ive worked in hw industry and arch team created specs, dev was developing product and its own tests<p>And val team was creating fake product which was used to help to write tests without product, or just tests - all of this basing on spec<p>It worked well when it comes to bug&#x2F;issues&#x2F;inconsistencies catching</div><br/></div></div><div id="41261717" class="c"><input type="checkbox" id="c-41261717" checked=""/><div class="controls bullet"><span class="by">gleenn</span><span>|</span><a href="#41261467">parent</a><span>|</span><a href="#41264553">prev</a><span>|</span><a href="#41263186">next</a><span>|</span><label class="collapse" for="c-41261717">[-]</label><label class="expand" for="c-41261717">[11 more]</label></div><br/><div class="children"><div class="content">I feel like developers who don&#x27;t write tests while writing their production code aren&#x27;t doing a real job in 2024. Sure you might have a QA team or something, but that should be a vast minority of the tests being written. Test driven development and Agile and all that had some people upset and whiny 20 years ago, but if I see code without tests, I assume it&#x27;s broken. The only way anyone knows anything works both now AND when the next 10, 100, 1000 commits roll in, your manually-tested edge cases have long been forgotten and I doubt you even got it right at all. Let&#x27;s keep normalizing writing tests and thinking, up front, how to ensure our code works. That&#x27;s the best time to think about all those pesky edge cases, and it&#x27;s the only practical way to keep code working. Don&#x27;t hoist this on to some poor chum because you are lazy or don&#x27;t know how.<p>(Spelling)</div><br/><div id="41261840" class="c"><input type="checkbox" id="c-41261840" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#41261467">root</a><span>|</span><a href="#41261717">parent</a><span>|</span><a href="#41262836">next</a><span>|</span><label class="collapse" for="c-41261840">[-]</label><label class="expand" for="c-41261840">[9 more]</label></div><br/><div class="children"><div class="content">Most tests I encounter in the real world are terrible, fundamentally broken, and a waste of build times. I have <i>almost never</i> had a potential bug caught by a test written by others. I have been a software developer for 25 years across multiple languages and ecosystems.<p>Everyone jumped on the testing bandwagon but writing code that is testable is a learned skill that nobody bothers to learn. Instead we end up with overly-mocked tests that—in practice—test that “the code is written like it currently is” rather than that it actually behaves correctly.<p>These kinds of tests actually provide <i>negative</i> value. Besides taking up time during every PR and build, they fire off on any attempt to clean up or refactor. Every time you edit the code you have to edit the tests which <i>entirely defeats the point</i>.<p>The solution ends up being, unsurprisingly, lessons learned from the functional world: don’t access or manipulate external state, operate only on direct inputs and only manipulate your outputs. As a result code ends up being dumb, short, and obvious. But nobody learns to write code this way, so two hundred line spaghetti functions are the norm.</div><br/><div id="41261912" class="c"><input type="checkbox" id="c-41261912" checked=""/><div class="controls bullet"><span class="by">kortilla</span><span>|</span><a href="#41261467">root</a><span>|</span><a href="#41261840">parent</a><span>|</span><a href="#41264190">next</a><span>|</span><label class="collapse" for="c-41261912">[-]</label><label class="expand" for="c-41261912">[7 more]</label></div><br/><div class="children"><div class="content">It sounds like you’re specifically talking about unit tests and people that suck at writing those.<p>I have seen functional and e2e tests prevent regressions far more times than I can count. The nice thing about those is that they force testing outcomes and don’t require “testable” code like unit tests do.<p>Don’t throw the baby out with the bathwater</div><br/><div id="41262022" class="c"><input type="checkbox" id="c-41262022" checked=""/><div class="controls bullet"><span class="by">SatvikBeri</span><span>|</span><a href="#41261467">root</a><span>|</span><a href="#41261912">parent</a><span>|</span><a href="#41262892">next</a><span>|</span><label class="collapse" for="c-41262022">[-]</label><label class="expand" for="c-41262022">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s really useful to ask the simple question &quot;what tests could have caught the most costly bugs we&#x27;ve had?&quot;<p>At one job, our code had a lot of math, and the worst bugs were when our data pipelines ran without crashing but gave the wrong numbers, sometimes due to weird stuff like &quot;a bug in our vendor&#x27;s code caused them to send us numbers denominated in pounds instead of dollars&quot;. This is pretty hard to catch with unit tests, but we ended up applying a layer of statistical checks that ran every hour or so and raised an alert if something was anomalous, and those alerts probably saved us more money than all other tests combined.</div><br/><div id="41263441" class="c"><input type="checkbox" id="c-41263441" checked=""/><div class="controls bullet"><span class="by">tetha</span><span>|</span><a href="#41261467">root</a><span>|</span><a href="#41262022">parent</a><span>|</span><a href="#41262892">next</a><span>|</span><label class="collapse" for="c-41263441">[-]</label><label class="expand" for="c-41263441">[1 more]</label></div><br/><div class="children"><div class="content">This reminds me of a fun thing I hacked up at a game shop. We were implementing some new feature involving a probability distribution and were somewhat stumped on how to make sure it worked right.<p>Eventually I setup something simple to exercise most of these functions, as well as most other balancing code, plot their results and send the results to the balancing team a week or so. For example, using D2 terms, it would run 1M item drops at different magic find levels and plot the resulting item level distribution, graph the implemented level -&gt; hp&#x2F;mana&#x2F;... curves and such.<p>That little thing caught so many implementation issues at first and we&#x27;d regularly have balancing poke us because someone &quot;optimized&quot; some code in there.</div><br/></div></div></div></div><div id="41262892" class="c"><input type="checkbox" id="c-41262892" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#41261467">root</a><span>|</span><a href="#41261912">parent</a><span>|</span><a href="#41262022">prev</a><span>|</span><a href="#41263270">next</a><span>|</span><label class="collapse" for="c-41262892">[-]</label><label class="expand" for="c-41262892">[2 more]</label></div><br/><div class="children"><div class="content">Integration tests can (and often do) suffer from the same issues since being composed of poorly-testable pieces doesn’t make things any more testable.<p>I’ve come to the conclusion that mocks <i>at all</i> are evil when done for anything except external services not under your control. And then, what you should be making is a trivial fake implementation of the other end, not just checking that specific methods were called.</div><br/><div id="41262948" class="c"><input type="checkbox" id="c-41262948" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#41261467">root</a><span>|</span><a href="#41262892">parent</a><span>|</span><a href="#41263270">next</a><span>|</span><label class="collapse" for="c-41262948">[-]</label><label class="expand" for="c-41262948">[1 more]</label></div><br/><div class="children"><div class="content">I mean, anything can be done poorly.  But consider that the team that builds the vehicles you drive is not the same as the team that tested said vehicle for safety concerns.<p>That is, you can have a solid testing team for pretty much anything.  You have to empower them, though.  Largely, a lot of what you get to empower them with is ability to put constraints onto the engineering team.<p>This could be crappy constraints that are far sweeping on the product.  There is no need that it has to be that, though.  The only constraint you have to have is stability of product interface.  Which.... yeah, our industry doesn&#x27;t do that so well.  (Note, not stability as in &quot;doesn&#x27;t crash.&quot;  Stability as in, same inputs that worked last year work today.)</div><br/></div></div></div></div><div id="41263270" class="c"><input type="checkbox" id="c-41263270" checked=""/><div class="controls bullet"><span class="by">stingraycharles</span><span>|</span><a href="#41261467">root</a><span>|</span><a href="#41261912">parent</a><span>|</span><a href="#41262892">prev</a><span>|</span><a href="#41264190">next</a><span>|</span><label class="collapse" for="c-41263270">[-]</label><label class="expand" for="c-41263270">[2 more]</label></div><br/><div class="children"><div class="content">Yeah. I work for a database company, if we didn’t have copious amounts of integration, regression and stress tests we would absolutely be having a very bad time.<p>And of course we still have manual exploratory QA, it’s difficult to replace that safety net.</div><br/><div id="41263433" class="c"><input type="checkbox" id="c-41263433" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#41261467">root</a><span>|</span><a href="#41263270">parent</a><span>|</span><a href="#41264190">next</a><span>|</span><label class="collapse" for="c-41263433">[-]</label><label class="expand" for="c-41263433">[1 more]</label></div><br/><div class="children"><div class="content">To be clear, tests when done well are incredible.<p>Very little in this industry is done well. Tests are one of those things.</div><br/></div></div></div></div></div></div><div id="41264190" class="c"><input type="checkbox" id="c-41264190" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#41261467">root</a><span>|</span><a href="#41261840">parent</a><span>|</span><a href="#41261912">prev</a><span>|</span><a href="#41262836">next</a><span>|</span><label class="collapse" for="c-41264190">[-]</label><label class="expand" for="c-41264190">[1 more]</label></div><br/><div class="children"><div class="content">&gt; As a result code ends up being dumb, short, and obvious.<p>I did a presentation on that last year:<p><a href="https:&#x2F;&#x2F;dconf.org&#x2F;2023&#x2F;#walterb" rel="nofollow">https:&#x2F;&#x2F;dconf.org&#x2F;2023&#x2F;#walterb</a></div><br/></div></div></div></div><div id="41262836" class="c"><input type="checkbox" id="c-41262836" checked=""/><div class="controls bullet"><span class="by">BobbyTables2</span><span>|</span><a href="#41261467">root</a><span>|</span><a href="#41261717">parent</a><span>|</span><a href="#41261840">prev</a><span>|</span><a href="#41263186">next</a><span>|</span><label class="collapse" for="c-41262836">[-]</label><label class="expand" for="c-41262836">[1 more]</label></div><br/><div class="children"><div class="content">I fully agree.  For most of my career, I hated the idea of writing (unit) tests.  They were almost always a waste of time.<p>At one point, I ended up on a team that had virtually no QA and only did automated end-to-end tests on a complex product.  After working through a lot of tech debt on the testing (took a few months), it was solid and caught many defects introduced by junior&#x2F;new developers (easily missed in code review).<p>I now have the fortune to be in a different group with a similar mindset.  I’m motivated to write tests for my own code just to prove to myself that it works properly in odd error cases too. My team prefers testing instead of “run fast and break things.” (And with multiple decades of experience, I humbly can state I cause significantly fewer bugs than in the past.) This also makes me write code in an easily testable manner. Trying to test already written code is usually a lengthy and painful exercise in frustration.<p>It’s also too easy to write error handlers that are NEVER actually exercised once, even manually — and surprise, they may not even work! People who never write tests do this quite often.</div><br/></div></div></div></div><div id="41263186" class="c"><input type="checkbox" id="c-41263186" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#41261467">parent</a><span>|</span><a href="#41261717">prev</a><span>|</span><a href="#41262515">next</a><span>|</span><label class="collapse" for="c-41263186">[-]</label><label class="expand" for="c-41263186">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m shocked that there are places in 2024 that have a separate set of devs writing test code. What decade is this?</div><br/><div id="41264184" class="c"><input type="checkbox" id="c-41264184" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#41261467">root</a><span>|</span><a href="#41263186">parent</a><span>|</span><a href="#41264121">next</a><span>|</span><label class="collapse" for="c-41264184">[-]</label><label class="expand" for="c-41264184">[1 more]</label></div><br/><div class="children"><div class="content">Having one set of developers write the code and another set of developers write tests from the same specification without reading the code is probably the most effective ways to use tests for high software quality and is typically required by certification bodies e.g. for avionics.</div><br/></div></div><div id="41264121" class="c"><input type="checkbox" id="c-41264121" checked=""/><div class="controls bullet"><span class="by">adrianN</span><span>|</span><a href="#41261467">root</a><span>|</span><a href="#41263186">parent</a><span>|</span><a href="#41264184">prev</a><span>|</span><a href="#41263702">next</a><span>|</span><label class="collapse" for="c-41264121">[-]</label><label class="expand" for="c-41264121">[1 more]</label></div><br/><div class="children"><div class="content">Having a separate test team is pretty much mandatory in safety critical development. You really want people who haven’t written the code go through the specification independently and write test cases for every requirement.</div><br/></div></div><div id="41263702" class="c"><input type="checkbox" id="c-41263702" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#41261467">root</a><span>|</span><a href="#41263186">parent</a><span>|</span><a href="#41264121">prev</a><span>|</span><a href="#41262515">next</a><span>|</span><label class="collapse" for="c-41263702">[-]</label><label class="expand" for="c-41263702">[1 more]</label></div><br/><div class="children"><div class="content">The (unit) tests developers write themselves check the developer did what they intended to, and then that things don&#x27;t change. Whatever case analysis the developer missed in the implementation tends to be missing from their tests as well, as they didn&#x27;t think of it.<p>Testing your own work also does nothing to protect against correctly implementing the wrong thing.</div><br/></div></div></div></div><div id="41262515" class="c"><input type="checkbox" id="c-41262515" checked=""/><div class="controls bullet"><span class="by">kabdib</span><span>|</span><a href="#41261467">parent</a><span>|</span><a href="#41263186">prev</a><span>|</span><a href="#41262630">next</a><span>|</span><label class="collapse" for="c-41262515">[-]</label><label class="expand" for="c-41262515">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve had &quot;quality-team-as-peer&quot; situations only a few times in my career, and it&#x27;s  been great every time. Getting meaningful feedback on specs and early builds from people who knew what they were doing (and were happy doing it) was like the first time I had a real editor (the human kind) marking up my writing, just a wonderful feeling that someone had your back <i>and</i> that you all had the same goal: Happy customers.</div><br/></div></div><div id="41262630" class="c"><input type="checkbox" id="c-41262630" checked=""/><div class="controls bullet"><span class="by">BobbyTables2</span><span>|</span><a href="#41261467">parent</a><span>|</span><a href="#41262515">prev</a><span>|</span><a href="#41261787">next</a><span>|</span><label class="collapse" for="c-41262630">[-]</label><label class="expand" for="c-41262630">[3 more]</label></div><br/><div class="children"><div class="content">It is indeed shocking what happens when a company doesn’t treat its (offshore) QA team as third class peons relative to the developers.<p>I’ve seen both and have actually seen much higher product quality when the QA team is smaller (or even almost non existent).<p>Turns out white-box testing usually fails to catch things only SMEs would know.</div><br/><div id="41263500" class="c"><input type="checkbox" id="c-41263500" checked=""/><div class="controls bullet"><span class="by">spc476</span><span>|</span><a href="#41261467">root</a><span>|</span><a href="#41262630">parent</a><span>|</span><a href="#41262700">next</a><span>|</span><label class="collapse" for="c-41263500">[-]</label><label class="expand" for="c-41263500">[1 more]</label></div><br/><div class="children"><div class="content">At my previous job, prior to new management (we got bought out), my team worked closely with QA during the development process---they would get daily, often times, more than daily, builds of our project and so by the time it got to the staging environment, it pretty much worked [1].  New management comes in, forces a hard wall between us and QA and pretty much, we went from &quot;favored vendor&quot; of our customer [2], to &quot;least favorite vendor&quot; in less than a year.  One deployment took <i>four</i> attempts to get right.  Bugs found left and right.  All because the new management didn&#x27;t want to &quot;pollute&quot; QA&#x27;s testing mindset with implementation details.  Sigh.<p>[1] During the 11 years I was there, there were only two deployments that were reversed, prior to new management.  And the bugs were found <i>during the immediate testing after deployment</i> and we were able to reverse quickly.<p>[2] The Oligarchic Cell Phone Company.</div><br/></div></div><div id="41262700" class="c"><input type="checkbox" id="c-41262700" checked=""/><div class="controls bullet"><span class="by">HideousKojima</span><span>|</span><a href="#41261467">root</a><span>|</span><a href="#41262630">parent</a><span>|</span><a href="#41263500">prev</a><span>|</span><a href="#41261787">next</a><span>|</span><label class="collapse" for="c-41262700">[-]</label><label class="expand" for="c-41262700">[1 more]</label></div><br/><div class="children"><div class="content">I frankly think my company&#x27;s offshore devs and QA (largely India-based) are a net negative. The existence of a decent sized team to do QA manually has made adoption of automated testing (and writing code that it easily testable) almost impossible because no one wants to change.</div><br/></div></div></div></div><div id="41261787" class="c"><input type="checkbox" id="c-41261787" checked=""/><div class="controls bullet"><span class="by">yreg</span><span>|</span><a href="#41261467">parent</a><span>|</span><a href="#41262630">prev</a><span>|</span><a href="#41264381">next</a><span>|</span><label class="collapse" for="c-41261787">[-]</label><label class="expand" for="c-41261787">[2 more]</label></div><br/><div class="children"><div class="content">A class system with developers writing production code looking down on developers writing tests doesn&#x27;t seem healthy to me.</div><br/><div id="41262850" class="c"><input type="checkbox" id="c-41262850" checked=""/><div class="controls bullet"><span class="by">BobbyTables2</span><span>|</span><a href="#41261467">root</a><span>|</span><a href="#41261787">parent</a><span>|</span><a href="#41264381">next</a><span>|</span><label class="collapse" for="c-41262850">[-]</label><label class="expand" for="c-41262850">[1 more]</label></div><br/><div class="children"><div class="content">It never is!</div><br/></div></div></div></div></div></div><div id="41264381" class="c"><input type="checkbox" id="c-41264381" checked=""/><div class="controls bullet"><span class="by">rbanffy</span><span>|</span><a href="#41261467">prev</a><span>|</span><a href="#41263545">next</a><span>|</span><label class="collapse" for="c-41264381">[-]</label><label class="expand" for="c-41264381">[1 more]</label></div><br/><div class="children"><div class="content">It seems difficult to test. Being difficult to test is usually a sign of inconvenient APIs and modules. For instance, the hiding of elements happens in multiple levels - the front-end needs a test to make sure the right intermediate representation is being generated. The backend, in turn, needs to be tested to make sure the intermediate representation with a hidden element generates the proper linker information and the linker itself needs a test to make sure the correctly annotated object code results in the correct artefact lacking external information about the hidden symbol. Testing end-to-end seems very laborious and error prone. Root-cause-analysis should have pinpointed the place the issue originates and one or more possible paths where it propagates downstream to inform future tests.<p>It also disturbs me that the author mentioned the order at which sources are compiled to matter in the final result. It should never matter.<p>When we build software we should always make it in such way it’s trivial to write tests for it. If writing a test is easy, it indicates using the tool you wrote is also easy.</div><br/></div></div><div id="41263545" class="c"><input type="checkbox" id="c-41263545" checked=""/><div class="controls bullet"><span class="by">tgma</span><span>|</span><a href="#41264381">prev</a><span>|</span><a href="#41261591">next</a><span>|</span><label class="collapse" for="c-41263545">[-]</label><label class="expand" for="c-41263545">[3 more]</label></div><br/><div class="children"><div class="content">The article touches on basic testing strategies that apply to general software as well as compilers. I have been involved with compiler testing projects on production LLVM and GCC in my past life. One thing that makes compiler testing specifically more difficult than general software is the Oracle Problem: how do you verify the output is in fact correct? Crashes are relatively easy to find by random fuzzing, but in the general case, proving that the output program is not miscompiled is non-trivial.<p>There are a couple effective techniques in the literature that might be useful here:<p>- <i>Differential testing</i>[1]: generate a bunch of random, correct, deterministic programs; run them under different compilers or under different compilation flags and check if the output of the program is identical<p>- <i>Equivalence Modulo Inputs</i>[2]: a class of techniques that can be used transform a program to a distinct program that is supposed to be equivalent to the original for a specific input. <i>(shameless plug)</i><p>[1]: <a href="https:&#x2F;&#x2F;users.cs.utah.edu&#x2F;~regehr&#x2F;papers&#x2F;pldi11-preprint.pdf" rel="nofollow">https:&#x2F;&#x2F;users.cs.utah.edu&#x2F;~regehr&#x2F;papers&#x2F;pldi11-preprint.pdf</a><p>[2]: <a href="https:&#x2F;&#x2F;web.cs.ucdavis.edu&#x2F;~su&#x2F;publications&#x2F;emi.pdf" rel="nofollow">https:&#x2F;&#x2F;web.cs.ucdavis.edu&#x2F;~su&#x2F;publications&#x2F;emi.pdf</a></div><br/><div id="41264348" class="c"><input type="checkbox" id="c-41264348" checked=""/><div class="controls bullet"><span class="by">sojuz151</span><span>|</span><a href="#41263545">parent</a><span>|</span><a href="#41261591">next</a><span>|</span><label class="collapse" for="c-41264348">[-]</label><label class="expand" for="c-41264348">[2 more]</label></div><br/><div class="children"><div class="content">What about using multiple open source projects with already existing tests? You check if results of execution are the same between compiler versions? This should also provide you with a better coverage of various features</div><br/><div id="41264460" class="c"><input type="checkbox" id="c-41264460" checked=""/><div class="controls bullet"><span class="by">tgma</span><span>|</span><a href="#41263545">root</a><span>|</span><a href="#41264348">parent</a><span>|</span><a href="#41261591">next</a><span>|</span><label class="collapse" for="c-41264460">[-]</label><label class="expand" for="c-41264460">[1 more]</label></div><br/><div class="children"><div class="content">Sure that counts as differential testing. The issue is there are limited number of them compared to the amount of code you can generate mechanically, and especially in the case of C, it is not straightforward to write a standardized script to build and run a bunch of random projects.</div><br/></div></div></div></div></div></div><div id="41261591" class="c"><input type="checkbox" id="c-41261591" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#41263545">prev</a><span>|</span><a href="#41264294">next</a><span>|</span><label class="collapse" for="c-41261591">[-]</label><label class="expand" for="c-41261591">[3 more]</label></div><br/><div class="children"><div class="content">From my years on GCC I can remember that 90% of regular users&#x27; bug reports were user error, not a compiler bug.<p>But as with any code, compilers have bugs too and sometimes they can be quite surprising.</div><br/><div id="41262382" class="c"><input type="checkbox" id="c-41262382" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#41261591">parent</a><span>|</span><a href="#41264294">next</a><span>|</span><label class="collapse" for="c-41262382">[-]</label><label class="expand" for="c-41262382">[2 more]</label></div><br/><div class="children"><div class="content">to be fair most of that is GCC&#x2F;C&#x27;s fault. C has tons of UB that is very difficult to reason about, and GCC chooses to do weird things by default that are at best ambiguously standard compliant (e.g. evaluating floating point expressions in higher than specified by the user). Compilers of languages with more intuitive semantics tend to get less user error bug reports.</div><br/><div id="41263171" class="c"><input type="checkbox" id="c-41263171" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#41261591">root</a><span>|</span><a href="#41262382">parent</a><span>|</span><a href="#41264294">next</a><span>|</span><label class="collapse" for="c-41263171">[-]</label><label class="expand" for="c-41263171">[1 more]</label></div><br/><div class="children"><div class="content">&gt; that are at best ambiguously standard compliant (e.g. evaluating floating point expressions in higher than specified by the user).<p>That&#x27;s not ambiguously standards-compliant, that is literally something that the standard has explicit mechanisms to indicate that&#x27;s what the compiler is doing (look up FLT_EVAL_METHOD).</div><br/></div></div></div></div></div></div><div id="41264294" class="c"><input type="checkbox" id="c-41264294" checked=""/><div class="controls bullet"><span class="by">danmur</span><span>|</span><a href="#41261591">prev</a><span>|</span><a href="#41263447">next</a><span>|</span><label class="collapse" for="c-41264294">[-]</label><label class="expand" for="c-41264294">[1 more]</label></div><br/><div class="children"><div class="content">Probably better than paying money to test an IDE :P</div><br/></div></div><div id="41263447" class="c"><input type="checkbox" id="c-41263447" checked=""/><div class="controls bullet"><span class="by">Haugsevje</span><span>|</span><a href="#41264294">prev</a><span>|</span><a href="#41262765">next</a><span>|</span><label class="collapse" for="c-41263447">[-]</label><label class="expand" for="c-41263447">[2 more]</label></div><br/><div class="children"><div class="content">Somehow I came to think of &#x27;Like a rolling stone&#x27;..Dylan I believe.</div><br/><div id="41263939" class="c"><input type="checkbox" id="c-41263939" checked=""/><div class="controls bullet"><span class="by">azakharenko</span><span>|</span><a href="#41263447">parent</a><span>|</span><a href="#41262765">next</a><span>|</span><label class="collapse" for="c-41263939">[-]</label><label class="expand" for="c-41263939">[1 more]</label></div><br/><div class="children"><div class="content">It partially inspired me, right :)</div><br/></div></div></div></div><div id="41262765" class="c"><input type="checkbox" id="c-41262765" checked=""/><div class="controls bullet"><span class="by">pfdietz</span><span>|</span><a href="#41263447">prev</a><span>|</span><a href="#41261738">next</a><span>|</span><label class="collapse" for="c-41262765">[-]</label><label class="expand" for="c-41262765">[1 more]</label></div><br/><div class="children"><div class="content">I was disappointed they apparently don&#x27;t do high volume differential testing with randomly generated programs, a kind of property based testing.  Each individual program has very little testing value, but when you can crank out millions or even billions of them they can find all sorts of bugs.</div><br/></div></div><div id="41261738" class="c"><input type="checkbox" id="c-41261738" checked=""/><div class="controls bullet"><span class="by">wslh</span><span>|</span><a href="#41262765">prev</a><span>|</span><label class="collapse" for="c-41261738">[-]</label><label class="expand" for="c-41261738">[1 more]</label></div><br/><div class="children"><div class="content">We recently posted about fuzzying a compiler with success [1]. The article contains the details. There is an error on the Zest link that should point to [2]. The key is how to craft the generator.<p>[1] <a href="https:&#x2F;&#x2F;www.coinfabrik.com&#x2F;blog&#x2F;why-the-fuzz-about-fuzzing-compilers&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.coinfabrik.com&#x2F;blog&#x2F;why-the-fuzz-about-fuzzing-c...</a><p>[2] <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;3293882.3330576" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;3293882.3330576</a></div><br/></div></div></div></div></div></div></div></body></html>