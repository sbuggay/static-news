<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1703235655988" as="style"/><link rel="stylesheet" href="styles.css?v=1703235655988"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.builder.io/blog/structured-clone">Deep cloning objects in JavaScript</a> <span class="domain">(<a href="https://www.builder.io">www.builder.io</a>)</span></div><div class="subtext"><span>kiyanwang</span> | <span>116 comments</span></div><br/><div><div id="38731215" class="c"><input type="checkbox" id="c-38731215" checked=""/><div class="controls bullet"><span class="by">namuol</span><span>|</span><a href="#38731794">next</a><span>|</span><label class="collapse" for="c-38731215">[-]</label><label class="expand" for="c-38731215">[2 more]</label></div><br/><div class="children"><div class="content">If you’re reaching for structuredClone, what you really want is native immutable Record and Tuple syntax, and the companion “deep path properties” syntax which allows for efficient and ergonomic immutable updates:<p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-record-tuple">https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-record-tuple</a><p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-deep-path-properties-for-record">https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-deep-path-properties-for-re...</a></div><br/><div id="38732309" class="c"><input type="checkbox" id="c-38732309" checked=""/><div class="controls bullet"><span class="by">nlitened</span><span>|</span><a href="#38731215">parent</a><span>|</span><a href="#38731794">next</a><span>|</span><label class="collapse" for="c-38732309">[-]</label><label class="expand" for="c-38732309">[1 more]</label></div><br/><div class="children"><div class="content">Also, if one found their way to immutable Records and Tuples, maybe it&#x27;s also time to start exploring Clojure&#x2F;ClojureScript.</div><br/></div></div></div></div><div id="38731794" class="c"><input type="checkbox" id="c-38731794" checked=""/><div class="controls bullet"><span class="by">ggorlen</span><span>|</span><a href="#38731215">prev</a><span>|</span><a href="#38729227">next</a><span>|</span><label class="collapse" for="c-38731794">[-]</label><label class="expand" for="c-38731794">[1 more]</label></div><br/><div class="children"><div class="content">I think there&#x27;s a typo in the cloneDeep example[1]. cloneDeep is imported but never used, and structuredClone is used instead.<p>[1]: <a href="https:&#x2F;&#x2F;www.builder.io&#x2F;blog&#x2F;structured-clone#why-not-code-clone-deep-code" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.builder.io&#x2F;blog&#x2F;structured-clone#why-not-code-cl...</a></div><br/></div></div><div id="38729227" class="c"><input type="checkbox" id="c-38729227" checked=""/><div class="controls bullet"><span class="by">xpressvideoz</span><span>|</span><a href="#38731794">prev</a><span>|</span><a href="#38730695">next</a><span>|</span><label class="collapse" for="c-38729227">[-]</label><label class="expand" for="c-38729227">[12 more]</label></div><br/><div class="children"><div class="content">TIL, thanks. But uh, I expected `JSON.stringify` to throw errors when met with unencodable objects, like Python does. But it silently corrupts the values. A typical JavaScript thing.<p>I also think the automatic conversion of a `Date` to a string is a bad thing, which again is prohibited in Python.</div><br/><div id="38729336" class="c"><input type="checkbox" id="c-38729336" checked=""/><div class="controls bullet"><span class="by">professoretc</span><span>|</span><a href="#38729227">parent</a><span>|</span><a href="#38730695">next</a><span>|</span><label class="collapse" for="c-38729336">[-]</label><label class="expand" for="c-38729336">[11 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t &quot;corrupt&quot; them; it converts them to JSON strings. It&#x27;s in the name. Expecting `JSON.stringify` to throw in those situations would be like expecting `str` in Python to throw.</div><br/><div id="38730034" class="c"><input type="checkbox" id="c-38730034" checked=""/><div class="controls bullet"><span class="by">xpressvideoz</span><span>|</span><a href="#38729227">root</a><span>|</span><a href="#38729336">parent</a><span>|</span><a href="#38729525">next</a><span>|</span><label class="collapse" for="c-38730034">[-]</label><label class="expand" for="c-38730034">[5 more]</label></div><br/><div class="children"><div class="content">It does not convert them to JSON strings, as stated in the original article. That&#x27;s why I said it corrupted the values.<p><pre><code>  &gt; JSON.stringify({a: ()=&gt;{}})
  {}
  &gt; JSON.stringify({a: &#x2F;b&#x2F;})
  {&quot;a&quot;:{}}</code></pre></div><br/><div id="38731165" class="c"><input type="checkbox" id="c-38731165" checked=""/><div class="controls bullet"><span class="by">wfhBrian</span><span>|</span><a href="#38729227">root</a><span>|</span><a href="#38730034">parent</a><span>|</span><a href="#38731872">next</a><span>|</span><label class="collapse" for="c-38731165">[-]</label><label class="expand" for="c-38731165">[3 more]</label></div><br/><div class="children"><div class="content">You can use a replacer function to special handle stringifying functions if you needed to do that.</div><br/><div id="38731492" class="c"><input type="checkbox" id="c-38731492" checked=""/><div class="controls bullet"><span class="by">xpressvideoz</span><span>|</span><a href="#38729227">root</a><span>|</span><a href="#38731165">parent</a><span>|</span><a href="#38731872">next</a><span>|</span><label class="collapse" for="c-38731492">[-]</label><label class="expand" for="c-38731492">[2 more]</label></div><br/><div class="children"><div class="content">What irks me is its default behavior. A function should do safe operations by default. Compared to `JSON.stringify()`, &#x27;structuredClone()` throws an error when it encounters values that cannot be cloned, which is a much saner approach. Probably because they learned from the mistake.</div><br/><div id="38732294" class="c"><input type="checkbox" id="c-38732294" checked=""/><div class="controls bullet"><span class="by">shrew</span><span>|</span><a href="#38729227">root</a><span>|</span><a href="#38731492">parent</a><span>|</span><a href="#38731872">next</a><span>|</span><label class="collapse" for="c-38732294">[-]</label><label class="expand" for="c-38732294">[1 more]</label></div><br/><div class="children"><div class="content">I understand your point and I can’t deny that Javascript continues to introduce weird, silent failures and quirks even today when everything is a bit more thought out than “the bad old days”.<p>But I think in the case of JSON.stringify it’s more about use case. 99% of the time, users of this method are taking some data and serialising it to a JSON compliant form to send to the server. JSON doesn’t support functions, or complex objects like a Date, so I tend to think it’s a reasonable default that functions disappear and Date’s are converted to an ISO standard. To insist that every single user runs a preparation step that strips out unserialisability data and chooses how to handle Date objects sounds laborious, error prone, and ripe for another npm dependency everyone suddenly normalises for every project.<p>Maybe a “strict mode” of some sort where you could have it throw on anything for cases where you need to guarantee everything is being sent?<p>OTOH, I have to concede that while this method has silent failures, they then implemented JSON.parse to throw at the slightest issue. So I have to admit there’s consistency even within the API.</div><br/></div></div></div></div></div></div><div id="38731872" class="c"><input type="checkbox" id="c-38731872" checked=""/><div class="controls bullet"><span class="by">watwut</span><span>|</span><a href="#38729227">root</a><span>|</span><a href="#38730034">parent</a><span>|</span><a href="#38731165">prev</a><span>|</span><a href="#38729525">next</a><span>|</span><label class="collapse" for="c-38731872">[-]</label><label class="expand" for="c-38731872">[1 more]</label></div><br/><div class="children"><div class="content">The first seems ok to me. Kotlin and Java does the same - ignore methods when serializing into json</div><br/></div></div></div></div><div id="38729525" class="c"><input type="checkbox" id="c-38729525" checked=""/><div class="controls bullet"><span class="by">mike_hock</span><span>|</span><a href="#38729227">root</a><span>|</span><a href="#38729336">parent</a><span>|</span><a href="#38730034">prev</a><span>|</span><a href="#38730695">next</a><span>|</span><label class="collapse" for="c-38729525">[-]</label><label class="expand" for="c-38729525">[5 more]</label></div><br/><div class="children"><div class="content">`str` is the equivalent of `toString`, not of `JSON.stringify`. Failure of a serializer-deserializer to roundtrip properly is corruption. The poorly chosen name (which is usually called &quot;dump&quot; or &quot;serialize&quot; in other languages) does not give license for silent corruption.</div><br/><div id="38729643" class="c"><input type="checkbox" id="c-38729643" checked=""/><div class="controls bullet"><span class="by">jay_kyburz</span><span>|</span><a href="#38729227">root</a><span>|</span><a href="#38729525">parent</a><span>|</span><a href="#38730695">next</a><span>|</span><label class="collapse" for="c-38729643">[-]</label><label class="expand" for="c-38729643">[4 more]</label></div><br/><div class="children"><div class="content">&quot;stringify&quot; sound more like toString than serialize to me.</div><br/><div id="38731501" class="c"><input type="checkbox" id="c-38731501" checked=""/><div class="controls bullet"><span class="by">anamexis</span><span>|</span><a href="#38729227">root</a><span>|</span><a href="#38729643">parent</a><span>|</span><a href="#38730695">next</a><span>|</span><label class="collapse" for="c-38731501">[-]</label><label class="expand" for="c-38731501">[3 more]</label></div><br/><div class="children"><div class="content">I think that is the issue.</div><br/><div id="38732227" class="c"><input type="checkbox" id="c-38732227" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38729227">root</a><span>|</span><a href="#38731501">parent</a><span>|</span><a href="#38732066">next</a><span>|</span><label class="collapse" for="c-38732227">[-]</label><label class="expand" for="c-38732227">[1 more]</label></div><br/><div class="children"><div class="content">That is the solution. It allows JSON.serialize to exhibit the non-corrupting behaviour, giving a reasonable indication to the developer which is which by the name alone.<p>The issue, if there is one, is that nobody ever got around to implementing JSON.serialize.</div><br/></div></div><div id="38732066" class="c"><input type="checkbox" id="c-38732066" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#38729227">root</a><span>|</span><a href="#38731501">parent</a><span>|</span><a href="#38732227">prev</a><span>|</span><a href="#38730695">next</a><span>|</span><label class="collapse" for="c-38732066">[-]</label><label class="expand" for="c-38732066">[1 more]</label></div><br/><div class="children"><div class="content">I agree with everyone here: it’s named correctly, but other languages did it… differently. (Stopping short of “better”, but only just.)</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38730695" class="c"><input type="checkbox" id="c-38730695" checked=""/><div class="controls bullet"><span class="by">leeoniya</span><span>|</span><a href="#38729227">prev</a><span>|</span><a href="#38730650">next</a><span>|</span><label class="collapse" for="c-38730695">[-]</label><label class="expand" for="c-38730695">[1 more]</label></div><br/><div class="children"><div class="content">for those considering Immer, check out Mutative or Limu instead (both much faster)<p><a href="https:&#x2F;&#x2F;github.com&#x2F;unadlib&#x2F;mutative">https:&#x2F;&#x2F;github.com&#x2F;unadlib&#x2F;mutative</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;tnfe&#x2F;limu">https:&#x2F;&#x2F;github.com&#x2F;tnfe&#x2F;limu</a></div><br/></div></div><div id="38730650" class="c"><input type="checkbox" id="c-38730650" checked=""/><div class="controls bullet"><span class="by">shanghaikid</span><span>|</span><a href="#38730695">prev</a><span>|</span><a href="#38730648">next</a><span>|</span><label class="collapse" for="c-38730650">[-]</label><label class="expand" for="c-38730650">[2 more]</label></div><br/><div class="children"><div class="content">For data to rendering on UI, JSON.parse(JSON.stringify()) is enough. 
For other operations, clone an object with such complex structure is not a good idea, you may change your way of coding.</div><br/><div id="38732195" class="c"><input type="checkbox" id="c-38732195" checked=""/><div class="controls bullet"><span class="by">noduerme</span><span>|</span><a href="#38730650">parent</a><span>|</span><a href="#38730648">next</a><span>|</span><label class="collapse" for="c-38732195">[-]</label><label class="expand" for="c-38732195">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, generally. But it may be nice for saving complicated game states, or sending complicated objects to a Worker without having to rebuild them from JSON.</div><br/></div></div></div></div><div id="38730648" class="c"><input type="checkbox" id="c-38730648" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#38730650">prev</a><span>|</span><a href="#38728880">next</a><span>|</span><label class="collapse" for="c-38730648">[-]</label><label class="expand" for="c-38730648">[4 more]</label></div><br/><div class="children"><div class="content">Why go with less recognizable &quot;structured&quot; in the name instead of &quot;deep&quot;?</div><br/><div id="38731563" class="c"><input type="checkbox" id="c-38731563" checked=""/><div class="controls bullet"><span class="by">HellsMaddy</span><span>|</span><a href="#38730648">parent</a><span>|</span><a href="#38728880">next</a><span>|</span><label class="collapse" for="c-38731563">[-]</label><label class="expand" for="c-38731563">[3 more]</label></div><br/><div class="children"><div class="content">I just did a deep dive into this (pun intended). The name appears to date back well over a decade (probably longer) and has roots in lower-level browser APIs like the implementation of `postMessage`.<p>&gt; Structured cloning algorithm defines the semantics of copying a well-defined subset of ECMAScript objects between Code Realms. This algorithm is extensible by host enviroment to support cloning of host objects.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;dslomov&#x2F;ecmascript-structured-clone">https:&#x2F;&#x2F;github.com&#x2F;dslomov&#x2F;ecmascript-structured-clone</a><p>Eventually, in 2015, it was suggested to expose the `structuredClone` algorithm as an API:<p>&gt; Has anyone ever proposed exposing the structured clone algorithm directly
as an API? Katelyn Gadd was musing about fast deep copy in JS on Twitter,
and I proposed a hack to use postMessage to do so[1], which works but it&#x27;s
a little roundabout. Since structured clone is a primitive that the web
platform is built on it seems like a primitive that ought to be exposed. I
know this exists in other languages (Python has copy.deepcopy[2]) and
there&#x27;s an npm &quot;deepcopy&quot; module[3] with lots of downloads so this is
clearly something people use.<p><a href="https:&#x2F;&#x2F;lists.w3.org&#x2F;Archives&#x2F;Public&#x2F;public-webapps&#x2F;2015AprJun&#x2F;0251.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;lists.w3.org&#x2F;Archives&#x2F;Public&#x2F;public-webapps&#x2F;2015AprJ...</a></div><br/><div id="38731691" class="c"><input type="checkbox" id="c-38731691" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#38730648">root</a><span>|</span><a href="#38731563">parent</a><span>|</span><a href="#38728880">next</a><span>|</span><label class="collapse" for="c-38731691">[-]</label><label class="expand" for="c-38731691">[2 more]</label></div><br/><div class="children"><div class="content">Thank you, have you seen whether there was any consideration of the obvious naming flaw? Don&#x27;t see anything in these links</div><br/><div id="38731709" class="c"><input type="checkbox" id="c-38731709" checked=""/><div class="controls bullet"><span class="by">HellsMaddy</span><span>|</span><a href="#38730648">root</a><span>|</span><a href="#38731691">parent</a><span>|</span><a href="#38728880">next</a><span>|</span><label class="collapse" for="c-38731709">[-]</label><label class="expand" for="c-38731709">[1 more]</label></div><br/><div class="children"><div class="content">I was trying to find something about that, but wasn&#x27;t able to. I would be very curious if someone else can find meeting minutes or mailing list posts where they discuss it.</div><br/></div></div></div></div></div></div></div></div><div id="38728880" class="c"><input type="checkbox" id="c-38728880" checked=""/><div class="controls bullet"><span class="by">toddmorey</span><span>|</span><a href="#38730648">prev</a><span>|</span><a href="#38729653">next</a><span>|</span><label class="collapse" for="c-38728880">[-]</label><label class="expand" for="c-38728880">[3 more]</label></div><br/><div class="children"><div class="content">I cannot believe lodash cloneDeep (just the one function) is 17.4kb minified!</div><br/><div id="38728994" class="c"><input type="checkbox" id="c-38728994" checked=""/><div class="controls bullet"><span class="by">jwalton</span><span>|</span><a href="#38728880">parent</a><span>|</span><a href="#38729653">next</a><span>|</span><label class="collapse" for="c-38728994">[-]</label><label class="expand" for="c-38728994">[2 more]</label></div><br/><div class="children"><div class="content">A lot of Lodash functions are implemented as combinations of other Lodash functions, so importing a single function actually imports half of Lodash under the hood:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;lodash&#x2F;lodash&#x2F;blob&#x2F;main&#x2F;src&#x2F;.internal&#x2F;baseClone.ts">https:&#x2F;&#x2F;github.com&#x2F;lodash&#x2F;lodash&#x2F;blob&#x2F;main&#x2F;src&#x2F;.internal&#x2F;bas...</a></div><br/><div id="38732076" class="c"><input type="checkbox" id="c-38732076" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#38728880">root</a><span>|</span><a href="#38728994">parent</a><span>|</span><a href="#38729653">next</a><span>|</span><label class="collapse" for="c-38732076">[-]</label><label class="expand" for="c-38732076">[1 more]</label></div><br/><div class="children"><div class="content">Would it be shorter if it didn’t, though?</div><br/></div></div></div></div></div></div><div id="38729653" class="c"><input type="checkbox" id="c-38729653" checked=""/><div class="controls bullet"><span class="by">johnfn</span><span>|</span><a href="#38728880">prev</a><span>|</span><a href="#38729397">next</a><span>|</span><label class="collapse" for="c-38729653">[-]</label><label class="expand" for="c-38729653">[10 more]</label></div><br/><div class="children"><div class="content">&gt; structuredClone({ a: () =&gt; {} })<p>&gt; VM187:1 Uncaught DOMException: Failed to execute &#x27;structuredClone&#x27; on &#x27;Window&#x27;: () =&gt; {} could not be cloned.<p>Ah, yes. I actually asked this question on StackOverflow 5 years ago [0], and the reason it can&#x27;t be cloned isn&#x27;t the worst reason ever... but it basically breaks cloning any non-trivial object. Well, I suppose I&#x27;ll check back in another 10 years when the next ecmascript proposal around cloning lands...<p>[0]: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;51939812&#x2F;how-to-clone-an-object-with-an-arrow-function-in-javascript" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;51939812&#x2F;how-to-clone-an...</a></div><br/><div id="38730622" class="c"><input type="checkbox" id="c-38730622" checked=""/><div class="controls bullet"><span class="by">XeO3</span><span>|</span><a href="#38729653">parent</a><span>|</span><a href="#38729728">next</a><span>|</span><label class="collapse" for="c-38730622">[-]</label><label class="expand" for="c-38730622">[1 more]</label></div><br/><div class="children"><div class="content">It is mentioned in the exception list of structuredClone.<p><a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Web_Workers_API&#x2F;Structured_clone_algorithm#things_that_dont_work_with_structured_clone" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Web_Workers...</a></div><br/></div></div><div id="38729728" class="c"><input type="checkbox" id="c-38729728" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#38729653">parent</a><span>|</span><a href="#38730622">prev</a><span>|</span><a href="#38731270">next</a><span>|</span><label class="collapse" for="c-38729728">[-]</label><label class="expand" for="c-38729728">[7 more]</label></div><br/><div class="children"><div class="content">I disagree that this is trivial.<p>You have a function, and that function could have local bindings to arbitrary local variables.</div><br/><div id="38730625" class="c"><input type="checkbox" id="c-38730625" checked=""/><div class="controls bullet"><span class="by">johnfn</span><span>|</span><a href="#38729653">root</a><span>|</span><a href="#38729728">parent</a><span>|</span><a href="#38730808">next</a><span>|</span><label class="collapse" for="c-38730625">[-]</label><label class="expand" for="c-38730625">[3 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t say that the algorithm was trivial, just that the object was. `{ foo: () =&gt; {} }` is a fairly trivial object, all things considered.</div><br/><div id="38731278" class="c"><input type="checkbox" id="c-38731278" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#38729653">root</a><span>|</span><a href="#38730625">parent</a><span>|</span><a href="#38730808">next</a><span>|</span><label class="collapse" for="c-38731278">[-]</label><label class="expand" for="c-38731278">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not an object. JSON wouldn&#x27;t cover that. It&#x27;s code. With code complexity. That&#x27;s non trivial &amp; you seem to double down on an extensive ask far beyond .odt people&#x27;s &amp; what the typical need is, in a way that belittles the effort. I don&#x27;t like how short you are, how you phrase this as some huge weakness. When in fact JSON.stringify&#x2F;parse - what everyone uses today - have the same object-but-not-code limitations.</div><br/><div id="38732088" class="c"><input type="checkbox" id="c-38732088" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#38729653">root</a><span>|</span><a href="#38731278">parent</a><span>|</span><a href="#38730808">next</a><span>|</span><label class="collapse" for="c-38732088">[-]</label><label class="expand" for="c-38732088">[1 more]</label></div><br/><div class="children"><div class="content">Functions are first-class objects though…? What’s json got to do with cloning objects except its prevalence as a limited workaround?</div><br/></div></div></div></div></div></div><div id="38730808" class="c"><input type="checkbox" id="c-38730808" checked=""/><div class="controls bullet"><span class="by">dap</span><span>|</span><a href="#38729653">root</a><span>|</span><a href="#38729728">parent</a><span>|</span><a href="#38730625">prev</a><span>|</span><a href="#38731270">next</a><span>|</span><label class="collapse" for="c-38730808">[-]</label><label class="expand" for="c-38730808">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s been a little while since I wrote JavaScript.  Aren&#x27;t Function objects immutable?  Would it not satisfy the desired behavior of clone to reference the same function (not copy it) in the new object?</div><br/><div id="38731008" class="c"><input type="checkbox" id="c-38731008" checked=""/><div class="controls bullet"><span class="by">eyelidlessness</span><span>|</span><a href="#38729653">root</a><span>|</span><a href="#38730808">parent</a><span>|</span><a href="#38730887">next</a><span>|</span><label class="collapse" for="c-38731008">[-]</label><label class="expand" for="c-38731008">[1 more]</label></div><br/><div class="children"><div class="content">Even if functions were immutable <i>as objects</i>, they can reference anything within their containing scope, including arbitrary dynamic variables in outer scopes and even values from other modules (whose bindings are “live”). They may also have their “this” bound to arbitrary objects from any scope at all.</div><br/></div></div><div id="38730887" class="c"><input type="checkbox" id="c-38730887" checked=""/><div class="controls bullet"><span class="by">aragonite</span><span>|</span><a href="#38729653">root</a><span>|</span><a href="#38730808">parent</a><span>|</span><a href="#38731008">prev</a><span>|</span><a href="#38731270">next</a><span>|</span><label class="collapse" for="c-38730887">[-]</label><label class="expand" for="c-38730887">[1 more]</label></div><br/><div class="children"><div class="content">Function objects are mutable in the sense that you can define new properties for them or assign new values to (writable) existing properties. This is sometimes used to simulate static variables:<p><pre><code>  function f() {
    f.count ??= 1;
    console.log(f.count++);
  }
  f(); &#x2F;&#x2F; Outputs: 1
  f(); &#x2F;&#x2F; Outputs: 2
  f(); &#x2F;&#x2F; Outputs: 3</code></pre></div><br/></div></div></div></div></div></div><div id="38731270" class="c"><input type="checkbox" id="c-38731270" checked=""/><div class="controls bullet"><span class="by">__s</span><span>|</span><a href="#38729653">parent</a><span>|</span><a href="#38729728">prev</a><span>|</span><a href="#38729397">next</a><span>|</span><label class="collapse" for="c-38731270">[-]</label><label class="expand" for="c-38731270">[1 more]</label></div><br/><div class="children"><div class="content">Consider LJSON: <a href="https:&#x2F;&#x2F;github.com&#x2F;VictorTaelin&#x2F;LJSON">https:&#x2F;&#x2F;github.com&#x2F;VictorTaelin&#x2F;LJSON</a></div><br/></div></div></div></div><div id="38729397" class="c"><input type="checkbox" id="c-38729397" checked=""/><div class="controls bullet"><span class="by">fennecbutt</span><span>|</span><a href="#38729653">prev</a><span>|</span><a href="#38729579">next</a><span>|</span><label class="collapse" for="c-38729397">[-]</label><label class="expand" for="c-38729397">[3 more]</label></div><br/><div class="children"><div class="content">As a JS&#x2F;TS dev since the early node says I still can&#x27;t believe how long we used the json stringify method for.<p>Not because it worked well, but because it was _good enough_. I feel like that in itself is an important lesson about our industry and probably the world.</div><br/><div id="38729938" class="c"><input type="checkbox" id="c-38729938" checked=""/><div class="controls bullet"><span class="by">fshr</span><span>|</span><a href="#38729397">parent</a><span>|</span><a href="#38731985">next</a><span>|</span><label class="collapse" for="c-38729938">[-]</label><label class="expand" for="c-38729938">[1 more]</label></div><br/><div class="children"><div class="content">It reminds me of using the STUFF() + FOR XML PATH trick in T-SQL (mssql) for so many years to aggregate row values into a comma separated string. Now you just call STRING_AGG()</div><br/></div></div><div id="38731985" class="c"><input type="checkbox" id="c-38731985" checked=""/><div class="controls bullet"><span class="by">uxp8u61q</span><span>|</span><a href="#38729397">parent</a><span>|</span><a href="#38729938">prev</a><span>|</span><a href="#38729579">next</a><span>|</span><label class="collapse" for="c-38731985">[-]</label><label class="expand" for="c-38731985">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the point of introducing a new solution that in the end produces the same results with the same caveats and limitations?</div><br/></div></div></div></div><div id="38729579" class="c"><input type="checkbox" id="c-38729579" checked=""/><div class="controls bullet"><span class="by">hughw</span><span>|</span><a href="#38729397">prev</a><span>|</span><a href="#38728847">next</a><span>|</span><label class="collapse" for="c-38729579">[-]</label><label class="expand" for="c-38729579">[4 more]</label></div><br/><div class="children"><div class="content">Looks like Webkit doesn&#x27;t support it in workers. Does anyone know why that would be difficult?</div><br/><div id="38729636" class="c"><input type="checkbox" id="c-38729636" checked=""/><div class="controls bullet"><span class="by">culi</span><span>|</span><a href="#38729579">parent</a><span>|</span><a href="#38728847">next</a><span>|</span><label class="collapse" for="c-38729636">[-]</label><label class="expand" for="c-38729636">[3 more]</label></div><br/><div class="children"><div class="content">well it was only adopted in 2022 across browsers. Where did you find that it&#x27;s not supported in webworkers? This makes me think it&#x27;s functional<p><a href="https:&#x2F;&#x2F;bugs.webkit.org&#x2F;show_bug.cgi?id=228331" rel="nofollow noreferrer">https:&#x2F;&#x2F;bugs.webkit.org&#x2F;show_bug.cgi?id=228331</a></div><br/><div id="38729659" class="c"><input type="checkbox" id="c-38729659" checked=""/><div class="controls bullet"><span class="by">hughw</span><span>|</span><a href="#38729579">root</a><span>|</span><a href="#38729636">parent</a><span>|</span><a href="#38728847">next</a><span>|</span><label class="collapse" for="c-38729659">[-]</label><label class="expand" for="c-38729659">[2 more]</label></div><br/><div class="children"><div class="content">A screenshot of caniuse or similar is in the linked article.</div><br/><div id="38730995" class="c"><input type="checkbox" id="c-38730995" checked=""/><div class="controls bullet"><span class="by">hughw</span><span>|</span><a href="#38729579">root</a><span>|</span><a href="#38729659">parent</a><span>|</span><a href="#38728847">next</a><span>|</span><label class="collapse" for="c-38730995">[-]</label><label class="expand" for="c-38730995">[1 more]</label></div><br/><div class="children"><div class="content">The screenshot was from MDN [1] but today the support table is all green; no caveats for workers.<p>[1] <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;structuredClone" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;structuredC...</a></div><br/></div></div></div></div></div></div></div></div><div id="38728847" class="c"><input type="checkbox" id="c-38728847" checked=""/><div class="controls bullet"><span class="by">twic</span><span>|</span><a href="#38729579">prev</a><span>|</span><a href="#38730886">next</a><span>|</span><label class="collapse" for="c-38728847">[-]</label><label class="expand" for="c-38728847">[4 more]</label></div><br/><div class="children"><div class="content">Not cloning instances of classes properly is a surprise. Is there a particular reason for that?</div><br/><div id="38729690" class="c"><input type="checkbox" id="c-38729690" checked=""/><div class="controls bullet"><span class="by">eyelidlessness</span><span>|</span><a href="#38728847">parent</a><span>|</span><a href="#38729053">next</a><span>|</span><label class="collapse" for="c-38729690">[-]</label><label class="expand" for="c-38729690">[1 more]</label></div><br/><div class="children"><div class="content">structuredClone is a standard library implementation of the structured clone algorithm, which was originally mainly designed for passing data between realms (eg between threads). Prototype chains are not preserved across realms, so it makes sense that the algorithm wouldn’t either. The accommodation for native&#x2F;host types is possible because they’re implemented in each realm by the runtime, but user-defined classes don’t have that benefit.</div><br/></div></div><div id="38729053" class="c"><input type="checkbox" id="c-38729053" checked=""/><div class="controls bullet"><span class="by">jwalton</span><span>|</span><a href="#38728847">parent</a><span>|</span><a href="#38729690">prev</a><span>|</span><a href="#38728953">next</a><span>|</span><label class="collapse" for="c-38729053">[-]</label><label class="expand" for="c-38729053">[1 more]</label></div><br/><div class="children"><div class="content">On the one hand, you’d think the copy would just have a prototype that points to the same as the original’s prototype, and that would make this all work out.  I’m surprised that’s not what happens since in 99% of cases it would be fine.<p>On the other hand, when you consider #privateMembers, you realize cloning a class in JS is basically impossible (and adding them to the language was probably a horrible mistake).</div><br/></div></div><div id="38728953" class="c"><input type="checkbox" id="c-38728953" checked=""/><div class="controls bullet"><span class="by">KTibow</span><span>|</span><a href="#38728847">parent</a><span>|</span><a href="#38729053">prev</a><span>|</span><a href="#38730886">next</a><span>|</span><label class="collapse" for="c-38728953">[-]</label><label class="expand" for="c-38728953">[1 more]</label></div><br/><div class="children"><div class="content">Classes have way more complex state that could be unpredictable</div><br/></div></div></div></div><div id="38730886" class="c"><input type="checkbox" id="c-38730886" checked=""/><div class="controls bullet"><span class="by">ramesh31</span><span>|</span><a href="#38728847">prev</a><span>|</span><a href="#38728944">next</a><span>|</span><label class="collapse" for="c-38730886">[-]</label><label class="expand" for="c-38730886">[2 more]</label></div><br/><div class="children"><div class="content">Wait, what? When did this happen?</div><br/><div id="38731228" class="c"><input type="checkbox" id="c-38731228" checked=""/><div class="controls bullet"><span class="by">Semaphor</span><span>|</span><a href="#38730886">parent</a><span>|</span><a href="#38728944">next</a><span>|</span><label class="collapse" for="c-38731228">[-]</label><label class="expand" for="c-38731228">[1 more]</label></div><br/><div class="children"><div class="content">Apparently, 1-2 years ago. I was also surprised.</div><br/></div></div></div></div><div id="38728944" class="c"><input type="checkbox" id="c-38728944" checked=""/><div class="controls bullet"><span class="by">chatmasta</span><span>|</span><a href="#38730886">prev</a><span>|</span><a href="#38728923">next</a><span>|</span><label class="collapse" for="c-38728944">[-]</label><label class="expand" for="c-38728944">[57 more]</label></div><br/><div class="children"><div class="content">Unpopular opinion:<p>I have never needed to &quot;deep clone&quot; an object in JavaScript. Any time I thought I needed to do that, it was actually a code smell for a different underlying problem.<p>I was glad to see the end of the &quot;immutable everything&quot; dogmatic obsession wrought by Redux. The code smell in that case was usually related to passing entire objects as props.<p>Can anyone describe a compelling use case for &quot;deep cloning&quot; objects in JavaScript (keep in mind _everything_ is
an object in JavaScript) that isn&#x27;t dancing around some hidden complexity? IMO, if it can&#x27;t be (de)serialized via JSON.stringify and JSON.parse, then you should consider why you&#x27;re trying to serialize it in the first place, and why you&#x27;re scared to pass around the reference to the object. (That said, structuredClone looks like a better alternative to the JSON method - but note it&#x27;s still not cloning functions, so you should still be careful where&#x2F;when you use it.)</div><br/><div id="38729065" class="c"><input type="checkbox" id="c-38729065" checked=""/><div class="controls bullet"><span class="by">madeofpalk</span><span>|</span><a href="#38728944">parent</a><span>|</span><a href="#38729122">next</a><span>|</span><label class="collapse" for="c-38729065">[-]</label><label class="expand" for="c-38729065">[9 more]</label></div><br/><div class="children"><div class="content">The most common reason I&#x27;ve had to do it is to log objects to the console.<p>Chrome dev tools logs a pointer to the object, so if the object is mutated after logging, but before you view&#x2F;expand it (especially for nested structures), it can be very confusing! JSON.parse(JSON.stringify()) usually is good enough for this :)<p>But yes, generally speaking I think a deep clone is a sign of a smell elsewhere. That doesn&#x27;t mean it never has a place in any code, but just that if I find myself reaching for it, I usually see if there&#x27;s a mistake being made elsewhere.</div><br/><div id="38729132" class="c"><input type="checkbox" id="c-38729132" checked=""/><div class="controls bullet"><span class="by">dylan604</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38729065">parent</a><span>|</span><a href="#38729122">next</a><span>|</span><label class="collapse" for="c-38729132">[-]</label><label class="expand" for="c-38729132">[8 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t that desired? You want to see what the object looks at at the time of logging. If you need to see it after some additional code has run, you log it again.</div><br/><div id="38729169" class="c"><input type="checkbox" id="c-38729169" checked=""/><div class="controls bullet"><span class="by">Akronymus</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38729132">parent</a><span>|</span><a href="#38730614">next</a><span>|</span><label class="collapse" for="c-38729169">[-]</label><label class="expand" for="c-38729169">[5 more]</label></div><br/><div class="children"><div class="content">The problem is that if you log one object multiple times, they all point to the same object.<p>So if between two logs it was modified, it reflects the new status on the log before as well.<p>I think you may have been confused and got how it is, vs how it ought to be the wrong way round.</div><br/><div id="38729548" class="c"><input type="checkbox" id="c-38729548" checked=""/><div class="controls bullet"><span class="by">dylan604</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38729169">parent</a><span>|</span><a href="#38729741">next</a><span>|</span><label class="collapse" for="c-38729548">[-]</label><label class="expand" for="c-38729548">[2 more]</label></div><br/><div class="children"><div class="content">to be honest, my experience with logging objects is so simple, i&#x27;ve never needed to try this live look into the object. my expectation was the log is a snap shot in time, not a live look at the object. an interactive view into the object does sound interesting rather than constant log entries for each step. which is how I would have tried to do something the first time only to be confused by it. TIL.</div><br/><div id="38730584" class="c"><input type="checkbox" id="c-38730584" checked=""/><div class="controls bullet"><span class="by">jholman</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38729548">parent</a><span>|</span><a href="#38729741">next</a><span>|</span><label class="collapse" for="c-38730584">[-]</label><label class="expand" for="c-38730584">[1 more]</label></div><br/><div class="children"><div class="content">What the parent posts are trying to hint to you is that the default logging behaviour of the console is the live-look model, which is almost never what you wanted with logging.  (Though it does have other uses.)  To avoid the live-look, you can deep clone, or just stringify.</div><br/></div></div></div></div><div id="38729741" class="c"><input type="checkbox" id="c-38729741" checked=""/><div class="controls bullet"><span class="by">jv22222</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38729169">parent</a><span>|</span><a href="#38729548">prev</a><span>|</span><a href="#38729619">next</a><span>|</span><label class="collapse" for="c-38729741">[-]</label><label class="expand" for="c-38729741">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s just one of the reasons I always say...<p><a href="https:&#x2F;&#x2F;twitter.com&#x2F;justinvincent&#x2F;status&#x2F;1714866433426067573" rel="nofollow noreferrer">https:&#x2F;&#x2F;twitter.com&#x2F;justinvincent&#x2F;status&#x2F;1714866433426067573</a></div><br/></div></div><div id="38729619" class="c"><input type="checkbox" id="c-38729619" checked=""/><div class="controls bullet"><span class="by">jay_kyburz</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38729169">parent</a><span>|</span><a href="#38729741">prev</a><span>|</span><a href="#38730614">next</a><span>|</span><label class="collapse" for="c-38729619">[-]</label><label class="expand" for="c-38729619">[1 more]</label></div><br/><div class="children"><div class="content">Wow, I never knew this.</div><br/></div></div></div></div><div id="38730614" class="c"><input type="checkbox" id="c-38730614" checked=""/><div class="controls bullet"><span class="by">cortesoft</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38729132">parent</a><span>|</span><a href="#38729169">prev</a><span>|</span><a href="#38731053">next</a><span>|</span><label class="collapse" for="c-38730614">[-]</label><label class="expand" for="c-38730614">[1 more]</label></div><br/><div class="children"><div class="content">You have it opposite… if you change the object after logging, it will retroactively change the logged version.</div><br/></div></div><div id="38731053" class="c"><input type="checkbox" id="c-38731053" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38729132">parent</a><span>|</span><a href="#38730614">prev</a><span>|</span><a href="#38729122">next</a><span>|</span><label class="collapse" for="c-38731053">[-]</label><label class="expand" for="c-38731053">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You want to see what the object looks at at the time of logging<p>Yes. That&#x27;s why you need to use structuredClone.  If you don&#x27;t, and you mutate the object, then you&#x27;ll see the new values when you expand the object.</div><br/></div></div></div></div></div></div><div id="38729122" class="c"><input type="checkbox" id="c-38729122" checked=""/><div class="controls bullet"><span class="by">sesm</span><span>|</span><a href="#38728944">parent</a><span>|</span><a href="#38729065">prev</a><span>|</span><a href="#38732181">next</a><span>|</span><label class="collapse" for="c-38729122">[-]</label><label class="expand" for="c-38729122">[10 more]</label></div><br/><div class="children"><div class="content">&gt; Can anyone describe a compelling use case for &quot;deep cloning&quot; objects in JavaScript<p>Sure. A library accepts an object as function argument (for example ‘params’) and then uses it inside. Modifying users object in-place would be a bad idea.</div><br/><div id="38730769" class="c"><input type="checkbox" id="c-38730769" checked=""/><div class="controls bullet"><span class="by">slmjkdbtl</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38729122">parent</a><span>|</span><a href="#38729319">next</a><span>|</span><label class="collapse" for="c-38730769">[-]</label><label class="expand" for="c-38730769">[1 more]</label></div><br/><div class="children"><div class="content">Another one is exporting an internally used object from the library, you don&#x27;t want user to be able to modify it.</div><br/></div></div><div id="38729319" class="c"><input type="checkbox" id="c-38729319" checked=""/><div class="controls bullet"><span class="by">WendyTheWillow</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38729122">parent</a><span>|</span><a href="#38730769">prev</a><span>|</span><a href="#38732181">next</a><span>|</span><label class="collapse" for="c-38729319">[-]</label><label class="expand" for="c-38729319">[8 more]</label></div><br/><div class="children"><div class="content">The smell here is in the library, is the commenter&#x27;s point.  The solution would be to search for a better written library.</div><br/><div id="38730965" class="c"><input type="checkbox" id="c-38730965" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38729319">parent</a><span>|</span><a href="#38729450">next</a><span>|</span><label class="collapse" for="c-38730965">[-]</label><label class="expand" for="c-38730965">[2 more]</label></div><br/><div class="children"><div class="content">Another issue is the opposite situation, where the library reads from the object multiple times, expecting the value to be stable, but the caller might change the value in between, either from the properties using getters or from the library being async. The library has to make a full deep copy to ensure that it&#x27;s completely stable regardless of the caller&#x27;s actions. Just freezing the input object would be confusing to the caller and still vulnerable to property getters.</div><br/><div id="38731549" class="c"><input type="checkbox" id="c-38731549" checked=""/><div class="controls bullet"><span class="by">WendyTheWillow</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38730965">parent</a><span>|</span><a href="#38729450">next</a><span>|</span><label class="collapse" for="c-38731549">[-]</label><label class="expand" for="c-38731549">[1 more]</label></div><br/><div class="children"><div class="content">That’s even worse! I would try to avoid a library with a function that fragile.</div><br/></div></div></div></div><div id="38729450" class="c"><input type="checkbox" id="c-38729450" checked=""/><div class="controls bullet"><span class="by">_a_a_a_</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38729319">parent</a><span>|</span><a href="#38730965">prev</a><span>|</span><a href="#38732181">next</a><span>|</span><label class="collapse" for="c-38729450">[-]</label><label class="expand" for="c-38729450">[5 more]</label></div><br/><div class="children"><div class="content">Sure! Use a library that deep-clones the object first, leaving the original parameter unchanged! And now it&#x27;s slower than the original library you&#x27;re criticising.</div><br/><div id="38729600" class="c"><input type="checkbox" id="c-38729600" checked=""/><div class="controls bullet"><span class="by">WendyTheWillow</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38729450">parent</a><span>|</span><a href="#38732181">next</a><span>|</span><label class="collapse" for="c-38729600">[-]</label><label class="expand" for="c-38729600">[4 more]</label></div><br/><div class="children"><div class="content">Or use a library that doesn’t modify the input…</div><br/><div id="38729625" class="c"><input type="checkbox" id="c-38729625" checked=""/><div class="controls bullet"><span class="by">_a_a_a_</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38729600">parent</a><span>|</span><a href="#38732181">next</a><span>|</span><label class="collapse" for="c-38729625">[-]</label><label class="expand" for="c-38729625">[3 more]</label></div><br/><div class="children"><div class="content">By deep-copying it, right? Sometimes it is needed.</div><br/><div id="38730621" class="c"><input type="checkbox" id="c-38730621" checked=""/><div class="controls bullet"><span class="by">jcparkyn</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38729625">parent</a><span>|</span><a href="#38729922">next</a><span>|</span><label class="collapse" for="c-38730621">[-]</label><label class="expand" for="c-38730621">[1 more]</label></div><br/><div class="children"><div class="content">If you know what modifications you need to make (hopefully the library author does), you only need to clone the relevant parts of the object (e.g. with spreading). Deep cloning still isn&#x27;t usually necessary unless you&#x27;re doing wierd stuff.</div><br/></div></div><div id="38729922" class="c"><input type="checkbox" id="c-38729922" checked=""/><div class="controls bullet"><span class="by">WendyTheWillow</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38729625">parent</a><span>|</span><a href="#38730621">prev</a><span>|</span><a href="#38732181">next</a><span>|</span><label class="collapse" for="c-38729922">[-]</label><label class="expand" for="c-38729922">[1 more]</label></div><br/><div class="children"><div class="content">…the whole thread you’re replying to is about it not actually being necessary.  To participate in this conversation you either accept that premise or disagree with it, passing it as a given is not really an option for the argument.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38732181" class="c"><input type="checkbox" id="c-38732181" checked=""/><div class="controls bullet"><span class="by">giankam</span><span>|</span><a href="#38728944">parent</a><span>|</span><a href="#38729122">prev</a><span>|</span><a href="#38729002">next</a><span>|</span><label class="collapse" for="c-38732181">[-]</label><label class="expand" for="c-38732181">[1 more]</label></div><br/><div class="children"><div class="content">I have an application with a big data structure built as a tree of objects. With deep cloning I can:
- Provide undo&#x2F;redo. I just clone the whole tree.
- Load&#x2F;Save from&#x2F;to the database part of the tree. I load it in a separate object and then deep clone in place.
- Do mass modifications to a part of the tree. A clone a copy, apply modifications and the clone back in place.<p>I could do some of the changes in place, but to optimize Vue reactivity I work on copies.<p>I use prototypes so only lodash works for me.</div><br/></div></div><div id="38729002" class="c"><input type="checkbox" id="c-38729002" checked=""/><div class="controls bullet"><span class="by">endisneigh</span><span>|</span><a href="#38728944">parent</a><span>|</span><a href="#38732181">prev</a><span>|</span><a href="#38730627">next</a><span>|</span><label class="collapse" for="c-38729002">[-]</label><label class="expand" for="c-38729002">[3 more]</label></div><br/><div class="children"><div class="content">There are plenty of reasons to deepclone. That being said I do share some agreement. JavaScript imo is best when you limit complex structures and stick with primitives, ideally just one layer deep, but there are situations when it can’t be helped, e.g, dealing with api calls.</div><br/><div id="38729047" class="c"><input type="checkbox" id="c-38729047" checked=""/><div class="controls bullet"><span class="by">chatmasta</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38729002">parent</a><span>|</span><a href="#38730627">next</a><span>|</span><label class="collapse" for="c-38729047">[-]</label><label class="expand" for="c-38729047">[2 more]</label></div><br/><div class="children"><div class="content">Yep. But API calls traverse the network, and assuming that&#x27;s via JSON, you&#x27;re already losing functionality like Date parsing, so the litmus test of JSON.stringify&#x2F;parse seems appropriate to determine if you&#x27;re dealing with a true &quot;data object.&quot; If you run into issues with things like Dates, then it&#x27;s a smell indicating a potential point of divergence in different codepaths that handle the network call differently.</div><br/><div id="38729084" class="c"><input type="checkbox" id="c-38729084" checked=""/><div class="controls bullet"><span class="by">endisneigh</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38729047">parent</a><span>|</span><a href="#38730627">next</a><span>|</span><label class="collapse" for="c-38729084">[-]</label><label class="expand" for="c-38729084">[1 more]</label></div><br/><div class="children"><div class="content">I don’t disagree, but just responding to your comments first paragraph.</div><br/></div></div></div></div></div></div><div id="38730627" class="c"><input type="checkbox" id="c-38730627" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#38728944">parent</a><span>|</span><a href="#38729002">prev</a><span>|</span><a href="#38732122">next</a><span>|</span><label class="collapse" for="c-38730627">[-]</label><label class="expand" for="c-38730627">[1 more]</label></div><br/><div class="children"><div class="content">If something is immutable then you never need to clone it. Just copy the reference.<p>If an object is immutable and you want to copy&#x2F;mutate one item it then you can surgically clone it in O(how deeply nested the item to change is). Object spread being the simple case.<p>JS makes this messy to do though! Lots of spreads and array maps or you pull in a library like Immer and now have “coloured” objects. Immutability in JS is not idiomatic so for that reason I try to avoid unless I really need to.</div><br/></div></div><div id="38732122" class="c"><input type="checkbox" id="c-38732122" checked=""/><div class="controls bullet"><span class="by">vasergen</span><span>|</span><a href="#38728944">parent</a><span>|</span><a href="#38730627">prev</a><span>|</span><a href="#38729796">next</a><span>|</span><label class="collapse" for="c-38732122">[-]</label><label class="expand" for="c-38732122">[1 more]</label></div><br/><div class="children"><div class="content">I used it mostly when I pass an object into a function I don&#x27;t control, but I want to make sure that the original object won&#x27;t be changed.</div><br/></div></div><div id="38729796" class="c"><input type="checkbox" id="c-38729796" checked=""/><div class="controls bullet"><span class="by">efortis</span><span>|</span><a href="#38728944">parent</a><span>|</span><a href="#38732122">prev</a><span>|</span><a href="#38730016">next</a><span>|</span><label class="collapse" for="c-38729796">[-]</label><label class="expand" for="c-38729796">[2 more]</label></div><br/><div class="children"><div class="content">Undo. I use it in UI Drafter for handling Undo.<p>For example, I create a revision of a store (a deep clone) and apply the undo frames one-by-one.<p>Each undo frame has the setter name and its arguments. IOW, the frames contain what changed, such as:<p><pre><code>    [
      [BASE.setCard, &#x27;some-id&#x27;, CF.title, &#x27;The New Title&#x27;],
      …more frames
    ]

</code></pre>
Here&#x27;s a post with more details<p><a href="https:&#x2F;&#x2F;blog.uidrafter.com&#x2F;architecture-of-a-desktop-alike-spa" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.uidrafter.com&#x2F;architecture-of-a-desktop-alike-s...</a></div><br/><div id="38732184" class="c"><input type="checkbox" id="c-38732184" checked=""/><div class="controls bullet"><span class="by">giankam</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38729796">parent</a><span>|</span><a href="#38730016">next</a><span>|</span><label class="collapse" for="c-38732184">[-]</label><label class="expand" for="c-38732184">[1 more]</label></div><br/><div class="children"><div class="content">Yep, I do the same.</div><br/></div></div></div></div><div id="38730016" class="c"><input type="checkbox" id="c-38730016" checked=""/><div class="controls bullet"><span class="by">laurencerowe</span><span>|</span><a href="#38728944">parent</a><span>|</span><a href="#38729796">prev</a><span>|</span><a href="#38730815">next</a><span>|</span><label class="collapse" for="c-38730016">[-]</label><label class="expand" for="c-38730016">[3 more]</label></div><br/><div class="children"><div class="content">Pedantically, while _everything_ is an object is true for Python it’s not for JavaScript which has distinct primitive types for strings, numbers, booleans, symbols, and undefined.</div><br/><div id="38730607" class="c"><input type="checkbox" id="c-38730607" checked=""/><div class="controls bullet"><span class="by">jholman</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38730016">parent</a><span>|</span><a href="#38730815">next</a><span>|</span><label class="collapse" for="c-38730607">[-]</label><label class="expand" for="c-38730607">[2 more]</label></div><br/><div class="children"><div class="content">And null.  I know that typeof(null) says &#x27;object&#x27;, but it&#x27;s lying.  When I say &quot;it&#x27;s lying&quot;, I mean that according to the spec, null is of type null.  Also it has absolutely nothing in common with objects except for the output of typeof.<p>Also these days there&#x27;s BigInt.</div><br/><div id="38732132" class="c"><input type="checkbox" id="c-38732132" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38730607">parent</a><span>|</span><a href="#38730815">next</a><span>|</span><label class="collapse" for="c-38732132">[-]</label><label class="expand" for="c-38732132">[1 more]</label></div><br/><div class="children"><div class="content">JS is amazing.<p>As in, it’s amazing that anything actually works given the internal inconsistencies in its core.<p>(Disclaimer: I code ts&#x2F;js for a living.)</div><br/></div></div></div></div></div></div><div id="38730815" class="c"><input type="checkbox" id="c-38730815" checked=""/><div class="controls bullet"><span class="by">ehutch79</span><span>|</span><a href="#38728944">parent</a><span>|</span><a href="#38730016">prev</a><span>|</span><a href="#38729649">next</a><span>|</span><label class="collapse" for="c-38730815">[-]</label><label class="expand" for="c-38730815">[1 more]</label></div><br/><div class="children"><div class="content">An edit dialog where you want to be able to cancel editing without leaving changes on the original object.</div><br/></div></div><div id="38729649" class="c"><input type="checkbox" id="c-38729649" checked=""/><div class="controls bullet"><span class="by">jv22222</span><span>|</span><a href="#38728944">parent</a><span>|</span><a href="#38730815">prev</a><span>|</span><a href="#38729537">next</a><span>|</span><label class="collapse" for="c-38729649">[-]</label><label class="expand" for="c-38729649">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Can anyone describe a compelling use case for &quot;deep cloning&quot; objects in JavaScript<p>Hierarchical data structures, in mindmaps, menu structures, block based notes apps, etc.</div><br/><div id="38730733" class="c"><input type="checkbox" id="c-38730733" checked=""/><div class="controls bullet"><span class="by">niedzielski</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38729649">parent</a><span>|</span><a href="#38729537">next</a><span>|</span><label class="collapse" for="c-38730733">[-]</label><label class="expand" for="c-38730733">[1 more]</label></div><br/><div class="children"><div class="content">I agree. I had this same problem with a tree UI model. Each node had links to both the children and the parent. Mutating any node in the tree, changes the reference of that node. Mutating the linkage to the updated node cascades to every other node in the tree.</div><br/></div></div></div></div><div id="38729537" class="c"><input type="checkbox" id="c-38729537" checked=""/><div class="controls bullet"><span class="by">hutzlibu</span><span>|</span><a href="#38728944">parent</a><span>|</span><a href="#38729649">prev</a><span>|</span><a href="#38728981">next</a><span>|</span><label class="collapse" for="c-38729537">[-]</label><label class="expand" for="c-38729537">[4 more]</label></div><br/><div class="children"><div class="content">One use case I have, which I do not like, but there is literally no other way:<p>Communicating with workerthreads.<p>I so much would like to pass references of big readonly objects towards them - but no, full copy it is, for every thread.</div><br/><div id="38729729" class="c"><input type="checkbox" id="c-38729729" checked=""/><div class="controls bullet"><span class="by">chatmasta</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38729537">parent</a><span>|</span><a href="#38728981">next</a><span>|</span><label class="collapse" for="c-38729729">[-]</label><label class="expand" for="c-38729729">[3 more]</label></div><br/><div class="children"><div class="content">You&#x27;re probably aware of this, but in some cases you might be able to use SharedArrayBuffer [0], which doesn&#x27;t make a copy of the underlying data but does use structured cloning to clone the outside of the object.<p>[0] <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;SharedArrayBuffer" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Refe...</a></div><br/><div id="38729814" class="c"><input type="checkbox" id="c-38729814" checked=""/><div class="controls bullet"><span class="by">hutzlibu</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38729729">parent</a><span>|</span><a href="#38728981">next</a><span>|</span><label class="collapse" for="c-38729814">[-]</label><label class="expand" for="c-38729814">[2 more]</label></div><br/><div class="children"><div class="content">I only used it for experimentation so far, but I abondoned it, after I learned, that only one worker can be the active user of a SharedArrayBuffer. So they cannot be shared at the same time? Sharing seems to mean, now A uses it, than gives control back, via the main thread, then B uses it, etc<p>(but I hope I missunderstood something there)<p>But I need many threads to access the same data, at the same time (readonly, so no racecondition).</div><br/><div id="38730630" class="c"><input type="checkbox" id="c-38730630" checked=""/><div class="controls bullet"><span class="by">bongobingo1</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38729814">parent</a><span>|</span><a href="#38728981">next</a><span>|</span><label class="collapse" for="c-38730630">[-]</label><label class="expand" for="c-38730630">[1 more]</label></div><br/><div class="children"><div class="content">Ah, the OnlyChild implementation of Shared.</div><br/></div></div></div></div></div></div></div></div><div id="38728981" class="c"><input type="checkbox" id="c-38728981" checked=""/><div class="controls bullet"><span class="by">holoduke</span><span>|</span><a href="#38728944">parent</a><span>|</span><a href="#38729537">prev</a><span>|</span><a href="#38729638">next</a><span>|</span><label class="collapse" for="c-38728981">[-]</label><label class="expand" for="c-38728981">[2 more]</label></div><br/><div class="children"><div class="content">An object containing just data for sure having lots of usecases. Like i.e undo&#x2F;redo. But deep cloning would be as simple as json.parse(json.stringify(object))</div><br/><div id="38729062" class="c"><input type="checkbox" id="c-38729062" checked=""/><div class="controls bullet"><span class="by">chatmasta</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38728981">parent</a><span>|</span><a href="#38729638">next</a><span>|</span><label class="collapse" for="c-38729062">[-]</label><label class="expand" for="c-38729062">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, agreed. And in that case you should treat the &quot;data object&quot; as opaque, in which case it should be sufficient to pass it by reference. Hence, if you&#x27;re reaching for deepClone, it&#x27;s a code smell - why can&#x27;t you pass the reference? Are you mutating the data object somewhere that you shouldn&#x27;t be?</div><br/></div></div></div></div><div id="38729638" class="c"><input type="checkbox" id="c-38729638" checked=""/><div class="controls bullet"><span class="by">kevincox</span><span>|</span><a href="#38728944">parent</a><span>|</span><a href="#38728981">prev</a><span>|</span><a href="#38731086">next</a><span>|</span><label class="collapse" for="c-38729638">[-]</label><label class="expand" for="c-38729638">[1 more]</label></div><br/><div class="children"><div class="content">The saving grace here is that it destroys classes. I have often seen deep clone and deep equals as a sort of back-door API that then breaks when the implementation of the class does. The fact that this ignores prototypes makes it clear that you should only be using this for data, not &quot;OO Objects&quot;.</div><br/></div></div><div id="38731086" class="c"><input type="checkbox" id="c-38731086" checked=""/><div class="controls bullet"><span class="by">namuol</span><span>|</span><a href="#38728944">parent</a><span>|</span><a href="#38729638">prev</a><span>|</span><a href="#38729135">next</a><span>|</span><label class="collapse" for="c-38731086">[-]</label><label class="expand" for="c-38731086">[1 more]</label></div><br/><div class="children"><div class="content">Popular opinion* at least amongst the JS developers I’ve worked with for the last 10 years or so.</div><br/></div></div><div id="38729135" class="c"><input type="checkbox" id="c-38729135" checked=""/><div class="controls bullet"><span class="by">compacct27</span><span>|</span><a href="#38728944">parent</a><span>|</span><a href="#38731086">prev</a><span>|</span><a href="#38729070">next</a><span>|</span><label class="collapse" for="c-38729135">[-]</label><label class="expand" for="c-38729135">[3 more]</label></div><br/><div class="children"><div class="content">React needs a new object for its hooks when you change them. We need to modify those objects, so deepClone + direct mutation on the clone bypasses a lot of annoying immutable object creation bs. ppl just destructure the whole thing anyways, which is actually also pretty slow</div><br/><div id="38729743" class="c"><input type="checkbox" id="c-38729743" checked=""/><div class="controls bullet"><span class="by">chatmasta</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38729135">parent</a><span>|</span><a href="#38730592">next</a><span>|</span><label class="collapse" for="c-38729743">[-]</label><label class="expand" for="c-38729743">[1 more]</label></div><br/><div class="children"><div class="content">React hooks don&#x27;t need to add the entire object to their dependency array; they can specify only the properties that are actually dependencies of the logic contained in the hook.</div><br/></div></div><div id="38730592" class="c"><input type="checkbox" id="c-38730592" checked=""/><div class="controls bullet"><span class="by">jcparkyn</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38729135">parent</a><span>|</span><a href="#38729743">prev</a><span>|</span><a href="#38729070">next</a><span>|</span><label class="collapse" for="c-38730592">[-]</label><label class="expand" for="c-38730592">[1 more]</label></div><br/><div class="children"><div class="content">You should check out immer for that use case (&quot;modifying&quot; an immutable object with imperative code).</div><br/></div></div></div></div><div id="38729070" class="c"><input type="checkbox" id="c-38729070" checked=""/><div class="controls bullet"><span class="by">davidmurdoch</span><span>|</span><a href="#38728944">parent</a><span>|</span><a href="#38729135">prev</a><span>|</span><a href="#38729110">next</a><span>|</span><label class="collapse" for="c-38729070">[-]</label><label class="expand" for="c-38729070">[1 more]</label></div><br/><div class="children"><div class="content">In my circles, &quot;immutable everything&quot; was from the functional purists.</div><br/></div></div><div id="38729110" class="c"><input type="checkbox" id="c-38729110" checked=""/><div class="controls bullet"><span class="by">Waterluvian</span><span>|</span><a href="#38728944">parent</a><span>|</span><a href="#38729070">prev</a><span>|</span><a href="#38729316">next</a><span>|</span><label class="collapse" for="c-38729110">[-]</label><label class="expand" for="c-38729110">[1 more]</label></div><br/><div class="children"><div class="content">Immutable structures are beautiful when I’ve got an editor for geographic data and want a high performance undo&#x2F;redo stack with basically no effort. It’s also considerably cheaper to identify when groups of polygons have changed by object identity rather than deep equality.  Did this property change? Did properties in general change? Did this polygon change? Did this collection of polygons change? All using === equality checks without any manual plumbing. About ten years into doing it this way and I’ve got one regret: starting with ImmutableJS instead of Immer.</div><br/></div></div><div id="38729316" class="c"><input type="checkbox" id="c-38729316" checked=""/><div class="controls bullet"><span class="by">dtx1</span><span>|</span><a href="#38728944">parent</a><span>|</span><a href="#38729110">prev</a><span>|</span><a href="#38729117">next</a><span>|</span><label class="collapse" for="c-38729316">[-]</label><label class="expand" for="c-38729316">[8 more]</label></div><br/><div class="children"><div class="content">I am building a card game engine in typescript. A simple AI based on monte carlo tree search requires me to copy the gamestate a lot. And it&#x27;s always a list of cards that i&#x27;m modeling so I really need to deepclone arrays.</div><br/><div id="38730663" class="c"><input type="checkbox" id="c-38730663" checked=""/><div class="controls bullet"><span class="by">jholman</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38729316">parent</a><span>|</span><a href="#38729829">next</a><span>|</span><label class="collapse" for="c-38730663">[-]</label><label class="expand" for="c-38730663">[1 more]</label></div><br/><div class="children"><div class="content">There are at least two obvious alternatives to (fully) deepcloning.<p>First, many &quot;everything must be immutable&quot; libraries provide data structures that give operations that feel like mutations (but actually are not), and many of those can re-use all the old objects that are not mutated.  This could save a lot, relative to full naive deepcopies.  Or it could save very little, depending on what you&#x27;re doing.<p>Second, if you have the ability, you can always mutate before recursion and then revert when the recursion finishes.  This could potentially be very tricky, because it&#x27;s not always easy to revert mutations.  As such, it&#x27;s not a good plan for a prototype, but if you can get it right, this could make your tree search wayyyyy faster.</div><br/></div></div><div id="38729829" class="c"><input type="checkbox" id="c-38729829" checked=""/><div class="controls bullet"><span class="by">chatmasta</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38729316">parent</a><span>|</span><a href="#38730663">prev</a><span>|</span><a href="#38729117">next</a><span>|</span><label class="collapse" for="c-38729829">[-]</label><label class="expand" for="c-38729829">[6 more]</label></div><br/><div class="children"><div class="content">Can you not serialize this state to&#x2F;from JSON? I&#x27;d encourage trying to reduce the state to be JSON-serializable, and then re-initialize any &quot;classes&quot; after deserializarion with a .fromJSON() method (the &quot;factory method&quot; pattern) - in fact you can even call such .toJSON() &quot;replacer&quot; [0] and .fromJSON() &quot;reviver&quot; [1] functions in a callback passed to JSON.stringify and JSON.parse.<p>[0] <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;JSON&#x2F;stringify#the_replacer_parameter" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Refe...</a><p>[1] <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;JSON&#x2F;parse#the_reviver_parameter" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Refe...</a></div><br/><div id="38730641" class="c"><input type="checkbox" id="c-38730641" checked=""/><div class="controls bullet"><span class="by">jholman</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38729829">parent</a><span>|</span><a href="#38729863">next</a><span>|</span><label class="collapse" for="c-38730641">[-]</label><label class="expand" for="c-38730641">[1 more]</label></div><br/><div class="children"><div class="content">How is this better than deepcopying?<p>Deserializing requires paying all the same costs as deepcopying, both in terms of compute time and in terms of memory usage, but it also incurs the extra costs of parsing.<p>I&#x27;m not saying that there wouldn&#x27;t be benefits to having a serializer for their gamestate (because there would surely be benefits), but I just cannot understand this as an alternative for the problem they described.</div><br/></div></div><div id="38729863" class="c"><input type="checkbox" id="c-38729863" checked=""/><div class="controls bullet"><span class="by">dtx1</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38729829">parent</a><span>|</span><a href="#38730641">prev</a><span>|</span><a href="#38729117">next</a><span>|</span><label class="collapse" for="c-38729863">[-]</label><label class="expand" for="c-38729863">[4 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t really gotten to the point where anything works but doing the serialize de&#x2F;serialize combo is possible. The issue is, that I am thinking about doing this not a few hundred times but more like several million times (preferably per minute), so i&#x27;ll likely have to implement several competing versions and benchmark them.<p>The full idea is implement a deckbuilding game like magic and use genetic algorithms and montecarlo simulation to balance the card pool. But that requires millions of games with millions of simulations to work. So i&#x27;ll see if it&#x27;s even possible.</div><br/><div id="38730004" class="c"><input type="checkbox" id="c-38730004" checked=""/><div class="controls bullet"><span class="by">chatmasta</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38729863">parent</a><span>|</span><a href="#38729117">next</a><span>|</span><label class="collapse" for="c-38730004">[-]</label><label class="expand" for="c-38730004">[3 more]</label></div><br/><div class="children"><div class="content">If you really need maximum performance then you probably don&#x27;t want to deal with JS objects at all. (But you should benchmark it first... you might be surprised how far V8 gets you with JIT optimizations - although serialization will be a bottleneck whether you&#x27;re using JSON or deepClone.) For example, as one potential alternative, you could invent a scheme for encoding the state in a bit array, and then find clever bitwise operations for inspecting or manipulating it.<p>For inspiration, many chess engines store game state in a &quot;bitboard&quot; [0] which is a 64 bit representation of some (partial) state of the board.<p>Of course, at this point you might not even want to be using JavaScript... maybe you could write the hot path in Rust, compile it to wasm, and then use JS for orchestration&#x2F;UI.<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Bitboard#Chess_bitboards" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Bitboard#Chess_bitboards</a></div><br/><div id="38730135" class="c"><input type="checkbox" id="c-38730135" checked=""/><div class="controls bullet"><span class="by">dtx1</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38730004">parent</a><span>|</span><a href="#38729117">next</a><span>|</span><label class="collapse" for="c-38730135">[-]</label><label class="expand" for="c-38730135">[2 more]</label></div><br/><div class="children"><div class="content">That is really useful, thank you! I think first stage is building the game and see if the whole Genetic Algorithm&#x2F;Monte Carlo Setup actually works, even if the first few iterations take weeks.<p>The issue is I want to figure out if there are combos that I don&#x27;t even know exist that are unusually strong. Basically make sure I balance the card pool but automatically.</div><br/><div id="38730953" class="c"><input type="checkbox" id="c-38730953" checked=""/><div class="controls bullet"><span class="by">chatmasta</span><span>|</span><a href="#38728944">root</a><span>|</span><a href="#38730135">parent</a><span>|</span><a href="#38729117">next</a><span>|</span><label class="collapse" for="c-38730953">[-]</label><label class="expand" for="c-38730953">[1 more]</label></div><br/><div class="children"><div class="content">&gt; first stage is building the game<p>Yeah :) Definitely better to make it slow but ship it. Then make it fast later.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="38728923" class="c"><input type="checkbox" id="c-38728923" checked=""/><div class="controls bullet"><span class="by">user3939382</span><span>|</span><a href="#38728944">prev</a><span>|</span><a href="#38731533">next</a><span>|</span><label class="collapse" for="c-38728923">[-]</label><label class="expand" for="c-38728923">[8 more]</label></div><br/><div class="children"><div class="content">This posts advice isn’t good because structuredClone performance is poor. Theres a small custom function I use for this which has much better performance.<p>If you’re so inclined you can google the benchmarks.</div><br/><div id="38728974" class="c"><input type="checkbox" id="c-38728974" checked=""/><div class="controls bullet"><span class="by">binarymax</span><span>|</span><a href="#38728923">parent</a><span>|</span><a href="#38729500">next</a><span>|</span><label class="collapse" for="c-38728974">[-]</label><label class="expand" for="c-38728974">[4 more]</label></div><br/><div class="children"><div class="content">The article states differently, saying it is performant.<p>Instead of saying we should search for benchmarks why not post them here?  Also, what is the small function you use?</div><br/><div id="38729392" class="c"><input type="checkbox" id="c-38729392" checked=""/><div class="controls bullet"><span class="by">hutzlibu</span><span>|</span><a href="#38728923">root</a><span>|</span><a href="#38728974">parent</a><span>|</span><a href="#38729500">next</a><span>|</span><label class="collapse" for="c-38729392">[-]</label><label class="expand" for="c-38729392">[3 more]</label></div><br/><div class="children"><div class="content">Sadly I can confirm, structuredClone is still not performant. At least on my various devices.<p>I just did a test again with 40000 times cloning a simple object and JSON.parse&#x2F;stringify was 6 times faster than structured cloning.<p>Since I heavily use deep cloning, I am still disappointed with the new native, but slower solution. (And was hoping there would be more than old news in the article)<p>Edit: Code for testing was as simple as<p>for ... 40000<p>JSON.parse(JSON.stringify(obj))<p>vs<p>structuredClone(obj)</div><br/><div id="38729568" class="c"><input type="checkbox" id="c-38729568" checked=""/><div class="controls bullet"><span class="by">meepmorp</span><span>|</span><a href="#38728923">root</a><span>|</span><a href="#38729392">parent</a><span>|</span><a href="#38729500">next</a><span>|</span><label class="collapse" for="c-38729568">[-]</label><label class="expand" for="c-38729568">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I just did a test again with 40000 times cloning a simple object and JSON.parse&#x2F;stringify was 6 times faster than structured cloning.<p>Depending on the object you&#x27;re cloning, that might be fine. But some types, like Date or Set, don&#x27;t round trip between JS and JSON so you&#x27;d have mangled objects.</div><br/><div id="38729650" class="c"><input type="checkbox" id="c-38729650" checked=""/><div class="controls bullet"><span class="by">hutzlibu</span><span>|</span><a href="#38728923">root</a><span>|</span><a href="#38729568">parent</a><span>|</span><a href="#38729500">next</a><span>|</span><label class="collapse" for="c-38729650">[-]</label><label class="expand" for="c-38729650">[1 more]</label></div><br/><div class="children"><div class="content">Yes I know, but 6 times slower is pretty bad, so when someone presents the modern way, he should probably include a warning, that modern not necesarily means better. Because those who used the old way before, know the limits and worked around them. So why should I switch? I wasted time trying it out (not now, when structuredClone came out). Because my assumption was, it should be faster than the JSON abuse. But it is not, it just has more features.</div><br/></div></div></div></div></div></div></div></div><div id="38729500" class="c"><input type="checkbox" id="c-38729500" checked=""/><div class="controls bullet"><span class="by">hutzlibu</span><span>|</span><a href="#38728923">parent</a><span>|</span><a href="#38728974">prev</a><span>|</span><a href="#38730144">next</a><span>|</span><label class="collapse" for="c-38729500">[-]</label><label class="expand" for="c-38729500">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Theres a small custom function I use for this which has much better performance.&quot;<p>Can you enlighten us?<p>JSON.parse and stringify, or customly copying what is needed? (the fastest solution to my knowledge)</div><br/></div></div><div id="38730144" class="c"><input type="checkbox" id="c-38730144" checked=""/><div class="controls bullet"><span class="by">user3939382</span><span>|</span><a href="#38728923">parent</a><span>|</span><a href="#38729500">prev</a><span>|</span><a href="#38728959">next</a><span>|</span><label class="collapse" for="c-38730144">[-]</label><label class="expand" for="c-38730144">[1 more]</label></div><br/><div class="children"><div class="content">My own version is proprietary so I can&#x27;t release it but here&#x27;s a reference and something like it:<p><a href="https:&#x2F;&#x2F;www.measurethat.net&#x2F;Benchmarks&#x2F;Show&#x2F;17150&#x2F;0&#x2F;lodash-clonedeep-vs-structuredclone-vs-recursivedeepcop" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.measurethat.net&#x2F;Benchmarks&#x2F;Show&#x2F;17150&#x2F;0&#x2F;lodash-c...</a></div><br/></div></div><div id="38728959" class="c"><input type="checkbox" id="c-38728959" checked=""/><div class="controls bullet"><span class="by">KTibow</span><span>|</span><a href="#38728923">parent</a><span>|</span><a href="#38730144">prev</a><span>|</span><a href="#38731533">next</a><span>|</span><label class="collapse" for="c-38728959">[-]</label><label class="expand" for="c-38728959">[1 more]</label></div><br/><div class="children"><div class="content">What types of objects are you copying?</div><br/></div></div></div></div><div id="38731533" class="c"><input type="checkbox" id="c-38731533" checked=""/><div class="controls bullet"><span class="by">rabbits_2002</span><span>|</span><a href="#38728923">prev</a><span>|</span><label class="collapse" for="c-38731533">[-]</label><label class="expand" for="c-38731533">[2 more]</label></div><br/><div class="children"><div class="content">I agree that its weirdly difficult but if you are trying to deep clone an object, you are probably doing something wring</div><br/><div id="38731556" class="c"><input type="checkbox" id="c-38731556" checked=""/><div class="controls bullet"><span class="by">WA</span><span>|</span><a href="#38731533">parent</a><span>|</span><label class="collapse" for="c-38731556">[-]</label><label class="expand" for="c-38731556">[1 more]</label></div><br/><div class="children"><div class="content">Not at all. It’s common to have nested data, it can be quite simple, but still nested. Think: config objects, simple state objects. I want my functions to be pure. Instead of modifying the nested object, they should return a modified deep copy.</div><br/></div></div></div></div></div></div></div></div></div></body></html>