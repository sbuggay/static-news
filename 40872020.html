<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1720083676209" as="style"/><link rel="stylesheet" href="styles.css?v=1720083676209"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.firezone.dev/blog/sans-io">Sans-IO: The secret to effective Rust for network services</a> <span class="domain">(<a href="https://www.firezone.dev">www.firezone.dev</a>)</span></div><div class="subtext"><span>wh33zle</span> | <span>31 comments</span></div><br/><div><div id="40872407" class="c"><input type="checkbox" id="c-40872407" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#40872955">next</a><span>|</span><label class="collapse" for="c-40872407">[-]</label><label class="expand" for="c-40872407">[6 more]</label></div><br/><div class="children"><div class="content">This is billed as something revolutionary and forward progress but that’s exactly how we used to do async in $lang - including Rust - before language support for async&#x2F;await landed.<p>The biggest productivity boost to my rust embedded firmware development was when I could stop manually implementing state machines and marshalling all local variables into custom state after custom state between each I&#x2F;O operation snd let rust do that for me by using async&#x2F;await syntax!<p>That’s, after all, what async desugars to in rust: an automatic state machine that saves values across I&#x2F;O (await) points for you.</div><br/><div id="40872448" class="c"><input type="checkbox" id="c-40872448" checked=""/><div class="controls bullet"><span class="by">wh33zle</span><span>|</span><a href="#40872407">parent</a><span>|</span><a href="#40872452">next</a><span>|</span><label class="collapse" for="c-40872448">[-]</label><label class="expand" for="c-40872448">[1 more]</label></div><br/><div class="children"><div class="content">I tried to address this at the end of the post: If what you are implementing is mostly _sequential_ IO operations, then this model becomes a bit painful.<p>That isn&#x27;t always the case though. In more packet-oriented usecases (QUIC, WebRTC &amp; IP), doing the actual IO bit is easy: send &amp; receive individual packets &#x2F; datagrams.<p>There isn&#x27;t really much the compiler can generate for you because you don&#x27;t end up with many `.await` points. At the same time, the state management across all these futures becomes spaghetti code because many of these aspects should run concurrently and thus need to be in their own future &#x2F; task.</div><br/></div></div><div id="40872452" class="c"><input type="checkbox" id="c-40872452" checked=""/><div class="controls bullet"><span class="by">k_bx</span><span>|</span><a href="#40872407">parent</a><span>|</span><a href="#40872448">prev</a><span>|</span><a href="#40872955">next</a><span>|</span><label class="collapse" for="c-40872452">[-]</label><label class="expand" for="c-40872452">[4 more]</label></div><br/><div class="children"><div class="content">Yep. The only things about async that bothers me is the need to write &quot;.await&quot; everywhere. I wish there&#x27;d be a way to inverse this, and actually just run &quot;.await&quot; by default, while having a special construct not to.</div><br/><div id="40872574" class="c"><input type="checkbox" id="c-40872574" checked=""/><div class="controls bullet"><span class="by">mdtusz</span><span>|</span><a href="#40872407">root</a><span>|</span><a href="#40872452">parent</a><span>|</span><a href="#40872955">next</a><span>|</span><label class="collapse" for="c-40872574">[-]</label><label class="expand" for="c-40872574">[3 more]</label></div><br/><div class="children"><div class="content">You mean `.await`, I assume?</div><br/><div id="40872927" class="c"><input type="checkbox" id="c-40872927" checked=""/><div class="controls bullet"><span class="by">k_bx</span><span>|</span><a href="#40872407">root</a><span>|</span><a href="#40872574">parent</a><span>|</span><a href="#40873211">next</a><span>|</span><label class="collapse" for="c-40872927">[-]</label><label class="expand" for="c-40872927">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, didn&#x27;t have my coffee yet :)</div><br/></div></div><div id="40873211" class="c"><input type="checkbox" id="c-40873211" checked=""/><div class="controls bullet"><span class="by">sirdvd</span><span>|</span><a href="#40872407">root</a><span>|</span><a href="#40872574">parent</a><span>|</span><a href="#40872927">prev</a><span>|</span><a href="#40872955">next</a><span>|</span><label class="collapse" for="c-40873211">[-]</label><label class="expand" for="c-40873211">[1 more]</label></div><br/><div class="children"><div class="content">&#x2F;s <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;2954&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;2954&#x2F;</a></div><br/></div></div></div></div></div></div></div></div><div id="40872955" class="c"><input type="checkbox" id="c-40872955" checked=""/><div class="controls bullet"><span class="by">ziziman</span><span>|</span><a href="#40872407">prev</a><span>|</span><a href="#40872227">next</a><span>|</span><label class="collapse" for="c-40872955">[-]</label><label class="expand" for="c-40872955">[3 more]</label></div><br/><div class="children"><div class="content">How does this design compare to using channels to send data to a dedicated handlers. When using channels i&#x27;ve found multiple issues:
(1) Web-shaped code that is often hard to follow along 
(2) Requires to manually implement message types that can then be converted to network-sendable messages 
(3) Requires to explicitly give a transmitter to interested&#x2F;allowed entities 
(4) You get a result if your channel message failed to transmit but NOT if your message failed to transmit over network<p>But besides that it&#x27;s pretty convenient. Let&#x27;s say you have a ws_handler channel, you just send your data through that and there is a dedicated handler somewhere that may or may not send that message if it&#x27;s able to.</div><br/><div id="40873339" class="c"><input type="checkbox" id="c-40873339" checked=""/><div class="controls bullet"><span class="by">K0nserv</span><span>|</span><a href="#40872955">parent</a><span>|</span><a href="#40872995">next</a><span>|</span><label class="collapse" for="c-40873339">[-]</label><label class="expand" for="c-40873339">[1 more]</label></div><br/><div class="children"><div class="content">For 4 you can implement that with a channel passed along with the message to send a result back. You can then block the sending side all the way to the callsite if you wish.<p>My feeling is that sans-IO is particularly useful for libraries, although it can be used for applications too. In a library it means you don&#x27;t force decisions about how I&#x2F;O happens on your consumer, making it strictly more useful. This is important for Rust because there&#x27;s already a bunch of ecosystem fragmentation between sync and async IO(not to mention different async runtimes)</div><br/></div></div><div id="40872995" class="c"><input type="checkbox" id="c-40872995" checked=""/><div class="controls bullet"><span class="by">wh33zle</span><span>|</span><a href="#40872955">parent</a><span>|</span><a href="#40873339">prev</a><span>|</span><a href="#40872227">next</a><span>|</span><label class="collapse" for="c-40872995">[-]</label><label class="expand" for="c-40872995">[1 more]</label></div><br/><div class="children"><div class="content">Channels work fine if you are happy for your software to have an actor-like design.<p>But as you say, it comes with problems: Actors &#x2F; channels can be disconnected for example. You also want to make sure they are bounded otherwise you don&#x27;t have backpressure. Plus, they require copying so achieving high-throughput may be tricky.</div><br/></div></div></div></div><div id="40872227" class="c"><input type="checkbox" id="c-40872227" checked=""/><div class="controls bullet"><span class="by">ethegwo</span><span>|</span><a href="#40872955">prev</a><span>|</span><a href="#40872638">next</a><span>|</span><label class="collapse" for="c-40872227">[-]</label><label class="expand" for="c-40872227">[4 more]</label></div><br/><div class="children"><div class="content">Good job! Exposing state could make any async function &#x27;pure&#x27;. All the user needs to do is push the state machine to the next state. I have tried to bind OpenSSL to async Rust before, its async API follows a similar design.</div><br/><div id="40872293" class="c"><input type="checkbox" id="c-40872293" checked=""/><div class="controls bullet"><span class="by">wh33zle</span><span>|</span><a href="#40872227">parent</a><span>|</span><a href="#40872638">next</a><span>|</span><label class="collapse" for="c-40872293">[-]</label><label class="expand" for="c-40872293">[3 more]</label></div><br/><div class="children"><div class="content">I did some quick research and found that there is an &quot;async job&quot; API in OpenSSL. That one appears to do IO though, it even says that creating a job is a very expensive operation and thus jobs should be reused.<p>Is the similarity you are seeing that the work itself that gets scheduled via a job is agnostic over how it is executed?<p>From this example [0] it looks more like that async API is very similar to Rust&#x27;s futures:<p>- Within a job you can access a &quot;wait context&quot;<p>- You can suspend on some condition<p>- You can trigger a wake-up to continue executing<p>[0]: <a href="https:&#x2F;&#x2F;www.openssl.org&#x2F;docs&#x2F;man1.1.1&#x2F;man3&#x2F;ASYNC_is_capable.html" rel="nofollow">https:&#x2F;&#x2F;www.openssl.org&#x2F;docs&#x2F;man1.1.1&#x2F;man3&#x2F;ASYNC_is_capable....</a></div><br/><div id="40872348" class="c"><input type="checkbox" id="c-40872348" checked=""/><div class="controls bullet"><span class="by">ethegwo</span><span>|</span><a href="#40872227">root</a><span>|</span><a href="#40872293">parent</a><span>|</span><a href="#40872638">next</a><span>|</span><label class="collapse" for="c-40872348">[-]</label><label class="expand" for="c-40872348">[2 more]</label></div><br/><div class="children"><div class="content">Yes, you&#x27;re right. It&#x27;s not entirely similar, it&#x27;s not IO-less. But in async Rust (or any other stackless coroutine runtimes), IO should be bound to the scheduler. This allows IO events callback scheduler and wake the task it binds to. Exposing and manually pushing state is a good way to decouple IO from the scheduler.</div><br/><div id="40872370" class="c"><input type="checkbox" id="c-40872370" checked=""/><div class="controls bullet"><span class="by">wh33zle</span><span>|</span><a href="#40872227">root</a><span>|</span><a href="#40872348">parent</a><span>|</span><a href="#40872638">next</a><span>|</span><label class="collapse" for="c-40872370">[-]</label><label class="expand" for="c-40872370">[1 more]</label></div><br/><div class="children"><div class="content">Yes! Decoupling is the goal of this! Using non-blocking IO is still useful in this case because it means we can wait on two conditions at once (i.e. socket IO and time), see [0].<p>It is possible to do the same blocking IO but it feels a little less natural: You have to set the read-timeout on the socket to the time when you need to wake-up the state machine.<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;firezone&#x2F;sans-io-blog-example&#x2F;blob&#x2F;99df7704ceaf1949065a003cedbffdc5bc74b8bb&#x2F;src&#x2F;bin&#x2F;stun_sans_io_time.rs#L31-L40">https:&#x2F;&#x2F;github.com&#x2F;firezone&#x2F;sans-io-blog-example&#x2F;blob&#x2F;99df77...</a></div><br/></div></div></div></div></div></div></div></div><div id="40872638" class="c"><input type="checkbox" id="c-40872638" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#40872227">prev</a><span>|</span><a href="#40872418">next</a><span>|</span><label class="collapse" for="c-40872638">[-]</label><label class="expand" for="c-40872638">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Also, sequential workflows require more code to be written. In Rust, async functions compile down to state machines, with each .await point representing a transition to a different state. This makes it easy for developers to write sequential code together with non-blocking IO. Without async, we need to write our own state machines for expressing the various steps.<p>Has anyone tried to combine async and sans-io?  At least morally, I ought to be able to write an async function that awaits sans-io-aware helpers, and the whole thing should be able to be compiled down to a state machine inside a struct with a nice sans-io interface that is easily callable by non-async code.<p>I’ve never tried this, but the main issues I would forsee would be getting decent ergonomics and dealing with Pin.</div><br/><div id="40872859" class="c"><input type="checkbox" id="c-40872859" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#40872638">parent</a><span>|</span><a href="#40873347">next</a><span>|</span><label class="collapse" for="c-40872859">[-]</label><label class="expand" for="c-40872859">[1 more]</label></div><br/><div class="children"><div class="content">Rust has generators&#x2F;coroutines that can somewhat address the use case you&#x27;re describing, but they&#x27;re an extra-unstable feature at the moment. Unfortunately, in its current incarnation, coroutines have the annoying limitation of only being exposed via the std::ops::Coroutine trait, so the underlying state machine generated by the compiler can&#x27;t be manually allocated, even though the size of the state machine is ostensibly a compile-time constant.<p>It&#x27;s not an issue for a single coroutine whose lifetime is contained within the function that defines it, since the compiler can figure that out and stack-allocate the state machine. But arguably the most useful application of coroutines is as elements in a queue for event loop machinery. But implementing that is made impossible unless you box the coroutines. Vec&lt;Box&lt;dyn Coroutine&gt;&gt; is not a cache friendly data structure, and you&#x27;ll feel the pain if you&#x27;re doing extremely high concurrency I&#x2F;O and need a million elements in your Vec.</div><br/></div></div><div id="40873347" class="c"><input type="checkbox" id="c-40873347" checked=""/><div class="controls bullet"><span class="by">kmac_</span><span>|</span><a href="#40872638">parent</a><span>|</span><a href="#40872859">prev</a><span>|</span><a href="#40873367">next</a><span>|</span><label class="collapse" for="c-40873347">[-]</label><label class="expand" for="c-40873347">[1 more]</label></div><br/><div class="children"><div class="content">This is another take on defunctionalization. You create a model of execution but do not execute it. I.e., return or queue a value of type Send, and do not execute &quot;send&quot;. The execution is separate and actually deals with &quot;real-world&quot; side effects. The execution can be done by sync&#x2F;async&#x2F;transformed to monads, it doesn&#x27;t matter.</div><br/></div></div><div id="40873367" class="c"><input type="checkbox" id="c-40873367" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#40872638">parent</a><span>|</span><a href="#40873347">prev</a><span>|</span><a href="#40872691">next</a><span>|</span><label class="collapse" for="c-40873367">[-]</label><label class="expand" for="c-40873367">[1 more]</label></div><br/><div class="children"><div class="content">A long time ago I had &quot;fun&quot; implementing all sorts of network protocols with such an event based library on C: <a href="https:&#x2F;&#x2F;github.com&#x2F;cesanta&#x2F;mongoose">https:&#x2F;&#x2F;github.com&#x2F;cesanta&#x2F;mongoose</a></div><br/></div></div><div id="40872691" class="c"><input type="checkbox" id="c-40872691" checked=""/><div class="controls bullet"><span class="by">wh33zle</span><span>|</span><a href="#40872638">parent</a><span>|</span><a href="#40873367">prev</a><span>|</span><a href="#40872897">next</a><span>|</span><label class="collapse" for="c-40872691">[-]</label><label class="expand" for="c-40872691">[1 more]</label></div><br/><div class="children"><div class="content">They actually play together fairly well higher up the stack. Non-blocking IO (i.e async) makes it easy to concurrently wait for socket IO and time. You can do it with blocking IO too by setting a read-timeout on the socket but using async primitives makes it a bit easier.<p>But I&#x27;ve also been mulling over the idea how they could be combined! One thing I&#x27;ve arrived at is the issue that async functions compile into opaque types. That makes it hard &#x2F; impossible to use the compiler&#x27;s facility of code-generating the state machine because you can&#x27;t interact with it once it has been created. This also breaks the borrow-checker in some way.<p>For example, if I have an async operation with multiple steps (i.e. `await` points) but only one section of those needs a mutable reference to some shared data structure. As soon as I express this using an `async` function, the mutable reference is captured in the generated `Future` type which spans across all steps. As a result, Rust doesn&#x27;t allow me to run more than one of those concurrently.<p>Normally, the advice for these situations is &quot;only capture the mutable reference for as short as possible&quot; but in the case of async, I can&#x27;t do that. And splitting the async function into multiple also gets messy and kind of defeats the point of wanting to express everything in a single function again.</div><br/></div></div><div id="40872897" class="c"><input type="checkbox" id="c-40872897" checked=""/><div class="controls bullet"><span class="by">wh33zle</span><span>|</span><a href="#40872638">parent</a><span>|</span><a href="#40872691">prev</a><span>|</span><a href="#40872760">next</a><span>|</span><label class="collapse" for="c-40872897">[-]</label><label class="expand" for="c-40872897">[1 more]</label></div><br/><div class="children"><div class="content">If Rust ever gets a native generator syntax, this might be become achievable because one would be able to say: `yield transmit` to &quot;write&quot; data whilst staying within the context of your async operation. In other words, every `socket.write` would turn into a `yield transmit`.<p>To read data, the generator would suspend (.await) and wait to be resumed with incoming data. I am not sure if there is nightly syntax for this but it would have to look something like:<p><pre><code>  &#x2F;&#x2F; Made up `gen` syntax: gen(yield_type, resume_type)
  gen(Transmit, &amp;[u8]) fn stun_binding(server: SocketAddr) -&gt; SocketAddr {
   let req = make_stun_request();

   yield Transmit {
      server,
      payload: req
   };

   let res = .await; &#x2F;&#x2F; Made up &quot;suspend and resume with argument&quot;-syntax.
   
   let addr = parse_stun_response(res);

   addr
 }</code></pre></div><br/></div></div><div id="40872760" class="c"><input type="checkbox" id="c-40872760" checked=""/><div class="controls bullet"><span class="by">algesten</span><span>|</span><a href="#40872638">parent</a><span>|</span><a href="#40872897">prev</a><span>|</span><a href="#40872418">next</a><span>|</span><label class="collapse" for="c-40872760">[-]</label><label class="expand" for="c-40872760">[1 more]</label></div><br/><div class="children"><div class="content">One thing I toyed with, but didn&#x27;t get very far, was to encode the HTTP&#x2F;1.1 protocol as a Sans-IO state machine with .await points for the IO, but rather than the IO registering Wakers with an async runtime, it relinquished control back to the user to perform the IO manually. One can think of it as .await releasing &quot;up&quot; instead of &quot;down&quot;.<p>In the context of HTTP&#x2F;1.1 the async code became a kind of &quot;blueprint&quot; for how the user wants the call to behave. At the time I was dead set on making it work for no_std (non allocator) environment, and I gave up because I couldn&#x27;t find a way around how to need dynamic dispatch via Box&lt;dyn X&gt; (needing an allocator).</div><br/></div></div></div></div><div id="40872418" class="c"><input type="checkbox" id="c-40872418" checked=""/><div class="controls bullet"><span class="by">r3trohack3r</span><span>|</span><a href="#40872638">prev</a><span>|</span><a href="#40872595">next</a><span>|</span><label class="collapse" for="c-40872418">[-]</label><label class="expand" for="c-40872418">[2 more]</label></div><br/><div class="children"><div class="content">Oh hey thomaseizinger!<p>I got half way through this article feeling like this pattern was extremely familiar after spending time down inside rust-libp2p. Seems like that wasn&#x27;t a coincidence!<p>Firezone looks amazing, connect all the things!</div><br/><div id="40872470" class="c"><input type="checkbox" id="c-40872470" checked=""/><div class="controls bullet"><span class="by">wh33zle</span><span>|</span><a href="#40872418">parent</a><span>|</span><a href="#40872595">next</a><span>|</span><label class="collapse" for="c-40872470">[-]</label><label class="expand" for="c-40872470">[1 more]</label></div><br/><div class="children"><div class="content">Haha thank you!<p>Yes there are indeed similarities to rust-libp2p! Over there, things are more interleaved though because the actual streams and connections are still within `Future`-like constructs and not strictly split like in the sans-IO case here.</div><br/></div></div></div></div><div id="40872502" class="c"><input type="checkbox" id="c-40872502" checked=""/><div class="controls bullet"><span class="by">tmd83</span><span>|</span><a href="#40872595">prev</a><span>|</span><a href="#40873180">next</a><span>|</span><label class="collapse" for="c-40872502">[-]</label><label class="expand" for="c-40872502">[2 more]</label></div><br/><div class="children"><div class="content">Does the actual traffic goes through the gateway or the gateway is only used for setting up the connection?</div><br/><div id="40872551" class="c"><input type="checkbox" id="c-40872551" checked=""/><div class="controls bullet"><span class="by">wh33zle</span><span>|</span><a href="#40872502">parent</a><span>|</span><a href="#40873180">next</a><span>|</span><label class="collapse" for="c-40872551">[-]</label><label class="expand" for="c-40872551">[1 more]</label></div><br/><div class="children"><div class="content">Yes, traffic is routed to the gateway through a WireGuard tunnel. Broadly speaking, what happens is:<p>- Client and gateway perform ICE to agree on a socket pair (this is where hole-punching happens or if that fails, a relay is used)<p>- The socket pair determined by ICE is used to set up a WireGuard tunnel (i.e. a noise handshake using ephemeral keys).<p>- IP traffic is read from the TUN device and sent via the WireGuard tunnel to the gateway.<p>- Gateway decrypts it and emits it as a packet from its TUN device, thereby forwarding it to the actual destination.<p>It is worth noting that a WireGuard tunnel in this case is &quot;just&quot; the Noise Protocol [0] layered on top of UDP. This ensures the traffic is end-to-end encrypted.<p>[0]: <a href="https:&#x2F;&#x2F;noiseprotocol.org" rel="nofollow">https:&#x2F;&#x2F;noiseprotocol.org</a></div><br/></div></div></div></div><div id="40873180" class="c"><input type="checkbox" id="c-40873180" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#40872502">prev</a><span>|</span><a href="#40873194">next</a><span>|</span><label class="collapse" for="c-40873180">[-]</label><label class="expand" for="c-40873180">[1 more]</label></div><br/><div class="children"><div class="content">This is just normal asynchronous I&#x2F;O with callbacks instead of coroutines.</div><br/></div></div><div id="40873194" class="c"><input type="checkbox" id="c-40873194" checked=""/><div class="controls bullet"><span class="by">Uptrenda</span><span>|</span><a href="#40873180">prev</a><span>|</span><a href="#40872260">next</a><span>|</span><label class="collapse" for="c-40873194">[-]</label><label class="expand" for="c-40873194">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know what the take away is supposed to be here. Everything spoken about here is already basic network programming. It seems to focus on higher level plumbing and geeks out on state management even though this is just a matter of preference and has nothing to do with networking.<p>The most interesting thing I learned from the article is that cloudflare runs a public stun server. But even that isn&#x27;t helpful because the &#x27;good&#x27; and &#x27;useful&#x27; version of the STUN protocol is the first version of the protocol which supports &#x27;change requests&#x27; -- a feature that allows for NAT enumeration. Later versions of the STUN protocol removed that feature thanks to the &#x27;helpful suggestions&#x27; of Cisco engineers who contributed to the spec.</div><br/></div></div><div id="40872260" class="c"><input type="checkbox" id="c-40872260" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#40873194">prev</a><span>|</span><label class="collapse" for="c-40872260">[-]</label><label class="expand" for="c-40872260">[3 more]</label></div><br/><div class="children"><div class="content">&quot;... be it from your Android phone, MacOS computer or Linux server. &quot;<p>Why would you want this in a client? It&#x27;s not like a client needs to manage tens of thousands of connections. Unless it&#x27;s doing a DDOS job.</div><br/><div id="40872319" class="c"><input type="checkbox" id="c-40872319" checked=""/><div class="controls bullet"><span class="by">wh33zle</span><span>|</span><a href="#40872260">parent</a><span>|</span><a href="#40872367">next</a><span>|</span><label class="collapse" for="c-40872319">[-]</label><label class="expand" for="c-40872319">[1 more]</label></div><br/><div class="children"><div class="content">In Firezone&#x27;s case, things are built on top of UDP so technically there aren&#x27;t any (kernel-managed) connections and only a single file descriptor is allocated for the UDP socket.<p>The main benefit is being able to use `&amp;mut` everywhere: At the time when we read an IP packet from the TUN device, we don&#x27;t yet know, which gateway (exit node), it needs to go to. We first have to look at the user&#x27;s policies and then encrypt and send it via a WireGuard tunnel.<p>Similarly, we need to concurrently receive on all of these tunnels. The tunnels are just a user-space concept though. All we do is receive on the UDP socket and index into the corresponding data structure based on the sending socket.<p>If all of these &quot;connections&quot; would use their own task and UDP socket, we&#x27;d would have to use channels (and thus copying) to dispatch them. Additionally, the policy state would have to be in an `Arc&lt;Mutex&gt;` because it is shared among all connections.</div><br/></div></div></div></div></div></div></div></div></div></body></html>