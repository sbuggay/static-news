<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1724058071688" as="style"/><link rel="stylesheet" href="styles.css?v=1724058071688"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://opsmonkey.blogspot.com/2007/01/linux-memory-overcommit.html">Linux Memory Overcommit (2007)</a> <span class="domain">(<a href="http://opsmonkey.blogspot.com">opsmonkey.blogspot.com</a>)</span></div><div class="subtext"><span>signa11</span> | <span>33 comments</span></div><br/><div><div id="41289148" class="c"><input type="checkbox" id="c-41289148" checked=""/><div class="controls bullet"><span class="by">CAP_NET_ADMIN</span><span>|</span><a href="#41285918">next</a><span>|</span><label class="collapse" for="c-41289148">[-]</label><label class="expand" for="c-41289148">[1 more]</label></div><br/><div class="children"><div class="content">The truth is that if you&#x27;re having issues with default overcommit configuration (namely overcommit_memory == 0 and overcommit_ratio == 50) your application probably sucks and you have to actually diagnose it and fix it.<p>&quot;We run a pretty java-heavy environment, with multiple large JVMs configured per host. The problem is that the heap sizes have been getting larger, and we were running in an overcommitted situation and did not realize it. The JVMs would all start up and malloc() their large heaps, and then at some later time once enough of the heaps were actually used, the OOM killer would kick in and more or less randomly off one of our JVMs.&quot;<p>I know that 2007 may have been different times, but I&#x27;d argue that max heaps for all your JVMs running on a system probably shouldn&#x27;t exceed around 88% of the total system memory. (percentage goes up as the total system memory goes up from 128GB -&gt; 256GB -&gt; 512GB)</div><br/></div></div><div id="41285918" class="c"><input type="checkbox" id="c-41285918" checked=""/><div class="controls bullet"><span class="by">__turbobrew__</span><span>|</span><a href="#41289148">prev</a><span>|</span><a href="#41286128">next</a><span>|</span><label class="collapse" for="c-41285918">[-]</label><label class="expand" for="c-41285918">[2 more]</label></div><br/><div class="children"><div class="content">If you want to optimize for throughout one option is to overcommit resources (CPU&#x2F;MEM&#x2F;IO&#x2F;NET) but utilize backpressure mechanisms to reduce load during times of saturation.<p>Kubernetes does this through node pressure eviction but it is pretty easy to hook into the pressure stall information  and have the application handle this as well (for example, start returning 429 HTTP responses when PSI goes over a certain level).<p>At the end of the day the optimal overcommit is workload dependent — good metrics and an iterative approach is needed.</div><br/><div id="41288417" class="c"><input type="checkbox" id="c-41288417" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41285918">parent</a><span>|</span><a href="#41286128">next</a><span>|</span><label class="collapse" for="c-41288417">[-]</label><label class="expand" for="c-41288417">[1 more]</label></div><br/><div class="children"><div class="content">You probably also want to do somewhat intelligent load shedding, where you basically make sure you drop the most expendable items first.<p>That&#x27;s a basic fact of life for CPU cycles even for consumers on their machines, we call that just CPU priorities or so.  But it&#x27;s also useful for the other resources; but there it&#x27;s a bit more disruptive, because we generally need to disrupt a program to eg claim back the disk space it uses.</div><br/></div></div></div></div><div id="41286128" class="c"><input type="checkbox" id="c-41286128" checked=""/><div class="controls bullet"><span class="by">nabla9</span><span>|</span><a href="#41285918">prev</a><span>|</span><a href="#41285817">next</a><span>|</span><label class="collapse" for="c-41286128">[-]</label><label class="expand" for="c-41286128">[15 more]</label></div><br/><div class="children"><div class="content">As then as now, you can manage it.<p>vm.overcommit_memory == 0  heuristic overcommit<p>vm.overcommit_memory == 1  (full overcommit) allows allocating more memory than there is ram + swap.<p>vm.overcommit_memory == 2  never overcommit. There must be enough physical ram or virtual swap to allocate the memory.</div><br/><div id="41286210" class="c"><input type="checkbox" id="c-41286210" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41286128">parent</a><span>|</span><a href="#41286368">next</a><span>|</span><label class="collapse" for="c-41286210">[-]</label><label class="expand" for="c-41286210">[3 more]</label></div><br/><div class="children"><div class="content">Can this be set for a specific process (or process group&#x2F;tree), or only globally?</div><br/><div id="41286310" class="c"><input type="checkbox" id="c-41286310" checked=""/><div class="controls bullet"><span class="by">nabla9</span><span>|</span><a href="#41286128">root</a><span>|</span><a href="#41286210">parent</a><span>|</span><a href="#41286368">next</a><span>|</span><label class="collapse" for="c-41286310">[-]</label><label class="expand" for="c-41286310">[2 more]</label></div><br/><div class="children"><div class="content">Globally<p>For a process you can use setrlimit()   (ulimit command)</div><br/><div id="41289201" class="c"><input type="checkbox" id="c-41289201" checked=""/><div class="controls bullet"><span class="by">silon42</span><span>|</span><a href="#41286128">root</a><span>|</span><a href="#41286310">parent</a><span>|</span><a href="#41286368">next</a><span>|</span><label class="collapse" for="c-41289201">[-]</label><label class="expand" for="c-41289201">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d want the OOM killer to kill processes with more over-commit first.</div><br/></div></div></div></div></div></div><div id="41286368" class="c"><input type="checkbox" id="c-41286368" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#41286128">parent</a><span>|</span><a href="#41286210">prev</a><span>|</span><a href="#41285817">next</a><span>|</span><label class="collapse" for="c-41286368">[-]</label><label class="expand" for="c-41286368">[11 more]</label></div><br/><div class="children"><div class="content">I like to run my development VM with overcommit_memory == 2, but I recently learned that the way it actually fails is pretty confusing. It&#x27;s not an orderly &#x27;abort: malloc failed&#x27; or process termination like I would&#x27;ve expected. Instead, you get weird intermittent failures that don&#x27;t look like OOMs and your system appears to have plenty of free memory at the time.<p>Still good for flushing out scenarios where i.e. your build process needs 64GB of memory for approximately 500ms and then drops back down to reasonable levels, due to parallelism</div><br/><div id="41288599" class="c"><input type="checkbox" id="c-41288599" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#41286128">root</a><span>|</span><a href="#41286368">parent</a><span>|</span><a href="#41287028">next</a><span>|</span><label class="collapse" for="c-41288599">[-]</label><label class="expand" for="c-41288599">[2 more]</label></div><br/><div class="children"><div class="content">Do you run with swap in that case? I would suspect two possible reasons: firstly most software on linux is not run in that configuration and is thus unprepared for malloc failure: I would not be surprised if the return is not checked for many malloc() calls. Secondly, running without swap will cause bad performance (like, whole system freezing for a long time) failure modes as linux will evict cached code pages from RAM instead of rarely accessed data under memory pressure.</div><br/><div id="41288771" class="c"><input type="checkbox" id="c-41288771" checked=""/><div class="controls bullet"><span class="by">taskforcegemini</span><span>|</span><a href="#41286128">root</a><span>|</span><a href="#41288599">parent</a><span>|</span><a href="#41287028">next</a><span>|</span><label class="collapse" for="c-41288771">[-]</label><label class="expand" for="c-41288771">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Secondly, running without swap will cause bad performance (like, whole system freezing for a long time)<p>in my experience it is exactly the opposite. unless you swap onto ssds, swapping will grind the whole system to a halt, while without swap the oom-reaper will kill the culprit and you can immediately work on the system to check&#x2F;fix things. result also depends on your applications of course.</div><br/></div></div></div></div><div id="41287028" class="c"><input type="checkbox" id="c-41287028" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#41286128">root</a><span>|</span><a href="#41286368">parent</a><span>|</span><a href="#41288599">prev</a><span>|</span><a href="#41285817">next</a><span>|</span><label class="collapse" for="c-41287028">[-]</label><label class="expand" for="c-41287028">[8 more]</label></div><br/><div class="children"><div class="content">That sounds wild. How else can it possibly fail than by failing malloc? Where do the intermittent failures occur, if not in the return value? Could it be some part of your code isn&#x27;t checking the return value for NULL?</div><br/><div id="41287428" class="c"><input type="checkbox" id="c-41287428" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#41286128">root</a><span>|</span><a href="#41287028">parent</a><span>|</span><a href="#41287376">next</a><span>|</span><label class="collapse" for="c-41287428">[-]</label><label class="expand" for="c-41287428">[3 more]</label></div><br/><div class="children"><div class="content">&gt; That sounds wild. How else can it possibly fail than by failing malloc?<p>By killing your process and&#x2F;or by failing fork()s.<p>In general, malloc() in Linux will never fail for small allocations.</div><br/><div id="41289207" class="c"><input type="checkbox" id="c-41289207" checked=""/><div class="controls bullet"><span class="by">ploxiln</span><span>|</span><a href="#41286128">root</a><span>|</span><a href="#41287428">parent</a><span>|</span><a href="#41288602">next</a><span>|</span><label class="collapse" for="c-41289207">[-]</label><label class="expand" for="c-41289207">[1 more]</label></div><br/><div class="children"><div class="content">&gt; malloc() in Linux will never fail for small allocations<p>That&#x27;s in kernel-space, not user-space processes. If you have overcommit disabled, it will be user-space processes making syscalls mmap() or sbrk() to get more heap memory (in which small allocations reside), that fails with an error return code, I assume. But I guess it could also fail to auto-grow the main thread stack, and presumably get a segfault. If the kernel needs to allocate more memory for a fork(), that syscall can fail. But if the kernel needs to allocate memory for some other internal purpose, probably back to the OOM killer, I guess ... hopefully this would be very rare?</div><br/></div></div><div id="41288602" class="c"><input type="checkbox" id="c-41288602" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#41286128">root</a><span>|</span><a href="#41287428">parent</a><span>|</span><a href="#41289207">prev</a><span>|</span><a href="#41287376">next</a><span>|</span><label class="collapse" for="c-41288602">[-]</label><label class="expand" for="c-41288602">[1 more]</label></div><br/><div class="children"><div class="content">With overcommit disabled, fork may fail, but your other claims are backwards: malloc can fail, and processes aren&#x27;t killed.</div><br/></div></div></div></div><div id="41287376" class="c"><input type="checkbox" id="c-41287376" checked=""/><div class="controls bullet"><span class="by">usefulcat</span><span>|</span><a href="#41286128">root</a><span>|</span><a href="#41287028">parent</a><span>|</span><a href="#41287428">prev</a><span>|</span><a href="#41285817">next</a><span>|</span><label class="collapse" for="c-41287376">[-]</label><label class="expand" for="c-41287376">[4 more]</label></div><br/><div class="children"><div class="content">IIUC, the way overcommit works on Linux is the memory returned by malloc() is not actually mapped to physical memory until it is accessed. So malloc may succeed and then at some point later you may get a segfault or similar when something actually tries to access that memory.</div><br/><div id="41287438" class="c"><input type="checkbox" id="c-41287438" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#41286128">root</a><span>|</span><a href="#41287376">parent</a><span>|</span><a href="#41287433">next</a><span>|</span><label class="collapse" for="c-41287438">[-]</label><label class="expand" for="c-41287438">[2 more]</label></div><br/><div class="children"><div class="content">&gt; IIUC, the way overcommit works on Linux<p>Doesn&#x27;t vm.overcommit_memory == 2 disable overcommit? That&#x27;s the situation we&#x27;re talking about...</div><br/><div id="41287523" class="c"><input type="checkbox" id="c-41287523" checked=""/><div class="controls bullet"><span class="by">usefulcat</span><span>|</span><a href="#41286128">root</a><span>|</span><a href="#41287438">parent</a><span>|</span><a href="#41287433">next</a><span>|</span><label class="collapse" for="c-41287523">[-]</label><label class="expand" for="c-41287523">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re correct; for some reason I didn&#x27;t interpret the question in that context. I was thinking about when vm.overcommit_memmory is 0 or 1.</div><br/></div></div></div></div><div id="41287433" class="c"><input type="checkbox" id="c-41287433" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#41286128">root</a><span>|</span><a href="#41287376">parent</a><span>|</span><a href="#41287438">prev</a><span>|</span><a href="#41285817">next</a><span>|</span><label class="collapse" for="c-41287433">[-]</label><label class="expand" for="c-41287433">[1 more]</label></div><br/><div class="children"><div class="content">malloc() will not return unmapped memory for small allocations. Your process might get killed if malloc() fails to get more backing pages.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41285817" class="c"><input type="checkbox" id="c-41285817" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#41286128">prev</a><span>|</span><a href="#41286020">next</a><span>|</span><label class="collapse" for="c-41285817">[-]</label><label class="expand" for="c-41285817">[11 more]</label></div><br/><div class="children"><div class="content">Reminder: if overcommit as a concept seems distasteful, the real ire should be directed at the Unix fork syscall, an API that will always fail on a process using over 50% of the available memory without overcommit. Ideally apps would use vfork or posix_spawn instead, but that isn&#x27;t the world we live in. Overcommit is a sensible way to help apps that use a lot of memory &quot;just work&quot;. You can always turn it off if you don&#x27;t need apps using a lot of memory to be able to fork.</div><br/><div id="41288194" class="c"><input type="checkbox" id="c-41288194" checked=""/><div class="controls bullet"><span class="by">jabl</span><span>|</span><a href="#41285817">parent</a><span>|</span><a href="#41288616">next</a><span>|</span><label class="collapse" for="c-41288194">[-]</label><label class="expand" for="c-41288194">[1 more]</label></div><br/><div class="children"><div class="content">This article explains the problems with fork pretty well: <a href="https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;uploads&#x2F;prod&#x2F;2019&#x2F;04&#x2F;fork-hotos19.pdf" rel="nofollow">https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;uploads&#x2F;prod&#x2F;2019&#x2F;0...</a></div><br/></div></div><div id="41288616" class="c"><input type="checkbox" id="c-41288616" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#41285817">parent</a><span>|</span><a href="#41288194">prev</a><span>|</span><a href="#41285944">next</a><span>|</span><label class="collapse" for="c-41288616">[-]</label><label class="expand" for="c-41288616">[1 more]</label></div><br/><div class="children"><div class="content">Also I would suggest using a Windows machine which seems to run out of memory despite hundreds of gigabytes of swap and yet still ~70% of RAM full. I don&#x27;t know what&#x27;s causing the bug but it affects multiple systems I use and it&#x27;s a right nuisance with a nearly full disk to have &gt;10% of it sitting there idle just in case whatever&#x27;s over-allocating memory decides to actually use it (I mean, I guess I could also direct my ire at whatever broken accounting fails to actually tell me what&#x27;s causing it as well, but I can be mad at two things at once).</div><br/></div></div><div id="41285944" class="c"><input type="checkbox" id="c-41285944" checked=""/><div class="controls bullet"><span class="by">senderista</span><span>|</span><a href="#41285817">parent</a><span>|</span><a href="#41288616">prev</a><span>|</span><a href="#41286640">next</a><span>|</span><label class="collapse" for="c-41285944">[-]</label><label class="expand" for="c-41285944">[1 more]</label></div><br/><div class="children"><div class="content">There are also legitimate uses of overcommit for reserving huge areas of virtual memory and relying on demand paging to allocate physical memory, although strictly speaking enabling overcommit isn’t necessary if you separate the “reserve” (mmap(PROT_NONE)) and “commit” (mmap(MAP_FIXED, PROT_READ | PROT_WRITE)) stages (which is what Windows forces you to do).</div><br/></div></div><div id="41286640" class="c"><input type="checkbox" id="c-41286640" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#41285817">parent</a><span>|</span><a href="#41285944">prev</a><span>|</span><a href="#41285959">next</a><span>|</span><label class="collapse" for="c-41286640">[-]</label><label class="expand" for="c-41286640">[1 more]</label></div><br/><div class="children"><div class="content">That explains why Windows, which has a process model based on spawning and not forking, never had overcommit.</div><br/></div></div><div id="41285959" class="c"><input type="checkbox" id="c-41285959" checked=""/><div class="controls bullet"><span class="by">dap</span><span>|</span><a href="#41285817">parent</a><span>|</span><a href="#41286640">prev</a><span>|</span><a href="#41286026">next</a><span>|</span><label class="collapse" for="c-41285959">[-]</label><label class="expand" for="c-41285959">[3 more]</label></div><br/><div class="children"><div class="content">I’m not sure how this works on Linux exactly but in principle you don’t need to support overcommit to avoid that problem.  On illumos for example anonymous memory allocations come from swap, which is a virtual resource that includes both disk and memory.  You do still have this problem if something is using more than half of swap, but (1) that’s much larger, and (2) you can augment it with more disk space, which won’t actually be used unless stuff actually uses all the physical memory.  This has its own tradeoffs but it’s useful to keep in mind that there are other ways to do things.</div><br/><div id="41286233" class="c"><input type="checkbox" id="c-41286233" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#41285817">root</a><span>|</span><a href="#41285959">parent</a><span>|</span><a href="#41286026">next</a><span>|</span><label class="collapse" for="c-41286233">[-]</label><label class="expand" for="c-41286233">[2 more]</label></div><br/><div class="children"><div class="content">If available memory means physical + swap then you&#x27;re saying the same thing as pcwalton.</div><br/><div id="41288115" class="c"><input type="checkbox" id="c-41288115" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#41285817">root</a><span>|</span><a href="#41286233">parent</a><span>|</span><a href="#41286026">next</a><span>|</span><label class="collapse" for="c-41288115">[-]</label><label class="expand" for="c-41288115">[1 more]</label></div><br/><div class="children"><div class="content">Right, available memory includes swap. (That&#x27;s why I didn&#x27;t say &quot;available RAM&quot;.)</div><br/></div></div></div></div></div></div><div id="41286026" class="c"><input type="checkbox" id="c-41286026" checked=""/><div class="controls bullet"><span class="by">thanatos519</span><span>|</span><a href="#41285817">parent</a><span>|</span><a href="#41285959">prev</a><span>|</span><a href="#41286020">next</a><span>|</span><label class="collapse" for="c-41286026">[-]</label><label class="expand" for="c-41286026">[3 more]</label></div><br/><div class="children"><div class="content">I thought fork was copy on write nowadays.</div><br/><div id="41286227" class="c"><input type="checkbox" id="c-41286227" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#41285817">root</a><span>|</span><a href="#41286026">parent</a><span>|</span><a href="#41286223">next</a><span>|</span><label class="collapse" for="c-41286227">[-]</label><label class="expand" for="c-41286227">[1 more]</label></div><br/><div class="children"><div class="content">Fork is copy-on-write. The problem is that there&#x27;s no way for fork() to know how much memory the child process needs. It might call exec() immediately, using very little memory. It might keep running, mostly sharing pages with the parent. It might touch every memory page, requiring a lot of memory.</div><br/></div></div><div id="41286223" class="c"><input type="checkbox" id="c-41286223" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41285817">root</a><span>|</span><a href="#41286026">parent</a><span>|</span><a href="#41286227">prev</a><span>|</span><a href="#41286020">next</a><span>|</span><label class="collapse" for="c-41286223">[-]</label><label class="expand" for="c-41286223">[1 more]</label></div><br/><div class="children"><div class="content">It is, but “write” doesn’t have an error code it can return on out-of-memory.<p>The whole crux of overcommit is that the affected process doesn’t get a chance to gracefully fall back or shutdown on OOM conditions at defined places in the code (like at invocations of <i>malloc</i>).</div><br/></div></div></div></div></div></div><div id="41286020" class="c"><input type="checkbox" id="c-41286020" checked=""/><div class="controls bullet"><span class="by">johnea</span><span>|</span><a href="#41285817">prev</a><span>|</span><label class="collapse" for="c-41286020">[-]</label><label class="expand" for="c-41286020">[3 more]</label></div><br/><div class="children"><div class="content">Is any of this still applicable in 2024?<p>One has to doubt...</div><br/><div id="41286939" class="c"><input type="checkbox" id="c-41286939" checked=""/><div class="controls bullet"><span class="by">graymatters</span><span>|</span><a href="#41286020">parent</a><span>|</span><label class="collapse" for="c-41286939">[-]</label><label class="expand" for="c-41286939">[2 more]</label></div><br/><div class="children"><div class="content">Doubt - based on what?</div><br/><div id="41287392" class="c"><input type="checkbox" id="c-41287392" checked=""/><div class="controls bullet"><span class="by">worthless-trash</span><span>|</span><a href="#41286020">root</a><span>|</span><a href="#41286939">parent</a><span>|</span><label class="collapse" for="c-41287392">[-]</label><label class="expand" for="c-41287392">[1 more]</label></div><br/><div class="children"><div class="content">Knowledge, GP probably thinks that the kernel world moves like the userspace (probably js) world.<p>Which clearly isnt true.  If OS development worked like userspace&#x2F;web dev we&#x27;d all be in much more pain.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>