<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1712480451597" as="style"/><link rel="stylesheet" href="styles.css?v=1712480451597"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blacksmith.sh/blog/cache-is-king-a-guide-for-docker-layer-caching-in-github-actions">Cache is King: A guide for Docker layer caching in GitHub Actions</a> <span class="domain">(<a href="https://blacksmith.sh">blacksmith.sh</a>)</span></div><div class="subtext"><span>adityamaru</span> | <span>54 comments</span></div><br/><div><div id="39958143" class="c"><input type="checkbox" id="c-39958143" checked=""/><div class="controls bullet"><span class="by">solatic</span><span>|</span><a href="#39957954">next</a><span>|</span><label class="collapse" for="c-39958143">[-]</label><label class="expand" for="c-39958143">[8 more]</label></div><br/><div class="children"><div class="content">As someone who spent <i>way</i> too much time chasing this rabbit, the real answer is Just Don&#x27;t. GitHub Actions is a CI system that makes it easy to get started with simple CI needs but runs into hard problems as soon as you have more advanced needs. Docker caching is one of those advanced needs. If you have non-trivial Docker builds then you simply need on-disk local caching, period.<p>Either use Depot or switch to self-hosted runners with large disks.</div><br/><div id="39958496" class="c"><input type="checkbox" id="c-39958496" checked=""/><div class="controls bullet"><span class="by">kylegalbraith</span><span>|</span><a href="#39958143">parent</a><span>|</span><a href="#39959126">next</a><span>|</span><label class="collapse" for="c-39958496">[-]</label><label class="expand" for="c-39958496">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the shout-out regarding Depot, really appreciate it. We came to the same conclusion regarding Docker layer cache and thus why we created Depot in the first place. The limitations and performance surrounding GitHub Actions cache leaves a lot to be desired.</div><br/></div></div><div id="39959126" class="c"><input type="checkbox" id="c-39959126" checked=""/><div class="controls bullet"><span class="by">mhitza</span><span>|</span><a href="#39958143">parent</a><span>|</span><a href="#39958496">prev</a><span>|</span><a href="#39958150">next</a><span>|</span><label class="collapse" for="c-39959126">[-]</label><label class="expand" for="c-39959126">[1 more]</label></div><br/><div class="children"><div class="content">On one project that was a bit more involved, I pulled the latest image I&#x27;ve built from the registry before starting the build. That worked well enough for caching in my case.</div><br/></div></div><div id="39958150" class="c"><input type="checkbox" id="c-39958150" checked=""/><div class="controls bullet"><span class="by">adityamaru</span><span>|</span><a href="#39958143">parent</a><span>|</span><a href="#39959126">prev</a><span>|</span><a href="#39958155">next</a><span>|</span><label class="collapse" for="c-39958150">[-]</label><label class="expand" for="c-39958150">[1 more]</label></div><br/><div class="children"><div class="content">totally agree, github actions has done an excellent job at this lowest layer of the build pipeline today but is woefully inadequate the minute your org hits north of 50 engineers</div><br/></div></div><div id="39958155" class="c"><input type="checkbox" id="c-39958155" checked=""/><div class="controls bullet"><span class="by">aayushshah15</span><span>|</span><a href="#39958143">parent</a><span>|</span><a href="#39958150">prev</a><span>|</span><a href="#39958412">next</a><span>|</span><label class="collapse" for="c-39958155">[-]</label><label class="expand" for="c-39958155">[2 more]</label></div><br/><div class="children"><div class="content">Did you consider using a local (in the same VPC) docker registry mirror perhaps? <a href="https:&#x2F;&#x2F;docs.docker.com&#x2F;docker-hub&#x2F;mirror&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.docker.com&#x2F;docker-hub&#x2F;mirror&#x2F;</a></div><br/><div id="39958407" class="c"><input type="checkbox" id="c-39958407" checked=""/><div class="controls bullet"><span class="by">solatic</span><span>|</span><a href="#39958143">root</a><span>|</span><a href="#39958155">parent</a><span>|</span><a href="#39958412">next</a><span>|</span><label class="collapse" for="c-39958407">[-]</label><label class="expand" for="c-39958407">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not the pulls that are the problem, it&#x27;s caching intermediate layers from the build that is the problem. As soon as you introduce a networked registry, the time it takes to pull layers from the registry cache and push them back to the registry cache are frequently not much better than simply rebuilding the layers, not to mention the additional compute&#x2F;storage cost of running the registry cache itself.<p>It&#x27;s just a problem that requires big, local disks to solve.</div><br/></div></div></div></div><div id="39958412" class="c"><input type="checkbox" id="c-39958412" checked=""/><div class="controls bullet"><span class="by">bushbaba</span><span>|</span><a href="#39958143">parent</a><span>|</span><a href="#39958155">prev</a><span>|</span><a href="#39958652">next</a><span>|</span><label class="collapse" for="c-39958412">[-]</label><label class="expand" for="c-39958412">[1 more]</label></div><br/><div class="children"><div class="content">Can’t you use s3 + mountpoint for most distributed CI cache needs?</div><br/></div></div><div id="39958652" class="c"><input type="checkbox" id="c-39958652" checked=""/><div class="controls bullet"><span class="by">matsemann</span><span>|</span><a href="#39958143">parent</a><span>|</span><a href="#39958412">prev</a><span>|</span><a href="#39957954">next</a><span>|</span><label class="collapse" for="c-39958652">[-]</label><label class="expand" for="c-39958652">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>as soon as you have more advanced needs</i><p>If there&#x27;s one thing I&#x27;ve learned over the years, is that we really seldom have advanced needs. Mostly we just want things to work a certain way, and will fight systems to make it behave so. It&#x27;s easier to just leave it be. Like maven vs gradle; yes, gradle can do everything, but if you <i>need</i> that it&#x27;s worth taking a step back and assess why the normal maven flow won&#x27;t work. What&#x27;s so special with our app compared to the millions working just fine out of the box?</div><br/></div></div></div></div><div id="39957954" class="c"><input type="checkbox" id="c-39957954" checked=""/><div class="controls bullet"><span class="by">cpfohl</span><span>|</span><a href="#39958143">prev</a><span>|</span><a href="#39958042">next</a><span>|</span><label class="collapse" for="c-39957954">[-]</label><label class="expand" for="c-39957954">[2 more]</label></div><br/><div class="children"><div class="content">This is wild. I&#x27;ve spent the last three weeks working on this stuff for two separate clients.<p>Important note if you&#x27;re taking advice: cache-from and cache-to both accept multiple values.  Cache to just ouputs the cache data to all the ones specified. cache-from looks for cache hits in the sources in-order. You can do some clever stuff to maximize cache hits with the least amount of downloading using the right combination.</div><br/><div id="39958006" class="c"><input type="checkbox" id="c-39958006" checked=""/><div class="controls bullet"><span class="by">adityamaru</span><span>|</span><a href="#39957954">parent</a><span>|</span><a href="#39958042">next</a><span>|</span><label class="collapse" for="c-39958006">[-]</label><label class="expand" for="c-39958006">[1 more]</label></div><br/><div class="children"><div class="content">oh TIL, that is interesting</div><br/></div></div></div></div><div id="39958042" class="c"><input type="checkbox" id="c-39958042" checked=""/><div class="controls bullet"><span class="by">boronine</span><span>|</span><a href="#39957954">prev</a><span>|</span><a href="#39958985">next</a><span>|</span><label class="collapse" for="c-39958042">[-]</label><label class="expand" for="c-39958042">[14 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve spent days trying all of these solution at my company. All of these solutions suck, they are slow and only successful builds get their layers cached. This is a dead end. The only workable solution is to have a self-hosted runner with a big disk.</div><br/><div id="39958503" class="c"><input type="checkbox" id="c-39958503" checked=""/><div class="controls bullet"><span class="by">kylegalbraith</span><span>|</span><a href="#39958042">parent</a><span>|</span><a href="#39958067">next</a><span>|</span><label class="collapse" for="c-39958503">[-]</label><label class="expand" for="c-39958503">[1 more]</label></div><br/><div class="children"><div class="content">This is definitely a direction to try. But if its faster Docker image builds and a layer caching system that actually works, you should definitely try out Depot. We automatically persist layer cache to persistent NVMe devices and orchestrate that to be immediately available across builds.</div><br/></div></div><div id="39958067" class="c"><input type="checkbox" id="c-39958067" checked=""/><div class="controls bullet"><span class="by">aayushshah15</span><span>|</span><a href="#39958042">parent</a><span>|</span><a href="#39958503">prev</a><span>|</span><a href="#39958110">next</a><span>|</span><label class="collapse" for="c-39958067">[-]</label><label class="expand" for="c-39958067">[10 more]</label></div><br/><div class="children"><div class="content">how do you ensure isolation between runs on a self hosted runner that way?</div><br/><div id="39958082" class="c"><input type="checkbox" id="c-39958082" checked=""/><div class="controls bullet"><span class="by">boronine</span><span>|</span><a href="#39958042">root</a><span>|</span><a href="#39958067">parent</a><span>|</span><a href="#39958116">next</a><span>|</span><label class="collapse" for="c-39958082">[-]</label><label class="expand" for="c-39958082">[3 more]</label></div><br/><div class="children"><div class="content">What kind of isolation do you need? We are building our own code so I don&#x27;t see the need for isolation beyond a clear directory.</div><br/><div id="39958107" class="c"><input type="checkbox" id="c-39958107" checked=""/><div class="controls bullet"><span class="by">airspeedjangle</span><span>|</span><a href="#39958042">root</a><span>|</span><a href="#39958082">parent</a><span>|</span><a href="#39958116">next</a><span>|</span><label class="collapse" for="c-39958107">[-]</label><label class="expand" for="c-39958107">[2 more]</label></div><br/><div class="children"><div class="content">Shared runner infrastructure in a big company. It&#x27;s pretty common to treat these situations as multi-tenant low trust environments.</div><br/><div id="39958270" class="c"><input type="checkbox" id="c-39958270" checked=""/><div class="controls bullet"><span class="by">damianh</span><span>|</span><a href="#39958042">root</a><span>|</span><a href="#39958107">parent</a><span>|</span><a href="#39958116">next</a><span>|</span><label class="collapse" for="c-39958270">[-]</label><label class="expand" for="c-39958270">[1 more]</label></div><br/><div class="children"><div class="content">Plenty of marketplace actions will install things and&#x2F;or mutate the runner. It&#x27;s a matter of time before someone does something or there&#x27;s a build that doesn&#x27;t cleannup after itself (e.g. leaving test processes running) that ruins the day for everyone else.</div><br/></div></div></div></div></div></div><div id="39958116" class="c"><input type="checkbox" id="c-39958116" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#39958042">root</a><span>|</span><a href="#39958067">parent</a><span>|</span><a href="#39958082">prev</a><span>|</span><a href="#39958108">next</a><span>|</span><label class="collapse" for="c-39958116">[-]</label><label class="expand" for="c-39958116">[1 more]</label></div><br/><div class="children"><div class="content">If you are in k8s, you can use the default chart provided by GitHub and get 90% of the way there.</div><br/></div></div><div id="39958108" class="c"><input type="checkbox" id="c-39958108" checked=""/><div class="controls bullet"><span class="by">damianh</span><span>|</span><a href="#39958042">root</a><span>|</span><a href="#39958067">parent</a><span>|</span><a href="#39958116">prev</a><span>|</span><a href="#39958110">next</a><span>|</span><label class="collapse" for="c-39958108">[-]</label><label class="expand" for="c-39958108">[5 more]</label></div><br/><div class="children"><div class="content">Selh-hosted runners can be ephemeral too. With such either mount the cache as a disk or bake docker layers&#x2F;images into the runner image.</div><br/><div id="39958169" class="c"><input type="checkbox" id="c-39958169" checked=""/><div class="controls bullet"><span class="by">remdoWater</span><span>|</span><a href="#39958042">root</a><span>|</span><a href="#39958108">parent</a><span>|</span><a href="#39958110">next</a><span>|</span><label class="collapse" for="c-39958169">[-]</label><label class="expand" for="c-39958169">[4 more]</label></div><br/><div class="children"><div class="content">This requires a lot of work from a dev inf team, though. Not as straightforward for an average team.</div><br/><div id="39958251" class="c"><input type="checkbox" id="c-39958251" checked=""/><div class="controls bullet"><span class="by">damianh</span><span>|</span><a href="#39958042">root</a><span>|</span><a href="#39958169">parent</a><span>|</span><a href="#39958797">next</a><span>|</span><label class="collapse" for="c-39958251">[-]</label><label class="expand" for="c-39958251">[1 more]</label></div><br/><div class="children"><div class="content">I won&#x27;t disagree. It should be easier imo. I guess this is why a cottage industry has sprung up addressing such e.g. <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39930908">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39930908</a></div><br/></div></div><div id="39958797" class="c"><input type="checkbox" id="c-39958797" checked=""/><div class="controls bullet"><span class="by">ownagefool</span><span>|</span><a href="#39958042">root</a><span>|</span><a href="#39958169">parent</a><span>|</span><a href="#39958251">prev</a><span>|</span><a href="#39958284">next</a><span>|</span><label class="collapse" for="c-39958797">[-]</label><label class="expand" for="c-39958797">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s actually pretty easy.<p>Setup GitHub app.  
Install the arc helm charts.
Install a buildkitd statefulset.<p>Update parans on build to use buildkitd.<p>That&#x27;s not to say there aren&#x27;t better caching strategies, but a really basic ephemeral setup is right there.</div><br/></div></div><div id="39958284" class="c"><input type="checkbox" id="c-39958284" checked=""/><div class="controls bullet"><span class="by">boundlessdreamz</span><span>|</span><a href="#39958042">root</a><span>|</span><a href="#39958169">parent</a><span>|</span><a href="#39958797">prev</a><span>|</span><a href="#39958110">next</a><span>|</span><label class="collapse" for="c-39958284">[-]</label><label class="expand" for="c-39958284">[1 more]</label></div><br/><div class="children"><div class="content">runs-ons supports custom images - <a href="https:&#x2F;&#x2F;runs-on.com&#x2F;features&#x2F;byoi&#x2F;" rel="nofollow">https:&#x2F;&#x2F;runs-on.com&#x2F;features&#x2F;byoi&#x2F;</a> and caching to S3 - <a href="https:&#x2F;&#x2F;runs-on.com&#x2F;reference&#x2F;caching&#x2F;" rel="nofollow">https:&#x2F;&#x2F;runs-on.com&#x2F;reference&#x2F;caching&#x2F;</a><p>I haven&#x27;t used it yet but these two features make it the clear favourite for me in alternate github action runners</div><br/></div></div></div></div></div></div></div></div><div id="39958110" class="c"><input type="checkbox" id="c-39958110" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#39958042">parent</a><span>|</span><a href="#39958067">prev</a><span>|</span><a href="#39958985">next</a><span>|</span><label class="collapse" for="c-39958110">[-]</label><label class="expand" for="c-39958110">[2 more]</label></div><br/><div class="children"><div class="content">I use namespace’s action runners for this (just a customer, not affiliated in any way). They’re a company with a pretty good product stack. Although the web UI is annoyingly barebones.</div><br/><div id="39958968" class="c"><input type="checkbox" id="c-39958968" checked=""/><div class="controls bullet"><span class="by">20thr</span><span>|</span><a href="#39958042">root</a><span>|</span><a href="#39958110">parent</a><span>|</span><a href="#39958985">next</a><span>|</span><label class="collapse" for="c-39958968">[-]</label><label class="expand" for="c-39958968">[1 more]</label></div><br/><div class="children"><div class="content">Hi -- Namespace&#x27;s CEO here; if you have a chance, please drop me a note at hugo-at-namespacelabs.com; I&#x27;d love to hear what we could be doing better in the UI, and product overall. Thank you!<p>Hugo @ Namespace (<a href="https:&#x2F;&#x2F;namespace.so" rel="nofollow">https:&#x2F;&#x2F;namespace.so</a>)</div><br/></div></div></div></div></div></div><div id="39958985" class="c"><input type="checkbox" id="c-39958985" checked=""/><div class="controls bullet"><span class="by">mshekow</span><span>|</span><a href="#39958042">prev</a><span>|</span><a href="#39958573">next</a><span>|</span><label class="collapse" for="c-39958985">[-]</label><label class="expand" for="c-39958985">[1 more]</label></div><br/><div class="children"><div class="content">I took a detailed look at Docker&#x27;s caching mechanism (actually: BuildKit) in this article <a href="https:&#x2F;&#x2F;www.augmentedmind.de&#x2F;2023&#x2F;11&#x2F;19&#x2F;advanced-buildkit-caching&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.augmentedmind.de&#x2F;2023&#x2F;11&#x2F;19&#x2F;advanced-buildkit-ca...</a><p>There I also explain that IF you use a registry cache import&#x2F;export, you should use the same registry to which you are also pushing your actual image, and use the &quot;image-manifest=true&quot; option (especially if you are targeting GHCR - on DockerHub &quot;image-manifest=true&quot; would not be necessary).</div><br/></div></div><div id="39958573" class="c"><input type="checkbox" id="c-39958573" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#39958985">prev</a><span>|</span><a href="#39958764">next</a><span>|</span><label class="collapse" for="c-39958573">[-]</label><label class="expand" for="c-39958573">[1 more]</label></div><br/><div class="children"><div class="content">The trick to Docker (well OCI) images is never under any circumstance use `docker build` or anything based on it. Dockerfile is your enemy.<p>Use tools like Bazel + rules_oci or Gradle + jib and never spend time thinking about image builds taking time at all.</div><br/></div></div><div id="39958764" class="c"><input type="checkbox" id="c-39958764" checked=""/><div class="controls bullet"><span class="by">glenjamin</span><span>|</span><a href="#39958573">prev</a><span>|</span><a href="#39957980">next</a><span>|</span><label class="collapse" for="c-39958764">[-]</label><label class="expand" for="c-39958764">[1 more]</label></div><br/><div class="children"><div class="content">Docker layer caching is complicated!<p>CircleCI has an implementation that used to use a detachable disk, but that had issues with concurrency<p>It’s since been replaced with an approach that uses a docker plugin under the hood to store layers in object storage<p><a href="https:&#x2F;&#x2F;circleci.com&#x2F;docs&#x2F;docker-layer-caching&#x2F;" rel="nofollow">https:&#x2F;&#x2F;circleci.com&#x2F;docs&#x2F;docker-layer-caching&#x2F;</a></div><br/></div></div><div id="39957980" class="c"><input type="checkbox" id="c-39957980" checked=""/><div class="controls bullet"><span class="by">user-</span><span>|</span><a href="#39958764">prev</a><span>|</span><a href="#39958358">next</a><span>|</span><label class="collapse" for="c-39957980">[-]</label><label class="expand" for="c-39957980">[1 more]</label></div><br/><div class="children"><div class="content">I feel like ive seen so many new companies just providing cheaper github actions.</div><br/></div></div><div id="39958358" class="c"><input type="checkbox" id="c-39958358" checked=""/><div class="controls bullet"><span class="by">ValtteriL</span><span>|</span><a href="#39957980">prev</a><span>|</span><a href="#39958020">next</a><span>|</span><label class="collapse" for="c-39958358">[-]</label><label class="expand" for="c-39958358">[5 more]</label></div><br/><div class="children"><div class="content">Docker layer caching is one of the reasons I moved to Jenkins 2 years ago and have been very happy with it for the most part.<p>I only need to install utils once and all build time goes to building my software. It even integrates nicely with Github. Result: 50% faster feedback.<p>However, it needs a bit initial housekeeping and discipline to use correctly. For example using Jenkinsfiles is a must and using containers as agents is desirable.</div><br/><div id="39958366" class="c"><input type="checkbox" id="c-39958366" checked=""/><div class="controls bullet"><span class="by">adityamaru</span><span>|</span><a href="#39958358">parent</a><span>|</span><a href="#39958370">next</a><span>|</span><label class="collapse" for="c-39958366">[-]</label><label class="expand" for="c-39958366">[2 more]</label></div><br/><div class="children"><div class="content">do you self host your jenkins deployment in your AWS account?</div><br/><div id="39958843" class="c"><input type="checkbox" id="c-39958843" checked=""/><div class="controls bullet"><span class="by">ValtteriL</span><span>|</span><a href="#39958358">root</a><span>|</span><a href="#39958366">parent</a><span>|</span><a href="#39958370">next</a><span>|</span><label class="collapse" for="c-39958843">[-]</label><label class="expand" for="c-39958843">[1 more]</label></div><br/><div class="children"><div class="content">Self host</div><br/></div></div></div></div><div id="39958370" class="c"><input type="checkbox" id="c-39958370" checked=""/><div class="controls bullet"><span class="by">remdoWater</span><span>|</span><a href="#39958358">parent</a><span>|</span><a href="#39958366">prev</a><span>|</span><a href="#39958020">next</a><span>|</span><label class="collapse" for="c-39958370">[-]</label><label class="expand" for="c-39958370">[2 more]</label></div><br/><div class="children"><div class="content">what do you mean by discipline here?</div><br/><div id="39958928" class="c"><input type="checkbox" id="c-39958928" checked=""/><div class="controls bullet"><span class="by">ValtteriL</span><span>|</span><a href="#39958358">root</a><span>|</span><a href="#39958370">parent</a><span>|</span><a href="#39958020">next</a><span>|</span><label class="collapse" for="c-39958928">[-]</label><label class="expand" for="c-39958928">[1 more]</label></div><br/><div class="children"><div class="content">Basically using exclusively declarative pipelines with Jenkinsfiles in SCM, avoiding cluttering Jenkins with tools aside from docker, keeping Jenkins up to date and protected with proper auth.<p>Jenkins is the most flexible automation platform and its easy to do things in suboptimal ways (eg. Configuring jobs using the GUI).<p>There&#x27;s also a way to configure Jenkins the IaC way and I am hoping to dig into that at some point. The old way requires manual work that instictly feels wrong when automating everything else.</div><br/></div></div></div></div></div></div><div id="39958020" class="c"><input type="checkbox" id="c-39958020" checked=""/><div class="controls bullet"><span class="by">aayushshah15</span><span>|</span><a href="#39958358">prev</a><span>|</span><a href="#39958408">next</a><span>|</span><label class="collapse" for="c-39958020">[-]</label><label class="expand" for="c-39958020">[4 more]</label></div><br/><div class="children"><div class="content">(blacksmith co-founder here)<p>it&#x27;s unfortunate the amount of expertise &#x2F; tinkering required to get &quot;incrementalism&quot; in docker builds in github actions. we&#x27;re hoping to solve this with some of the stuff we have in the pipeline in the near future.</div><br/><div id="39958275" class="c"><input type="checkbox" id="c-39958275" checked=""/><div class="controls bullet"><span class="by">damianh</span><span>|</span><a href="#39958020">parent</a><span>|</span><a href="#39958408">next</a><span>|</span><label class="collapse" for="c-39958275">[-]</label><label class="expand" for="c-39958275">[3 more]</label></div><br/><div class="children"><div class="content">The fact that GitHub don&#x27;t provide a better solution here has to be actually costing them money with the network usage and extra agent time consumed. Right?</div><br/><div id="39958289" class="c"><input type="checkbox" id="c-39958289" checked=""/><div class="controls bullet"><span class="by">aayushshah15</span><span>|</span><a href="#39958020">root</a><span>|</span><a href="#39958275">parent</a><span>|</span><a href="#39958408">next</a><span>|</span><label class="collapse" for="c-39958289">[-]</label><label class="expand" for="c-39958289">[2 more]</label></div><br/><div class="children"><div class="content">GitHub has perverse incentives to not fix this problem because they charge customers based on usage (by the minute), so they make more money by providing slower builds to end-users.</div><br/><div id="39958506" class="c"><input type="checkbox" id="c-39958506" checked=""/><div class="controls bullet"><span class="by">krainboltgreene</span><span>|</span><a href="#39958020">root</a><span>|</span><a href="#39958289">parent</a><span>|</span><a href="#39958408">next</a><span>|</span><label class="collapse" for="c-39958506">[-]</label><label class="expand" for="c-39958506">[1 more]</label></div><br/><div class="children"><div class="content">They&#x27;ve also just completely refocused to AI in the last two years thanks to the microsoft&#x2F;ChatGPT situation.</div><br/></div></div></div></div></div></div></div></div><div id="39958408" class="c"><input type="checkbox" id="c-39958408" checked=""/><div class="controls bullet"><span class="by">tanepiper</span><span>|</span><a href="#39958020">prev</a><span>|</span><a href="#39958328">next</a><span>|</span><label class="collapse" for="c-39958408">[-]</label><label class="expand" for="c-39958408">[2 more]</label></div><br/><div class="children"><div class="content">I have this set up in our pipeline, we also build the image early and use assets to move it between jobs. We&#x27;ve also just switched to self-hosted runners, so might look into shared disk.<p>But in the long run, as annoying as it is out build pipelines reduced but quite a few minutes per build.</div><br/><div id="39958439" class="c"><input type="checkbox" id="c-39958439" checked=""/><div class="controls bullet"><span class="by">adityajp</span><span>|</span><a href="#39958408">parent</a><span>|</span><a href="#39958328">next</a><span>|</span><label class="collapse" for="c-39958439">[-]</label><label class="expand" for="c-39958439">[1 more]</label></div><br/><div class="children"><div class="content">(Co-founder of Blacksmith here)<p>Glad it worked really well for you.<p>What made you switch to self-hosted runners?</div><br/></div></div></div></div><div id="39958328" class="c"><input type="checkbox" id="c-39958328" checked=""/><div class="controls bullet"><span class="by">manx</span><span>|</span><a href="#39958408">prev</a><span>|</span><a href="#39957612">next</a><span>|</span><label class="collapse" for="c-39958328">[-]</label><label class="expand" for="c-39958328">[1 more]</label></div><br/><div class="children"><div class="content">Earthly solves this really well: <a href="https:&#x2F;&#x2F;earthly.dev" rel="nofollow">https:&#x2F;&#x2F;earthly.dev</a><p>They rethink Dockerfiles with really good caching support.</div><br/></div></div><div id="39957612" class="c"><input type="checkbox" id="c-39957612" checked=""/><div class="controls bullet"><span class="by">notnmeyer</span><span>|</span><a href="#39958328">prev</a><span>|</span><a href="#39958400">next</a><span>|</span><label class="collapse" for="c-39957612">[-]</label><label class="expand" for="c-39957612">[3 more]</label></div><br/><div class="children"><div class="content">this is pretty neat—it’s been a while since i’ve tried caching layers with gha. it used to be quite frustrating.<p>my previous experience was that in nearly all situations the time spent sending and retrieving cache layers over the network wound up making a shorter build step moot. ultimately we said “fuck it” and focused on making builds faster without (docker layer) caching.</div><br/><div id="39958679" class="c"><input type="checkbox" id="c-39958679" checked=""/><div class="controls bullet"><span class="by">kylegalbraith</span><span>|</span><a href="#39957612">parent</a><span>|</span><a href="#39957887">next</a><span>|</span><label class="collapse" for="c-39958679">[-]</label><label class="expand" for="c-39958679">[1 more]</label></div><br/><div class="children"><div class="content">Yup! We observed the same thing back before we built Depot. The act of saving&#x2F;loading cache over a GHA network pretty much negated any performance gain from layer caching. So, we created a solution to persist cache to NVMe disks and orchestrate that across builds so it&#x27;s immediately available on the next build. All the performance of layer caching without any network transfer.<p>The registry cache idea is a neat idea, but in practice suffers the same problem.</div><br/></div></div><div id="39957887" class="c"><input type="checkbox" id="c-39957887" checked=""/><div class="controls bullet"><span class="by">adityamaru</span><span>|</span><a href="#39957612">parent</a><span>|</span><a href="#39958679">prev</a><span>|</span><a href="#39958400">next</a><span>|</span><label class="collapse" for="c-39957887">[-]</label><label class="expand" for="c-39957887">[1 more]</label></div><br/><div class="children"><div class="content">Yeah that still holds true to some extent today with the GHA cache. Blacksmith colocates its cache with our CI runners, and ensures that they&#x27;re in the same local network allowing us to saturate the NIC and provide much faster cache reads&#x2F;writes. We&#x27;re also thinking of clever ways to avoid downloading from a cache entirely and instead bind mount cache volumes over the network into the CI runner. Still early days, but stay tuned!</div><br/></div></div></div></div><div id="39958400" class="c"><input type="checkbox" id="c-39958400" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#39957612">prev</a><span>|</span><a href="#39957753">next</a><span>|</span><label class="collapse" for="c-39958400">[-]</label><label class="expand" for="c-39958400">[2 more]</label></div><br/><div class="children"><div class="content">No!<p>So much time spent debunking such broken &quot;caching&quot; solutions.<p>Computers are very fast now. Use proper package&#x2F;versioning systems (part of the problem here is that those are often also broken&#x2F;badly designed).</div><br/><div id="39958423" class="c"><input type="checkbox" id="c-39958423" checked=""/><div class="controls bullet"><span class="by">aayushshah15</span><span>|</span><a href="#39958400">parent</a><span>|</span><a href="#39957753">next</a><span>|</span><label class="collapse" for="c-39958423">[-]</label><label class="expand" for="c-39958423">[1 more]</label></div><br/><div class="children"><div class="content">This is simply false. For starters, GitHub actions by default run on Intel Haswell chips from 2014 (in some cases). Secondly, hardware being faster doesn&#x27;t obviate the need for caching, especially for docker builds where your layer pulls are purely network bound.</div><br/></div></div></div></div><div id="39957753" class="c"><input type="checkbox" id="c-39957753" checked=""/><div class="controls bullet"><span class="by">maxmcd</span><span>|</span><a href="#39958400">prev</a><span>|</span><a href="#39958033">next</a><span>|</span><label class="collapse" for="c-39957753">[-]</label><label class="expand" for="c-39957753">[7 more]</label></div><br/><div class="children"><div class="content">I weep for this period of time where we don&#x27;t have sticky disks readily available for builds. Uploading the layer cache each time is such a coarse and time-consuming way to cache things.<p>Maybe building from scratch all the time is a good correctness decision? Maybe stale values in disks is a tricky enough issue to want to avoid entirely?<p>If you keep a stack of disks around and grab a free one when the job starts you&#x27;d end up with good speedup a lot of the time. If cost is an issue you can expire them quickly. I regularly see CI jobs spending &gt;50% of their time downloading the same things, or compiling the same things, over and over. How many times have I triggered an action that compiled the exact same sqlite source code? Tens of thousands?<p>Maybe this is fine, I dunno.</div><br/><div id="39958157" class="c"><input type="checkbox" id="c-39958157" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#39957753">parent</a><span>|</span><a href="#39958669">next</a><span>|</span><label class="collapse" for="c-39958157">[-]</label><label class="expand" for="c-39958157">[1 more]</label></div><br/><div class="children"><div class="content">Interesting.<p>I remember working on a project where the first clean build would always fail, and only incremental builds could succeed. I was a junior at the time, so this was 15-20 years ago. I remember spending some time trying to get it to succeed from a clean build and my lead pulling me aside: he said it was an easy fix, but if we fixed it, the ops guys would insist on building from scratch for every build. So please, stop.<p>Personally, unless you have an exotic build env, it’s usually faster and easier to simply build in the runner. If you need a docker image at the end, build a dockerfile that simply copies the artifacts from disk.</div><br/></div></div><div id="39958669" class="c"><input type="checkbox" id="c-39958669" checked=""/><div class="controls bullet"><span class="by">kylegalbraith</span><span>|</span><a href="#39957753">parent</a><span>|</span><a href="#39958157">prev</a><span>|</span><a href="#39957854">next</a><span>|</span><label class="collapse" for="c-39958669">[-]</label><label class="expand" for="c-39958669">[1 more]</label></div><br/><div class="children"><div class="content">Couldn&#x27;t agree more. Somewhere, we lost the concept of disks in CI unless you run it yourself, and a lot of build tools could benefit from having them.<p>We came to the same conclusion and built Depot around this exact workflow for the Docker image build problem. We&#x27;re now bringing that same tech into GitHub Actions workflows.</div><br/></div></div><div id="39957854" class="c"><input type="checkbox" id="c-39957854" checked=""/><div class="controls bullet"><span class="by">adityamaru</span><span>|</span><a href="#39957753">parent</a><span>|</span><a href="#39958669">prev</a><span>|</span><a href="#39957774">next</a><span>|</span><label class="collapse" for="c-39957854">[-]</label><label class="expand" for="c-39957854">[1 more]</label></div><br/><div class="children"><div class="content">This is exactly the sort of insight that led us to work on Blacksmith. Since we own the hardware we run CI jobs on there are some exciting things we can do to make these &quot;sticky disks&quot; work the way you describe it. Stay tuned!</div><br/></div></div><div id="39957774" class="c"><input type="checkbox" id="c-39957774" checked=""/><div class="controls bullet"><span class="by">parentheses</span><span>|</span><a href="#39957753">parent</a><span>|</span><a href="#39957854">prev</a><span>|</span><a href="#39958396">next</a><span>|</span><label class="collapse" for="c-39957774">[-]</label><label class="expand" for="c-39957774">[1 more]</label></div><br/><div class="children"><div class="content">I agree. The notion that everything must be docker is nice in principle but requires a lot of performance optimization work early on. Earlier than one would need with &quot;sticky disks&quot; as you called them.</div><br/></div></div><div id="39958396" class="c"><input type="checkbox" id="c-39958396" checked=""/><div class="controls bullet"><span class="by">aayushshah15</span><span>|</span><a href="#39957753">parent</a><span>|</span><a href="#39957774">prev</a><span>|</span><a href="#39957864">next</a><span>|</span><label class="collapse" for="c-39958396">[-]</label><label class="expand" for="c-39958396">[1 more]</label></div><br/><div class="children"><div class="content">A subtle challenge with &quot;sticky disks&quot; is that it requires your workflow steps to be idempotent beyond the point of &quot;resumption&quot;, which can be tricky in a lot of cases.</div><br/></div></div></div></div><div id="39958033" class="c"><input type="checkbox" id="c-39958033" checked=""/><div class="controls bullet"><span class="by">remdoWater</span><span>|</span><a href="#39957753">prev</a><span>|</span><label class="collapse" for="c-39958033">[-]</label><label class="expand" for="c-39958033">[1 more]</label></div><br/><div class="children"><div class="content">title suggestion: Cache Rules Everything Around Me (C.R.E.A.M.)</div><br/></div></div></div></div></div></div></div></body></html>