<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1708419661424" as="style"/><link rel="stylesheet" href="styles.css?v=1708419661424"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://arxiv.org/abs/2102.11245">Silent data corruptions at scale (2021)</a> <span class="domain">(<a href="https://arxiv.org">arxiv.org</a>)</span></div><div class="subtext"><span>losfair</span> | <span>19 comments</span></div><br/><div><div id="39437919" class="c"><input type="checkbox" id="c-39437919" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#39438348">next</a><span>|</span><label class="collapse" for="c-39437919">[-]</label><label class="expand" for="c-39437919">[2 more]</label></div><br/><div class="children"><div class="content">Very interesting topic, but rather low on detail --- really wanted to see what those 60 lines of Asm that allegedly show a faulty CPU instruction were, and also surprised that it wasn&#x27;t intermittent; in my experience, CPU problems usually are intermittent and heavily dependent upon prior state, and manually stepping through with a debugger has never shown the &quot;1+1=3&quot; type of situation they claim. That said, I wonder if LINPACK&#x27;ing would&#x27;ve found it, as that is known to be a very powerful stress-test with divisive opinions among the overclocking community; some, including me, claim that a system can never be considered stable it if fails LINPACK since that is essentially showing intermittent &quot;1+1=3&quot; behaviour, while others are fine with &quot;occasional&quot; discrepancies in its output since the system otherwise appears to be stable.</div><br/><div id="39438531" class="c"><input type="checkbox" id="c-39438531" checked=""/><div class="controls bullet"><span class="by">jorticka</span><span>|</span><a href="#39437919">parent</a><span>|</span><a href="#39438348">next</a><span>|</span><label class="collapse" for="c-39438531">[-]</label><label class="expand" for="c-39438531">[1 more]</label></div><br/><div class="children"><div class="content">Like all stress tests, linpack will find some errors, but not all.<p>I had memory stability issues which would immediatly show under Prime95 (less than 1 minute) but pass hours of Linpack.</div><br/></div></div></div></div><div id="39438348" class="c"><input type="checkbox" id="c-39438348" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#39437919">prev</a><span>|</span><a href="#39438991">next</a><span>|</span><label class="collapse" for="c-39438348">[-]</label><label class="expand" for="c-39438348">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>Meta quickly detects silent data corruptions at scale</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30905636">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30905636</a> - April 2022 (95 comments)<p><i>Silent Data Corruptions at Scale</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27484866">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27484866</a> - June 2021 (12 comments)</div><br/></div></div><div id="39438991" class="c"><input type="checkbox" id="c-39438991" checked=""/><div class="controls bullet"><span class="by">twhitmore</span><span>|</span><a href="#39438348">prev</a><span>|</span><a href="#39438287">next</a><span>|</span><label class="collapse" for="c-39438991">[-]</label><label class="expand" for="c-39438991">[1 more]</label></div><br/><div class="children"><div class="content">Interesting. The corruption was in a math.pow() calculation, representing a compressed filesize prior to a file decompression step.<p>Compressing data, with the increased information density &amp; greater number of CPU instructions involved, seems obviously to increase the exposure to corruption&#x2F; bitflips.<p>What I did wonder was why compress the filesize as an exponent? One would imagine that representing as a floating-point exponent would take lots of cycles, pretty much as many bits, and have nasty precision inaccuracies at larger sizes.</div><br/></div></div><div id="39438287" class="c"><input type="checkbox" id="c-39438287" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39438991">prev</a><span>|</span><a href="#39437981">next</a><span>|</span><label class="collapse" for="c-39438287">[-]</label><label class="expand" for="c-39438287">[2 more]</label></div><br/><div class="children"><div class="content">Google also had a &quot;Cores That Don&#x27;t Count&quot; paper on so-called &quot;mercurial cores&quot; <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27378624">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27378624</a>
as well as a presentation <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=QMF3rqhjYuM" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=QMF3rqhjYuM</a></div><br/></div></div><div id="39437981" class="c"><input type="checkbox" id="c-39437981" checked=""/><div class="controls bullet"><span class="by">opisthenar84</span><span>|</span><a href="#39438287">prev</a><span>|</span><a href="#39437884">next</a><span>|</span><label class="collapse" for="c-39437981">[-]</label><label class="expand" for="c-39437981">[10 more]</label></div><br/><div class="children"><div class="content">Might be a noob question but for truly important data, couldn&#x27;t SDCs be detected by using ECC everywhere?</div><br/><div id="39438732" class="c"><input type="checkbox" id="c-39438732" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#39437981">parent</a><span>|</span><a href="#39438945">next</a><span>|</span><label class="collapse" for="c-39438732">[-]</label><label class="expand" for="c-39438732">[1 more]</label></div><br/><div class="children"><div class="content">ECC isn’t free and ECC has a limited ability to detect all statistically plausible errors. Additionally, error correction in hardware is frequently defined by standards, some of which have backward compatibility requirements that go back decades. This is why, for example, reliable software often uses (quasi-)cryptographic checksums at all I&#x2F;O boundaries. There is error correction in the hardware but in some parts of the silicon that error correction is weak enough that it is likely to eventually deliver a false negative in large scale systems.<p>None of this is free, and there are both hardware and software solutions for mitigating various categories of risk. It is explicitly modeled as an economics problem i.e. how does the cost of not mitigating a risk, if it materializes, compare to the cost of minimizing or eliminating it. In many cases, the optimal solution is unintuitive, such as computing everything twice or thrice and comparing the results rather than using error correction.</div><br/></div></div><div id="39438945" class="c"><input type="checkbox" id="c-39438945" checked=""/><div class="controls bullet"><span class="by">lobochrome</span><span>|</span><a href="#39437981">parent</a><span>|</span><a href="#39438732">prev</a><span>|</span><a href="#39438446">next</a><span>|</span><label class="collapse" for="c-39438945">[-]</label><label class="expand" for="c-39438945">[1 more]</label></div><br/><div class="children"><div class="content">In those cases, the CPU makes a false calculation independent of what&#x27;s done in RAM. It can be solved by having flop redundancy as in system z - but nobody at Google or Meta would be considering big metal.<p>From my point of view, this technology problem may be interesting academically (and good for pretending to be important in the hierarchy at those companies) but a non-issue at scale business-wise in modern data centers.<p>Have a blade that once in a while acts funny? Trash and replace. Who cares what particular hiccup the CPU had.</div><br/></div></div><div id="39438446" class="c"><input type="checkbox" id="c-39438446" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#39437981">parent</a><span>|</span><a href="#39438945">prev</a><span>|</span><a href="#39437884">next</a><span>|</span><label class="collapse" for="c-39438446">[-]</label><label class="expand" for="c-39438446">[7 more]</label></div><br/><div class="children"><div class="content">There are errors within the CPU.<p>As for adding ECC within the CPU, I think that would require you to essentially have a second CPU in parallel to compare against.</div><br/><div id="39438567" class="c"><input type="checkbox" id="c-39438567" checked=""/><div class="controls bullet"><span class="by">MertsA</span><span>|</span><a href="#39437981">root</a><span>|</span><a href="#39438446">parent</a><span>|</span><a href="#39438485">next</a><span>|</span><label class="collapse" for="c-39438567">[-]</label><label class="expand" for="c-39438567">[1 more]</label></div><br/><div class="children"><div class="content">Actually it&#x27;s not uncommon for there to be ECC used within components as a method to guard against stuff like this. I don&#x27;t think it&#x27;s practical to ever have complete coverage without going full blown dual&#x2F;triple redundant CPU but for stuff like SSD controllers they have ECC coverage internally on the data path.</div><br/></div></div><div id="39438485" class="c"><input type="checkbox" id="c-39438485" checked=""/><div class="controls bullet"><span class="by">XorNot</span><span>|</span><a href="#39437981">root</a><span>|</span><a href="#39438446">parent</a><span>|</span><a href="#39438567">prev</a><span>|</span><a href="#39437884">next</a><span>|</span><label class="collapse" for="c-39438485">[-]</label><label class="expand" for="c-39438485">[5 more]</label></div><br/><div class="children"><div class="content">You actually need 3 - which is how it&#x27;s done for space (I believe SpaceX uses this as a solution to avoiding radiation hardened costs).<p>2 will tell you if they diverge, but you lose both if they do. 3 let&#x27;s you retain 2 in operation if one does diverge.</div><br/><div id="39438525" class="c"><input type="checkbox" id="c-39438525" checked=""/><div class="controls bullet"><span class="by">jorticka</span><span>|</span><a href="#39437981">root</a><span>|</span><a href="#39438485">parent</a><span>|</span><a href="#39437884">next</a><span>|</span><label class="collapse" for="c-39438525">[-]</label><label class="expand" for="c-39438525">[4 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re not hard realtime 2 is enough, you just redo the computation.</div><br/><div id="39438598" class="c"><input type="checkbox" id="c-39438598" checked=""/><div class="controls bullet"><span class="by">MertsA</span><span>|</span><a href="#39437981">root</a><span>|</span><a href="#39438525">parent</a><span>|</span><a href="#39437884">next</a><span>|</span><label class="collapse" for="c-39438598">[-]</label><label class="expand" for="c-39438598">[3 more]</label></div><br/><div class="children"><div class="content">But if it&#x27;s a consistent fault, like the silent data corruption covered in the linked paper, redoing the computation is still going to end up with no way to identify which core is faulty. If it&#x27;s an intermittent fault, then even for hard realtime you can accomplish that with one core, just compute 3x and go with majority result.</div><br/><div id="39438662" class="c"><input type="checkbox" id="c-39438662" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#39437981">root</a><span>|</span><a href="#39438598">parent</a><span>|</span><a href="#39438859">next</a><span>|</span><label class="collapse" for="c-39438662">[-]</label><label class="expand" for="c-39438662">[1 more]</label></div><br/><div class="children"><div class="content">Yup exactly. The only way independent hardware can help is if the fault is state dependent in a way on the hardware (eg differences in behavior due to thermal load or different internal state corruption or something) in which case repeated computations may not help if the repeated computation is not sufficiently decoupled temporally to get rid of that state. The other thing with independent hardware is that you don’t pay a 3x performance penalty (instead 3x cost penalty). That being said, none of these fault modes are what are really what is being discussed in the paper.<p>The other one that freaks me out is miscompilation by the compiler and JITs in the data path of an application. Like we’re using these machines to process hundreds of millions of transactions and trillions of dollars - how much are these silent mistakes costing us?</div><br/></div></div><div id="39438859" class="c"><input type="checkbox" id="c-39438859" checked=""/><div class="controls bullet"><span class="by">jorticka</span><span>|</span><a href="#39437981">root</a><span>|</span><a href="#39438598">parent</a><span>|</span><a href="#39438662">prev</a><span>|</span><a href="#39437884">next</a><span>|</span><label class="collapse" for="c-39438859">[-]</label><label class="expand" for="c-39438859">[1 more]</label></div><br/><div class="children"><div class="content">If it&#x27;s consistent and persistent, wouldn&#x27;t that classify as broken hardware requiring device change?<p>Even with 3 chips, if one is permanently wrong you are then left with only 2 working ones so no redundancy is left for further degradation.<p>&gt; just compute 3x<p>That might be difficult if CPU is broken. How are you sure you actually computed 3 times if you can&#x27;t trust the logic.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39437884" class="c"><input type="checkbox" id="c-39437884" checked=""/><div class="controls bullet"><span class="by">ekelsen</span><span>|</span><a href="#39437981">prev</a><span>|</span><label class="collapse" for="c-39437884">[-]</label><label class="expand" for="c-39437884">[2 more]</label></div><br/><div class="children"><div class="content">I wrote an article about these affecting LLM training at <a href="https:&#x2F;&#x2F;www.adept.ai&#x2F;blog&#x2F;sherlock-sdc" rel="nofollow">https:&#x2F;&#x2F;www.adept.ai&#x2F;blog&#x2F;sherlock-sdc</a></div><br/><div id="39438436" class="c"><input type="checkbox" id="c-39438436" checked=""/><div class="controls bullet"><span class="by">walterbell</span><span>|</span><a href="#39437884">parent</a><span>|</span><label class="collapse" for="c-39438436">[-]</label><label class="expand" for="c-39438436">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, does your blog have a working RSS feed?</div><br/></div></div></div></div></div></div></div></div></div></body></html>